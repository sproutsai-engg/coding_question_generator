[
    {
        "title": "Longest Palindromic Substring",
        "description": "Given a string `s`, find and return the longest palindromic substring in `s`. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward. If there are multiple longest palindromic substrings, return any one of them.",
        "example": "Example 1:\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\nExample 2:\n\nInput: s = \"cbbd\"\nOutput: \"bb\"",
        "level": "Medium",
        "tags": [
            "String",
            "Dynamic Programming"
        ],
        "test_cases": {
            "inputs": [
                "\"babad\"",
                "\"cbbd\"",
                "\"a\"",
                "\"ac\"",
                "\"bb\"",
                "\"racecar\"",
                "\"abcdeedcba\"",
                "\"abcdefedcba\"",
                "\"abcdeedcbafg\"",
                "\"abcdefedcbagf\"",
                "\"abacdfgdcaba\"",
                "\"abacdfgdcabba\"",
                "\"abacdfgdcabbaa\"",
                "\"abacdfgdcabbaaa\"",
                "\"abacdfgdcabbaaaa\"",
                "\"abacdfgdcabbaaaaa\"",
                "\"abacdfgdcabbaaaaaa\"",
                "\"abacdfgdcabbaaaaaaa\"",
                "\"abacdfgdcabbaaaaaaaa\"",
                "\"abacdfgdcabbaaaaaaaaa\"",
                "\"abacdfgdcabbaaaaaaaaaa\""
            ],
            "outputs": [
                "\"bab\"",
                "\"bb\"",
                "\"a\"",
                "\"a\"",
                "\"bb\"",
                "\"racecar\"",
                "\"abcdeedcba\"",
                "\"abcdefedcba\"",
                "\"abcdeedcba\"",
                "\"abcdefedcba\"",
                "\"aba\"",
                "\"abba\"",
                "\"abba\"",
                "\"abba\"",
                "\"abba\"",
                "\"abba\"",
                "\"abba\"",
                "\"abba\"",
                "\"abba\"",
                "\"abba\"",
                "\"abba\""
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n\nstd::string longestPalindromicSubstring(std::string s) {\n  int n = s.size();\n  if (n == 0) return \"\";\n  int start = 0, maxLength = 1;\n\n  for (int i = 0; i < n; ++i) {\n    int l = i, r = i;\n\n    while (r < n - 1 && s[r] == s[r + 1])\n      r++;\n    i = r;\n\n    while (l > 0 && r < n - 1 && s[l - 1] == s[r + 1]) {\n      l--;\n      r++;\n    }\n\n    int length = r - l + 1;\n    if (length > maxLength) {\n      start = l;\n      maxLength = length;\n    }\n  }\n\n  return s.substr(start, maxLength);\n}\n",
            "java": "public static String longestPalindromicSubstring(String s) {\n    int n = s.length();\n    if (n == 0) return \"\";\n\n    int start = 0, maxLength = 1;\n\n    for (int i = 0; i < n; ++i) {\n        int l = i, r = i;\n\n        while (r < n - 1 && s.charAt(r) == s.charAt(r + 1))\n            r++;\n        i = r;\n\n        while (l > 0 && r < n - 1 && s.charAt(l - 1) == s.charAt(r + 1)) {\n            l--;\n            r++;\n        }\n\n        int length = r - l + 1;\n        if (length > maxLength) {\n            start = l;\n            maxLength = length;\n        }\n    }\n\n    return s.substring(start, start + maxLength);\n}\n",
            "python": "def longest_palindromic_substring(s: str) -> str:\n    n = len(s)\n    if n == 0: return \"\"\n\n    start, max_length = 0, 1\n\n    for i in range(n):\n        l, r = i, i\n\n        while r < n - 1 and s[r] == s[r + 1]:\n            r += 1\n        i = r\n\n        while l > 0 and r < n - 1 and s[l - 1] == s[r + 1]:\n            l -= 1\n            r += 1\n\n        length = r - l + 1\n        if length > max_length:\n            start, max_length = l, length\n\n    return s[start:start + max_length]\n",
            "javascript": "function longestPalindromicSubstring(s) {\n  let n = s.length;\n  if (n === 0) return \"\";\n\n  let start = 0, maxLength = 1;\n\n  for (let i = 0; i < n; ++i) {\n    let l = i, r = i;\n\n    while (r < n - 1 && s[r] === s[r + 1])\n      r++;\n    i = r;\n\n    while (l > 0 && r < n - 1 && s[l - 1] === s[r + 1]) {\n      l--;\n      r++;\n    }\n\n    let length = r - l + 1;\n    if (length > maxLength) {\n      start = l;\n      maxLength = length;\n    }\n  }\n\n  return s.substring(start, start + maxLength);\n}\n",
            "explanation": "1. Initialize `start` and `maxLength` for result substring.\n2. Iterate through the given string `s` using the index `i`.\n3. For each index `i`, create two pointers `l` and `r` starting at `i`.\n4. Check if there's a consecutive sequence of identical characters, increment the right pointer `r` until the end of the sequence is reached.\n5. Update the index `i` to the current value of `r`.\n6. Expand the pointers `l` and `r` outwards to find the longest palindromic substring, checking that characters on both sides are equal.\n7. If the current length of the substring is greater than `maxLength`, update `start` and `maxLength`.\n8. Return the longest palindromic substring using the `start` and `maxLength`."
        },
        "structure": {
            "c++": "#include <string>\n\nstd::string longestPalindromicSubstring(std::string s) \n    // Your code here\n}\n",
            "java": "public static String longestPalindromicSubstring(String s) {\n    // Your code here\n}\n",
            "python": "def longest_palindromic_substring(s: str) -> str:\n    # Your code here\n\n",
            "javascript": "function longestPalindromicSubstring(s) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <string>\n\nstd::string longestPalindromicSubstring(std::string s);\n\nint main() {\n    std::string input = $args;\n    std::string result = longestPalindromicSubstring(input);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    String input = $args;\n    String result  = longestPalindromicSubstring(input);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = longest_palindromic_substring(s)\n    print(result)",
            "javascript": "function main() {\n  const s = $args;\n  const result = longestPalindromicSubstring(s);\n  console.log(result);\n}"
        },
        "Qid": "5",
        "languages verified": "all"
    },
    {
        "title": "Palindrome Integer",
        "description": "Given an integer `x`, determine if it is a palindrome. Return `true` if `x` is a palindrome, and `false` otherwise.",
        "example": "Example 1:\n\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.",
        "level": "Easy",
        "tags": [
            "math"
        ],
        "test_cases": {
            "inputs": [
                121,
                -121,
                10,
                12321,
                1234321,
                123454321,
                {
                    "$numberLong": "12345654321"
                },
                {
                    "$numberLong": "123456654321"
                }
            ],
            "outputs": [
                true,
                false,
                false,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "bool isPalindrome(int x) {\n    if (x < 0) return false;\n    int original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x /= 10;\n    }\n    return original == reversed;\n}\n\n",
            "java": "public static boolean isPalindrome(int x) {\n    if (x < 0) return false;\n    int original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x /= 10;\n    }\n    return original == reversed;\n}\n\n",
            "python": "def is_palindrome(x: int) -> bool:\n    if x < 0:\n        return False\n    original, reversed = x, 0\n    while x > 0:\n        reversed = reversed * 10 + x % 10\n        x //= 10\n    return original == reversed\n\n",
            "javascript": "function isPalindrome(x) {\n    if (x < 0) return false;\n    let original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x = Math.floor(x / 10);\n    }\n    return original === reversed;\n}\n\n",
            "explanation": "Here is the algorithm:\n\n1. If the integer is negative, immediately return false, as negative numbers cannot be palindromes.\n2. Create a variable named `original` to store the original integer value and `reversed` initialized with 0 to store the reversed integer value.\n3. Iterate through the integer while it's greater than zero and, in each iteration, perform the following operations:\n   a. Multiply the `reversed` value by 10 and add the modulus of the integer (x) by 10.\n   b. Divide the integer (x) by 10, discarding the remainder.\n4. Compare `original` and `reversed` integers; if they are equal, return true; otherwise, return false.\n\nThis approach requires O(log10(n)) time complexity as we are dividing the input by 10 in each iteration."
        },
        "structure": {
            "c++": "bool isPalindrome(int x) \n    // Your code here\n}\n\n",
            "java": "public static boolean isPalindrome(int x) {\n    // Your code here\n}\n\n",
            "python": "def is_palindrome(x: int) -> bool:\n    # Your code here\n\n",
            "javascript": "function isPalindrome(x) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n =121;\n    bool result = isPalindrome(n);\n    cout << boolalpha << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    int x = $args;\n    boolean result = isPalindrome(x);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    x = $args\n    result = is_palindrome(x)\n    print(result)\n",
            "javascript": "function main() {\n    const x = $args;\n    const result = isPalindrome(x);\n    console.log(result);\n}\n"
        },
        "Qid": "9",
        "languages verified": "all"
    },
    {
        "title": "String to Integer (atoi)",
        "description": "Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).\n\nThe algorithm for `myAtoi(string s)` is as follows:\n\n1. Read in and ignore any leading whitespace.\n2. Check if the next character (if not already at the end of the string) is \"-\" or \"+\". Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n3. Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n4. Convert these digits into an integer (i.e. \"123 \" -> 123, \"0032 \" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\n5. If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\n6. Return the integer as the final result.\n\n**Note:**\n\n- Only the space character \" \" is considered a whitespace character.\n- **Do not ignore** any characters other than the leading whitespace or the rest of the string after the digits.",
        "example": "Example 1:\n\nInput: s = \"42 \"\nOutput: 42\nExplanation: The underlined characters are what is read in, the caret is the current reader position.\nStep 1: \"42 \" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42 \" (no characters read because there is neither a \"-\" nor \"+\")\n         ^\nStep 3: \"42 \" (\"42\" is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range [-231, 231 - 1], the final result is 42.\n\nExample 2:\n\nInput: s = \"   -42 \"\nOutput: -42\nExplanation: Step 1: \"   -42 \" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   -42 \" (\"-\" is read, so the result should be negative)\n             ^\nStep 3: \"   -42 \" (\"42\" is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range [-231, 231 - 1], the final result is -42.\n\nExample 3:\n\nInput: s = \"4193 with words \"\nOutput: 4193\nExplanation: Step 1: \"4193 with words \" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"4193 with words \" (no characters read because there is neither a \"-\" nor \"+\")\n         ^\nStep 3: \"4193 with words \" (\"4193\" is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\nSince 4193 is in the range [-231, 231 - 1], the final result is 4193.",
        "level": "Medium",
        "tags": [
            "string",
            "parsing",
            "integer"
        ],
        "test_cases": {
            "inputs": [
                "\"42 \"",
                "\"   -42 \"",
                "\"4193 with words \"",
                "\"words and 987\"",
                "\"-91283472332\"",
                "\"3.14159\"",
                "\"-3.14159\"",
                "\"-1234567890123456789012345678901234567890\"",
                "\"1234567890123456789012345678901234567890\"",
                "\"\"",
                "\"0\"",
                "\"-\"",
                "\"+\"",
                "\"-0\"",
                "\"+0\"",
                "\"-123\"",
                "\"+123\"",
                "\"-000123\"",
                "\"+000123\"",
                "\"-000\"",
                "\"+000\""
            ],
            "outputs": [
                "42",
                "-42",
                "4193",
                "0",
                "-2147483648",
                "3",
                "-3",
                "-2147483648",
                "2147483647",
                "0",
                "0",
                "0",
                "0",
                "0",
                "-123",
                "123",
                "-123",
                "123",
                "0",
                "0"
            ]
        },
        "sample_code": {
            "c++": "#include <iostream>\n#include <string>\n#include <climits> // for INT_MAX and INT_MIN\nusing namespace std;\n\nint myAtoi(string s) {\n    long result = 0;\n    int i = 0, sign = 1;\n    while (i < s.length() && s[i] == ' ') i++; // Fixing boundary check\n    if (i < s.length() && (s[i] == '-' || s[i] == '+')) sign = (s[i++] == '+') ? 1 : -1; // Fixing boundary check\n    while (i < s.length() && isdigit(s[i])) { // Fixing boundary check\n        result = result * 10 + (s[i++] - '0');\n        if (result * sign > INT_MAX) return INT_MAX;\n        if (result * sign < INT_MIN) return INT_MIN;\n    }\n    return result * sign;\n}",
            "java": "public static int myAtoi(String s) {\n    long result = 0;\n    int i = 0, sign = 1;\n    while (i < s.length() && s.charAt(i) == ' ') i++;\n    if (i < s.length() && (s.charAt(i) == '-' || s.charAt(i) == '+')) {\n        sign = (s.charAt(i++) == '+') ? 1 : -1;\n    }\n    while (i < s.length() && Character.isDigit(s.charAt(i))) {\n        result = result * 10 + (s.charAt(i++) - '0');\n        if (result * sign > Integer.MAX_VALUE) return Integer.MAX_VALUE;\n        if (result * sign < Integer.MIN_VALUE) return Integer.MIN_VALUE;\n    }\n    return (int) (result * sign);\n}\n",
            "python": "def myAtoi(s):\n    result, i, sign = 0, 0, 1\n    while i < len(s) and s[i] == ' ': i += 1\n    if i < len(s) and (s[i] == '-' or s[i] == '+'):\n        sign = -1 if s[i] == '-' else 1\n        i += 1\n    while i < len(s) and s[i].isdigit():\n        result = result * 10 + int(s[i])\n        i += 1\n        if result * sign > 2**31 - 1: return 2**31 - 1\n        if result * sign < -2**31: return -2**31\n    return result * sign\n",
            "javascript": "function myAtoi(s) {\n    let result = 0, i = 0, sign = 1;\n    while (s[i] === ' ') i++;\n    if (s[i] === '-' || s[i] === '+') sign = (s[i++] === '+') ? 1 : -1;\n    while (!isNaN(s[i]) && s[i] !== ' ') {\n        result = result * 10 + parseInt(s[i++], 10);\n        if (result * sign > 2147483647) return 2147483647;\n        if (result * sign < -2147483648) return -2147483648;\n    }\n    return result * sign;\n}\n",
            "explanation": "1. Initialize `result` as 0, index `i` as 0, and `sign` as 1 (positive).\n2. Loop through the string until a non-space character is found or the end of the string is reached.\n3. If the current character is '+' or '-', update the `sign` according to the character and increment the index `i`.\n4. If a digit is found, multiply the previous `result` by 10 and add the digit to it. Increment the index `i`.\n5. Check if the result multiplied by the sign is out of the 32-bit signed integer range. If so, return the appropriate boundary value.\n6. When no more digits are found, return the final result multiplied by the sign."
        },
        "structure": {
            "c++": "#include <iostream>\n#include <string>\n#include <climits> // for INT_MAX and INT_MIN\nusing namespace std;\n\nint myAtoi(string s) {\n    // Your code here\n}\n",
            "java": "public static int myAtoi(String s){ \n    // Your code here\n}\n",
            "python": "def myAtoi(s):\n    # Your code here\n\n",
            "javascript": "function myAtoi(s) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    string s =$args;\n    int result = myAtoi(s);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args){\n    String input = $args;\n    int result = myAtoi(input);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = myAtoi(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = myAtoi(s);\n    console.log(result);\n}"
        },
        "Qid": "8",
        "languages verified": "all"
    },
    {
        "title": "Convert Integer to Roman Numeral",
        "description": "Given an integer, convert it to a Roman numeral. Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D`, and `M`. The symbols and their corresponding values are as follows:\n\n`I` - 1\n`V` - 5\n`X` - 10\n`L` - 50\n`C` - 100\n`D` - 500\n`M` - 1000\n\nRoman numerals are usually written largest to smallest from left to right. However, there are six instances where subtraction is used. For example, `IV` represents 4, `IX` represents 9, `XL` represents 40, `XC` represents 90, `CD` represents 400, and `CM` represents 900.\n\nWrite a function `convertToRoman` that takes an integer `num` as input and returns its Roman numeral representation as a string.",
        "example": "Example:\n\nInput:\nnum = 3\n\nOutput:\n\"III\"\n\nExplanation:\n3 is represented as 3 ones.\n\nInput:\nnum = 58\n\nOutput:\n\"LVIII\"\n\nExplanation:\nL = 50, V = 5, III = 3.\n\nInput:\nnum = 1994\n\nOutput:\n\"MCMXCIV\"\n\nExplanation:\nM = 1000, CM = 900, XC = 90, and IV = 4.",
        "level": "Medium",
        "tags": [
            "Math",
            "String"
        ],
        "test_cases": {
            "inputs": [
                3,
                58,
                1994,
                4,
                9,
                40,
                90,
                400,
                900,
                3999,
                1,
                10,
                100,
                1000,
                399,
                444,
                555,
                666,
                777,
                888
            ],
            "outputs": [
                "III",
                "LVIII",
                "MCMXCIV",
                "IV",
                "IX",
                "XL",
                "XC",
                "CD",
                "CM",
                "MMMCMXCIX",
                "I",
                "X",
                "C",
                "M",
                "CCCXCIX",
                "CDXLIV",
                "DLV",
                "DCLXVI",
                "DCCLXXVII",
                "DCCCLXXXVIII"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n\nstd::string intToRoman(int num) {\n    std::vector<std::pair<int, std::string>> romans = {\n        {1000, \"M\"},\n        {900, \"CM\"},\n        {500, \"D\"},\n        {400, \"CD\"},\n        {100, \"C\"},\n        {90, \"XC\"},\n        {50, \"L\"},\n        {40, \"XL\"},\n        {10, \"X\"},\n        {9, \"IX\"},\n        {5, \"V\"},\n        {4, \"IV\"},\n        {1, \"I\"}\n    };\n    std::string roman = \"\";\n    for (const auto& p : romans) {\n        while (num >= p.first) {\n            roman += p.second;\n            num -= p.first;\n        }\n    }\n    return roman;\n}\n",
            "java": "\n    public static String intToRoman(int num) {\n        List<Pair> romans = Arrays.asList(\n            new Pair(1000, \"M\"), new Pair(900, \"CM\"), new Pair(500, \"D\"), \n            new Pair(400, \"CD\"), new Pair(100, \"C\"), new Pair(90, \"XC\"),\n            new Pair(50, \"L\"), new Pair(40, \"XL\"), new Pair(10, \"X\"), \n            new Pair(9, \"IX\"), new Pair(5, \"V\"), new Pair(4, \"IV\"),\n            new Pair(1, \"I\")\n        );\n        StringBuilder roman = new StringBuilder();\n        for (Pair p : romans) {\n            while (num >= p.num) {\n                roman.append(p.symbol);\n                num -= p.num;\n            }\n        }\n        return roman.toString();\n    }\n    \n    private static class Pair {\n        final int num;\n        final String symbol;\n        \n        Pair(int num, String symbol) {\n            this.num = num;\n            this.symbol = symbol;\n        }\n    }\n\n",
            "python": "def int_to_roman(num):\n    romans = [\n        (1000, \"M\"), (900, \"CM\"), (500, \"D\"),\n        (400, \"CD\"), (100, \"C\"), (90, \"XC\"),\n        (50, \"L\"), (40, \"XL\"), (10, \"X\"), \n        (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")\n    ]\n    roman = \"\"\n    for value, symbol in romans:\n        while num >= value:\n            roman += symbol\n            num -= value\n    return roman\n",
            "javascript": "function intToRoman(num) {\n    const romans = [\n        [1000, \"M\"], [900, \"CM\"], [500, \"D\"],\n        [400, \"CD\"], [100, \"C\"], [90, \"XC\"],\n        [50, \"L\"], [40, \"XL\"], [10, \"X\"], \n        [9, \"IX\"], [5, \"V\"], [4, \"IV\"], [1, \"I\"]\n    ];\n    let roman = \"\";\n    for (const [value, symbol] of romans) {\n        while (num >= value) {\n            roman += symbol;\n            num -= value;\n        }\n    }\n    return roman;\n}\n",
            "explanation": "The algorithm starts with a list of pairs, where each pair contains a decimal value and its corresponding roman numeral. Then, it iteratively go through the list of pairs and checks if the num is greater than or equal to the decimal value. If it is, it appends the roman numeral to the result, and subtracts the decimal value from the num. This is done until the num becomes 0."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n\nstd::string intToRoman(int num) {\n    // Your code here\n}\n",
            "java": "public static class RomanNumerals {\n    // Your code here\n}\n",
            "python": "def int_to_roman(num):\n    # Your code here\n\n",
            "javascript": "function intToRoman(num)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::string intToRoman(int num);\n\nint main() {\n    int n = $args;\n    std::string result = intToRoman(n);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public static void main(String[] args) {\n    int num = $args;\n    String result = intToRoman(num);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    num = $args\n    result = int_to_roman(num)\n    print(result)",
            "javascript": "function main() {\n    const num = $args;\n    const result = intToRoman(num);\n    console.log(result);\n}"
        },
        "Qid": "12",
        "languages verified": "all"
    },
    {
        "title": "Roman Numeral to Integer Conversion",
        "description": "Given a Roman numeral, convert it to an integer. Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D`, and `M`. The symbols and their corresponding values are as follows: \n\n`I` - 1\n`V` - 5\n`X` - 10\n`L` - 50\n`C` - 100\n`D` - 500\n`M` - 1000\n\nRoman numerals are usually written largest to smallest from left to right. However, there are six instances where subtraction is used. For example, `IV` represents 4 (5 - 1) and `IX` represents 9 (10 - 1). The goal is to convert the given Roman numeral into its corresponding integer value.",
        "example": "Example:\n\nInput: \"III\"\nOutput: 3\nExplanation: The Roman numeral \"III\" represents the number 3.\n\nInput: \"LVIII\"\nOutput: 58\nExplanation: The Roman numeral \"LVIII\" represents the number 58. It can be broken down as follows: L (50) + V (5) + III (3).\n\nInput: \"MCMXCIV\"\nOutput: 1994\nExplanation: The Roman numeral \"MCMXCIV\" represents the number 1994. It can be broken down as follows: M (1000) + CM (900) + XC (90) + IV (4).",
        "level": "Easy",
        "tags": [
            "String",
            "Math"
        ],
        "test_cases": {
            "inputs": [
                "\"III\"",
                "\"LVIII\"",
                "\"MCMXCIV\"",
                "\"IV\"",
                "\"IX\"",
                "\"XL\"",
                "\"XC\"",
                "\"CD\"",
                "\"CM\"",
                "\"XIV\"",
                "\"XXIX\"",
                "\"XLV\"",
                "\"XCIX\"",
                "\"CDXLIV\"",
                "\"CMXCIX\"",
                "\"MMMCMXCIX\"",
                "\"I\"",
                "\"V\"",
                "\"X\"",
                "\"L\"",
                "\"C\"",
                "\"D\"",
                "\"M\""
            ],
            "outputs": [
                "3",
                "58",
                "1994",
                "4",
                "9",
                "40",
                "90",
                "400",
                "900",
                "14",
                "29",
                "45",
                "99",
                "444",
                "999",
                "3999",
                "1",
                "5",
                "10",
                "50",
                "100",
                "500",
                "1000"
            ]
        },
        "sample_code": {
            "c++": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\n\nint romanToInt(string s) {\n    unordered_map<char, int> roman_values = { {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000} };\n    int total = 0;\n    int prev_value = 0;\n\n    for (char c : s) {\n        int current_value = roman_values[c];\n        if (current_value > prev_value)\n            total += current_value - (2 * prev_value);\n        else\n            total += current_value;\n        prev_value = current_value;\n    }\n\n    return total;\n}\n\n",
            "java": "public static int romanToInt(String s) {\n    Map<Character, Integer> romanValues = new HashMap<>();\n    romanValues.put('I', 1);\n    romanValues.put('V', 5);\n    romanValues.put('X', 10);\n    romanValues.put('L', 50);\n    romanValues.put('C', 100);\n    romanValues.put('D', 500);\n    romanValues.put('M', 1000);\n\n    int total = 0;\n    int prevValue = 0;\n\n    for (char c : s.toCharArray()) {\n        int currValue = romanValues.get(c);\n        total += currValue > prevValue ? currValue - 2 * prevValue : currValue;\n        prevValue = currValue;\n    }\n\n    return total;\n}\n\n",
            "python": "def roman_to_int(s):\n    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    total = 0\n    prev_value = 0\n    \n    for c in s:\n        current_value = roman_values[c]\n        if current_value > prev_value:\n            total += current_value - 2 * prev_value\n        else:\n            total += current_value\n        prev_value = current_value\n\n    return total\n\n",
            "javascript": "function romanToInt(s) {\n    const romanValues = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000};\n    let total = 0;\n    let prevValue = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        let currValue = romanValues[s[i]];\n        if (currValue > prevValue)\n            total += currValue - (2 * prevValue);\n        else\n            total += currValue;\n        prevValue = currValue;\n    }\n\n    return total;\n}\n\n",
            "explanation": "The algorithm iterates through the input string, which represents the Roman numeral. At each iteration, the character is converted to its corresponding integer value using a hash map. Then, the value is added to the total. However, if the current value is greater than the previous value, it means that we need to subtract the previous value from the current value (while considering that the previous value has already been added once). To do this, we add to the total the current value minus 2 times the previous value. Finally, the previous value is updated, and the loop continues. After the loop finishes, the total gives us the integer value equivalent to the Roman numeral."
        },
        "structure": {
            "c++": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint romanToInt(string s) {\n    // Your code here\n}\n\n",
            "java": "public static int romanToInt(String s) {\n    // Your code here\n}\n\n",
            "python": "def roman_to_int(s):\n    # Your code here\n\n",
            "javascript": "function romanToInt(s) {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "\nint main() {\n    string s = \"X\";\n    int result = romanToInt(s);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args){\n    String input = \"M\";\n    int result = romanToInt(input);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = roman_to_int(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = romanToInt(s);\n    console.log(result);\n}"
        },
        "Qid": "13",
        "languages verified": "all"
    },
    {
        "title": "Count and Say Sequence",
        "description": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula. Given a positive integer n, return the nth term of the count-and-say sequence.",
        "example": "Example:\n\nInput: n = 4\nOutput: \"1211\"\nExplanation:\ncountAndSay(1) = \"1\"\ncountAndSay(2) = say \"1\" = one 1 = \"11\"\ncountAndSay(3) = say \"11\" = two 1's = \"21\"\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"",
        "level": "Easy",
        "tags": [
            "recursion",
            "string"
        ],
        "test_cases": {
            "inputs": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                15,
                20,
                25,
                30
            ],
            "outputs": [
                "1",
                "11",
                "21",
                "1211",
                "111221",
                "312211",
                "13112221",
                "1113213211",
                "31131211131221",
                "13211311123113112211",
                "311311222113111231131112132112311321322112111312211312111322212311322113212221",
                "11131221131211131231121113112221121321132132211331222113112211",
                "311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111312211311123113322112111312211312111322212311322113212221",
                "111312211312111312311211131122211213211321322113312221131122111213122112311311222112111312211311123113322112111312211312111322212311322113212221"
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n\nstd::string countAndSay(int n) {\n    if (n == 1) return \"1\";\n    std::string previous = countAndSay(n-1);\n    std::string result = \"\";\n    int count = 1;\n    for (int i = 1; i < previous.length(); i++) {\n        if (previous[i] == previous[i-1]) {\n            count++;\n        } else {\n            result += std::to_string(count) + previous[i-1];\n            count = 1;\n        }\n    }\n    result += std::to_string(count) + previous.back();\n    return result;\n}\n",
            "java": "public static String countAndSay(int n) {\n    if (n == 1) return \"1\";\n    String previous = countAndSay(n-1);\n    StringBuilder result = new StringBuilder();\n    int count = 1;\n    for (int i = 1; i < previous.length(); i++) {\n        if (previous.charAt(i) == previous.charAt(i-1)) {\n            count++;\n        } else {\n            result.append(count).append(previous.charAt(i-1));\n            count = 1;\n        }\n    }\n    result.append(count).append(previous.charAt(previous.length()-1));\n    return result.toString();\n}\n",
            "python": "def count_and_say(n):\n    if n == 1:\n        return \"1\"\n    previous = count_and_say(n - 1)\n    result = []\n    count = 1\n    for i in range(1, len(previous)):\n        if previous[i] == previous[i - 1]:\n            count += 1\n        else:\n            result.append(str(count))\n            result.append(previous[i - 1])\n            count = 1\n    result.append(str(count))\n    result.append(previous[-1])\n    return \"\".join(result)\n",
            "javascript": "function countAndSay(n) {\n    if (n === 1) return \"1\";\n    let previous = countAndSay(n - 1);\n    let result = \"\";\n    let count = 1;\n    for (let i = 1; i < previous.length; i++) {\n        if (previous[i] === previous[i - 1]) {\n            count++;\n        } else {\n            result += count.toString() + previous[i - 1];\n            count = 1;\n        }\n    }\n    result += count.toString() + previous[previous.length - 1];\n    return result;\n}\n",
            "explanation": "The algorithm is a recursive solution. It starts with the base case, when `n` is 1, it returns the first term of the sequence \"1\". In other cases, it makes a recursive call to the function with `n-1` to get the previous term in the sequence. Then it iterates through the previous term, comparing each character with the previous one to count the number of consecutive equal digits. When it encounters a different character, it appends the count and the character to the result string and resets the count to 1. Finally, it appends the last count and character to the result string and returns it."
        },
        "structure": {
            "c++": "#include <string>\n\nstd::string countAndSay(int n) {\n    // Your code here\n}\n",
            "java": "public static String countAndSay(int n) {\n    // Your code here\n}\n",
            "python": "def count_and_say(n):\n    # Your code here\n\n",
            "javascript": "function countAndSay(n) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <string>\n\nint main() {\n    int n = $args;\n    std::string result = countAndSay(n);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    n = 5\n    print(count_and_say(n))",
            "javascript": "function main() {\n    const n = $args;\n    const result = countAndSay(n);\n    console.log(result);\n}",
            "java": "public static void main(String[] args){\n    int input = $args;\n    String result = countAndSay(input);\n    System.out.println(result);\n}"
        },
        "Qid": "38",
        "languages verified": "all"
    },
    {
        "title": "Length of Last Word",
        "description": "Given a string `s` consisting of words and spaces, return the length of the last word in the string. A word is a maximal substring consisting of non-space characters only.",
        "example": "Example 1:\n\nInput: s = \"Hello World \"\nOutput: 5\nExplanation: The last word is \"World \" with length 5.",
        "level": "Easy",
        "tags": [
            "string",
            "parsing"
        ],
        "test_cases": {
            "inputs": [
                "\"Hello World \"",
                "\"   fly me   to   the moon   \"",
                "\"luffy is still joyboy \"",
                "\"This is a test\"",
                "\"Coding is fun\"",
                "\"  Hello  \"",
                "\"  Hello World\"",
                "\"Hello World\"",
                "\"Hello\"",
                "\"\"",
                "\"   \"",
                "\"a\"",
                "\"a b\"",
                "\"a b c\"",
                "\"a b c d\"",
                "\"a b c d e\"",
                "\"a b c d e f\"",
                "\"a b c d e f g\"",
                "\"a b c d e f g h\"",
                "\"a b c d e f g h i\""
            ],
            "outputs": [
                5,
                4,
                6,
                4,
                3,
                5,
                5,
                5,
                5,
                0,
                0,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1
            ]
        },
        "sample_code": {
            "c++": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint lengthOfLastWord(string s) {\n    int length = 0;\n    int tail = s.length() - 1;\n    while (tail >= 0 && s[tail] == ' ') tail--;\n    while (tail >= 0 && s[tail] != ' ') {\n        length++;\n        tail--;\n    }\n    return length;\n}",
            "java": "public static int lengthOfLastWord(String s) {\n    int length = 0;\n    int tail = s.length() - 1;\n    while (tail >= 0 && s.charAt(tail) == ' ') tail--;\n    while (tail >= 0 && s.charAt(tail) != ' ') {\n        length++;\n        tail--;\n    }\n    return length;\n}\n",
            "python": "def length_of_last_word(s: str) -> int:\n    length = 0\n    tail = len(s) - 1\n    while tail >= 0 and s[tail] == ' ':\n        tail -= 1\n    while tail >= 0 and s[tail] != ' ':\n        length += 1\n        tail -= 1\n    return length\n",
            "javascript": "function lengthOfLastWord(s) {\n    let length = 0;\n    let tail = s.length - 1;\n    while (tail >= 0 && s[tail] === ' ') tail--;\n    while (tail >= 0 && s[tail] !== ' ') {\n        length++;\n        tail--;\n    }\n    return length;\n}\n",
            "explanation": "The algorithm for finding the length of the last word in a string containing multiple words separated by spaces is as follows:\n\n1. Initialize variables for the length of the last word and the tail (i.e., the end) of the input string.\n2. Traverse the string in reverse order to find the start of the last word by checking if a character is a space. Skip all spaces found.\n3. Continue traversing the string in reverse order and record the length of the last word until a space is encountered or the start of the string is reached.\n4. Return the length of the last word.\n\nThis algorithm is implemented in each of the given programming languages (C++, Java, Python, and JavaScript) with the appropriate syntax and variable initialization. The functions are named `lengthOfLastWord` for C++, Java, and JavaScript, and `length_of_last_word` for Python."
        },
        "structure": {
            "c++": "int lengthOfLastWord(string s) \n    // Your code here\n}\n",
            "java": "public int lengthOfLastWord(String s) {\n    // Your code here\n}\n",
            "python": "def length_of_last_word(s: str) -> int:\n    # Your code here\n\n",
            "javascript": "function lengthOfLastWord(s) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    string s = $args;\n    int result = lengthOfLastWord(s);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = length_of_last_word(s)\n    print(result)",
            "java": "public static void main(String[] args){\n    String input = $args;\n    int result = lengthOfLastWord(input);\n    System.out.println(result);\n}",
            "javascript": "function main() {\n  const s = $args;\n  const result = lengthOfLastWord(s);\n  console.log(result);\n}"
        },
        "Qid": "58",
        "languages verified": "all"
    },
    {
        "title": "Valid Number",
        "description": "Given a string `s`, determine if it is a valid number. A valid number can be split into components in a specific order: a decimal number or an integer, followed by an optional 'e' or 'E' followed by an integer. A decimal number can have an optional sign character ('+' or '-'), followed by one of the following formats: one or more digits followed by a dot '.', one or more digits followed by a dot '.' and one or more digits, or a dot '.' followed by one or more digits. An integer can have an optional sign character followed by one or more digits. Return true if the given string is a valid number, otherwise return false.",
        "example": "Example:\n\nInput: \"0 \"\nOutput: true\n\nInput: \"e \"\nOutput: false\n\nInput: \". \"\nOutput: false\n\nExplanation:\n\nIn the first example, the string \"0 \" is a valid number as it is an integer.\n\nIn the second example, the string \"e \" is not a valid number as it does not have any components.\n\nIn the third example, the string \". \" is not a valid number as it does not have any components.",
        "level": "Medium",
        "tags": [
            "string",
            "parsing"
        ],
        "test_cases": {
            "inputs": [
                "\"2\"",
                "\"0089\"",
                "\"-0.1\"",
                "\"+3.14\"",
                "\"4.\"",
                "\"-.9\"",
                "\"2e10\"",
                "\"-90E3\"",
                "\"3e+7\"",
                "\"+6e-1\"",
                "\"53.5e93\"",
                "\"-123.456e789\"",
                "\"abc\"",
                "\"1a\"",
                "\"1e\"",
                "\"e3\"",
                "\"99e2.5\"",
                "\"--6\"",
                "\"-+3\"",
                "\"95a54e53\""
            ],
            "outputs": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "#include <regex>\n#include <string>\n\nbool isNumber(const std::string& s) {\n    std::regex pattern(\"^[-+]?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(e[-+]?[0-9]+)?$\");\n    return std::regex_match(s, pattern);\n}\n\n",
            "java": " public static boolean isNumber(String s) {\n        String pattern = \"^[-+]?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(e[-+]?[0-9]+)?$\";\n        return Pattern.matches(pattern, s);\n    }\n\n\n",
            "python": "import re\n\ndef is_number(s: str) -> bool:\n    pattern = re.compile(r'^[-+]?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(e[-+]?[0-9]+)?$')\n    return bool(pattern.match(s))\n\n",
            "javascript": "function isNumber(s) {\n    const pattern = /^[-+]?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(e[-+]?[0-9]+)?$/;\n    return pattern.test(s);\n}\n\n",
            "explanation": "The algorithm utilizes regular expressions to match the input string against a pattern that defines a valid number. The regular expression in this case has the following meaning:\n\n1. `^`: Start of the string\n2. `[-+]?`: An optional sign, either `+` or `-`\n3. `(`: Start of a group that can be an integer or a decimal\n4. `(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))`: Here, a valid number can either have digits before and after the decimal point or only after the decimal point (or only before the decimal point with an optional decimal delimiter).\n5. `)`: End of the group\n6. `(e[-+]?[0-9]+)?`: An optional scientific notation part, which consists of the letter 'e', followed by an optional sign and at least one digit\n7. `$`: End of the string\n\nThe regex pattern is constructed to cover all cases according to the problem's description. The function then uses each language's regex library to match the input string against this pattern, returning `true` if the input string matches and `false` otherwise."
        },
        "structure": {
            "c++": "#include <regex>\n#include <string>\n\nbool isNumber(const std::string& s) {\n    // Your code here\n}\n\n",
            "java": "public class Solution {\n    // Your code here\n}\n\n",
            "python": "import re\n    # Your code here\n\n",
            "javascript": "function isNumber(s) {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <regex>\n#include <string>\n#include <iostream>\n\nint main() {\n    std::string s = $args;\n    bool result = isNumber(s);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "java": "public static void main(String[] args){\n    String input = $args;\n    boolean result = isNumber(input);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = is_number(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = isNumber(s);\n    console.log(result);\n}"
        },
        "Qid": "65",
        "languages verified": "all"
    },
    {
        "title": "Square Root Rounded Down",
        "description": "Given a non-negative integer `x`, you need to find the square root of `x` rounded down to the nearest integer. The returned integer should be non-negative. You must not use any built-in exponent function or operator.",
        "example": "Example:\n\nInput: x = 4\nOutput: 2\nExplanation: The square root of 4 is 2, so we return 2.",
        "level": "Easy",
        "tags": [
            "Math",
            "Binary Search"
        ],
        "test_cases": {
            "inputs": [
                0,
                1,
                2,
                3,
                4,
                8,
                9,
                16,
                25,
                36,
                49,
                64,
                81,
                100,
                121,
                144,
                169,
                196,
                225,
                256
            ],
            "outputs": [
                0,
                1,
                1,
                1,
                2,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16
            ]
        },
        "sample_code": {
            "c++": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint mySqrt(int x) {\n    if (x == 0 || x == 1) return x;\n    int start = 1, end = x, ans;\n    while (start <= end) {\n        int mid = (start + end) / 2;\n        if (mid * mid == x) return mid;\n        if (mid * mid < x) {\n            start = mid + 1;\n            ans = mid;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}\n",
            "java": "public static int mySqrt(int x) {\n    if (x == 0 || x == 1) return x;\n    int start = 1, end = x, ans = 0;\n    while (start <= end) {\n        int mid = (start + end) / 2;\n        if (mid * mid == x) return mid;\n        if (mid <= x / mid) {\n            start = mid + 1;\n            ans = mid;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}\n",
            "python": "def mySqrt(x):\n    if x == 0 or x == 1:\n        return x\n    start, end, ans = 1, x, 0\n    while start <= end:\n        mid = (start + end) // 2\n        if mid * mid == x:\n            return mid\n        if mid * mid < x:\n            start = mid + 1\n            ans = mid\n        else:\n            end = mid - 1\n    return ans\n",
            "javascript": "function mySqrt(x) {\n    if (x === 0 || x === 1) return x;\n    let start = 1, end = x, ans;\n    while (start <= end) {\n        let mid = Math.floor((start + end) / 2);\n        if (mid * mid === x) return mid;\n        if (mid * mid < x) {\n            start = mid + 1;\n            ans = mid;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}\n\n",
            "explanation": "The algorithm uses a binary search approach to find the integer square root of the given number `x`. It starts with the smallest possible answer (1) and the largest possible answer (x), updating the \"start\" and \"end\" positions based on whether the current midpoint squared is smaller or larger than x. The integer square root of the number is found when `mid * mid == x`, or when the closest integer (under or equal to x) value has been located. The binary search approach keeps the time complexity at O(log(x)), making it an efficient solution."
        },
        "structure": {
            "c++": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint mySqrt(int x) {\n    // Your code here\n}\n",
            "java": "public static int mySqrt(int x) \n    // Your code here\n}\n",
            "python": "def mySqrt(x):\n    # Your code here\n\n",
            "javascript": "function mySqrt(x) {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int x = $args;\n    int result = mySqrt(x);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args){\n    int input = $args;\n    int result = mySqrt(input);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    x = $args\n    result = mySqrt(x)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = mySqrt(s);\n    console.log(result);\n}"
        },
        "Qid": "69",
        "languages verified": "all"
    },
    {
        "title": "Longest Substring Without Repeating Characters",
        "description": "Given a string `s`, find the length of the longest substring without repeating characters.",
        "example": "Example 1:\n\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.",
        "level": "Medium",
        "tags": [
            "string",
            "sliding window",
            "hash table"
        ],
        "test_cases": {
            "inputs": [
                "\"abcabcbb\"",
                "\"bbbbb\"",
                "\"pwwkew\"",
                "\"\"",
                "\"a\"",
                "\"abcdefg\"",
                "\"aab\"",
                "\"abb\"",
                "\"abcabcabc\"",
                "\"abcdeffghijklmnopqrstuvwxyz\""
            ],
            "outputs": [
                "3",
                "1",
                "3",
                "0",
                "1",
                "7",
                "2",
                "2",
                "3",
                "26"
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <unordered_set>\n\nint lengthOfLongestSubstring(std::string s) {\n    int left = 0, right = 0, maxLength = 0;\n    std::unordered_set<char> characters;\n\n    while (right < s.size()) {\n        if (characters.find(s[right]) == characters.end()) {\n            characters.insert(s[right]);\n            maxLength = std::max(maxLength, right - left + 1);\n            right++;\n        } else {\n            characters.erase(s[left]);\n            left++;\n        }\n    }\n\n    return maxLength;\n}\n",
            "java": "public static int lengthOfLongestSubstring(String s) {\n    int left = 0, right = 0, maxLength = 0;\n    Set<Character> characters = new HashSet<>();\n\n    while (right < s.length()) {\n        if (!characters.contains(s.charAt(right))) {\n            characters.add(s.charAt(right));\n            maxLength = Math.max(maxLength, right - left + 1);\n            right++;\n        } else {\n            characters.remove(s.charAt(left));\n            left++;\n        }\n    }\n\n    return maxLength;\n}\n",
            "python": "def length_of_longest_substring(s: str) -> int:\n    left = 0\n    right = 0\n    max_length = 0\n    characters = set()\n\n    while right < len(s):\n        if s[right] not in characters:\n            characters.add(s[right])\n            max_length = max(max_length, right - left + 1)\n            right += 1\n        else:\n            characters.remove(s[left])\n            left += 1\n\n    return max_length\n",
            "javascript": "function lengthOfLongestSubstring(s) {\n    let left = 0, right = 0, maxLength = 0;\n    const characters = new Set();\n\n    while (right < s.length) {\n        if (!characters.has(s.charAt(right))) {\n            characters.add(s.charAt(right));\n            maxLength = Math.max(maxLength, right - left + 1);\n            right++;\n        } else {\n            characters.delete(s.charAt(left));\n            left++;\n        }\n    }\n\n    return maxLength;\n}\n",
            "explanation": "The algorithm uses a sliding window with two pointers, left and right, to iterate through the string. It also uses a set to store the unique characters in the current window.\n\n1. Initialize left and right pointers to the start of the string, and maxLength to 0.\n2. Check if the character at the right index is in the set.\n   - If it's not in the set, add the character to the set, update maxLength, and move the right pointer forward.\n   - If it's in the set, remove the character at the left index from the set, and move the left pointer forward.\n3. Repeat step 2 until the right pointer reaches the end of the string.\n4. Return maxLength. \n\nThe algorithm runs in O(n) time, where n is the length of the input string."
        },
        "structure": {
            "c++": "#include <string>\n#include <unordered_set>\n\nint lengthOfLongestSubstring(std::string s) \n    // Your code here\n}\n",
            "java": "public static int lengthOfLongestSubstring(String s) {\n    // Your code here\n}\n",
            "python": "def length_of_longest_substring(s: str) -> int:\n    # Your code here\n\n",
            "javascript": "function lengthOfLongestSubstring(s) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <string>\n#include <unordered_set>\n\nint main() {\n    std::string s = $args;\n    int result = lengthOfLongestSubstring(s);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = length_of_longest_substring(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = lengthOfLongestSubstring(s);\n    console.log(result);\n}",
            "java": "public static void main(String[] args) {\n        String input = $args;\n        int result = lengthOfLongestSubstring(input);\n        System.out.println(result);\n    }"
        },
        "Qid": "3",
        "languages verified": "all"
    }
]