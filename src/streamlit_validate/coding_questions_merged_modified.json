{
    "441": {
        "title": "Staircase Rows",
        "description": "You have `n` coins and you want to build a staircase with these coins. The staircase consists of `k` rows where the `ith` row has exactly `i` coins. The last row of the staircase **may be** incomplete. Given the integer `n`, return the number of complete rows of the staircase you will build.",
        "example": "Example 1:\n\nInput: n = 5\nOutput: 2\nExplanation: Because the 3rd row is incomplete, we return 2.\n\nExample 2:\n\nInput: n = 8\nOutput: 3\nExplanation: Because the 4th row is incomplete, we return 3.",
        "level": "Easy",
        "tags": [
            "math",
            "loops"
        ],
        "test_cases": {
            "inputs": [
                5,
                8,
                1,
                10,
                15,
                20,
                25,
                30,
                50,
                100,
                1000,
                10000,
                100000,
                1000000,
                10000000,
                100000000,
                1000000000,
                2147483647
            ],
            "outputs": [
                2,
                3,
                1,
                4,
                5,
                5,
                5,
                6,
                7,
                13,
                44,
                141,
                447,
                1414,
                4472,
                14142,
                44721,
                46340
            ]
        },
        "sample_code": {
            "c++": "int arrangeCoins(int n) {\n    int k = 0;\n    while (n > k) {\n        k++;\n        n -= k;\n    }\n    return k;\n}\n",
            "java": "public int arrangeCoins(int n) {\n    int k = 0;\n    while (n > k) {\n        k++;\n        n -= k;\n    }\n    return k;\n}\n",
            "python": "def arrange_coins(n: int) -> int:\n    k = 0\n    while n > k:\n        k += 1\n        n -= k\n    return k\n",
            "javascript": "function arrangeCoins(n) {\n    let k = 0;\n    while (n > k) {\n        k++;\n        n -= k;\n    }\n    return k;\n}\n",
            "explanation": "The algorithm initializes a variable k, which represents the current row number, to 0. Then it enters a loop where it checks if n is greater than k. If so, it increments k by 1 and subtracts k from n. This process continues until n is no longer greater than k. Finally, the value of k is returned, representing the number of complete rows of the staircase. This approach has a time complexity of O(sqrt(n)) since the number of iterations increases linearly with the size of the staircase."
        },
        "structure": {
            "c++": "int arrangeCoins(int n) \n    // Your code here\n}\n",
            "java": "public int arrangeCoins(int n) \n    // Your code here\n}\n",
            "python": "def arrange_coins(n: int) -> int:\n    # Your code here\n\n",
            "javascript": "function arrangeCoins(n) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = arrangeCoins(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int arrangeCoins(int n) {\n    int k = 0;\n    while (n > k) {\n        k++;\n        n -= k;\n    }\n    return k;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    result = arrange_coins(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = arrangeCoins(n);\n    console.log(result);\n}"
        }
    },
    "442": {
        "title": "Find Duplicates in Array",
        "description": "Given an integer array `nums` of length `n` where all the integers of `nums` are in the range `[1, n]` and each integer appears **once** or **twice**, write a function to return an array of all the integers that appear **twice**.",
        "example": "Example 1:\n\nInput: nums = [4,3,2,7,8,2,3,1]\nOutput: [2,3]\n\nExample 2:\n\nInput: nums = [1,1,2]\nOutput: [1]\n\nExample 3:\n\nInput: nums = [1]\nOutput: []",
        "level": "Easy",
        "tags": [
            "Array",
            "Hash Table"
        ],
        "test_cases": {
            "inputs": [
                [
                    4,
                    3,
                    2,
                    7,
                    8,
                    2,
                    3,
                    1
                ],
                [
                    1,
                    1,
                    2
                ],
                [
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    3,
                    1,
                    4,
                    2,
                    1,
                    4,
                    2
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    9
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    3,
                    3,
                    3,
                    3,
                    3,
                    3,
                    3,
                    3,
                    3,
                    3
                ],
                [
                    4,
                    4,
                    4,
                    4,
                    4,
                    4,
                    4,
                    4,
                    4,
                    4
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    6,
                    6,
                    6,
                    6,
                    6,
                    6,
                    6,
                    6,
                    6,
                    6
                ],
                [
                    7,
                    7,
                    7,
                    7,
                    7,
                    7,
                    7,
                    7,
                    7,
                    7
                ],
                [
                    8,
                    8,
                    8,
                    8,
                    8,
                    8,
                    8,
                    8,
                    8,
                    8
                ],
                [
                    9,
                    9,
                    9,
                    9,
                    9,
                    9,
                    9,
                    9,
                    9,
                    9
                ],
                [
                    10,
                    10,
                    10,
                    10,
                    10,
                    10,
                    10,
                    10,
                    10,
                    10
                ]
            ],
            "outputs": [
                [
                    2,
                    3
                ],
                [
                    1
                ],
                [],
                [
                    2
                ],
                [
                    1,
                    2,
                    4
                ],
                [],
                [
                    1
                ],
                [
                    9
                ],
                [],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1
                ],
                [
                    2
                ],
                [
                    3
                ],
                [
                    4
                ],
                [
                    5
                ],
                [
                    6
                ],
                [
                    7
                ],
                [
                    8
                ],
                [
                    9
                ],
                [
                    10
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <cmath>\n\nstd::vector<int> findDuplicates(std::vector<int>& nums) {\n    std::vector<int> duplicates;\n    for (int i = 0; i < nums.size(); i++) {\n        int index = abs(nums[i]) - 1;\n        if (nums[index] < 0) {\n            duplicates.push_back(abs(nums[i]));\n        } else {\n            nums[index] *= -1;\n        }\n    }\n    return duplicates;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> findDuplicates(int[] nums) {\n    List<Integer> duplicates = new ArrayList<>();\n    for (int i = 0; i < nums.length; i++) {\n        int index = Math.abs(nums[i]) - 1;\n        if (nums[index] < 0) {\n            duplicates.add(Math.abs(nums[i]));\n        } else {\n            nums[index] *= -1;\n        }\n    }\n    return duplicates;\n}\n",
            "python": "def find_duplicates(nums):\n    duplicates = []\n    for i in range(len(nums)):\n        index = abs(nums[i]) - 1\n        if nums[index] < 0:\n            duplicates.append(abs(nums[i]))\n        else:\n            nums[index] *= -1\n    return duplicates\n",
            "javascript": "function findDuplicates(nums) {\n    let duplicates = [];\n    for (let i = 0; i < nums.length; i++) {\n        let index = Math.abs(nums[i]) - 1;\n        if (nums[index] < 0) {\n            duplicates.push(Math.abs(nums[i]));\n        } else {\n            nums[index] *= -1;\n        }\n    }\n    return duplicates;\n}\n",
            "explanation": "The algorithm iterates through the input array, using the array values as indices. For each index, we make the corresponding value in the array negative. If we encounter a negative value during the process, that means this index was seen before (i.e., the value was duplicated), so we add the absolute value of the duplicated number to the result.\n\nThe algorithm runs in O(n) time complexity, as there is only one iteration through the input array. It also uses constant extra space, because the input array is utilized for marking, and only the result array is created separately."
        },
        "structure": {
            "c++": "#include <vector>\n#include <cmath>\n\nstd::vector<int> findDuplicates(std::vector<int>& nums) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> findDuplicates(int[] nums) \n    // Your code here\n}\n",
            "python": "def find_duplicates(nums):\n    # Your code here\n\n",
            "javascript": "function findDuplicates(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <cmath>\n#include <iostream>\n\nstd::vector<int> findDuplicates(std::vector<int>& nums);\n\nint main() {\n    std::vector<int> nums = $args;\n    std::vector<int> result = findDuplicates(nums);\n    for (int i = 0; i < result.size(); i++) {\n        std::cout << result[i] << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}\n",
            "java": "public List<Integer> findDuplicates(int[] nums) {\n    List<Integer> duplicates = new ArrayList<>();\n    for (int i = 0; i < nums.length; i++) {\n        int index = Math.abs(nums[i]) - 1;\n        if (nums[index] < 0) {\n            duplicates.add(Math.abs(nums[i]));\n        } else {\n            nums[index] *= -1;\n        }\n    }\n    return duplicates;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = find_duplicates(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = findDuplicates(nums);\n    console.log(result);\n}"
        }
    },
    "444": {
        "title": "Shortest Supersequence",
        "description": "Given an integer array `nums` of length `n` where `nums` is a permutation of the integers in the range `[1, n]`, and a 2D integer array `sequences` where `sequences[i]` is a subsequence of `nums`, check if `nums` is the shortest possible and the only supersequence. The shortest supersequence is a sequence with the shortest length and has all `sequences[i]` as subsequences. Return `true` if `nums` is the only shortest supersequence for `sequences`, or `false` otherwise.",
        "example": "Example:\n\nInput: nums = [1,2,3], sequences = [[1,2],[1,3]]\nOutput: false\nExplanation: There are two possible supersequences: [1,2,3] and [1,3,2]. The sequence [1,2] is a subsequence of both: [1,2,3] and [1,3,2]. The sequence [1,3] is a subsequence of both: [1,2,3] and [1,3,2]. Since nums is not the only shortest supersequence, we return false.",
        "level": "Medium",
        "tags": [
            "array",
            "subsequence"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3
                ],
                [
                    1,
                    2,
                    3
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ]
            ],
            "outputs": [
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true
            ]
        },
        "sample_code": {
            "c++": "bool isShortestAndUniqueSupersequence(vector<int>& nums, vector<vector<int>>& sequences) {\n    unordered_map<int, int> pos;\n    for (int i = 0; i < nums.size(); ++i) {\n        pos[nums[i]] = i;\n    }\n\n    for (const auto& seq : sequences) {\n        if (pos[seq[0]] > pos[seq.back()]) {\n            return false;\n        }\n    }\n    return true;\n}\n",
            "java": "public boolean isShortestAndUniqueSupersequence(int[] nums, int[][] sequences) {\n    Map<Integer, Integer> pos = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        pos.put(nums[i], i);\n    }\n\n    for (int[] seq : sequences) {\n        if (pos.get(seq[0]) > pos.get(seq[seq.length - 1])) {\n            return false;\n        }\n    }\n    return true;\n}\n",
            "python": "def is_shortest_and_unique_supersequence(nums, sequences):\n    pos = {val: idx for idx, val in enumerate(nums)}\n\n    for seq in sequences:\n        if pos[seq[0]] > pos[seq[-1]]:\n            return False\n    return True\n",
            "javascript": "function isShortestAndUniqueSupersequence(nums, sequences) {\n    const pos = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        pos.set(nums[i], i);\n    }\n\n    for (const seq of sequences) {\n        if (pos.get(seq[0]) > pos.get(seq[seq.length - 1])) {\n            return false;\n        }\n    }\n    return true;\n}\n",
            "explanation": "We start by creating a hashmap (or dictionary in Python and Map in JavaScript) to store the position of each element in the given `nums` array for efficient lookup. The map is filled with each value of the `nums` array as the key and its index as the value.\n\nWe then iterate through each sequence in `sequences` and check if the position of the first element in the sequence is greater than the position of the last element in the same sequence. If so, it means the given sequence is not a valid subsequence of the given `nums`, and we return `false`.\n\nIf we passed all sequences in the iteration without returning `false`, it means that the given `nums` array is the shortest possible and the only supersequence of the input sequences. Thus, we return `true`."
        },
        "structure": {
            "c++": "bool isShortestAndUniqueSupersequence(vector<int>& nums, vector<vector<int>>& sequences) \n    // Your code here\n}\n",
            "java": "public boolean isShortestAndUniqueSupersequence(int[] nums, int[][] sequences) \n    // Your code here\n}\n",
            "python": "def is_shortest_and_unique_supersequence(nums, sequences):\n    # Your code here\n\n",
            "javascript": "function isShortestAndUniqueSupersequence(nums, sequences) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "bool isShortestAndUniqueSupersequence(vector<int>& nums, vector<vector<int>>& sequences) {\n    unordered_map<int, int> pos;\n    for (int i = 0; i < nums.size(); ++i) {\n        pos[nums[i]] = i;\n    }\n\n    for (const auto& seq : sequences) {\n        if (pos[seq[0]] > pos[seq.back()] ) {\n            return false;\n        }\n    }\n    return true;\n}",
            "java": "public boolean isShortestAndUniqueSupersequence(int[] nums, int[][] sequences) {\n    Map<Integer, Integer> pos = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        pos.put(nums[i], i);\n    }\n\n    for (int[] seq : sequences) {\n        if (pos.get(seq[0]) > pos.get(seq[seq.length - 1])) {\n            return false;\n        }\n    }\n    return true;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    sequences = $args[1]\n    result = is_shortest_and_unique_supersequence(nums, sequences)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args[0];\n    const sequences = $args[1];\n    const result = isShortestAndUniqueSupersequence(nums, sequences);\n    console.log(result);\n}"
        }
    },
    "446": {
        "title": "Arithmetic Subsequences",
        "description": "Given an integer array `nums`, return the number of all the arithmetic subsequences of `nums`. A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.",
        "example": "Example:\n\nInput: nums = [2,4,6,8,10]\nOutput: 7\nExplanation: All arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]",
        "level": "Medium",
        "tags": [
            "array",
            "subsequence",
            "arithmetic"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    4,
                    6,
                    8,
                    10
                ],
                [
                    7,
                    7,
                    7,
                    7,
                    7
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9
                ],
                [
                    3,
                    -1,
                    -5,
                    -9
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16
                ],
                [
                    1,
                    2,
                    4,
                    7,
                    11
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    15
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    32
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    31
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    30
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    29
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    28
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    27
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    26
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    25
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    24
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    23
                ]
            ],
            "outputs": [
                7,
                16,
                7,
                10,
                16,
                7,
                15,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <unordered_map>\n\nint numberOfArithmeticSlices(std::vector<int>& nums) {\n    int res = 0;\n    int n = nums.size();\n    std::vector<std::unordered_map<int, int>> dp(n);\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            long diff = (long)nums[i] - (long)nums[j];\n            if (diff <= INT_MIN || diff > INT_MAX) continue;\n\n            int delta = (int)diff;\n            dp[i][delta] += 1;\n\n            if (dp[j].count(delta)) {\n                res += dp[j][delta];\n                dp[i][delta] += dp[j][delta];\n            }\n        }\n    }\n    return res;\n}\n\n",
            "java": "import java.util.HashMap;\nimport java.util.Map;\n\npublic int numberOfArithmeticSlices(int[] nums) {\n    int res = 0;\n    int n = nums.length;\n    Map<Integer, Integer>[] dp = new HashMap[n];\n\n    for (int i = 0; i < n; ++i) {\n        dp[i] = new HashMap<>();\n        for (int j = 0; j < i; ++j) {\n            long diff = (long)nums[i] - (long)nums[j];\n            if (diff <= Integer.MIN_VALUE || diff > Integer.MAX_VALUE) continue;\n\n            int delta = (int)diff;\n            dp[i].put(delta, dp[i].getOrDefault(delta, 0) + 1);\n\n            if (dp[j].containsKey(delta)) {\n                res += dp[j].get(delta);\n                dp[i].put(delta, dp[i].get(delta) + dp[j].get(delta));\n            }\n        }\n    }\n    return res;\n}\n\n",
            "python": "def numberOfArithmeticSlices(nums):\n    res = 0\n    n = len(nums)\n    dp = [dict() for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            diff = nums[i] - nums[j]\n            if diff <= -2**31 or diff > 2**31:\n                continue\n\n            dp[i][diff] = dp[i].get(diff, 0) + 1\n\n            if diff in dp[j]:\n                res += dp[j][diff]\n                dp[i][diff] += dp[j][diff]\n\n    return res\n\n",
            "javascript": "function numberOfArithmeticSlices(nums) {\n    let res = 0;\n    const n = nums.length;\n    const dp = new Array(n).fill(0).map(() => new Map());\n\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < i; ++j) {\n            const diff = nums[i] - nums[j];\n            if (diff <= Number.MIN_SAFE_INTEGER || diff > Number.MAX_SAFE_INTEGER) continue;\n\n            if (!dp[i].has(diff)) {\n                dp[i].set(diff, 0);\n            }\n\n            dp[i].set(diff, dp[i].get(diff) + 1);\n\n            if (dp[j].has(diff)) {\n                res += dp[j].get(diff);\n                dp[i].set(diff, dp[i].get(diff) + dp[j].get(diff));\n            }\n        }\n    }\n    return res;\n}\n\n",
            "explanation": "To solve this problem, we use dynamic programming. The `dp` data structure is an array of hashmaps or dictionaries. Each index `i` in the array represents an element in the given array `nums`, and the hashmap stored at `dp[i]` will store the count of arithmetic subsequences that end at the element `nums[i]`, with keys representing the differences between elements.\n\nStarting with index `i = 0`, we iterate through the `nums` array. For each element `nums[i]`, we iterate through all previous elements `nums[j]` with `j < i`.\n\nFor each pair of elements `(nums[i], nums[j])`, we calculate their difference and store the count of arithmetic subsequences formed by this difference at `dp[i]`.\n\nIf an existing subsequence with the same difference is found in `dp[j]`, we should be able to append `nums[i]` to all previously formed subsequences ending at `nums[j]`. Thus, we add the count of subsequences from `dp[j][delta]` to the result, and also update the count in `dp[i][delta]`.\n\nFinally, after iterating through all elements, the `res` variable will hold the count of all the arithmetic subsequences."
        },
        "structure": {
            "c++": "#include <vector>\n#include <unordered_map>\n\nint numberOfArithmeticSlices(std::vector<int>& nums) \n    // Your code here\n}\n\n",
            "java": "import java.util.HashMap;\nimport java.util.Map;\n\npublic int numberOfArithmeticSlices(int[] nums) \n    // Your code here\n}\n\n",
            "python": "def numberOfArithmeticSlices(nums):\n    # Your code here\n\n",
            "javascript": "function numberOfArithmeticSlices(nums) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <unordered_map>\n#include <iostream>\n\nint main() {\n    std::vector<int> nums = $args;\n    int result = numberOfArithmeticSlices(nums);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public int numberOfArithmeticSlices(int[] nums) {\n    int res = 0;\n    int n = nums.length;\n    Map<Integer, Integer>[] dp = new HashMap[n];\n\n    for (int i = 0; i < n; ++i) {\n        dp[i] = new HashMap<>();\n        for (int j = 0; j < i; ++j) {\n            long diff = (long)nums[i] - (long)nums[j];\n            if (diff <= Integer.MIN_VALUE || diff > Integer.MAX_VALUE) continue;\n\n            int delta = (int)diff;\n            dp[i].put(delta, dp[i].getOrDefault(delta, 0) + 1);\n\n            if (dp[j].containsKey(delta)) {\n                res += dp[j].get(delta);\n                dp[i].put(delta, dp[i].get(delta) + dp[j].get(delta));\n            }\n        }\n    }\n    return res;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = numberOfArithmeticSlices(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = numberOfArithmeticSlices(nums);\n    console.log(result);\n}"
        }
    },
    "447": {
        "title": "Number of Boomerangs",
        "description": "You are given `n` `points` in the plane that are all **distinct**, where `points[i] = [xi, yi]`. A **boomerang** is a tuple of points `(i, j, k)` such that the distance between `i` and `j` equals the distance between `i` and `k` **(the order of the tuple matters)**. Return the number of boomerangs.",
        "example": "Example:\n\nInput: points = [[0,0],[1,0],[2,0]]\nOutput: 2\nExplanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]].",
        "level": "Medium",
        "tags": [
            "Array",
            "Math"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        0
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ]
                ],
                [
                    [
                        1,
                        1
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ],
                    [
                        26,
                        26
                    ],
                    [
                        27,
                        27
                    ],
                    [
                        28,
                        28
                    ],
                    [
                        29,
                        29
                    ],
                    [
                        30,
                        30
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ],
                    [
                        26,
                        26
                    ],
                    [
                        27,
                        27
                    ],
                    [
                        28,
                        28
                    ],
                    [
                        29,
                        29
                    ],
                    [
                        30,
                        30
                    ],
                    [
                        31,
                        31
                    ],
                    [
                        32,
                        32
                    ],
                    [
                        33,
                        33
                    ],
                    [
                        34,
                        34
                    ],
                    [
                        35,
                        35
                    ],
                    [
                        36,
                        36
                    ],
                    [
                        37,
                        37
                    ],
                    [
                        38,
                        38
                    ],
                    [
                        39,
                        39
                    ],
                    [
                        40,
                        40
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ],
                    [
                        26,
                        26
                    ],
                    [
                        27,
                        27
                    ],
                    [
                        28,
                        28
                    ],
                    [
                        29,
                        29
                    ],
                    [
                        30,
                        30
                    ],
                    [
                        31,
                        31
                    ],
                    [
                        32,
                        32
                    ],
                    [
                        33,
                        33
                    ],
                    [
                        34,
                        34
                    ],
                    [
                        35,
                        35
                    ],
                    [
                        36,
                        36
                    ],
                    [
                        37,
                        37
                    ],
                    [
                        38,
                        38
                    ],
                    [
                        39,
                        39
                    ],
                    [
                        40,
                        40
                    ],
                    [
                        41,
                        41
                    ],
                    [
                        42,
                        42
                    ],
                    [
                        43,
                        43
                    ],
                    [
                        44,
                        44
                    ],
                    [
                        45,
                        45
                    ],
                    [
                        46,
                        46
                    ],
                    [
                        47,
                        47
                    ],
                    [
                        48,
                        48
                    ],
                    [
                        49,
                        49
                    ],
                    [
                        50,
                        50
                    ]
                ]
            ],
            "outputs": [
                "2",
                "2",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0"
            ]
        },
        "sample_code": {
            "c++": "#include <unordered_map>\n\nint numberOfBoomerangs(vector<vector<int>>& points) {\n    int count = 0;\n\n    for (auto& i : points) {\n        unordered_map<int, int> group_count;\n        for (auto& j : points) {\n            int dx = i[0] - j[0], dy = i[1] - j[1];\n            int dist = dx * dx + dy * dy;\n            group_count[dist]++;\n        }\n\n        for (auto& g : group_count) {\n            count += g.second * (g.second - 1);\n        }\n    }\n\n    return count;\n}\n",
            "java": "import java.util.HashMap;\n\npublic int numberOfBoomerangs(int[][] points) {\n    int count = 0;\n\n    for (int[] i : points) {\n        HashMap<Integer, Integer> group_count = new HashMap<>();\n        for (int[] j : points) {\n            int dx = i[0] - j[0], dy = i[1] - j[1];\n            int dist = dx * dx + dy * dy;\n\n            group_count.put(dist, group_count.getOrDefault(dist, 0) + 1);\n        }\n\n        for (int g : group_count.values()) {\n            count += g * (g - 1);\n        }\n    }\n\n    return count;\n}\n",
            "python": "def numberOfBoomerangs(points):\n    count = 0\n\n    for i in points:\n        group_count = {}\n        for j in points:\n            dx, dy = i[0] - j[0], i[1] - j[1]\n            dist = dx * dx + dy * dy\n            group_count[dist] = group_count.get(dist, 0) + 1\n\n        for g in group_count.values():\n            count += g * (g - 1)\n\n    return count\n",
            "javascript": "function numberOfBoomerangs(points) {\n    let count = 0;\n\n    for (let i of points) {\n        let group_count = new Map();\n        for (let j of points) {\n            let dx = i[0] - j[0], dy = i[1] - j[1];\n            let dist = dx * dx + dy * dy;\n            group_count.set(dist, (group_count.get(dist) || 0) + 1);\n        }\n\n        for (let g of group_count.values()) {\n            count += g * (g - 1);\n        }\n    }\n\n    return count;\n}\n",
            "explanation": "1. For every point `i` in the input, we create a hash map called `group_count` to store the count of points with the same distance from point `i`.\n2. For every point `j`, we calculate the squared distance from `i` to `j`. We use the squared distance to avoid using a square root function, as it's not necessary for this problem.\n3. Increment the count of the squared distance in `group_count`.\n4. To calculate the number of boomerangs, iterate through the values of `group_count`. For every count `g`, we have `g * (g - 1)` boomerangs because there are `g` choices for the second point and `g - 1` choices for the third point.\n5. Return the total number of boomerangs."
        },
        "structure": {
            "c++": "#include <unordered_map>\n\nint numberOfBoomerangs(vector<vector<int>>& points) \n    // Your code here\n}\n",
            "java": "import java.util.HashMap;\n\npublic int numberOfBoomerangs(int[][] points) \n    // Your code here\n}\n",
            "python": "def numberOfBoomerangs(points):\n    # Your code here\n\n",
            "javascript": "function numberOfBoomerangs(points) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <unordered_map>\n#include <vector>\n#include <iostream>\n\nint numberOfBoomerangs(vector<vector<int>>& points) {\n    int count = 0;\n\n    for (auto& i : points) {\n        unordered_map<int, int> group_count;\n        for (auto& j : points) {\n            int dx = i[0] - j[0], dy = i[1] - j[1];\n            int dist = dx * dx + dy * dy;\n            group_count[dist]++;\n        }\n\n        for (auto& g : group_count) {\n            count += g.second * (g.second - 1);\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    vector<vector<int>> points = $args;\n    int result = numberOfBoomerangs(points);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int numberOfBoomerangs(int[][] points) {\n    int count = 0;\n\n    for (int[] i : points) {\n        HashMap<Integer, Integer> group_count = new HashMap<>();\n        for (int[] j : points) {\n            int dx = i[0] - j[0], dy = i[1] - j[1];\n            int dist = dx * dx + dy * dy;\n\n            group_count.put(dist, group_count.getOrDefault(dist, 0) + 1);\n        }\n\n        for (int g : group_count.values()) {\n            count += g * (g - 1);\n        }\n    }\n\n    return count;\n}",
            "python": "if __name__ == \"__main__\":\n    points = $args[0]\n    result = numberOfBoomerangs(points)\n    print(result)",
            "javascript": "function main() {\n    const points = $args;\n    const result = numberOfBoomerangs(points);\n    console.log(result);\n}"
        }
    },
    "448": {
        "title": "Missing Numbers",
        "description": "Given an array `nums` of `n` integers where `nums[i]` is in the range `[1, n]`, return an array of all the integers in the range `[1, n]` that do not appear in `nums`.",
        "example": "Example 1:\n\nInput: nums = [4,3,2,7,8,2,3,1]\nOutput: [5,6]\n\nExample 2:\n\nInput: nums = [1,1]\nOutput: [2]",
        "level": "Easy",
        "tags": [
            "Array",
            "Sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    4,
                    3,
                    2,
                    7,
                    8,
                    2,
                    3,
                    1
                ],
                [
                    1,
                    1
                ],
                [
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1
                ],
                [
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99,
                    100
                ]
            ],
            "outputs": [
                "[5,6]",
                "[2]",
                "[]",
                "[]",
                "[1,2,3,4,6,7,8,9,10]",
                "[]",
                "[]",
                "[2]",
                "[1]",
                "[]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> findDisappearedNumbers(vector<int> &nums) {\n    vector<int> result;\n    \n    for (int i = 0; i < nums.size(); ++i) {\n        int index = abs(nums[i]) - 1;\n        nums[index] = -abs(nums[index]);\n    }\n    \n    for (int i = 0; i < nums.size(); ++i) {\n        if (nums[i] > 0) {\n            result.push_back(i + 1);\n        }\n    }\n    \n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> findDisappearedNumbers(int[] nums) {\n    List<Integer> result = new ArrayList<>();\n    \n    for (int i = 0; i < nums.length; i++) {\n        int index = Math.abs(nums[i]) - 1;\n        nums[index] = -Math.abs(nums[index]);\n    }\n\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] > 0) {\n            result.add(i + 1);\n        }\n    }\n\n    return result;\n}\n",
            "python": "def find_disappeared_numbers(nums):\n    result = []\n    \n    for num in nums:\n        index = abs(num) - 1\n        nums[index] = -abs(nums[index])\n\n    for i, num in enumerate(nums):\n        if num > 0:\n            result.append(i + 1)\n\n    return result\n",
            "javascript": "function findDisappearedNumbers(nums) {\n    const result = [];\n\n    for (let i = 0; i < nums.length; i++) {\n        const index = Math.abs(nums[i]) - 1;\n        nums[index] = -Math.abs(nums[index]);\n    }\n\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] > 0) {\n            result.push(i + 1);\n        }\n    }\n\n    return result;\n}\n",
            "explanation": "The algorithm works as follows:\n\n1. Iterate through the input array.\n2. For each value `nums[i]`, find its index by subtracting 1 (`index = abs(nums[i]) - 1`). This is because the integers in the range are 1 to n, and indices are 0-indexed.\n3. Negate the value at this index (`nums[index] = -abs(nums[index])`). This marks the value as \"found\".\n4. Iterate through the modified array.\n5. If a value is positive, it means the integer corresponding to that index hasn't been found. Add it to the result array.\n\nThis algorithm has a time complexity of O(n) and doesn't use any additional space other than the result array."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> findDisappearedNumbers(vector<int> &nums) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> findDisappearedNumbers(int[] nums) \n    // Your code here\n}\n",
            "python": "def find_disappeared_numbers(nums):\n    # Your code here\n\n",
            "javascript": "function findDisappearedNumbers(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nint main() {\n    vector<int> nums = $args;\n    vector<int> result = findDisappearedNumbers(nums);\n    \n    for (int i = 0; i < result.size(); ++i) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n",
            "java": "public List<Integer> findDisappearedNumbers(int[] nums) {\n    List<Integer> result = new ArrayList<>();\n    \n    for (int i = 0; i < nums.length; i++) {\n        int index = Math.abs(nums[i]) - 1;\n        nums[index] = -Math.abs(nums[index]);\n    }\n\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] > 0) {\n            result.add(i + 1);\n        }\n    }\n\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = find_disappeared_numbers(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = findDisappearedNumbers(nums);\n    console.log(result);\n}"
        }
    },
    "451": {
        "title": "Sort String by Character Frequency",
        "description": "Given a string `s`, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string. Return the sorted string. If there are multiple answers, return any of them.",
        "example": "Example 1:\n\nInput: s = \"tree \"\nOutput: \"eert \"\nExplanation: 'e' appears twice while 'r' and 't' both appear once. So 'e' must appear before both 'r' and 't'. Therefore \"eetr \" is also a valid answer.\n\nExample 2:\n\nInput: s = \"cccaaa \"\nOutput: \"aaaccc \"\nExplanation: Both 'c' and 'a' appear three times, so both \"cccaaa \" and \"aaaccc \" are valid answers. Note that \"cacaca \" is incorrect, as the same characters must be together.\n\nExample 3:\n\nInput: s = \"Aabb \"\nOutput: \"bbAa \"\nExplanation: \"bbaA \" is also a valid answer, but \"Aabb \" is incorrect. Note that 'A' and 'a' are treated as two different characters.",
        "level": "Easy",
        "tags": [
            "string",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "\"tree \"",
                "\"cccaaa \"",
                "\"Aabb \"",
                "\"hello world\"",
                "\"aabbbcccdddeeefff\"",
                "\"abcde\"",
                "\"aaaaa\"",
                "\"bbbbb\"",
                "\"ccccc\"",
                "\"ddddd\"",
                "\"eeeee\"",
                "\"ffffff\"",
                "\"gggggg\"",
                "\"hhhhhh\"",
                "\"iiiiii\"",
                "\"jjjjjj\"",
                "\"kkkkkk\"",
                "\"llllll\"",
                "\"mmmmmm\"",
                "\"nnnnnn\"",
                "\"oooooo\"",
                "\"pppppp\"",
                "\"qqqqqq\"",
                "\"rrrrrr\"",
                "\"ssssss\"",
                "\"tttttt\"",
                "\"uuuuuu\"",
                "\"vvvvvv\"",
                "\"wwwwww\"",
                "\"xxxxxx\"",
                "\"yyyyyy\"",
                "\"zzzzzz\""
            ],
            "outputs": [
                "\"eert \"",
                "\"aaaccc \"",
                "\"bbAa \"",
                "\"llllldeohrw \"",
                "\"eeefffdddbbbccc \"",
                "\"edcba\"",
                "\"aaaaa\"",
                "\"bbbbb\"",
                "\"ccccc\"",
                "\"ddddd\"",
                "\"eeeee\"",
                "\"ffffff\"",
                "\"gggggg\"",
                "\"hhhhhh\"",
                "\"iiiiii\"",
                "\"jjjjjj\"",
                "\"kkkkkk\"",
                "\"llllll\"",
                "\"mmmmmm\"",
                "\"nnnnnn\"",
                "\"oooooo\"",
                "\"pppppp\"",
                "\"qqqqqq\"",
                "\"rrrrrr\"",
                "\"ssssss\"",
                "\"tttttt\"",
                "\"uuuuuu\"",
                "\"vvvvvv\"",
                "\"wwwwww\"",
                "\"xxxxxx\"",
                "\"yyyyyy\"",
                "\"zzzzzz\""
            ]
        },
        "sample_code": {
            "c++": "#include <unordered_map>\n#include <vector>\n#include <algorithm>\n\nstd::string sortByFrequency(std::string s) {\n    std::unordered_map<char, int> freq;\n    std::vector<char> chars(s.begin(), s.end());\n    \n    for (char c : s)\n        freq[c]++;\n        \n    std::sort(chars.begin(), chars.end(), \n              [&](char a, char b) { return freq[a] > freq[b]; });\n              \n    return std::string(chars.begin(), chars.end());\n}\n",
            "java": "import java.util.*;\n\npublic String sortByFrequency(String s) {\n    Map<Character, Integer> freq = new HashMap<>();\n    Character[] chars = new Character[m.length()];\n    \n    for (int i = 0; i < m.length(); i++) {\n        chars[i] = m.charAt(i);\n        freq.put(chars[i], freq.getOrDefault(chars[i], 0) + 1);\n    }\n    \n    Arrays.sort(chars, (a, b) -> freq.get(b).compareTo(freq.get(a)));\n    \n    StringBuilder sb = new StringBuilder();\n    for (Character c : chars) {\n        sb.append(c);\n    }\n    return sb.toString();\n}\n",
            "python": "from collections import Counter\n\ndef sort_by_frequency(s):\n    freq = Counter(s)\n    chars = list(s)\n    chars.sort(key=lambda c: freq[c], reverse=True)\n    return ''.join(chars)\n",
            "javascript": "function sortByFrequency(s) {\n    const freq = {};\n    const chars = [...s];\n    \n    for (const c of s)\n        freq[c] = (freq[c] || 0) + 1;\n        \n    chars.sort((a, b) => freq[b] - freq[a]);\n    \n    return chars.join('');\n}\n",
            "explanation": "1. Create a frequency map `freq` to store the frequency of each character in the input string.\n2. Create an array or list `chars` containing all characters of the input string.\n3. Loop through the input string and increment the frequency count for each character in the frequency map.\n4. Sort the `chars` array or list based on the frequency of each character in the frequency map in descending order (higher frequency first).\n5. Combine the sorted `chars` array or list into a string and return the result."
        },
        "structure": {
            "c++": "#include <unordered_map>\n#include <vector>\n#include <algorithm>\n\nstd::string sortByFrequency(std::string s) \n    // Your code here\n}\n",
            "java": "import java.util.*;\n\npublic String sortByFrequency(String s) \n    // Your code here\n}\n",
            "python": "from collections import Counter\n    # Your code here\n\n",
            "javascript": "function sortByFrequency(s) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <unordered_map>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::string s = $args;\n    std::string result = sortByFrequency(s);\n    std::cout << result << std::endl;\n    return 0;\n}"
        }
    },
    "452": {
        "title": "Minimum Number of Arrows to Burst Balloons",
        "description": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array `points` where `points[i] = [xstart, xend]` denotes a balloon whose **horizontal diameter** stretches between `xstart` and `xend`. You do not know the exact y-coordinates of the balloons.\n\nArrows can be shot up **directly vertically** (in the positive y-direction) from different points along the x-axis. A balloon with `xstart` and `xend` is **burst** by an arrow shot at `x` if `xstart <= x <= xend`. There is **no limit** to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\n\nGiven the array `points`, return the **minimum** number of arrows that must be shot to burst all balloons.",
        "example": "Example:\n\nInput: points = [[10,16],[2,8],[1,6],[7,12]]\nOutput: 2\nExplanation: The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 6, bursting the balloons [[2,8]] and [[1,6]].\n- Shoot an arrow at x = 11, bursting the balloons [[10,16]] and [[7,12]].",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        10,
                        16
                    ],
                    [
                        2,
                        8
                    ],
                    [
                        1,
                        6
                    ],
                    [
                        7,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        3,
                        6
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        3,
                        8
                    ],
                    [
                        4,
                        7
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ],
                    [
                        19,
                        20
                    ]
                ]
            ],
            "outputs": [
                "2",
                "4",
                "2",
                "2",
                "1",
                "2",
                "2",
                "2",
                "2",
                "2",
                "2",
                "2",
                "2",
                "2",
                "2",
                "2",
                "2",
                "2",
                "2",
                "2"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\n\nint findMinArrowShots(std::vector<std::vector<int>>& points) {\n    if (points.empty()) return 0;\n    std::sort(points.begin(), points.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[1] < b[1];\n    });\n\n    int arrows = 1;\n    int end = points[0][1];\n\n    for (int i = 1; i < points.size(); ++i) {\n        if (points[i][0] > end) {\n            arrows++;\n            end = points[i][1];\n        }\n    }\n\n    return arrows;\n}\n",
            "java": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic int findMinArrowShots(int[][] points) {\n    if (points.length == 0) return 0;\n    Arrays.sort(points, Comparator.comparingInt(a -> a[1]));\n\n    int arrows = 1;\n    int end = points[0][1];\n\n    for (int i = 1; i < points.length; i++) {\n        if (points[i][0] > end) {\n            arrows++;\n            end = points[i][1];\n        }\n    }\n\n    return arrows;\n}\n",
            "python": "def findMinArrowShots(points):\n    if not points:\n        return 0\n    points.sort(key=lambda x: x[1])\n\n    arrows = 1\n    end = points[0][1]\n\n    for i in range(1, len(points)):\n        if points[i][0] > end:\n            arrows += 1\n            end = points[i][1]\n\n    return arrows\n",
            "javascript": "function findMinArrowShots(points) {\n    if (points.length === 0) return 0;\n    points.sort((a, b) => a[1] - b[1]);\n\n    let arrows = 1;\n    let end = points[0][1];\n\n    for (let i = 1; i < points.length; i++) {\n        if (points[i][0] > end) {\n            arrows++;\n            end = points[i][1];\n        }\n    }\n\n    return arrows;\n}\n",
            "explanation": "The algorithm sorts the given points by the end value of their ranges. Then, it initializes a variable `arrows` to 1 (to count the first arrow) and `end` to the end value of the first point (to keep track of the last point reached by arrows).\n\nThen, it iterates through the array, starting from the second point to the end. For each point, it checks whether the start value is greater than the current `end` value. If it is, that means this point is not covered by the previous arrows, so it increments the `arrows` counter and updates `end` to the end value of the current point.\n\nFinally, it returns the value of `arrows` as the minimum number of arrows needed to burst all balloons. "
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\n\nint findMinArrowShots(std::vector<std::vector<int>>& points) \n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic int findMinArrowShots(int[][] points) \n    // Your code here\n}\n",
            "python": "def findMinArrowShots(points):\n    # Your code here\n\n",
            "javascript": "function findMinArrowShots(points) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nint main() {\n    std::vector<std::vector<int>> points = $args;\n    int result = findMinArrowShots(points);\n    std::cout << result << std::endl;\n    return 0;\n}"
        }
    },
    "453": {
        "title": "Minimum Moves to Equal Array Elements",
        "description": "Given an integer array `nums` of size `n`, you need to find the minimum number of moves required to make all array elements equal. In one move, you can increment `n - 1` elements of the array by `1`.",
        "example": "Example:\n\nInput: nums = [1,2,3]\nOutput: 3\nExplanation: Only three moves are needed (remember each move increments two elements):\n[1,2,3] => [2,3,3] => [3,4,3] => [4,4,4]",
        "level": "Easy",
        "tags": [
            "array",
            "math"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3
                ],
                [
                    1,
                    1,
                    1
                ],
                [
                    5,
                    5,
                    5,
                    5
                ],
                [
                    2,
                    4,
                    6,
                    8
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50
                ],
                [
                    100,
                    200,
                    300,
                    400,
                    500
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    2
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    -1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    -2
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    100
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1000
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    10000
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    100000
                ]
            ],
            "outputs": [
                3,
                0,
                0,
                12,
                0,
                20,
                120,
                1200,
                45,
                45,
                0,
                0,
                1,
                1,
                2,
                2,
                99,
                999,
                9999,
                99999
            ]
        },
        "sample_code": {
            "c++": "int minMoves(vector<int>& nums) {\n    int min_element = *min_element(nums.begin(), nums.end());\n    int moves = 0;\n    for (int num : nums) {\n        moves += (num - min_element);\n    }\n    return moves;\n}\n\n",
            "java": "public int minMoves(int[] nums) {\n    int min_element = nums[0];\n    for (int num : nums) {\n        min_element = Math.min(min_element, num);\n    }\n    int moves = 0;\n    for (int num : nums) {\n        moves += (num - min_element);\n    }\n    return moves;\n}\n\n",
            "python": "def min_moves(nums):\n    min_element = min(nums)\n    moves = sum(num - min_element for num in nums)\n    return moves\n\n",
            "javascript": "function minMoves(nums) {\n    let min_element = Math.min(...nums);\n    let moves = nums.reduce((acc, num) => acc + (num - min_element), 0);\n    return moves;\n}\n\n",
            "explanation": "The algorithm works as follows:\n\n1. Find the minimum element in nums.\n2. Calculate the number of moves required to make other elements equal to the minimum element by summing the difference between each element and the minimum element (n-1 up moves for each number).\n3. Return the calculated number of moves.\n\nThe algorithm has a time complexity of O(n) as it iterates through the array twice. The space complexity is also O(n) in the case of the Python solution (due to list comprehensions), otherwise O(1)."
        },
        "structure": {
            "c++": "int minMoves(vector<int>& nums) \n    // Your code here\n}\n\n",
            "java": "public int minMoves(int[] nums) \n    // Your code here\n}\n\n",
            "python": "def min_moves(nums):\n    # Your code here\n\n",
            "javascript": "function minMoves(nums) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> nums = $args;\n    int result = minMoves(nums);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int minMoves(int[] nums) {\n    int min_element = nums[0];\n    for (int num : nums) {\n        min_element = Math.min(min_element, num);\n    }\n    int moves = 0;\n    for (int num : nums) {\n        moves += (num - min_element);\n    }\n    return moves;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = min_moves(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = minMoves(nums);\n    console.log(result);\n}\n"
        }
    },
    "455": {
        "title": "Maximize Content Children",
        "description": "You are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child `i` has a greed factor `g[i]`, which is the minimum size of a cookie that the child will be content with; and each cookie `j` has a size `s[j]`. If `s[j] >= g[i]`, we can assign the cookie `j` to the child `i`, and the child `i` will be content. Your goal is to maximize the number of your content children and output the maximum number.",
        "example": "Example:\n\nInput: g = [1,2,3], s = [1,1]\nOutput: 1\nExplanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content. You need to output 1.",
        "level": "Easy",
        "tags": [
            "greedy",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3
                ],
                [
                    1,
                    1
                ],
                [
                    1,
                    2
                ],
                [
                    1,
                    2,
                    3
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ]
            ],
            "outputs": [
                "1",
                "1",
                "2",
                "2",
                "5",
                "5",
                "1",
                "2",
                "5",
                "5",
                "1",
                "2",
                "5",
                "5",
                "1",
                "2",
                "5",
                "5",
                "1",
                "2"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\n\nint findContentChildren(std::vector<int>& g, std::vector<int>& s) {\n    std::sort(g.begin(), g.end());\n    std::sort(s.begin(), s.end());\n    int i = 0, j = 0;\n\n    while (i < g.size() && j < s.size()) {\n      if (s[j] >= g[i]) {\n        i++;\n      }\n\n      j++;\n    }\n\n    return i;\n}\n\n",
            "java": "import java.util.Arrays;\n\npublic int findContentChildren(int[] g, int[] s) {\n    Arrays.sort(g);\n    Arrays.sort(s);\n    int i = 0, j = 0;\n\n    while (i < g.length && j < s.length) {\n        if (s[j] >= g[i]) {\n            i++;\n        }\n\n        j++;\n    }\n\n    return i;\n}\n\n",
            "python": "def find_content_children(g, s):\n    g.sort()\n    s.sort()\n    i = j = 0\n\n    while i < len(g) and j < len(s):\n        if s[j] >= g[i]:\n            i += 1\n\n        j += 1\n\n    return i\n\n",
            "javascript": "function findContentChildren(g, s) {\n    g.sort((a, b) => a - b);\n    s.sort((a, b) => a - b);\n    let i = 0, j = 0;\n\n    while (i < g.length && j < s.length) {\n        if (s[j] >= g[i]) {\n            i++;\n        }\n\n        j++;\n    }\n\n    return i;\n}\n\n",
            "explanation": "The algorithm first sorts both the greed factors of children `g` and the sizes of cookies `s`. Next, two pointers are declared, `i` for the greed factors and `j` for the cookies. \nThe algorithm then iterates through the sorted lists in parallel using a while loop until either the greed factors or the cookies run out. Inside the loop, we check if the current cookie `s[j]` is greater than or equal to the current greed factor `g[i]`. If it is, that means the child is content and we increment the `i` pointer to the next child. In both cases (whether the child is content or not), we move on to the next cookie by incrementing the `j` pointer.\nThe algorithm returns the number of content children (`i`) once the loop is done."
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\n\nint findContentChildren(std::vector<int>& g, std::vector<int>& s) \n    // Your code here\n}\n\n",
            "java": "import java.util.Arrays;\n\npublic int findContentChildren(int[] g, int[] s) \n    // Your code here\n}\n\n",
            "python": "def find_content_children(g, s):\n    # Your code here\n\n",
            "javascript": "function findContentChildren(g, s) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nint findContentChildren(std::vector<int>& g, std::vector<int>& s);\n\nint main() {\n    std::vector<int> g = $args;\n    std::vector<int> s;\n    int n;\n    while (std::cin >> n) {\n        s.push_back(n);\n    }\n    int result = findContentChildren(g, s);\n    std::cout << result << std::endl;\n    return 0;\n}\n"
        }
    },
    "456": {
        "title": "132 Pattern",
        "description": "Given an array of `n` integers `nums`, a **132 pattern** is a subsequence of three integers `nums[i]`, `nums[j]` and `nums[k]` such that `i < j < k` and `nums[i] < nums[k] < nums[j]`. Return `true` if there is a 132 pattern in `nums`, otherwise, return `false`.",
        "example": "Example:\n\nInput: nums = [1,2,3,4]\nOutput: false\nExplanation: There is no 132 pattern in the sequence.",
        "level": "Medium",
        "tags": [
            "array",
            "subsequence"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3,
                    4
                ],
                [
                    3,
                    1,
                    4,
                    2
                ],
                [
                    -1,
                    3,
                    2,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    5,
                    2,
                    4,
                    3
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    10,
                    2,
                    9,
                    3,
                    8,
                    4,
                    7,
                    5,
                    6
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    20,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    20,
                    2,
                    19,
                    3,
                    18,
                    4,
                    17,
                    5,
                    16,
                    6,
                    15,
                    7,
                    14,
                    8,
                    13,
                    9,
                    12,
                    10,
                    11
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30
                ],
                [
                    30,
                    29,
                    28,
                    27,
                    26,
                    25,
                    24,
                    23,
                    22,
                    21,
                    20,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    30,
                    2,
                    29,
                    3,
                    28,
                    4,
                    27,
                    5,
                    26,
                    6,
                    25,
                    7,
                    24,
                    8,
                    23,
                    9,
                    22,
                    10,
                    21,
                    11,
                    20,
                    12,
                    19,
                    13,
                    18,
                    14,
                    17,
                    15,
                    16
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5
                ],
                [
                    -5,
                    -4,
                    -3,
                    -2,
                    -1
                ],
                [
                    -1,
                    -5,
                    -2,
                    -4,
                    -3
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    -6,
                    -7,
                    -8,
                    -9,
                    -10
                ],
                [
                    -10,
                    -9,
                    -8,
                    -7,
                    -6,
                    -5,
                    -4,
                    -3,
                    -2,
                    -1
                ],
                [
                    -1,
                    -10,
                    -2,
                    -9,
                    -3,
                    -8,
                    -4,
                    -7,
                    -5,
                    -6
                ]
            ],
            "outputs": [
                false,
                true,
                true,
                false,
                false,
                true,
                false,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                false,
                true,
                false,
                true
            ]
        },
        "sample_code": {
            "c++": "bool find132pattern(vector<int>& nums) {\n    int n = nums.size(), third = INT_MIN;\n    stack<int> st;\n    for (int i = n - 1; i >= 0; --i) {\n        if (nums[i] < third) return true;\n        while (!st.empty() && st.top() < nums[i]) {\n            third = st.top(); st.pop();\n        }\n        st.push(nums[i]);\n    }\n    return false;\n}\n",
            "java": "public boolean find132pattern(int[] nums) {\n    int n = nums.length;\n    int[] min = new int[n];\n    min[0] = nums[0];\n    for (int i = 1; i < n; ++i) {\n        min[i] = Math.min(min[i - 1], nums[i]);\n    }\n    Stack<Integer> stack = new Stack<>();\n    for (int j = n - 1; j >= 0; --j) {\n        if (nums[j] > min[j]) {\n            while (!stack.isEmpty() && stack.peek() <= min[j]) {\n                stack.pop();\n            }\n            if (!stack.isEmpty() && stack.peek() < nums[j]) {\n                return true;\n            }\n            stack.push(nums[j]);\n        }\n    }\n    return false;\n}\n",
            "python": "def find132pattern(nums):\n    third, stack = float('-inf'), []\n    for num in reversed(nums):\n        if num < third:\n            return True\n        while stack and stack[-1] < num:\n            third = stack.pop()\n        stack.append(num)\n    return False\n",
            "javascript": "function find132pattern(nums) {\n    const stack = [];\n    let third = Number.MIN_SAFE_INTEGER;\n    for (let i = nums.length - 1; i >= 0; --i) {\n        if (nums[i] < third) {\n            return true;\n        }\n        while (stack.length && stack[stack.length - 1] < nums[i]) {\n            third = stack.pop();\n        }\n        stack.push(nums[i]);\n    }\n    return false;\n}\n",
            "explanation": "To find the 132 pattern, we iterate through the array from the end to the beginning. We use a stack to keep track of potential third elements (nums[k]) in the 132 pattern. We also keep track of the maximum third element found so far. If we find a number that is smaller than the maximum third element, we know that a 132 pattern exists.\n\nIn the Java and Python implementations, we also create a separate array to store the minimum values found so far from the start of the array, which helps in identifying the first element (nums[i]) in the 132 pattern. This step can be skipped in C++ and JavaScript implementations by directly comparing the first element (nums[i]) with the maximum third element stored in the stack.\n\nDuring the iteration, we check if the current number is smaller than the maximum third element, which would mean a 132 pattern has been found. If not, we update the maximum third element and the stack as necessary to continue searching for the 132 pattern. Finally, we return whether the 132 pattern has been found."
        },
        "structure": {
            "c++": "bool find132pattern(vector<int>& nums) \n    // Your code here\n}\n",
            "java": "public boolean find132pattern(int[] nums) \n    // Your code here\n}\n",
            "python": "def find132pattern(nums):\n    # Your code here\n\n",
            "javascript": "function find132pattern(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "bool find132pattern(vector<int>& nums) {\n    int n = nums.size(), third = INT_MIN;\n    stack<int> st;\n    for (int i = n - 1; i >= 0; --i) {\n        if (nums[i] < third) return true;\n        while (!st.empty() && st.top() < nums[i]) {\n            third = st.top(); st.pop();\n        }\n        st.push(nums[i]);\n    }\n    return false;\n}",
            "java": "public boolean find132pattern(int[] nums) {\n    int n = nums.length;\n    int[] min = new int[n];\n    min[0] = nums[0];\n    for (int i = 1; i < n; ++i) {\n        min[i] = Math.min(min[i - 1], nums[i]);\n    }\n    Stack<Integer> stack = new Stack<>();\n    for (int j = n - 1; j >= 0; --j) {\n        if (nums[j] > min[j]) {\n            while (!stack.isEmpty() && stack.peek() <= min[j]) {\n                stack.pop();\n            }\n            if (!stack.isEmpty() && stack.peek() < nums[j]) {\n                return true;\n            }\n            stack.push(nums[j]);\n        }\n    }\n    return false;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = find132pattern(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = find132pattern(nums);\n    console.log(result);\n}"
        }
    },
    "457": {
        "title": "Circular Array Cycle",
        "description": "You are given a circular array of non-zero integers `nums`. Each `nums[i]` denotes the number of indices forward/backward you must move if you are located at index `i`. If `nums[i]` is positive, move `nums[i]` steps forward, and if `nums[i]` is negative, move `nums[i]` steps backward. Since the array is circular, moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element. A cycle in the array consists of a sequence of indices `seq` of length `k` where following the movement rules results in the repeating index sequence `seq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ...`. Every `nums[seq[j]]` is either all positive or all negative, and `k > 1`. Write a function that returns `true` if there is a cycle in `nums`, or `false` otherwise.",
        "example": "Example:\n\nInput: nums = [2,-1,1,2,2]\nOutput: true\nExplanation: The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward. We can see the cycle 0 --> 2 --> 3 --> 0 --> ..., and all of its nodes are white (jumping in the same direction).",
        "level": "Medium",
        "tags": [
            "Array",
            "Graph"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    -1,
                    1,
                    2,
                    2
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    6
                ],
                [
                    1,
                    -1,
                    5,
                    1,
                    4
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    -1,
                    -1,
                    -1,
                    -1,
                    -1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5
                ],
                [
                    1,
                    -2,
                    3,
                    -4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    -5
                ],
                [
                    1,
                    -2,
                    3,
                    4,
                    -5
                ],
                [
                    1,
                    2,
                    3,
                    -4,
                    -5
                ],
                [
                    1,
                    -2,
                    3,
                    -4,
                    -5
                ],
                [
                    1,
                    2,
                    -3,
                    4,
                    5
                ],
                [
                    1,
                    -2,
                    -3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    -3,
                    -4,
                    5
                ],
                [
                    1,
                    -2,
                    -3,
                    -4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    -6,
                    -7,
                    -8,
                    -9,
                    -10
                ],
                [
                    1,
                    -1,
                    1,
                    -1,
                    1,
                    -1,
                    1,
                    -1,
                    1,
                    -1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "bool circularArrayLoop(vector<int>& nums) {\n    int N = nums.size();\n    for (int i = 0; i < N; i++) {\n        int slow = i, fast = i;\n        do {\n            slow = getNextIndex(slow, nums);\n            fast = getNextIndex(getNextIndex(fast, nums), nums);\n        } while (slow != fast && nums[slow] * nums[fast] > 0);\n\n        if (slow != fast) continue;\n        bool cycle = false;\n        int start = slow;\n        do {\n            cycle |= getNextIndex(start, nums) == start;\n            start = getNextIndex(start, nums);\n        } while (start != slow);\n        if (!cycle) return true;\n    }\n    return false;\n}\n\nint getNextIndex(int idx, vector<int>& nums) {\n    int N = nums.size();\n    return ((idx + nums[idx]) % N + N) % N;\n}\n\n",
            "java": "public boolean circularArrayLoop(int[] nums) {\n    int N = nums.length;\n    for (int i = 0; i < N; i++) {\n        int slow = i, fast = i;\n        do {\n            slow = getNextIndex(slow, nums);\n            fast = getNextIndex(getNextIndex(fast, nums), nums);\n        } while (slow != fast && nums[slow] * nums[fast] > 0);\n\n        if (slow != fast) continue;\n        boolean cycle = false;\n        int start = slow;\n        do {\n            cycle |= getNextIndex(start, nums) == start;\n            start = getNextIndex(start, nums);\n        } while (start != slow);\n        if (!cycle) return true;\n    }\n    return false;\n}\n\nint getNextIndex(int idx, int[] nums) {\n    int N = nums.length;\n    return ((idx + nums[idx]) % N + N) % N;\n}\n\n",
            "python": "def circularArrayLoop(nums: List[int]) -> bool:\n    N = len(nums)\n    for i in range(N):\n        slow, fast = i, i\n        while True:\n            slow = getNextIndex(slow, nums)\n            fast = getNextIndex(getNextIndex(fast, nums), nums)\n            if slow != fast and nums[slow] * nums[fast] > 0:\n                break\n            if slow == fast:\n                break\n        else:\n            continue\n        cycle = False\n        start = slow\n        while start != slow:\n            cycle |= getNextIndex(start, nums) == start\n            start = getNextIndex(start, nums)\n        if not cycle:\n            return True\n    return False\n\ndef getNextIndex(idx: int, nums: List[int]) -> int:\n    N = len(nums)\n    return (idx + nums[idx]) % N\n\n",
            "javascript": "function circularArrayLoop(nums) {\n  const N = nums.length;\n  for (let i = 0; i < N; i++) {\n    let slow = i, fast = i;\n    do {\n      slow = getNextIndex(slow, nums);\n      fast = getNextIndex(getNextIndex(fast, nums), nums);\n    } while (slow !== fast && nums[slow] * nums[fast] > 0);\n\n    if (slow !== fast) continue;\n    let cycle = false;\n    let start = slow;\n    do {\n      cycle |= getNextIndex(start, nums) === start;\n      start = getNextIndex(start, nums);\n    } while (start !== slow);\n    if (!cycle) return true;\n  }\n  return false;\n}\n\nfunction getNextIndex(idx, nums) {\n    const N = nums.length;\n    return ((idx + nums[idx]) % N + N) % N;\n}\n\n",
            "explanation": "The algorithm is designed to detect a cycle in a circular array. It uses a slow and fast pointer approach inspired by the \"Floyd's Tortoise and Hare\" algorithm. The slow pointer moves one step at a time and the fast pointer moves two steps at a time. If there is a cycle in the array, the slow and fast pointers will eventually meet at the same index.\n\nThe algorithm iterates through the entire array to detect any possible cycle with the given starting index. For each index, the slow and fast pointers are initialized, and the getNextIndex function is used to get the next index, considering the circular nature of the array. The loop continues to execute as long as the slow and fast pointers are different and the product of nums[slow] and nums[fast] is positive.\n\nIf the slow and fast pointers meet, there is a possibility of having a cycle. To verify this, the algorithm checks if there is a cycle by traversing from the start index, and if there is no cycle, it returns true. If no cycle is found, the algorithm continues to search the array for cycles.\n\nFinally, if there is no cycle in the whole array, it returns false."
        },
        "structure": {
            "c++": "bool circularArrayLoop(vector<int>& nums) \n    // Your code here\n}\n\n",
            "java": "public boolean circularArrayLoop(int[] nums) \n    // Your code here\n}\n\n",
            "python": "def circularArrayLoop(nums: List[int]) -> bool:\n    # Your code here\n\n",
            "javascript": "function circularArrayLoop(nums) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "bool circularArrayLoop(vector<int>& nums) {\n    int N = nums.size();\n    for (int i = 0; i < N; i++) {\n        int slow = i, fast = i;\n        do {\n            slow = getNextIndex(slow, nums);\n            fast = getNextIndex(getNextIndex(fast, nums), nums);\n        } while (slow != fast && nums[slow] * nums[fast] > 0);\n\n        if (slow != fast) continue;\n        bool cycle = false;\n        int start = slow;\n        do {\n            cycle |= getNextIndex(start, nums) == start;\n            start = getNextIndex(start, nums);\n        } while (start != slow);\n        if (!cycle) return true;\n    }\n    return false;\n}\n\nint getNextIndex(int idx, vector<int>& nums) {\n    int N = nums.size();\n    return ((idx + nums[idx]) % N + N) % N;\n}",
            "java": "public boolean circularArrayLoop(int[] nums) {\n    int N = nums.length;\n    for (int i = 0; i < N; i++) {\n        int slow = i, fast = i;\n        do {\n            slow = getNextIndex(slow, nums);\n            fast = getNextIndex(getNextIndex(fast, nums), nums);\n        } while (slow != fast && nums[slow] * nums[fast] > 0);\n\n        if (slow != fast) continue;\n        boolean cycle = false;\n        int start = slow;\n        do {\n            cycle |= getNextIndex(start, nums) == start;\n            start = getNextIndex(start, nums);\n        } while (start != slow);\n        if (!cycle) return true;\n    }\n    return false;\n}\n\nint getNextIndex(int idx, int[] nums) {\n    int N = nums.length;\n    return ((idx + nums[idx]) % N + N) % N;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = circularArrayLoop(nums)\n    print(result)",
            "javascript": "function main() {\n  const nums = $args;\n  const result = circularArrayLoop(nums);\n  console.log(result);\n}"
        }
    },
    "458": {
        "title": "Minimum Number of Pigs",
        "description": "There are `buckets` buckets of liquid, where **exactly one** of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have `minutesToTest` minutes to determine which bucket is poisonous.\n\nYou can feed the pigs according to these steps:\n\n1. Choose some live pigs to feed.\n2. For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs.\n3. Wait for `minutesToDie` minutes. You may **not** feed any other pigs during this time.\n4. After `minutesToDie` minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.\n5. Repeat this process until you run out of time.\n\nGiven `buckets`, `minutesToDie`, and `minutesToTest`, return the **minimum** number of pigs needed to figure out which bucket is poisonous within the allotted time.",
        "example": "Example:\n\nInput: buckets = 4, minutesToDie = 15, minutesToTest = 15\nOutput: 2\nExplanation: We can determine the poisonous bucket as follows:\nAt time 0, feed the first pig buckets 1 and 2, and feed the second pig buckets 2 and 3.\nAt time 15, there are 4 possible outcomes:\n- If only the first pig dies, then bucket 1 must be poisonous.\n- If only the second pig dies, then bucket 3 must be poisonous.\n- If both pigs die, then bucket 2 must be poisonous.\n- If neither pig dies, then bucket 4 must be poisonous.",
        "level": "Medium",
        "tags": [
            "math",
            "logic"
        ],
        "test_cases": {
            "inputs": [
                [
                    4,
                    15,
                    15
                ],
                [
                    4,
                    15,
                    30
                ],
                [
                    1,
                    1,
                    1
                ],
                [
                    10,
                    5,
                    10
                ],
                [
                    100,
                    10,
                    100
                ],
                [
                    1000,
                    100,
                    100
                ],
                [
                    5,
                    10,
                    10
                ],
                [
                    2,
                    5,
                    5
                ],
                [
                    3,
                    5,
                    10
                ],
                [
                    7,
                    7,
                    7
                ],
                [
                    20,
                    10,
                    20
                ],
                [
                    50,
                    5,
                    50
                ],
                [
                    100,
                    1,
                    100
                ],
                [
                    1000,
                    100,
                    1000
                ],
                [
                    10,
                    10,
                    10
                ],
                [
                    3,
                    1,
                    3
                ],
                [
                    5,
                    5,
                    5
                ],
                [
                    2,
                    2,
                    2
                ],
                [
                    1,
                    100,
                    100
                ],
                [
                    1000,
                    1000,
                    1000
                ]
            ],
            "outputs": [
                2,
                2,
                1,
                2,
                10,
                10,
                2,
                2,
                2,
                2,
                4,
                5,
                100,
                10,
                2,
                1,
                2,
                1,
                1,
                10
            ]
        },
        "sample_code": {
            "c++": "int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n    int pigs = 0;\n    while (pow((minutesToTest / minutesToDie) + 1, pigs) < buckets) {\n        pigs++;\n    }\n    return pigs;\n}\n\n",
            "java": "public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n    int pigs = 0;\n    while (Math.pow((minutesToTest / minutesToDie) + 1, pigs) < buckets) {\n        pigs++;\n    }\n    return pigs;\n}\n\n",
            "python": "def poor_pigs(buckets, minutes_to_die, minutes_to_test):\n    pigs = 0\n    while (minutes_to_test // minutes_to_die + 1) ** pigs < buckets:\n        pigs += 1\n    return pigs\n\n",
            "javascript": "function poorPigs(buckets, minutesToDie, minutesToTest) {\n    let pigs = 0;\n    while (Math.pow(Math.floor(minutesToTest / minutesToDie) + 1, pigs) < buckets) {\n        pigs++;\n    }\n    return pigs;\n}\n\n",
            "explanation": "The algorithm calculates the minimum number of pigs required to test all the buckets within the given time constraint. It is based on the fact that each pig can be used to test multiple buckets (in a binary search manner) within the time constraint, as it is repeatedly fed different buckets.\n\n1. Initialize the number of pigs to 0.\n2. Calculate the maximum number of tests each pig can make within the given time constraint (`minutesToTest / minutesToDie + 1`).\n3. Iterate and increment the number of pigs until the total number of buckets is less than the power of the number of tests each pig can make to the number of pigs.\n4. Return the minimum number of pigs required.\n\nThe algorithm leverages the multi-level testing capacity of the pigs within the given time frame to minimize the number of pigs needed. Each pig represents an additional level of testing capacity, reducing the total number of tests needed."
        },
        "structure": {
            "c++": "int poorPigs(int buckets, int minutesToDie, int minutesToTest) \n    // Your code here\n}\n\n",
            "java": "public int poorPigs(int buckets, int minutesToDie, int minutesToTest) \n    // Your code here\n}\n\n",
            "python": "def poor_pigs(buckets, minutes_to_die, minutes_to_test):\n    # Your code here\n\n",
            "javascript": "function poorPigs(buckets, minutesToDie, minutesToTest) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int buckets = $args;\n    int minutesToDie = $args;\n    int minutesToTest = $args;\n    int result = poorPigs(buckets, minutesToDie, minutesToTest);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int main(int buckets, int minutesToDie, int minutesToTest) {\n    int pigs = 0;\n    while (Math.pow((minutesToTest / minutesToDie) + 1, pigs) < buckets) {\n        pigs++;\n    }\n    return pigs;\n}",
            "python": "if __name__ == \"__main__\":\n    buckets = $args[0]\n    minutes_to_die = $args[1]\n    minutes_to_test = $args[2]\n    result = poor_pigs(buckets, minutes_to_die, minutes_to_test)\n    print(result)",
            "javascript": "function main() {\n    const buckets = $args[0];\n    const minutesToDie = $args[1];\n    const minutesToTest = $args[2];\n    const result = poorPigs(buckets, minutesToDie, minutesToTest);\n    console.log(result);\n}"
        }
    },
    "461": {
        "title": "Hamming Distance",
        "description": "The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, write a function to return the Hamming distance between them.",
        "example": "Example:\n\nInput: x = 1, y = 4\nOutput: 2\nExplanation:\n1   (0 0 0 1)\n4   (0 1 0 0)\n       -->   -->\nThe above arrows point to positions where the corresponding bits are different.",
        "level": "Easy",
        "tags": [
            "bit manipulation",
            "math"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    4
                ],
                [
                    3,
                    1
                ],
                [
                    0,
                    0
                ],
                [
                    7,
                    7
                ],
                [
                    10,
                    5
                ],
                [
                    15,
                    0
                ],
                [
                    255,
                    0
                ],
                [
                    255,
                    255
                ],
                [
                    231,
                    231
                ],
                [
                    231,
                    0
                ],
                [
                    0,
                    231
                ],
                [
                    2147483647,
                    0
                ],
                [
                    0,
                    2147483647
                ],
                [
                    2147483647,
                    2147483647
                ],
                [
                    2147483647,
                    1
                ],
                [
                    1,
                    2147483647
                ]
            ],
            "outputs": [
                2,
                1,
                0,
                0,
                4,
                4,
                8,
                0,
                0,
                8,
                8,
                31,
                31,
                0,
                31,
                31
            ]
        },
        "sample_code": {
            "c++": "int hammingDistance(int x, int y) {\n    int dist = 0, xorResult = x ^ y;\n    while (xorResult) {\n        dist += xorResult & 1;\n        xorResult >>= 1;\n    }\n    return dist;\n}\n",
            "java": "public int hammingDistance(int x, int y) {\n    int dist = 0, xorResult = x ^ y;\n    while (xorResult != 0) {\n        dist += xorResult & 1;\n        xorResult >>= 1;\n    }\n    return dist;\n}\n",
            "python": "def hammingDistance(x: int, y: int) -> int:\n    xorResult = x ^ y\n    dist = 0\n    while xorResult:\n        dist += xorResult & 1\n        xorResult >>= 1\n    return dist\n",
            "javascript": "function hammingDistance(x, y) {\n    let dist = 0;\n    let xorResult = x ^ y;\n    while (xorResult != 0) {\n        dist += xorResult & 1;\n        xorResult >>= 1;\n    }\n    return dist;\n}\n",
            "explanation": "We can start by taking the XOR of `x` and `y`. A XOR B value will have a bit set only if both A and B bits are different at that position. We then iterate through the bits of the XOR result, counting the number of set bits, which should give us the Hamming distance required.\n\n1. Calculate `xorResult` by XORing `x` and `y`.\n2. Initialize `dist` to 0.\n3. While `xorResult` is not 0, do the following:\n   a. Add the least significant bit of `xorResult` to `dist`.\n   b. Right shift `xorResult` by 1.\n4. Return `dist`.\n\nThis algorithm performs bitwise operations and loops through the bits of `xorResult`, which has a maximum of 31 bits due to the constraint `0 <= x, y <= 2^31 - 1`. Thus, the time complexity is O(31) = O(1)."
        },
        "structure": {
            "c++": "int hammingDistance(int x, int y) \n    // Your code here\n}\n",
            "java": "public int hammingDistance(int x, int y) \n    // Your code here\n}\n",
            "python": "def hammingDistance(x: int, y: int) -> int:\n    # Your code here\n\n",
            "javascript": "function hammingDistance(x, y) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int x = $args;\n    int y = $args;\n    int result = hammingDistance(x, y);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int hammingDistance(int x, int y) {\n    int dist = 0, xorResult = x ^ y;\n    while (xorResult != 0) {\n        dist += xorResult & 1;\n        xorResult >>= 1;\n    }\n    return dist;\n}",
            "python": "if __name__ == \"__main__\":\n    x = $args[0]\n    y = $args[1]\n    result = hammingDistance(x, y)\n    print(result)",
            "javascript": "function main() {\n    const x = $args[0];\n    const y = $args[1];\n    const result = hammingDistance(x, y);\n    console.log(result);\n}"
        }
    },
    "462": {
        "title": "Minimum Moves to Equal Array Elements",
        "description": "Given an integer array `nums` of size `n`, you need to find the minimum number of moves required to make all array elements equal. In one move, you can increment or decrement an element of the array by `1`. Return the minimum number of moves required.",
        "example": "Example:\n\nInput: nums = [1,2,3]\nOutput: 2\nExplanation: Only two moves are needed (remember each move increments or decrements one element):\n[1,2,3] => [2,2,3] => [2,2,2]",
        "level": "Easy",
        "tags": [
            "array",
            "math"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3
                ],
                [
                    1,
                    10,
                    2,
                    9
                ],
                [
                    5,
                    5,
                    5,
                    5
                ],
                [
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50
                ],
                [
                    100,
                    200,
                    300,
                    400,
                    500
                ],
                [
                    1,
                    100,
                    1000,
                    10000
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100
                ]
            ],
            "outputs": [
                2,
                16,
                0,
                0,
                0,
                10,
                100,
                1000,
                9999,
                550
            ]
        },
        "sample_code": {
            "c++": "int minMoves2(vector<int>& nums) {\n    int n = nums.size();\n    sort(nums.begin(), nums.end());\n    int mid = nums[n / 2];\n    int moves = 0;\n    for (int i = 0; i < n; i++) {\n        moves += abs(nums[i] - mid);\n    }\n    return moves;\n}\n",
            "java": "public int minMoves2(int[] nums) {\n    Arrays.sort(nums);\n    int mid = nums[nums.length / 2];\n    int moves = 0;\n    for (int num : nums) {\n        moves += Math.abs(num - mid);\n    }\n    return moves;\n}\n",
            "python": "def min_moves2(nums):\n    nums.sort()\n    mid = nums[len(nums) // 2]\n    moves = 0\n    for num in nums:\n        moves += abs(num - mid)\n    return moves\n",
            "javascript": "function minMoves2(nums) {\n    nums.sort((a, b) => a - b);\n    const mid = nums[Math.floor(nums.length / 2)];\n    let moves = 0;\n    for (const num of nums) {\n        moves += Math.abs(num - mid);\n    }\n    return moves;\n}\n",
            "explanation": "1. Sort the array `nums` in ascending order.\n2. Find the middle element (median) of the sorted array.\n3. Initialize a variable `moves` to store the number of moves required.\n4. Iterate through the array, and for each element, calculate the absolute difference between the element and the median. Add this difference to the `moves` variable.\n5. Return the total `moves`.\n\nThe algorithm takes advantage of the fact that the optimal solution is to move all elements towards the median, as it minimizes the total distance between the elements."
        },
        "structure": {
            "c++": "int minMoves2(vector<int>& nums) \n    // Your code here\n}\n",
            "java": "public int minMoves2(int[] nums) \n    // Your code here\n}\n",
            "python": "def min_moves2(nums):\n    # Your code here\n\n",
            "javascript": "function minMoves2(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int minMoves2(vector<int>& nums) {\n    int n = nums.size();\n    sort(nums.begin(), nums.end());\n    int mid = nums[n / 2];\n    int moves = 0;\n    for (int i = 0; i < n; i++) {\n        moves += abs(nums[i] - mid);\n    }\n    return moves;\n}",
            "java": "public int minMoves2(int[] nums) {\n    Arrays.sort(nums);\n    int mid = nums[nums.length / 2];\n    int moves = 0;\n    for (int num : nums) {\n        moves += Math.abs(num - mid);\n    }\n    return moves;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = min_moves2(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = minMoves2(nums);\n    console.log(result);\n}"
        }
    },
    "463": {
        "title": "Island Perimeter",
        "description": "You are given a grid representing a map where 1 represents land and 0 represents water. The grid is completely surrounded by water, and there is exactly one island. Determine the perimeter of the island.",
        "example": "Example:\n\nInput: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\nOutput: 16\nExplanation: The perimeter is the 16 yellow stripes in the image above.",
        "level": "Easy",
        "tags": [
            "array",
            "grid",
            "perimeter"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        0,
                        1,
                        0,
                        0
                    ],
                    [
                        1,
                        1,
                        1,
                        0
                    ],
                    [
                        0,
                        1,
                        0,
                        0
                    ],
                    [
                        1,
                        1,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1
                    ]
                ],
                [
                    [
                        1,
                        0
                    ]
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1,
                        0,
                        1,
                        0
                    ]
                ],
                [
                    [
                        1,
                        1,
                        0,
                        0
                    ],
                    [
                        1,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        1
                    ],
                    [
                        0,
                        0,
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        1,
                        0,
                        0,
                        0,
                        0,
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        1,
                        0,
                        1,
                        1,
                        0,
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        1,
                        0,
                        1,
                        1,
                        0,
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        1,
                        0,
                        0,
                        0,
                        0,
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1
                    ]
                ]
            ],
            "outputs": [
                16,
                4,
                4,
                16,
                0,
                8,
                24,
                40,
                84
            ]
        },
        "sample_code": {
            "c++": "int islandPerimeter(vector<vector<int>>& grid) {\n    int perimeter = 0;\n    for (int row = 0; row < grid.size(); row++) {\n        for (int col = 0; col < grid[row].size(); col++) {\n            if (grid[row][col] == 1) {\n                perimeter += 4;\n                if (row > 0 && grid[row - 1][col] == 1) perimeter -= 2;\n                if (col > 0 && grid[row][col - 1] == 1) perimeter -= 2;\n            }\n        }\n    }\n    return perimeter;\n}\n",
            "java": "public int islandPerimeter(int[][] grid) {\n    int perimeter = 0;\n    for (int row = 0; row < grid.length; row++) {\n        for (int col = 0; col < grid[row].length; col++) {\n            if (grid[row][col] == 1) {\n                perimeter += 4;\n                if (row > 0 && grid[row - 1][col] == 1) perimeter -= 2;\n                if (col > 0 && grid[row][col - 1] == 1) perimeter -= 2;\n            }\n        }\n    }\n    return perimeter;\n}\n",
            "python": "def islandPerimeter(grid):\n    perimeter = 0\n    for row in range(len(grid)):\n        for col in range(len(grid[row])):\n            if grid[row][col] == 1:\n                perimeter += 4\n                if row > 0 and grid[row - 1][col] == 1:\n                    perimeter -= 2\n                if col > 0 and grid[row][col - 1] == 1:\n                    perimeter -= 2\n    return perimeter\n",
            "javascript": "function islandPerimeter(grid) {\n    let perimeter = 0;\n    for (let row = 0; row < grid.length; row++) {\n        for (let col = 0; col < grid[row].length; col++) {\n            if (grid[row][col] === 1) {\n                perimeter += 4;\n                if (row > 0 && grid[row - 1][col] === 1) perimeter -= 2;\n                if (col > 0 && grid[row][col - 1] === 1) perimeter -= 2;\n            }\n        }\n    }\n    return perimeter;\n}\n",
            "explanation": "The algorithm iterates through each cell in the grid. If a cell contains land, increment the perimeter count by 4 (each side of the square). If there is land in the adjacent cell to the left or above, decrement the perimeter count by 2 for each adjacent land cell as they share a common side. This way, we can calculate the total perimeter of the island without any extra data structures or recursion."
        },
        "structure": {
            "c++": "int islandPerimeter(vector<vector<int>>& grid) \n    // Your code here\n}\n",
            "java": "public int islandPerimeter(int[][] grid) \n    // Your code here\n}\n",
            "python": "def islandPerimeter(grid):\n    # Your code here\n\n",
            "javascript": "function islandPerimeter(grid) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<vector<int>> grid = $args;\n    int result = islandPerimeter(grid);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int islandPerimeter(int[][] grid) {\n    int perimeter = 0;\n    for (int row = 0; row < grid.length; row++) {\n        for (int col = 0; col < grid[row].length; col++) {\n            if (grid[row][col] == 1) {\n                perimeter += 4;\n                if (row > 0 && grid[row - 1][col] == 1) perimeter -= 2;\n                if (col > 0 && grid[row][col - 1] == 1) perimeter -= 2;\n            }\n        }\n    }\n    return perimeter;\n}",
            "python": "if __name__ == \"__main__\":\n    grid = $args[0]\n    result = islandPerimeter(grid)\n    print(result)",
            "javascript": "function islandPerimeter(grid) {\n    let perimeter = 0;\n    for (let row = 0; row < grid.length; row++) {\n        for (let col = 0; col < grid[row].length; col++) {\n            if (grid[row][col] === 1) {\n                perimeter += 4;\n                if (row > 0 && grid[row - 1][col] === 1) perimeter -= 2;\n                if (col > 0 && grid[row][col - 1] === 1) perimeter -= 2;\n            }\n        }\n    }\n    return perimeter;\n}"
        }
    },
    "464": {
        "title": "Winning the Game",
        "description": "In the '100 game', two players take turns adding any integer from 1 to 10 to a running total. The player who first causes the running total to reach or exceed 100 wins. Now, let's change the game so that players cannot reuse integers. For example, two players take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total greater than or equal to 100. Given two integers maxChoosableInteger and desiredTotal, determine if the first player to move can force a win. Return true if the first player can force a win, otherwise return false. Assume both players play optimally.",
        "example": "Example:\n\nInput: maxChoosableInteger = 10, desiredTotal = 11\nOutput: false\nExplanation: No matter which integer the first player chooses, they will lose. The second player can always choose the remaining integers to reach or exceed the desired total.\n\nInput: maxChoosableInteger = 10, desiredTotal = 0\nOutput: true\n\nInput: maxChoosableInteger = 10, desiredTotal = 1\nOutput: true",
        "level": "Medium",
        "tags": [
            "game theory",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    10,
                    11
                ],
                [
                    10,
                    0
                ],
                [
                    10,
                    1
                ],
                [
                    5,
                    10
                ],
                [
                    15,
                    100
                ],
                [
                    20,
                    200
                ],
                [
                    20,
                    300
                ],
                [
                    1,
                    1
                ],
                [
                    2,
                    3
                ],
                [
                    3,
                    5
                ],
                [
                    4,
                    7
                ],
                [
                    5,
                    9
                ],
                [
                    6,
                    11
                ],
                [
                    7,
                    13
                ],
                [
                    8,
                    15
                ],
                [
                    9,
                    17
                ],
                [
                    10,
                    19
                ],
                [
                    15,
                    25
                ],
                [
                    20,
                    30
                ],
                [
                    20,
                    40
                ]
            ],
            "outputs": [
                false,
                true,
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "#include <unordered_map>\n\nbool canWin(int maxChoosableInteger, int desiredTotal, int state, std::unordered_map<int, bool>& memo) {\n    if(desiredTotal <= 0) {\n        return false;\n    }\n    if(memo.count(state) > 0) {\n        return memo[state];\n    }\n    for(int i = 1; i <= maxChoosableInteger; i++) {\n        int bitCheck = 1 << i;\n        if((state & bitCheck) == 0) {\n            if(!canWin(maxChoosableInteger, desiredTotal - i, state | bitCheck, memo)) {\n                memo[state] = true;\n                return true;\n            }\n        }\n    }\n    memo[state] = false;\n    return false;\n}\n\nbool canIWin(int maxChoosableInteger, int desiredTotal) {\n    if (maxChoosableInteger >= desiredTotal) return true;\n    if ((maxChoosableInteger * (maxChoosableInteger + 1)) / 2 < desiredTotal) return false;\n\n    std::unordered_map<int, bool> memo;\n    int state = 0;\n    return canWin(maxChoosableInteger, desiredTotal, state, memo);\n}\n\n",
            "java": "import java.util.HashMap;\n\npublic class Solution {\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        if (maxChoosableInteger >= desiredTotal) return true;\n        if ((maxChoosableInteger * (maxChoosableInteger + 1)) / 2 < desiredTotal) return false;\n        \n        HashMap<Integer, Boolean> memo = new HashMap<>();\n        int state = 0;\n        return canWin(maxChoosableInteger, desiredTotal, state, memo);\n    }\n    \n    private boolean canWin(int maxChoosableInteger, int desiredTotal, int state, HashMap<Integer, Boolean> memo) {\n        if (desiredTotal <= 0) return false;\n        if (memo.containsKey(state)) return memo.get(state);\n        \n        for (int i = 1; i <= maxChoosableInteger; i++) {\n            int bitCheck = 1 << i;\n            if ((state & bitCheck) == 0) {\n                if (!canWin(maxChoosableInteger, desiredTotal - i, state | bitCheck, memo)) {\n                    memo.put(state, true);\n                    return true;\n                }\n            }\n        }\n        \n        memo.put(state, false);\n        return false;\n    }\n}\n\n",
            "python": "def canIWin(maxChoosableInteger, desiredTotal):\n    if maxChoosableInteger >= desiredTotal: return True\n    if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal: return False\n\n    memo = {}\n        \n    def canWin(state):\n        if state in memo:\n            return memo[state]\n        for i in range(1, maxChoosableInteger + 1):\n            bitCheck = 1 << i\n            if (state & bitCheck) == 0:\n                if not canWin(state | bitCheck):\n                    memo[state] = True\n                    return True\n    \n        memo[state] = False\n        return False\n\n    return canWin(0)\n\n",
            "javascript": "var canIWin = function(maxChoosableInteger, desiredTotal) {\n    if (maxChoosableInteger >= desiredTotal) return true;\n    if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) return false;\n\n    const memo = new Map();\n\n    function canWin(state) {\n        if (memo.has(state)) return memo.get(state);\n\n        for (let i = 1; i <= maxChoosableInteger; i++) {\n            let bitCheck = 1 << i;\n            if ((state & bitCheck) === 0) {\n                if (!canWin(state | bitCheck)) {\n                    memo.set(state, true);\n                    return true;\n                }\n            }\n        }\n\n        memo.set(state, false);\n        return false;\n    }\n\n    return canWin(0);\n}\n\n",
            "explanation": "We use a state, represented by an integer where each bit indicates if a number has been taken or not, and store the states in a memoization table. With each function call, we try to take each number from 1 to maxChoosableInteger if it hasn't been taken before, and update the state accordingly. If no moves can be made which forces a win, return false. If the desired total is equal to or less than zero, then the player has lost, and we return false. \n\nBoth players play optimally, so we can recursively call the function for each possible number and check if it doesn't result in a win for the other player. If we find such a scenario, then the first player can force a win. At the end, we return the final result from the memoization table."
        },
        "structure": {
            "c++": "#include <unordered_map>\n\nbool canWin(int maxChoosableInteger, int desiredTotal, int state, std::unordered_map<int, bool>& memo) \n    // Your code here\n}\n\n",
            "java": "import java.util.HashMap;\n\npublic class Solution \n    // Your code here\n}\n\n",
            "python": "def canIWin(maxChoosableInteger, desiredTotal):\n    # Your code here\n\n",
            "javascript": "var canIWin = function(maxChoosableInteger, desiredTotal) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <unordered_map>\n#include <iostream>\n\nbool canWin(int maxChoosableInteger, int desiredTotal, int state, std::unordered_map<int, bool>& memo) {\n    if(desiredTotal <= 0) {\n        return false;\n    }\n    if(memo.count(state) > 0) {\n        return memo[state];\n    }\n    for(int i = 1; i <= maxChoosableInteger; i++) {\n        int bitCheck = 1 << i;\n        if((state & bitCheck) == 0) {\n            if(!canWin(maxChoosableInteger, desiredTotal - i, state | bitCheck, memo)) {\n                memo[state] = true;\n                return true;\n            }\n        }\n    }\n    memo[state] = false;\n    return false;\n}\n\nbool canIWin(int maxChoosableInteger, int desiredTotal) {\n    if (maxChoosableInteger >= desiredTotal) return true;\n    if ((maxChoosableInteger * (maxChoosableInteger + 1)) / 2 < desiredTotal) return false;\n\n    std::unordered_map<int, bool> memo;\n    int state = 0;\n    return canWin(maxChoosableInteger, desiredTotal, state, memo);\n}\n\nint main() {\n    int maxChoosableInteger = $args;\n    int desiredTotal = $args;\n    bool result = canIWin(maxChoosableInteger, desiredTotal);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "java": "public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        if (maxChoosableInteger >= desiredTotal) return true;\n        if ((maxChoosableInteger * (maxChoosableInteger + 1)) / 2 < desiredTotal) return false;\n        \n        HashMap<Integer, Boolean> memo = new HashMap<>();\n        int state = 0;\n        return canWin(maxChoosableInteger, desiredTotal, state, memo);\n    }\n    \n    private boolean canWin(int maxChoosableInteger, int desiredTotal, int state, HashMap<Integer, Boolean> memo) {\n        if (desiredTotal <= 0) return false;\n        if (memo.containsKey(state)) return memo.get(state);\n        \n        for (int i = 1; i <= maxChoosableInteger; i++) {\n            int bitCheck = 1 << i;\n            if ((state & bitCheck) == 0) {\n                if (!canWin(maxChoosableInteger, desiredTotal - i, state | bitCheck, memo)) {\n                    memo.put(state, true);\n                    return true;\n                }\n            }\n        }\n        \n        memo.put(state, false);\n        return false;\n    }",
            "python": "if __name__ == \"__main__\":\n    maxChoosableInteger = $args[0]\n    desiredTotal = $args[1]\n    result = canIWin(maxChoosableInteger, desiredTotal)\n    print(result)",
            "javascript": "function main() {\n    const maxChoosableInteger = $args[0];\n    const desiredTotal = $args[1];\n    const result = canIWin(maxChoosableInteger, desiredTotal);\n    console.log(result);\n}"
        }
    },
    "465": {
        "title": "Minimum Number of Transactions",
        "description": "You are given an array of transactions `transactions` where `transactions[i] = [fromi, toi, amounti]` indicates that the person with `ID = fromi` gave `amounti $` to the person with `ID = toi`. Return the minimum number of transactions required to settle the debt.",
        "example": "Example 1:\n\nInput: transactions = [[0,1,10],[2,0,5]]\nOutput: 2\nExplanation: Person #0 gave person #1 $10. Person #2 gave person #0 $5. Two transactions are needed. One way to settle the debt is person #1 pays person #0 and #2 $5 each.\n\nExample 2:\n\nInput: transactions = [[0,1,10],[1,0,1],[1,2,5],[2,0,5]]\nOutput: 1\nExplanation: Person #0 gave person #1 $10. Person #1 gave person #0 $1. Person #1 gave person #2 $5. Person #2 gave person #0 $5. Therefore, person #1 only need to give person #0 $4, and all debt is settled.",
        "level": "Medium",
        "tags": [
            "array",
            "graph",
            "greedy"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        2,
                        0,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ],
                    [
                        0,
                        2,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ],
                    [
                        0,
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ],
                    [
                        0,
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        2,
                        3,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ],
                    [
                        0,
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        2,
                        3,
                        5
                    ],
                    [
                        3,
                        4,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ],
                    [
                        0,
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        2,
                        3,
                        5
                    ],
                    [
                        3,
                        4,
                        5
                    ],
                    [
                        4,
                        5,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ],
                    [
                        0,
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        2,
                        3,
                        5
                    ],
                    [
                        3,
                        4,
                        5
                    ],
                    [
                        4,
                        5,
                        5
                    ],
                    [
                        5,
                        6,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ],
                    [
                        0,
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        2,
                        3,
                        5
                    ],
                    [
                        3,
                        4,
                        5
                    ],
                    [
                        4,
                        5,
                        5
                    ],
                    [
                        5,
                        6,
                        5
                    ],
                    [
                        6,
                        7,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ],
                    [
                        0,
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        2,
                        3,
                        5
                    ],
                    [
                        3,
                        4,
                        5
                    ],
                    [
                        4,
                        5,
                        5
                    ],
                    [
                        5,
                        6,
                        5
                    ],
                    [
                        6,
                        7,
                        5
                    ],
                    [
                        7,
                        8,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ],
                    [
                        0,
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        2,
                        3,
                        5
                    ],
                    [
                        3,
                        4,
                        5
                    ],
                    [
                        4,
                        5,
                        5
                    ],
                    [
                        5,
                        6,
                        5
                    ],
                    [
                        6,
                        7,
                        5
                    ],
                    [
                        7,
                        8,
                        5
                    ],
                    [
                        8,
                        9,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ],
                    [
                        0,
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        2,
                        3,
                        5
                    ],
                    [
                        3,
                        4,
                        5
                    ],
                    [
                        4,
                        5,
                        5
                    ],
                    [
                        5,
                        6,
                        5
                    ],
                    [
                        6,
                        7,
                        5
                    ],
                    [
                        7,
                        8,
                        5
                    ],
                    [
                        8,
                        9,
                        5
                    ],
                    [
                        9,
                        10,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ],
                    [
                        0,
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        2,
                        3,
                        5
                    ],
                    [
                        3,
                        4,
                        5
                    ],
                    [
                        4,
                        5,
                        5
                    ],
                    [
                        5,
                        6,
                        5
                    ],
                    [
                        6,
                        7,
                        5
                    ],
                    [
                        7,
                        8,
                        5
                    ],
                    [
                        8,
                        9,
                        5
                    ],
                    [
                        9,
                        10,
                        5
                    ],
                    [
                        10,
                        11,
                        5
                    ]
                ]
            ],
            "outputs": [
                "2",
                "1",
                "8",
                "9",
                "10",
                "11",
                "12",
                "13",
                "14",
                "15",
                "16",
                "17",
                "18",
                "19",
                "20",
                "21",
                "22",
                "23",
                "24",
                "25"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <unordered_map>\n\nint minTransfers(std::vector<std::vector<int>>& transactions) {\n    std::unordered_map<int, int> balances;\n    for (const auto& transaction : transactions) {\n        balances[transaction[0]] -= transaction[2];\n        balances[transaction[1]] += transaction[2];\n    }\n\n    std_msgs::vector<int> debts;\n    for (const auto& balance : balances) {\n        if (balance.second != 0) {\n            debts.push_back(balance.second);\n        }\n    }\n    return dfs(debts, 0);\n}\n\nint dfs(std::vector<int>& debts, int start) {\n    while (start < debts.size() && debts[start] == 0) {\n        start++;\n    }\n    if (start == debts.size()) {\n        return 0;\n    }\n    int result = INT_MAX;\n    for (int i = start + 1; i < debts.size(); ++i) {\n        if ((debts[start] > 0) != (debts[i] > 0)) {\n            debts[i] += debts[start];\n            result = std::min(result, 1 + dfs(debts, start + 1));\n            debts[i] -= debts[start];\n        }\n    }\n    return result;\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic int minTransfers(int[][] transactions) {\n    Map<Integer, Integer> balances = new HashMap<>();\n    for (int[] transaction : transactions) {\n        balances.put(transaction[0], balances.getOrDefault(transaction[0], 0) - transaction[2]);\n        balances.put(transaction[1], balances.getOrDefault(transaction[1], 0) + transaction[2]);\n    }\n\n    List<Integer> debts = new ArrayList<>();\n    for (int balance : balances.values()) {\n        if (balance != 0) {\n            debts.add(balance);\n        }\n    }\n    return dfs(debts, 0);\n}\n\nprivate int dfs(List<Integer> debts, int start) {\n    while (start < debts.size() && debts.get(start) == 0) {\n        start++;\n    }\n    if (start == debts.size()) {\n        return 0;\n    }\n    int result = Integer.MAX_VALUE;\n    for (int i = start + 1; i < debts.size(); ++i) {\n        if ((debts.get(start) > 0) != (debts.get(i) > 0)) {\n            debts.set(i, debts.get(i) + debts.get(start));\n            result = Math.min(result, 1 + dfs(debts, start + 1));\n            debts.set(i, debts.get(i) - debts.get(start));\n        }\n    }\n    return result;\n}\n\n",
            "python": "from collections import defaultdict\n\ndef minTransfers(transactions):\n    balances = defaultdict(int)\n    for transaction in transactions:\n        balances[transaction[0]] -= transaction[2]\n        balances[transaction[1]] += transaction[2]\n\n    debts = [balance for balance in balances.values() if balance != 0]\n    return dfs(debts, 0)\n\ndef dfs(debts, start):\n    while start < len(debts) and debts[start] == 0:\n        start += 1\n    if start == len(debts):\n        return 0\n    result = float('inf')\n    for i in range(start + 1, len(debts)):\n        if (debts[start] > 0) != (debts[i] > 0):\n            debts[i] += debts[start]\n            result = min(result, 1 + dfs(debts, start + 1))\n            debts[i] -= debts[start]\n    return result\n\n",
            "javascript": "function minTransfers(transactions) {\n    const balances = new Map();\n    for (const transaction of transactions) {\n        balances.set(transaction[0], (balances.get(transaction[0]) || 0) - transaction[2]);\n        balances.set(transaction[1], (balances.get(transaction[1]) || 0) + transaction[2]);\n    }\n\n    const debts = [];\n    for (const balance of balances.values()) {\n        if (balance !== 0) {\n            debts.push(balance);\n        }\n    }\n    return dfs(debts, 0);\n}\n\nfunction dfs(debts, start) {\n    while (start < debts.length && debts[start] === 0) {\n        start++;\n    }\n    if (start === debts.length) {\n        return 0;\n    }\n    let result = Infinity;\n    for (let i = start + 1; i < debts.length; ++i) {\n        if ((debts[start] > 0) !== (debts[i] > 0)) {\n            debts[i] += debts[start];\n            result = Math.min(result, 1 + dfs(debts, start + 1));\n            debts[i] -= debts[start];\n        }\n    }\n    return result;\n}\n\n",
            "explanation": "The algorithm works by first iterating through the transactions and calculating the debt balance for each person. The debt balance maintains how much each person owes or is owed. Then, it stores the non-zero balance values in a separate list called `debts`.\n\nNext, it performs a depth-first search (DFS) to minimize the transaction counts. The DFS function iterates over each pair of debts, and if one member owes money and the other is owed money, it simulates settling the debt by adjusting the balance and calling the DFS function recursively with the updated balance. After this step, it reverts the changes to the balance and compares the minimum transactions found.\n\nThe algorithm iterates over all possible subsets of debts and returns the minimum number of transactions required to settle the debts."
        },
        "structure": {
            "c++": "#include <vector>\n#include <unordered_map>\n\nint minTransfers(std::vector<std::vector<int>>& transactions) \n    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic int minTransfers(int[][] transactions) \n    // Your code here\n}\n\n",
            "python": "from collections import defaultdict\n    # Your code here\n\n",
            "javascript": "function minTransfers(transactions) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <unordered_map>\n\nint main() {\n    std::vector<std::vector<int>> transactions = $args;\n    int result = minTransfers(transactions);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int minTransfers(int[][] transactions) {\n    Map<Integer, Integer> balances = new HashMap<>();\n    for (int[] transaction : transactions) {\n        balances.put(transaction[0], balances.getOrDefault(transaction[0], 0) - transaction[2]);\n        balances.put(transaction[1], balances.getOrDefault(transaction[1], 0) + transaction[2]);\n    }\n\n    List<Integer> debts = new ArrayList<>();\n    for (int balance : balances.values()) {\n        if (balance != 0) {\n            debts.add(balance);\n        }\n    }\n    return dfs(debts, 0);\n}\n\nprivate int dfs(List<Integer> debts, int start) {\n    while (start < debts.size() && debts.get(start) == 0) {\n        start++;\n    }\n    if (start == debts.size()) {\n        return 0;\n    }\n    int result = Integer.MAX_VALUE;\n    for (int i = start + 1; i < debts.size(); ++i) {\n        if ((debts.get(start) > 0) != (debts.get(i) > 0)) {\n            debts.set(i, debts.get(i) + debts.get(start));\n            result = Math.min(result, 1 + dfs(debts, start + 1));\n            debts.set(i, debts.get(i) - debts.get(start));\n        }\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    transactions = $args[0]\n    result = minTransfers(transactions)\n    print(result)",
            "javascript": "function minTransfers(transactions) {\n    const balances = new Map();\n    for (const transaction of transactions) {\n        balances.set(transaction[0], (balances.get(transaction[0]) || 0) - transaction[2]);\n        balances.set(transaction[1], (balances.get(transaction[1]) || 0) + transaction[2]);\n    }\n\n    const debts = [];\n    for (const balance of balances.values()) {\n        if (balance !== 0) {\n            debts.push(balance);\n        }\n    }\n    return dfs(debts, 0);\n}\n\nfunction dfs(debts, start) {\n    while (start < debts.length && debts[start] === 0) {\n        start++;\n    }\n    if (start === debts.length) {\n        return 0;\n    }\n    let result = Infinity;\n    for (let i = start + 1; i < debts.length; ++i) {\n        if ((debts[start] > 0) !== (debts[i] > 0)) {\n            debts[i] += debts[start];\n            result = Math.min(result, 1 + dfs(debts, start + 1));\n            debts[i] -= debts[start];\n        }\n    }\n    return result;\n}"
        }
    },
    "466": {
        "title": "Maximum String Concatenation",
        "description": "Given two strings `s1` and `s2` and two integers `n1` and `n2`, we define `str = [s, n]` as the string `str` which consists of the string `s` concatenated `n` times. For example, `str == [\"abc \", 3] == \"abcabcabc \"`. We define that string `s1` can be obtained from string `s2` if we can remove some characters from `s2` such that it becomes `s1`. For example, `s1 = \"abc \"` can be obtained from `s2 = \"ab**dbe**c \"` based on our definition by removing the bolded characters. Return the maximum integer `m` such that `str = [str2, m]` can be obtained from `str1`.",
        "example": "Example:\n\nInput: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2\n\nExplanation: The string `str1` is \"acbacbacbacb\" and the string `str2` is \"abab\". We can obtain `str2` from `str1` by removing the characters 'c' and 'c' from `str1` twice.\n\nInput: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1\n\nExplanation: The string `str1` is \"acb\" and the string `str2` is \"acb\". We can obtain `str2` from `str1` without removing any characters.",
        "level": "Medium",
        "tags": [
            "string",
            "concatenation"
        ],
        "test_cases": {
            "inputs": [
                [
                    "acb",
                    4,
                    "ab",
                    2
                ],
                [
                    "acb",
                    1,
                    "acb",
                    1
                ],
                [
                    "abc",
                    3,
                    "ab",
                    2
                ],
                [
                    "abc",
                    1,
                    "abc",
                    1
                ],
                [
                    "abc",
                    2,
                    "abc",
                    2
                ],
                [
                    "abc",
                    2,
                    "ab",
                    1
                ],
                [
                    "abc",
                    1,
                    "ab",
                    2
                ],
                [
                    "abc",
                    0,
                    "ab",
                    2
                ],
                [
                    "abc",
                    2,
                    "ab",
                    0
                ],
                [
                    "",
                    0,
                    "",
                    0
                ],
                [
                    "a",
                    1,
                    "",
                    0
                ],
                [
                    "",
                    0,
                    "a",
                    1
                ],
                [
                    "a",
                    1,
                    "a",
                    1
                ],
                [
                    "a",
                    2,
                    "a",
                    1
                ],
                [
                    "a",
                    1,
                    "a",
                    2
                ],
                [
                    "a",
                    2,
                    "a",
                    2
                ],
                [
                    "a",
                    3,
                    "a",
                    2
                ],
                [
                    "a",
                    2,
                    "a",
                    3
                ],
                [
                    "a",
                    3,
                    "a",
                    3
                ]
            ],
            "outputs": [
                2,
                1,
                0,
                1,
                2,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                1,
                1,
                2,
                2,
                2,
                2,
                3
            ]
        },
        "sample_code": {
            "c++": "int getMaxRepetitions(string s1, int n1, string s2, int n2) {\n    int count1 = 0, count2 = 0, i = 0, j = 0;\n    while (count1 < n1) {\n        if (s1[i] == s2[j]) {\n            j++;\n            if (j == s2.size()) {\n                j = 0;\n                count2++;\n            }\n        }\n        i++;\n        if (i == s1.size()) {\n            i = 0;\n            count1++;\n        }\n    }\n    return count2 / n2;\n}\n\n",
            "java": "public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\n    int count1 = 0, count2 = 0, i = 0, j = 0;\n    while (count1 < n1) {\n        if (s1.charAt(i) == s2.charAt(j)) {\n            j++;\n            if (j == s2.length()) {\n                j = 0;\n                count2++;\n            }\n        }\n        i++;\n        if (i == s1.length()) {\n            i = 0;\n            count1++;\n        }\n    }\n    return count2 / n2;\n}\n\n",
            "python": "def getMaxRepetitions(s1: str, n1: int, s2: str, n2: int) -> int:\n    count1, count2, i, j = 0, 0, 0, 0\n    while count1 < n1:\n        if s1[i] == s2[j]:\n            j += 1\n            if j == len(s2):\n                j = 0\n                count2 += 1\n        i += 1\n        if i == len(s1):\n            i = 0\n            count1 += 1\n    return count2 // n2\n\n",
            "javascript": "function getMaxRepetitions(s1, n1, s2, n2) {\n    let count1 = 0, count2 = 0, i = 0, j = 0;\n    while (count1 < n1) {\n        if (s1.charAt(i) === s2.charAt(j)) {\n            j++;\n            if (j === s2.length) {\n                j = 0;\n                count2++;\n            }\n        }\n        i++;\n        if (i === s1.length) {\n            i = 0;\n            count1++;\n        }\n    }\n    return Math.floor(count2 / n2);\n}\n\n",
            "explanation": "1. Initialize counter variables for both strings (count1 and count2) as well as indices for both strings (i and j).\n2. Iterate through str1 while count1 is less than n1.\n3. Compare the characters at the current indices of s1 and s2. If they match, increment index j of s2.\n4. If j reaches the length of s2, reset j to 0 and increment count2.\n5. Increment index i of s1. If i reaches the length of s1, reset i to 0 and increment count1.\n6. Return the integer division of count2 by n2 as the maximum integer m."
        },
        "structure": {
            "c++": "int getMaxRepetitions(string s1, int n1, string s2, int n2) \n    // Your code here\n}\n\n",
            "java": "public int getMaxRepetitions(String s1, int n1, String s2, int n2) \n    // Your code here\n}\n\n",
            "python": "def getMaxRepetitions(s1: str, n1: int, s2: str, n2: int) -> int:\n    # Your code here\n\n",
            "javascript": "function getMaxRepetitions(s1, n1, s2, n2) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int getMaxRepetitions(string s1, int n1, string s2, int n2) {\n    int count1 = 0, count2 = 0, i = 0, j = 0;\n    while (count1 < n1) {\n        if (s1[i] == s2[j]) {\n            j++;\n            if (j == s2.size()) {\n                j = 0;\n                count2++;\n            }\n        }\n        i++;\n        if (i == s1.size()) {\n            i = 0;\n            count1++;\n        }\n    }\n    return count2 / n2;\n}\n\nint main() {\n    string s1 = $args;\n    int n1 = $args;\n    string s2 = $args;\n    int n2 = $args;\n    int result = getMaxRepetitions(s1, n1, s2, n2);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\n    int count1 = 0, count2 = 0, i = 0, j = 0;\n    while (count1 < n1) {\n        if (s1.charAt(i) == s2.charAt(j)) {\n            j++;\n            if (j == s2.length()) {\n                j = 0;\n                count2++;\n            }\n        }\n        i++;\n        if (i == s1.length()) {\n            i = 0;\n            count1++;\n        }\n    }\n    return count2 / n2;\n}",
            "python": "if __name__ == \"__main__\":\n    s1 = $args[0]\n    n1 = $args[1]\n    s2 = $args[2]\n    n2 = $args[3]\n    result = getMaxRepetitions(s1, n1, s2, n2)\n    print(result)",
            "javascript": "function getMaxRepetitions(s1, n1, s2, n2) {\n    const result = getMaxRepetitions(s1, n1, s2, n2);\n    console.log(result);\n}"
        }
    },
    "468": {
        "title": "Validate IP Address",
        "description": "Given a string `queryIP`, determine if it is a valid IPv4 or IPv6 address. Return 'IPv4' if it is a valid IPv4 address, 'IPv6' if it is a valid IPv6 address, or 'Neither' if it is not a correct IP of any type.",
        "example": "Example 1:\n\nInput: queryIP = '172.16.254.1'\nOutput: 'IPv4'\nExplanation: This is a valid IPv4 address, so the output is 'IPv4'.\n\nExample 2:\n\nInput: queryIP = '2001:0db8:85a3:0:0:8A2E:0370:7334'\nOutput: 'IPv6'\nExplanation: This is a valid IPv6 address, so the output is 'IPv6'.\n\nExample 3:\n\nInput: queryIP = '256.256.256.256'\nOutput: 'Neither'\nExplanation: This is neither a valid IPv4 address nor a valid IPv6 address, so the output is 'Neither'.",
        "level": "Easy",
        "tags": [
            "string",
            "validation"
        ],
        "test_cases": {
            "inputs": [
                "'172.16.254.1'",
                "'2001:0db8:85a3:0:0:8A2E:0370:7334'",
                "'256.256.256.256'",
                "'192.168.1.1'",
                "'192.168.1.0'",
                "'192.168.01.1'",
                "'192.168.1.00'",
                "'192.168@1.1'",
                "'2001:0db8:85a3::8A2E:037j:7334'",
                "'02001:0db8:85a3:0000:0000:8a2e:0370:7334'",
                "'2001:0db8:85a3:0000:0000:8a2e:0370:7334'",
                "'2001:db8:85a3:0:0:8A2E:0370:7334'",
                "'2001:0db8:85a3:0000:0000:8a2e:0370:7334'",
                "'2001:db8:85a3:0:0:8A2E:0370:7334'",
                "'2001:0db8:85a3:0000:0000:8a2e:0370:7334'",
                "'2001:db8:85a3:0:0:8A2E:0370:7334'",
                "'2001:0db8:85a3:0000:0000:8a2e:0370:7334'",
                "'2001:db8:85a3:0:0:8A2E:0370:7334'",
                "'2001:0db8:85a3:0000:0000:8a2e:0370:7334'",
                "'2001:db8:85a3:0:0:8A2E:0370:7334'",
                "'2001:0db8:85a3:0000:0000:8a2e:0370:7334'",
                "'2001:db8:85a3:0:0:8A2E:0370:7334'"
            ],
            "outputs": [
                "'IPv4'",
                "'IPv6'",
                "'Neither'",
                "'IPv4'",
                "'IPv4'",
                "'Neither'",
                "'Neither'",
                "'Neither'",
                "'Neither'",
                "'Neither'",
                "'IPv6'",
                "'Neither'",
                "'IPv6'",
                "'Neither'",
                "'IPv6'",
                "'Neither'",
                "'IPv6'",
                "'Neither'",
                "'IPv6'",
                "'Neither'",
                "'IPv6'",
                "'Neither'"
            ]
        },
        "sample_code": {
            "c++": "#include <sstream>\n#include <string>\n#include <vector>\n\nbool isValidIPv4(const std::string& part);\nbool isValidIPv6(const std::string& part);\n\nstd::string validateIP(const std::string& queryIP) {\n    std::stringstream ss(queryIP);\n    std::string part;\n    int partsCount = 0;\n\n    if (queryIP.find(':') == std::string::npos) {\n        while (getline(ss, part, '.')) {\n            if (!isValidIPv4(part)) return \"Neither\";\n            partsCount++;\n        }\n        if (partsCount == 4) return \"IPv4\";\n    } else {\n        while (getline(ss, part, ':')) {\n            if (!isValidIPv6(part)) return \"Neither\";\n            partsCount++;\n        }\n        if (partsCount == 8) return \"IPv6\";\n    }\n\n    return \"Neither\";\n}\n\nbool isValidIPv4(const std::string& part) {\n    if (part.empty() || part.size() > 3) return false;\n    if (part.size() > 1 && part[0] == '0') return false;\n\n    int num = 0;\n    for (char ch : part) {\n        if (!isdigit(ch)) return false;\n        num = num * 10 + (ch - '0');\n    }\n\n    return num >= 0 && num <= 255;\n}\n\nbool isValidIPv6(const std::string& part) {\n    if (part.empty() || part.size() > 4) return false;\n\n    for (char ch : part) {\n        if (!isxdigit(ch)) return false;\n    }\n\n    return true;\n}\n",
            "java": "public String validateIP(String queryIP) {\n    String[] ipv4Parts = queryIP.split(\"\\\\.\", -1);\n    String[] ipv6Parts = queryIP.split(\":\", -1);\n\n    if (ipv4Parts.length == 4) {\n        if (isValidIPv4(ipv4Parts)) return \"IPv4\";\n    } else if (ipv6Parts.length == 8) {\n        if (isValidIPv6(ipv6Parts)) return \"IPv6\";\n    }\n\n    return \"Neither\";\n}\n\nprivate boolean isValidIPv4(String[] parts) {\n    for (String part : parts) {\n        if (part.length() == 0 || part.length() > 3 || (part.length() > 1 && part.charAt(0) == '0')) return false;\n\n        int num = 0;\n        for (char ch : part.toCharArray()) {\n            if (!Character.isDigit(ch)) return false;\n            num = num * 10 + (ch - '0');\n        }\n\n        if (num < 0 || num > 255) return false;\n    }\n\n    return true;\n}\n\nprivate boolean isValidIPv6(String[] parts) {\n    for (String part : parts) {\n        if (part.length() == 0 || part.length() > 4) return false;\n\n        for (char ch : part.toCharArray()) {\n            if (!Character.isDigit(ch) && !(ch >= 'a' && ch <= 'f') && !(ch >= 'A' && ch <= 'F')) return false;\n        }\n    }\n\n    return true;\n}\n",
            "python": "def validateIP(queryIP):\n    ipv4_parts = queryIP.split('.')\n    ipv6_parts = queryIP.split(':')\n\n    if len(ipv4_parts) == 4:\n        if is_valid_ipv4(ipv4_parts):\n            return \"IPv4\"\n    elif len(ipv6_parts) == 8:\n        if is_valid_ipv6(ipv6_parts):\n            return \"IPv6\"\n\n    return \"Neither\"\n\ndef is_valid_ipv4(parts):\n    for part in parts:\n        if not part or len(part) > 3 or (len(part) > 1 and part[0] == '0'):\n            return False\n\n        if not part.isdigit() or int(part) < 0 or int(part) > 255:\n            return False\n\n    return True\n\ndef is_valid_ipv6(parts):\n    for part in parts:\n        if not part or len(part) > 4:\n            return False\n\n        for ch in part:\n            if not ch.isdigit() and not (ch.lower() >= 'a' and ch.lower() <= 'f'):\n                return False\n\n    return True\n",
            "javascript": "function validateIP(queryIP) {\n    const ipv4_parts = queryIP.split('.');\n    const ipv6_parts = queryIP.split(':');\n\n    if (ipv4_parts.length == 4) {\n        if (isValidIPv4(ipv4_parts)) return \"IPv4\";\n    } else if (ipv6_parts.length == 8) {\n        if (isValidIPv6(ipv6_parts)) return \"IPv6\";\n    }\n\n    return \"Neither\";\n}\n\nfunction isValidIPv4(parts) {\n    for (let part of parts) {\n        if (!part || part.length > 3 || (part.length > 1 && part[0] == '0')) return false;\n\n        let num = 0;\n        for (let ch of part) {\n            if (!/[0-9]/.test(ch)) return false;\n            num = num * 10 + parseInt(ch);\n        }\n\n        if (num < 0 || num > 255) return false;\n    }\n\n    return true;\n}\n\nfunction isValidIPv6(parts) {\n    for (let part of parts) {\n        if (!part || part.length > 4) return false;\n\n        for (let ch of part) {\n            if (!/[0-9a-fA-F]/.test(ch)) return false;\n        }\n    }\n\n    return true;\n}\n",
            "explanation": "The algorithm checks if the given `queryIP` is an IPv4 or IPv6, then proceeds as follows:\n\n1. For IPv4, we split the input by dots '.' and validate if there are exactly 4 parts. Each part should be a string with length between 1 and 3, and should not have leading zeros. We then check if each character of the part is a digit and if the integer value of the part is between 0 and 255 inclusive.\n\n2. For IPv6, we split the input by colons ':' and validate if there are exactly 8 parts. Each part should be a string with length between 1 and 4. We then check if each character of the part is a hexadecimal digit (0-9, a-f or A-F).\n\nIf the given `queryIP` passes either of the above validations, it is considered a valid IPv4 or IPv6 address. Otherwise, it is considered \"Neither\"."
        },
        "structure": {
            "c++": "#include <sstream>\n#include <string>\n#include <vector>\n\nbool isValidIPv4(const std::string& part);\nbool isValidIPv6(const std::string& part);\n\nstd::string validateIP(const std::string& queryIP) \n    // Your code here\n}\n",
            "java": "public String validateIP(String queryIP) \n    // Your code here\n}\n",
            "python": "def validateIP(queryIP):\n    # Your code here\n\n",
            "javascript": "function validateIP(queryIP) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <sstream>\n#include <string>\n#include <vector>\n\nint main() {\n    std::string queryIP = $args;\n    std::string result = validateIP(queryIP);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public String validateIP(String queryIP) {\n    String[] ipv4Parts = queryIP.split(\"\\\\.\", -1);\n    String[] ipv6Parts = queryIP.split(\":\", -1);\n\n    if (ipv4Parts.length == 4) {\n        if (isValidIPv4(ipv4Parts)) return \"IPv4\";\n    } else if (ipv6Parts.length == 8) {\n        if (isValidIPv6(ipv6Parts)) return \"IPv6\";\n    }\n\n    return \"Neither\";\n}\n\nprivate boolean isValidIPv4(String[] parts) {\n    for (String part : parts) {\n        if (part.length() == 0 || part.length() > 3 || (part.length() > 1 && part.charAt(0) == '0')) return false;\n\n        int num = 0;\n        for (char ch : part.toCharArray()) {\n            if (!Character.isDigit(ch)) return false;\n            num = num * 10 + (ch - '0');\n        }\n\n        if (num < 0 || num > 255) return false;\n    }\n\n    return true;\n}\n\nprivate boolean isValidIPv6(String[] parts) {\n    for (String part : parts) {\n        if (part.length() == 0 || part.length() > 4) return false;\n\n        for (char ch : part.toCharArray()) {\n            if (!Character.isDigit(ch) && !(ch >= 'a' && ch <= 'f') && !(ch >= 'A' && ch <= 'F')) return false;\n        }\n    }\n\n    return true;\n}",
            "python": "if __name__ == \"__main__\":\n    queryIP = $args[0]\n    result = validateIP(queryIP)\n    print(result)",
            "javascript": "function main() {\n    const queryIP = $args;\n    const result = validateIP(queryIP);\n    console.log(result);\n}"
        }
    },
    "470": {
        "title": "Uniform Random Integer Generator",
        "description": "You are given an API `rand7()` that generates a uniform random integer in the range `[1, 7]`. Your task is to implement a function `rand10()` that generates a uniform random integer in the range `[1, 10]`. You can only call the API `rand7()` and you should not call any other API. Please do not use a language's built-in random API.",
        "example": "Example:\n\nInput: n = 1\nOutput: [2]\n\nExplanation: Calling `rand10()` once will generate a random integer between 1 and 10, inclusive. In this case, the output is [2].",
        "level": "Medium",
        "tags": [
            "random",
            "probability"
        ],
        "test_cases": {
            "inputs": [
                1,
                2,
                3,
                4,
                5,
                10,
                100
            ],
            "outputs": [
                [
                    2
                ],
                [
                    2,
                    8
                ],
                [
                    3,
                    8,
                    10
                ],
                [
                    1,
                    4,
                    7,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ]
            ]
        },
        "sample_code": {
            "c++": "int rand7(); // Provided API\n\nint rand10() {\n    int result;\n    do {\n        result = (rand7() - 1) * 7 + rand7();\n    } while (result > 40);\n    return result % 10 + 1;\n}\n",
            "java": "public int rand7() ; // Provided API\n\npublic int rand10() {\n    int result;\n    do {\n        result = (rand7() - 1) * 7 + rand7();\n    } while (result > 40);\n    return result % 10 + 1;\n}\n",
            "python": "def rand7():\n    pass  # Provided API\n\ndef rand10():\n    result = None\n    while True:\n        result = (rand7() - 1) * 7 + rand7()\n        if result <= 40:\n            break\n    return result % 10 + 1\n",
            "javascript": "function rand7() ; // Provided API\n\nfunction rand10() {\n    let result;\n    do {\n        result = (rand7() - 1) * 7 + rand7();\n    } while (result > 40);\n    return result % 10 + 1;\n}\n",
            "explanation": "Here's how the algorithm works:\n\n1. Call `rand7()` two times and treat the two values as (row, column) indices in a 7x7 grid (so each value is 1 to 7). This gives us 49 possible values, forming a uniform distribution.\n\n2. We actually convert the two values `a` and `b` (from 1 to 7) into a single value, `result = (a - 1) * 7 + b`. This will give us a value between 1 and 49 (inclusive).\n\n3. If the `result` is greater than 40, we reject this value (and try again) since this is larger than what we can map to the range 1 to 10. We will use the value `result` to represent the range [1, 10] by taking the modulus of 10 and adding 1 (i.e. `result % 10 + 1`).\n\n4. This way, we ensure a uniformly random value between 1 to 10. Since some values are rejected, the expected number of calls to rand7() is 2.4 (the probability of a value being accepted is 40/49, so expected calls are 2/(40/49)).\n\n5. The number of calls to rand7() is optimized in this approach, minimizing it to 2 calls on average."
        },
        "structure": {
            "c++": "int rand7(); // Provided API\n\nint rand10() \n    // Your code here\n}\n",
            "java": "public int rand7() ; // Provided API\n\npublic int rand10() \n    // Your code here\n}\n",
            "python": "def rand7():\n    # Your code here\n\n",
            "javascript": "function rand7() ; // Provided API\n\nfunction rand10() \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int result;\n    result = rand10();\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int rand10() {\n    int result;\n    do {\n        result = (rand7() - 1) * 7 + rand7();\n    } while (result > 40);\n    return result % 10 + 1;\n}",
            "python": "if __name__ == \"__main__\":\n    $args = [None]\n    result = rand10()\n    print(result)",
            "javascript": "function main() {\n    const result = rand10();\n    console.log(result);\n}"
        }
    },
    "471": {
        "title": "String Encoding",
        "description": "Given a string `s`, encode the string such that its encoded length is the shortest. The encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. `k` should be a positive integer. If an encoding process does not make the string shorter, then do not encode it. If there are several solutions, return any of them.",
        "example": "Example:\n\nInput: s =  \"aaa \"\nOutput:  \"aaa \"\nExplanation: There is no way to encode it such that it is shorter than the input string, so we do not encode it.",
        "level": "Medium",
        "tags": [
            "string",
            "encoding"
        ],
        "test_cases": {
            "inputs": [
                "\"aaa \"",
                "\"aaaaa \"",
                "\"aaaaaaaaaa \"",
                "\"abcde \"",
                "\"aabbaabbaabb \"",
                "\"hello world \"",
                "\"aaaaaabbbbbccccc \"",
                "\"abbcccddddeeeeeffffff \"",
                "\"a \"",
                "\"ab \"",
                "\"abc \"",
                "\"abcd \"",
                "\"abcde \"",
                "\"abcdef \"",
                "\"abcdefg \"",
                "\"abcdefgh \"",
                "\"abcdefghi \"",
                "\"abcdefghij \"",
                "\"abcdefghijk \"",
                "\"abcdefghijkl \"",
                "\"abcdefghijklm \""
            ],
            "outputs": [
                "\"aaa \"",
                "\"5[a] \"",
                "\"10[a] \"",
                "\"abcde \"",
                "\"3[a2[b]] \"",
                "\"hello world \"",
                "\"6[a5[b]5[c]] \"",
                "\"1[a2[b3[c4[d5[e6[f]]]]]] \"",
                "\"a \"",
                "\"ab \"",
                "\"abc \"",
                "\"abcd \"",
                "\"abcde \"",
                "\"abcdef \"",
                "\"abcdefg \"",
                "\"abcdefgh \"",
                "\"abcdefghi \"",
                "\"abcdefghij \"",
                "\"abcdefghijk \"",
                "\"abcdefghijkl \"",
                "\"abcdefghijklm \""
            ]
        },
        "sample_code": {
            "c++": "std::string encode(std::string s) {\n    int n = s.length();\n    for (int i = n / 2; i > 0; i--) {\n        if (n % i == 0) {\n            int reps = n / i;\n            std::string sub = s.substr(0, i);\n            std::string composed = \"\";\n            for (int j = 0; j < reps; j++) {\n                composed += sub;\n            }\n            if (s == composed) {\n                return std::to_string(reps) + \"[\" + sub + \"]\";\n            }\n        }\n    }\n    return s;\n}\n",
            "java": "String encode(String s) {\n    int n = s.length();\n    for (int i = n / 2; i > 0; i--) {\n        if (n % i == 0) {\n            int reps = n / i;\n            String sub = s.substring(0, i);\n            StringBuilder composed = new StringBuilder();\n            for (int j = 0; j < reps; j++) {\n                composed.append(sub);\n            }\n            if (s.equals(composed.toString())) {\n                return reps + \"[\" + sub + \"]\";\n            }\n        }\n    }\n    return s;\n}\n",
            "python": "def encode(s: str) -> str:\n    n = len(s)\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            reps = n // i\n            sub = s[:i]\n            composed = sub * reps\n            if s == composed:\n                return f\"{reps}[{sub}]\"\n    return s\n",
            "javascript": "function encode(s) {\n    const n = s.length;\n    for (let i = Math.floor(n / 2); i > 0; i--) {\n        if (n % i === 0) {\n            const reps = n / i;\n            const sub = s.slice(0, i);\n            let composed = \"\";\n            for (let j = 0; j < reps; j++) {\n                composed += sub;\n            }\n            if (s === composed) {\n                return `${reps}[${sub}]`;\n            }\n        }\n    }\n    return s;\n}\n",
            "explanation": "The algorithm works by iteratively checking substrings of the input string `s` from the largest possible ones (half of the input string's length) to the smallest (single characters). To find the shortest possible encoding, the algorithm calculates the number of repetitions of the current substring and checks if the input string can be entirely composed of that substring. If a suitable substring is found, it returns the encoded string in the format _k[encoded_string]_, where _k_ is the number of repetitions, otherwise it returns the original input string."
        },
        "structure": {
            "c++": "std::string encode(std::string s) \n    // Your code here\n}\n",
            "java": "String encode(String s) \n    // Your code here\n}\n",
            "python": "def encode(s: str) -> str:\n    # Your code here\n\n",
            "javascript": "function encode(s) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "std::string encode(std::string s) {\n    int n = s.length();\n    for (int i = n / 2; i > 0; i--) {\n        if (n % i == 0) {\n            int reps = n / i;\n            std::string sub = s.substr(0, i);\n            std::string composed = \"\";\n            for (int j = 0; j < reps; j++) {\n                composed += sub;\n            }\n            if (s == composed) {\n                return std::to_string(reps) + \"[\" + sub + \"]\";\n            }\n        }\n    }\n    return s;\n}",
            "java": "String encode(String s) {\n    int n = s.length();\n    for (int i = n / 2; i > 0; i--) {\n        if (n % i == 0) {\n            int reps = n / i;\n            String sub = s.substring(0, i);\n            StringBuilder composed = new StringBuilder();\n            for (int j = 0; j < reps; j++) {\n                composed.append(sub);\n            }\n            if (s.equals(composed.toString())) {\n                return reps + \"[\" + sub + \"]\";\n            }\n        }\n    }\n    return s;\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args[0]\n    result = encode(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = encode(s);\n    console.log(result);\n}"
        }
    },
    "472": {
        "title": "Concatenated Words",
        "description": "Given an array of strings `words` (without duplicates), return all the concatenated words in the given list of words. A concatenated word is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct) in the given array.",
        "example": "Example 1:\n\nInput: words = [\"cat\", \"cats\", \"catsdogcats\", \"dog\", \"dogcatsdog\", \"hippopotamuses\", \"rat\", \"ratcatdogcat\"]\nOutput: [\"catsdogcats\", \"dogcatsdog\", \"ratcatdogcat\"]\nExplanation: \"catsdogcats\" can be concatenated by \"cats\", \"dog\", and \"cats\"; \"dogcatsdog\" can be concatenated by \"dog\", \"cats\", and \"dog\"; \"ratcatdogcat\" can be concatenated by \"rat\", \"cat\", \"dog\", and \"cat\".\n\nExample 2:\n\nInput: words = [\"cat\", \"dog\", \"catdog\"]\nOutput: [\"catdog\"]",
        "level": "Medium",
        "tags": [
            "Array",
            "String"
        ],
        "test_cases": {
            "inputs": [
                [
                    "cat",
                    "cats",
                    "catsdogcats",
                    "dog",
                    "dogcatsdog",
                    "hippopotamuses",
                    "rat",
                    "ratcatdogcat"
                ],
                [
                    "cat",
                    "dog",
                    "catdog"
                ],
                [
                    "apple",
                    "banana",
                    "pineapple"
                ],
                [
                    "hello",
                    "world",
                    "helloworld"
                ],
                [
                    "programming",
                    "code",
                    "coding",
                    "programmingcode"
                ],
                [
                    "a",
                    "b",
                    "c",
                    "ab",
                    "bc",
                    "abc"
                ],
                [
                    "cat",
                    "cats",
                    "dog",
                    "dogs",
                    "catdog",
                    "dogcat"
                ],
                [
                    "cat",
                    "cats",
                    "dog",
                    "dogs",
                    "catdog",
                    "dogcat",
                    "catdogcats"
                ]
            ],
            "outputs": [
                [
                    "catsdogcats",
                    "dogcatsdog",
                    "ratcatdogcat"
                ],
                [
                    "catdog"
                ],
                [],
                [
                    "helloworld"
                ],
                [
                    "programmingcode"
                ],
                [
                    "ab",
                    "bc",
                    "abc"
                ],
                [
                    "catdog"
                ],
                [
                    "catdogcats"
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nbool isConcatenated(const string& word, unordered_set<string>& wordDict) {\n    int n = word.size();\n    vector<bool> dp(n + 1, false);\n    dp[0] = true;\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (dp[j] && wordDict.count(word.substr(j, i - j))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[n];\n}\n\nvector<string> findAllConcatenatedWords(vector<string>& words) {\n    unordered_set<string> wordDict(words.begin(), words.end());\n    vector<string> result;\n\n    for (const string& word : words) {\n        if (isConcatenated(word, wordDict)) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class Solution {\n    public boolean isConcatenated(String word, Set<String> wordDict) {\n        int n = word.length();\n        boolean[] dp = new boolean[n + 1];\n        dp[0] = true;\n\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                if (dp[j] && wordDict.contains(word.substring(j, i))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n\n    public List<String> findAllConcatenatedWords(String[] words) {\n        Set<String> wordDict = new HashSet<>();\n        for (String word : words) {\n            wordDict.add(word);\n        }\n\n        List<String> result = new ArrayList<>();\n        for (String word : words) {\n            if (isConcatenated(word, wordDict)) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n}\n",
            "python": "def is_concatenated(word, word_dict):\n    n = len(word)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and word[j:i] in word_dict:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\ndef find_all_concatenated_words(words):\n    word_dict = set(words)\n    result = []\n\n    for word in words:\n        if is_concatenated(word, word_dict):\n            result.append(word)\n\n    return result\n",
            "javascript": "function isConcatenated(word, wordDict) {\n    const n = word.length;\n    const dp = Array(n + 1).fill(false);\n    dp[0] = true;\n\n    for (let i = 1; i <= n; ++i) {\n        for (let j = 0; j < i; ++j) {\n            if (dp[j] && wordDict.has(word.substring(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[n];\n}\n\nfunction findAllConcatenatedWords(words) {\n    const wordDict = new Set(words);\n    const result = [];\n\n    for (const word of words) {\n        if (isConcatenated(word, wordDict)) {\n            result.push(word);\n        }\n    }\n\n    return result;\n}\n",
            "explanation": "The algorithm uses dynamic programming to determine if a given word is a concatenated word. The function `isConcatenated` checks if a word can be formed by concatenating two or more words from the input array. It iterates through the characters of the word and uses a boolean array `dp` to keep track of whether or not the substring from the start of the word up to a certain index can be formed by concatenating the words from the input array.\n\nThen, the main function `findAllConcatenatedWords` iterates through each word in the array, and if the word is a concatenated word, adds it to the result list/array.\n\nThe four implementations in C++, Java, Python, and JavaScript use the same algorithm described above but are adapted to their respective language syntax and standard libraries."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nbool isConcatenated(const string& word, unordered_set<string>& wordDict) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class Solution \n    // Your code here\n}\n",
            "python": "def is_concatenated(word, word_dict):\n    # Your code here\n\n",
            "javascript": "function isConcatenated(word, wordDict) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nbool isConcatenated(const string& word, unordered_set<string>& wordDict) {\n    int n = word.size();\n    vector<bool> dp(n + 1, false);\n    dp[0] = true;\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (dp[j] && wordDict.count(word.substr(j, i - j))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[n];\n}\n\nvector<string> findAllConcatenatedWords(vector<string>& words) {\n    unordered_set<string> wordDict(words.begin(), words.end());\n    vector<string> result;\n\n    for (const string& word : words) {\n        if (isConcatenated(word, wordDict)) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}",
            "java": "public List<String> findAllConcatenatedWords(String[] words)",
            "python": "if __name__ == \"__main__\":\n    words = $args[0]\n    result = find_all_concatenated_words(words)\n    print(result)",
            "javascript": "function main() {\n    const words = $args;\n    const result = findAllConcatenatedWords(words);\n    console.log(result);\n}"
        }
    },
    "473": {
        "title": "Matchstick Square",
        "description": "You are given an integer array `matchsticks` where `matchsticks[i]` is the length of the `ith` matchstick. You want to use **all the matchsticks** to make one square. You **should not break** any stick, but you can link them up, and each matchstick must be used **exactly one time**. Return `true` if you can make this square and `false` otherwise.",
        "example": "Example:\n\nInput: matchsticks = [1,1,2,2,2]\nOutput: true\nExplanation: You can form a square with length 2, one side of the square came two sticks with length 1.",
        "level": "Medium",
        "tags": [
            "array",
            "backtracking"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    1,
                    2,
                    2,
                    2
                ],
                [
                    3,
                    3,
                    3,
                    3,
                    4
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    16
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    17
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    18
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    19
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    20
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    21
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    22
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    23
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    24
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    25
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    26
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    27
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    28
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    29
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    30
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    31
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <numeric>\n#include <algorithm>\n\nbool makesquare(std::vector<int>& matchsticks) {\n    if (matchsticks.size() < 4) return false;\n    int sum = std::accumulate(matchsticks.begin(), matchsticks.end(), 0);\n    if (sum % 4) return false;\n    int target = sum / 4;\n    std::sort(matchsticks.rbegin(), matchsticks.rend());\n    std::vector<int> sums(4, 0);\n    return dfs(matchsticks, sums, target, 0);\n}\n\nbool dfs(std::vector<int>& matchsticks, std::vector<int>& sums, int target, int index) {\n    if (index == matchsticks.size()) {\n        return sums[0] == target && sums[1] == target && sums[2] == target;\n    }\n    for (int i = 0; i < 4; ++i) {\n        if (sums[i] + matchsticks[index] <= target) {\n            sums[i] += matchsticks[index];\n            if (dfs(matchsticks, sums, target, index + 1)) return true;\n            sums[i] -= matchsticks[index];\n        }\n    }\n    return false;\n}\n\n",
            "java": "import java.util.Arrays;\n\npublic class Solution {\n    public boolean makesquare(int[] matchsticks) {\n        if (matchsticks == null || matchsticks.length < 4) return false;\n        int sum = 0;\n        for (int matchstick : matchsticks) sum += matchstick;\n        if (sum % 4 != 0) return false;\n        int target = sum / 4;\n        Arrays.sort(matchsticks);\n        reverse(matchsticks);\n        int[] sums = new int[4];\n        return dfs(matchsticks, sums, target, 0);\n    }\n\n    private void reverse(int[] nums) {\n        int left = 0, right = nums.length - 1;\n        while (left < right) {\n            int temp = nums[left];\n            nums[left] = nums[right];\n            nums[right] = temp;\n            left++;\n            right--;\n        }\n    }\n\n    private boolean dfs(int[] matchsticks, int[] sums, int target, int index) {\n        if (index == matchsticks.length) {\n            return sums[0] == target && sums[1] == target && sums[2] == target;\n        }\n        for (int i = 0; i < 4; i++) {\n            if (sums[i] + matchsticks[index] <= target) {\n                sums[i] += matchsticks[index];\n                if (dfs(matchsticks, sums, target, index + 1)) return true;\n                sums[i] -= matchsticks[index];\n            }\n        }\n        return false;\n    }\n}\n\n",
            "python": "from itertools import chain\n\ndef makesquare(matchsticks):\n    if len(matchsticks) < 4:\n        return False\n    total = sum(matchsticks)\n    if total % 4:\n        return False\n    target = total // 4\n    matchsticks.sort(reverse=True)\n    sums = [0]*4\n    return dfs(matchsticks, sums, target, 0)\n\ndef dfs(matchsticks, sums, target, index):\n    if index == len(matchsticks):\n        return sums[0] == target and sums[1] == target and sums[2] == target\n    for i in range(4):\n        if sums[i] + matchsticks[index] <= target:\n            sums[i] += matchsticks[index]\n            if dfs(matchsticks, sums, target, index + 1):\n                return True\n            sums[i] -= matchsticks[index]\n    return False\n\n",
            "javascript": "function makesquare(matchsticks) {\n    if (matchsticks.length < 4) return false;\n    const total = matchsticks.reduce((a, b) => a + b, 0);\n    if (total % 4 !== 0) return false;\n    const target = total / 4;\n    matchsticks.sort((a, b) => b - a);\n    const sums = [0, 0, 0, 0];\n    return dfs(matchsticks, sums, target, 0);\n}\n\nfunction dfs(matchsticks, sums, target, index) {\n    if (index === matchsticks.length) {\n        return sums[0] === target && sums[1] === target && sums[2] === target;\n    }\n    for (let i = 0; i < 4; i++) {\n        if (sums[i] + matchsticks[index] <= target) {\n            sums[i] += matchsticks[index];\n            if (dfs(matchsticks, sums, target, index + 1)) return true;\n            sums[i] -= matchsticks[index];\n        }\n    }\n    return false;\n}\n\n",
            "explanation": "1. First, we check if there are enough matchsticks and if the total length of matchsticks can be divided by 4 to form a square. If not, return false.\n2. Sort the matchsticks in descending order to traverse them from the largest to the smallest. This helps to prune branches in the depth-first search.\n3. Utilize a recursive depth-first search function to try placing matchsticks i (0 <= i < 4) to form each side. If we reach the sum of all the matchsticks in a square, return true.\n4. Make sure each matchstick is used exactly once and check if the assigned sums satisfy the required target.\n5. If we reach the end and could not make a square, return false."
        },
        "structure": {
            "c++": "#include <vector>\n#include <numeric>\n#include <algorithm>\n\nbool makesquare(std::vector<int>& matchsticks) \n    // Your code here\n}\n\n",
            "java": "import java.util.Arrays;\n\npublic class Solution \n    // Your code here\n}\n\n",
            "python": "from itertools import chain\n    # Your code here\n\n",
            "javascript": "function makesquare(matchsticks) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <iostream>\n\nbool dfs(std::vector<int>& matchsticks, std::vector<int>& sums, int target, int index);\n\nbool makesquare(std::vector<int>& matchsticks) {\n    if (matchsticks.size() < 4) return false;\n    int sum = std::accumulate(matchsticks.begin(), matchsticks.end(), 0);\n    if (sum % 4) return false;\n    int target = sum / 4;\n    std::sort(matchsticks.rbegin(), matchsticks.rend());\n    std::vector<int> sums(4, 0);\n    return dfs(matchsticks, sums, target, 0);\n}\n\nbool dfs(std::vector<int>& matchsticks, std::vector<int>& sums, int target, int index) {\n    if (index == matchsticks.size()) {\n        return sums[0] == target && sums[1] == target && sums[2] == target;\n    }\n    for (int i = 0; i < 4; ++i) {\n        if (sums[i] + matchsticks[index] <= target) {\n            sums[i] += matchsticks[index];\n            if (dfs(matchsticks, sums, target, index + 1)) return true;\n            sums[i] -= matchsticks[index];\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::vector<int> matchsticks = $args;\n    bool result = makesquare(matchsticks);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "java": "public boolean makesquare(int[] matchsticks) {\n        if (matchsticks == null || matchsticks.length < 4) return false;\n        int sum = 0;\n        for (int matchstick : matchsticks) sum += matchstick;\n        if (sum % 4 != 0) return false;\n        int target = sum / 4;\n        Arrays.sort(matchsticks);\n        reverse(matchsticks);\n        int[] sums = new int[4];\n        return dfs(matchsticks, sums, target, 0);\n    }\n\n    private void reverse(int[] nums) {\n        int left = 0, right = nums.length - 1;\n        while (left < right) {\n            int temp = nums[left];\n            nums[left] = nums[right];\n            nums[right] = temp;\n            left++;\n            right--;\n        }\n    }\n\n    private boolean dfs(int[] matchsticks, int[] sums, int target, int index) {\n        if (index == matchsticks.length) {\n            return sums[0] == target && sums[1] == target && sums[2] == target;\n        }\n        for (int i = 0; i < 4; i++) {\n            if (sums[i] + matchsticks[index] <= target) {\n                sums[i] += matchsticks[index];\n                if (dfs(matchsticks, sums, target, index + 1)) return true;\n                sums[i] -= matchsticks[index];\n            }\n        }\n        return false;\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    matchsticks = $args[0]\n    result = makesquare(matchsticks)\n    print(result)",
            "javascript": "function makesquare(matchsticks) {\n    if (matchsticks.length < 4) return false;\n    const total = matchsticks.reduce((a, b) => a + b, 0);\n    if (total % 4 !== 0) return false;\n    const target = total / 4;\n    matchsticks.sort((a, b) => b - a);\n    const sums = [0, 0, 0, 0];\n    return dfs(matchsticks, sums, target, 0);\n}\n\nfunction dfs(matchsticks, sums, target, index) {\n    if (index === matchsticks.length) {\n        return sums[0] === target && sums[1] === target && sums[2] === target;\n    }\n    for (let i = 0; i < 4; i++) {\n        if (sums[i] + matchsticks[index] <= target) {\n            sums[i] += matchsticks[index];\n            if (dfs(matchsticks, sums, target, index + 1)) return true;\n            sums[i] -= matchsticks[index];\n        }\n    }\n    return false;\n}"
        }
    },
    "474": {
        "title": "Largest Subset of Binary Strings",
        "description": "Given an array of binary strings `strs` and two integers `m` and `n`, find the size of the largest subset of `strs` such that there are at most `m` 0's and `n` 1's in the subset. A set `x` is a subset of a set `y` if all elements of `x` are also elements of `y`.",
        "example": "Example:\n\nInput: strs = [\"10\", \"0001\", \"111001\", \"1\", \"0\"], m = 5, n = 3\nOutput: 4\nExplanation: The largest subset with at most 5 0's and 3 1's is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4. Other valid but smaller subsets include {\"0001\", \"1\"} and {\"10\", \"1\", \"0\"}. {\"111001\"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "10",
                        "0001",
                        "111001",
                        "1",
                        "0"
                    ],
                    5,
                    3
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    1,
                    1
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    0,
                    0
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    2,
                    2
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    3,
                    1
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    1,
                    3
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    0,
                    1
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    1,
                    0
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    2,
                    1
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    1,
                    2
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    3,
                    0
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    0,
                    3
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    2,
                    0
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    0,
                    2
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    1,
                    1
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    2,
                    2
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    3,
                    3
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    4,
                    4
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    5,
                    5
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    6,
                    6
                ]
            ],
            "outputs": [
                4,
                2,
                3,
                3,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <algorithm>\n\nint findMaxForm(std::vector<std::string>& strs, int m, int n) {\n    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1));\n    \n    for (const std::string& str: strs) {\n        int ones = std::count(str.begin(), str.end(), '1');\n        int zeros = str.length() - ones;\n        \n        for (int i = m; i >= zeros; --i) {\n            for (int j = n; j >= ones; --j) {\n                dp[i][j] = std::max(dp[i][j], dp[i - zeros][j - ones] + 1);\n            }\n        }\n    }\n    return dp[m][n];\n}\n",
            "java": "import java.util.Arrays;\n\npublic int findMaxForm(String[] strs, int m, int n) {\n    int[][] dp = new int[m + 1][n + 1];\n    \n    for (String str: strs) {\n        int ones = (int) str.chars().filter(ch -> ch == '1').count();\n        int zeros = str.length() - ones;\n        \n        for (int i = m; i >= zeros; --i) {\n            for (int j = n; j >= ones; --j) {\n                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);\n            }\n        }\n    }\n    return dp[m][n];\n}\n",
            "python": "def findMaxForm(strs, m, n):\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for s in strs:\n        ones = s.count('1')\n        zeros = len(s) - ones\n        \n        for i in range(m, zeros - 1, -1):\n            for j in range(n, ones - 1, -1):\n                dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n    \n    return dp[m][n]\n",
            "javascript": "function findMaxForm(strs, m, n) {\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    \n    for (const str of strs) {\n        const ones = str.split('').filter(ch => ch === '1').length;\n        const zeros = str.length - ones;\n        \n        for (let i = m; i >= zeros; --i) {\n            for (let j = n; j >= ones; --j) {\n                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);\n            }\n        }\n    }\n    return dp[m][n];\n}\n",
            "explanation": "1. Initialize a 2-dimensional DP table dp, where dp[i][j] represents the maximum size of a subset with i 0's and j 1's.\n2. Loop through each string in strs.\n3. Count the number of 0's (zeros) and 1's (ones) in each string.\n4. Iterate backward through the DP table, updating dp[i][j] to the maximum of its current value and dp[i - zeros][j - ones] + 1. This is because a string with zeros 0's and ones 1's will be included in the subset if i 0's and j 1's are available.\n5. After processing all the strings, return dp[m][n], which represents the size of the largest subset with at most m 0's and n 1's."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <algorithm>\n\nint findMaxForm(std::vector<std::string>& strs, int m, int n) \n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\n\npublic int findMaxForm(String[] strs, int m, int n) \n    // Your code here\n}\n",
            "python": "def findMaxForm(strs, m, n):\n    # Your code here\n\n",
            "javascript": "function findMaxForm(strs, m, n) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <algorithm>\n\nint main() {\n    std::vector<std::string> strs = $args;\n    int m = 5;\n    int n = 3;\n    int result = findMaxForm(strs, m, n);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int findMaxForm(String[] strs, int m, int n) {\n    int[][] dp = new int[m + 1][n + 1];\n    \n    for (String str: strs) {\n        int ones = (int) str.chars().filter(ch -> ch == '1').count();\n        int zeros = str.length() - ones;\n        \n        for (int i = m; i >= zeros; --i) {\n            for (int j = n; j >= ones; --j) {\n                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);\n            }\n        }\n    }\n    return dp[m][n];\n}",
            "python": "if __name__ == \"__main__\":\n    strs = $args[0]\n    m = $args[1]\n    n = $args[2]\n    result = findMaxForm(strs, m, n)\n    print(result)",
            "javascript": "function findMaxForm(strs, m, n) {\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    \n    for (const str of strs) {\n        const ones = str.split('').filter(ch => ch === '1').length;\n        const zeros = str.length - ones;\n        \n        for (let i = m; i >= zeros; --i) {\n            for (let j = n; j >= ones; --j) {\n                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);\n            }\n        }\n    }\n    return dp[m][n];\n}"
        }
    },
    "475": {
        "title": "Minimum Radius Standard of Heaters",
        "description": "Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses. Every house can be warmed, as long as the house is within the heater's warm radius range. Given the positions of houses and heaters on a horizontal line, return the minimum radius standard of heaters so that those heaters could cover all houses. Notice that all the heaters follow your radius standard, and the warm radius will be the same.",
        "example": "Example:\n\nInput: houses = [1,2,3], heaters = [2]\nOutput: 1\nExplanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3
                ],
                [
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4
                ],
                [
                    1,
                    4
                ],
                [
                    1,
                    5
                ],
                [
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ]
            ],
            "outputs": [
                "1",
                "1",
                "1",
                "1",
                "3",
                "3",
                "5",
                "4",
                "4",
                "4",
                "4",
                "4",
                "4",
                "4",
                "4",
                "4",
                "4",
                "4",
                "4",
                "4"
            ]
        },
        "sample_code": {
            "c++": "int findRadius(vector<int>& houses, vector<int>& heaters) {\n    sort(houses.begin(), houses.end());\n    sort(heaters.begin(), heaters.end());\n\n    int result = 0;\n    int i = 0;\n\n    for (int house : houses) {\n        while (i < heaters.size() - 1 &&\n               abs(heaters[i + 1] - house) <= abs(heaters[i] - house)) {\n            i++;\n        }\n        result = max(result, abs(heaters[i] - house));\n    }\n    return result;\n}\n",
            "java": "public int findRadius(int[] houses, int[] heaters) {\n    Arrays.sort(houses);\n    Arrays.sort(heaters);\n    int result = 0;\n    int i = 0;\n\n    for (int house : houses) {\n        while (i < heaters.length - 1 &&\n               Math.abs(heaters[i + 1] - house) <= Math.abs(heaters[i] - house)) {\n            i++;\n        }\n        result = Math.max(result, Math.abs(heaters[i] - house));\n    }\n    return result;\n}\n",
            "python": "def findRadius(houses, heaters):\n    houses.sort()\n    heaters.sort()\n    result, i = 0, 0\n\n    for house in houses:\n        while i < len(heaters) - 1 and abs(heaters[i + 1] - house) <= abs(heaters[i] - house):\n            i += 1\n        result = max(result, abs(heaters[i] - house))\n\n    return result\n",
            "javascript": "function findRadius(houses, heaters) {\n    houses.sort((a, b) => a - b);\n    heaters.sort((a, b) => a - b);\n    let result = 0;\n    let i = 0;\n\n    for (const house of houses) {\n        while (i < heaters.length - 1 &&\n               Math.abs(heaters[i + 1] - house) <= Math.abs(heaters[i] - house)) {\n            i++;\n        }\n        result = Math.max(result, Math.abs(heaters[i] - house));\n    }\n    return result;\n}\n",
            "explanation": "1. Sort both the arrays `houses` and `heaters`.\n2. Initialize two variables `result` and `i` to store the minimum required radius and the current heater index, respectively.\n3. Iterate through the `houses` array.\n   1. Using a nested while loop:\n   2. Increment `i` until the current heater is closer to the current house than the next heater.\n   3. Update `result` with the maximum distance between a house and a heater we have seen so far.\n4. After iterating through all houses, `result` contains the minimum radius for the heaters to cover all houses."
        },
        "structure": {
            "c++": "int findRadius(vector<int>& houses, vector<int>& heaters) \n    // Your code here\n}\n",
            "java": "public int findRadius(int[] houses, int[] heaters) \n    // Your code here\n}\n",
            "python": "def findRadius(houses, heaters):\n    # Your code here\n\n",
            "javascript": "function findRadius(houses, heaters) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int findRadius(vector<int>& houses, vector<int>& heaters) {\n    sort(houses.begin(), houses.end());\n    sort(heaters.begin(), heaters.end());\n\n    int result = 0;\n    int i = 0;\n\n    for (int house : houses) {\n        while (i < heaters.size() - 1 &&\n               abs(heaters[i + 1] - house) <= abs(heaters[i] - house)) {\n            i++;\n        }\n        result = max(result, abs(heaters[i] - house));\n    }\n    return result;\n}",
            "java": "public int findRadius(int[] houses, int[] heaters) {\n    Arrays.sort(houses);\n    Arrays.sort(heaters);\n    int result = 0;\n    int i = 0;\n\n    for (int house : houses) {\n        while (i < heaters.length - 1 &&\n               Math.abs(heaters[i + 1] - house) <= Math.abs(heaters[i] - house)) {\n            i++;\n        }\n        result = Math.max(result, Math.abs(heaters[i] - house));\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    houses = $args[0]\n    heaters = $args[1]\n    result = findRadius(houses, heaters)\n    print(result)",
            "javascript": "function findRadius(houses, heaters) {\n    houses.sort((a, b) => a - b);\n    heaters.sort((a, b) => a - b);\n    let result = 0;\n    let i = 0;\n\n    for (const house of houses) {\n        while (i < heaters.length - 1 &&\n               Math.abs(heaters[i + 1] - house) <= Math.abs(heaters[i] - house)) {\n            i++;\n        }\n        result = Math.max(result, Math.abs(heaters[i] - house));\n    }\n    return result;\n}"
        }
    },
    "476": {
        "title": "Binary Complement",
        "description": "Given an integer `num`, find its complement by flipping all the `0`'s to `1`'s and all the `1`'s to `0`'s in its binary representation.",
        "example": "Example:\n\nInput: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So the output is 2.",
        "level": "Easy",
        "tags": [
            "bit manipulation",
            "binary representation"
        ],
        "test_cases": {
            "inputs": [
                5,
                1,
                0,
                10,
                15,
                100,
                255,
                1023,
                2047,
                4095,
                8191,
                16383,
                32767,
                65535,
                131071,
                262143,
                524287,
                1048575,
                2097151,
                4194303
            ],
            "outputs": [
                2,
                0,
                1,
                5,
                0,
                27,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "int findComplement(int num) {\n    int bitLength = 0;\n    int mask = num;\n    while (mask > 0) {\n        mask >>= 1;\n        bitLength++;\n    }\n    int allOnes = (1 << bitLength) - 1;\n\n    return num ^ allOnes;\n}\n",
            "java": "public int findComplement(int num) {\n    int bitLength = 0;\n    int mask = num;\n    while (mask > 0) {\n        mask >>= 1;\n        bitLength++;\n    }\n    int allOnes = (1 << bitLength) - 1;\n\n    return num ^ allOnes;\n}\n",
            "python": "def find_complement(num: int) -> int:\n    bit_length = 0\n    mask = num\n    while mask > 0:\n        mask >>= 1\n        bit_length += 1\n    all_ones = (1 << bit_length) - 1\n\n    return num ^ all_ones\n",
            "javascript": "function findComplement(num) {\n    let bitLength = 0;\n    let mask = num;\n    while (mask > 0) {\n        mask >>= 1;\n        bitLength++;\n    }\n    const allOnes = (1 << bitLength) - 1;\n\n    return num ^ allOnes;\n}\n",
            "explanation": "First, we calculate the number of bits in the binary representation of the input integer `num`. We do this by consecutively right-shifting the number (bitwise operation) and counting the iterations until the number becomes 0. This gives us the length of the binary representation.\n\nOnce we have the length, we create a bitmask of the same length with all bits set to 1 (for example, if the length is 3, the bitmask would be 111 in binary). To get the complement of the input integer, we then XOR (`^` operator) the number with this all-1 mask. The XOR operation returns 1 when the input bits are different and 0 when they are the same, so if we have a 0 in the input, we will get 1 and vice versa. This way, we get the complement of the original number.\n\nFinally, we return the resulting number, which is the complement of the input integer `num`."
        },
        "structure": {
            "c++": "int findComplement(int num) \n    // Your code here\n}\n",
            "java": "public int findComplement(int num) \n    // Your code here\n}\n",
            "python": "def find_complement(num: int) -> int:\n    # Your code here\n\n",
            "javascript": "function findComplement(num) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int num = $args;\n    int result = findComplement(num);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int findComplement(int num) {\n    int bitLength = 0;\n    int mask = num;\n    while (mask > 0) {\n        mask >>= 1;\n        bitLength++;\n    }\n    int allOnes = (1 << bitLength) - 1;\n\n    return num ^ allOnes;\n}",
            "python": "if __name__ == \"__main__\":\n    num = $args[0]\n    result = find_complement(num)\n    print(result)",
            "javascript": "function main() {\n    const num = $args;\n    const bitLength = 0;\n    let mask = num;\n    while (mask > 0) {\n        mask >>= 1;\n        bitLength++;\n    }\n    const allOnes = (1 << bitLength) - 1;\n\n    const result = num ^ allOnes;\n    console.log(result);\n}"
        }
    },
    "477": {
        "title": "Hamming Distance Sum",
        "description": "Given an integer array `nums`, return the sum of Hamming distances between all the pairs of the integers in `nums`. The Hamming distance between two integers is the number of positions at which the corresponding bits are different.",
        "example": "Example:\n\nInput: nums = [4,14,2]\nOutput: 6\nExplanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just showing the four bits relevant in this case). The answer will be: HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.",
        "level": "Medium",
        "tags": [
            "bit manipulation",
            "array"
        ],
        "test_cases": {
            "inputs": [
                [
                    4,
                    14,
                    2
                ],
                [
                    4,
                    14,
                    4
                ],
                [
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50
                ],
                [
                    100,
                    200,
                    300,
                    400,
                    500
                ],
                [
                    1024,
                    2048,
                    4096,
                    8192
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    15,
                    15,
                    15,
                    15,
                    15
                ],
                [
                    16,
                    16,
                    16,
                    16,
                    16
                ]
            ],
            "outputs": [
                6,
                4,
                0,
                10,
                40,
                80,
                48,
                90,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "int totalHammingDistance(vector<int>& nums) {\n    int total_distance = 0, n = nums.size();\n    \n    for (int i = 0; i < 32; ++i) {\n        int bit_count = 0;\n        for (int num : nums) {\n            bit_count += (num >> i) & 1;\n        }\n        total_distance += bit_count * (n - bit_count);\n    }\n    \n    return total_distance;\n}\n",
            "java": "public int totalHammingDistance(int[] nums) {\n    int totalDistance = 0, n = nums.length;\n    \n    for (int i = 0; i < 32; ++i) {\n        int bitCount = 0;\n        for (int num : nums) {\n            bitCount += (num >> i) & 1;\n        }\n        totalDistance += bitCount * (n - bitCount);\n    }\n    \n    return totalDistance;\n}\n",
            "python": "def total_hamming_distance(nums):\n    total_distance = 0\n    n = len(nums)\n\n    for i in range(32):\n        bit_count = sum(((num >> i) & 1) for num in nums)\n        total_distance += bit_count * (n - bit_count)\n\n    return total_distance\n",
            "javascript": "function totalHammingDistance(nums) {\n    let totalDistance = 0, n = nums.length;\n    \n    for (let i = 0; i < 32; ++i) {\n        let bitCount = 0;\n        for (let num of nums) {\n            bitCount += (num >> i) & 1;\n        }\n        totalDistance += bitCount * (n - bitCount);\n    }\n    \n    return totalDistance;\n}\n",
            "explanation": "The algorithm iterates through the 32-bit positions of the integers. For each bit position, it counts the number of integers in the array that have a 1 at that position. Then, it calculates the Hamming distance for that bit position by multiplying the number of 1s by the number of 0s at that position. Finally, it sums up the Hamming distances for all the bit positions to find the total Hamming distance between all the pairs of integers in the array. This way, the algorithm has a linear runtime complexity with respect to the size of the input array."
        },
        "structure": {
            "c++": "int totalHammingDistance(vector<int>& nums) \n    // Your code here\n}\n",
            "java": "public int totalHammingDistance(int[] nums) \n    // Your code here\n}\n",
            "python": "def total_hamming_distance(nums):\n    # Your code here\n\n",
            "javascript": "function totalHammingDistance(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> nums = $args;\n    int result = totalHammingDistance(nums);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int callTotalHammingDistance(int[] nums) {\n    int totalDistance = 0, n = nums.length;\n    \n    for (int i = 0; i < 32; ++i) {\n        int bitCount = 0;\n        for (int num : nums) {\n            bitCount += (num >> i) & 1;\n        }\n        totalDistance += bitCount * (n - bitCount);\n    }\n    \n    return totalDistance;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = total_hamming_distance(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = totalHammingDistance(nums);\n    console.log(result);\n}"
        }
    },
    "478": {
        "title": "Random Point Inside Circle",
        "description": "You are given the radius and the position of the center of a circle. Implement the function `randPoint` which generates a uniform random point inside the circle.\n\nImplement the `Solution` class:\n\n- `Solution(double radius, double x_center, double y_center)`: Initializes the object with the radius of the circle `radius` and the position of the center `(x_center, y_center)`.\n- `randPoint()`: Returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array `[x, y]`.",
        "example": "Example:\n\nInput:\nSolution(1.0, 0.0, 0.0)\n\nOutput:\nnull\n\nExplanation:\nSolution solution = new Solution(1.0, 0.0, 0.0);\nsolution.randPoint(); // return [-0.02493, -0.38077]\nsolution.randPoint(); // return [0.82314, 0.38945]\nsolution.randPoint(); // return [0.36572, 0.17248]",
        "level": "Medium",
        "tags": [
            "Math",
            "Geometry"
        ],
        "test_cases": {
            "inputs": [
                [
                    1.0,
                    0.0,
                    0.0
                ],
                [
                    2.5,
                    1.0,
                    -2.0
                ],
                [
                    0.5,
                    3.0,
                    4.0
                ],
                [
                    10.0,
                    -5.0,
                    5.0
                ],
                [
                    7.5,
                    0.0,
                    0.0
                ],
                [
                    3.0,
                    2.0,
                    2.0
                ],
                [
                    1.5,
                    -3.0,
                    -3.0
                ],
                [
                    4.0,
                    1.0,
                    1.0
                ],
                [
                    2.0,
                    0.0,
                    0.0
                ],
                [
                    6.0,
                    2.5,
                    -1.5
                ],
                [
                    0.75,
                    3.5,
                    2.5
                ],
                [
                    8.0,
                    -4.0,
                    4.0
                ],
                [
                    5.5,
                    0.0,
                    0.0
                ],
                [
                    2.5,
                    1.5,
                    1.5
                ],
                [
                    1.25,
                    -2.5,
                    -2.5
                ],
                [
                    3.5,
                    1.0,
                    1.0
                ],
                [
                    1.0,
                    0.0,
                    0.0
                ],
                [
                    2.5,
                    1.0,
                    -2.0
                ],
                [
                    0.5,
                    3.0,
                    4.0
                ],
                [
                    10.0,
                    -5.0,
                    5.0
                ]
            ],
            "outputs": [
                "null",
                "[-0.02493, -0.38077]",
                "[0.82314, 0.38945]",
                "[0.36572, 0.17248]",
                "[6.12345, -0.98765]",
                "[2.0, 2.0]",
                "[-2.0, -2.0]",
                "[1.0, 1.0]",
                "[0.0, 0.0]",
                "[3.53553, -0.70711]",
                "[3.0, 3.0]",
                "[-4.0, -4.0]",
                "[3.53553, 0.70711]",
                "[1.5, 1.5]",
                "[-1.5, -1.5]",
                "[2.0, 1.0]",
                "[0.0, 0.0]",
                "[2.5, -0.5]",
                "[4.0, 1.0]",
                "[0.5, 0.5]",
                "[-5.0, -5.0]"
            ]
        },
        "sample_code": {
            "c++": "#include <random>\n#include <cmath>\n\nclass Solution {\npublic:\n    std::default_random_engine gen;\n    std::uniform_real_distribution<double> dist;\n    double radius, x_center, y_center;\n    \n    Solution(double radius, double x_center, double y_center): dist(0, 1), radius(radius), x_center(x_center), y_center(y_center) {}\n    \n    vector<double> randPoint() {\n        double r = sqrt(dist(gen)) * radius;\n        double theta = dist(gen) * 2 * M_PI;\n        return {x_center + r * cos(theta), y_center + r * sin(theta)};\n    }\n};\n",
            "java": "import java.util.Random;\n\npublic class Solution {\n    private double radius;\n    private double x_center;\n    private double y_center;\n    private Random random;\n\n    public Solution(double radius, double x_center, double y_center) {\n        this.radius = radius;\n        this.x_center = x_center;\n        this.y_center = y_center;\n        random = new Random();\n    }\n\n    public double[] randPoint() {\n        double r = Math.sqrt(random.nextDouble()) * radius;\n        double theta = random.nextDouble() * 2 * Math.PI;\n        return new double[]{x_center + r * Math.cos(theta), y_center + r * Math.sin(theta)};\n    }\n}\n",
            "python": "import random\nfrom math import sqrt, pi, cos, sin\n\nclass Solution:\n\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        r = sqrt(random.random()) * self.radius\n        theta = random.random() * 2 * pi\n        return [self.x_center + r * cos(theta), self.y_center + r * sin(theta)]\n",
            "javascript": "class Solution {\n    constructor(radius, x_center, y_center) {\n        this.radius = radius;\n        this.x_center = x_center;\n        this.y_center = y_center;\n    }\n\n    randPoint() {\n        const r = Math.sqrt(Math.random()) * this.radius;\n        const theta = Math.random() * 2 * Math.PI;\n        return [this.x_center + r * Math.cos(theta), this.y_center + r * Math.sin(theta)];\n    }\n}\n",
            "explanation": "We first generate a random radius `r` within the circle by generating a random value between 0 and 1, taking the square root of the value, and multiplying it with the circle's `radius`. We do this sqrt operation because the area of a circle is A=\u00cf\u20acr\u00c2\u00b2, which means that the random point distribution is proportional to r\u00c2\u00b2, so the uniform rectilinear random generator is transformed to be a uniform circular one.\n\nNext, we generate a random angle `theta` between 0 and 2\u00cf\u20ac, which represents the angle of the polar coordinate inside the circle. \n\nWith the random radius `r` and angle `theta`, we can use trigonometry to calculate the x and y offsets from the circle's center: `r * cos(theta)` for the x-coordinate and `r * sin(theta)` for the y-coordinate.\n\nFinally, we add the circle's x_center and y_center to the x and y offsets to get the absolute x and y coordinate of the random point within the circle."
        },
        "structure": {
            "c++": "#include <random>\n#include <cmath>\n\nclass Solution \n    // Your code here\n};\n",
            "java": "import java.util.Random;\n\npublic class Solution \n    // Your code here\n}\n",
            "python": "import random\n    # Your code here\n\n",
            "javascript": "class Solution \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <random>\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    double radius = $args;\n    double x_center = $args;\n    double y_center = $args;\n    \n    Solution obj(radius, x_center, y_center);\n    vector<double> result = obj.randPoint();\n    \n    cout << \"[\" << result[0] << \", \" << result[1] << \"]\" << endl;\n    \n    return 0;\n}",
            "java": "public double[] randPoint() {\n        double r = Math.sqrt(random.nextDouble()) * radius;\n        double theta = random.nextDouble() * 2 * Math.PI;\n        return new double[]{x_center + r * Math.cos(theta), y_center + r * Math.sin(theta)};\n    }",
            "python": "if __name__ == \"__main__\":\n    radius = $args[0]\n    x_center = $args[1]\n    y_center = $args[2]\n    obj = Solution(radius, x_center, y_center)\n    result = obj.randPoint()\n    print(result)",
            "javascript": "function main() {\n    const radius = $args[0];\n    const x_center = $args[1];\n    const y_center = $args[2];\n\n    const obj = new Solution(radius, x_center, y_center);\n    const result = obj.randPoint();\n\n    console.log(result);\n}"
        }
    },
    "479": {
        "title": "Largest Palindromic Integer",
        "description": "Given an integer n, return the largest palindromic integer that can be represented as the product of two n-digit integers. Since the answer can be very large, return it modulo 1337.",
        "example": "Example:\n\nInput: n = 2\nOutput: 987\nExplanation: 99 x 91 = 9009, 9009 % 1337 = 987",
        "level": "Medium",
        "tags": [
            "Math",
            "Palindrome"
        ],
        "test_cases": {
            "inputs": [
                2,
                1,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "outputs": [
                987,
                9,
                12321,
                597795,
                9009,
                906609,
                99000099,
                9966006699
            ]
        },
        "sample_code": {
            "c++": "int largestPalindrome(int n) {\n    if (n == 1) return 9;\n    int upper_limit = pow(10, n) - 1;\n    int lower_limit = upper_limit / 10;\n    for (int i = upper_limit; i > lower_limit; --i) {\n        long long temp = i;\n        long long reverse = 0;\n        while (temp != 0) {\n            reverse = reverse * 10 + temp % 10;\n            temp /= 10;\n        }\n        long long palindrome = i * pow(10, n) + reverse;\n        for (long long j = upper_limit; j > lower_limit; --j) {\n            long long product = palindrome / j;\n            if (palindrome % j == 0 && product <= upper_limit) {\n                return palindrome % 1337;\n            }\n        }\n    }\n    return -1;\n}\n",
            "java": "int largestPalindrome(int n) {\n    if (n == 1) return 9;\n    int upper_limit = (int) Math.pow(10, n) - 1;\n    int lower_limit = upper_limit / 10;\n    for (int i = upper_limit; i > lower_limit; --i) {\n        long temp = i;\n        long reverse = 0;\n        while (temp != 0) {\n            reverse = reverse * 10 + temp % 10;\n            temp /= 10;\n        }\n        long palindrome = i * (long) Math.pow(10, n) + reverse;\n        for (long j = upper_limit; j > lower_limit; --j) {\n            long product = palindrome / j;\n            if (palindrome % j == 0 && product <= upper_limit) {\n                return (int) (palindrome % 1337);\n            }\n        }\n    }\n    return -1;\n}\n",
            "python": "def largestPalindrome(n):\n    if n == 1: \n        return 9\n    upper_limit = 10**n - 1\n    lower_limit = upper_limit // 10\n    for i in range(upper_limit, lower_limit, -1):\n        temp = i\n        reverse = 0\n        while temp != 0:\n            reverse = reverse * 10 + temp % 10\n            temp //= 10\n        palindrome = i * (10**n) + reverse\n        for j in range(upper_limit, lower_limit, -1):\n            product = palindrome // j\n            if palindrome % j == 0 and product <= upper_limit:\n                return palindrome % 1337\n    return -1\n",
            "javascript": "function largestPalindrome(n) {\n    if (n === 1) return 9; // Handle 1-digit numbers\n    let upper_limit = Math.pow(10, n) - 1;\n    let lower_limit = Math.floor(upper_limit / 10);\n    for (let i = upper_limit; i > lower_limit; i--) {\n        let temp = i;\n        let reverse = 0;\n        while (temp !== 0) {\n            reverse = reverse * 10 + temp % 10;\n            temp = Math.floor(temp / 10);\n        }\n        let palindrome = i * Math.pow(10, n) + reverse;\n        for (let j = upper_limit; j > lower_limit; j--) {\n            let product = Math.floor(palindrome / j);\n            if (palindrome % j === 0 && product <= upper_limit) {\n                return palindrome % 1337;\n            }\n        }\n    }\n    return -1;\n}\n\n",
            "explanation": "1. If n is 1, return 9 (the largest palindromic product of two 1-digit numbers is 9).\n2. Calculate the upper and lower limits for the n-digit numbers.\n3. Loop through the numbers in reverse order, starting from the upper limit down to the lower limit.\n4. Within the loop, find the reverse of the current iteration number.\n5. Calculate the possible palindrome by concatenating the current number and its reverse.\n6. Loop through the numbers again to find the two factors of the palindrome.\n7. If a palindrome with valid factors is found, return the palindrome modulo 1337.\n8. If no such palindrome is found, return -1."
        },
        "structure": {
            "c++": "int largestPalindrome(int n) \n    // Your code here\n}\n",
            "java": "int largestPalindrome(int n) \n    // Your code here\n}\n",
            "python": "def largestPalindrome(n):\n    # Your code here\n\n",
            "javascript": "function largestPalindrome(n) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = largestPalindrome(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "int largestPalindrome(int n) {\n    if (n == 1) return 9;\n    int upper_limit = (int) Math.pow(10, n) - 1;\n    int lower_limit = upper_limit / 10;\n    for (int i = upper_limit; i > lower_limit; --i) {\n        long temp = i;\n        long reverse = 0;\n        while (temp != 0) {\n            reverse = reverse * 10 + temp % 10;\n            temp /= 10;\n        }\n        long palindrome = i * (long) Math.pow(10, n) + reverse;\n        for (long j = upper_limit; j > lower_limit; --j) {\n            long product = palindrome / j;\n            if (palindrome % j == 0 && product <= upper_limit) {\n                return (int) (palindrome % 1337);\n            }\n        }\n    }\n    return -1;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    result = largestPalindrome(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = largestPalindrome(n);\n    console.log(result);\n}"
        }
    },
    "480": {
        "title": "Sliding Window Median",
        "description": "Given an integer array `nums` and an integer `k`, find the median of each sliding window of size `k` as it moves from left to right. If the size of the window is even, return the average of the two middle elements.",
        "example": "Example 1:\n\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\nExplanation: \nWindow position                Median\n---------------                -----\n[1  3  -1] -3  5  3  6  7        1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7        3\n 1  3  -1  -3 [5  3  6] 7        5\n 1  3  -1  -3  5 [3  6  7]       6\n\nExample 2:\n\nInput: nums = [1,2,3,4,2,3,1,4,2], k = 3\nOutput: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]",
        "level": "Medium",
        "tags": [
            "array",
            "sliding window",
            "median"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    3,
                    -1,
                    -3,
                    5,
                    3,
                    6,
                    7
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    2,
                    3,
                    1,
                    4,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11
                ],
                [
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12
                ],
                [
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13
                ],
                [
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14
                ],
                [
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ]
            ],
            "outputs": [
                "[1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]",
                "[2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]",
                "[2.00000,3.00000,4.00000,5.00000,6.00000,7.00000,8.00000]",
                "[7.00000,6.00000,5.00000,4.00000,3.00000,2.00000,1.00000]",
                "[5.00000,5.00000,5.00000,5.00000,5.00000,5.00000,5.00000]",
                "[1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000]",
                "[2.00000,3.00000,4.00000,5.00000,6.00000,7.00000,8.00000,9.00000]",
                "[9.00000,8.00000,7.00000,6.00000,5.00000,4.00000,3.00000,2.00000]",
                "[1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000]",
                "[2.00000,3.00000,4.00000,5.00000,6.00000,7.00000,8.00000,9.00000,10.00000]",
                "[10.00000,9.00000,8.00000,7.00000,6.00000,5.00000,4.00000,3.00000,2.00000,1.00000]",
                "[1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000]",
                "[2.00000,3.00000,4.00000,5.00000,6.00000,7.00000,8.00000,9.00000,10.00000,11.00000]",
                "[11.00000,10.00000,9.00000,8.00000,7.00000,6.00000,5.00000,4.00000,3.00000,2.00000,1.00000]",
                "[1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000]",
                "[2.00000,3.00000,4.00000,5.00000,6.00000,7.00000,8.00000,9.00000,10.00000,11.00000,12.00000]",
                "[12.00000,11.00000,10.00000,9.00000,8.00000,7.00000,6.00000,5.00000,4.00000,3.00000,2.00000,1.00000]",
                "[1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000]",
                "[2.00000,3.00000,4.00000,5.00000,6.00000,7.00000,8.00000,9.00000,10.00000,11.00000,12.00000,13.00000]",
                "[13.00000,12.00000,11.00000,10.00000,9.00000,8.00000,7.00000,6.00000,5.00000,4.00000,3.00000,2.00000,1.00000]",
                "[1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000,1.00000]",
                "[2.00000,3.00000,4.00000,5.00000,6.00000,7.00000,8.00000,9.00000,10.00000,11.00000,12.00000,13.00000,14.00000]",
                "[14.00000,13.00000,12.00000,11.00000,10.00000,9.00000,8.00000,7.00000,6.00000,5.00000,4.00000,3.00000,2.00000,1.00000]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <set>\n\nstd::vector<double> medianSlidingWindow(std::vector<int>& nums, int k) {\n    std::multiset<int> window(nums.begin(), nums.begin() + k);\n    auto mid = std::next(window.begin(), k / 2);\n    std::vector<double> medians;\n\n    for (int i = k;; i++) {\n        medians.push_back((double(*mid) + *std::prev(mid, 1 - k % 2)) / 2);\n        \n        if (i == nums.size()) {\n            return medians;\n        }\n        window.insert(nums[i]);\n        if (nums[i] < *mid) {\n            mid--;\n        }\n        if (nums[i - k] <= *mid) {\n            mid++;\n        }\n        window.erase(window.lower_bound(nums[i - k]));\n    }\n}\n\n",
            "java": "import java.util.TreeMap;\n\npublic double[] medianSlidingWindow(int[] nums, int k) {\n    TreeMap<Integer, Integer> window = new TreeMap<>();\n    int n = nums.length;\n    double[] result = new double[n - k + 1];\n\n    for (int i = 0; i < k; i++) {\n        window.put(nums[i], window.getOrDefault(nums[i], 0) + 1);\n    }\n\n    for (int i = k; i <= n; i++) {\n        int cnt = 0, mid1 = 0, mid2 = 0;\n        for (Integer num : window.keySet()) {\n            cnt += window.get(num);\n            if (cnt >= (k + 1) / 2 && mid1 == 0) {\n                mid1 = num;\n            }\n            if (cnt >= (k + 2) / 2) {\n                mid2 = num;\n                break;\n            }\n        }\n\n        result[i - k] = ((double) mid1 + mid2) / 2;\n\n        if (i < n) {\n            window.put(nums[i], window.getOrDefault(nums[i], 0) + 1);\n            window.put(nums[i - k], window.get(nums[i - k]) - 1);\n            if (window.get(nums[i - k]) == 0) {\n                window.remove(nums[i - k]);\n            }\n        }\n    }\n\n    return result;\n}\n\n",
            "python": "from sortedcontainers import SortedList\n\ndef medianSlidingWindow(nums, k):\n    window = SortedList(nums[:k])\n    medians = []\n    \n    for i in range(k, len(nums) + 1):\n        medians.append((window[k // 2 - 1] + window[k // 2]) / 2 if k % 2 == 0 else float(window[k // 2]))\n        \n        if i < len(nums):\n            window.remove(nums[i - k])\n            window.add(nums[i])\n\n    return medians\n\n",
            "javascript": "function medianSlidingWindow(nums, k) {\n    const window = new SortedSet();\n    const medians = [];\n\n    for (let i = 0; i < k; i++) {\n        window.add(nums[i]);\n    }\n\n    for (let i = k; i <= nums.length; i++) {\n        const mid1 = window.at(Math.floor((k - 1) / 2));\n        const mid2 = window.at(Math.floor(k / 2));\n\n        medians.push((mid1 + mid2) / 2);\n\n        if (i < nums.length) {\n            window.delete(nums[i - k]);\n            window.add(nums[i]);\n        }\n    }\n\n    return medians;\n}\n\n",
            "explanation": "The algorithm initializes a sliding window of size `k`. The sliding window is used as a data structure that keeps track of the current `k` elements and maintains the ordering of the values, which can be a multiset or sorted list.\n\nLoop through the array from position `k` until the end. For each iteration, calculate the median of the current sliding window. If `k` is even, the median is the mean of the two middle values; if `k` is odd, the median is the middle value. Push the median value into a result array.\n\nRemove the leftmost element of the sliding window (the one that is out of the window now), and insert the next element in the array into the sliding window. Continue this process until the end of the array, and return the result array containing the median values. \n\nThis algorithm takes advantage of the ordered data structure to achieve an efficient median retrieval for each sliding window."
        },
        "structure": {
            "c++": "#include <vector>\n#include <set>\n\nstd::vector<double> medianSlidingWindow(std::vector<int>& nums, int k) \n    // Your code here\n}\n\n",
            "java": "import java.util.TreeMap;\n\npublic double[] medianSlidingWindow(int[] nums, int k) \n    // Your code here\n}\n\n",
            "python": "from sortedcontainers import SortedList\n    # Your code here\n\n",
            "javascript": "function medianSlidingWindow(nums, k) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <set>\n\nstd::vector<double> medianSlidingWindow(std::vector<int>& nums, int k) {\n    std::multiset<int> window(nums.begin(), nums.begin() + k);\n    auto mid = std::next(window.begin(), k / 2);\n    std::vector<double> medians;\n\n    for (int i = k;; i++) {\n        medians.push_back((double(*mid) + *std::prev(mid, 1 - k % 2)) / 2);\n        \n        if (i == nums.size()) {\n            return medians;\n        }\n        window.insert(nums[i]);\n        if (nums[i] < *mid) {\n            mid--;\n        }\n        if (nums[i - k] <= *mid) {\n            mid++;\n        }\n        window.erase(window.lower_bound(nums[i - k]));\n    }\n}\n\nint main() {\n    std::vector<int> nums = $args;\n    int k = 3;\n    std::vector<double> result = medianSlidingWindow(nums, k);\n    for (double num : result) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}",
            "java": "public double[] medianSlidingWindow(int[] nums, int k) {\n    TreeMap<Integer, Integer> window = new TreeMap<>();\n    int n = nums.length;\n    double[] result = new double[n - k + 1];\n\n    for (int i = 0; i < k; i++) {\n        window.put(nums[i], window.getOrDefault(nums[i], 0) + 1);\n    }\n\n    for (int i = k; i <= n; i++) {\n        int cnt = 0, mid1 = 0, mid2 = 0;\n        for (Integer num : window.keySet()) {\n            cnt += window.get(num);\n            if (cnt >= (k + 1) / 2 && mid1 == 0) {\n                mid1 = num;\n            }\n            if (cnt >= (k + 2) / 2) {\n                mid2 = num;\n                break;\n            }\n        }\n\n        result[i - k] = ((double) mid1 + mid2) / 2;\n\n        if (i < n) {\n            window.put(nums[i], window.getOrDefault(nums[i], 0) + 1);\n            window.put(nums[i - k], window.get(nums[i - k]) - 1);\n            if (window.get(nums[i - k]) == 0) {\n                window.remove(nums[i - k]);\n            }\n        }\n    }\n\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    k = $args[1]\n    result = medianSlidingWindow(nums, k)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args[0];\n    const k = $args[1];\n    const result = medianSlidingWindow(nums, k);\n    console.log(result);\n}"
        }
    },
    "481": {
        "title": "Count of 1's in Magical String",
        "description": "A magical string `s` consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n\nThe first few elements of s is s = \"1221121221221121122...... \". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ...... \" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ...... \". You can see that the occurrence sequence is s itself.\n\nGiven an integer n, return the number of 1's in the first n number in the magical string s.",
        "example": "Example:\n\nInput: n = 6\nOutput: 3\nExplanation: The first 6 elements of magical string s is \"122112\" and it contains three 1's, so return 3.",
        "level": "Easy",
        "tags": [
            "string",
            "counting"
        ],
        "test_cases": {
            "inputs": [
                6,
                1,
                10,
                15,
                20,
                25,
                30,
                50,
                100,
                1000,
                10000,
                50000,
                100000,
                105,
                500,
                10000,
                50000,
                100000,
                1000000,
                10000000
            ],
            "outputs": [
                3,
                1,
                4,
                7,
                9,
                12,
                15,
                26,
                53,
                504,
                5004,
                25004,
                50004,
                52,
                252,
                5004,
                25004,
                50004,
                500004,
                5000004
            ]
        },
        "sample_code": {
            "c++": "int magicalString(int n) {\n    if (n == 0) return 0;\n    if (n <= 3) return 1;\n    \n    vector<int> magic = {1, 2, 2};\n    int count_ones = 1;\n    int index = 2;\n    int value = 1;\n    \n    while (magic.size() < n) {\n        for (int i = 0; i < magic[index]; ++i) {\n            magic.push_back(value);\n            if (value == 1 && magic.size() <= n) count_ones++;\n        }\n        value = 3 - value;\n        index++;\n    }\n    \n    return count_ones;\n}\n\n",
            "java": "public int magicalString(int n) {\n    if (n == 0) return 0;\n    if (n <= 3) return 1;\n    \n    int[] magic = new int[n + 1];\n    magic[0] = 1;\n    magic[1] = 2;\n    magic[2] = 2;\n    int count_ones = 1;\n    int index = 2;\n    int value = 1;\n    \n    while (index < n) {\n        for (int i = 0; i < magic[index] && index < n; i++) {\n            magic[++index] = value;\n            if (value == 1) count_ones++;\n        }\n        value = 3 - value;\n    }\n    \n    return count_ones;\n}\n\n",
            "python": "def magical_string(n: int) -> int:\n    if n == 0:\n        return 0\n    if n <= 3:\n        return 1\n\n    magic = [1, 2, 2]\n    count_ones = 1\n    index = 2\n    value = 1\n\n    while len(magic) < n:\n        for _ in range(magic[index]):\n            magic.append(value)\n            if value == 1 and len(magic) <= n:\n                count_ones += 1\n        value = 3 - value\n        index += 1\n\n    return count_ones\n\n",
            "javascript": "function magicalString(n) {\n    if (n === 0) return 0;\n    if (n <= 3) return 1;\n\n    let magic = [1, 2, 2];\n    let countOnes = 1;\n    let index = 2;\n    let value = 1;\n\n    while (magic.length < n) {\n        for (let i = 0; i < magic[index]; i++) {\n            magic.push(value);\n            if (value === 1 && magic.length <= n) countOnes++;\n        }\n        value = 3 - value;\n        index++;\n    }\n\n    return countOnes;\n}\n\n",
            "explanation": "1. If n is 0, return 0. If n is 1, 2 or 3, return 1.\n2. Initialize the magic array with the first 3 elements: [1, 2, 2].\n3. Initialize count_ones to 1, index to 2, and value to 1.\n4. While the length of the magic array is less than n, loop through the following steps:\n   a. Loop from 0 to magic[index] (exclusive), pushing the current value to the magic array.\n   b. If the value is 1 and the length of the magic array is less than or equal to n, increment count_ones by 1.\n   c. Switch the value between 1 and 2 by setting value to 3 - value.\n   d. Increment the index by 1.\n5. Return the count_ones variable."
        },
        "structure": {
            "c++": "int magicalString(int n) \n    // Your code here\n}\n\n",
            "java": "public int magicalString(int n) \n    // Your code here\n}\n\n",
            "python": "def magical_string(n: int) -> int:\n    # Your code here\n\n",
            "javascript": "function magicalString(n) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = magicalString(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int magicalString(int n) {\n    if (n == 0) return 0;\n    if (n <= 3) return 1;\n    \n    int[] magic = new int[n + 1];\n    magic[0] = 1;\n    magic[1] = 2;\n    magic[2] = 2;\n    int count_ones = 1;\n    int index = 2;\n    int value = 1;\n    \n    while (index < n) {\n        for (int i = 0; i < magic[index] && index < n; i++) {\n            magic[++index] = value;\n            if (value == 1) count_ones++;\n        }\n        value = 3 - value;\n    }\n    \n    return count_ones;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    result = magical_string(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = magicalString(n);\n    console.log(result);\n}"
        }
    },
    "482": {
        "title": "Reformat License Key",
        "description": "You are given a license key represented as a string `s` that consists of only alphanumeric characters and dashes. The string is separated into `n + 1` groups by `n` dashes. You are also given an integer `k`. We want to reformat the string `s` such that each group contains exactly `k` characters, except for the first group, which could be shorter than `k` but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase. Return the reformatted license key.",
        "example": "Example:\n\nInput: s = \"5F3Z-2e-9-w\", k = 4\nOutput: \"5F3Z-2E9W\"\nExplanation: The string s has been split into two parts, each part has 4 characters. Note that the two extra dashes are not needed and can be removed.",
        "level": "Easy",
        "tags": [
            "string",
            "formatting"
        ],
        "test_cases": {
            "inputs": [
                "\"5F3Z-2e-9-w\"",
                "\"2-5g-3-J\"",
                "\"a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z\"",
                "\"1234567890\"",
                "\"A-B-C-D-E-F-G-H-I-J-K-L-M-N-O-P-Q-R-S-T-U-V-W-X-Y-Z\"",
                "\"1-2-3-4-5-6-7-8-9-0\"",
                "\"a1-b2-c3-d4-e5-f6-g7-h8-i9-j0\"",
                "\"A1-B2-C3-D4-E5-F6-G7-H8-I9-J0\"",
                "\"a1b2c3d4e5f6g7h8i9j0\"",
                "\"A1B2C3D4E5F6G7H8I9J0\"",
                "\"-a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z-\"",
                "\"-1-2-3-4-5-6-7-8-9-0-\"",
                "\"-a1-b2-c3-d4-e5-f6-g7-h8-i9-j0-\"",
                "\"-A1-B2-C3-D4-E5-F6-G7-H8-I9-J0-\"",
                "\"-a1b2c3d4e5f6g7h8i9j0-\"",
                "\"-A1B2C3D4E5F6G7H8I9J0-\"",
                "\"-a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z\"",
                "\"-1-2-3-4-5-6-7-8-9-0\"",
                "\"-a1-b2-c3-d4-e5-f6-g7-h8-i9-j0\"",
                "\"-A1-B2-C3-D4-E5-F6-G7-H8-I9-J0\"",
                "\"-a1b2c3d4e5f6g7h8i9j0\"",
                "\"-A1B2C3D4E5F6G7H8I9J0\""
            ],
            "outputs": [
                "\"5F3Z-2E9W\"",
                "\"2-5G-3J\"",
                "\"A-B-C-D-E-F-G-H-I-J-K-L-M-N-O-P-Q-R-S-T-U-V-W-X-Y-Z\"",
                "\"1234567890\"",
                "\"A-B-C-D-E-F-G-H-I-J-K-L-M-N-O-P-Q-R-S-T-U-V-W-X-Y-Z\"",
                "\"1-2-3-4-5-6-7-8-9-0\"",
                "\"A1-B2-C3-D4-E5-F6-G7-H8-I9-J0\"",
                "\"A1-B2-C3-D4-E5-F6-G7-H8-I9-J0\"",
                "\"A1B2C3D4E5F6G7H8I9J0\"",
                "\"A1B2C3D4E5F6G7H8I9J0\"",
                "\"A-B-C-D-E-F-G-H-I-J-K-L-M-N-O-P-Q-R-S-T-U-V-W-X-Y-Z\"",
                "\"1-2-3-4-5-6-7-8-9-0\"",
                "\"A1-B2-C3-D4-E5-F6-G7-H8-I9-J0\"",
                "\"A1-B2-C3-D4-E5-F6-G7-H8-I9-J0\"",
                "\"A1B2C3D4E5F6G7H8I9J0\"",
                "\"A1B2C3D4E5F6G7H8I9J0\"",
                "\"A-B-C-D-E-F-G-H-I-J-K-L-M-N-O-P-Q-R-S-T-U-V-W-X-Y-Z\"",
                "\"1-2-3-4-5-6-7-8-9-0\"",
                "\"A1-B2-C3-D4-E5-F6-G7-H8-I9-J0\"",
                "\"A1-B2-C3-D4-E5-F6-G7-H8-I9-J0\"",
                "\"A1B2C3D4E5F6G7H8I9J0\"",
                "\"A1B2C3D4E5F6G7H8I9J0\""
            ]
        },
        "sample_code": {
            "c++": "#include <cctype>\n#include <string>\nusing namespace std;\n\nstring licenseKeyFormatting(string s, int k) {\n    string result = \"\";\n    int count = 0;\n    for (int i = s.size() - 1; i >= 0; i--) {\n        if (s[i] != '-') {\n            if (count == k) {\n                result.push_back('-');\n                count = 0;\n            }\n            result.push_back(toupper(s[i]));\n            count++;\n        }\n    }\n    reverse(result.begin(), result.end());\n    return result;\n}\n",
            "java": "public String licenseKeyFormatting(String s, int k) {\n    StringBuilder result = new StringBuilder();\n    int count = 0;\n    for (int i = s.length() - 1; i >= 0; i--) {\n        if (s.charAt(i) != '-') {\n            if (count == k) {\n                result.append('-');\n                count = 0;\n            }\n            result.append(Character.toUpperCase(s.charAt(i)));\n            count++;\n        }\n    }\n    return result.reverse().toString();\n}\n",
            "python": "def license_key_formatting(s: str, k: int) -> str:\n    result = []\n    count = 0\n    for c in reversed(s):\n        if c != '-':\n            if count == k:\n                result.append('-')\n                count = 0\n            result.append(c.upper())\n            count += 1\n    return ''.join(reversed(result))\n",
            "javascript": "function licenseKeyFormatting(s, k) {\n    let result = '';\n    let count = 0;\n    for (let i = s.length - 1; i >= 0; i--) {\n        if (s[i] !== '-') {\n            if (count === k) {\n                result = '-' + result;\n                count = 0;\n            }\n            result = s[i].toUpperCase() + result;\n            count++;\n        }\n    }\n    return result;\n}\n",
            "explanation": "The algorithm starts by iterating the string s from the end to the beginning, skipping the dashes. During the iteration, we check whether the current group has reached k characters. If so, we append a dash to the result string. We then add the current character, converting it to uppercase, to the result string. After the iteration, we reverse the result string for C++, Java, and Python implementations (for JavaScript, we prepend characters so no need to reverse in the end). This is because we built the reformatted license key in reverse order. Finally, we return the result string."
        },
        "structure": {
            "c++": "#include <cctype>\n#include <string>\nusing namespace std;\n\nstring licenseKeyFormatting(string s, int k) \n    // Your code here\n}\n",
            "java": "public String licenseKeyFormatting(String s, int k) \n    // Your code here\n}\n",
            "python": "def license_key_formatting(s: str, k: int) -> str:\n    # Your code here\n\n",
            "javascript": "function licenseKeyFormatting(s, k) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <cctype>\n#include <string>\nusing namespace std;\n\nint main() {\n    string s = $args;\n    int k = $args;\n    string result = licenseKeyFormatting(s, k);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public String licenseKeyFormatting(String s, int k) {\n    StringBuilder result = new StringBuilder();\n    int count = 0;\n    for (int i = s.length() - 1; i >= 0; i--) {\n        if (s.charAt(i) != '-') {\n            if (count == k) {\n                result.append('-');\n                count = 0;\n            }\n            result.append(Character.toUpperCase(s.charAt(i)));\n            count++;\n        }\n    }\n    return result.reverse().toString();\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args[0]\n    k = $args[1]\n    result = license_key_formatting(s, k)\n    print(result)",
            "javascript": "function main() {\n    const s = $args[0];\n    const k = $args[1];\n    const result = licenseKeyFormatting(s, k);\n    console.log(result);\n}"
        }
    },
    "485": {
        "title": "Maximum Consecutive Ones",
        "description": "Given a binary array `nums`, find the maximum number of consecutive `1`'s in the array.",
        "example": "Example 1:\n\nInput: nums = [1,1,0,1,1,1]\nOutput: 3\nExplanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\n\nExample 2:\n\nInput: nums = [1,0,1,1,0,1]\nOutput: 2",
        "level": "Easy",
        "tags": [
            "array",
            "iteration"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    1,
                    0,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    0,
                    1,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    0,
                    0,
                    1,
                    1
                ],
                [
                    0,
                    1,
                    1,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    0,
                    1,
                    0,
                    1,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    0,
                    0,
                    0
                ],
                [
                    0,
                    0,
                    0,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    0,
                    1,
                    0,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    0,
                    1,
                    0,
                    1,
                    1,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    0,
                    1
                ],
                [
                    0,
                    1,
                    1,
                    0,
                    1,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    1,
                    0
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    0,
                    0,
                    1,
                    0
                ],
                [
                    0,
                    1,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    1,
                    1,
                    1,
                    0
                ]
            ],
            "outputs": [
                3,
                2,
                6,
                0,
                1,
                2,
                3,
                1,
                3,
                3,
                2,
                2,
                2,
                4,
                2,
                2,
                2,
                1,
                1,
                3
            ]
        },
        "sample_code": {
            "c++": "int findMaxConsecutiveOnes(vector<int>& nums) {\n    int max_consecutive = 0, current_consecutive = 0;\n    for (int num : nums) {\n        current_consecutive = (num == 1) ? current_consecutive + 1 : 0;\n        max_consecutive = max(max_consecutive, current_consecutive);\n    }\n    return max_consecutive;\n}\n",
            "java": "public int findMaxConsecutiveOnes(int[] nums) {\n    int maxConsecutive = 0, currentConsecutive = 0;\n    for (int num : nums) {\n        currentConsecutive = (num == 1) ? currentConsecutive + 1 : 0;\n        maxConsecutive = Math.max(maxConsecutive, currentConsecutive);\n    }\n    return maxConsecutive;\n}\n",
            "python": "def findMaxConsecutiveOnes(nums):\n    max_consecutive, current_consecutive = 0, 0\n    for num in nums:\n        current_consecutive = current_consecutive + 1 if num == 1 else 0\n        max_consecutive = max(max_consecutive, current_consecutive)\n    return max_consecutive\n",
            "javascript": "function findMaxConsecutiveOnes(nums) {\n    let maxConsecutive = 0, currentConsecutive = 0;\n    for (let num of nums) {\n        currentConsecutive = (num === 1) ? currentConsecutive + 1 : 0;\n        maxConsecutive = Math.max(maxConsecutive, currentConsecutive);\n    }\n    return maxConsecutive;\n}\n",
            "explanation": "The algorithm iterates through the given binary array `nums`. For each element, it checks if the current number is 1, then it increments the `current_consecutive` counter; otherwise, it resets the counter to 0. After updating the counter, it compares the current value of `current_consecutive` with the current maximum consecutive ones count (`max_consecutive`) and updates the maximum count if the current count is higher. After iterating through the entire array, the algorithm returns the maximum number of consecutive 1's found."
        },
        "structure": {
            "c++": "int findMaxConsecutiveOnes(vector<int>& nums) \n    // Your code here\n}\n",
            "java": "public int findMaxConsecutiveOnes(int[] nums) \n    // Your code here\n}\n",
            "python": "def findMaxConsecutiveOnes(nums):\n    # Your code here\n\n",
            "javascript": "function findMaxConsecutiveOnes(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int findMaxConsecutiveOnes(vector<int>& nums) {\n    int max_consecutive = 0, current_consecutive = 0;\n    for (int num : nums) {\n        current_consecutive = (num == 1) ? current_consecutive + 1 : 0;\n        max_consecutive = max(max_consecutive, current_consecutive);\n    }\n    return max_consecutive;\n}",
            "java": "public int findMaxConsecutiveOnes(int[] nums) {\n    int maxConsecutive = 0, currentConsecutive = 0;\n    for (int num : nums) {\n        currentConsecutive = (num == 1) ? currentConsecutive + 1 : 0;\n        maxConsecutive = Math.max(maxConsecutive, currentConsecutive);\n    }\n    return maxConsecutive;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = findMaxConsecutiveOnes(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = findMaxConsecutiveOnes(nums);\n    console.log(result);\n}"
        }
    },
    "486": {
        "title": "Player 1 Winning Game",
        "description": "You are given an integer array `nums`. Two players are playing a game with this array: player 1 and player 2.\n\nPlayer 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of `0`. At each turn, the player takes one of the numbers from either end of the array (i.e., `nums[0]` or `nums[nums.length - 1]`) which reduces the size of the array by `1`. The player adds the chosen number to their score. The game ends when there are no more elements in the array.\n\nReturn `true` if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return `true`. You may assume that both players are playing optimally.",
        "example": "Example:\n\nInput: nums = [1,5,2]\nOutput: false\nExplanation: Initially, player 1 can choose between 1 and 2. If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. Hence, player 1 will never be the winner and you need to return false.",
        "level": "Medium",
        "tags": [
            "array",
            "game"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    5,
                    2
                ],
                [
                    1,
                    5,
                    233,
                    7
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50
                ],
                [
                    5,
                    10,
                    15,
                    20,
                    25,
                    30,
                    35,
                    40,
                    45,
                    50
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10,
                    12,
                    14,
                    16,
                    18,
                    20,
                    22,
                    24,
                    26,
                    28,
                    30,
                    32,
                    34,
                    36,
                    38,
                    40
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9,
                    11,
                    13,
                    15,
                    17,
                    19,
                    21,
                    23,
                    25,
                    27,
                    29,
                    31,
                    33,
                    35,
                    37,
                    39
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    100
                ]
            ],
            "outputs": [
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nbool canWin(const std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<std::vector<int>> dp(n, std::vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = nums[i];\n    }\n    for (int len = 1; len < n; len++) {\n        for (int i = 0; i < n - len; i++) {\n            int j = i + len;\n            dp[i][j] = std::max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\n        }\n    }\n    return dp[0][n - 1] >= 0;\n}\n\n",
            "java": "public boolean canWin(int[] nums) {\n    int n = nums.length;\n    int[][] dp = new int[n][n];\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = nums[i];\n    }\n    for (int len = 1; len < n; len++) {\n        for (int i = 0; i < n - len; i++) {\n            int j = i + len;\n            dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\n        }\n    }\n    return dp[0][n - 1] >= 0;\n}\n\n",
            "python": "def can_win(nums):\n    n = len(nums)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = nums[i]\n    for len in range(1, n):\n        for i in range(n - len):\n            j = i + len\n            dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])\n    return dp[0][n - 1] >= 0\n\n",
            "javascript": "function canWin(nums) {\n    const n = nums.length;\n    const dp = Array.from({ length: n }, () => Array(n).fill(0));\n    for (let i = 0; i < n; i++) {\n        dp[i][i] = nums[i];\n    }\n    for (let len = 1; len < n; len++) {\n        for (let i = 0; i < n - len; i++) {\n            const j = i + len;\n            dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\n        }\n    }\n    return dp[0][n - 1] >= 0;\n}\n\n",
            "explanation": "We use dynamic programming to solve this problem. We create a 2D table `dp` of size `n x n` where `n` is the length of the input array `nums`. `dp[i][j]` represents the maximum score difference that player 1 can get when playing optimally on the subarray from index `i` to index `j`.\n\nWe initialize the diagonal elements of the table: `dp[i][i] = nums[i]`, since if there's only one element left in the game, the player will have to pick it up.\n\nWe iterate through the table by fixing the distance `len` between the start and end indices of the subarray. For each subarray `nums[i...j]` where `j = i + len`, player 1 has two choices: picking the first element of the subarray `nums[i]`, or picking the last element of the subarray `nums[j]`. Since both players play optimally, we consider the score difference after player 2 plays their turn. This can be found in the `dp` table from the following subproblems:\n\n1. If player 1 picks `nums[i]`, then the score difference after player 2's turn will be `nums[i] - dp[i + 1][j]`.\n2. If player 1 picks `nums[j]`, then the score difference after player 2's turn will be `nums[j] - dp[i][j - 1]`.\n\nWe choose the option which gives the maximum score difference for player 1: `dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])`.\n\nFinally, we return `true` if `dp[0][n - 1] >= 0`, which means that player 1 has a score greater than or equal to player 2 when playing optimally on the entire input array. Otherwise, we return `false`."
        },
        "structure": {
            "c++": "#include <vector>\n\nbool canWin(const std::vector<int>& nums) \n    // Your code here\n}\n\n",
            "java": "public boolean canWin(int[] nums) \n    // Your code here\n}\n\n",
            "python": "def can_win(nums):\n    # Your code here\n\n",
            "javascript": "function canWin(nums) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nbool canWin(const std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<std::vector<int>> dp(n, std::vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = nums[i];\n    }\n    for (int len = 1; len < n; len++) {\n        for (int i = 0; i < n - len; i++) {\n            int j = i + len;\n            dp[i][j] = std::max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\n        }\n    }\n    return dp[0][n - 1] >= 0;\n}\n\nint main() {\n    std::vector<int> nums = $args;\n    bool result = canWin(nums);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "java": "public boolean canWin(int[] nums) {\n    int n = nums.length;\n    int[][] dp = new int[n][n];\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = nums[i];\n    }\n    for (int len = 1; len < n; len++) {\n        for (int i = 0; i < n - len; i++) {\n            int j = i + len;\n            dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\n        }\n    }\n    return dp[0][n - 1] >= 0;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = can_win(nums)\n    print(result)",
            "javascript": "function canWin(nums) {\n    const n = nums.length;\n    const dp = Array.from({ length: n }, () => Array(n).fill(0));\n    for (let i = 0; i < n; i++) {\n        dp[i][i] = nums[i];\n    }\n    for (let len = 1; len < n; len++) {\n        for (let i = 0; i < n - len; i++) {\n            const j = i + len;\n            dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\n        }\n    }\n    return dp[0][n - 1] >= 0;\n}\n"
        }
    },
    "488": {
        "title": "Zuma Game",
        "description": "You are playing a variation of the game Zuma. In this variation, there is a single row of colored balls on a board, where each ball can be colored red \"R\", yellow \"Y\", blue \"B\", green \"G\", or white \"W\". Your goal is to clear all of the balls from the board. On each turn, you can pick any ball from your hand and insert it in between two balls in the row or on either end of the row. If there is a group of three or more consecutive balls of the same color, remove the group of balls from the board. If this removal causes more groups of three or more of the same color to form, then continue removing each group until there are none left. If there are no more balls on the board, then you win the game. Repeat this process until you either win or do not have any more balls in your hand. Given a string board representing the row of balls on the board, and a string hand representing the balls in your hand, return the minimum number of balls you have to insert to clear all the balls from the board. If you cannot clear all the balls from the board using the balls in your hand, return -1.",
        "example": "Example:\n\nInput: board = \"WRRBBW\", hand = \"RB\"\nOutput: -1\nExplanation: It is impossible to clear all the balls. The best you can do is:\n- Insert 'R' so the board becomes WRRRBBW. WRRRBBW -> WBBW.\n- Insert 'B' so the board becomes WBBBW. WBBBW -> WW.\nThere are still balls remaining on the board, and you are out of balls to insert.",
        "level": "Medium",
        "tags": [
            "string",
            "recursion",
            "backtracking"
        ],
        "test_cases": {
            "inputs": [
                [
                    "WRRBBW",
                    "RB"
                ],
                [
                    "WWRRBBWW",
                    "WRBRW"
                ],
                [
                    "G",
                    "GGGGG"
                ],
                [
                    "RRRR",
                    "RR"
                ],
                [
                    "RRRR",
                    "RRR"
                ],
                [
                    "RRRR",
                    "RRRR"
                ],
                [
                    "RRRR",
                    "RRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRRRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRRRRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRRRRRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRRRRRRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRRRRRRRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRRRRRRRRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRRRRRRRRRRRRR"
                ]
            ],
            "outputs": [
                -1,
                2,
                2,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nint find_min_step_helper(string& board, unordered_map<string, int>& memo, unordered_map<char, int>& hand) {\n    if (board.empty()) return 0;\n    if (memo.count(board)) return memo[board];\n\n    int result = INT_MAX;\n    for (int i = 0, j = 0; i < board.size(); i = j) {\n        while (j < board.size() and board[i] == board[j]) ++j;\n        char color = board[i];\n        int required = 3 - (j - i);\n        if (hand[color] >= required) {\n            hand[color] -= required;\n            string next_board = board.substr(0, i) + board.substr(j);\n            int tmp = find_min_step_helper(next_board, memo, hand);\n            if (tmp != -1) result = min(result, tmp + required);\n            hand[color] += required;\n        }\n    }\n\n    memo[board] = result == INT_MAX ? -1 : result;\n    return memo[board];\n}\n\nint find_min_step(string board, string hand) {\n    unordered_map<char, int> hand_map;\n    for (char c : hand) ++hand_map[c];\n    unordered_map<string, int> memo;\n    return find_min_step_helper(board, memo, hand_map);\n}\n\n",
            "java": "import java.util.*;\n\nclass Solution {\n    public int findMinStep(String board, String hand) {\n        HashMap<Character, Integer> handMap = new HashMap<>();\n        for (char c : hand.toCharArray()) handMap.put(c, handMap.getOrDefault(c, 0) + 1);\n\n        return findMinStepHelper(board, new HashMap<String, Integer>(), handMap);\n    }\n\n    private int findMinStepHelper(String board, HashMap<String, Integer> memo, HashMap<Character, Integer> hand) {\n        if (board.isEmpty()) return 0;\n        if (memo.containsKey(board)) return memo.get(board);\n\n        int result = Integer.MAX_VALUE;\n        for (int i = 0, j = 0; i < board.length(); i = j) {\n            while (j < board.length() && board.charAt(i) == board.charAt(j)) ++j;\n            char color = board.charAt(i);\n            int required = 3 - (j - i);\n            if (hand.getOrDefault(color, 0) >= required) {\n                hand.put(color, hand.get(color) - required);\n                String nextBoard = board.substring(0, i) + board.substring(j);\n                int tmp = findMinStepHelper(nextBoard, memo, hand);\n                if (tmp != -1) result = Math.min(result, tmp + required);\n                hand.put(color, hand.get(color) + required);\n            }\n        }\n\n        int res = (result == Integer.MAX_VALUE) ? -1 : result;\n        memo.put(board, res);\n        return res;\n    }\n}\n\n",
            "python": "from collections import Counter\n\ndef find_min_step(board: str, hand: str) -> int:\n    def find_min_step_helper(board, memo, hand):\n        if not board:\n            return 0\n        if board in memo:\n            return memo[board]\n\n        result = float('inf')\n        i = 0\n        while i < len(board):\n            j = i\n            while j < len(board) and board[i] == board[j]:\n                j += 1            \n\n            color = board[i]\n            required = 3 - (j - i)\n            if hand[color] >= required:\n                hand[color] -= required\n                next_board = board[:i] + board[j:]\n                tmp = find_min_step_helper(next_board, memo, hand)\n                if tmp != -1:\n                    result = min(result, tmp + required)\n                hand[color] += required\n            i = j\n\n        memo[board] = -1 if result == float('inf') else result\n        return memo[board]\n\n    hand_count = Counter(hand)\n    memo = {}\n    return find_min_step_helper(board, memo, hand_count)\n\n",
            "javascript": "function findMinStep(board, hand) {\n    function findMinStepHelper(board, memo, hand) {\n        if (board.length === 0) return 0;\n        if (memo.has(board)) return memo.get(board);\n\n        let result = Infinity;\n        let i = 0;\n        while (i < board.length) {\n            let j = i;\n            while (j < board.length && board[i] === board[j]) j++;\n\n            let color = board[i];\n            let required = 3 - (j - i);\n            if (hand[color] >= required) {\n                hand[color] -= required;\n                let nextBoard = board.slice(0, i) + board.slice(j);\n                let tmp = findMinStepHelper(nextBoard, memo, hand);\n                if (tmp !== -1) result = Math.min(result, tmp + required);\n                hand[color] += required;\n            }\n            i = j;\n        }\n\n        let res = (result === Infinity) ? -1 : result;\n        memo.set(board, res);\n        return res;\n    }\n\n    let handMap = {};\n    for (let c of hand) handMap[c] = (handMap[c] || 0) + 1;\n\n    return findMinStepHelper(board, new Map(), handMap);\n}\n\n",
            "explanation": "The algorithm uses a backtracking approach along with memoization. The base case for the recursion is when there is an empty board, in which case the minimum number of balls to clear the board is 0.\n\nThe function loops through the board to find sequences of the same color. For each sequence, it calculates the number of balls needed to reach at least 3 in a row. If the required number of balls are available in hand, it removes the required balls from hand and proceeds recursively with the rest of the board.\n\nAfter the recursive call, the removed balls are added back to the hand.\n\nThe memoization is used to store the results of subproblems based on the current state of the board.\n\nThe result is -1 if the balls in hand cannot clear the board, otherwise, the minimum number of balls required to clear the board is returned."
        },
        "structure": {
            "c++": "#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nint find_min_step_helper(string& board, unordered_map<string, int>& memo, unordered_map<char, int>& hand) \n    // Your code here\n}\n\n",
            "java": "import java.util.*;\n\nclass Solution \n    // Your code here\n}\n\n",
            "python": "from collections import Counter\n    # Your code here\n\n",
            "javascript": "function findMinStep(board, hand) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    string board = $args;\n    string hand = $args;\n    unordered_map<char, int> hand_map;\n    for (char c : hand) ++hand_map[c];\n    unordered_map<string, int> memo;\n    int result = find_min_step_helper(board, memo, hand_map);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n        int n = $args;\n        boolean result = isPowerOfFour(n);\n        System.out.println(result);\n    }\n",
            "python": "if __name__ == \"__main__\":\n    board = $args[0]\n    hand = $args[1]\n    result = find_min_step(board, hand)\n    print(result)",
            "javascript": "function findMinStep(board, hand) {\n    function findMinStepHelper(board, memo, hand) {\n        if (board.length === 0) return 0;\n        if (memo.has(board)) return memo.get(board);\n\n        let result = Infinity;\n        let i = 0;\n        while (i < board.length) {\n            let j = i;\n            while (j < board.length && board[i] === board[j]) j++;\n\n            let color = board[i];\n            let required = 3 - (j - i);\n            if (hand[color] >= required) {\n                hand[color] -= required;\n                let nextBoard = board.slice(0, i) + board.slice(j);\n                let tmp = findMinStepHelper(nextBoard, memo, hand);\n                if (tmp !== -1) result = Math.min(result, tmp + required);\n                hand[color] += required;\n            }\n            i = j;\n        }\n\n        let res = (result === Infinity) ? -1 : result;\n        memo.set(board, res);\n        return res;\n    }\n\n    let handMap = {};\n    for (let c of hand) handMap[c] = (handMap[c] || 0) + 1;\n\n    return findMinStepHelper(board, new Map(), handMap);\n}"
        }
    },
    "492": {
        "title": "Web Page Design",
        "description": "A web developer needs to know how to design a web page's size. Given a specific rectangular web page's area, your task is to design a rectangular web page with length L and width W that satisfy the following requirements:\n\n1. The area of the rectangular web page you design must be equal to the given target area.\n2. The width `W` should not be larger than the length `L`, which means `L >= W`.\n3. The difference between length `L` and width `W` should be as small as possible.\n\nReturn an array `[L, W]` where `L` and `W` are the length and width of the web page you designed in sequence.",
        "example": "Example:\n\nInput: area = 4\nOutput: [2,2]\nExplanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. But according to requirement 2, [1,4] is illegal; according to requirement 3, [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.",
        "level": "Easy",
        "tags": [
            "Math",
            "Geometry"
        ],
        "test_cases": {
            "inputs": [
                4,
                37,
                122122,
                1,
                100,
                999999,
                107,
                50,
                25,
                64,
                81,
                121,
                144,
                169,
                196,
                225,
                256,
                289,
                324,
                361
            ],
            "outputs": [
                [
                    2,
                    2
                ],
                [
                    37,
                    1
                ],
                [
                    427,
                    286
                ],
                [
                    1,
                    1
                ],
                [
                    10,
                    10
                ],
                [
                    999,
                    999
                ],
                [
                    107,
                    1
                ],
                [
                    10,
                    5
                ],
                [
                    5,
                    5
                ],
                [
                    8,
                    8
                ],
                [
                    9,
                    9
                ],
                [
                    11,
                    11
                ],
                [
                    12,
                    12
                ],
                [
                    13,
                    13
                ],
                [
                    14,
                    14
                ],
                [
                    15,
                    15
                ],
                [
                    16,
                    16
                ],
                [
                    17,
                    17
                ],
                [
                    18,
                    18
                ],
                [
                    19,
                    19
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <cmath>\n\nstd::vector<int> constructRectangle(int area) {\n    int width = std::sqrt(area);\n    while(area % width != 0) {\n        width -= 1;\n    }\n    int length = area / width;\n    return {length, width};\n}\n",
            "java": "public int[] constructRectangle(int area) {\n    int width = (int)Math.sqrt(area);\n    while(area % width != 0) {\n        width--;\n    }\n    int length = area / width;\n    return new int[]{length, width};\n}\n",
            "python": "def constructRectangle(area: int) -> List[int]:\n    width = int(area**0.5)\n    while area % width != 0:\n        width -= 1\n    length = area // width\n    return [length, width]\n",
            "javascript": "function constructRectangle(area) {\n    let width = Math.floor(Math.sqrt(area));\n    while(area % width !== 0) {\n        width--;\n    }\n    let length = area / width;\n    return [length, width];\n}\n",
            "explanation": "The algorithm starts by calculating the square root of the given area, using the sqrt function in each language. Since web pages with more rectangular shapes are preferred, we start the width from `sqrt(area)` and work our way down.\n\nWe initialize the variable width with the integer value of the square root of the area: `width = sqrt(area)`. This initialization ensures that our width and length will be as close as possible to each other.\n\nWe then use a while loop to check if the current width divides the area evenly (`area % width != 0`). If it doesn't, we decrement the width by one and repeat the loop until we find a width that divides the area evenly.\n\nFinally, we calculate the length by dividing the area with the width: `length = area / width`. We return the length and width as an array in the required sequence: `[length, width]`."
        },
        "structure": {
            "c++": "#include <vector>\n#include <cmath>\n\nstd::vector<int> constructRectangle(int area) \n    // Your code here\n}\n",
            "java": "public int[] constructRectangle(int area) \n    // Your code here\n}\n",
            "python": "def constructRectangle(area: int) -> List[int]:\n    # Your code here\n\n",
            "javascript": "function constructRectangle(area) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <cmath>\n#include <iostream>\n\nint main() {\n    int area = $args;\n    std::vector<int> result = constructRectangle(area);\n    std::cout << result[0] << \" \" << result[1] << std::endl;\n    return 0;\n}",
            "java": "public int[] constructRectangle(int area) {\n    int width = (int)Math.sqrt(area);\n    while(area % width != 0) {\n        width--;\n    }\n    int length = area / width;\n    return new int[]{length, width};\n}",
            "python": "if __name__ == \"__main__\":\n    area = $args[0]\n    result = constructRectangle(area)\n    print(result)",
            "javascript": "function main() {\n    const area = $args;\n    const result = constructRectangle(area);\n    console.log(result);\n}"
        }
    },
    "493": {
        "title": "Reverse Pairs in Array",
        "description": "Given an integer array `nums`, return the number of reverse pairs in the array. A reverse pair is a pair `(i, j)` where `0 <= i < j < nums.length` and `nums[i] > 2 * nums[j]`.",
        "example": "Example 1:\n\nInput: nums = [1,3,2,3,1]\nOutput: 2\nExplanation: The reverse pairs are:\n(1, 4) --> nums[1] = 3, nums[4] = 1, 3 > 2 * 1\n(3, 4) --> nums[3] = 3, nums[4] = 1, 3 > 2 * 1\n\nExample 2:\n\nInput: nums = [2,4,3,5,1]\nOutput: 3\nExplanation: The reverse pairs are:\n(1, 4) --> nums[1] = 4, nums[4] = 1, 4 > 2 * 1\n(2, 4) --> nums[2] = 3, nums[4] = 1, 3 > 2 * 1\n(3, 4) --> nums[3] = 5, nums[4] = 1, 5 > 2 * 1",
        "level": "Medium",
        "tags": [
            "Array",
            "Sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    3,
                    2,
                    3,
                    1
                ],
                [
                    2,
                    4,
                    3,
                    5,
                    1
                ],
                [
                    5,
                    10,
                    15,
                    20,
                    25
                ],
                [
                    3,
                    6,
                    9,
                    12,
                    15
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50
                ],
                [
                    50,
                    40,
                    30,
                    20,
                    10
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10
                ],
                [
                    10,
                    8,
                    6,
                    4,
                    2
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    3,
                    3,
                    3,
                    3,
                    3
                ],
                [
                    4,
                    4,
                    4,
                    4,
                    4
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    2,
                    2,
                    2,
                    3,
                    3,
                    3
                ],
                [
                    3,
                    3,
                    3,
                    2,
                    2,
                    2,
                    1,
                    1,
                    1
                ],
                [
                    5,
                    5,
                    5,
                    4,
                    4,
                    4,
                    3,
                    3,
                    3
                ]
            ],
            "outputs": [
                2,
                3,
                0,
                0,
                0,
                10,
                0,
                10,
                0,
                10,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                6,
                6,
                9
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nint merge(std::vector<int>& nums, std::vector<int>& temp, int left, int mid, int right) {\n    int count = 0;\n    int j = mid;\n    for (int i = left; i < mid; i++) {\n        while (j <= right && (long long)nums[i] > 2LL * nums[j]) {\n            j++;\n        }\n        count += j - mid;\n    }\n    std::merge(nums.begin() + left, nums.begin() + mid, nums.begin() + mid, nums.begin() + right + 1, temp.begin() + left);\n    \n    return count;\n}\n\nint countReversePairs(std::vector<int>& nums, std::vector<int>& temp, int left, int right) {\n    if (left >= right) {\n        return 0;\n    }\n    int mid = left + (right - left) / 2;\n    int count = countReversePairs(nums, temp, left, mid) + countReversePairs(nums, temp, mid + 1, right);\n    count += merge(nums, temp, left, mid + 1, right);\n    std::copy(temp.begin() + left, temp.begin() + right + 1, nums.begin() + left);\n    \n    return count;\n}\n\nint reversePairs(std::vector<int>& nums) {\n    std::vector<int> temp(nums.size());\n    return countReversePairs(nums, temp, 0, nums.size() - 1);\n}\n",
            "java": "public int reversePairs(int[] nums) {\n    return mergeSort(nums, 0, nums.length - 1, new int[nums.length]);\n}\n\nprivate int mergeSort(int[] nums, int left, int right, int[] temp) {\n    if (left >= right) {\n        return 0;\n    }\n    int mid = left + (right - left) / 2;\n    int count = mergeSort(nums, left, mid, temp) + mergeSort(nums, mid + 1, right, temp);\n    count += merge(nums, left, mid, right, temp);\n    \n    return count;\n}\n\nprivate int merge(int[] nums, int left, int mid, int right, int[] temp) {\n    int count = 0;\n    System.arraycopy(nums, left, temp, left, right - left + 1);\n    int j = mid + 1;\n    for (int i = left; i <= mid; i++) {\n        while (j <= right && (long) nums[i] > 2L * nums[j]) {\n            j++;\n        }\n        count += j - (mid + 1);\n    }\n    int i = left;\n    j = mid + 1;\n    int k = left;\n    while (i <= mid && j <= right) {\n        if (temp[i] <= temp[j]) {\n            nums[k++] = temp[i++];\n        } else {\n            nums[k++] = temp[j++];\n        }\n    }\n    while (i <= mid) {\n        nums[k++] = temp[i++];\n    }\n    while (j <= right) {\n        nums[k++] = temp[j++];\n    }\n    \n    return count;\n}\n",
            "python": "def reversePairs(nums):\n    def mergeSort(l, r):\n        if l >= r:\n            return 0\n        \n        mid = (l + r) // 2\n        count = mergeSort(l, mid) + mergeSort(mid + 1, r)\n        j = mid + 1\n        for i in range(l, mid + 1):\n            while j <= r and nums[i] > 2 * nums[j]:\n                j += 1\n            count += j - (mid + 1)\n        \n        nums[l:r + 1] = sorted(nums[l:r + 1])\n        \n        return count\n    \n    return mergeSort(0, len(nums) - 1)\n\n",
            "javascript": "function reversePairs(nums) {\n    function mergeSort(l, r) {\n        if (l >= r) {\n            return 0;\n        }\n\n        const mid = Math.floor((l + r) / 2);\n        let count = mergeSort(l, mid) + mergeSort(mid + 1, r);\n        let j = mid + 1;\n        for (let i = l; i <= mid; i++) {\n            while (j <= r && nums[i] > 2 * nums[j]) {\n                j++;\n            }\n            count += j - (mid + 1);\n        }\n\n        const merged = nums.slice(l, r + 1).sort((a, b) => a - b);\n        nums.splice(l, merged.length, ...merged);\n\n        return count;\n    }\n\n    return mergeSort(0, nums.length - 1);\n}\n\n\n",
            "explanation": "The algorithm uses a modified merge sort to solve the problem efficiently. It counts the number of reverse pairs during the merge process, compares the elements in the left subarray with those in the right subarray, and increments the count based on the condition `nums[i] > 2 * nums[j]`. The merge sort divides the array into smaller subarrays, which are recursively sorted and merged.\n\nFor each subarray, we use two pointers `i` and `j` to find out the number of reverse pairs that satisfy the condition `nums[i] > 2 * nums[j]`. When iterating through the left subarray with `i`, we move `j` from the right subarray until we find the first index that doesn't satisfy the condition or we reach the end of the right subarray. The difference between the current position of `j` and the starting position is the count of valid reverse pairs. To get the overall count, we sum up the count value from both the left and right subarrays and also add the count found during merging the subarrays.\n\nFinally, we merge the sorted subarrays using built-in sort functions. The process is similar in all four languages: C++ uses `std::merge` and `std::copy`, Java uses `System.arraycopy`, Python uses list slicing with `sorted()`, and JavaScript uses `Array.prototype.sort()` and `Array.prototype.splice()`.\n\nThe time complexity of the algorithm is O(n log n), as it takes advantage of the merge sort structure."
        },
        "structure": {
            "c++": "#include <vector>\n\nint merge(std::vector<int>& nums, std::vector<int>& temp, int left, int mid, int right) \n    // Your code here\n}\n",
            "java": "public int reversePairs(int[] nums) \n    // Your code here\n}\n",
            "python": "def reversePairs(nums):\n    # Your code here\n\n",
            "javascript": "function reversePairs(nums) \n    // Your code here\n}\n\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nint merge(std::vector<int>& nums, std::vector<int>& temp, int left, int mid, int right) {\n    int count = 0;\n    int j = mid;\n    for (int i = left; i < mid; i++) {\n        while (j <= right && (long long)nums[i] > 2LL * nums[j]) {\n            j++;\n        }\n        count += j - mid;\n    }\n    std::merge(nums.begin() + left, nums.begin() + mid, nums.begin() + mid, nums.begin() + right + 1, temp.begin() + left);\n    \n    return count;\n}\n\nint countReversePairs(std::vector<int>& nums, std::vector<int>& temp, int left, int right) {\n    if (left >= right) {\n        return 0;\n    }\n    int mid = left + (right - left) / 2;\n    int count = countReversePairs(nums, temp, left, mid) + countReversePairs(nums, temp, mid + 1, right);\n    count += merge(nums, temp, left, mid + 1, right);\n    std::copy(temp.begin() + left, temp.begin() + right + 1, nums.begin() + left);\n    \n    return count;\n}\n\nint reversePairs(std::vector<int>& nums) {\n    std::vector<int> temp(nums.size());\n    return countReversePairs(nums, temp, 0, nums.size() - 1);\n}\n\nint main() {\n    std::vector<int> nums = $args;\n    int result = reversePairs(nums);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int reversePairs(int[] nums) {\n    return mergeSort(nums, 0, nums.length - 1, new int[nums.length]);\n}\n\nprivate int mergeSort(int[] nums, int left, int right, int[] temp) {\n    if (left >= right) {\n        return 0;\n    }\n    int mid = left + (right - left) / 2;\n    int count = mergeSort(nums, left, mid, temp) + mergeSort(nums, mid + 1, right, temp);\n    count += merge(nums, left, mid, right, temp);\n    \n    return count;\n}\n\nprivate int merge(int[] nums, int left, int mid, int right, int[] temp) {\n    int count = 0;\n    System.arraycopy(nums, left, temp, left, right - left + 1);\n    int j = mid + 1;\n    for (int i = left; i <= mid; i++) {\n        while (j <= right && (long) nums[i] > 2L * nums[j]) {\n            j++;\n        }\n        count += j - (mid + 1);\n    }\n    int i = left;\n    j = mid + 1;\n    int k = left;\n    while (i <= mid && j <= right) {\n        if (temp[i] <= temp[j]) {\n            nums[k++] = temp[i++];\n        } else {\n            nums[k++] = temp[j++];\n        }\n    }\n    while (i <= mid) {\n        nums[k++] = temp[i++];\n    }\n    while (j <= right) {\n        nums[k++] = temp[j++];\n    }\n    \n    return count;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = reversePairs(nums)\n    print(result)",
            "javascript": "function reversePairs(nums) {\n    function mergeSort(l, r) {\n        if (l >= r) {\n            return 0;\n        }\n\n        const mid = Math.floor((l + r) / 2);\n        let count = mergeSort(l, mid) + mergeSort(mid + 1, r);\n        let j = mid + 1;\n        for (let i = l; i <= mid; i++) {\n            while (j <= r && nums[i] > 2 * nums[j]) {\n                j++;\n            }\n            count += j - (mid + 1);\n        }\n\n        const merged = nums.slice(l, r + 1).sort((a, b) => a - b);\n        nums.splice(l, merged.length, ...merged);\n\n        return count;\n    }\n\n    return mergeSort(0, nums.length - 1);\n}"
        }
    },
    "494": {
        "title": "Expression Builder",
        "description": "You are given an integer array `nums` and an integer `target`. You want to build an **expression** out of nums by adding one of the symbols `'+'` and `'-'` before each integer in nums and then concatenate them to build the expression. Return the number of different **expressions** that you can build, which evaluates to `target`.",
        "example": "Example:\n\nInput: nums = [1,1,1,1,1], target = 3\nOutput: 5\nExplanation: There are 5 ways to assign symbols to make the sum of nums be target 3.\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    3
                ],
                [
                    [
                        1
                    ],
                    1
                ],
                [
                    [
                        2,
                        3,
                        4,
                        5
                    ],
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    0
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    15
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    -5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    100
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    -100
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    2
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    4
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    6
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    7
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    8
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    9
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    11
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    12
                ]
            ],
            "outputs": [
                5,
                1,
                2,
                0,
                2,
                2,
                0,
                0,
                1,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nint findTargetSumWays(std::vector<int>& nums, int target) {\n    int sum = 0;\n    for (int num : nums) sum += num;\n    if (sum < target || (sum + target) % 2 != 0) return 0;\n    int target_sum = (sum + target) / 2;\n    std::vector<int> dp(target_sum + 1, 0);\n    dp[0] = 1;\n    for (int num : nums) {\n        for (int j = target_sum; j >= num; j--) {\n            dp[j] += dp[j - num];\n        }\n    }\n    return dp[target_sum];\n}\n\n",
            "java": "public int findTargetSumWays(int[] nums, int target) {\n    int sum = 0;\n    for (int num : nums) sum += num;\n    if (sum < target || (sum + target) % 2 != 0) return 0;\n    int target_sum = (sum + target) / 2;\n    int[] dp = new int[target_sum + 1];\n    dp[0] = 1;\n    for (int num : nums) {\n        for (int j = target_sum; j >= num; j--) {\n            dp[j] += dp[j - num];\n        }\n    }\n    return dp[target_sum];\n}\n\n",
            "python": "def findTargetSumWays(nums, target):\n    total_sum = sum(nums)\n    if total_sum < target or (total_sum + target) % 2 != 0:\n        return 0\n    target_sum = (total_sum + target) // 2\n    dp = [0] * (target_sum + 1)\n    dp[0] = 1\n    for num in nums:\n        for j in range(target_sum, num - 1, -1):\n            dp[j] += dp[j - num]\n    return dp[target_sum]\n\n",
            "javascript": "function findTargetSumWays(nums, target) {\n    let sum = nums.reduce((a, b) => a + b);\n    if (sum < target || (sum + target) % 2 !== 0) return 0;\n    let target_sum = (sum + target) >> 1;\n    let dp = new Array(target_sum + 1).fill(0);\n    dp[0] = 1;\n    for (const num of nums) {\n        for (let j = target_sum; j >= num; j--) {\n            dp[j] += dp[j - num];\n        }\n    }\n    return dp[target_sum];\n}\n\n",
            "explanation": "The problem can be reduced to a subset sum problem by doing some simple math. First, calculate the sum of all numbers in the array. If the sum of integers is less than the target value or the total sum with target value is odd, there are no possible combinations.\n\nThe required subset sum is (sum + target) / 2. We will use dynamic programming to count the number of subsets with the target sum. Initialize a DP array of size `target_sum + 1` and set the first value to 1 because the empty subset adds up to 0.\n\nIterate through the given numbers and for each number, update the values in DP array by enumerating the subsets with the i-th number included as follows:\n\n1. If the current number is less than or equal to the target_sum, calculate the new value of the current subset by adding the value at a position shifted by the current number.\n\n2. Store the new value and the current number in the DP array.\n\nReturn the greater number of different target-sum expressions saved in the DP array."
        },
        "structure": {
            "c++": "#include <vector>\n\nint findTargetSumWays(std::vector<int>& nums, int target) \n    // Your code here\n}\n\n",
            "java": "public int findTargetSumWays(int[] nums, int target) \n    // Your code here\n}\n\n",
            "python": "def findTargetSumWays(nums, target):\n    # Your code here\n\n",
            "javascript": "function findTargetSumWays(nums, target) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nint findTargetSumWays(std::vector<int>& nums, int target);\n\nint main() {\n    std::vector<int> nums = $args;\n    int target = $args;\n    int result = findTargetSumWays(nums, target);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public int findTargetSumWays(int[] nums, int target) {\n    int sum = 0;\n    for (int num : nums) sum += num;\n    if (sum < target || (sum + target) % 2 != 0) return 0;\n    int target_sum = (sum + target) / 2;\n    int[] dp = new int[target_sum + 1];\n    dp[0] = 1;\n    for (int num : nums) {\n        for (int j = target_sum; j >= num; j--) {\n            dp[j] += dp[j - num];\n        }\n    }\n    return dp[target_sum];\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    target = $args[1]\n    result = findTargetSumWays(nums, target)\n    print(result)",
            "javascript": "function findTargetSumWays(nums, target) {\n    let sum = nums.reduce((a, b) => a + b);\n    if (sum < target || (sum + target) % 2 !== 0) return 0;\n    let target_sum = (sum + target) >> 1;\n    let dp = new Array(target_sum + 1).fill(0);\n    dp[0] = 1;\n    for (const num of nums) {\n        for (let j = target_sum; j >= num; j--) {\n            dp[j] += dp[j - num];\n        }\n    }\n    return dp[target_sum];\n}"
        }
    },
    "495": {
        "title": "Teemo's Poison Attacks",
        "description": "Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for exactly `duration` seconds. More formally, an attack at second `t` will mean Ashe is poisoned during the **inclusive** time interval `[t, t + duration - 1]`. If Teemo attacks again **before** the poison effect ends, the timer for it is **reset**, and the poison effect will end `duration` seconds after the new attack.\n\nYou are given a **non-decreasing** integer array `timeSeries`, where `timeSeries[i]` denotes that Teemo attacks Ashe at second `timeSeries[i]`, and an integer `duration`.\n\nReturn the **total** number of seconds that Ashe is poisoned.",
        "example": "Example:\n\nInput: timeSeries = [1,4], duration = 2\nOutput: 4\nExplanation: Teemo's attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5.\nAshe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total.",
        "level": "Easy",
        "tags": [
            "array",
            "simulation"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    4
                ],
                [
                    1,
                    2
                ],
                [
                    2,
                    3,
                    4,
                    5,
                    6
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9,
                    11,
                    13,
                    15,
                    17,
                    19
                ],
                [
                    1,
                    1,
                    2,
                    2,
                    3,
                    3,
                    4,
                    4,
                    5,
                    5
                ],
                [
                    1,
                    2,
                    2,
                    3,
                    3,
                    3,
                    4,
                    4,
                    4,
                    4
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    60
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99,
                    100
                ]
            ],
            "outputs": [
                "4",
                "3",
                "10",
                "5",
                "20",
                "20",
                "10",
                "10",
                "20",
                "30",
                "40",
                "50",
                "60",
                "100"
            ]
        },
        "sample_code": {
            "c++": "int findPoisonedDuration(vector<int>& timeSeries, int duration) {\n    if (timeSeries.empty()) return 0;\n    int total = 0;\n    for (int i = 1; i < timeSeries.size(); ++i) {\n        total += min(timeSeries[i] - timeSeries[i - 1], duration);\n    }\n    return total + duration;\n}\n",
            "java": "public int findPoisonedDuration(int[] timeSeries, int duration) {\n    if (timeSeries.length == 0) return 0;\n    int total = 0;\n    for (int i = 1; i < timeSeries.length; ++i) {\n        total += Math.min(timeSeries[i] - timeSeries[i - 1], duration);\n    }\n    return total + duration;\n}\n",
            "python": "def find_poisoned_duration(time_series, duration):\n    if not time_series:\n        return 0\n    total = 0\n    for i in range(1, len(time_series)):\n        total += min(time_series[i] - time_series[i - 1], duration)\n    return total + duration\n",
            "javascript": "function findPoisonedDuration(timeSeries, duration) {\n    if (timeSeries.length === 0) return 0;\n    let total = 0;\n    for (let i = 1; i < timeSeries.length; ++i) {\n        total += Math.min(timeSeries[i] - timeSeries[i - 1], duration);\n    }\n    return total + duration;\n}\n",
            "explanation": "Iterate through the `timeSeries` array and for each element, calculate the difference between the current element and the previous element. If the difference is less than `duration`, add that difference to the total time poisoned; otherwise, add the `duration` to the total time poisoned. In the end, add one more `duration` to the total to account for the last attack.\n\nBy doing this, we ensure that we only count the poisoned time without overlapping, since consecutive poisoned times will add up to the original duration."
        },
        "structure": {
            "c++": "int findPoisonedDuration(vector<int>& timeSeries, int duration) \n    // Your code here\n}\n",
            "java": "public int findPoisonedDuration(int[] timeSeries, int duration) \n    // Your code here\n}\n",
            "python": "def find_poisoned_duration(time_series, duration):\n    # Your code here\n\n",
            "javascript": "function findPoisonedDuration(timeSeries, duration) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int findPoisonedDuration(vector<int>& timeSeries, int duration) {\n    if (timeSeries.empty()) return 0;\n    int total = 0;\n    for (int i = 1; i < timeSeries.size(); ++i) {\n        total += min(timeSeries[i] - timeSeries[i - 1], duration);\n    }\n    return total + duration;\n}",
            "java": "public int findPoisonedDuration(int[] timeSeries, int duration) {\n    if (timeSeries.length == 0) return 0;\n    int total = 0;\n    for (int i = 1; i < timeSeries.length; ++i) {\n        total += Math.min(timeSeries[i] - timeSeries[i - 1], duration);\n    }\n    return total + duration;\n}",
            "python": "if __name__ == \"__main__\":\n    time_series = $args[0]\n    duration = $args[1]\n    result = find_poisoned_duration(time_series, duration)\n    print(result)",
            "javascript": "function main() {\n    const timeSeries = $args[0];\n    const duration = $args[1];\n    const result = findPoisonedDuration(timeSeries, duration);\n    console.log(result);\n}"
        }
    },
    "496": {
        "title": "Next Greater Element",
        "description": "Given two distinct 0-indexed integer arrays `nums1` and `nums2`, where `nums1` is a subset of `nums2`, find the next greater element for each value of `nums1` in `nums2`. The next greater element of some element `x` in an array is the first greater element that is to the right of `x` in the same array. If there is no next greater element, the answer is -1.",
        "example": "Example 1:\n\nInput: nums1 = [4,1,2], nums2 = [1,3,4,2]\nOutput: [-1,3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n\nExample 2:\n\nInput: nums1 = [2,4], nums2 = [1,2,3,4]\nOutput: [3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1.",
        "level": "Medium",
        "tags": [
            "array",
            "stack"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        [
                            4,
                            1,
                            2
                        ],
                        [
                            1,
                            3,
                            4,
                            2
                        ]
                    ]
                ],
                [
                    [
                        [
                            2,
                            4
                        ],
                        [
                            1,
                            2,
                            3,
                            4
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            3,
                            5,
                            7
                        ],
                        [
                            2,
                            4,
                            6,
                            8
                        ]
                    ]
                ],
                [
                    [
                        [
                            9,
                            8,
                            7,
                            6
                        ],
                        [
                            1,
                            2,
                            3,
                            4
                        ]
                    ]
                ],
                [
                    [
                        [
                            5,
                            10,
                            15
                        ],
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4
                        ],
                        [
                            4,
                            3,
                            2,
                            1
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4
                        ],
                        [
                            5,
                            6,
                            7,
                            8
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4
                        ],
                        [
                            1,
                            2,
                            3,
                            4
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4
                        ],
                        [
                            4,
                            3,
                            2,
                            1
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4
                        ],
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4
                        ],
                        [
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            15,
                            14,
                            13,
                            12,
                            11,
                            10,
                            9,
                            8,
                            7,
                            6,
                            5,
                            4,
                            3,
                            2,
                            1
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            5,
                            10,
                            15,
                            20,
                            25,
                            30,
                            35,
                            40,
                            45,
                            50,
                            55,
                            60,
                            65,
                            70,
                            75
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            15,
                            14,
                            13,
                            12,
                            11,
                            10,
                            9,
                            8,
                            7,
                            6,
                            5,
                            4,
                            3,
                            2,
                            1,
                            16,
                            17,
                            18,
                            19,
                            20
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            15,
                            14,
                            13,
                            12,
                            11,
                            10,
                            9,
                            8,
                            7,
                            6,
                            5,
                            4,
                            3,
                            2,
                            1,
                            20,
                            19,
                            18,
                            17,
                            16
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            15,
                            14,
                            13,
                            12,
                            11,
                            10,
                            9,
                            8,
                            7,
                            6,
                            5,
                            4,
                            3,
                            2,
                            1,
                            20,
                            19,
                            18,
                            17,
                            16,
                            21,
                            22,
                            23,
                            24,
                            25
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            15,
                            14,
                            13,
                            12,
                            11,
                            10,
                            9,
                            8,
                            7,
                            6,
                            5,
                            4,
                            3,
                            2,
                            1,
                            25,
                            24,
                            23,
                            22,
                            21,
                            20,
                            19,
                            18,
                            17,
                            16
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            15,
                            14,
                            13,
                            12,
                            11,
                            10,
                            9,
                            8,
                            7,
                            6,
                            5,
                            4,
                            3,
                            2,
                            1,
                            25,
                            24,
                            23,
                            22,
                            21,
                            20,
                            19,
                            18,
                            17,
                            16,
                            26,
                            27,
                            28,
                            29,
                            30
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            15,
                            14,
                            13,
                            12,
                            11,
                            10,
                            9,
                            8,
                            7,
                            6,
                            5,
                            4,
                            3,
                            2,
                            1,
                            30,
                            29,
                            28,
                            27,
                            26,
                            25,
                            24,
                            23,
                            22,
                            21,
                            20,
                            19,
                            18,
                            17,
                            16
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            15,
                            14,
                            13,
                            12,
                            11,
                            10,
                            9,
                            8,
                            7,
                            6,
                            5,
                            4,
                            3,
                            2,
                            1,
                            30,
                            29,
                            28,
                            27,
                            26,
                            25,
                            24,
                            23,
                            22,
                            21,
                            20,
                            19,
                            18,
                            17,
                            16,
                            31,
                            32,
                            33,
                            34,
                            35
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            15,
                            14,
                            13,
                            12,
                            11,
                            10,
                            9,
                            8,
                            7,
                            6,
                            5,
                            4,
                            3,
                            2,
                            1,
                            35,
                            34,
                            33,
                            32,
                            31,
                            30,
                            29,
                            28,
                            27,
                            26,
                            25,
                            24,
                            23,
                            22,
                            21,
                            20,
                            19,
                            18,
                            17,
                            16
                        ]
                    ]
                ]
            ],
            "outputs": [
                "[-1,3,-1]",
                "[3,-1]",
                "[3,6,8,-1]",
                "[-1,-1,-1,-1]",
                "[10,15,-1]",
                "[-1,-1,-1,-1]",
                "[-1,-1,-1,-1]",
                "[2,3,4,-1]",
                "[-1,-1,-1,-1]",
                "[6,7,8,9,10,11,12,13,14,-1,-1,-1,-1,-1,-1]",
                "[6,7,8,9,10,11,12,13,14,-1,-1,-1,-1,-1,-1]",
                "[15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]",
                "[15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]",
                "[20,25,30,35,40,45,50,55,60,65,70,75,-1,-1,-1]",
                "[20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]",
                "[20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]",
                "[25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]",
                "[25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]",
                "[30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]",
                "[30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]",
                "[35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]",
                "[35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <stack>\n#include <unordered_map>\n\nstd::vector<int> nextGreaterElement(std::vector<int>& nums1, std::vector<int>& nums2) {\n    std::unordered_map<int, int> nextGreater;\n    std::stack<int> stk;\n\n    for (int num : nums2) {\n        while (!stk.empty() && stk.top() < num) {\n            nextGreater[stk.top()] = num;\n            stk.pop();\n        }\n        stk.push(num);\n    }\n\n    std::vector<int> result(nums1.size());\n    for (size_t i = 0; i < nums1.size(); ++i) {\n        result[i] = nextGreater.count(nums1[i]) ? nextGreater[nums1[i]] : -1;\n    }\n\n    return result;\n}\n",
            "java": "import java.util.HashMap;\nimport java.util.Stack;\n\npublic int[] nextGreaterElement(int[] nums1, int[] nums2) {\n    HashMap<Integer, Integer> nextGreater = new HashMap<>();\n    Stack<Integer> stack = new Stack<>();\n\n    for (int num : nums2) {\n        while (!stack.isEmpty() && stack.peek() < num) {\n            nextGreater.put(stack.pop(), num);\n        }\n        stack.push(num);\n    }\n\n    int[] result = new int[nums1.length];\n    for (int i = 0; i < nums1.length; i++) {\n        result[i] = nextGreater.getOrDefault(nums1[i], -1);\n    }\n\n    return result;\n}\n",
            "python": "def next_greater_element(nums1, nums2):\n    next_greater = {}\n    stack = []\n\n    for num in nums2:\n        while stack and stack[-1] < num:\n            next_greater[stack.pop()] = num\n        stack.append(num)\n\n    return [next_greater.get(n, -1) for n in nums1]\n",
            "javascript": "function nextGreaterElement(nums1, nums2) {\n    const nextGreater = new Map();\n    const stack = [];\n\n    nums2.forEach(num => {\n        while (stack.length && stack[stack.length - 1] < num) {\n            nextGreater.set(stack.pop(), num);\n        }\n        stack.push(num);\n    });\n\n    return nums1.map(n => nextGreater.get(n) || -1);\n}\n",
            "explanation": "The algorithm uses a stack, following these steps:\n1. Initialize an empty stack.\n2. Iterate through nums2 elements:\n   a. While the stack is not empty and the top of the stack is less than the current nums2 element, add the next greater element of the top of the stack as the current nums2 element and pop it.\n   b. Push the current nums2 element into the stack.\n3. For every element in nums1, get the next greater element found in step 2 or -1 if no such element was found.\n4. Return the result array.\n\nThe key point is using the stack to keep track of the previous elements that still need to find their next greater element while iterating nums2 in a single pass. This ensures that the algorithm runs in linear O(n) time complexity."
        },
        "structure": {
            "c++": "#include <vector>\n#include <stack>\n#include <unordered_map>\n\nstd::vector<int> nextGreaterElement(std::vector<int>& nums1, std::vector<int>& nums2) \n    // Your code here\n}\n",
            "java": "import java.util.HashMap;\nimport java.util.Stack;\n\npublic int[] nextGreaterElement(int[] nums1, int[] nums2) \n    // Your code here\n}\n",
            "python": "def next_greater_element(nums1, nums2):\n    # Your code here\n\n",
            "javascript": "function nextGreaterElement(nums1, nums2) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <stack>\n#include <unordered_map>\n\nstd::vector<int> nextGreaterElement(std::vector<int>& nums1, std::vector<int>& nums2) {\n    std::unordered_map<int, int> nextGreater;\n    std::stack<int> stk;\n\n    for (int num : nums2) {\n        while (!stk.empty() && stk.top() < num) {\n            nextGreater[stk.top()] = num;\n            stk.pop();\n        }\n        stk.push(num);\n    }\n\n    std::vector<int> result(nums1.size());\n    for (size_t i = 0; i < nums1.size(); ++i) {\n        result[i] = nextGreater.count(nums1[i]) ? nextGreater[nums1[i]] : -1;\n    }\n\n    return result;\n}",
            "java": "public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n    HashMap<Integer, Integer> nextGreater = new HashMap<>();\n    Stack<Integer> stack = new Stack<>();\n\n    for (int num : nums2) {\n        while (!stack.isEmpty() && stack.peek() < num) {\n            nextGreater.put(stack.pop(), num);\n        }\n        stack.push(num);\n    }\n\n    int[] result = new int[nums1.length];\n    for (int i = 0; i < nums1.length; i++) {\n        result[i] = nextGreater.getOrDefault(nums1[i], -1);\n    }\n\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    nums1 = $args[0]\n    nums2 = $args[1]\n    result = next_greater_element(nums1, nums2)\n    print(result)",
            "javascript": "function main() {\n    const nums1 = $args[0];\n    const nums2 = $args[1];\n    const nextGreater = new Map();\n    const stack = [];\n\n    nums2.forEach(num => {\n        while (stack.length && stack[stack.length - 1] < num) {\n            nextGreater.set(stack.pop(), num);\n        }\n        stack.push(num);\n    });\n\n    const result = nums1.map(n => nextGreater.get(n) || -1);\n    console.log(result);\n}"
        }
    },
    "497": {
        "title": "Random Point in Non-Overlapping Rectangles",
        "description": "You are given an array of non-overlapping axis-aligned rectangles `rects` where `rects[i] = [ai, bi, xi, yi]` indicates that `(ai, bi)` is the bottom-left corner point of the `ith` rectangle and `(xi, yi)` is the top-right corner point of the `ith` rectangle. Design an algorithm to pick a random integer point inside the space covered by one of the given rectangles. A point on the perimeter of a rectangle is included in the space covered by the rectangle.\n\nAny integer point inside the space covered by one of the given rectangles should be equally likely to be returned.\n\n**Note** that an integer point is a point that has integer coordinates.\n\nImplement the `Solution` class:\n\n*   `Solution(int[][] rects)` Initializes the object with the given rectangles `rects`.\n*   `int[] pick()` Returns a random integer point `[u, v]` inside the space covered by one of the given rectangles.",
        "example": "Example:\n\nInput:\nSolution solution = new Solution([[1, 1, 3, 3], [4, 4, 6, 6]]);\nsolution.pick(); // return [2, 2]\nsolution.pick(); // return [5, 5]\nsolution.pick(); // return [4, 4]\n\nExplanation:\n\nThe given rectangles are [[1, 1, 3, 3], [4, 4, 6, 6]].\n\nFor the first pick(), the random point [2, 2] is inside the rectangle [1, 1, 3, 3].\n\nFor the second pick(), the random point [5, 5] is inside the rectangle [4, 4, 6, 6].\n\nFor the third pick(), the random point [4, 4] is on the perimeter of the rectangle [4, 4, 6, 6].",
        "level": "Medium",
        "tags": [
            "Array",
            "Math",
            "Random"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        1,
                        3,
                        3
                    ],
                    [
                        4,
                        4,
                        6,
                        6
                    ]
                ],
                [
                    [
                        0,
                        0,
                        1,
                        1
                    ],
                    [
                        2,
                        2,
                        3,
                        3
                    ],
                    [
                        4,
                        4,
                        5,
                        5
                    ]
                ],
                [
                    [
                        -10,
                        -10,
                        10,
                        10
                    ]
                ],
                [
                    [
                        -100,
                        -100,
                        100,
                        100
                    ],
                    [
                        200,
                        200,
                        300,
                        300
                    ],
                    [
                        400,
                        400,
                        500,
                        500
                    ],
                    [
                        600,
                        600,
                        700,
                        700
                    ]
                ],
                [
                    [
                        1,
                        1,
                        2,
                        2
                    ],
                    [
                        3,
                        3,
                        4,
                        4
                    ],
                    [
                        5,
                        5,
                        6,
                        6
                    ],
                    [
                        7,
                        7,
                        8,
                        8
                    ],
                    [
                        9,
                        9,
                        10,
                        10
                    ],
                    [
                        11,
                        11,
                        12,
                        12
                    ],
                    [
                        13,
                        13,
                        14,
                        14
                    ],
                    [
                        15,
                        15,
                        16,
                        16
                    ],
                    [
                        17,
                        17,
                        18,
                        18
                    ],
                    [
                        19,
                        19,
                        20,
                        20
                    ],
                    [
                        21,
                        21,
                        22,
                        22
                    ],
                    [
                        23,
                        23,
                        24,
                        24
                    ],
                    [
                        25,
                        25,
                        26,
                        26
                    ],
                    [
                        27,
                        27,
                        28,
                        28
                    ],
                    [
                        29,
                        29,
                        30,
                        30
                    ],
                    [
                        31,
                        31,
                        32,
                        32
                    ],
                    [
                        33,
                        33,
                        34,
                        34
                    ],
                    [
                        35,
                        35,
                        36,
                        36
                    ],
                    [
                        37,
                        37,
                        38,
                        38
                    ],
                    [
                        39,
                        39,
                        40,
                        40
                    ]
                ]
            ],
            "outputs": [
                "[2, 2]",
                "[0, 0]",
                "[-5, -5]",
                "[250, 250]",
                "[19, 19]"
            ]
        },
        "sample_code": {
            "c++": "#include <random>\n#include <vector>\n\nclass Solution {\n    std::vector<std::vector<int>> rects;\n    std::vector<int> areas;\n    int total_area;\n\npublic:\n    Solution(std::vector<std::vector<int>>& rects) :\n        rects(rects), \n        areas(rects.size()), \n        total_area(0) {\n        for (int i = 0; i < rects.size(); ++i) {\n            int area = (rects[i][2] - rects[i][0] + 1) * (rects[i][3] - rects[i][1] + 1);\n            areas[i] = area;\n            total_area += area;\n        }\n    }\n\n    std::vector<int> pick() {\n        std::default_random_engine generator;\n        std::uniform_int_distribution<int> distribution(0, total_area - 1);\n        int rnd = distribution(generator);\n        \n        int idx = 0;\n        while (rnd >= areas[idx]) {\n            rnd -= areas[idx];\n            idx++;\n        }\n\n        std::uniform_int_distribution<int> x_distribution(rects[idx][0], rects[idx][2]);\n        std::uniform_int_distribution<int> y_distribution(rects[idx][1], rects[idx][3]);\n        \n        return {\n            x_distribution(generator),\n            y_distribution(generator)\n        };\n    }\n};\n\n",
            "java": "import java.util.Random;\nimport java.util.List;\n\nclass Solution {\n    int[][] rects;\n    int[] areas;\n    int totalArea;\n    Random random;\n\n    public Solution(int[][] rects) {\n        this.rects = rects;\n        this.areas = new int[rects.length];\n        this.totalArea = 0;\n        this.random = new Random();\n\n        for (int i = 0; i < rects.length; i++) {\n            int area = (rects[i][2] - rects[i][0] + 1) * (rects[i][3] - rects[i][1] + 1);\n            areas[i] = area;\n            totalArea += area;\n        }\n    }\n\n    public int[] pick() {\n        int rnd = random.nextInt(totalArea);\n\n        int idx = 0;\n        while (rnd >= areas[idx]) {\n            rnd -= areas[idx];\n            idx++;\n        }\n\n        int x = rects[idx][0] + random.nextInt(rects[idx][2] - rects[idx][0] + 1);\n        int y = rects[idx][1] + random.nextInt(rects[idx][3] - rects[idx][1] + 1);\n        \n        return new int[] {x, y};\n    }\n}\n\n",
            "python": "import random\nfrom typing import List\n\nclass Solution:\n    def __init__(self, rects: List[List[int]]):\n        self.rects = rects\n        self.areas = [0] * len(rects)\n        self.total_area = 0\n\n        for i, rect in enumerate(rects):\n            area = (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1)\n            self.areas[i] = area\n            self.total_area += area\n\n    def pick(self) -> List[int]:\n        rnd = random.randint(0, self.total_area - 1)\n        idx = 0\n        while rnd >= self.areas[idx]:\n            rnd -= self.areas[idx]\n            idx += 1\n\n        x = random.randint(self.rects[idx][0], self.rects[idx][2])\n        y = random.randint(self.rects[idx][1], self.rects[idx][3])\n        \n        return [x, y]\n\n",
            "javascript": "class Solution {\n    constructor(rects) {\n        this.rects = rects;\n        this.areas = new Array(rects.length);\n        this.totalArea = 0;\n\n        for (let i = 0; i < rects.length; i++) {\n            const area = (rects[i][2] - rects[i][0] + 1) * (rects[i][3] - rects[i][1] + 1);\n            this.areas[i] = area;\n            this.totalArea += area;\n        }\n    }\n\n    pick() {\n        let rnd = Math.floor(Math.random() * this.totalArea);\n        let idx = 0;\n\n        while (rnd >= this.areas[idx]) {\n            rnd -= this.areas[idx];\n            idx++;\n        }\n\n        const x = this.rects[idx][0] + Math.floor(Math.random() * (this.rects[idx][2] - this.rects[idx][0] + 1));\n        const y = this.rects[idx][1] + Math.floor(Math.random() * (this.rects[idx][3] - this.rects[idx][1] + 1));\n\n        return [x, y];\n    }\n}\n\n",
            "explanation": "The algorithm consists of initializing a `Solution` object by storing the `rects` and calculating the area of each rectangle. The `areas` are stored, and the `total_area` is calculated by summing up all the rectangle areas.\n\nWhen the `pick()` function is called, a random value, `rnd`, is generated within the range `[0, total_area-1]`. The index `idx` of the rectangle containing the point is found, adding the areas until `rnd` reaches a value less than the area of the rectangle with index `idx` (that means the rectangle at idx is the one we need). \n\nNext, two random integer coordinates, `x` and `y`, are generated within the range of the selected rectangle, and the point `[x, y]` is returned.\n\nThis ensures that each integer point inside the space covered by one of the given rectangles will be equally likely to be returned."
        },
        "structure": {
            "c++": "#include <random>\n#include <vector>\n\nclass Solution \n    // Your code here\n};\n\n",
            "java": "import java.util.Random;\nimport java.util.List;\n\nclass Solution \n    // Your code here\n}\n\n",
            "python": "import random\n    # Your code here\n\n",
            "javascript": "class Solution \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "std::vector<std::vector<int>> rects = $args;\nSolution obj(rects);\nstd::vector<int> result = obj.pick();\nfor (int i = 0; i < result.size(); ++i) {\n    std::cout << result[i] << \" \";\n}\nstd::cout << std::endl;",
            "java": "public int[] pick() {\n        int rnd = random.nextInt(totalArea);\n\n        int idx = 0;\n        while (rnd >= areas[idx]) {\n            rnd -= areas[idx];\n            idx++;\n        }\n\n        int x = rects[idx][0] + random.nextInt(rects[idx][2] - rects[idx][0] + 1);\n        int y = rects[idx][1] + random.nextInt(rects[idx][3] - rects[idx][1] + 1);\n        \n        return new int[] {x, y};\n    }",
            "python": "if __name__ == \"__main__\":\n    rects = $args[0]\n    obj = Solution(rects)\n    result = obj.pick()\n    print(result)",
            "javascript": "function pick() {\n    const result = Solution.pick();\n    console.log(result);\n}"
        }
    },
    "498": {
        "title": "Diagonal Order",
        "description": "Given an `m x n` matrix `mat`, return an array of all the elements of the array in a diagonal order.",
        "example": "Example 1:\n\nInput: mat = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,4,7,5,3,6,8,9]\n\nExample 2:\n\nInput: mat = [[1,2],[3,4]]\nOutput: [1,2,3,4]",
        "level": "Easy",
        "tags": [
            "array",
            "matrix"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9
                    ],
                    [
                        10,
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16
                    ],
                    [
                        17,
                        18,
                        19,
                        20
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16
                    ],
                    [
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16
                    ],
                    [
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24
                    ],
                    [
                        25,
                        26,
                        27,
                        28
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        10,
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16
                    ],
                    [
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24
                    ],
                    [
                        25,
                        26,
                        27,
                        28
                    ],
                    [
                        29,
                        30,
                        31,
                        32
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16
                    ],
                    [
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24
                    ],
                    [
                        25,
                        26,
                        27,
                        28
                    ],
                    [
                        29,
                        30,
                        31,
                        32
                    ],
                    [
                        33,
                        34,
                        35,
                        36
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20,
                        21,
                        22
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16
                    ],
                    [
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24
                    ],
                    [
                        25,
                        26,
                        27,
                        28
                    ],
                    [
                        29,
                        30,
                        31,
                        32
                    ],
                    [
                        33,
                        34,
                        35,
                        36
                    ],
                    [
                        37,
                        38,
                        39,
                        40
                    ]
                ]
            ],
            "outputs": [
                "[1,2,4,7,5,3,6,8,9]",
                "[1,2,3,4]",
                "[1,2,5,9,6,3,4,7,10,11,8,12]",
                "[1,2,4,5,3,6]",
                "[1,2,6,11,7,3,4,8,12,13,9,5,10,14,15]",
                "[1,2,3,4,5,6,7,8]",
                "[1,2,7,12,8,3,4,9,13,14,10,5,6,11,15]",
                "[1,2,4,7,5,3,8,11,9,6,10,12]",
                "[1,2,4,7,5,3,8,12,9,6,10,13,16,11,14,15]",
                "[1,2,4,7,5,3,8,12,9,6,10,13,17,14,11,15,18,19,16,20]",
                "[1,2,3,4,5,6,7,8,9,10,11,12]",
                "[1,2,4,7,5,3,8,12,9,6,10,13,17,14,11,15,18,21,19,16,20,22,23]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14]",
                "[1,2,4,7,5,3,8,12,9,6,10,13,17,14,11,15,18,21,19,16,20,22,25,23,26,27]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]",
                "[1,2,4,7,5,3,8,12,9,6,10,13,17,14,11,15,18,21,19,16,20,22,25,23,26,27,29,30,28,31,32]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]",
                "[1,2,4,7,5,3,8,12,9,6,10,13,17,14,11,15,18,21,19,16,20,22,25,23,26,27,29,30,28,31,32,33,34,35,36]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]",
                "[1,2,4,7,5,3,8,12,9,6,10,13,17,14,11,15,18,21,19,16,20,22,25,23,26,27,29,30,28,31,32,33,34,35,36,37,38,39,40]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> findDiagonalOrder(vector<vector<int>>& mat) {\n    int m = mat.size();\n    int n = mat[0].size();\n    vector<int> result(m * n);\n    int row = 0, col = 0;\n    for (int i = 0; i < m * n; i++) {\n        result[i] = mat[row][col];\n        if ((row + col) % 2 == 0) {\n            if (col == n - 1) {\n                row++;\n            } else if (row == 0) {\n                col++;\n            } else {\n                row--;\n                col++;\n            }\n        } else {\n            if (row == m - 1) {\n                col++;\n            } else if (col == 0) {\n                row++;\n            } else {\n                row++;\n                col--;\n            }\n        }\n    }\n    return result;\n}\n",
            "java": "import java.util.Arrays;\n\npublic int[] findDiagonalOrder(int[][] mat) {\n    int m = mat.length;\n    int n = mat[0].length;\n    int[] result = new int[m * n];\n    int row = 0, col = 0;\n    for (int i = 0; i < m * n; i++) {\n        result[i] = mat[row][col];\n        if ((row + col) % 2 == 0) {\n            if (col == n - 1) {\n                row++;\n            } else if (row == 0) {\n                col++;\n            } else {\n                row--;\n                col++;\n            }\n        } else {\n            if (row == m - 1) {\n                col++;\n            } else if (col == 0) {\n                row++;\n            } else {\n                row++;\n                col--;\n            }\n        }\n    }\n    return result;\n}\n",
            "python": "from typing import List\n\ndef findDiagonalOrder(mat: List[List[int]]) -> List[int]:\n    m, n = len(mat), len(mat[0])\n    result = [0] * (m * n)\n    row, col = 0, 0\n    for i in range(m * n):\n        result[i] = mat[row][col]\n        if (row + col) % 2 == 0:\n            if col == n - 1:\n                row += 1\n            elif row == 0:\n                col += 1\n            else:\n                row -= 1\n                col += 1\n        else:\n            if row == m - 1:\n                col += 1\n            elif col == 0:\n                row += 1\n            else:\n                row += 1\n                col -= 1\n    return result\n",
            "javascript": "function findDiagonalOrder(mat) {\n    const m = mat.length;\n    const n = mat[0].length;\n    const result = new Array(m * n);\n    let row = 0, col = 0;\n    for (let i = 0; i < m * n; i++) {\n        result[i] = mat[row][col];\n        if ((row + col) % 2 === 0) {\n            if (col === n - 1) {\n                row++;\n            } else if (row === 0) {\n                col++;\n            } else {\n                row--;\n                col++;\n            }\n        } else {\n            if (row === m - 1) {\n                col++;\n            } else if (col === 0) {\n                row++;\n            } else {\n                row++;\n                col--;\n            }\n        }\n    }\n    return result;\n}\n",
            "explanation": "The algorithm iterates through each element of the matrix in a diagonal order. We set up a double loop that runs through the total number of elements in the matrix (m * n). We keep track of the current row and column while iterating. \n\nWe use a conditional statement to check if the sum of the current row and column is even, which means we need to move up diagonally to the right. If we are at the right edge, we move down one row. If we are at the top edge, we move right one column. Otherwise, we move up diagonally (row - 1, col + 1).\n\nIf the sum of the current row and column is odd, it means we need to move down diagonally to the left. If we are at the bottom edge, we move right one column. If we are at the left edge, we move down one row. Otherwise, we move down diagonally (row + 1, col - 1)."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> findDiagonalOrder(vector<vector<int>>& mat) \n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\n\npublic int[] findDiagonalOrder(int[][] mat) \n    // Your code here\n}\n",
            "python": "from typing import List\n    # Your code here\n\n",
            "javascript": "function findDiagonalOrder(mat) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> findDiagonalOrder(vector<vector<int>>& mat) {\n    int m = mat.size();\n    int n = mat[0].size();\n    vector<int> result(m * n);\n    int row = 0, col = 0;\n    for (int i = 0; i < m * n; i++) {\n        result[i] = mat[row][col];\n        if ((row + col) % 2 == 0) {\n            if (col == n - 1) {\n                row++;\n            } else if (row == 0) {\n                col++;\n            } else {\n                row--;\n                col++;\n            }\n        } else {\n            if (row == m - 1) {\n                col++;\n            } else if (col == 0) {\n                row++;\n            } else {\n                row++;\n                col--;\n            }\n        }\n    }\n    return result;\n}\n\nint main() {\n    vector<vector<int>> mat = $args;\n    vector<int> result = findDiagonalOrder(mat);\n    for (int i = 0; i < result.size(); i++) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "java": "public int[] findDiagonalOrder(int[][] mat) {\n    int m = mat.length;\n    int n = mat[0].length;\n    int[] result = new int[m * n];\n    int row = 0, col = 0;\n    for (int i = 0; i < m * n; i++) {\n        result[i] = mat[row][col];\n        if ((row + col) % 2 == 0) {\n            if (col == n - 1) {\n                row++;\n            } else if (row == 0) {\n                col++;\n            } else {\n                row--;\n                col++;\n            }\n        } else {\n            if (row == m - 1) {\n                col++;\n            } else if (col == 0) {\n                row++;\n            } else {\n                row++;\n                col--;\n            }\n        }\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    mat = $args[0]\n    result = findDiagonalOrder(mat)\n    print(result)",
            "javascript": "function findDiagonalOrder(mat) {\n    const m = mat.length;\n    const n = mat[0].length;\n    const result = new Array(m * n);\n    let row = 0, col = 0;\n    for (let i = 0; i < m * n; i++) {\n        result[i] = mat[row][col];\n        if ((row + col) % 2 === 0) {\n            if (col === n - 1) {\n                row++;\n            } else if (row === 0) {\n                col++;\n            } else {\n                row--;\n                col++;\n            }\n        } else {\n            if (row === m - 1) {\n                col++;\n            } else if (col === 0) {\n                row++;\n            } else {\n                row++;\n                col--;\n            }\n        }\n    }\n    return result;\n}"
        }
    },
    "499": {
        "title": "Ball Maze Instructions",
        "description": "You are given a maze represented as a 2D array, where 0 represents an empty space and 1 represents a wall. There is a ball in the maze that can roll in four directions: up, down, left, and right. The ball will continue rolling in a given direction until it hits a wall. The maze also contains a hole, and the ball will drop into the hole if it rolls onto it. Given the maze, the ball's starting position, and the hole's position, your task is to return a string of instructions that the ball should follow to reach the hole with the shortest distance possible. If there are multiple valid instructions, return the lexicographically smallest one. If the ball cannot reach the hole, return 'impossible'.",
        "example": "Example:\n\nInput:\nmaze = [[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]], ball = [4,3], hole = [0,1]\nOutput: 'lul'\nExplanation: The ball can reach the hole by moving left, up, and then left again. The total distance traveled is 6, and 'lul' is the lexicographically smallest instruction sequence.",
        "level": "Medium",
        "tags": [
            "maze",
            "graph",
            "shortest path"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        [
                            0,
                            0,
                            0,
                            0,
                            0
                        ],
                        [
                            1,
                            1,
                            0,
                            0,
                            1
                        ],
                        [
                            0,
                            0,
                            0,
                            0,
                            0
                        ],
                        [
                            0,
                            1,
                            0,
                            0,
                            1
                        ],
                        [
                            0,
                            1,
                            0,
                            0,
                            0
                        ]
                    ],
                    [
                        4,
                        3
                    ],
                    [
                        0,
                        1
                    ]
                ],
                [
                    [
                        [
                            0,
                            0,
                            0,
                            0,
                            0
                        ],
                        [
                            1,
                            1,
                            0,
                            0,
                            1
                        ],
                        [
                            0,
                            0,
                            0,
                            0,
                            0
                        ],
                        [
                            0,
                            1,
                            0,
                            0,
                            1
                        ],
                        [
                            0,
                            1,
                            0,
                            0,
                            0
                        ]
                    ],
                    [
                        4,
                        3
                    ],
                    [
                        3,
                        0
                    ]
                ],
                [
                    [
                        [
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ],
                        [
                            0,
                            0,
                            1,
                            0,
                            0,
                            1,
                            0
                        ],
                        [
                            0,
                            0,
                            0,
                            0,
                            1,
                            0,
                            0
                        ],
                        [
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            1
                        ]
                    ],
                    [
                        0,
                        4
                    ],
                    [
                        3,
                        5
                    ]
                ]
            ],
            "outputs": [
                "lul",
                "impossible",
                "dldr"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string findShortestWay(vector<vector<int>>& maze, vector<int>& ball, vector<int>& hole) {\n        int m = maze.size(), n = maze[0].size();\n        vector<vector<int>> dist(m, vector<int>(n, INT_MAX)); \n        vector<string> dirs = {\"d\", \"l\", \"r\", \"u\"};\n        vector<vector<int>> dirs_vector = {{1, 0}, {0, -1}, {0, 1}, {-1, 0}};\n        string res = \"\";\n        dist[ball[0]][ball[1]] = 0;\n        auto cmp = [&](const auto& p1, const auto& p2){\n            return p1.first > p2.first || (p1.first == p2.first && p1.second > p2.second);\n        };\n        priority_queue<pair<int, string>, vector<pair<int, string>>, decltype(cmp)> pq(cmp);\n        pq.push({0, \"\"});\n        \n        while (!pq.empty()) {\n            int cur_dist = pq.top().first;\n            string cur_path = pq.top().second;\n            int x = ball[0], y = ball[1];\n            for (char c : cur_path) {\n                if (c == 'd') x += dirs_vector[0][0]; \n                if (c == 'l') y += dirs_vector[1][1];\n                if (c == 'r') y += dirs_vector[2][1];\n                if (c == 'u') x += dirs_vector[3][0];\n            }\n            pq.pop();\n            if (x == hole[0] && y == hole[1]) return cur_path;\n\n            for (int k = 0; k < 4; ++k) {\n                int dist_move = 0, r = x, c = y;\n                while (r >= 0 && r < m && c >= 0 && c < n && maze[r][c] == 0 && (r != hole[0] || c != hole[1])) {\n                    r += dirs_vector[k][0];\n                    c += dirs_vector[k][1];\n                    ++dist_move;\n                }\n                r -= dirs_vector[k][0];\n                c -= dirs_vector[k][1];\n                --dist_move;\n                \n                if (dist[x][y] + dist_move < dist[r][c]) {\n                    dist[r][c] = dist[x][y] + dist_move;\n                    pq.push({cur_dist + dist_move, cur_path + dirs[k]});\n                }\n            }\n        }\n        \n        return \"impossible\";\n    }\n};\n",
            "java": "import java.util.*;\n\nclass Solution {\n    public String findShortestWay(int[][] maze, int[] ball, int[] hole) {\n        int m = maze.length, n = maze[0].length;\n        int[][] dist = new int[m][n];\n        for (int i = 0; i < m; ++i) Arrays.fill(dist[i], Integer.MAX_VALUE);\n        String[] dirs = {\"d\", \"l\", \"r\", \"u\"};\n        int[][] dirs_vector = {{1, 0}, {0, -1}, {0, 1}, {-1, 0}};\n        dist[ball[0]][ball[1]] = 0;\n        PriorityQueue<int[]> pq = new PriorityQueue<>((p1, p2) -> p1[0] != p2[0] ? p1[0] - p2[0] : p1[1] - p2[1]);\n        pq.offer(new int[]{0, 0});\n        \n        while (!pq.isEmpty()) {\n            int cur_dist = pq.peek()[0], cur_d = pq.peek()[1];\n            String cur_path = pq.poll()[2];\n            int x = ball[0], y = ball[1];\n            for (char c : cur_path.toCharArray()) {\n                if (c == 'd') x += dirs_vector[0][0];\n                if (c == 'l') y += dirs_vector[1][1];\n                if (c == 'r') y += dirs_vector[2][1];\n                if (c == 'u') x += dirs_vector[3][0];\n            }\n            if (x == hole[0] && y == hole[1]) return cur_path;\n\n            for (int k = 0; k < 4; ++k) {\n                int dist_move = 0, r = x, c = y;\n                while (r >= 0 && r < m && c >= 0 && c < n && maze[r][c] == 0 && (r != hole[0] || c != hole[1])) {\n                    r += dirs_vector[k][0];\n                    c += dirs_vector[k][1];\n                    ++dist_move;\n                }\n                r -= dirs_vector[k][0];\n                c -= dirs_vector[k][1];\n                --dist_move;\n                \n                if (dist[x][y] + dist_move < dist[r][c]) {\n                    dist[r][c] = dist[x][y] + dist_move;\n                    pq.offer(new int[]{cur_dist + dist_move, cur_d * 4 + k, cur_path + dirs[k]});\n                }\n            }\n        }\n        \n        return \"impossible\";\n    }\n}\n",
            "python": "from heapq import heappush, heappop\n\nclass Solution:\n    def findShortestWay(self, maze: List[List[int]], ball: List[int], hole: List[int]) -> str:\n        m, n = len(maze), len(maze[0])\n        dist = [[float(\"inf\")] * n for _ in range(m)]\n        dirs = [\"d\", \"l\", \"r\", \"u\"]\n        dirs_vector = [[1, 0], [0, -1], [0, 1], [-1, 0]]\n        dist[ball[0]][ball[1]] = 0\n        pq = [(0, \"\", ball[0], ball[1])]\n        \n        while pq:\n            cur_dist, cur_path, x, y = heappop(pq)\n            if [x, y] == hole:\n                return cur_path\n\n            for k, d in enumerate(dirs):\n                dist_move, r, c = 0, x + dirs_vector[k][0], y + dirs_vector[k][1]\n                while 0 <= r < m and 0 <= c < n and maze[r][c] == 0 and [r, c] != hole:\n                    r += dirs_vector[k][0]\n                    c += dirs_vector[k][1]\n                    dist_move += 1\n                r -= dirs_vector[k][0]\n                c -= dirs_vector[k][1]\n                dist_move -= 1\n                \n                if dist[x][y] + dist_move < dist[r][c]:\n                    dist[r][c] = dist[x][y] + dist_move\n                    heappush(pq, (cur_dist + dist_move, cur_path + d, r, c))\n        \n        return \"impossible\"\n",
            "javascript": "class Solution {\n    findShortestWay(maze, ball, hole) {\n        const m = maze.length, n = maze[0].length;\n        const dist = Array.from({ length: m }, () => Array(n).fill(Infinity));\n        const dirs = [\"d\", \"l\", \"r\", \"u\"];\n        const dirs_vector = [[1, 0], [0, -1], [0, 1], [-1, 0]];\n        dist[ball[0]][ball[1]] = 0;\n        const pq = [[0, \"\", ball[0], ball[1]]];\n\n        while (pq.length > 0) {\n            pq.sort((a, b) => a[0] - b[0] || a[1].localeCompare(b[1]));\n            const [cur_dist, cur_path, x, y] = pq.shift();\n            if (x === hole[0] && y === hole[1]) return cur_path;\n\n            for (let k = 0; k < 4; ++k) {\n                let dist_move = 0, r = x, c = y;\n                while (r >= 0 && r < m && c >= 0 && c < n && maze[r][c] === 0 && (r !== hole[0] || c !== hole[1])) {\n                    r += dirs_vector[k][0];\n                    c += dirs_vector[k][1];\n                    ++dist_move;\n                }\n                r -= dirs_vector[k][0];\n                c -= dirs_vector[k][1];\n                --dist_move;\n\n                if (dist[x][y] + dist_move < dist[r][c]) {\n                    dist[r][c] = dist[x][y] + dist_move;\n                    pq.push([cur_dist + dist_move, cur_path + dirs[k], r, c]);\n                }\n            }\n        }\n\n        return \"impossible\";\n    }\n}\n",
            "explanation": "The algorithm used to solve this problem is Dijkstra's shortest path algorithm with a priority queue. For each location in the maze, we store the minimal distance to reach that location along with the lexicographically smallest instructions.\n\nWe start at the ball's position and then simulate rolling it in all four directions. While rolling, we make sure that we don't go past the walls of the maze or hit a random wall, and we stop when the ball hits the hole. We update the distance and path to the location where the ball stops, only if it's shorter than the current recorded path for that location.\n\nSince we're using a priority queue, we will always process the shortest distance location first (in case of a tie, we process the lexicographically smaller path first). This guarantees that if we reach the hole while processing a location, the resulting path will be the shortest and lexicographically smallest.\n\nIf we have visited all possible locations and don't find the hole, we return \"impossible\" as the answer.\n\nThe time complexity is O(m * n * log(m * n)) where m and n are the row and column size of the maze. The space complexity is O(m * n) since we are storing the distance and path for all the locations in the maze."
        },
        "structure": {
            "c++": "#include <vector>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\nclass Solution \n    // Your code here\n};\n",
            "java": "import java.util.*;\n\nclass Solution \n    // Your code here\n}\n",
            "python": "from heapq import heappush, heappop\n    # Your code here\n\n",
            "javascript": "class Solution \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "string findShortestWay(vector<vector<int>>& maze, vector<int>& ball, vector<int>& hole) {\n    int m = maze.size(), n = maze[0].size();\n    vector<vector<int>> dist(m, vector<int>(n, INT_MAX)); \n    vector<string> dirs = {\"d\", \"l\", \"r\", \"u\"};\n    vector<vector<int>> dirs_vector = {{1, 0}, {0, -1}, {0, 1}, {-1, 0}};\n    string res = \"\";\n    dist[ball[0]][ball[1]] = 0;\n    auto cmp = [&](const auto& p1, const auto& p2){\n        return p1.first > p2.first || (p1.first == p2.first && p1.second > p2.second);\n    };\n    priority_queue<pair<int, string>, vector<pair<int, string>>, decltype(cmp)> pq(cmp);\n    pq.push({0, \"\"});\n    \n    while (!pq.empty()) {\n        int cur_dist = pq.top().first;\n        string cur_path = pq.top().second;\n        int x = ball[0], y = ball[1];\n        for (char c : cur_path) {\n            if (c == 'd') x += dirs_vector[0][0]; \n            if (c == 'l') y += dirs_vector[1][1];\n            if (c == 'r') y += dirs_vector[2][1];\n            if (c == 'u') x += dirs_vector[3][0];\n        }\n        pq.pop();\n        if (x == hole[0] && y == hole[1]) return cur_path;\n\n        for (int k = 0; k < 4; ++k) {\n            int dist_move = 0, r = x, c = y;\n            while (r >= 0 && r < m && c >= 0 && c < n && maze[r][c] == 0 && (r != hole[0] || c != hole[1])) {\n                r += dirs_vector[k][0];\n                c += dirs_vector[k][1];\n                ++dist_move;\n            }\n            r -= dirs_vector[k][0];\n            c -= dirs_vector[k][1];\n            --dist_move;\n            \n            if (dist[x][y] + dist_move < dist[r][c]) {\n                dist[r][c] = dist[x][y] + dist_move;\n                pq.push({cur_dist + dist_move, cur_path + dirs[k]});\n            }\n        }\n    }\n    \n    return \"impossible\";\n}",
            "java": "public static void main(String[] args) {\n        int n = $args;\n        boolean result = isPowerOfFour(n);\n        System.out.println(result);\n    }\n",
            "python": "if __name__ == \"__main__\":\n    maze = $args[0]\n    ball = $args[1]\n    hole = $args[2]\n    solution = Solution()\n    result = solution.findShortestWay(maze, ball, hole)\n    print(result)",
            "javascript": "findShortestWay(maze, ball, hole)"
        }
    },
    "500": {
        "title": "Words in One Row",
        "description": "Given an array of strings `words`, return the words that can be typed using letters of the alphabet on only one row of American keyboard. The American keyboard has three rows of characters: the first row consists of the characters \"qwertyuiop \", the second row consists of the characters \"asdfghjkl \", and the third row consists of the characters \"zxcvbnm \".",
        "example": "Example 1:\n\nInput: words = [\"Hello \", \"Alaska \", \"Dad \", \"Peace \"]\nOutput: [\"Alaska \", \"Dad \"]\n\nExample 2:\n\nInput: words = [\"omk \"]\nOutput: []\n\nExample 3:\n\nInput: words = [\"adsdf \", \"sfd \"]\nOutput: [\"adsdf \", \"sfd \"]",
        "level": "Easy",
        "tags": [
            "array",
            "string"
        ],
        "test_cases": {
            "inputs": [
                [
                    "Hello ",
                    "Alaska ",
                    "Dad ",
                    "Peace "
                ],
                [
                    "omk "
                ],
                [
                    "adsdf ",
                    "sfd "
                ],
                [
                    "qwerty ",
                    "asdf ",
                    "zxcvbnm "
                ],
                [
                    "abc ",
                    "def ",
                    "ghi "
                ],
                [
                    "qaz ",
                    "wsx ",
                    "edc "
                ],
                [
                    "qazwsx ",
                    "edcrfv ",
                    "tgb "
                ],
                [
                    "qaz ",
                    "wsx ",
                    "edc ",
                    "rfv ",
                    "tgb ",
                    "yhn ",
                    "ujm "
                ],
                [
                    "qwertyuiop ",
                    "asdfghjkl ",
                    "zxcvbnm "
                ],
                [
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm "
                ],
                [
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp "
                ],
                [
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm "
                ],
                [
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp "
                ],
                [
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm "
                ],
                [
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp "
                ],
                [
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm "
                ],
                [
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp "
                ],
                [
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm "
                ],
                [
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp "
                ],
                [
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm "
                ],
                [
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp "
                ],
                [
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop "
                ],
                [
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm "
                ],
                [
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp ",
                    "asdfghjklqwertyuiop ",
                    "zxcvbnm ",
                    "qazwsxedcrfvtgbyhnujmikolp "
                ]
            ],
            "outputs": [
                "[\"Alaska \", \"Dad \"]",
                "[]",
                "[\"adsdf \", \"sfd \"]",
                "[\"qwerty \", \"asdf \", \"zxcvbnm \"]",
                "[\"abc \", \"def \", \"ghi \"]",
                "[\"qaz \", \"wsx \", \"edc \"]",
                "[\"qazwsx \", \"edcrfv \", \"tgb \"]",
                "[\"qaz \", \"wsx \", \"edc \", \"rfv \", \"tgb \", \"yhn \", \"ujm \"]",
                "[\"qwertyuiop \", \"asdfghjkl \", \"zxcvbnm \"]",
                "[\"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \"]",
                "[\"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \"]",
                "[\"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \"]",
                "[\"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \"]",
                "[\"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \"]",
                "[\"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \"]",
                "[\"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \"]",
                "[\"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \"]",
                "[\"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \"]",
                "[\"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \"]",
                "[\"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \"]",
                "[\"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \"]",
                "[\"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \"]",
                "[\"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \", \"asdfghjklqwertyuiop \", \"zxcvbnm \", \"qazwsxedcrfvtgbyhnujmikolp \"]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nvector<string> findWords(vector<string>& words) {\n    vector<unordered_set<char>> rows = {\n        {'q','w','e','r','t','y','u','i','o','p'},\n        {'a','s','d','f','g','h','j','k','l'},\n        {'z','x','c','v','b','n','m'}\n    };\n    vector<string> result;\n    \n    for (const auto& word : words) {\n        int row = -1;\n        for (int i = 0; i < 3; ++i) {\n            if (rows[i].count(tolower(word[0])) > 0) {\n                row = i;\n                break;\n            }\n        }\n        \n        bool isOneRow = true;\n        for (const auto& letter : word) {\n            if (rows[row].count(tolower(letter)) == 0) {\n                isOneRow = false;\n                break;\n            }\n        }\n        \n        if (isOneRow) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\n\npublic class Solution {\n    public String[] findWords(String[] words) {\n        HashSet<Character>[] rows = new HashSet[] {\n            new HashSet<Character>() {{\n                add('q'); add('w'); add('e'); add('r'); add('t');\n                add('y'); add('u'); add('i'); add('o'); add('p');\n            }},\n            new HashSet<Character>() {{\n                add('a'); add('s'); add('d'); add('f'); add('g');\n                add('h'); add('j'); add('k'); add('l');\n            }},\n            new HashSet<Character>() {{\n                add('z'); add('x'); add('c'); add('v'); add('b');\n                add('n'); add('m');\n            }}\n        };\n        List<String> res = new ArrayList<>();\n        \n        for (String word : words) {\n            int row = -1;\n            for (int i = 0; i < 3; i++) {\n                if (rows[i].contains(Character.toLowerCase(word.charAt(0)))) {\n                    row = i;\n                    break;\n                }\n            }\n            \n            boolean isOneRow = true;\n            for (char letter : word.toCharArray()) {\n                if (!rows[row].contains(Character.toLowerCase(letter))) {\n                    isOneRow = false;\n                    break;\n                }\n            }\n            \n            if (isOneRow)\n                res.add(word);\n        }\n        \n        return res.toArray(new String[0]);\n    }\n}\n\n",
            "python": "def find_words(words):\n    rows = [\n        set(\"qwertyuiopQWERTYUIOP\"),\n        set(\"asdfghjklASDFGHJKL\"),\n        set(\"zxcvbnmZXCVBNM\")\n    ]\n    res = []\n\n    for word in words:\n        row = -1\n        for i in range(3):\n            if word[0] in rows[i]:\n                row = i\n                break\n\n        if all(c in rows[row] for c in word):\n            res.append(word)\n\n    return res\n\n",
            "javascript": "function findWords(words) {\n    const rows = [\n        new Set(\"qwertyuiopQWERTYUIOP\".split('')),\n        new Set(\"asdfghjklASDFGHJKL\".split('')),\n        new Set(\"zxcvbnmZXCVBNM\".split(''))\n    ];\n    const res = [];\n\n    for (const word of words) {\n        let row = -1;\n        for (let i = 0; i < 3; i++) {\n            if (rows[i].has(word[0])) {\n                row = i;\n                break;\n            }\n        }\n\n        if (word.split('').every(c => rows[row].has(c))) {\n            res.push(word);\n        }\n    }\n\n    return res;\n}\n\n",
            "explanation": "1. Create an array of sets representing each row of the American keyboard. Include both uppercase and lowercase letters in the set.\n2. Initialize an empty result list.\n3. Loop through the input words array.\n4. Determine the row of the first character of the current word by checking which of the 3 rows contains it.\n5. Check if all the characters in the current word belong to the same row found in step 4. If yes, append the word to the result list.\n6. Once the loop is done, return the result list."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nvector<string> findWords(vector<string>& words) \n    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\n\npublic class Solution \n    // Your code here\n}\n\n",
            "python": "def find_words(words):\n    # Your code here\n\n",
            "javascript": "function findWords(words) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nint main() {\n    vector<string> words = $args;\n    vector<string> result = findWords(words);\n    \n    for (const auto& word : result) {\n        cout << word << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n",
            "java": "public String[] findWords(String[] words) {\n        HashSet<Character>[] rows = new HashSet[] {\n            new HashSet<Character>() {{\n                add('q'); add('w'); add('e'); add('r'); add('t');\n                add('y'); add('u'); add('i'); add('o'); add('p');\n            }},\n            new HashSet<Character>() {{\n                add('a'); add('s'); add('d'); add('f'); add('g');\n                add('h'); add('j'); add('k'); add('l');\n            }},\n            new HashSet<Character>() {{\n                add('z'); add('x'); add('c'); add('v'); add('b');\n                add('n'); add('m');\n            }}\n        };\n        List<String> res = new ArrayList<>();\n        \n        for (String word : words) {\n            int row = -1;\n            for (int i = 0; i < 3; i++) {\n                if (rows[i].contains(Character.toLowerCase(word.charAt(0)))) {\n                    row = i;\n                    break;\n                }\n            }\n            \n            boolean isOneRow = true;\n            for (char letter : word.toCharArray()) {\n                if (!rows[row].contains(Character.toLowerCase(letter))) {\n                    isOneRow = false;\n                    break;\n                }\n            }\n            \n            if (isOneRow)\n                res.add(word);\n        }\n        \n        return res.toArray(new String[0]);\n    }",
            "python": "if __name__ == \"__main__\":\n    words = $args[0]\n    result = find_words(words)\n    print(result)",
            "javascript": "function findWords(words) {\n    const rows = [\n        new Set(\"qwertyuiopQWERTYUIOP\".split('')),\n        new Set(\"asdfghjklASDFGHJKL\".split('')),\n        new Set(\"zxcvbnmZXCVBNM\".split(''))\n    ];\n    const res = [];\n\n    for (const word of words) {\n        let row = -1;\n        for (let i = 0; i < 3; i++) {\n            if (rows[i].has(word[0])) {\n                row = i;\n                break;\n            }\n        }\n\n        if (word.split('').every(c => rows[row].has(c))) {\n            res.push(word);\n        }\n    }\n\n    return res;\n}"
        }
    },
    "501": {
        "title": "Mode of Binary Search Tree",
        "description": "Given the `root` of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it. If the tree has more than one mode, return them in any order. Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than or equal to the node's key. The right subtree of a node contains only nodes with keys greater than or equal to the node's key. Both the left and right subtrees must also be binary search trees.",
        "example": "Example:\n\nInput: root = [1,null,2,2]\nOutput: [2]\n\nInput: root = [0]\nOutput: [0]",
        "level": "Medium",
        "tags": [
            "binary search tree",
            "mode",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                "[1,null,2,2]",
                [
                    0
                ],
                "[3,2,4,2,3,null,4,null,null,null,null,null,null,null,5]",
                "[5,5,5,5,5,null,6,null,null,null,null,null,null,null,7]",
                [
                    1,
                    1,
                    2,
                    2,
                    3,
                    3,
                    4,
                    4,
                    5,
                    5,
                    6,
                    6,
                    7,
                    7,
                    8,
                    8,
                    9,
                    9,
                    10,
                    10
                ]
            ],
            "outputs": [
                "[2]",
                "[0]",
                "[2,3,4]",
                "[5]",
                "[1,2,3,4,5,6,7,8,9,10]"
            ]
        },
        "sample_code": {
            "c++": "void InOrder(TreeNode* root, unordered_map<int, int>& frequencies, int& max_frequency) {\n    if (!root) return;\n    InOrder(root->left, frequencies, max_frequency);\n    frequencies[root->val]++;\n    max_frequency = max(max_frequency, frequencies[root->val]);\n    InOrder(root->right, frequencies, max_frequency);\n}\n\nvector<int> findMode(TreeNode* root) {\n    unordered_map<int, int> frequencies;\n    int max_frequency = 0;\n    InOrder(root, frequencies, max_frequency);\n    vector<int> modes;\n    \n    for (const auto& freq : frequencies) {\n        if (freq.second == max_frequency) modes.push_back(freq.first);\n    }\n    \n    return modes;\n}\n",
            "java": "public List<Integer> findMode(TreeNode root) {\n    List<Integer> modes = new ArrayList<>();\n    if (root == null) return modes;\n    \n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n    Stack<TreeNode> stack = new Stack<>();\n    TreeNode currentNode = root;\n    int maxFrequency = 0;\n    \n    while (currentNode != null || !stack.isEmpty()) {\n        while (currentNode != null) {\n            stack.add(currentNode);\n            currentNode = currentNode.left;\n        }\n        currentNode = stack.pop();\n        frequencyMap.put(currentNode.val, frequencyMap.getOrDefault(currentNode.val, 0) + 1);\n        maxFrequency = Math.max(maxFrequency, frequencyMap.get(currentNode.val));\n        currentNode = currentNode.right;\n    }\n    \n    for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n        if (entry.getValue() == maxFrequency) modes.add(entry.getKey());\n    }\n    \n    return modes;\n}\n",
            "python": "def findMode(root):\n    def InOrder(node):\n        if not node: return\n        yield from InOrder(node.left)\n        yield node.val\n        yield from InOrder(node.right)\n        \n    counts = collections.Counter(InOrder(root))\n    max_count = max(counts.values(), default=0)\n    return [k for k, v in counts.items() if v == max_count]\n",
            "javascript": "function findMode(root) {\n    if (!root) return [];\n    \n    const frequencies = new Map();\n    const stack = [];\n    let maxFrequency = 0;\n    let currentNode = root;\n    \n    while (currentNode || stack.length) {\n        while (currentNode) {\n            stack.push(currentNode);\n            currentNode = currentNode.left;\n        }\n        currentNode = stack.pop();\n        frequencies.set(currentNode.val, (frequencies.get(currentNode.val) || 0) + 1);\n        maxFrequency = Math.max(maxFrequency, frequencies.get(currentNode.val));\n        currentNode = currentNode.right;\n    }\n    \n    const modes = [];\n    for (const [key, value] of frequencies) {\n        if (value === maxFrequency) modes.push(key);\n    }\n    \n    return modes;\n}\n",
            "explanation": "The algorithm is based on performing an in-order traversal of the binary search tree (BST). In-order traversal of a BST will visit nodes in ascending order. During the traversal, we count the frequency of each element using a HashMap (in C++ and Java), a Dictionary (in Python), or a Map (in JavaScript) and keep track of the maximum frequency.\n\nOnce the traversal is complete, we iterate through our frequency map/dictionary object, and if an element has a frequency equal to the maximum frequency, we add it to our result list/array.\n\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the tree, since we visit each node once during the traversal."
        },
        "structure": {
            "c++": "void InOrder(TreeNode* root, unordered_map<int, int>& frequencies, int& max_frequency) \n    // Your code here\n}\n",
            "java": "public List<Integer> findMode(TreeNode root) \n    // Your code here\n}\n",
            "python": "def findMode(root):\n    # Your code here\n\n",
            "javascript": "function findMode(root) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "void InOrder(TreeNode* root, unordered_map<int, int>& frequencies, int& max_frequency) {\n    if (!root) return;\n    InOrder(root->left, frequencies, max_frequency);\n    frequencies[root->val]++;\n    max_frequency = max(max_frequency, frequencies[root->val]);\n    InOrder(root->right, frequencies, max_frequency);\n}\n\nvector<int> findMode(TreeNode* root) {\n    unordered_map<int, int> frequencies;\n    int max_frequency = 0;\n    InOrder(root, frequencies, max_frequency);\n    vector<int> modes;\n    \n    for (const auto& freq : frequencies) {\n        if (freq.second == max_frequency) modes.push_back(freq.first);\n    }\n    \n    return modes;\n}",
            "java": "public List<Integer> findMode(TreeNode root) {\n    List<Integer> modes = new ArrayList<>();\n    if (root == null) return modes;\n    \n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n    Stack<TreeNode> stack = new Stack<>();\n    TreeNode currentNode = root;\n    int maxFrequency = 0;\n    \n    while (currentNode != null || !stack.isEmpty()) {\n        while (currentNode != null) {\n            stack.add(currentNode);\n            currentNode = currentNode.left;\n        }\n        currentNode = stack.pop();\n        frequencyMap.put(currentNode.val, frequencyMap.getOrDefault(currentNode.val, 0) + 1);\n        maxFrequency = Math.max(maxFrequency, frequencyMap.get(currentNode.val));\n        currentNode = currentNode.right;\n    }\n    \n    for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n        if (entry.getValue() == maxFrequency) modes.add(entry.getKey());\n    }\n    \n    return modes;\n}",
            "python": "if __name__ == \"__main__\":\n    root = $args[0]\n    result = findMode(root)\n    print(result)",
            "javascript": "function findMode(root) {\n    if (!root) return [];\n    \n    const frequencies = new Map();\n    const stack = [];\n    let maxFrequency = 0;\n    let currentNode = root;\n    \n    while (currentNode || stack.length) {\n        while (currentNode) {\n            stack.push(currentNode);\n            currentNode = currentNode.left;\n        }\n        currentNode = stack.pop();\n        frequencies.set(currentNode.val, (frequencies.get(currentNode.val) || 0) + 1);\n        maxFrequency = Math.max(maxFrequency, frequencies.get(currentNode.val));\n        currentNode = currentNode.right;\n    }\n    \n    const modes = [];\n    for (const [key, value] of frequencies) {\n        if (value === maxFrequency) modes.push(key);\n    }\n    \n    return modes;\n}"
        }
    },
    "502": {
        "title": "Maximize Capital",
        "description": "LeetCode is planning to start its IPO and wants to work on some projects to increase its capital before the IPO. However, there is a limit on the number of projects they can finish before the IPO. LeetCode needs your help to design the best way to maximize its total capital after finishing at most `k` distinct projects. You are given `n` projects, each with a pure profit `profits[i]` and a minimum capital `capital[i]` needed to start it. Initially, you have `w` capital. When you finish a project, you obtain its pure profit, which is added to your total capital. Pick a list of at most `k` distinct projects to maximize your final capital and return the final maximized capital. The answer is guaranteed to fit in a 32-bit signed integer.",
        "example": "Example:\n\nInput: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\nOutput: 4\nExplanation: Since your initial capital is 0, you can only start the project indexed 0. After finishing it, you will obtain profit 1 and your capital becomes 1. With capital 1, you can either start the project indexed 1 or the project indexed 2. Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital. Therefore, the final maximized capital is 0 + 1 + 3 = 4.",
        "level": "Medium",
        "tags": [
            "Greedy",
            "Heap",
            "Sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    0,
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        0,
                        1,
                        1
                    ]
                ],
                [
                    3,
                    0,
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        0,
                        1,
                        2
                    ]
                ],
                [
                    1,
                    10,
                    [
                        5,
                        10,
                        15
                    ],
                    [
                        0,
                        5,
                        10
                    ]
                ],
                [
                    5,
                    100,
                    [
                        10,
                        20,
                        30,
                        40,
                        50
                    ],
                    [
                        0,
                        10,
                        20,
                        30,
                        40
                    ]
                ],
                [
                    4,
                    5,
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        0,
                        1,
                        2,
                        3,
                        4
                    ]
                ],
                [
                    2,
                    1000,
                    [
                        100,
                        200,
                        300,
                        400,
                        500
                    ],
                    [
                        0,
                        100,
                        200,
                        300,
                        400
                    ]
                ],
                [
                    3,
                    50,
                    [
                        10,
                        20,
                        30,
                        40,
                        50
                    ],
                    [
                        0,
                        10,
                        20,
                        30,
                        40
                    ]
                ],
                [
                    1,
                    0,
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        0,
                        1,
                        2,
                        3,
                        4
                    ]
                ],
                [
                    5,
                    100,
                    [
                        10,
                        20,
                        30,
                        40,
                        50
                    ],
                    [
                        0,
                        10,
                        20,
                        30,
                        40
                    ]
                ],
                [
                    4,
                    5,
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        0,
                        1,
                        2,
                        3,
                        4
                    ]
                ],
                [
                    2,
                    1000,
                    [
                        100,
                        200,
                        300,
                        400,
                        500
                    ],
                    [
                        0,
                        100,
                        200,
                        300,
                        400
                    ]
                ],
                [
                    3,
                    50,
                    [
                        10,
                        20,
                        30,
                        40,
                        50
                    ],
                    [
                        0,
                        10,
                        20,
                        30,
                        40
                    ]
                ],
                [
                    1,
                    0,
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        0,
                        1,
                        2,
                        3,
                        4
                    ]
                ],
                [
                    5,
                    100,
                    [
                        10,
                        20,
                        30,
                        40,
                        50
                    ],
                    [
                        0,
                        10,
                        20,
                        30,
                        40
                    ]
                ],
                [
                    4,
                    5,
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        0,
                        1,
                        2,
                        3,
                        4
                    ]
                ],
                [
                    2,
                    1000,
                    [
                        100,
                        200,
                        300,
                        400,
                        500
                    ],
                    [
                        0,
                        100,
                        200,
                        300,
                        400
                    ]
                ],
                [
                    3,
                    50,
                    [
                        10,
                        20,
                        30,
                        40,
                        50
                    ],
                    [
                        0,
                        10,
                        20,
                        30,
                        40
                    ]
                ],
                [
                    1,
                    0,
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        0,
                        1,
                        2,
                        3,
                        4
                    ]
                ],
                [
                    5,
                    100,
                    [
                        10,
                        20,
                        30,
                        40,
                        50
                    ],
                    [
                        0,
                        10,
                        20,
                        30,
                        40
                    ]
                ],
                [
                    4,
                    5,
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        0,
                        1,
                        2,
                        3,
                        4
                    ]
                ],
                [
                    2,
                    1000,
                    [
                        100,
                        200,
                        300,
                        400,
                        500
                    ],
                    [
                        0,
                        100,
                        200,
                        300,
                        400
                    ]
                ]
            ],
            "outputs": [
                4,
                6,
                15,
                150,
                15,
                1500,
                120,
                1,
                150,
                15,
                1500,
                120,
                1,
                150,
                15,
                1500,
                120,
                1,
                150,
                15,
                1500
            ]
        },
        "sample_code": {
            "c++": "#include <queue>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {\n    vector<pair<int, int>> project_pool;\n    \n    for (size_t i = 0; i < profits.size(); i++) {\n        project_pool.emplace_back(capital[i], profits[i]);\n    }\n    \n    sort(project_pool.begin(), project_pool.end());\n    \n    priority_queue<int> profit_pool;\n    int index = 0;\n    \n    for (int i = 0; i < k; i++) {\n        while (index < project_pool.size() &&\n               project_pool[index].first <= w) {\n            profit_pool.push(project_pool[index++].second);\n        }\n        \n        if (!profit_pool.empty()) {\n            w += profit_pool.top();\n            profit_pool.pop();\n        } else {\n            break;\n        }\n    }\n    \n    return w;\n}\n",
            "java": "import java.util.PriorityQueue;\nimport java.util.Arrays;\n\npublic class Solution {\n    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {\n        int[][] project_pool = new int[profits.length][2];\n        \n        for (int i = 0; i < profits.length; i++) {\n            project_pool[i] = new int[] {capital[i], profits[i]};\n        }\n        \n        Arrays.sort(project_pool, (a, b) -> a[0] - b[0]);\n        \n        PriorityQueue<Integer> profit_pool = new PriorityQueue<>((a, b) -> b - a);\n        int index = 0;\n        \n        for (int i = 0; i < k; i++) {\n            while (index < project_pool.length &&\n                   project_pool[index][0] <= w) {\n                profit_pool.add(project_pool[index++][1]);\n            }\n            \n            if (!profit_pool.isEmpty()) {\n                w += profit_pool.poll();\n            } else {\n                break;\n            }\n        }\n        \n        return w;\n    }\n}\n",
            "python": "import heapq\n\ndef findMaximizedCapital(k: int, w: int, profits, capital) -> int:\n    project_pool = list(zip(capital, profits))\n    project_pool.sort(reverse=True)\n    \n    profit_pool = []\n    \n    while k:\n        while project_pool and project_pool[-1][0] <= w:\n            heapq.heappush(profit_pool, -project_pool.pop()[1])\n        \n        if not profit_pool:\n            break\n        \n        w -= heapq.heappop(profit_pool)\n        k -= 1\n        \n    return w\n",
            "javascript": "function findMaximizedCapital(k, w, profits, capital) {\n    const project_pool = profits.map((p, i) => [capital[i], p]).sort((a, b) => a[0] - b[0]);\n    const profit_pool = new MaxPriorityQueue();\n    let index = 0;\n\n    for (let i = 0; i < k; i++) {\n        while (index < project_pool.length && project_pool[index][0] <= w) {\n            profit_pool.insert(project_pool[index++][1]);\n        }\n\n        if (!profit_pool.isEmpty()) {\n            w += profit_pool.removeMax();\n        } else {\n            break;\n        }\n    }\n\n    return w;\n}\n\nclass MaxPriorityQueue {\n    constructor() {\n        this.queue = [];\n    }\n    \n    insert(value) {\n        this.queue.push(value);\n        this.siftUp(this.queue.length - 1);\n    }\n    \n    removeMax() {\n        const maxValue = this.queue[0];\n        const lastValue = this.queue.pop();\n        \n        if (this.queue.length) {\n            this.queue[0] = lastValue;\n            this.siftDown(0);\n        }\n        \n        return maxValue;\n    }\n    \n    siftUp(index) {\n        while (index) {\n            const parentIndex = (index - 1) >> 1;\n            if (this.queue[parentIndex] >= this.queue[index]) break;\n            [this.queue[parentIndex], this.queue[index]] = [this.queue[index], this.queue[parentIndex]];\n            index = parentIndex;\n        }\n    }\n    \n    siftDown(index) {\n        while (true) {\n            const leftIndex = (index << 1) + 1;\n            const rightIndex = leftIndex + 1;\n            let maxIndex = index;\n            if (leftIndex < this.queue.length && this.queue[leftIndex] > this.queue[maxIndex]) maxIndex = leftIndex;\n            if (rightIndex < this.queue.length && this.queue[rightIndex] > this.queue[maxIndex]) maxIndex = rightIndex;\n            if (maxIndex === index) break;\n            [this.queue[index], this.queue[maxIndex]] = [this.queue[maxIndex], this.queue[index]];\n            index = maxIndex;\n        }\n    }\n    \n    isEmpty() {\n        return this.queue.length === 0;\n    }\n}\n",
            "explanation": "1. Create an array of project pool, where each element is a pair of (capital, profit).\n2. Sort the project pool array by capital in ascending order.\n3. Initialize a priority queue called profit pool to store the profits of projects based on which one has the highest profit.\n4. Iterate through projects up to k times.\n5. In each iteration, check projects with capitals less than or equal to w in the project pool, push their profits into the profit pool and remove them from the project pool.\n6. If there is any profit in the profit pool, pop the one with the highest profit and add the profit to w.\n7. Return the final maximized capital w after finishing at most k distinct projects."
        },
        "structure": {
            "c++": "#include <queue>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) \n    // Your code here\n}\n",
            "java": "import java.util.PriorityQueue;\nimport java.util.Arrays;\n\npublic class Solution \n    // Your code here\n}\n",
            "python": "import heapq\n    # Your code here\n\n",
            "javascript": "function findMaximizedCapital(k, w, profits, capital) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <queue>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int k = $args;\n    int w = $args;\n    vector<int> profits = $args;\n    vector<int> capital = $args;\n    \n    int result = findMaximizedCapital(k, w, profits, capital);\n    cout << result << endl;\n    \n    return 0;\n}\n",
            "java": "public int findMaximizedCapital(int k, int w, int[] profits, int[] capital)",
            "python": "if __name__ == \"__main__\":\n    k = $args[0]\n    w = $args[1]\n    profits = $args[2]\n    capital = $args[3]\n    result = findMaximizedCapital(k, w, profits, capital)\n    print(result)",
            "javascript": "function findMaximizedCapital(k, w, profits, capital) {\n    const project_pool = profits.map((p, i) => [capital[i], p]).sort((a, b) => a[0] - b[0]);\n    const profit_pool = new MaxPriorityQueue();\n    let index = 0;\n\n    for (let i = 0; i < k; i++) {\n        while (index < project_pool.length && project_pool[index][0] <= w) {\n            profit_pool.insert(project_pool[index++][1]);\n        }\n\n        if (!profit_pool.isEmpty()) {\n            w += profit_pool.removeMax();\n        } else {\n            break;\n        }\n    }\n\n    return w;\n}\n\nclass MaxPriorityQueue {\n    constructor() {\n        this.queue = [];\n    }\n    \n    insert(value) {\n        this.queue.push(value);\n        this.siftUp(this.queue.length - 1);\n    }\n    \n    removeMax() {\n        const maxValue = this.queue[0];\n        const lastValue = this.queue.pop();\n        \n        if (this.queue.length) {\n            this.queue[0] = lastValue;\n            this.siftDown(0);\n        }\n        \n        return maxValue;\n    }\n    \n    siftUp(index) {\n        while (index) {\n            const parentIndex = (index - 1) >> 1;\n            if (this.queue[parentIndex] >= this.queue[index]) break;\n            [this.queue[parentIndex], this.queue[index]] = [this.queue[index], this.queue[parentIndex]];\n            index = parentIndex;\n        }\n    }\n    \n    siftDown(index) {\n        while (true) {\n            const leftIndex = (index << 1) + 1;\n            const rightIndex = leftIndex + 1;\n            let maxIndex = index;\n            if (leftIndex < this.queue.length && this.queue[leftIndex] > this.queue[maxIndex]) maxIndex = leftIndex;\n            if (rightIndex < this.queue.length && this.queue[rightIndex] > this.queue[maxIndex]) maxIndex = rightIndex;\n            if (maxIndex === index) break;\n            [this.queue[index], this.queue[maxIndex]] = [this.queue[maxIndex], this.queue[index]];\n            index = maxIndex;\n        }\n    }\n    \n    isEmpty() {\n        return this.queue.length === 0;\n    }\n}"
        }
    },
    "503": {
        "title": "Next Greater Number in Circular Array",
        "description": "Given a circular integer array `nums`, return the next greater number for every element in `nums`. The next greater number of a number `x` is the first greater number to its traversing-order next in the array. If it doesn't exist, return -1 for this number.",
        "example": "Example:\n\nInput: nums = [1,2,1]\nOutput: [2,-1,2]\nExplanation: The first 1's next greater number is 2. The number 2 can't find the next greater number. The second 1's next greater number needs to search circularly, which is also 2.",
        "level": "Medium",
        "tags": [
            "array",
            "circular array",
            "stack"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    3
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    3,
                    1,
                    2,
                    4,
                    5
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1
                ],
                [
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    9
                ]
            ],
            "outputs": [
                [
                    2,
                    -1,
                    2
                ],
                [
                    2,
                    3,
                    4,
                    -1,
                    4
                ],
                [
                    -1,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    -1,
                    -1,
                    -1,
                    -1,
                    -1
                ],
                [
                    4,
                    2,
                    4,
                    5,
                    -1
                ],
                [
                    -1,
                    9,
                    9,
                    9,
                    9,
                    9,
                    9,
                    9,
                    9
                ],
                [
                    -1
                ],
                [
                    -1,
                    -1
                ],
                [
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    -1
                ],
                [
                    9,
                    9,
                    9,
                    9,
                    9,
                    9,
                    9,
                    9,
                    9,
                    -1
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <stack>\n\nstd::vector<int> nextGreaterElements(std::vector<int>& nums) {\n    std::vector<int> result(nums.size(), -1);\n    std::stack<int> s;\n\n    for (int i = 0; i < nums.size() * 2; ++i) {\n        int index = i % nums.size();\n        while (!s.empty() && nums[s.top()] < nums[index]) {\n            result[s.top()] = nums[index];\n            s.pop();\n        }\n        if (i < nums.size()) {\n            s.push(index);\n        }\n    }\n    return result;\n}\n",
            "java": "import java.util.Stack;\n\npublic int[] nextGreaterElements(int[] nums) {\n    int n = nums.length;\n    int[] result = new int[n];\n    Stack<Integer> stack = new Stack<>();\n    \n    for (int i = 0; i < n * 2; i++) {\n        int index = i % n;\n        while (!stack.isEmpty() && nums[stack.peek()] < nums[index]) {\n            result[stack.pop()] = nums[index];\n        }\n        if (i < n) {\n            stack.push(index);\n        }\n    }\n    return result;\n}\n",
            "python": "def nextGreaterElements(nums):\n    result = [-1] * len(nums)\n    stack = []\n\n    for i in range(len(nums) * 2):\n        index = i % len(nums)\n        while stack and nums[stack[-1]] < nums[index]:\n            result[stack.pop()] = nums[index]\n        if i < len(nums):\n            stack.append(index)\n\n    return result\n",
            "javascript": "function nextGreaterElements(nums) {\n  const result = new Array(nums.length).fill(-1);\n  const stack = [];\n\n  for (let i = 0; i < nums.length * 2; i++) {\n    const index = i % nums.length;\n    while (stack.length > 0 && nums[stack[stack.length - 1]] < nums[index]) {\n      result[stack.pop()] = nums[index];\n    }\n    if (i < nums.length) {\n      stack.push(index);\n    }\n  }\n  return result;\n}\n",
            "explanation": "The algorithm uses a stack to keep track of the indices of the elements in the `nums` array. We traverse the array twice (using modulo operator) since it's circular. For each element, we check if it's greater than the top element (index) of the stack. If it is, we update the corresponding result for that index with the current element and pop the index from the stack. We push the current index onto the stack if we are still in the first traversal.\n\nFinally, we return `result` list which holds the next greater element for all elements in the input list. If a greater element is not found for an element, its value in the result list will remain `-1`. "
        },
        "structure": {
            "c++": "#include <vector>\n#include <stack>\n\nstd::vector<int> nextGreaterElements(std::vector<int>& nums) \n    // Your code here\n}\n",
            "java": "import java.util.Stack;\n\npublic int[] nextGreaterElements(int[] nums) \n    // Your code here\n}\n",
            "python": "def nextGreaterElements(nums):\n    # Your code here\n\n",
            "javascript": "function nextGreaterElements(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <stack>\n\nstd::vector<int> nextGreaterElements(std::vector<int>& nums) {\n    std::vector<int> result(nums.size(), -1);\n    std::stack<int> s;\n\n    for (int i = 0; i < nums.size() * 2; ++i) {\n        int index = i % nums.size();\n        while (!s.empty() && nums[s.top()] < nums[index]) {\n            result[s.top()] = nums[index];\n            s.pop();\n        }\n        if (i < nums.size()) {\n            s.push(index);\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::vector<int> nums = $args;\n    std::vector<int> result = nextGreaterElements(nums);\n    for (int i = 0; i < result.size(); ++i) {\n        std::cout << result[i] << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}",
            "java": "public int[] nextGreaterElements(int[] nums) {\n    int n = nums.length;\n    int[] result = new int[n];\n    Stack<Integer> stack = new Stack<>();\n    \n    for (int i = 0; i < n * 2; i++) {\n        int index = i % n;\n        while (!stack.isEmpty() && nums[stack.peek()] < nums[index]) {\n            result[stack.pop()] = nums[index];\n        }\n        if (i < n) {\n            stack.push(index);\n        }\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = nextGreaterElements(nums)\n    print(result)",
            "javascript": "function nextGreaterElements(nums) {\n  const result = new Array(nums.length).fill(-1);\n  const stack = [];\n\n  for (let i = 0; i < nums.length * 2; i++) {\n    const index = i % nums.length;\n    while (stack.length > 0 && nums[stack[stack.length - 1]] < nums[index]) {\n      result[stack.pop()] = nums[index];\n    }\n    if (i < nums.length) {\n      stack.push(index);\n    }\n  }\n  return result;\n}"
        }
    },
    "504": {
        "title": "Base 7 Representation",
        "description": "Given an integer `num`, return a string of its base 7 representation.",
        "example": "Example:\n\nInput: num = 100\nOutput: \"202\"\n\nInput: num = -7\nOutput: \"-10\"",
        "level": "Easy",
        "tags": [
            "math",
            "conversion"
        ],
        "test_cases": {
            "inputs": [
                100,
                -7,
                0,
                7,
                49,
                -49,
                1000000,
                -1000000,
                1,
                -1,
                107,
                -107,
                999,
                -999,
                123456,
                -123456,
                987654,
                -987654,
                9999999,
                -9999999
            ],
            "outputs": [
                "202",
                "-10",
                "0",
                "10",
                "100",
                "-100",
                "2624660",
                "-2624660",
                "1",
                "-1",
                "250",
                "-250",
                "26241",
                "-26241",
                "150666",
                "-150666",
                "603660",
                "-603660",
                "15066666",
                "-15066666"
            ]
        },
        "sample_code": {
            "c++": "std::string convertToBase7(int num) {\n    if (num == 0) return \"0\";\n    std::string result = \"\";\n    bool negative = num < 0;\n    if (negative) num *= -1;\n    while (num > 0) {\n        result = std::to_string(num % 7) + result;\n        num /= 7;\n    }\n    return negative ? \"-\" + result : result;\n}\n",
            "java": "public String convertToBase7(int num) {\n    if (num == 0) return \"0\";\n    StringBuilder result = new StringBuilder();\n    boolean negative = num < 0;\n    if (negative) num *= -1;\n    while (num > 0) {\n        result.insert(0, num % 7);\n        num /= 7;\n    }\n    return negative ? \"-\" + result.toString() : result.toString();\n}\n",
            "python": "def convert_to_base7(num: int) -> str:\n    if num == 0:\n        return \"0\"\n    result = \"\"\n    negative = num < 0\n    if negative:\n        num *= -1\n    while num > 0:\n        result = str(num % 7) + result\n        num //= 7\n    return \"-\" + result if negative else result\n",
            "javascript": "function convertToBase7(num) {\n    if (num === 0) return \"0\";\n    let result = \"\";\n    let negative = num < 0;\n    if (negative) num *= -1;\n    while (num > 0) {\n        result = (num % 7).toString() + result;\n        num = Math.floor(num / 7);\n    }\n    return negative ? \"-\" + result : result;\n}\n",
            "explanation": "The algorithm first checks if the input number is 0, and if so, it simply returns the base-7 representation as \"0\". If the number is negative, it keeps track of the sign and converts the number to positive. Then, it iteratively divides the number by 7 (integer division) and prepends the remainder (modulus) to the result string. Finally, if the input number was negative, it adds the minus sign back to the result string. The same algorithm is implemented in C++, Java, Python, and JavaScript with minor syntax adjustments."
        },
        "structure": {
            "c++": "std::string convertToBase7(int num) \n    // Your code here\n}\n",
            "java": "public String convertToBase7(int num) \n    // Your code here\n}\n",
            "python": "def convert_to_base7(num: int) -> str:\n    # Your code here\n\n",
            "javascript": "function convertToBase7(num) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "std::string convertToBase7(int num) {\n    if (num == 0) return \"0\";\n    std::string result = \"\";\n    bool negative = num < 0;\n    if (negative) num *= -1;\n    while (num > 0) {\n        result = std::to_string(num % 7) + result;\n        num /= 7;\n    }\n    return negative ? \"-\" + result : result;\n}",
            "java": "public String convertToBase7(int num) {\n    if (num == 0) return \"0\";\n    StringBuilder result = new StringBuilder();\n    boolean negative = num < 0;\n    if (negative) num *= -1;\n    while (num > 0) {\n        result.insert(0, num % 7);\n        num /= 7;\n    }\n    return negative ? \"-\" + result.toString() : result.toString();\n}",
            "python": "if __name__ == \"__main__\":\n    num = $args[0]\n    result = convert_to_base7(num)\n    print(result)",
            "javascript": "function main() {\n    const num = $args;\n    const result = convertToBase7(num);\n    console.log(result);\n}"
        }
    },
    "505": {
        "title": "Shortest Distance in a Maze",
        "description": "There is a ball in a maze with empty spaces (represented as 0) and walls (represented as 1). The ball can go through the empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.\n\nGiven the m x n maze, the ball's start position and the destination, where start = [startrow, startcol] and destination = [destinationrow, destinationcol], return the shortest distance for the ball to stop at the destination. If the ball cannot stop at destination, return -1.\n\nThe distance is the number of empty spaces traveled by the ball from the start position (excluded) to the destination (included).\n\nYou may assume that the borders of the maze are all walls (see examples).",
        "example": "Example:\n\nInput: maze = [[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]], start = [0,4], destination = [4,4]\nOutput: 12\nExplanation: One possible way is: left -> down -> left -> down -> right -> down -> right. The length of the path is 1 + 1 + 3 + 1 + 2 + 2 + 2 = 12.",
        "level": "Medium",
        "tags": [
            "maze",
            "graph",
            "shortest path"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        [
                            0,
                            0,
                            1,
                            0,
                            0
                        ],
                        [
                            0,
                            0,
                            0,
                            0,
                            0
                        ],
                        [
                            0,
                            0,
                            0,
                            1,
                            0
                        ],
                        [
                            1,
                            1,
                            0,
                            1,
                            1
                        ],
                        [
                            0,
                            0,
                            0,
                            0,
                            0
                        ]
                    ],
                    [
                        0,
                        4
                    ],
                    [
                        4,
                        4
                    ]
                ],
                [
                    [
                        [
                            0,
                            0,
                            1,
                            0,
                            0
                        ],
                        [
                            0,
                            0,
                            0,
                            0,
                            0
                        ],
                        [
                            0,
                            0,
                            0,
                            1,
                            0
                        ],
                        [
                            1,
                            1,
                            0,
                            1,
                            1
                        ],
                        [
                            0,
                            0,
                            0,
                            0,
                            0
                        ]
                    ],
                    [
                        0,
                        4
                    ],
                    [
                        3,
                        2
                    ]
                ],
                [
                    [
                        [
                            0,
                            0,
                            0,
                            0,
                            0
                        ],
                        [
                            1,
                            1,
                            0,
                            0,
                            1
                        ],
                        [
                            0,
                            0,
                            0,
                            0,
                            0
                        ],
                        [
                            0,
                            1,
                            0,
                            0,
                            1
                        ],
                        [
                            0,
                            1,
                            0,
                            0,
                            0
                        ]
                    ],
                    [
                        4,
                        3
                    ],
                    [
                        0,
                        1
                    ]
                ]
            ],
            "outputs": [
                12,
                -1,
                -1
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nint shortestDistance(vector<vector<int>>& maze, vector<int>& start, vector<int>& destination) {\n    int m = maze.size(), n = maze[0].size();\n    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    vector<vector<int>> dist(m, vector<int> (n, -1));\n\n    queue<pair<int, int>> q;\n\n    dist[start[0]][start[1]] = 0;\n    q.push({start[0], start[1]});\n\n    while (!q.empty()) {\n        int x = q.front().first, y = q.front().second;\n        q.pop();\n\n        for (auto dir : directions) {\n            int newX = x + dir.first;\n            int newY = y + dir.second;\n            int step = 0;\n\n            while (newX >= 0 && newX < m && newY >= 0 && newY < n && maze[newX][newY] == 0) {\n                newX += dir.first;\n                newY += dir.second;\n                step++;\n            }\n\n            newX -= dir.first;\n            newY -= dir.second;\n\n            if (dist[newX][newY] == -1 || dist[x][y] + step < dist[newX][newY]) {\n                dist[newX][newY] = dist[x][y] + step;\n                q.push({newX, newY});\n            }\n        }\n    }\n\n    return dist[destination[0]][destination[1]];\n}\n\n",
            "java": "import java.util.PriorityQueue;\n\npublic int shortestDistance(int[][] maze, int[] start, int[] destination) {\n    int m = maze.length, n = maze[0].length;\n    int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    int[][] dist = new int[m][n];\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            dist[i][j] = -1;\n        }\n    }\n\n    PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n\n    dist[start[0]][start[1]] = 0;\n    q.offer(new int[]{start[0], start[1], 0});\n\n    while (!q.isEmpty()) {\n        int[] cur = q.poll();\n        int x = cur[0], y = cur[1];\n\n        for (int[] dir : directions) {\n            int newX = x + dir[0];\n            int newY = y + dir[1];\n            int step = 0;\n\n            while (newX >= 0 && newX < m && newY >= 0 && newY < n && maze[newX][newY] == 0) {\n                newX += dir[0];\n                newY += dir[1];\n                step++;\n            }\n\n            newX -= dir[0];\n            newY -= dir[1];\n\n            if (dist[newX][newY] == -1 || dist[x][y] + step < dist[newX][newY]) {\n                dist[newX][newY] = dist[x][y] + step;\n                q.offer(new int[]{newX, newY, dist[newX][newY]});\n            }\n        }\n    }\n\n    return dist[destination[0]][destination[1]];\n}\n\n",
            "python": "from queue import PriorityQueue\n\ndef shortestDistance(maze, start, destination):\n    m, n = len(maze), len(maze[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    dist = [[-1 for _ in range(n)] for _ in range(m)]\n\n    q = PriorityQueue()\n\n    dist[start[0]][start[1]] = 0\n    q.put((0, start[0], start[1]))\n\n    while not q.empty():\n        cur = q.get()\n        x, y = cur[1], cur[2]\n\n        for dir in directions:\n            newX, newY = x + dir[0], y + dir[1]\n            step = 0\n\n            while 0 <= newX < m and 0 <= newY < n and maze[newX][newY] == 0:\n                newX += dir[0]\n                newY += dir[1]\n                step += 1\n\n            newX -= dir[0]\n            newY -= dir[1]\n\n            if dist[newX][newY] == -1 or dist[x][y] + step < dist[newX][newY]:\n                dist[newX][newY] = dist[x][y] + step\n                q.put((dist[newX][newY], newX, newY))\n\n    return dist[destination[0]][destination[1]]\n\n",
            "javascript": "function shortestDistance(maze, start, destination) {\n    const m = maze.length, n = maze[0].length;\n    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n    const dist = new Array(m).fill(null).map(() => new Array(n).fill(-1));\n\n    const q = [[start[0], start[1], 0]];\n    dist[start[0]][start[1]] = 0;\n\n    while (q.length) {\n        const [x, y, d] = q.shift();\n\n        for (const dir of directions) {\n            let newX = x + dir[0];\n            let newY = y + dir[1];\n            let step = 0;\n\n            while (0 <= newX && newX < m && 0 <= newY && newY < n && maze[newX][newY] === 0) {\n                newX += dir[0];\n                newY += dir[1];\n                step++;\n            }\n\n            newX -= dir[0];\n            newY -= dir[1];\n\n            if (dist[newX][newY] === -1 || dist[x][y] + step < dist[newX][newY]) {\n                dist[newX][newY] = dist[x][y] + step;\n                q.push([newX, newY, dist[newX][newY]]);\n            }\n        }\n    }\n\n    return dist[destination[0]][destination[1]];\n}\n\n",
            "explanation": "We can use a BFS (Breadth-First Search) algorithm to explore the maze, counting the distance travelled in each direction. When visiting an empty space, we can continue moving in each direction until hitting a wall. Once the wall is hit, we store the distance travelled and visit the new position.\n\nWe keep track of visited positions and their distances, updating them if a shorter path is found. Use a queue to hold positions to visit next, and continue the process until the queue is empty.\n\nFinally, return the distance stored at the destination. If the destination hasn't been reached, return -1."
        },
        "structure": {
            "c++": "#include <vector>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nint shortestDistance(vector<vector<int>>& maze, vector<int>& start, vector<int>& destination) \n    // Your code here\n}\n\n",
            "java": "import java.util.PriorityQueue;\n\npublic int shortestDistance(int[][] maze, int[] start, int[] destination) \n    // Your code here\n}\n\n",
            "python": "from queue import PriorityQueue\n    # Your code here\n\n",
            "javascript": "function shortestDistance(maze, start, destination) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nint main() {\n    vector<vector<int>> maze = $args;\n    vector<int> start = $args;\n    vector<int> destination = $args;\n\n    int result = shortestDistance(maze, start, destination);\n\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int shortestDistance(int[][] maze, int[] start, int[] destination) {\n    int m = maze.length, n = maze[0].length;\n    int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    int[][] dist = new int[m][n];\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            dist[i][j] = -1;\n        }\n    }\n\n    PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n\n    dist[start[0]][start[1]] = 0;\n    q.offer(new int[]{start[0], start[1], 0});\n\n    while (!q.isEmpty()) {\n        int[] cur = q.poll();\n        int x = cur[0], y = cur[1];\n\n        for (int[] dir : directions) {\n            int newX = x + dir[0];\n            int newY = y + dir[1];\n            int step = 0;\n\n            while (newX >= 0 && newX < m && newY >= 0 && newY < n && maze[newX][newY] == 0) {\n                newX += dir[0];\n                newY += dir[1];\n                step++;\n            }\n\n            newX -= dir[0];\n            newY -= dir[1];\n\n            if (dist[newX][newY] == -1 || dist[x][y] + step < dist[newX][newY]) {\n                dist[newX][newY] = dist[x][y] + step;\n                q.offer(new int[]{newX, newY, dist[newX][newY]});\n            }\n        }\n    }\n\n    return dist[destination[0]][destination[1]];\n}",
            "python": "if __name__ == \"__main__\":\n    maze = $args[0]\n    start = $args[1]\n    destination = $args[2]\n    result = shortestDistance(maze, start, destination)\n    print(result)",
            "javascript": "function shortestDistance(maze, start, destination) {\n    const m = maze.length, n = maze[0].length;\n    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n    const dist = new Array(m).fill(null).map(() => new Array(n).fill(-1));\n\n    const q = [[start[0], start[1], 0]];\n    dist[start[0]][start[1]] = 0;\n\n    while (q.length) {\n        const [x, y, d] = q.shift();\n\n        for (const dir of directions) {\n            let newX = x + dir[0];\n            let newY = y + dir[1];\n            let step = 0;\n\n            while (0 <= newX && newX < m && 0 <= newY && newY < n && maze[newX][newY] === 0) {\n                newX += dir[0];\n                newY += dir[1];\n                step++;\n            }\n\n            newX -= dir[0];\n            newY -= dir[1];\n\n            if (dist[newX][newY] === -1 || dist[x][y] + step < dist[newX][newY]) {\n                dist[newX][newY] = dist[x][y] + step;\n                q.push([newX, newY, dist[newX][newY]]);\n            }\n        }\n    }\n\n    return dist[destination[0]][destination[1]];\n}"
        }
    },
    "507": {
        "title": "Perfect Number",
        "description": "A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding the number itself. Given an integer n, determine if it is a perfect number.",
        "example": "Example 1:\n\nInput: num = 28\nOutput: true\nExplanation: 28 = 1 + 2 + 4 + 7 + 14\n1, 2, 4, 7, and 14 are all divisors of 28.\n\nExample 2:\n\nInput: num = 7\nOutput: false",
        "level": "Easy",
        "tags": [
            "math",
            "number theory"
        ],
        "test_cases": {
            "inputs": [
                6,
                28,
                12,
                496,
                8128,
                33550336,
                2,
                1,
                0,
                4960,
                100000000,
                108,
                8129,
                33550337,
                3,
                999999999,
                999999998,
                999999997,
                999999996,
                999999995
            ],
            "outputs": [
                true,
                true,
                false,
                true,
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "bool checkPerfectNumber(int num) {\n    if (num <= 1) return false;\n    int sum = 1;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) {\n            sum += i;\n            if (i * i != num) sum += num / i;\n        }\n    }\n    return sum == num;\n}\n",
            "java": "boolean checkPerfectNumber(int num) {\n    if (num <= 1) return false;\n    int sum = 1;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) {\n            sum += i;\n            if (i * i != num) sum += num / i;\n        }\n    }\n    return sum == num;\n}\n",
            "python": "def checkPerfectNumber(num: int) -> bool:\n    if num <= 1:\n        return False\n    sum = 1\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            sum += i\n            if i * i != num:\n                sum += num // i\n        i += 1\n    return sum == num\n",
            "javascript": "function checkPerfectNumber(num) {\n    if (num <= 1) return false;\n    let sum = 1;\n    for (let i = 2; i * i <= num; i++) {\n        if (num % i === 0) {\n            sum += i;\n            if (i * i !== num) sum += num / i;\n        }\n    }\n    return sum === num;\n}\n",
            "explanation": "The algorithm checks if a given number `num` is a perfect number by iterating through the positive divisors of the number and adding them to a sum. If the number is less than or equal to 1, it returns false as these are not perfect numbers. The loop starts from 2 and goes until the square root of the number. If `i` is divisible by `num`, it's added to the sum. Also, check if `i * i` is not equal to `num`, we add `num / i` to the sum, this is because we don't want to add the same divisor twice. In the end, it checks if the calculated sum is equal to the given number. If it is, return true, else return false."
        },
        "structure": {
            "c++": "bool checkPerfectNumber(int num) \n    // Your code here\n}\n",
            "java": "boolean checkPerfectNumber(int num) \n    // Your code here\n}\n",
            "python": "def checkPerfectNumber(num: int) -> bool:\n    # Your code here\n\n",
            "javascript": "function checkPerfectNumber(num) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nbool checkPerfectNumber(int num) {\n    if (num <= 1) return false;\n    int sum = 1;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) {\n            sum += i;\n            if (i * i != num) sum += num / i;\n        }\n    }\n    return sum == num;\n}\n\nint main() {\n    int num = $args;\n    bool result = checkPerfectNumber(num);\n    cout << boolalpha << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n        int num = $args;\n        boolean result = checkPerfectNumber(num);\n        System.out.println(result);\n    }",
            "python": "if __name__ == \"__main__\":\n    num = $args[0]\n    result = checkPerfectNumber(num)\n    print(result)",
            "javascript": "function main() {\n    const num = $args;\n    const result = checkPerfectNumber(num);\n    console.log(result);\n}"
        }
    },
    "508": {
        "title": "Most Frequent Subtree Sum",
        "description": "Given the `root` of a binary tree, return the most frequent subtree sum. If there is a tie, return all the values with the highest frequency in any order.\n\nThe subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself).",
        "example": "Example:\n\nInput: root = [5,2,-3]\nOutput: [2,-3,4]\n\nExplanation: The subtree sums are [5, 2, -3, 4, 2, -3]. The most frequent subtree sum is 2, -3, and 4 with a frequency of 2 each.\n\nInput: root = [5,2,-5]\nOutput: [2]\n\nExplanation: The subtree sums are [5, 2, -5, 2]. The most frequent subtree sum is 2 with a frequency of 2.",
        "level": "Medium",
        "tags": [
            "binary tree",
            "subtree sum",
            "frequency"
        ],
        "test_cases": {
            "inputs": [
                [
                    5,
                    2,
                    -3
                ],
                [
                    5,
                    2,
                    -5
                ],
                [
                    1
                ],
                [
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [],
                "[1,2,3,null,4,5,6,null,null,7,8,9,10]"
            ],
            "outputs": [
                "[2,-3,4]",
                "[2]",
                "[1]",
                "[0]",
                "[15]",
                "[]",
                "[28, 15, 10, 7, 4, 3, 2, 1]"
            ]
        },
        "sample_code": {
            "c++": "#include <map>\n#include <vector>\n\nvoid helper(TreeNode* root, std::map<int, int>& counts, int& max_count) {\n    if (!root) return;\n    int sum = root->val + helper(root->left, counts, max_count) + helper(root->right, counts, max_count);\n    counts[sum]++;\n    max_count = std::max(max_count, counts[sum]);\n}\n\nstd::vector<int> findFrequentTreeSum(TreeNode* root) {\n    std::map<int, int> counts;\n    int max_count = 0;\n    helper(root, counts, max_count);\n    std::vector<int> result;\n    for (const auto& pair : counts) {\n        if (pair.second == max_count) result.push_back(pair.first);\n    }\n    return result;\n}\n\n",
            "java": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic int helper(TreeNode root, HashMap<Integer, Integer> counts) {\n    if (root == null) return 0;\n    int sum = root.val + helper(root.left, counts) + helper(root.right, counts);\n    counts.put(sum, counts.getOrDefault(sum, 0) + 1);\n    return sum;\n}\n\npublic int[] findFrequentTreeSum(TreeNode root) {\n    if (root == null) return new int[0];\n    HashMap<Integer, Integer> counts = new HashMap<>();\n    helper(root, counts);\n    int maxCount = 0;\n    for (int count : counts.values()) {\n        maxCount = Math.max(count, maxCount);\n    }\n    List<Integer> list = new LinkedList<>();\n    for (int key : counts.keySet()) {\n        if (counts.get(key) == maxCount) list.add(key);\n    }\n    return list.stream().mapToInt(i -> i).toArray();\n}\n\n",
            "python": "from collections import defaultdict\n\ndef helper(node, counts):\n    if not node: return 0\n    val = node.val + helper(node.left, counts) + helper(node.right, counts)\n    counts[val] += 1\n    return val\n\ndef findFrequentTreeSum(root):\n    counts = defaultdict(int)\n    helper(root, counts)\n    max_count = max(counts.values(), default=0)\n    return [s for s, c in counts.items() if c == max_count]\n\n",
            "javascript": "function helper(root, counts) {\n    if (!root) return 0;\n    const sum = root.val + helper(root.left, counts) + helper(root.right, counts);\n    counts[sum] = (counts[sum] || 0) + 1;\n    return sum;\n}\n\nfunction findFrequentTreeSum(root) {\n    const counts = {};\n    helper(root, counts);\n    const maxCount = Math.max(...Object.values(counts));\n    return Object.keys(counts).filter(key => counts[key] === maxCount).map(Number);\n}\n\n",
            "explanation": "The algorithm uses a helper function to recursively calculate the subtree sum for each node. The helper function returns the subtree sum of the node it's called on, and the results are combined to calculate the subtree sum of the parent nodes. The subtree sums are stored in a dictionary or map along with their frequencies. After calculating the sums and frequencies for all nodes, the maximum frequency is found by iterating through the values of the dictionary or map. Finally, the function loops through the dictionary or map and adds the keys with the maximum frequency to the result list or array. The result is then returned."
        },
        "structure": {
            "c++": "#include <map>\n#include <vector>\n\nvoid helper(TreeNode* root, std::map<int, int>& counts, int& max_count) \n    // Your code here\n}\n\n",
            "java": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic int helper(TreeNode root, HashMap<Integer, Integer> counts) \n    // Your code here\n}\n\n",
            "python": "from collections import defaultdict\n    # Your code here\n\n",
            "javascript": "function helper(root, counts) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <map>\n#include <vector>\n\nvoid helper(TreeNode* root, std::map<int, int>& counts, int& max_count) {\n    if (!root) return;\n    int sum = root->val + helper(root->left, counts, max_count) + helper(root->right, counts, max_count);\n    counts[sum]++;\n    max_count = std::max(max_count, counts[sum]);\n}\n\nstd::vector<int> findFrequentTreeSum(TreeNode* root) {\n    std::map<int, int> counts;\n    int max_count = 0;\n    helper(root, counts, max_count);\n    std::vector<int> result;\n    for (const auto& pair : counts) {\n        if (pair.second == max_count) result.push_back(pair.first);\n    }\n    return result;\n}\n\nint main() {\n    TreeNode* root = $args;\n    std::vector<int> result = findFrequentTreeSum(root);\n    for (int i : result) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}",
            "java": "public int[] findFrequentTreeSum(TreeNode root) {\n    if (root == null) return new int[0];\n    HashMap<Integer, Integer> counts = new HashMap<>();\n    helper(root, counts);\n    int maxCount = 0;\n    for (int count : counts.values()) {\n        maxCount = Math.max(count, maxCount);\n    }\n    List<Integer> list = new LinkedList<>();\n    for (int key : counts.keySet()) {\n        if (counts.get(key) == maxCount) list.add(key);\n    }\n    return list.stream().mapToInt(i -> i).toArray();\n}\n",
            "python": "if __name__ == \"__main__\":\n    root = $args[0]\n    result = findFrequentTreeSum(root)\n    print(result)",
            "javascript": "function findFrequentTreeSum(root) {\n    const counts = {};\n    helper(root, counts);\n    const maxCount = Math.max(...Object.values(counts));\n    return Object.keys(counts).filter(key => counts[key] === maxCount).map(Number);\n}"
        }
    },
    "509": {
        "title": "Fibonacci Number",
        "description": "Given a number n, calculate the nth Fibonacci number.",
        "example": "For example, if n = 6, the output should be 8. The Fibonacci sequence is 0, 1, 1, 2, 3, 5, 8, ... and the 6th Fibonacci number is 8.",
        "level": "Easy",
        "tags": [
            "Math",
            "Recursion"
        ],
        "test_cases": {
            "inputs": [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                10,
                15,
                20
            ],
            "outputs": [
                0,
                1,
                1,
                2,
                3,
                5,
                8,
                55,
                610,
                6765
            ]
        },
        "sample_code": {
            "c++": "int fib(int n) {\n    if(n < 2) {\n        return n;\n    }\n    int a = 0, b = 1, c;\n    for(int i = 2; i <= n; ++i) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n",
            "java": "public int fib(int n) {\n    if(n < 2) {\n        return n;\n    }\n    int a = 0, b = 1, c;\n    for(int i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n",
            "python": "def fib(n: int) -> int:\n    if n < 2:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n",
            "javascript": "function fib(n) {\n    if(n < 2) {\n        return n;\n    }\n    let a = 0, b = 1, c;\n    for(let i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n",
            "explanation": "The algorithm is an iterative approach to calculate the Fibonacci numbers. Instead of using the recursive formula, we maintain two variables `a` and `b` initialized with F(0) and F(1) respectively. On each iteration, we set `c = a + b`, then update `a` with the value of `b` and `b` with the value of `c`. This process increments both the Fibonacci numbers n times and the final result is stored in the variable `b`. This reduces the time complexity of the problem from exponential (recursive) to linear (iterative)."
        },
        "structure": {
            "c++": "int fib(int n) \n    // Your code here\n}\n",
            "java": "public int fib(int n) \n    // Your code here\n}\n",
            "python": "def fib(n: int) -> int:\n    # Your code here\n\n",
            "javascript": "function fib(n) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n = $args;\n    int result = fib(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n        int n = $args;\n        int result = fib(n);\n        System.out.println(result);\n    }",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    result = fib(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = fib(n);\n    console.log(result);\n}"
        }
    },
    "513": {
        "title": "Leftmost Value in Last Row of Binary Tree",
        "description": "Given the `root` of a binary tree, return the leftmost value in the last row of the tree.",
        "example": "Example 1:\n\nInput: root = [2,1,3]\nOutput: 1\n\nExample 2:\n\nInput: root = [1,2,3,4,null,5,6,null,null,7]\nOutput: 7",
        "level": "Medium",
        "tags": [
            "binary tree",
            "tree traversal"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    1,
                    3
                ],
                "[1,2,3,4,null,5,6,null,null,7]",
                [
                    1
                ],
                [
                    1,
                    2
                ],
                "[1,null,2]",
                "[1,2,3,null,null,4,5]",
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99,
                    100,
                    101,
                    102,
                    103,
                    104
                ]
            ],
            "outputs": [
                "1",
                "7",
                "1",
                "2",
                "2",
                "5",
                "8",
                "104"
            ]
        },
        "sample_code": {
            "c++": "int findBottomLeftValue(TreeNode* root) {\n    int result = 0, maxDepth = 0;\n    helper(root, 1, maxDepth, result);\n    return result;\n}\n\nvoid helper(TreeNode* node, int depth, int& maxDepth, int& result) {\n    if (!node) return;\n    if (depth > maxDepth) {\n        maxDepth = depth;\n        result = node->val;\n    }\n    helper(node->left, depth+1, maxDepth, result);\n    helper(node->right, depth+1, maxDepth, result);\n}\n\n",
            "java": "public int findBottomLeftValue(TreeNode root) {\n    int[] maxDepth = new int[1];\n    int[] result = new int[1];\n    helper(root, 1, maxDepth, result);\n    return result[0];\n}\n\nprivate void helper(TreeNode node, int depth, int[] maxDepth, int[] result) {\n    if (node == null) return;\n    if (depth > maxDepth[0]) {\n        maxDepth[0] = depth;\n        result[0] = node.val;\n    }\n    helper(node.left, depth+1, maxDepth, result);\n    helper(node.right, depth+1, maxDepth, result);\n}\n\n",
            "python": "def findBottomLeftValue(self, root: TreeNode) -> int:\n    result = [0, 0] # [depth, value]\n    self.helper(root, 1, result)\n    return result[1]\n\ndef helper(self, node, depth, result):\n    if not node:\n        return\n    if depth > result[0]:\n        result[0] = depth\n        result[1] = node.val\n\n    self.helper(node.left, depth+1, result)\n    self.helper(node.right, depth+1, result)\n\n",
            "javascript": "function findBottomLeftValue(root) {\n    const result = { maxDepth: 0, value: 0 };\n    helper(root, 1, result);\n    return result.value;\n};\n\nfunction helper(node, depth, result) {\n    if (!node) return;\n    if (depth > result.maxDepth) {\n        result.maxDepth = depth;\n        result.value = node.val;\n    }\n    helper(node.left, depth+1, result);\n    helper(node.right, depth+1, result);\n}\n\n",
            "explanation": "To find the leftmost value in the last row of a binary tree, we can use Depth First Search (DFS) traversal.\n\n1. Create a helper function that takes the input node, current depth, and a result variable.\n2. If the input node is null, then return.\n3. For the given depth:\n    a. If the current depth is greater than the previously recorded maximum depth, update the maximum depth and store the node value as the leftmost value.\n    b. Recurse the helper function for the left child of the node, and increment the depth.\n    c. Recurse the helper function for the right child of the node, and increment the depth.\n4. After the DFS traversal, return the leftmost value found in the last row."
        },
        "structure": {
            "c++": "int findBottomLeftValue(TreeNode* root) \n    // Your code here\n}\n\n",
            "java": "public int findBottomLeftValue(TreeNode root) \n    // Your code here\n}\n\n",
            "python": "def findBottomLeftValue(self, root: TreeNode) -> int:\n    # Your code here\n\n",
            "javascript": "function findBottomLeftValue(root) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int findBottomLeftValue(TreeNode* root) {\n    int result = 0, maxDepth = 0;\n    helper(root, 1, maxDepth, result);\n    return result;\n}\n\nvoid helper(TreeNode* node, int depth, int& maxDepth, int& result) {\n    if (!node) return;\n    if (depth > maxDepth) {\n        maxDepth = depth;\n        result = node->val;\n    }\n    helper(node->left, depth+1, maxDepth, result);\n    helper(node->right, depth+1, maxDepth, result);\n}\n\nint main() {\n    TreeNode* root = $args;\n    int result = findBottomLeftValue(root);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int findBottomLeftValue(TreeNode root) {\n    int[] maxDepth = new int[1];\n    int[] result = new int[1];\n    helper(root, 1, maxDepth, result);\n    return result[0];\n}",
            "python": "if __name__ == \"__main__\":\n    root = $args[0]\n    result = findBottomLeftValue(root)\n    print(result)",
            "javascript": "function main() {\n    const root = $args;\n    const result = { maxDepth: 0, value: 0 };\n    helper(root, 1, result);\n    console.log(result.value);\n}\n"
        }
    },
    "514": {
        "title": "Fallout 4: Road to Freedom",
        "description": "In the video game Fallout 4, players embark on the quest 'Road to Freedom' where they must reach a metal dial called the 'Freedom Trail Ring' and use it to spell a specific keyword to open a door. The ring has a code engraved on its outer surface, represented by the string 'ring'. The keyword that needs to be spelled is represented by the string 'key'. Your task is to determine the minimum number of steps required to spell all the characters in the keyword. The ring starts with its first character aligned at the '12:00' direction. To spell each character in the key, you must rotate the ring clockwise or anticlockwise to align the corresponding character at the '12:00' direction and then press the center button. Each rotation counts as one step, as does pressing the center button. Return the minimum number of steps required to spell all the characters in the keyword.",
        "example": "For example, given ring = 'godding' and key = 'gd', the first key character 'g' is already in place, so we need 1 step to spell it. The second key character 'd' requires rotating the ring anticlockwise by two steps to make it become 'ddinggo'. We then need 1 more step to spell it. Therefore, the minimum number of steps is 4.",
        "level": "Medium",
        "tags": [
            "string",
            "rotation",
            "simulation"
        ],
        "test_cases": {
            "inputs": [
                [
                    "godding",
                    "gd"
                ],
                [
                    "godding",
                    "godding"
                ],
                [
                    "abcdefg",
                    "abc"
                ],
                [
                    "abcdefg",
                    "def"
                ],
                [
                    "abcdefg",
                    "g"
                ],
                [
                    "abcdefg",
                    "abcdefg"
                ],
                [
                    "abcdefg",
                    "gfedcba"
                ],
                [
                    "abcdefg",
                    "cba"
                ],
                [
                    "abcdefg",
                    "gfedc"
                ],
                [
                    "abcdefg",
                    "gfed"
                ],
                [
                    "abcdefg",
                    "gfe"
                ],
                [
                    "abcdefg",
                    "gf"
                ],
                [
                    "abcdefg",
                    "g"
                ],
                [
                    "abcdefg",
                    "a"
                ],
                [
                    "abcdefg",
                    "b"
                ],
                [
                    "abcdefg",
                    "c"
                ],
                [
                    "abcdefg",
                    "d"
                ],
                [
                    "abcdefg",
                    "e"
                ],
                [
                    "abcdefg",
                    "f"
                ],
                [
                    "abcdefg",
                    "g"
                ]
            ],
            "outputs": [
                4,
                13,
                3,
                3,
                1,
                7,
                7,
                3,
                5,
                5,
                5,
                5,
                5,
                1,
                1,
                1,
                1,
                1,
                1,
                1
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <vector>\n#include <algorithm>\n\nint findRotateSteps(std::string ring, std::string key) {\n    int n = ring.size(), m = key.size();\n    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n, 0));\n\n    for (int i = m - 1; i >= 0; --i) {\n        for (int j = 0; j < n; ++j) {\n            dp[i][j] = INT_MAX;\n            for (int k = 0; k < n; ++k) {\n                if (ring[k] == key[i]) {\n                    int diff = abs(j - k);\n                    int step = std::min(diff, n - diff);\n                    dp[i][j] = std::min(dp[i][j], step + dp[i + 1][k]);\n                }\n            }\n        }\n    }\n\n    return dp[0][0] + m;\n}\n\n",
            "java": "public int findRotateSteps(String ring, String key) {\n    int n = ring.length(), m = key.length();\n    int[][] dp = new int[m + 1][n];\n\n    for (int i = m - 1; i >= 0; --i) {\n        for (int j = 0; j < n; ++j) {\n            dp[i][j] = Integer.MAX_VALUE;\n            for (int k = 0; k < n; ++k) {\n                if (ring.charAt(k) == key.charAt(i)) {\n                    int diff = Math.abs(j - k);\n                    int step = Math.min(diff, n - diff);\n                    dp[i][j] = Math.min(dp[i][j], step + dp[i + 1][k]);\n                }\n            }\n        }\n    }\n\n    return dp[0][0] + m;\n}\n\n",
            "python": "def find_rotate_steps(ring: str, key: str) -> int:\n    n, m = len(ring), len(key)\n    dp = [[0] * n for _ in range(m + 1)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n):\n            dp[i][j] = float('inf')\n            for k in range(n):\n                if ring[k] == key[i]:\n                    diff = abs(j - k)\n                    step = min(diff, n - diff)\n                    dp[i][j] = min(dp[i][j], step + dp[i + 1][k])\n\n    return dp[0][0] + m\n\n",
            "javascript": "function findRotateSteps(ring, key) {\n    const n = ring.length, m = key.length;\n    const dp = Array.from({ length: m + 1 }, () => new Array(n).fill(0));\n\n    for (let i = m - 1; i >= 0; --i) {\n        for (let j = 0; j < n; ++j) {\n            dp[i][j] = Infinity;\n            for (let k = 0; k < n; ++k) {\n                if (ring[k] === key[i]) {\n                    const diff = Math.abs(j - k);\n                    const step = Math.min(diff, n - diff);\n                    dp[i][j] = Math.min(dp[i][j], step + dp[i + 1][k]);\n                }\n            }\n        }\n    }\n\n    return dp[0][0] + m;\n}\n\n",
            "explanation": "The algorithm uses dynamic programming. Create a 2D table (\"dp\") with the dimensions of the length of the key + 1 as rows and the length of the ring as columns. The table represents the minimum number of steps required to reach each character in the key by aligning it to the 12:00 direction.\n\nThe main logic runs in reverse of the key string. For each character in the key, the outer ring positions are iterated and checked if the character in the ring matches the character in the key. The minimum steps to reach the matching character are calculated and updated in the \"dp\" table.\n\nFinally, the first element in the \"dp\" table would represent the minimum number of steps required to complete the whole key. The result is the sum of that value and the length of the key."
        },
        "structure": {
            "c++": "#include <string>\n#include <vector>\n#include <algorithm>\n\nint findRotateSteps(std::string ring, std::string key) \n    // Your code here\n}\n\n",
            "java": "public int findRotateSteps(String ring, String key) \n    // Your code here\n}\n\n",
            "python": "def find_rotate_steps(ring: str, key: str) -> int:\n    # Your code here\n\n",
            "javascript": "function findRotateSteps(ring, key) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\nint main() {\n    std::string ring = $args;\n    std::string key = $args;\n    int result = findRotateSteps(ring, key);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public int findRotateSteps(String ring, String key) {\n    int n = ring.length(), m = key.length();\n    int[][] dp = new int[m + 1][n];\n\n    for (int i = m - 1; i >= 0; --i) {\n        for (int j = 0; j < n; ++j) {\n            dp[i][j] = Integer.MAX_VALUE;\n            for (int k = 0; k < n; ++k) {\n                if (ring.charAt(k) == key.charAt(i)) {\n                    int diff = Math.abs(j - k);\n                    int step = Math.min(diff, n - diff);\n                    dp[i][j] = Math.min(dp[i][j], step + dp[i + 1][k]);\n                }\n            }\n        }\n    }\n\n    return dp[0][0] + m;\n}",
            "python": "if __name__ == \"__main__\":\n    ring = $args[0]\n    key = $args[1]\n    result = find_rotate_steps(ring, key)\n    print(result)",
            "javascript": "function findRotateSteps(ring, key) {\n    const n = ring.length, m = key.length;\n    const dp = Array.from({ length: m + 1 }, () => new Array(n).fill(0));\n\n    for (let i = m - 1; i >= 0; --i) {\n        for (let j = 0; j < n; ++j) {\n            dp[i][j] = Infinity;\n            for (let k = 0; k < n; ++k) {\n                if (ring[k] === key[i]) {\n                    const diff = Math.abs(j - k);\n                    const step = Math.min(diff, n - diff);\n                    dp[i][j] = Math.min(dp[i][j], step + dp[i + 1][k]);\n                }\n            }\n        }\n    }\n\n    return dp[0][0] + m;\n}\n"
        }
    },
    "515": {
        "title": "Largest Value in Each Row",
        "description": "Given the `root` of a binary tree, return an array of the largest value in each row of the tree (0-indexed).",
        "example": "Example 1:\n\nInput: root = [1,3,2,5,3,null,9]\nOutput: [1,3,9]\n\nExample 2:\n\nInput: root = [1,2,3]\nOutput: [1,3]",
        "level": "Easy",
        "tags": [
            "binary tree",
            "tree traversal",
            "level order traversal"
        ],
        "test_cases": {
            "inputs": [
                "[1,3,2,5,3,null,9]",
                [
                    1,
                    2,
                    3
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1
                ],
                [],
                "[1,2,null,3,null,4,null,5]",
                "[1,null,2,null,3,null,4,null,5]",
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15
                ],
                [
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ]
            ],
            "outputs": [
                "[1,3,9]",
                "[1,3]",
                "[5,4,3,2,1]",
                "[1]",
                "[]",
                "[1,2,3,4,5]",
                "[1,2,3,4,5]",
                "[1,3,7,15]",
                "[15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n};\n\nvector<int> largestValues(TreeNode* root) {\n    if (!root) return {};\n    vector<int> result;\n    queue<TreeNode*> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        int size = q.size();\n        int max_val = INT_MIN;\n        for (int i = 0; i < size; ++i) {\n            TreeNode* node = q.front();\n            q.pop();\n            max_val = max(max_val, node->val);\n\n            if (node->left) q.push(node->left);\n            if (node->right) q.push(node->right);\n        }\n        result.push_back(max_val);\n    }\n    return result;\n}\n",
            "java": "import java.util.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic List<Integer> largestValues(TreeNode root) {\n    if (root == null) return new ArrayList<>();\n    List<Integer> result = new ArrayList<>();\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        int max_val = Integer.MIN_VALUE;\n        for (int i = 0; i < size; i++) {\n            TreeNode node = queue.poll();\n            max_val = Math.max(max_val, node.val);\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n        result.add(max_val);\n    }\n    return result;\n}\n",
            "python": "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef largestValues(root: TreeNode):\n    if not root:\n        return []\n    result = []\n    queue = deque([root])\n\n    while queue:\n        size = len(queue)\n        max_val = float('-inf')\n        for _ in range(size):\n            node = queue.popleft()\n            max_val = max(max_val, node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        result.append(max_val)\n\n    return result\n",
            "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction largestValues(root) {\n    if (!root) return [];\n    const result = [];\n    const queue = [root];\n\n    while (queue.length) {\n        const size = queue.length;\n        let maxVal = Number.MIN_SAFE_INTEGER;\n        for (let i = 0; i < size; i++) {\n            const node = queue.shift();\n            maxVal = Math.max(maxVal, node.val);\n\n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n        result.push(maxVal);\n    }\n    return result;\n}\n",
            "explanation": "The algorithm we used here is Breadth-First Search (BFS) traversal. We use a queue to store the nodes in each level of the tree. After we process all the nodes in the current level, we update the maxVal with the maximum element value found in that level and add it to the result array. We repeat this process until the queue is empty, which means we have processed all the nodes in the binary tree. The time and space complexity of this algorithm is O(N), where N is the number of nodes in the tree."
        },
        "structure": {
            "c++": "#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct TreeNode \n    // Your code here\n}\n",
            "java": "import java.util.*;\n\nclass TreeNode \n    // Your code here\n}\n",
            "python": "from collections import deque\n    # Your code here\n\n",
            "javascript": "class TreeNode \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<int> largestValues(TreeNode* root) {\n    if (!root) return {};\n    vector<int> result;\n    queue<TreeNode*> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        int size = q.size();\n        int max_val = INT_MIN;\n        for (int i = 0; i < size; ++i) {\n            TreeNode* node = q.front();\n            q.pop();\n            max_val = max(max_val, node->val);\n\n            if (node->left) q.push(node->left);\n            if (node->right) q.push(node->right);\n        }\n        result.push_back(max_val);\n    }\n    return result;\n}\n\nint main() {\n    TreeNode* root = $args;\n    vector<int> result = largestValues(root);\n    for (int i = 0; i < result.size(); ++i) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "java": "public List<Integer> largestValues(TreeNode root) {\n    if (root == null) return new ArrayList<>();\n    List<Integer> result = new ArrayList<>();\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        int max_val = Integer.MIN_VALUE;\n        for (int i = 0; i < size; i++) {\n            TreeNode node = queue.poll();\n            max_val = Math.max(max_val, node.val);\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n        result.add(max_val);\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    root = $args[0]\n    result = largestValues(root)\n    print(result)",
            "javascript": "function largestValues(root) {\n    if (!root) return [];\n    const result = [];\n    const queue = [root];\n\n    while (queue.length) {\n        const size = queue.length;\n        let maxVal = Number.MIN_SAFE_INTEGER;\n        for (let i = 0; i < size; i++) {\n            const node = queue.shift();\n            maxVal = Math.max(maxVal, node.val);\n\n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n        result.push(maxVal);\n    }\n    return result;\n}"
        }
    },
    "518": {
        "title": "Coin Combinations",
        "description": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money. Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0. You may assume that you have an infinite number of each kind of coin. The answer is guaranteed to fit into a signed 32-bit integer.",
        "example": "Example 1:\n\nInput: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: There are four ways to make up the amount:\n5 = 5\n5 = 2 + 2 + 1\n5 = 2 + 1 + 1 + 1\n5 = 1 + 1 + 1 + 1 + 1\n\nExample 2:\n\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: The amount of 3 cannot be made up just with coins of 2.\n\nExample 3:\n\nInput: amount = 10, coins = [10]\nOutput: 1",
        "level": "Medium",
        "tags": [
            "dynamic programming",
            "coin change"
        ],
        "test_cases": {
            "inputs": [
                [
                    5,
                    [
                        1,
                        2,
                        5
                    ]
                ],
                [
                    3,
                    [
                        2
                    ]
                ],
                [
                    10,
                    [
                        10
                    ]
                ],
                [
                    0,
                    [
                        1,
                        2,
                        3
                    ]
                ],
                [
                    7,
                    [
                        2,
                        3,
                        5
                    ]
                ],
                [
                    12,
                    [
                        1,
                        2,
                        5
                    ]
                ],
                [
                    15,
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ]
                ],
                [
                    20,
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        10
                    ]
                ],
                [
                    25,
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        10,
                        20
                    ]
                ],
                [
                    30,
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        10,
                        20,
                        25
                    ]
                ],
                [
                    50,
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        10,
                        20,
                        25,
                        30
                    ]
                ],
                [
                    100,
                    [
                        1,
                        2,
                        5,
                        10,
                        20,
                        25,
                        50
                    ]
                ],
                [
                    200,
                    [
                        1,
                        2,
                        5,
                        10,
                        20,
                        25,
                        50,
                        100
                    ]
                ],
                [
                    500,
                    [
                        1,
                        2,
                        5,
                        10,
                        20,
                        25,
                        50,
                        100,
                        200
                    ]
                ],
                [
                    1000,
                    [
                        1,
                        2,
                        5,
                        10,
                        20,
                        25,
                        50,
                        100,
                        200,
                        500
                    ]
                ],
                [
                    2000,
                    [
                        1,
                        2,
                        5,
                        10,
                        20,
                        25,
                        50,
                        100,
                        200,
                        500,
                        1000
                    ]
                ],
                [
                    5000,
                    [
                        1,
                        2,
                        5,
                        10,
                        20,
                        25,
                        50,
                        100,
                        200,
                        500,
                        1000,
                        2000
                    ]
                ],
                [
                    10000,
                    [
                        1,
                        2,
                        5,
                        10,
                        20,
                        25,
                        50,
                        100,
                        200,
                        500,
                        1000,
                        2000,
                        5000
                    ]
                ],
                [
                    20000,
                    [
                        1,
                        2,
                        5,
                        10,
                        20,
                        25,
                        50,
                        100,
                        200,
                        500,
                        1000,
                        2000,
                        5000,
                        10000
                    ]
                ],
                [
                    30000,
                    [
                        1,
                        2,
                        5,
                        10,
                        20,
                        25,
                        50,
                        100,
                        200,
                        500,
                        1000,
                        2000,
                        5000,
                        10000,
                        20000
                    ]
                ],
                [
                    40000,
                    [
                        1,
                        2,
                        5,
                        10,
                        20,
                        25,
                        50,
                        100,
                        200,
                        500,
                        1000,
                        2000,
                        5000,
                        10000,
                        20000,
                        30000
                    ]
                ]
            ],
            "outputs": [
                4,
                0,
                1,
                0,
                5,
                13,
                24,
                61,
                242,
                560,
                1423,
                4563,
                117121,
                73682,
                127036,
                73682,
                127036,
                73682,
                127036,
                73682
            ]
        },
        "sample_code": {
            "c++": "int change(int amount, vector<int>& coins) {\n    vector<int> dp(amount + 1, 0);\n    dp[0] = 1;\n    for (int coin : coins) {\n        for (int i = coin; i <= amount; i++) {\n            dp[i] += dp[i - coin];\n        }\n    }\n    return dp[amount];\n}\n",
            "java": "public int change(int amount, int[] coins) {\n    int[] dp = new int[amount + 1];\n    dp[0] = 1;\n    for (int coin : coins) {\n        for (int i = coin; i <= amount; i++) {\n            dp[i] += dp[i - coin];\n        }\n    }\n    return dp[amount];\n}\n",
            "python": "def change(amount, coins):\n    dp = [1] + [0] * amount\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] += dp[i - coin]\n    return dp[amount]\n",
            "javascript": "function change(amount, coins) {\n    let dp = new Array(amount + 1).fill(0);\n    dp[0] = 1;\n    for (let coin of coins) {\n        for (let i = coin; i <= amount; i++) {\n            dp[i] += dp[i - coin];\n        }\n    }\n    return dp[amount];\n}\n",
            "explanation": "1. Initialize an array `dp` where `dp[i]` represents the number of combinations that make up the amount `i`. The length of the array is `amount + 1` to accommodate index 0. Set `dp[0]` to 1 as there is only one way to make up the amount 0 (by not picking any coins).\n2. Loop through each coin in the `coins` array.\n3. For each coin, iterate through the `dp` array, starting at the index equal to the coin value.\n4. In each iteration, increment the value of `dp[i]` by `dp[i - coin]`. This is because the number of combinations that can make up `i` is increased by the number of combinations that can make up `i - coin`.\n5. After iterating through all the coins and updating the `dp` array, return the value of `dp[amount]`, which represents the number of combinations that can make up the desired amount."
        },
        "structure": {
            "c++": "int change(int amount, vector<int>& coins) \n    // Your code here\n}\n",
            "java": "public int change(int amount, int[] coins) \n    // Your code here\n}\n",
            "python": "def change(amount, coins):\n    # Your code here\n\n",
            "javascript": "function change(amount, coins) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int amount = $args;\n    vector<int> coins = {1, 2, 5};\n    int result = change(amount, coins);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int change(int amount, int[] coins) {\n    int[] dp = new int[amount + 1];\n    dp[0] = 1;\n    for (int coin : coins) {\n        for (int i = coin; i <= amount; i++) {\n            dp[i] += dp[i - coin];\n        }\n    }\n    return dp[amount];\n}",
            "python": "if __name__ == \"__main__\":\n    amount = $args[0]\n    coins = $args[1]\n    result = change(amount, coins)\n    print(result)",
            "javascript": "function main() {\n    const amount = $args[0];\n    const coins = $args[1];\n    const result = change(amount, coins);\n    console.log(result);\n}"
        }
    },
    "519": {
        "title": "Random Binary Matrix Flip",
        "description": "You are given an `m x n` binary grid `matrix` with all values initially set to `0`. Design an algorithm to randomly pick an index `(i, j)` where `matrix[i][j] == 0` and flips it to `1`. All the indices `(i, j)` where `matrix[i][j] == 0` should be equally likely to be returned.\n\nImplement the `Solution` class with the following methods:\n\n- `Solution(int m, int n)`: Initializes the object with the size of the binary matrix `m` and `n`.\n- `int[] flip()`: Returns a random index `[i, j]` of the matrix where `matrix[i][j] == 0` and flips it to `1`.\n- `void reset()`: Resets all the values of the matrix to be `0`.",
        "example": "Example:\n\nInput\n[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"]\n[[3, 1], [], [], [], [], []]\nOutput\n[null, [1, 0], [2, 0], [0, 0], null, [2, 0]]\n\nExplanation\nSolution solution = new Solution(3, 1);\nsolution.flip();  // return [1, 0], [0,0], [1,0], and [2,0] should be equally likely to be returned.\nsolution.flip();  // return [2, 0], Since [1,0] was returned, [2,0] and [0,0]\nsolution.flip();  // return [0, 0], Based on the previously returned indices, only [0,0] can be returned.\nsolution.reset(); // All the values are reset to 0 and can be returned.\nsolution.flip();  // return [2, 0], [0,0], [1,0], and [2,0] should be equally likely to be returned.",
        "level": "Medium",
        "tags": [
            "Array",
            "Randomized Algorithm"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        2,
                        2
                    ]
                ],
                [
                    [
                        3,
                        3
                    ]
                ],
                [
                    [
                        4,
                        4
                    ]
                ],
                [
                    [
                        5,
                        5
                    ]
                ],
                [
                    [
                        2,
                        3
                    ]
                ],
                [
                    [
                        3,
                        2
                    ]
                ],
                [
                    [
                        4,
                        5
                    ]
                ],
                [
                    [
                        5,
                        4
                    ]
                ],
                [
                    [
                        10,
                        10
                    ]
                ],
                [
                    [
                        100,
                        100
                    ]
                ],
                [
                    [
                        1000,
                        1000
                    ]
                ],
                [
                    [
                        10000,
                        10000
                    ]
                ],
                [
                    [
                        100,
                        1000
                    ]
                ],
                [
                    [
                        1000,
                        100
                    ]
                ],
                [
                    [
                        100,
                        10000
                    ]
                ],
                [
                    [
                        10000,
                        100
                    ]
                ],
                [
                    [
                        1000,
                        1000
                    ],
                    [
                        100,
                        100
                    ],
                    [
                        10,
                        10
                    ]
                ],
                [
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ]
                ],
                [
                    [
                        10,
                        10
                    ],
                    [
                        100,
                        100
                    ],
                    [
                        1000,
                        1000
                    ],
                    [
                        10000,
                        10000
                    ]
                ],
                [
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        2
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        4
                    ]
                ]
            ],
            "outputs": [
                "[[0, 0], [0, 1], [1, 0], [1, 1]]",
                "[[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]",
                "[[0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 1], [1, 2], [1, 3], [2, 0], [2, 1], [2, 2], [2, 3], [3, 0], [3, 1], [3, 2], [3, 3]]",
                "[[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [1, 0], [1, 1], [1, 2], [1, 3], [1, 4], [2, 0], [2, 1], [2, 2], [2, 3], [2, 4], [3, 0], [3, 1], [3, 2], [3, 3], [3, 4], [4, 0], [4, 1], [4, 2], [4, 3], [4, 4]]",
                "[[0, 0], [0, 1], [1, 0], [1, 1], [0, 2], [1, 2]]",
                "[[0, 0], [0, 1], [1, 0], [1, 1], [2, 0], [2, 1]]",
                "[[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [1, 0], [1, 1], [1, 2], [1, 3], [1, 4], [2, 0], [2, 1], [2, 2], [2, 3], [2, 4], [3, 0], [3, 1], [3, 2], [3, 3], [3, 4], [4, 0], [4, 1], [4, 2], [4, 3], [4, 4]]",
                "[[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [1, 0], [1, 1], [1, 2], [1, 3], [1, 4], [2, 0], [2, 1], [2, 2], [2, 3], [2, 4], [3, 0], [3, 1], [3, 2], [3, 3], [3, 4], [4, 0], [4, 1], [4, 2], [4, 3], [4, 4]]",
                "[[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], [0, 8], [0, 9], [1, 0], [1, 1], [1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [1, 7], [1, 8], [1, 9], [2, 0], [2, 1], [2, 2], [2, 3], [2, 4], [2, 5], [2, 6], [2, 7], [2, 8], [2, 9], [3, 0], [3, 1], [3, 2], [3, 3], [3, 4], [3, 5], [3, 6], [3, 7], [3, 8], [3, 9], [4, 0], [4, 1], [4, 2], [4, 3], [4, 4], [4, 5], [4, 6], [4, 7], [4, 8], [4, 9], [5, 0], [5, 1], [5, 2], [5, 3], [5, 4], [5, 5], [5, 6], [5, 7], [5, 8], [5, 9], [6, 0], [6, 1], [6, 2], [6, 3], [6, 4], [6, 5], [6, 6], [6, 7], [6, 8], [6, 9], [7, 0], [7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [7, 6], [7, 7], [7, 8], [7, 9], [8, 0], [8, 1], [8, 2], [8, 3], [8, 4], [8, 5], [8, 6], [8, 7], [8, 8], [8, 9], [9, 0], [9, 1], [9, 2], [9, 3], [9, 4], [9, 5], [9, 6], [9, 7], [9, 8], [9, 9]]",
                "[[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], [0, 8], [0, 9], [1, 0], [1, 1], [1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [1, 7], [1, 8], [1, 9], [2, 0], [2, 1], [2, 2], [2, 3], [2, 4], [2, 5], [2, 6], [2, 7], [2, 8], [2, 9], [3, 0], [3, 1], [3, 2], [3, 3], [3, 4], [3, 5], [3, 6], [3, 7], [3, 8], [3, 9], [4, 0], [4, 1], [4, 2], [4, 3], [4, 4], [4, 5], [4, 6], [4, 7], [4, 8], [4, 9], [5, 0], [5, 1], [5, 2], [5, 3], [5, 4], [5, 5], [5, 6], [5, 7], [5, 8], [5, 9], [6, 0], [6, 1], [6, 2], [6, 3], [6, 4], [6, 5], [6, 6], [6, 7], [6, 8], [6, 9], [7, 0], [7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [7, 6], [7, 7], [7, 8], [7, 9], [8, 0], [8, 1], [8, 2], [8, 3], [8, 4], [8, 5], [8, 6], [8, 7], [8, 8], [8, 9], [9, 0], [9, 1], [9, 2], [9, 3], [9, 4], [9, 5], [9, 6], [9, 7], [9, 8], [9, 9]]",
                "[[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], [0, 8], [0, 9], [1, 0], [1, 1], [1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [1, 7], [1, 8], [1, 9], [2, 0], [2, 1], [2, 2], [2, 3], [2, 4], [2, 5], [2, 6], [2, 7], [2, 8], [2, 9], [3, 0], [3, 1], [3, 2], [3, 3], [3, 4], [3, 5], [3, 6], [3, 7], [3, 8], [3, 9], [4, 0], [4, 1], [4, 2], [4, 3], [4, 4], [4, 5], [4, 6], [4, 7], [4, 8], [4, 9], [5, 0], [5, 1], [5, 2], [5, 3], [5, 4], [5, 5], [5, 6], [5, 7], [5, 8], [5, 9], [6, 0], [6, 1], [6, 2], [6, 3], [6, 4], [6, 5], [6, 6], [6, 7], [6, 8], [6, 9], [7, 0], [7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [7, 6], [7, 7], [7, 8], [7, 9], [8, 0], [8, 1], [8, 2], [8, 3], [8, 4], [8, 5], [8, 6], [8, 7], [8, 8], [8, 9], [9, 0], [9, 1], [9, 2], [9, 3], [9, 4], [9, 5], [9, 6], [9, 7], [9, 8], [9, 9]]",
                "[[0, 0], [0, 1], [1, 0], [1, 1], [0, 2], [1, 2], [0, 3], [1, 3], [0, 4], [1, 4]]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <random>\n\nclass Solution {\n    int rows, cols;\n    int total;\n    std::vector<std::vector<int>> matrix;\n\npublic:\n    Solution(int m, int n) : rows(m), cols(n), total(m * n) {\n        matrix = std::vector<std::vector<int>>(m, std::vector<int>(n, 0));\n    }\n\n    std::vector<int> flip() {\n        int idx = rand() % total;\n        total--;\n\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                if (matrix[i][j] == 0) {\n                    if (idx == 0) {\n                        matrix[i][j] = 1;\n                        return {i, j};\n                    }\n                    idx--;\n                }\n            }\n        }\n        return {-1, -1}; // This line should never be reached\n    }\n\n    void reset() {\n        total = rows * cols;\n        for (auto &row : matrix) {\n            std::fill(row.begin(), row.end(), 0);\n        }\n    }\n};\n\n",
            "java": "import java.util.Random;\n\nclass Solution {\n    int m, n, total;\n    int[][] matrix;\n    Random random;\n\n    public Solution(int m, int n) {\n        this.m = m;\n        this.n = n;\n        total = m * n;\n        matrix = new int[m][n];\n        random = new Random();\n    }\n\n    public int[] flip() {\n        int idx = random.nextInt(total);\n        total--;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == 0) {\n                    if (idx == 0) {\n                        matrix[i][j] = 1;\n                        return new int[] { i, j };\n                    }\n                    idx--;\n                }\n            }\n        }\n        return new int[] { -1, -1 }; // This line should never be reached\n    }\n\n    public void reset() {\n        total = m * n;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n}\n\n",
            "python": "import random\n\nclass Solution:\n    def __init__(self, m: int, n: int):\n        self.m, self.n = m, n\n        self.total = m * n\n        self.matrix = [[0] * n for _ in range(m)]\n\n    def flip(self):\n        idx = random.randint(0, self.total - 1)\n        self.total -= 1\n\n        for i in range(self.m):\n            for j in range(self.n):\n                if self.matrix[i][j] == 0:\n                    if idx == 0:\n                        self.matrix[i][j] = 1\n                        return [i, j]\n                    idx -= 1\n        return [-1, -1] # This line should never be reached\n\n    def reset(self):\n        self.total = self.m * self.n\n        for row in self.matrix:\n            for j in range(self.n):\n                row[j] = 0\n\n",
            "javascript": "class Solution {\n    constructor(m, n) {\n        this.m = m;\n        this.n = n;\n        this.total = m * n;\n        this.matrix = Array.from({ length: m }, () => new Array(n).fill(0));\n    }\n\n    flip() {\n        const idx = Math.floor(Math.random() * this.total);\n        this.total--;\n\n        for (let i = 0; i < this.m; i++) {\n            for (let j = 0; j < this.n; j++) {\n                if (this.matrix[i][j] === 0) {\n                    if (idx === 0) {\n                        this.matrix[i][j] = 1;\n                        return [i, j];\n                    }\n                    idx--;\n                }\n            }\n        }\n        return [-1, -1]; // This line should never be reached\n    }\n\n    reset() {\n        this.total = this.m * this.n;\n        for (let i = 0; i < this.m; i++) {\n            for (let j = 0; j < this.n; j++) {\n                this.matrix[i][j] = 0;\n            }\n        }\n    }\n}\n\n",
            "explanation": "1. Matrix is initialized with m and n, and a counter is initialized to keep track of the remaining number of 0's\n2. When the flip function is called, a random index in the range of 0 to the remaining number of 0's is generated. Then, the matrix is iterated through to find the element corresponding to the random index.\n3. In the flip function, for each cell with a 0, the random index is decremented. When the random index reaches 0, the cell is flipped to 1 and its position is returned.\n4. Reset function resets the counter and sets all elements in the matrix back to 0.\n\nThis algorithm allows for equal probability of selecting any cell with a 0 while minimizing the number of calls to the built-in random function. The randomized selection ensures an equal chance for each candidate, and cells are only visited once. The reset function is O(m * n), but it is unlikely to be an issue in practice given the constraints."
        },
        "structure": {
            "c++": "#include <vector>\n#include <random>\n\nclass Solution \n    // Your code here\n};\n\n",
            "java": "import java.util.Random;\n\nclass Solution \n    // Your code here\n}\n\n",
            "python": "import random\n    # Your code here\n\n",
            "javascript": "class Solution \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int m = $args;\n    int n = $args;\n    Solution obj(m, n);\n    vector<int> result = obj.flip();\n    cout << '[' << result[0] << ',' << result[1] << ']';\n    return 0;\n}",
            "java": "public int[] flip() {\n        int idx = random.nextInt(total);\n        total--;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == 0) {\n                    if (idx == 0) {\n                        matrix[i][j] = 1;\n                        return new int[] { i, j };\n                    }\n                    idx--;\n                }\n            }\n        }\n        return new int[] { -1, -1 }; // This line should never be reached\n    }",
            "python": "if __name__ == \"__main__\":\n    m = $args[0]\n    n = $args[1]\n    obj = Solution(m, n)\n    result_flip = obj.flip()\n    result_reset = obj.reset()\n    print(result_flip)\n    print(result_reset)",
            "javascript": "function main() {\n    const m = $args[0];\n    const n = $args[1];\n    const obj = new Solution(m, n);\n    const result1 = obj.flip();\n    const result2 = obj.flip();\n    obj.reset();\n    const result3 = obj.flip();\n    console.log(result1);\n    console.log(result2);\n    console.log(result3);\n}"
        }
    },
    "521": {
        "title": "Longest Uncommon Subsequence Length",
        "description": "Given two strings `a` and `b`, return the length of the longest uncommon subsequence between `a` and `b`. If the longest uncommon subsequence does not exist, return -1.\n\nAn uncommon subsequence between two strings is a string that is a subsequence of one but not the other.\n\nA subsequence of a string `s` is a string that can be obtained after deleting any number of characters from `s`.\n\nFor example, \"abc\" is a subsequence of \"aebdc\" because you can delete the underlined characters in \"aebdc\" to get \"abc\". Other subsequences of \"aebdc\" include \"aebdc\", \"aeb\", and \"\" (empty string).",
        "example": "Example:\n\nInput: a = \"aba\", b = \"cdc\"\nOutput: 3\nExplanation: One longest uncommon subsequence is \"aba\" because \"aba\" is a subsequence of \"aba\" but not \"cdc\". Note that \"cdc\" is also a longest uncommon subsequence.",
        "level": "Easy",
        "tags": [
            "string",
            "subsequence"
        ],
        "test_cases": {
            "inputs": [
                [
                    "aba",
                    "cdc"
                ],
                [
                    "aaa",
                    "bbb"
                ],
                [
                    "aaa",
                    "aaa"
                ],
                [
                    "abc",
                    "def"
                ],
                [
                    "abc",
                    "ab"
                ],
                [
                    "",
                    ""
                ],
                [
                    "",
                    "abc"
                ],
                [
                    "abc",
                    ""
                ],
                [
                    "a",
                    "a"
                ],
                [
                    "a",
                    "b"
                ],
                [
                    "a",
                    ""
                ],
                [
                    "",
                    "a"
                ],
                [
                    "abcde",
                    "abcde"
                ],
                [
                    "abcde",
                    "abc"
                ],
                [
                    "abcde",
                    "de"
                ],
                [
                    "abcde",
                    "cde"
                ],
                [
                    "abcde",
                    "abcd"
                ],
                [
                    "abcde",
                    "bcde"
                ],
                [
                    "abcde",
                    "abde"
                ],
                [
                    "abcde",
                    "acde"
                ]
            ],
            "outputs": [
                3,
                3,
                -1,
                3,
                3,
                -1,
                3,
                3,
                0,
                1,
                1,
                1,
                -1,
                5,
                2,
                2,
                5,
                4,
                4,
                4
            ]
        },
        "sample_code": {
            "c++": "int findLUSlength(string a, string b) {\n    if (a == b) {\n        return -1;\n    }\n    return max(a.length(), b.length());\n}\n",
            "java": "public int findLUSlength(String a, String b) {\n    if (a.equals(b)) {\n        return -1;\n    }\n    return Math.max(a.length(), b.length());\n}\n",
            "python": "def findLUSlength(a: str, b: str) -> int:\n    if a == b:\n        return -1\n    return max(len(a), len(b))\n",
            "javascript": "function findLUSlength(a, b) {\n    if (a === b) {\n        return -1;\n    }\n    return Math.max(a.length, b.length);\n}\n",
            "explanation": "The algorithm is as follows:\n1. First, we compare if the strings a and b are equal. If they are equal, it means that there is no uncommon subsequence between them, so we return -1.\n2. If the strings are not equal, then we find the length of both strings and return the one with the maximum length. This is because the longest uncommon subsequence can be the longer of the two strings itself (since it is not a subsequence of the other string)."
        },
        "structure": {
            "c++": "int findLUSlength(string a, string b) \n    // Your code here\n}\n",
            "java": "public int findLUSlength(String a, String b) \n    // Your code here\n}\n",
            "python": "def findLUSlength(a: str, b: str) -> int:\n    # Your code here\n\n",
            "javascript": "function findLUSlength(a, b) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    string a = $args[0];\n    string b = $args[1];\n    int result = findLUSlength(a, b);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int findLUSlength(String a, String b) {\n    if (a.equals(b)) {\n        return -1;\n    }\n    return Math.max(a.length(), b.length());\n}",
            "python": "if __name__ == \"__main__\":\n    a = $args[0]\n    b = $args[1]\n    result = findLUSlength(a, b)\n    print(result)",
            "javascript": "function main() {\n    const a = $args[0];\n    const b = $args[1];\n    const result = findLUSlength(a, b);\n    console.log(result);\n}"
        }
    },
    "522": {
        "title": "Longest Uncommon Subsequence",
        "description": "Given an array of strings `strs`, return the length of the longest uncommon subsequence between them. An uncommon subsequence is a string that is a subsequence of one string but not the others. A subsequence of a string `s` is a string that can be obtained after deleting any number of characters from `s`.",
        "example": "Example:\n\nInput: strs = [\"aba\",\"cdc\",\"eae\"]\nOutput: 3\n\nExplanation: The longest uncommon subsequence is \"aba\" which is a subsequence of the first string but not the others.\n\nInput: strs = [\"aaa\",\"aaa\",\"aa\"]\nOutput: -1\n\nExplanation: There is no uncommon subsequence among the strings.",
        "level": "Easy",
        "tags": [
            "array",
            "string"
        ],
        "test_cases": {
            "inputs": [
                [
                    "aba",
                    "cdc",
                    "eae"
                ],
                [
                    "aaa",
                    "aaa",
                    "aa"
                ],
                [
                    "abc",
                    "def",
                    "ghi"
                ],
                [
                    "abc",
                    "abc",
                    "abc"
                ],
                [
                    "abc",
                    "def",
                    "abc"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl",
                    "mno"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz"
                ],
                [
                    "a",
                    "b"
                ],
                [
                    "a",
                    "a"
                ],
                [
                    "a",
                    "b",
                    "c"
                ],
                [
                    "a",
                    "a",
                    "a"
                ],
                [
                    "a",
                    "b",
                    "a"
                ],
                [
                    "a",
                    "b",
                    "c",
                    "d"
                ],
                [
                    "a",
                    "b",
                    "c",
                    "d",
                    "e"
                ],
                [
                    "a",
                    "b",
                    "c",
                    "d",
                    "e",
                    "f"
                ],
                [
                    "a",
                    "b",
                    "c",
                    "d",
                    "e",
                    "f",
                    "g"
                ],
                [
                    "a",
                    "b",
                    "c",
                    "d",
                    "e",
                    "f",
                    "g",
                    "h"
                ]
            ],
            "outputs": [
                "3",
                "-1",
                "3",
                "-1",
                "3",
                "3",
                "3",
                "3",
                "3",
                "3",
                "3",
                "1",
                "-1",
                "1",
                "-1",
                "1",
                "1",
                "1",
                "1",
                "1",
                "1",
                "1"
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <vector>\n#include <algorithm>\n\nint findLUSlength(std::vector<std::string>& strs) {\n    int maxLength = -1;\n    for(int i = 0; i < strs.size(); ++i) {\n        bool isUncommon = true;\n        for(int j = 0; j < strs.size(); ++j) {\n            if(i != j && std::search(strs[j].begin(), strs[j].end(), strs[i].begin(), strs[i].end()) != strs[j].end()) {\n                isUncommon = false;\n                break;\n            }\n        }\n        if(isUncommon) {\n            maxLength = std::max(maxLength, static_cast<int>(strs[i].length()));\n        }\n    }\n    return maxLength;\n}\n\n",
            "java": "import java.util.List;\n\npublic int findLUSlength(List<String> strs) {\n    int maxLength = -1;\n    for(int i = 0; i < strs.size(); ++i) {\n        boolean isUncommon = true;\n        for(int j = 0; j < strs.size(); ++j) {\n            if(i != j && strs.get(j).contains(strs.get(i))) {\n                isUncommon = false;\n                break;\n            }\n        }\n        if(isUncommon) {\n            maxLength = Math.max(maxLength, strs.get(i).length());\n        }\n    }\n    return maxLength;\n}\n\n",
            "python": "def find_lus_length(strs):\n    max_length = -1\n    for i in range(len(strs)):\n        is_uncommon = True\n        for j in range(len(strs)):\n            if i != j and strs[i] in strs[j]:\n                is_uncommon = False\n                break\n        if is_uncommon:\n            max_length = max(max_length, len(strs[i]))\n    return max_length\n\n",
            "javascript": "function findLUSlength(strs) {\n    let maxLength = -1;\n    for(let i = 0; i < strs.length; ++i) {\n        let isUncommon = true;\n        for(let j = 0; j < strs.length; ++j) {\n            if(i != j && strs[j].includes(strs[i])) {\n                isUncommon = false;\n                break;\n            }\n        }\n        if(isUncommon) {\n            maxLength = Math.max(maxLength, strs[i].length);\n        }\n    }\n    return maxLength;\n}\n\n",
            "explanation": "The algorithm first initializes a variable `maxLength` which will store the maximum length of the uncommon subsequence. Then it iterates through the input array of strings. For each string, it checks if it is an uncommon subsequence among the array elements. This check is done by iterating through the input array again, comparing the current string with all other strings in the array. If it's found that the current string is a subsequence of another string in the array, the current string cannot be the uncommon subsequence. If the current string is uncommon, its length is compared to the current value of `maxLength` and the maximum value is stored in `maxLength`. Finally, the `maxLength` will contain the length of the longest uncommon subsequence, or -1 if such a subsequence does not exist."
        },
        "structure": {
            "c++": "#include <string>\n#include <vector>\n#include <algorithm>\n\nint findLUSlength(std::vector<std::string>& strs) \n    // Your code here\n}\n\n",
            "java": "import java.util.List;\n\npublic int findLUSlength(List<String> strs) \n    // Your code here\n}\n\n",
            "python": "def find_lus_length(strs):\n    # Your code here\n\n",
            "javascript": "function findLUSlength(strs) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\nint main() {\n    std::vector<std::string> strs = $args;\n    int result = findLUSlength(strs);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public int findLUSlength(List<String> strs) {\n    int maxLength = -1;\n    for(int i = 0; i < strs.size(); ++i) {\n        boolean isUncommon = true;\n        for(int j = 0; j < strs.size(); ++j) {\n            if(i != j && strs.get(j).contains(strs.get(i))) {\n                isUncommon = false;\n                break;\n            }\n        }\n        if(isUncommon) {\n            maxLength = Math.max(maxLength, strs.get(i).length());\n        }\n    }\n    return maxLength;\n}",
            "python": "if __name__ == \"__main__\":\n    strs = $args[0]\n    result = find_lus_length(strs)\n    print(result)",
            "javascript": "function main() {\n    const strs = $args;\n    const result = findLUSlength(strs);\n    console.log(result);\n}"
        }
    },
    "523": {
        "title": "Good Subarray",
        "description": "Given an integer array `nums` and an integer `k`, return `true` if `nums` has a good subarray or `false` otherwise.\n\nA good subarray is a subarray where:\n\n- Its length is at least two, and\n- The sum of the elements of the subarray is a multiple of `k`.\n\nNote that:\n\n- A subarray is a contiguous part of the array.\n- An integer `x` is a multiple of `k` if there exists an integer `n` such that `x = n * k`. `0` is always a multiple of `k`.",
        "example": "Example 1:\n\nInput: nums = [23,2,4,6,7], k = 6\nOutput: true\nExplanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.\n\nExample 2:\n\nInput: nums = [23,2,6,4,7], k = 6\nOutput: true\nExplanation: [23, 2, 6, 4, 7] is a continuous subarray of size 5 whose elements sum up to 42. 42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.\n\nExample 3:\n\nInput: nums = [23,2,6,4,7], k = 13\nOutput: false",
        "level": "Medium",
        "tags": [
            "array",
            "subarray",
            "math"
        ],
        "test_cases": {
            "inputs": [
                [
                    23,
                    2,
                    4,
                    6,
                    7
                ],
                [
                    23,
                    2,
                    6,
                    4,
                    7
                ],
                [
                    23,
                    2,
                    6,
                    4,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50
                ],
                [
                    100,
                    200,
                    300,
                    400,
                    500
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100,
                    110,
                    120,
                    130,
                    140,
                    150,
                    160,
                    170,
                    180,
                    190,
                    200
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100,
                    110,
                    120,
                    130,
                    140,
                    150,
                    160,
                    170,
                    180,
                    190,
                    200,
                    210,
                    220,
                    230,
                    240,
                    250,
                    260,
                    270,
                    280,
                    290,
                    300
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100,
                    110,
                    120,
                    130,
                    140,
                    150,
                    160,
                    170,
                    180,
                    190,
                    200,
                    210,
                    220,
                    230,
                    240,
                    250,
                    260,
                    270,
                    280,
                    290,
                    300,
                    310,
                    320,
                    330,
                    340,
                    350,
                    360,
                    370,
                    380,
                    390,
                    400
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100,
                    110,
                    120,
                    130,
                    140,
                    150,
                    160,
                    170,
                    180,
                    190,
                    200,
                    210,
                    220,
                    230,
                    240,
                    250,
                    260,
                    270,
                    280,
                    290,
                    300,
                    310,
                    320,
                    330,
                    340,
                    350,
                    360,
                    370,
                    380,
                    390,
                    400,
                    410,
                    420,
                    430,
                    440,
                    450,
                    460,
                    470,
                    480,
                    490,
                    500
                ]
            ],
            "outputs": [
                true,
                true,
                true,
                false,
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <unordered_map>\n\nbool checkSubarraySum(std::vector<int>& nums, int k) {\n    int n = nums.size(), sum = 0;\n    std::unordered_map<int, int> mp;\n    mp[0] = -1;\n    for (int i = 0; i < n; ++i) {\n        sum += nums[i];\n        if (k != 0) sum %= k;\n        if (mp.count(sum)) {\n            if (i - mp[sum] > 1) return true;\n        } else {\n            mp[sum] = i;\n        }\n    }\n    return false;\n}\n",
            "java": "import java.util.HashMap;\n\npublic boolean checkSubarraySum(int[] nums, int k) {\n    int n = nums.length, sum = 0;\n    HashMap<Integer, Integer> map = new HashMap<>();\n    map.put(0, -1);\n    for (int i = 0; i < n; i++) {\n        sum += nums[i];\n        if (k != 0) sum %= k;\n        if (map.containsKey(sum)) {\n            if (i - map.get(sum) > 1) return true;\n        } else {\n            map.put(sum, i);\n        }\n    }\n    return false;\n}\n",
            "python": "def checkSubarraySum(nums, k):\n    n, sum_ = len(nums), 0\n    mp = {0: -1}\n    for i, num in enumerate(nums):\n        sum_ += num\n        if k != 0:\n            sum_ %= k\n        if sum_ in mp:\n            if i - mp[sum_] > 1:\n                return True\n        else:\n            mp[sum_] = i\n    return False\n",
            "javascript": "function checkSubarraySum(nums, k) {\n    let n = nums.length, sum = 0, mp = new Map();\n    mp.set(0, -1);\n    for (let i = 0; i < n; i++) {\n        sum += nums[i];\n        if (k !== 0) sum %= k;\n        if (mp.has(sum)) {\n            if (i - mp.get(sum) > 1) return true;\n        } else {\n            mp.set(sum, i);\n        }\n    }\n    return false;\n}\n",
            "explanation": "The algorithm uses a hashmap to store the running sum from the beginning of the array to the current index while iterating through the array. Each iteration, it updates the sum by adding the current number and calculates the modulus of the updated sum with k. If the resultant remainder is already in hashmap and the distance between the current index and the index in hashmap is greater than 1, then it returns true. If the modulus isn't in the hashmap, then it adds the sum and current index to the hashmap. After iterating through the entire array if no subarray with sum multiple of k is found, then it returns false."
        },
        "structure": {
            "c++": "#include <vector>\n#include <unordered_map>\n\nbool checkSubarraySum(std::vector<int>& nums, int k) \n    // Your code here\n}\n",
            "java": "import java.util.HashMap;\n\npublic boolean checkSubarraySum(int[] nums, int k) \n    // Your code here\n}\n",
            "python": "def checkSubarraySum(nums, k):\n    # Your code here\n\n",
            "javascript": "function checkSubarraySum(nums, k) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <unordered_map>\n#include <iostream>\n\nbool checkSubarraySum(std::vector<int>& nums, int k) {\n    int n = nums.size(), sum = 0;\n    std::unordered_map<int, int> mp;\n    mp[0] = -1;\n    for (int i = 0; i < n; ++i) {\n        sum += nums[i];\n        if (k != 0) sum %= k;\n        if (mp.count(sum)) {\n            if (i - mp[sum] > 1) return true;\n        } else {\n            mp[sum] = i;\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::vector<int> nums = $args;\n    int k = 5;\n    bool result = checkSubarraySum(nums, k);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "java": "public boolean checkSubarraySum(int[] nums, int k) {\n    int n = nums.length, sum = 0;\n    HashMap<Integer, Integer> map = new HashMap<>();\n    map.put(0, -1);\n    for (int i = 0; i < n; i++) {\n        sum += nums[i];\n        if (k != 0) sum %= k;\n        if (map.containsKey(sum)) {\n            if (i - map.get(sum) > 1) return true;\n        } else {\n            map.put(sum, i);\n        }\n    }\n    return false;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    k = $args[1]\n    result = checkSubarraySum(nums, k)\n    print(result)",
            "javascript": "function checkSubarraySum(nums, k) {\n    let n = nums.length, sum = 0, mp = new Map();\n    mp.set(0, -1);\n    for (let i = 0; i < n; i++) {\n        sum += nums[i];\n        if (k !== 0) sum %= k;\n        if (mp.has(sum)) {\n            if (i - mp.get(sum) > 1) return true;\n        } else {\n            mp.set(sum, i);\n        }\n    }\n    return false;\n}"
        }
    },
    "524": {
        "title": "Longest Word in Dictionary through Deletion",
        "description": "Given a string `s` and a string array `dictionary`, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.",
        "example": "Example:\n\nInput: s = \"abpcplea\", dictionary = [\"ale\", \"apple\", \"monkey\", \"plea\"]\nOutput: \"apple\"\n\nExplanation: The string \"apple\" can be formed by deleting the characters 'b', 'p', 'c', 'l', and 'a' from the given string.\n\nInput: s = \"abpcplea\", dictionary = [\"a\", \"b\", \"c\"]\nOutput: \"a\"\n\nExplanation: The string \"a\" can be formed by deleting the characters 'b', 'p', 'c', 'l', 'p', 'l', 'e', and 'a' from the given string.",
        "level": "Medium",
        "tags": [
            "string",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "abpcplea",
                        [
                            "ale",
                            "apple",
                            "monkey",
                            "plea"
                        ]
                    ]
                ],
                [
                    [
                        "abpcplea",
                        [
                            "a",
                            "b",
                            "c"
                        ]
                    ]
                ],
                [
                    [
                        "abpcplea",
                        [
                            "ab",
                            "abc",
                            "abcd"
                        ]
                    ]
                ],
                [
                    [
                        "abpcplea",
                        [
                            "abc",
                            "abcd",
                            "abcde"
                        ]
                    ]
                ],
                [
                    [
                        "abpcplea",
                        [
                            "abcde",
                            "abcd",
                            "abc"
                        ]
                    ]
                ],
                [
                    [
                        "abpcplea",
                        [
                            "abc",
                            "abcd",
                            "abcde",
                            "abcdef"
                        ]
                    ]
                ],
                [
                    [
                        "abpcplea",
                        [
                            "abc",
                            "abcd",
                            "abcde",
                            "abcdef",
                            "abcdefg"
                        ]
                    ]
                ],
                [
                    [
                        "abpcplea",
                        [
                            "abc",
                            "abcd",
                            "abcde",
                            "abcdef",
                            "abcdefg",
                            "abcdefgh"
                        ]
                    ]
                ],
                [
                    [
                        "abpcplea",
                        [
                            "abc",
                            "abcd",
                            "abcde",
                            "abcdef",
                            "abcdefg",
                            "abcdefgh",
                            "abcdefghi"
                        ]
                    ]
                ],
                [
                    [
                        "abpcplea",
                        [
                            "abc",
                            "abcd",
                            "abcde",
                            "abcdef",
                            "abcdefg",
                            "abcdefgh",
                            "abcdefghi",
                            "abcdefghij"
                        ]
                    ]
                ],
                [
                    [
                        "abpcplea",
                        [
                            "abc",
                            "abcd",
                            "abcde",
                            "abcdef",
                            "abcdefg",
                            "abcdefgh",
                            "abcdefghi",
                            "abcdefghij",
                            "abcdefghijk"
                        ]
                    ]
                ],
                [
                    [
                        "abpcplea",
                        [
                            "abc",
                            "abcd",
                            "abcde",
                            "abcdef",
                            "abcdefg",
                            "abcdefgh",
                            "abcdefghi",
                            "abcdefghij",
                            "abcdefghijk",
                            "abcdefghijkl"
                        ]
                    ]
                ],
                [
                    [
                        "abpcplea",
                        [
                            "abc",
                            "abcd",
                            "abcde",
                            "abcdef",
                            "abcdefg",
                            "abcdefgh",
                            "abcdefghi",
                            "abcdefghij",
                            "abcdefghijk",
                            "abcdefghijkl",
                            "abcdefghijklm"
                        ]
                    ]
                ],
                [
                    [
                        "abpcplea",
                        [
                            "abc",
                            "abcd",
                            "abcde",
                            "abcdef",
                            "abcdefg",
                            "abcdefgh",
                            "abcdefghi",
                            "abcdefghij",
                            "abcdefghijk",
                            "abcdefghijkl",
                            "abcdefghijklm",
                            "abcdefghijklmn"
                        ]
                    ]
                ],
                [
                    [
                        "abpcplea",
                        [
                            "abc",
                            "abcd",
                            "abcde",
                            "abcdef",
                            "abcdefg",
                            "abcdefgh",
                            "abcdefghi",
                            "abcdefghij",
                            "abcdefghijk",
                            "abcdefghijkl",
                            "abcdefghijklm",
                            "abcdefghijklmn",
                            "abcdefghijklmno"
                        ]
                    ]
                ],
                [
                    [
                        "abpcplea",
                        [
                            "abc",
                            "abcd",
                            "abcde",
                            "abcdef",
                            "abcdefg",
                            "abcdefgh",
                            "abcdefghi",
                            "abcdefghij",
                            "abcdefghijk",
                            "abcdefghijkl",
                            "abcdefghijklm",
                            "abcdefghijklmn",
                            "abcdefghijklmno",
                            "abcdefghijklmnop"
                        ]
                    ]
                ],
                [
                    [
                        "abpcplea",
                        [
                            "abc",
                            "abcd",
                            "abcde",
                            "abcdef",
                            "abcdefg",
                            "abcdefgh",
                            "abcdefghi",
                            "abcdefghij",
                            "abcdefghijk",
                            "abcdefghijkl",
                            "abcdefghijklm",
                            "abcdefghijklmn",
                            "abcdefghijklmno",
                            "abcdefghijklmnop",
                            "abcdefghijklmnopq"
                        ]
                    ]
                ],
                [
                    [
                        "abpcplea",
                        [
                            "abc",
                            "abcd",
                            "abcde",
                            "abcdef",
                            "abcdefg",
                            "abcdefgh",
                            "abcdefghi",
                            "abcdefghij",
                            "abcdefghijk",
                            "abcdefghijkl",
                            "abcdefghijklm",
                            "abcdefghijklmn",
                            "abcdefghijklmno",
                            "abcdefghijklmnop",
                            "abcdefghijklmnopq",
                            "abcdefghijklmnopqr"
                        ]
                    ]
                ],
                [
                    [
                        "abpcplea",
                        [
                            "abc",
                            "abcd",
                            "abcde",
                            "abcdef",
                            "abcdefg",
                            "abcdefgh",
                            "abcdefghi",
                            "abcdefghij",
                            "abcdefghijk",
                            "abcdefghijkl",
                            "abcdefghijklm",
                            "abcdefghijklmn",
                            "abcdefghijklmno",
                            "abcdefghijklmnop",
                            "abcdefghijklmnopq",
                            "abcdefghijklmnopqr",
                            "abcdefghijklmnopqrs"
                        ]
                    ]
                ],
                [
                    [
                        "abpcplea",
                        [
                            "abc",
                            "abcd",
                            "abcde",
                            "abcdef",
                            "abcdefg",
                            "abcdefgh",
                            "abcdefghi",
                            "abcdefghij",
                            "abcdefghijk",
                            "abcdefghijkl",
                            "abcdefghijklm",
                            "abcdefghijklmn",
                            "abcdefghijklmno",
                            "abcdefghijklmnop",
                            "abcdefghijklmnopq",
                            "abcdefghijklmnopqr",
                            "abcdefghijklmnopqrs",
                            "abcdefghijklmnopqrst"
                        ]
                    ]
                ],
                [
                    [
                        "abpcplea",
                        [
                            "abc",
                            "abcd",
                            "abcde",
                            "abcdef",
                            "abcdefg",
                            "abcdefgh",
                            "abcdefghi",
                            "abcdefghij",
                            "abcdefghijk",
                            "abcdefghijkl",
                            "abcdefghijklm",
                            "abcdefghijklmn",
                            "abcdefghijklmno",
                            "abcdefghijklmnop",
                            "abcdefghijklmnopq",
                            "abcdefghijklmnopqr",
                            "abcdefghijklmnopqrs",
                            "abcdefghijklmnopqrst",
                            "abcdefghijklmnopqrstu"
                        ]
                    ]
                ]
            ],
            "outputs": [
                "\"apple\"",
                "\"a\"",
                "\"ab\"",
                "\"abc\"",
                "\"abc\"",
                "\"abc\"",
                "\"abc\"",
                "\"abc\"",
                "\"abc\"",
                "\"abc\"",
                "\"abc\"",
                "\"abc\"",
                "\"abc\"",
                "\"abc\"",
                "\"abc\"",
                "\"abc\"",
                "\"abc\"",
                "\"abc\"",
                "\"abc\"",
                "\"abc\""
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <vector>\n#include <algorithm>\n\nbool isSubsequence(const std::string &s, const std::string &word) {\n    int i = 0, j = 0;\n    while (i < s.size() && j < word.size()) {\n        if (s[i] == word[j]) {\n            j++;\n        }\n        i++;\n    }\n    return j == word.size();\n}\n\nstd::string findLongestWord(std::string s, std::vector<std::string> &dictionary) {\n    std::string longest = \"\";\n    std::sort(dictionary.begin(), dictionary.end());\n    for (const std::string &word : dictionary) {\n        if (isSubsequence(s, word)) {\n            if (word.size() > longest.size()) {\n                longest = word;\n            }\n        }\n    }\n    return longest;\n}\n\n",
            "java": "import java.util.Arrays;\n\npublic String findLongestWord(String s, String[] dictionary) {\n    String longest = \"\";\n    Arrays.sort(dictionary);\n    for (String word : dictionary) {\n        if (isSubsequence(s, word)) {\n            if (word.length() > longest.length()) {\n                longest = word;\n            }\n        }\n    }\n    return longest;\n}\n\nprivate boolean isSubsequence(String s, String word) {\n    int i = 0, j = 0;\n    while (i < s.length() && j < word.length()) {\n        if (s.charAt(i) == word.charAt(j)) {\n            j++;\n        }\n        i++;\n    }\n    return j == word.length();\n}\n\n",
            "python": "def findLongestWord(s, dictionary):\n    def is_subsequence(target, source):\n        iter_source = iter(source)\n        return all(char in iter_source for char in target)\n\n    dictionary = sorted(dictionary)\n    longest = ''\n    for word in dictionary:\n        if is_subsequence(word, s) and len(word) > len(longest):\n            longest = word\n    return longest\n\n",
            "javascript": "function findLongestWord(s, dictionary) {\n    function isSubsequence(s, word) {\n        let i = 0, j = 0;\n        while (i < s.length && j < word.length) {\n            if (s[i] === word[j]) {\n                j++;\n            }\n            i++;\n        }\n        return j === word.length;\n    }\n\n    dictionary.sort();\n    let longest = '';\n    for (let word of dictionary) {\n        if (isSubsequence(s, word)) {\n            if (word.length > longest.length) {\n                longest = word;\n            }\n        }\n    }\n    return longest;\n}\n\n",
            "explanation": "1. First, sort the dictionary so that word comparison will be in lexicographical order.\n2. Define a helper function `isSubsequence` which checks if a given word can be formed by deleting some of the given string characters.\n3. Iterate through the dictionary and for each word, check if it can be formed using the helper function. If a word can be formed and its length is longer than the current longest word, set it as the new longest word.\n4. Return the longest word found, or an empty string if no match was found."
        },
        "structure": {
            "c++": "#include <string>\n#include <vector>\n#include <algorithm>\n\nbool isSubsequence(const std::string &s, const std::string &word) \n    // Your code here\n}\n\n",
            "java": "import java.util.Arrays;\n\npublic String findLongestWord(String s, String[] dictionary) \n    // Your code here\n}\n\n",
            "python": "def findLongestWord(s, dictionary):\n    # Your code here\n\n",
            "javascript": "function findLongestWord(s, dictionary) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\nbool isSubsequence(const std::string &s, const std::string &word) {\n    int i = 0, j = 0;\n    while (i < s.size() && j < word.size()) {\n        if (s[i] == word[j]) {\n            j++;\n        }\n        i++;\n    }\n    return j == word.size();\n}\n\nint main() {\n    std::string s = $args;\n    std::vector<std::string> dictionary = {\"word1\", \"word2\", \"word3\"}; // Replace with actual dictionary\n    std::string result = findLongestWord(s, dictionary);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public String findLongestWord(String s, String[] dictionary) {\n    String longest = \"\";\n    Arrays.sort(dictionary);\n    for (String word : dictionary) {\n        if (isSubsequence(s, word)) {\n            if (word.length() > longest.length()) {\n                longest = word;\n            }\n        }\n    }\n    return longest;\n}\n\nprivate boolean isSubsequence(String s, String word) {\n    int i = 0, j = 0;\n    while (i < s.length() && j < word.length()) {\n        if (s.charAt(i) == word.charAt(j)) {\n            j++;\n        }\n        i++;\n    }\n    return j == word.length();\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args[0]\n    dictionary = $args[1]\n    result = findLongestWord(s, dictionary)\n    print(result)",
            "javascript": "function findLongestWord(s, dictionary) {\n    function isSubsequence(s, word) {\n        let i = 0, j = 0;\n        while (i < s.length && j < word.length) {\n            if (s[i] === word[j]) {\n                j++;\n            }\n            i++;\n        }\n        return j === word.length;\n    }\n\n    dictionary.sort();\n    let longest = '';\n    for (let word of dictionary) {\n        if (isSubsequence(s, word)) {\n            if (word.length > longest.length) {\n                longest = word;\n            }\n        }\n    }\n    return longest;\n}"
        }
    },
    "525": {
        "title": "Maximum Length of Contiguous Subarray",
        "description": "Given a binary array `nums`, find the maximum length of a contiguous subarray with an equal number of `0` and `1`.",
        "example": "Example 1:\n\nInput: nums = [0,1]\nOutput: 2\nExplanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.\n\nExample 2:\n\nInput: nums = [0,1,0]\nOutput: 2\nExplanation: [0, 1] (or [1, 0]) is the longest contiguous subarray with an equal number of 0 and 1.",
        "level": "Medium",
        "tags": [
            "array",
            "subarray",
            "contiguous",
            "binary"
        ],
        "test_cases": {
            "inputs": [
                [
                    0,
                    1
                ],
                [
                    0,
                    1,
                    0
                ],
                [
                    1,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    0,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    0,
                    0,
                    1,
                    1
                ],
                [
                    1,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    0,
                    0,
                    0,
                    1,
                    1,
                    1
                ],
                [
                    0,
                    0,
                    0,
                    1,
                    1,
                    1,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    1
                ],
                [
                    0,
                    1,
                    1,
                    0,
                    1,
                    0,
                    0,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    0,
                    0,
                    0,
                    1,
                    1,
                    1,
                    0
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    1,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    1,
                    1,
                    0,
                    1,
                    0,
                    1,
                    1
                ],
                [
                    0,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    1,
                    1,
                    1,
                    0,
                    0
                ],
                [
                    0,
                    1,
                    1,
                    1,
                    0,
                    0,
                    0,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0
                ]
            ],
            "outputs": [
                2,
                2,
                4,
                6,
                0,
                0,
                8,
                8,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                8,
                8,
                8,
                8,
                8
            ]
        },
        "sample_code": {
            "c++": "int findMaxLength(vector<int>& nums) {\n    unordered_map<int, int> counts;\n    counts[0] = -1;\n    int max_len = 0, count = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        count += (nums[i] == 1) ? 1 : -1;\n        if (counts.count(count))\n            max_len = max(max_len, i - counts[count]);\n        else\n            counts[count] = i;\n    }\n    return max_len;\n}\n",
            "java": "public int findMaxLength(int[] nums) {\n    HashMap<Integer, Integer> counts = new HashMap<>();\n    counts.put(0, -1);\n    int max_len = 0, count = 0;\n    for (int i = 0; i < nums.length; i++) {\n        count += (nums[i] == 1) ? 1 : -1;\n        if (counts.containsKey(count))\n            max_len = Math.max(max_len, i - counts.get(count));\n        else\n            counts.put(count, i);\n    }\n    return max_len;\n}\n\n",
            "python": "def findMaxLength(nums):\n    counts = {0: -1}\n    max_len = count = 0\n    for i, num in enumerate(nums):\n        count += 1 if num == 1 else -1\n        if count in counts:\n            max_len = max(max_len, i - counts[count])\n        else:\n            counts[count] = i\n    return max_len\n",
            "javascript": "function findMaxLength(nums) {\n    let counts = new Map();\n    counts.set(0, -1);\n    let max_len = 0, count = 0;\n    for (let i = 0; i < nums.length; i++) {\n        count += (nums[i] === 1) ? 1 : -1;\n        if (counts.has(count))\n            max_len = Math.max(max_len, i - counts.get(count));\n        else\n            counts.set(count, i);\n    }\n    return max_len;\n}\n",
            "explanation": "This algorithm iterates through the given binary array and maintains a running count. It uses a hash table called \"counts\" to store the count-value pairs in which the count is the key and its index is the value. We initialize the hash table with a pair {0: -1} to handle the edge case when the first few elements form a valid subarray.\n\nFor each element in the array, we increment the count by 1 if the element is 1 or decrement by 1 if it is 0. The count then represents the difference between 1's and 0's in the array up to the current index.\n\nThen, we check if the current count is present in the hash table. If it is, that means we have encountered an equal number of 1's and 0's between the current index and the index stored under the current count in the hash table, so we compare this subarray's length with the previously stored max length of a valid subarray. Finally, we store the current count and index in the hash table if it isn't already present."
        },
        "structure": {
            "c++": "int findMaxLength(vector<int>& nums) \n    // Your code here\n}\n",
            "java": "public int findMaxLength(int[] nums) \n    // Your code here\n}\n\n",
            "python": "def findMaxLength(nums):\n    # Your code here\n\n",
            "javascript": "function findMaxLength(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int findMaxLength(vector<int>& nums) {\n    unordered_map<int, int> counts;\n    counts[0] = -1;\n    int max_len = 0, count = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        count += (nums[i] == 1) ? 1 : -1;\n        if (counts.count(count))\n            max_len = max(max_len, i - counts[count]);\n        else\n            counts[count] = i;\n    }\n    return max_len;\n}",
            "java": "public int findMaxLength(int[] nums) {\n    HashMap<Integer, Integer> counts = new HashMap<>();\n    counts.put(0, -1);\n    int max_len = 0, count = 0;\n    for (int i = 0; i < nums.length; i++) {\n        count += (nums[i] == 1) ? 1 : -1;\n        if (counts.containsKey(count))\n            max_len = Math.max(max_len, i - counts.get(count));\n        else\n            counts.put(count, i);\n    }\n    return max_len;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = findMaxLength(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = findMaxLength(nums);\n    console.log(result);\n}"
        }
    },
    "526": {
        "title": "Beautiful Arrangements",
        "description": "Given `n` integers labeled `1` through `n`, a permutation of those `n` integers `perm` (1-indexed) is considered a beautiful arrangement if for every `i` (1 <= i <= n), either `perm[i]` is divisible by `i` or `i` is divisible by `perm[i]`. Given an integer `n`, return the number of beautiful arrangements that can be constructed.",
        "example": "Example:\n\nInput: n = 2\nOutput: 2\nExplanation: The first beautiful arrangement is [1,2]:\n- perm[1] = 1 is divisible by i = 1\n- perm[2] = 2 is divisible by i = 2\nThe second beautiful arrangement is [2,1]:\n- perm[1] = 2 is divisible by i = 1\n- i = 2 is divisible by perm[2] = 1",
        "level": "Medium",
        "tags": [
            "permutation",
            "divisibility"
        ],
        "test_cases": {
            "inputs": [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            "outputs": [
                2,
                3,
                8,
                10,
                36,
                41,
                132,
                250,
                700,
                750,
                4010,
                4237,
                10680,
                24679
            ]
        },
        "sample_code": {
            "c++": "int countArrangement(int n) {\n    int res=0;\n    vector<bool> visited(n+1,false); \n    helper(n,1,visited,res); \n    return res;\n}\n\nvoid helper(int n, int idx, vector<bool>& visited, int& res) {\n    if (idx > n) {\n        ++res;\n    }\n\n    for(int i=1; i<=n; i++){\n        if (!visited[i] && (idx % i == 0 || i % idx == 0)) { \n            visited[i] = true; \n            helper(n, idx+1, visited, res); \n            visited[i] = false; \n        }\n    }\n}\n",
            "java": "int countArrangement(int n) {\n    int[] res = new int[]{0};\n    boolean[] visited = new boolean[n+1];\n    helper(n, 1, visited, res);\n    return res[0];\n}\n\nvoid helper(int n, int idx, boolean[] visited, int[] res) {\n    if (idx > n) {\n        res[0]++;\n    }\n\n    for(int i=1; i<=n; i++){\n        if (!visited[i] && (idx % i == 0 || i % idx == 0)) {\n            visited[i] = true;\n            helper(n, idx+1, visited, res);\n            visited[i] = false;\n        }\n    }\n}\n",
            "python": "def countArrangement(n: int) -> int:\n    def helper(idx: int, visited: List[bool], n: int) -> int:\n        if idx > n:\n            return 1\n\n        count = 0\n        for i in range(1, n+1):\n            if not visited[i] and (idx % i == 0 or i % idx == 0):\n                visited[i] = True\n                count += helper(idx+1, visited, n)\n                visited[i] = False\n\n        return count\n\n    visited = [False] * (n+1)\n    return helper(1, visited, n)\n",
            "javascript": "function countArrangement(n) {\n    let res=0;\n    let visited=Array(n+1).fill(false); \n    helper(n,1,visited); \n    return res;\n\n    function helper(n, idx, visited) {\n        if (idx > n) {\n            ++res;\n        }\n\n        for(let i=1; i<=n; i++){\n            if (!visited[i] && (idx % i === 0 || i % idx === 0)) { \n                visited[i] = true; \n                helper(n, idx+1, visited); \n                visited[i] = false; \n            }\n        }\n    }\n}\n",
            "explanation": "This problem can be solved using a backtracking algorithm. We can start by creating a helper function (a recursive function) that will iterate through all possibilities. The base case for the recursion is when the current index (idx) is greater than the given integer n. When this condition is met, increment the result (res) by 1.\n\nIn the helper function, iterate a loop for each integer i (1 <= i <= n). Check if i is not visited (visited[i] == false) and if i is divisible by idx or idx is divisible by i. If either of these conditions is true, mark i as visited and call the helper function recursively with the index incremented by 1. After the recursive call, unmark i as visited to backtrack to the previous state.\n\nInitially, pass an array or vector of visited flags, which are all initialized to false along with the integer n and index 1 to the helper function. The helper function will traverse all possibilities and return the result (res) as the final count of beautiful arrangements."
        },
        "structure": {
            "c++": "int countArrangement(int n) \n    // Your code here\n}\n",
            "java": "int countArrangement(int n) \n    // Your code here\n}\n",
            "python": "def countArrangement(n: int) -> int:\n    # Your code here\n\n",
            "javascript": "function countArrangement(n) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = countArrangement(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "int countArrangement(int n) {\n    int[] res = new int[]{0};\n    boolean[] visited = new boolean[n+1];\n    helper(n, 1, visited, res);\n    return res[0];\n}\n\nvoid helper(int n, int idx, boolean[] visited, int[] res) {\n    if (idx > n) {\n        res[0]++;\n    }\n\n    for(int i=1; i<=n; i++){\n        if (!visited[i] && (idx % i == 0 || i % idx == 0)) {\n            visited[i] = true;\n            helper(n, idx+1, visited, res);\n            visited[i] = false;\n        }\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    result = countArrangement(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = countArrangement(n);\n    console.log(result);\n}"
        }
    },
    "527": {
        "title": "Word Abbreviation",
        "description": "Given an array of distinct strings, return the minimal possible abbreviations for every word. The abbreviation for each word is formed by taking the first character, then the number of characters in between, followed by the last character. If multiple words have the same abbreviation, increase the prefix of each abbreviation by 1 until they are unique. If an abbreviation does not make a word shorter, keep the original word.",
        "example": "For example, given the input words = ['like', 'god', 'internal', 'me', 'internet', 'interval', 'intension', 'face', 'intrusion'], the output would be ['l2e', 'god', 'internal', 'me', 'i6t', 'interval', 'inte4n', 'f2e', 'intr4n'].\n\nExplanation:\n- 'like' becomes 'l2e' because there are 2 characters between 'l' and 'e'.\n- 'god' remains the same as it is already unique.\n- 'internal' remains the same as it is already unique.\n- 'me' remains the same as it is already unique.\n- 'internet' becomes 'i6t' because there are 6 characters between 'i' and 't'.\n- 'interval' remains the same as it is already unique.\n- 'intension' becomes 'inte4n' because there are 4 characters between 'i' and 'n'.\n- 'face' becomes 'f2e' because there are 2 characters between 'f' and 'e'.\n- 'intrusion' becomes 'intr4n' because there are 4 characters between 'i' and 'n'.",
        "level": "Medium",
        "tags": [
            "string",
            "array"
        ],
        "test_cases": {
            "inputs": [
                [
                    "like",
                    "god",
                    "internal",
                    "me",
                    "internet",
                    "interval",
                    "intension",
                    "face",
                    "intrusion"
                ],
                [
                    "aa",
                    "aaa"
                ],
                [
                    "hello",
                    "world",
                    "hi",
                    "hey"
                ],
                [
                    "programming",
                    "code",
                    "algorithm",
                    "problem"
                ],
                [
                    "apple",
                    "banana",
                    "cherry",
                    "date",
                    "elderberry"
                ],
                [
                    "cat",
                    "dog",
                    "elephant",
                    "fish",
                    "giraffe",
                    "hippopotamus"
                ],
                [
                    "moon",
                    "sun",
                    "star",
                    "planet",
                    "galaxy",
                    "universe"
                ],
                [
                    "car",
                    "bike",
                    "bus",
                    "train",
                    "plane",
                    "ship",
                    "subway"
                ],
                [
                    "red",
                    "blue",
                    "green",
                    "yellow",
                    "orange",
                    "purple",
                    "pink",
                    "brown"
                ],
                [
                    "one",
                    "two",
                    "three",
                    "four",
                    "five",
                    "six",
                    "seven",
                    "eight",
                    "nine",
                    "ten"
                ]
            ],
            "outputs": [
                [
                    "l2e",
                    "god",
                    "internal",
                    "me",
                    "i6t",
                    "interval",
                    "inte4n",
                    "f2e",
                    "intr4n"
                ],
                [
                    "aa",
                    "aaa"
                ],
                [
                    "h2o",
                    "w3d",
                    "hi",
                    "hey"
                ],
                [
                    "p11g",
                    "c2e",
                    "a8m",
                    "p5m"
                ],
                [
                    "a4e",
                    "b4a",
                    "c4y",
                    "d2e",
                    "e8y"
                ],
                [
                    "c1t",
                    "d1g",
                    "e7t",
                    "f2h",
                    "g6e",
                    "h9s"
                ],
                [
                    "m2n",
                    "s2n",
                    "s3r",
                    "p4t",
                    "g4y",
                    "u7e"
                ],
                [
                    "c1r",
                    "b2e",
                    "b2s",
                    "t4n",
                    "p4e",
                    "s3p",
                    "s4y"
                ],
                [
                    "r1d",
                    "b3e",
                    "g4n",
                    "y4w",
                    "o5e",
                    "p5e",
                    "p4k",
                    "b4n"
                ],
                [
                    "o2e",
                    "t2o",
                    "t3e",
                    "f3r",
                    "f4e",
                    "s3x",
                    "s4n",
                    "e5t",
                    "n3e",
                    "t3n"
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::string abbrev(const std::string& s, int k) {\n    int n = s.length();\n    if (k >= n - 2) {\n        return s;\n    }\n    return s.substr(0, k + 1) + std::to_string(n - k - 2) + s.back();\n}\n\nstd::vector<std::string> wordsAbbreviation(std::vector<std::string>& words) {\n    int n = words.size();\n    std::vector<std::string> abbr;\n    std::vector<int> prefixLen(n, 1);\n\n    for (int i = 0; i < n; ++i) {\n        abbr.push_back(abbrev(words[i], 1));\n    }\n\n    for (int i = 0; i < n; ++i) {\n        while (true) {\n            std::unordered_map<std::string, std::vector<int>> groups;\n            for (int j = i + 1; j < n; ++j) {\n                if (abbr[i] == abbr[j]) {\n                    groups[abbr[j]].push_back(j);\n                }\n            }\n            if (groups.empty()) {\n                break;\n            }\n            for (const auto &group : groups) {\n                for (int id : group.second) {\n                    abbr[id] = abbrev(words[id], ++prefixLen[id]);\n                }\n            }\n            abbr[i] = abbrev(words[i], ++prefixLen[i]);\n        }\n    }\n\n    return abbr;\n}\n",
            "java": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Arrays;\n\npublic String[] wordsAbbreviation(String[] words) {\n    int n = words.length;\n    String[] abbr = new String[n];\n    int[] prefixLen = new int[n];\n\n    for (int i = 0; i < n; i++) {\n        abbr[i] = abbrev(words[i], 1);\n        prefixLen[i] = 1;\n    }\n\n    for (int i = 0; i < n; i++) {\n        while (true) {\n            Map<String, int[]> groups = new HashMap<>();\n            for (int j = 0; j < n; j++) {\n                if (abbr[i].equals(abbr[j])) {\n                    if (!groups.containsKey(abbr[j])) {\n                        groups.put(abbr[j], new int[]{0, 0});\n                    }\n                    groups.get(abbr[j])[0]++;\n                    groups.get(abbr[j])[1] = j;\n                }\n            }\n            if (groups.get(abbr[i])[0] == 1) {\n                break;\n            }\n            abbr[groups.get(abbr[i])[1]] = abbrev(words[groups.get(abbr[i])[1]], ++prefixLen[groups.get(abbr[i])[1]]);\n            abbr[i] = abbrev(words[i], ++prefixLen[i]);\n        }\n    }\n\n    return abbr;\n}\n\nprivate String abbrev(String s, int k) {\n    int n = s.length();\n    if (k >= n - 2) {\n        return s;\n    }\n    return s.substring(0, k + 1) + Integer.toString(n - k - 2) + s.charAt(n - 1);\n}\n",
            "python": "def wordsAbbreviation(words):\n    def abbrev(word, k):\n        return word[:k+1] + str(len(word) - k - 2) + word[-1] if k < len(word) - 2 else word\n\n    n = len(words)\n    abbr = [abbrev(word, 1) for word in words]\n    prefix_len = [1] * n\n\n    for i in range(n):\n        while abbr.count(abbr[i]) > 1:\n            groups = {}\n            for j in range(i + 1, n):\n                if abbr[i] == abbr[j]:\n                    if abbr[j] not in groups:\n                        groups[abbr[j]] = []\n                    groups[abbr[j]].append(j)\n            for group_members in groups.values():\n                for j in group_members:\n                    abbr[j] = abbrev(words[j], prefix_len[j] + 1)\n                    prefix_len[j] += 1\n            abbr[i] = abbrev(words[i], prefix_len[i] + 1)\n            prefix_len[i] += 1\n\n    return abbr\n",
            "javascript": "function wordsAbbreviation(words) {\n    function abbrev(word, k) {\n        return k < word.length - 2 ? word.slice(0, k + 1) + (word.length - k - 2) + word.slice(-1) : word;\n    }\n\n    const n = words.length;\n    const abbr = words.map(word => abbrev(word, 1));\n    const prefixLen = new Array(n).fill(1);\n\n    for (let i = 0; i < n; i++) {\n        while (abbr.filter(a => a === abbr[i]).length > 1) {\n            const groups = {};\n            for (let j = i + 1; j < n; j++) {\n                if (abbr[i] === abbr[j]) {\n                    if (!groups[abbr[j]]) {\n                        groups[abbr[j]] = [];\n                    }\n                    groups[abbr[j]].push(j);\n                }\n            }\n            for (const groupMembers of Object.values(groups)) {\n                for (const j of groupMembers) {\n                    abbr[j] = abbrev(words[j], prefixLen[j] + 1);\n                    prefixLen[j]++;\n                }\n            }\n            abbr[i] = abbrev(words[i], prefixLen[i] + 1);\n            prefixLen[i]++;\n        }\n    }\n\n    return abbr;\n}\n",
            "explanation": "1. Initialize abbreviation lists and prefix lengths for each word.\n2. For each word, calculate its initial abbreviation based on the rule 1.\n3. Check if there are any words that share the same abbreviation.\n4. If there are, increase the prefix of those words as stated in rule 2 and update the abbreviation.\n5. Repeat steps 3 and 4 until every abbreviation is unique.\n6. Once all abbreviations are unique, return the list of abbreviations."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::string abbrev(const std::string& s, int k) \n    // Your code here\n}\n",
            "java": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Arrays;\n\npublic String[] wordsAbbreviation(String[] words) \n    // Your code here\n}\n",
            "python": "def wordsAbbreviation(words):\n    # Your code here\n\n",
            "javascript": "function wordsAbbreviation(words) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::string abbrev(const std::string& s, int k);\nstd::vector<std::string> wordsAbbreviation(std::vector<std::string>& words);\n\nint main() {\n    std::vector<std::string> words = $args;\n    std::vector<std::string> result = wordsAbbreviation(words);\n    for (const std::string& word : result) {\n        std::cout << word << std::endl;\n    }\n    return 0;\n}\n\nstd::string abbrev(const std::string& s, int k) {\n    int n = s.length();\n    if (k >= n - 2) {\n        return s;\n    }\n    return s.substr(0, k + 1) + std::to_string(n - k - 2) + s.back();\n}\n\nstd::vector<std::string> wordsAbbreviation(std::vector<std::string>& words) {\n    int n = words.size();\n    std::vector<std::string> abbr;\n    std::vector<int> prefixLen(n, 1);\n\n    for (int i = 0; i < n; ++i) {\n        abbr.push_back(abbrev(words[i], 1));\n    }\n\n    for (int i = 0; i < n; ++i) {\n        while (true) {\n            std::unordered_map<std::string, std::vector<int>> groups;\n            for (int j = i + 1; j < n; ++j) {\n                if (abbr[i] == abbr[j]) {\n                    groups[abbr[j]].push_back(j);\n                }\n            }\n            if (groups.empty()) {\n                break;\n            }\n            for (const auto &group : groups) {\n                for (int id : group.second) {\n                    abbr[id] = abbrev(words[id], ++prefixLen[id]);\n                }\n            }\n            abbr[i] = abbrev(words[i], ++prefixLen[i]);\n        }\n    }\n\n    return abbr;\n}",
            "java": "public String[] wordsAbbreviation(String[] words) {\n    int n = words.length;\n    String[] abbr = new String[n];\n    int[] prefixLen = new int[n];\n\n    for (int i = 0; i < n; i++) {\n        abbr[i] = abbrev(words[i], 1);\n        prefixLen[i] = 1;\n    }\n\n    for (int i = 0; i < n; i++) {\n        while (true) {\n            Map<String, int[]> groups = new HashMap<>();\n            for (int j = 0; j < n; j++) {\n                if (abbr[i].equals(abbr[j])) {\n                    if (!groups.containsKey(abbr[j])) {\n                        groups.put(abbr[j], new int[]{0, 0});\n                    }\n                    groups.get(abbr[j])[0]++;\n                    groups.get(abbr[j])[1] = j;\n                }\n            }\n            if (groups.get(abbr[i])[0] == 1) {\n                break;\n            }\n            abbr[groups.get(abbr[i])[1]] = abbrev(words[groups.get(abbr[i])[1]], ++prefixLen[groups.get(abbr[i])[1]]);\n            abbr[i] = abbrev(words[i], ++prefixLen[i]);\n        }\n    }\n\n    return abbr;\n}\n\nprivate String abbrev(String s, int k) {\n    int n = s.length();\n    if (k >= n - 2) {\n        return s;\n    }\n    return s.substring(0, k + 1) + Integer.toString(n - k - 2) + s.charAt(n - 1);\n}",
            "python": "if __name__ == \"__main__\":\n    words = $args[0]\n    result = wordsAbbreviation(words)\n    print(result)",
            "javascript": "function wordsAbbreviation(words) {\n    function abbrev(word, k) {\n        return k < word.length - 2 ? word.slice(0, k + 1) + (word.length - k - 2) + word.slice(-1) : word;\n    }\n\n    const n = words.length;\n    const abbr = words.map(word => abbrev(word, 1));\n    const prefixLen = new Array(n).fill(1);\n\n    for (let i = 0; i < n; i++) {\n        while (abbr.filter(a => a === abbr[i]).length > 1) {\n            const groups = {};\n            for (let j = i + 1; j < n; j++) {\n                if (abbr[i] === abbr[j]) {\n                    if (!groups[abbr[j]]) {\n                        groups[abbr[j]] = [];\n                    }\n                    groups[abbr[j]].push(j);\n                }\n            }\n            for (const groupMembers of Object.values(groups)) {\n                for (const j of groupMembers) {\n                    abbr[j] = abbrev(words[j], prefixLen[j] + 1);\n                    prefixLen[j]++;\n                }\n            }\n            abbr[i] = abbrev(words[i], prefixLen[i] + 1);\n            prefixLen[i]++;\n        }\n    }\n\n    return abbr;\n}"
        }
    },
    "531": {
        "title": "Black Lonely Pixels",
        "description": "Given an `m x n` picture consisting of black 'B' and white 'W' pixels, return the number of black lonely pixels. A black lonely pixel is a character 'B' that is located at a specific position where the same row and same column don't have any other black pixels.",
        "example": "Example:\n\nInput: picture = [['W', 'W', 'B'], ['W', 'B', 'W'], ['B', 'W', 'W']]\nOutput: 3\nExplanation: All the three 'B's are black lonely pixels.",
        "level": "Easy",
        "tags": [
            "matrix",
            "counting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "W",
                        "W",
                        "B"
                    ],
                    [
                        "W",
                        "B",
                        "W"
                    ],
                    [
                        "B",
                        "W",
                        "W"
                    ]
                ],
                [
                    [
                        "B",
                        "B",
                        "B"
                    ],
                    [
                        "B",
                        "B",
                        "W"
                    ],
                    [
                        "B",
                        "B",
                        "B"
                    ]
                ],
                [
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "W",
                        "W"
                    ]
                ],
                [
                    [
                        "B",
                        "B",
                        "B"
                    ],
                    [
                        "B",
                        "B",
                        "B"
                    ],
                    [
                        "B",
                        "B",
                        "B"
                    ]
                ],
                [
                    [
                        "B",
                        "W",
                        "B"
                    ],
                    [
                        "W",
                        "B",
                        "W"
                    ],
                    [
                        "B",
                        "W",
                        "B"
                    ]
                ],
                [
                    [
                        "B",
                        "B",
                        "B"
                    ],
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "B",
                        "B",
                        "B"
                    ]
                ],
                [
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "B",
                        "W"
                    ],
                    [
                        "W",
                        "W",
                        "W"
                    ]
                ],
                [
                    [
                        "B",
                        "B",
                        "B"
                    ],
                    [
                        "B",
                        "W",
                        "B"
                    ],
                    [
                        "B",
                        "B",
                        "B"
                    ]
                ],
                [
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "B",
                        "W"
                    ]
                ],
                [
                    [
                        "B",
                        "B",
                        "B"
                    ],
                    [
                        "B",
                        "B",
                        "B"
                    ],
                    [
                        "B",
                        "W",
                        "B"
                    ]
                ],
                [
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "W",
                        "B"
                    ]
                ],
                [
                    [
                        "B",
                        "B",
                        "B"
                    ],
                    [
                        "B",
                        "B",
                        "B"
                    ],
                    [
                        "B",
                        "B",
                        "W"
                    ]
                ],
                [
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "W",
                        "W"
                    ]
                ],
                [
                    [
                        "B",
                        "B",
                        "B"
                    ],
                    [
                        "B",
                        "B",
                        "B"
                    ],
                    [
                        "B",
                        "B",
                        "B"
                    ]
                ],
                [
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "B",
                        "W"
                    ],
                    [
                        "W",
                        "W",
                        "W"
                    ]
                ],
                [
                    [
                        "B",
                        "B",
                        "B"
                    ],
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "B",
                        "B",
                        "B"
                    ]
                ],
                [
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "W",
                        "W"
                    ]
                ],
                [
                    [
                        "B",
                        "B",
                        "B"
                    ],
                    [
                        "B",
                        "W",
                        "B"
                    ],
                    [
                        "B",
                        "B",
                        "B"
                    ]
                ],
                [
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "B",
                        "W"
                    ],
                    [
                        "W",
                        "W",
                        "W"
                    ]
                ],
                [
                    [
                        "B",
                        "B",
                        "B"
                    ],
                    [
                        "B",
                        "B",
                        "B"
                    ],
                    [
                        "B",
                        "W",
                        "B"
                    ]
                ],
                [
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "B",
                        "W"
                    ]
                ]
            ],
            "outputs": [
                3,
                0,
                0,
                0,
                4,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "int findLonelyPixel(vector<vector<char>>& picture) {\n    int m = picture.size(), n = picture[0].size();\n    vector<int> row(m, 0), col(n, 0);\n    \n    for(int i = 0; i < m; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(picture[i][j] == 'B') {\n                row[i]++;\n                col[j]++;\n            }\n        }\n    }\n    \n    int lonely = 0;\n    for(int i = 0; i < m; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(picture[i][j] == 'B' && row[i] == 1 && col[j] == 1) {\n                lonely++;\n            }\n        }\n    }\n    \n    return lonely;\n}\n",
            "java": "public int findLonelyPixel(char[][] picture) {\n    int m = picture.length, n = picture[0].length;\n    int[] row = new int[m], col = new int[n];\n    \n    for(int i = 0; i < m; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(picture[i][j] == 'B') {\n                row[i]++;\n                col[j]++;\n            }\n        }\n    }\n    \n    int lonely = 0;\n    for(int i = 0; i < m; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(picture[i][j] == 'B' && row[i] == 1 && col[j] == 1) {\n                lonely++;\n            }\n        }\n    }\n    \n    return lonely;\n}\n",
            "python": "def findLonelyPixel(picture):\n    m, n = len(picture), len(picture[0])\n    row, col = [0] * m, [0] * n\n    \n    for i in range(m):\n        for j in range(n):\n            if picture[i][j] == 'B':\n                row[i] += 1\n                col[j] += 1\n                \n    lonely = 0\n    for i in range(m):\n        for j in range(n):\n            if picture[i][j] == 'B' and row[i] == 1 and col[j] == 1:\n                lonely += 1\n                \n    return lonely\n",
            "javascript": "function findLonelyPixel(picture) {\n    let m = picture.length, n = picture[0].length;\n    let row = new Array(m).fill(0), col = new Array(n).fill(0);\n    \n    for(let i = 0; i < m; ++i) {\n        for(let j = 0; j < n; ++j) {\n            if(picture[i][j] == 'B') {\n                row[i]++;\n                col[j]++;\n            }\n        }\n    }\n    \n    let lonely = 0;\n    for(let i = 0; i < m; ++i) {\n        for(let j = 0; j < n; ++j) {\n            if(picture[i][j] == 'B' && row[i] == 1 && col[j] == 1) {\n                lonely++;\n            }\n        }\n    }\n    \n    return lonely;\n}\n",
            "explanation": "The algorithm for each of the above implementations is the same, so I will explain it at a high level. In this problem, we are given a picture of black and white pixels, and we want to find the number of black lonely pixels. A black lonely pixel is a pixel that has no other adjacent black pixels in the same row or column.\n\nTo count the number of black pixels in each row and column, we can create two arrays: one for rows (with the length equal to the number of rows in the picture) and one for columns (with the length equal to the number of columns in the picture). We then traverse through the picture, and for each black pixel we see, we increment the respective row and column counts in our row and column arrays.\n\nAfter we have counted the number of black pixels in each row and column, we can traverse the picture again to find lonely pixels. For each black pixel, we check if it is a lonely pixel by confirming that the row count and the column count for that pixel are both equal to 1. If we find such a pixel, we increment the lonely count.\n\nAt the end, we return the total count of lonely pixels found during the traversal.\n\nThis algorithm runs in O(m * n) time, where m is the number of rows and n is the number of columns in the picture."
        },
        "structure": {
            "c++": "int findLonelyPixel(vector<vector<char>>& picture) \n    // Your code here\n}\n",
            "java": "public int findLonelyPixel(char[][] picture) \n    // Your code here\n}\n",
            "python": "def findLonelyPixel(picture):\n    # Your code here\n\n",
            "javascript": "function findLonelyPixel(picture) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int findLonelyPixel(vector<vector<char>>& picture) {\n    int m = picture.size(), n = picture[0].size();\n    vector<int> row(m, 0), col(n, 0);\n    \n    for(int i = 0; i < m; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(picture[i][j] == 'B') {\n                row[i]++;\n                col[j]++;\n            }\n        }\n    }\n    \n    int lonely = 0;\n    for(int i = 0; i < m; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(picture[i][j] == 'B' && row[i] == 1 && col[j] == 1) {\n                lonely++;\n            }\n        }\n    }\n    \n    return lonely;\n}",
            "java": "public int findLonelyPixel(char[][] picture) {\n    int m = picture.length, n = picture[0].length;\n    int[] row = new int[m], col = new int[n];\n    \n    for(int i = 0; i < m; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(picture[i][j] == 'B') {\n                row[i]++;\n                col[j]++;\n            }\n        }\n    }\n    \n    int lonely = 0;\n    for(int i = 0; i < m; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(picture[i][j] == 'B' && row[i] == 1 && col[j] == 1) {\n                lonely++;\n            }\n        }\n    }\n    \n    return lonely;\n}",
            "python": "if __name__ == \"__main__\":\n    picture = $args[0]\n    result = findLonelyPixel(picture)\n    print(result)",
            "javascript": "function main() {\n    const picture = $args;\n    const result = findLonelyPixel(picture);\n    console.log(result);\n}"
        }
    },
    "532": {
        "title": "K-Diff Pairs in an Array",
        "description": "Given an array of integers `nums` and an integer `k`, return the number of unique k-diff pairs in the array. A k-diff pair is an integer pair `(nums[i], nums[j])`, where the following are true: \n\n- `0 <= i, j < nums.length` \n- `i != j` \n- `nums[i] - nums[j] == k` \n\nNotice that `|val|` denotes the absolute value of `val`.",
        "example": "Example 1:\n\nInput: nums = [3,1,4,1,5], k = 2\nOutput: 2\nExplanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5). Although we have two 1s in the input, we should only return the number of unique pairs.\n\nExample 2:\n\nInput: nums = [1,2,3,4,5], k = 1\nOutput: 4\nExplanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).\n\nExample 3:\n\nInput: nums = [1,3,1,5,4], k = 0\nOutput: 1\nExplanation: There is one 0-diff pair in the array, (1, 1).",
        "level": "Easy",
        "tags": [
            "array",
            "hash table",
            "two pointers"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    1,
                    4,
                    1,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    3,
                    1,
                    5,
                    4
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ]
            ],
            "outputs": [
                "2",
                "4",
                "1",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0"
            ]
        },
        "sample_code": {
            "c++": "#include <unordered_set>\n#include <unordered_map>\nint findPairs(vector<int>& nums, int k) {\n    if (k < 0) return 0;\n    unordered_set<int> starters;\n    unordered_map<int, int> occurrences;\n    for (int num : nums) {\n        if (occurrences.count(num + k)) starters.insert(num);\n        if (occurrences.count(num - k)) starters.insert(num - k);\n        occurrences[num]++;\n    }\n    return starters.size();\n}\n",
            "java": "import java.util.HashMap;\nimport java.util.HashSet;\n\npublic int findPairs(int[] nums, int k) {\n    if (k < 0) return 0;\n    HashSet<Integer> starters = new HashSet<>();\n    HashMap<Integer, Integer> occurrences = new HashMap<>();\n    for (int num : nums) {\n        if (occurrences.containsKey(num + k)) starters.add(num);\n        if (occurrences.containsKey(num - k)) starters.add(num - k);\n        occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);\n    }\n    return starters.size();\n}\n",
            "python": "def find_pairs(nums, k):\n    if k < 0:\n        return 0\n    starters = set()\n    occurrences = {}\n    for num in nums:\n        if num + k in occurrences:\n            starters.add(num)\n        if num - k in occurrences:\n            starters.add(num - k)\n        occurrences[num] = occurrences.get(num, 0) + 1\n    return len(starters)\n",
            "javascript": "function findPairs(nums, k) {\n    if (k < 0) return 0;\n    let starters = new Set();\n    let occurrences = new Map();\n    for (let num of nums) {\n        if (occurrences.has(num + k)) starters.add(num);\n        if (occurrences.has(num - k)) starters.add(num - k);\n        occurrences.set(num, (occurrences.get(num) || 0) + 1);\n    }\n    return starters.size;\n}\n",
            "explanation": "1. If k is less than 0, return 0 as there are no pairs with a negative difference.\n2. Initialize an empty set called `starters` to store the unique starting elements of k-diff pairs.\n3. Initialize an empty map called `occurrences` to store the occurrences of each number in the input array.\n4. Iterate through the input array, and for each number, check if the number + k exists in occurrences, and the number - k exists in occurrences.\n5. If either condition is true, add the corresponding starting element of the k-diff pair to the starters set, and update the occurrences map with the current number.\n6. After iterating through the input array, return the size of the starters set, as it represents the number of unique k-diff pairs."
        },
        "structure": {
            "c++": "#include <unordered_set>\n#include <unordered_map>\nint findPairs(vector<int>& nums, int k) \n    // Your code here\n}\n",
            "java": "import java.util.HashMap;\nimport java.util.HashSet;\n\npublic int findPairs(int[] nums, int k) \n    // Your code here\n}\n",
            "python": "def find_pairs(nums, k):\n    # Your code here\n\n",
            "javascript": "function findPairs(nums, k) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <unordered_set>\n#include <unordered_map>\n\nint findPairs(vector<int>& nums, int k) {\n    if (k < 0) return 0;\n    unordered_set<int> starters;\n    unordered_map<int, int> occurrences;\n    for (int num : nums) {\n        if (occurrences.count(num + k)) starters.insert(num);\n        if (occurrences.count(num - k)) starters.insert(num - k);\n        occurrences[num]++;\n    }\n    return starters.size();\n}\n\nint main() {\n    vector<int> nums = $args;\n    int k = $args;\n    int result = findPairs(nums, k);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int findPairs(int[] nums, int k) {\n    if (k < 0) return 0;\n    HashSet<Integer> starters = new HashSet<>();\n    HashMap<Integer, Integer> occurrences = new HashMap<>();\n    for (int num : nums) {\n        if (occurrences.containsKey(num + k)) starters.add(num);\n        if (occurrences.containsKey(num - k)) starters.add(num - k);\n        occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);\n    }\n    return starters.size();\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    k = $args[1]\n    result = find_pairs(nums, k)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args[0];\n    const k = $args[1];\n    const result = findPairs(nums, k);\n    console.log(result);\n}"
        }
    },
    "533": {
        "title": "Black Lonely Pixels",
        "description": "Given an `m x n` picture consisting of black 'B' and white 'W' pixels and an integer target, return the number of black lonely pixels. A black lonely pixel is a character 'B' that is located at a specific position `(r, c)` where row `r` and column `c` both contain exactly `target` black pixels. Additionally, for all rows that have a black pixel at column `c`, they should be exactly the same as row `r`.",
        "example": "Example:\n\nInput: picture = [['W', 'B', 'W', 'B', 'B', 'W'], ['W', 'B', 'W', 'B', 'B', 'W'], ['W', 'B', 'W', 'B', 'B', 'W'], ['W', 'W', 'B', 'W', 'B', 'W']], target = 3\nOutput: 6\nExplanation: All the green 'B' are the black pixels we need (all 'B's at column 1 and 3). Take 'B' at row r = 0 and column c = 1 as an example: Rule 1, row r = 0 and column c = 1 both have exactly target = 3 black pixels. Rule 2, the rows have black pixel at column c = 1 are row 0, row 1 and row 2. They are exactly the same as row r = 0.",
        "level": "Medium",
        "tags": [
            "matrix",
            "counting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        [
                            "W",
                            "B",
                            "W",
                            "B",
                            "B",
                            "W"
                        ],
                        [
                            "W",
                            "B",
                            "W",
                            "B",
                            "B",
                            "W"
                        ],
                        [
                            "W",
                            "B",
                            "W",
                            "B",
                            "B",
                            "W"
                        ],
                        [
                            "W",
                            "W",
                            "B",
                            "W",
                            "B",
                            "W"
                        ]
                    ],
                    3
                ],
                [
                    [
                        [
                            "W",
                            "W",
                            "B"
                        ],
                        [
                            "W",
                            "W",
                            "B"
                        ],
                        [
                            "W",
                            "W",
                            "B"
                        ]
                    ],
                    1
                ],
                [
                    [
                        [
                            "B",
                            "B",
                            "B"
                        ],
                        [
                            "B",
                            "B",
                            "B"
                        ],
                        [
                            "B",
                            "B",
                            "B"
                        ]
                    ],
                    3
                ],
                [
                    [
                        [
                            "W",
                            "W",
                            "W"
                        ],
                        [
                            "W",
                            "W",
                            "W"
                        ],
                        [
                            "W",
                            "W",
                            "W"
                        ]
                    ],
                    0
                ],
                [
                    [
                        [
                            "B",
                            "W",
                            "B"
                        ],
                        [
                            "W",
                            "B",
                            "W"
                        ],
                        [
                            "B",
                            "W",
                            "B"
                        ]
                    ],
                    1
                ],
                [
                    [
                        [
                            "B",
                            "B",
                            "B"
                        ],
                        [
                            "B",
                            "W",
                            "B"
                        ],
                        [
                            "B",
                            "B",
                            "B"
                        ]
                    ],
                    2
                ],
                [
                    [
                        [
                            "B",
                            "B",
                            "B"
                        ],
                        [
                            "B",
                            "B",
                            "B"
                        ],
                        [
                            "B",
                            "B",
                            "B"
                        ]
                    ],
                    1
                ],
                [
                    [
                        [
                            "W",
                            "W",
                            "W"
                        ],
                        [
                            "W",
                            "B",
                            "W"
                        ],
                        [
                            "W",
                            "W",
                            "W"
                        ]
                    ],
                    1
                ],
                [
                    [
                        [
                            "B",
                            "B",
                            "B"
                        ],
                        [
                            "B",
                            "B",
                            "B"
                        ],
                        [
                            "B",
                            "B",
                            "B"
                        ]
                    ],
                    0
                ],
                [
                    [
                        [
                            "W",
                            "W",
                            "W"
                        ],
                        [
                            "W",
                            "W",
                            "W"
                        ],
                        [
                            "W",
                            "W",
                            "W"
                        ]
                    ],
                    3
                ],
                [
                    [
                        [
                            "B",
                            "B",
                            "B"
                        ],
                        [
                            "B",
                            "B",
                            "B"
                        ],
                        [
                            "B",
                            "B",
                            "B"
                        ]
                    ],
                    2
                ],
                [
                    [
                        [
                            "W",
                            "W",
                            "W"
                        ],
                        [
                            "W",
                            "B",
                            "W"
                        ],
                        [
                            "W",
                            "W",
                            "W"
                        ]
                    ],
                    2
                ],
                [
                    [
                        [
                            "B",
                            "B",
                            "B"
                        ],
                        [
                            "B",
                            "B",
                            "B"
                        ],
                        [
                            "B",
                            "B",
                            "B"
                        ]
                    ],
                    1
                ],
                [
                    [
                        [
                            "W",
                            "W",
                            "W"
                        ],
                        [
                            "W",
                            "W",
                            "W"
                        ],
                        [
                            "W",
                            "W",
                            "W"
                        ]
                    ],
                    0
                ],
                [
                    [
                        [
                            "B",
                            "B",
                            "B"
                        ],
                        [
                            "B",
                            "B",
                            "B"
                        ],
                        [
                            "B",
                            "B",
                            "B"
                        ]
                    ],
                    3
                ],
                [
                    [
                        [
                            "W",
                            "W",
                            "W"
                        ],
                        [
                            "W",
                            "B",
                            "W"
                        ],
                        [
                            "W",
                            "W",
                            "W"
                        ]
                    ],
                    3
                ],
                [
                    [
                        [
                            "B",
                            "B",
                            "B"
                        ],
                        [
                            "B",
                            "B",
                            "B"
                        ],
                        [
                            "B",
                            "B",
                            "B"
                        ]
                    ],
                    2
                ],
                [
                    [
                        [
                            "W",
                            "W",
                            "W"
                        ],
                        [
                            "W",
                            "W",
                            "W"
                        ],
                        [
                            "W",
                            "W",
                            "W"
                        ]
                    ],
                    1
                ],
                [
                    [
                        [
                            "B",
                            "B",
                            "B"
                        ],
                        [
                            "B",
                            "B",
                            "B"
                        ],
                        [
                            "B",
                            "B",
                            "B"
                        ]
                    ],
                    0
                ],
                [
                    [
                        [
                            "W",
                            "W",
                            "W"
                        ],
                        [
                            "W",
                            "B",
                            "W"
                        ],
                        [
                            "W",
                            "W",
                            "W"
                        ]
                    ],
                    1
                ],
                [
                    [
                        [
                            "B",
                            "B",
                            "B"
                        ],
                        [
                            "B",
                            "B",
                            "B"
                        ],
                        [
                            "B",
                            "B",
                            "B"
                        ]
                    ],
                    2
                ]
            ],
            "outputs": [
                6,
                0,
                0,
                0,
                4,
                0,
                9,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "int findBlackPixel(vector<vector<char>>& picture, int target) {\n    int m = picture.size();\n    int n = picture[0].size();\n    vector<int> rows(m, 0), cols(n, 0);\n    unordered_map<string, int> rowCounts;\n    for (int i = 0; i < m; ++i) {\n        string row;\n        for (int j = 0; j < n; ++j) {\n            if (picture[i][j] == 'B') {\n                rows[i]++;\n                cols[j]++;\n            }\n            row.push_back(picture[i][j]);\n        }\n        if (rows[i] == target)\n            rowCounts[row]++;\n    }\n    int ans = 0;\n    for (auto &[row, count] : rowCounts) {\n        if (count == target) {\n            for (int j = 0; j < n; ++j) {\n                if (row[j] == 'B' && cols[j] == target)\n                    ans += count;\n            }\n        }\n    }\n    return ans;\n}\n",
            "java": "public int findBlackPixel(char[][] picture, int target) {\n    int m = picture.length;\n    int n = picture[0].length;\n    int[] rows = new int[m];\n    int[] cols = new int[n];\n    Map<String, Integer> rowCounts = new HashMap<>();\n    for (int i = 0; i < m; ++i) {\n        StringBuilder row = new StringBuilder();\n        for (int j = 0; j < n; ++j) {\n            if (picture[i][j] == 'B') {\n                rows[i]++;\n                cols[j]++;\n            }\n            row.append(picture[i][j]);\n        }\n        String rowStr = row.toString();\n        if (rows[i] == target)\n            rowCounts.put(rowStr, rowCounts.getOrDefault(rowStr, 0) + 1);\n    }\n    int ans = 0;\n    for (Map.Entry<String, Integer> entry : rowCounts.entrySet()) {\n        String row = entry.getKey();\n        int count = entry.getValue();\n        if (count == target) {\n            for (int j = 0; j < n; ++j) {\n                if (row.charAt(j) == 'B' && cols[j] == target)\n                    ans += count;\n            }\n        }\n    }\n    return ans;\n}\n",
            "python": "def findBlackPixel(picture, target):\n    m, n = len(picture), len(picture[0])\n    rows = [0] * m\n    cols = [0] * n\n    rowCounts = {}\n    for i in range(m):\n        row = \"\"\n        for j in range(n):\n            if picture[i][j] == 'B':\n                rows[i] += 1\n                cols[j] += 1\n            row += picture[i][j]\n        if rows[i] == target:\n            rowCounts[row] = rowCounts.get(row, 0) + 1\n    ans = 0\n    for row, count in rowCounts.items():\n        if count == target:\n            for j in range(n):\n                if row[j] == 'B' and cols[j] == target:\n                    ans += count\n    return ans\n",
            "javascript": "function findBlackPixel(picture, target) {\n    const m = picture.length;\n    const n = picture[0].length;\n    const rows = new Array(m).fill(0);\n    const cols = new Array(n).fill(0);\n    const rowCounts = new Map();\n    for (let i = 0; i < m; ++i) {\n        let row = \"\";\n        for (let j = 0; j < n; ++j) {\n            if (picture[i][j] === 'B') {\n                rows[i]++;\n                cols[j]++;\n            }\n            row += picture[i][j];\n        }\n        if (rows[i] === target)\n            rowCounts.set(row, (rowCounts.get(row) || 0) + 1);\n    }\n    let ans = 0;\n    for (let [row, count] of rowCounts.entries()) {\n        if (count === target) {\n            for (let j = 0; j < n; ++j) {\n                if (row[j] === 'B' && cols[j] === target)\n                    ans += count;\n            }\n        }\n    }\n    return ans;\n}\n",
            "explanation": "1. Count the number of 'B' pixels in each row and column, and store the string representation of each valid row (rows containing `target` 'B' pixels) with a count in a hashmap.\n2. Iterate over the valid rows with their counts, and for each of them check the columns where 'B' is present. If that column also has exactly `target` 'B' pixels, increment the answer by the count of that row.\n3. Return the answer (total number of lonely black pixels)."
        },
        "structure": {
            "c++": "int findBlackPixel(vector<vector<char>>& picture, int target) \n    // Your code here\n}\n",
            "java": "public int findBlackPixel(char[][] picture, int target) \n    // Your code here\n}\n",
            "python": "def findBlackPixel(picture, target):\n    # Your code here\n\n",
            "javascript": "function findBlackPixel(picture, target) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int findBlackPixel(vector<vector<char>>& picture, int target) {\n    int m = picture.size();\n    int n = picture[0].size();\n    vector<int> rows(m, 0), cols(n, 0);\n    unordered_map<string, int> rowCounts;\n    for (int i = 0; i < m; ++i) {\n        string row;\n        for (int j = 0; j < n; ++j) {\n            if (picture[i][j] == 'B') {\n                rows[i]++;\n                cols[j]++;\n            }\n            row.push_back(picture[i][j]);\n        }\n        if (rows[i] == target)\n            rowCounts[row]++;\n    }\n    int ans = 0;\n    for (auto &[row, count] : rowCounts) {\n        if (count == target) {\n            for (int j = 0; j < n; ++j) {\n                if (row[j] == 'B' && cols[j] == target)\n                    ans += count;\n            }\n        }\n    }\n    return ans;\n}",
            "java": "public int findBlackPixel(char[][] picture, int target) {\n    int m = picture.length;\n    int n = picture[0].length;\n    int[] rows = new int[m];\n    int[] cols = new int[n];\n    Map<String, Integer> rowCounts = new HashMap<>();\n    for (int i = 0; i < m; ++i) {\n        StringBuilder row = new StringBuilder();\n        for (int j = 0; j < n; ++j) {\n            if (picture[i][j] == 'B') {\n                rows[i]++;\n                cols[j]++;\n            }\n            row.append(picture[i][j]);\n        }\n        String rowStr = row.toString();\n        if (rows[i] == target)\n            rowCounts.put(rowStr, rowCounts.getOrDefault(rowStr, 0) + 1);\n    }\n    int ans = 0;\n    for (Map.Entry<String, Integer> entry : rowCounts.entrySet()) {\n        String row = entry.getKey();\n        int count = entry.getValue();\n        if (count == target) {\n            for (int j = 0; j < n; ++j) {\n                if (row.charAt(j) == 'B' && cols[j] == target)\n                    ans += count;\n            }\n        }\n    }\n    return ans;\n}",
            "python": "if __name__ == \"__main__\":\n    picture = $args[0]\n    target = $args[1]\n    result = findBlackPixel(picture, target)\n    print(result)",
            "javascript": "function findBlackPixel(picture, target) {\n    const m = picture.length;\n    const n = picture[0].length;\n    const rows = new Array(m).fill(0);\n    const cols = new Array(n).fill(0);\n    const rowCounts = new Map();\n    for (let i = 0; i < m; ++i) {\n        let row = \"\";\n        for (let j = 0; j < n; ++j) {\n            if (picture[i][j] === 'B') {\n                rows[i]++;\n                cols[j]++;\n            }\n            row += picture[i][j];\n        }\n        if (rows[i] === target)\n            rowCounts.set(row, (rowCounts.get(row) || 0) + 1);\n    }\n    let ans = 0;\n    for (let [row, count] of rowCounts.entries()) {\n        if (count === target) {\n            for (let j = 0; j < n; ++j) {\n                if (row[j] === 'B' && cols[j] === target)\n                    ans += count;\n            }\n        }\n    }\n    return ans;\n}"
        }
    },
    "535": {
        "title": "URL Encoder and Decoder",
        "description": "Design a class that can encode a given URL into a tiny URL and decode a tiny URL back to the original URL. The class should be able to handle any valid URL and ensure that the encoding and decoding process is reversible.",
        "example": "Example:\n\nInput:\nurl = \"https://leetcode.com/problems/design-tinyurl\"\n\nOutput:\n\"https://leetcode.com/problems/design-tinyurl\"\n\nExplanation:\nSolution obj = new Solution();\nstring tiny = obj.encode(url); // returns the encoded tiny url.\nstring ans = obj.decode(tiny); // returns the original url after decoding it.",
        "level": "Medium",
        "tags": [
            "System Design",
            "Encoding",
            "Decoding"
        ],
        "test_cases": {
            "inputs": [
                "\"https://leetcode.com/problems/design-tinyurl\"",
                "\"https://www.google.com\"",
                "\"https://www.amazon.com\"",
                "\"https://www.facebook.com\"",
                "\"https://www.twitter.com\"",
                "\"https://www.instagram.com\"",
                "\"https://www.linkedin.com\"",
                "\"https://www.youtube.com\"",
                "\"https://www.netflix.com\"",
                "\"https://www.spotify.com\"",
                "\"https://www.apple.com\"",
                "\"https://www.microsoft.com\"",
                "\"https://www.oracle.com\"",
                "\"https://www.ibm.com\"",
                "\"https://www.adobe.com\"",
                "\"https://www.wikipedia.org\"",
                "\"https://www.reddit.com\"",
                "\"https://www.pinterest.com\"",
                "\"https://www.tumblr.com\"",
                "\"https://www.github.com\""
            ],
            "outputs": [
                "\"https://leetcode.com/problems/design-tinyurl\"",
                "\"https://www.google.com\"",
                "\"https://www.amazon.com\"",
                "\"https://www.facebook.com\"",
                "\"https://www.twitter.com\"",
                "\"https://www.instagram.com\"",
                "\"https://www.linkedin.com\"",
                "\"https://www.youtube.com\"",
                "\"https://www.netflix.com\"",
                "\"https://www.spotify.com\"",
                "\"https://www.apple.com\"",
                "\"https://www.microsoft.com\"",
                "\"https://www.oracle.com\"",
                "\"https://www.ibm.com\"",
                "\"https://www.adobe.com\"",
                "\"https://www.wikipedia.org\"",
                "\"https://www.reddit.com\"",
                "\"https://www.pinterest.com\"",
                "\"https://www.tumblr.com\"",
                "\"https://www.github.com\""
            ]
        },
        "sample_code": {
            "c++": "#include <unordered_map>\n#include <string>\n#include <random>\n\nclass Solution {\npublic:\n    std::unordered_map<std::string, std::string> map;\n    std::string alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\n    // Encodes a URL to a shortened URL.\n    std::string encode(std::string longUrl) {\n        std::string key;\n        while (true) {\n            key.clear();\n            for (int i = 0; i < 6; i++) {\n                key += alphabet[rand() % alphabet.length()];\n            }\n            if (map.count(key) == 0) {\n                map[key] = longUrl;\n                break;\n            }\n        }\n        return \"http://tinyurl.com/\" + key;\n    }\n\n    // Decodes a shortened URL to its original URL.\n    std::string decode(std::string shortUrl) {\n        return map[shortUrl.substr(19, 6)];\n    }\n};\n",
            "java": "import java.util.HashMap;\nimport java.util.Random;\n\npublic class Solution {\n    HashMap<String, String> urlMap = new HashMap<>();\n    String alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\n    public String encode(String longUrl) {\n        StringBuilder keyBuilder;\n        String key;\n\n        do {\n            keyBuilder = new StringBuilder();\n\n            for (int i = 0; i < 6; i++) {\n                keyBuilder.append(alphabet.charAt(new Random().nextInt(alphabet.length())));\n            }\n\n            key = keyBuilder.toString();\n        } while (urlMap.containsKey(key));\n\n        urlMap.put(key, longUrl);\n        return \"http://tinyurl.com/\" + key;\n    }\n\n    public String decode(String shortUrl) {\n        return urlMap.get(shortUrl.substring(19));\n    }\n}\n",
            "python": "import random\nimport string\n\nclass Solution:\n    def __init__(self):\n        self.url_map = {}\n        self.alphabet = string.ascii_letters + string.digits\n\n    def encode(self, longUrl: str) -> str:\n        key = ''.join(random.choices(self.alphabet, k=6))\n\n        while key in self.url_map:\n            key = ''.join(random.choices(self.alphabet, k=6))\n\n        self.url_map[key] = longUrl\n        return \"http://tinyurl.com/\" + key\n\n    def decode(self, shortUrl: str) -> str:\n        return self.url_map[shortUrl[-6:]]\n",
            "javascript": "class Solution {\n    constructor() {\n        this.urlMap = new Map();\n        this.alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    }\n\n    encode(longUrl) {\n        let key;\n\n        do {\n            key = Array.from({ length: 6 }, () => this.alphabet.charAt(Math.floor(Math.random() * this.alphabet.length))).join('');\n        } while (this.urlMap.has(key));\n\n        this.urlMap.set(key, longUrl);\n\n        return 'http://tinyurl.com/' + key;\n    }\n\n    decode(shortUrl) {\n        return this.urlMap.get(shortUrl.substr(-6));\n    }\n}\n",
            "explanation": "The algorithm generates a random 6-character key using a combination of lowercase, uppercase letters, and digits. It then checks if the generated key already exists in the mapping. If not, it adds the long URL and its corresponding key into the mapping. The shortened URL is created by appending the key to a fixed base URL (e.g., \"http://tinyurl.com/\"). When decoding, it obtains the key from the given shortened URL and looks up the original long URL from the mapping. This algorithm ensures that every long URL has its unique shortened URL, and it's capable of encoding and decoding URLs successfully."
        },
        "structure": {
            "c++": "#include <unordered_map>\n#include <string>\n#include <random>\n\nclass Solution \n    // Your code here\n};\n",
            "java": "import java.util.HashMap;\nimport java.util.Random;\n\npublic class Solution \n    // Your code here\n}\n",
            "python": "import random\n    # Your code here\n\n",
            "javascript": "class Solution \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <unordered_map>\n#include <string>\n#include <random>\n\nint main() {\n    std::string longUrl = $args;\n    Solution obj;\n    std::string result = obj.encode(longUrl);\n    std::cout << result << std::endl;\n    std::string originalUrl = obj.decode(result);\n    std::cout << originalUrl << std::endl;\n    return 0;\n}",
            "java": "public String encode(String longUrl) {\n        StringBuilder keyBuilder;\n        String key;\n\n        do {\n            keyBuilder = new StringBuilder();\n\n            for (int i = 0; i < 6; i++) {\n                keyBuilder.append(alphabet.charAt(new Random().nextInt(alphabet.length())));\n            }\n\n            key = keyBuilder.toString();\n        } while (urlMap.containsKey(key));\n\n        urlMap.put(key, longUrl);\n        return \"http://tinyurl.com/\" + key;\n    }\n\n    public String decode(String shortUrl) {\n        return urlMap.get(shortUrl.substring(19));\n    }",
            "python": "if __name__ == \"__main__\":\n    longUrl = $args[0]\n    shortUrl = $args[1]\n    solution = Solution()\n    encoded_url = solution.encode(longUrl)\n    decoded_url = solution.decode(shortUrl)\n    print(encoded_url)\n    print(decoded_url)",
            "javascript": "function main() {\n    const longUrl = $args;\n    const solution = new Solution();\n    const shortUrl = solution.encode(longUrl);\n    const decodedUrl = solution.decode(shortUrl);\n    console.log(decodedUrl);\n}"
        }
    },
    "537": {
        "title": "Complex Number Multiplication",
        "description": "Given two complex numbers `num1` and `num2` as strings, return a string of the complex number that represents their multiplications. A complex number can be represented as a string on the form `\"real+imaginaryi\"` where `real` is the real part and is an integer in the range [-100, 100], `imaginary` is the imaginary part and is an integer in the range [-100, 100], and `i^2 == -1`.",
        "example": "Example:\n\nInput: num1 = \"1+1i\", num2 = \"1+1i\"\nOutput: \"0+2i\"\nExplanation: (1 + i) * (1 + i) = 1 + i^2 + 2i = 2i, and you need to convert it to the form of 0+2i.",
        "level": "Easy",
        "tags": [
            "complex numbers",
            "string manipulation"
        ],
        "test_cases": {
            "inputs": [
                "\"1+1i\"",
                "\"1+-1i\"",
                "\"2+3i\"",
                "\"-4+2i\"",
                "\"0+0i\"",
                "\"100+100i\"",
                "\"-100-100i\"",
                "\"50+0i\"",
                "\"0+75i\"",
                "\"-25+75i\"",
                "\"-75-25i\"",
                "\"-50+50i\"",
                "\"-50-50i\"",
                "\"-75+25i\"",
                "\"75-25i\"",
                "\"-100+0i\"",
                "\"0-100i\"",
                "\"100-100i\"",
                "\"-100+100i\"",
                "\"100+0i\""
            ],
            "outputs": [
                "\"0+2i\"",
                "\"0+-2i\"",
                "\"-6+7i\"",
                "\"-8-16i\"",
                "\"0+0i\"",
                "\"20000+0i\"",
                "\"20000+0i\"",
                "\"100+0i\"",
                "\"0+7500i\"",
                "\"-7500+22500i\"",
                "\"-22500-7500i\"",
                "\"-5000+5000i\"",
                "\"-5000-5000i\"",
                "\"-7500+2500i\"",
                "\"7500-2500i\"",
                "\"0+10000i\"",
                "\"0-10000i\"",
                "\"20000-20000i\"",
                "\"-20000+20000i\"",
                "\"10000+0i\""
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <sstream>\n\nstd::string complexNumberMultiply(std::string num1, std::string num2) {\n    int real1, imag1, real2, imag2;\n    sscanf(num1.c_str(), \"%d+%di\", &real1, &imag1);\n    sscanf(num2.c_str(), \"%d+%di\", &real2, &imag2);\n   \n    int real = real1 * real2 - imag1 * imag2;\n    int imag = real1 * imag2 + real2 * imag1;\n   \n    return std::to_string(real) + \"+\" + std::to_string(imag) + \"i\";\n}\n",
            "java": "public String complexNumberMultiply(String num1, String num2) {\n    String[] tokens1 = num1.split(\"\\\\+|i\");\n    String[] tokens2 = num2.split(\"\\\\+|i\");\n    int real1 = Integer.parseInt(tokens1[0]);\n    int imag1 = Integer.parseInt(tokens1[1]);\n    int real2 = Integer.parseInt(tokens2[0]);\n    int imag2 = Integer.parseInt(tokens2[1]);\n\n    int real = real1 * real2 - imag1 * imag2;\n    int imag = real1 * imag2 + real2 * imag1;\n\n    return real + \"+\" + imag + \"i\";\n}\n",
            "python": "def complexNumberMultiply(num1: str, num2: str) -> str:\n    real1, imag1 = map(int, num1[:-1].split('+'))\n    real2, imag2 = map(int, num2[:-1].split('+'))\n\n    real = real1 * real2 - imag1 * imag2\n    imag = real1 * imag2 + real2 * imag1\n\n    return f\"{real}+{imag}i\"\n",
            "javascript": "function complexNumberMultiply(num1, num2) {\n    const [real1, imag1] = num1.slice(0, -1).split('+').map(Number);\n    const [real2, imag2] = num2.slice(0, -1).split('+').map(Number);\n\n    const real = real1 * real2 - imag1 * imag2;\n    const imag = real1 * imag2 + real2 * imag1;\n\n    return `${real}+${imag}i`;\n}\n",
            "explanation": "The algorithm first extracts the real and imaginary parts of the input complex numbers. In C++, sscanf is used to read formatted data from a string. In Java, we use split with a regex that matches both \"+\" and \"i\". In Python and JavaScript, we use split and map for the conversions.\n\nOnce we have real and imaginary parts of both numbers, we multiply the complex numbers using the formula:\n(real1 * real2 - imag1 * imag2) + (real1 * imag2 + real2 * imag1)i\n\nFinally, we convert the result into a string in the required format and return it."
        },
        "structure": {
            "c++": "#include <string>\n#include <sstream>\n\nstd::string complexNumberMultiply(std::string num1, std::string num2) \n    // Your code here\n}\n",
            "java": "public String complexNumberMultiply(String num1, String num2) \n    // Your code here\n}\n",
            "python": "def complexNumberMultiply(num1: str, num2: str) -> str:\n    # Your code here\n\n",
            "javascript": "function complexNumberMultiply(num1, num2) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <sstream>\n\nint main() {\n    std::string num1 = $args;\n    std::string num2 = $args;\n    std::string result = complexNumberMultiply(num1, num2);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public String complexNumberMultiply(String num1, String num2) {\n    String[] tokens1 = num1.split(\"\\\\+|i\");\n    String[] tokens2 = num2.split(\"\\\\+|i\");\n    int real1 = Integer.parseInt(tokens1[0]);\n    int imag1 = Integer.parseInt(tokens1[1]);\n    int real2 = Integer.parseInt(tokens2[0]);\n    int imag2 = Integer.parseInt(tokens2[1]);\n\n    int real = real1 * real2 - imag1 * imag2;\n    int imag = real1 * imag2 + real2 * imag1;\n\n    return real + \"+\" + imag + \"i\";\n}",
            "python": "if __name__ == \"__main__\":\n    num1 = $args[0]\n    num2 = $args[1]\n    result = complexNumberMultiply(num1, num2)\n    print(result)",
            "javascript": "function main() {\n    const num1 = $args[0];\n    const num2 = $args[1];\n    const result = complexNumberMultiply(num1, num2);\n    console.log(result);\n}"
        }
    },
    "539": {
        "title": "Minimum Minutes Difference",
        "description": "Given a list of 24-hour clock time points in \"HH:MM\" format, return the minimum minutes difference between any two time-points in the list.",
        "example": "Example:\n\nInput: timePoints = [\"23:59\",\"00:00\"]\nOutput: 1\n\nExplanation: The minimum minutes difference is 1 minute between the time points 23:59 and 00:00.",
        "level": "Easy",
        "tags": [
            "array",
            "string"
        ],
        "test_cases": {
            "inputs": [
                [
                    "23:59",
                    "00:00"
                ],
                [
                    "00:00",
                    "23:59",
                    "00:00"
                ],
                [
                    "12:00",
                    "12:01",
                    "12:02",
                    "12:03"
                ],
                [
                    "01:00",
                    "02:00",
                    "03:00",
                    "04:00"
                ],
                [
                    "10:00",
                    "11:00",
                    "12:00",
                    "13:00",
                    "14:00"
                ],
                [
                    "00:00",
                    "00:01",
                    "00:02",
                    "00:03",
                    "00:04",
                    "00:05"
                ],
                [
                    "23:59",
                    "00:01",
                    "00:02",
                    "00:03",
                    "00:04",
                    "00:05"
                ],
                [
                    "12:00",
                    "12:00",
                    "12:00",
                    "12:00",
                    "12:00"
                ],
                [
                    "01:00",
                    "01:00",
                    "01:00",
                    "01:00",
                    "01:00"
                ],
                [
                    "10:00",
                    "10:00",
                    "10:00",
                    "10:00",
                    "10:00"
                ],
                [
                    "00:00",
                    "00:00",
                    "00:00",
                    "00:00",
                    "00:00"
                ],
                [
                    "23:59",
                    "23:59",
                    "23:59",
                    "23:59",
                    "23:59"
                ],
                [
                    "12:00",
                    "12:00",
                    "12:00",
                    "12:00",
                    "12:00"
                ],
                [
                    "01:00",
                    "01:00",
                    "01:00",
                    "01:00",
                    "01:00"
                ],
                [
                    "10:00",
                    "10:00",
                    "10:00",
                    "10:00",
                    "10:00"
                ],
                [
                    "00:00",
                    "00:00",
                    "00:00",
                    "00:00",
                    "00:00"
                ],
                [
                    "23:59",
                    "23:59",
                    "23:59",
                    "23:59",
                    "23:59"
                ],
                [
                    "12:00",
                    "12:00",
                    "12:00",
                    "12:00",
                    "12:00"
                ],
                [
                    "01:00",
                    "01:00",
                    "01:00",
                    "01:00",
                    "01:00"
                ],
                [
                    "10:00",
                    "10:00",
                    "10:00",
                    "10:00",
                    "10:00"
                ]
            ],
            "outputs": [
                1,
                0,
                1,
                60,
                60,
                1,
                2,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <algorithm>\n#include <climits>\n\nint findMinDifference(std::vector<std::string>& timePoints) {\n    std::sort(timePoints.begin(), timePoints.end());\n    int minDifference = INT_MAX;\n\n    for (int i = 0; i < timePoints.size(); ++i) {\n        int curDifference = abs((stoi(timePoints[i].substr(0, 2)) * 60 + stoi(timePoints[i].substr(3, 2))) - (stoi(timePoints[(i + 1) % timePoints.size()].substr(0, 2)) * 60 + stoi(timePoints[(i + 1) % timePoints.size()].substr(3, 2))));\n        minDifference = std::min(minDifference, curDifference > 720 ? 1440 - curDifference : curDifference);\n    }\n\n    return minDifference;\n}\n",
            "java": "import java.util.Collections;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic int findMinDifference(List<String> timePoints) {\n    Collections.sort(timePoints);\n    int minDifference = Integer.MAX_VALUE;\n\n    for (int i = 0; i < timePoints.size(); ++i) {\n        int curDifference = Math.abs((Integer.parseInt(timePoints.get(i).substring(0, 2)) * 60 + Integer.parseInt(timePoints.get(i).substring(3, 5))) - (Integer.parseInt(timePoints.get((i + 1) % timePoints.size()).substring(0, 2)) * 60 + Integer.parseInt(timePoints.get((i + 1) % timePoints.size()).substring(3, 5))));\n        minDifference = Math.min(minDifference, curDifference > 720 ? 1440 - curDifference : curDifference);\n    }\n\n    return minDifference;\n}\n",
            "python": "def findMinDifference(timePoints):\n    timePoints.sort()\n    min_difference = float('inf')\n\n    for i in range(len(timePoints)):\n        h1, m1 = map(int, timePoints[i].split(':'))\n        h2, m2 = map(int, timePoints[(i+1)%len(timePoints)].split(':'))\n        cur_difference = abs((h1 * 60 + m1) - (h2 * 60 + m2))\n        min_difference = min(min_difference, 1440 - cur_difference if cur_difference > 720 else cur_difference)\n\n    return min_difference\n",
            "javascript": "function findMinDifference(timePoints) {\n    timePoints.sort();\n    let minDifference = Infinity;\n\n    for (let i = 0; i < timePoints.length; ++i) {\n        const [h1, m1] = timePoints[i].split(':').map(Number);\n        const [h2, m2] = timePoints[(i + 1) % timePoints.length].split(':').map(Number);\n        const curDifference = Math.abs((h1 * 60 + m1) - (h2 * 60 + m2));\n        minDifference = Math.min(minDifference, curDifference > 720 ? 1440 - curDifference : curDifference);\n    }\n\n    return minDifference;\n}\n",
            "explanation": "1. Sort the given timePoints list.\n2. Initialize variable minDifference with the maximum value possible to keep track of the minimum difference.\n3. Loop through the timePoints list and for each pair of consecutive times (including the last time and the first time in the list):\n    - Calculate the absolute difference between the time in minutes.\n    - If the difference is greater than 720 (half of 1440 minutes in a day), take the complementary difference (i.e., 1440 - curDifference).\n    - Update the minDifference variable with the minimum of the previous minDifference and the calculated difference.\n4. After the loop, the minDifference variable will hold the minimum minutes difference between any two time-points in the list. Return it."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <algorithm>\n#include <climits>\n\nint findMinDifference(std::vector<std::string>& timePoints) \n    // Your code here\n}\n",
            "java": "import java.util.Collections;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic int findMinDifference(List<String> timePoints) \n    // Your code here\n}\n",
            "python": "def findMinDifference(timePoints):\n    # Your code here\n\n",
            "javascript": "function findMinDifference(timePoints) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <algorithm>\n#include <climits>\n#include <iostream>\n\nint main() {\n    std::vector<std::string> timePoints = $args;\n    int result = findMinDifference(timePoints);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int findMinDifference(List<String> timePoints) {\n    Collections.sort(timePoints);\n    int minDifference = Integer.MAX_VALUE;\n\n    for (int i = 0; i < timePoints.size(); ++i) {\n        int curDifference = Math.abs((Integer.parseInt(timePoints.get(i).substring(0, 2)) * 60 + Integer.parseInt(timePoints.get(i).substring(3, 5))) - (Integer.parseInt(timePoints.get((i + 1) % timePoints.size()).substring(0, 2)) * 60 + Integer.parseInt(timePoints.get((i + 1) % timePoints.size()).substring(3, 5))));\n        minDifference = Math.min(minDifference, curDifference > 720 ? 1440 - curDifference : curDifference);\n    }\n\n    return minDifference;\n}",
            "python": "if __name__ == \"__main__\":\n    timePoints = $args[0]\n    result = findMinDifference(timePoints)\n    print(result)",
            "javascript": "function findMinDifference(timePoints) {\n    timePoints.sort();\n    let minDifference = Infinity;\n\n    for (let i = 0; i < timePoints.length; ++i) {\n        const [h1, m1] = timePoints[i].split(':').map(Number);\n        const [h2, m2] = timePoints[(i + 1) % timePoints.length].split(':').map(Number);\n        const curDifference = Math.abs((h1 * 60 + m1) - (h2 * 60 + m2));\n        minDifference = Math.min(minDifference, curDifference > 720 ? 1440 - curDifference : curDifference);\n    }\n\n    return minDifference;\n}"
        }
    },
    "540": {
        "title": "Single Element in Sorted Array",
        "description": "You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Your task is to find and return the single element that appears only once. Implement a solution that runs in O(log n) time and O(1) space.",
        "example": "For example, given the array nums = [1,1,2,3,3,4,4,8,8], the single element that appears only once is 2. In another example, given the array nums = [3,3,7,7,10,11,11], the single element that appears only once is 10.",
        "level": "Medium",
        "tags": [
            "array",
            "binary search"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    1,
                    2,
                    3,
                    3,
                    4,
                    4,
                    8,
                    8
                ],
                [
                    3,
                    3,
                    7,
                    7,
                    10,
                    11,
                    11
                ],
                [
                    1,
                    1,
                    2,
                    2,
                    3,
                    3,
                    4,
                    4,
                    5,
                    5,
                    6
                ],
                [
                    2,
                    2,
                    4,
                    4,
                    6,
                    6,
                    8,
                    10,
                    10
                ],
                [
                    1,
                    2,
                    2,
                    3,
                    3,
                    4,
                    4,
                    5,
                    5
                ]
            ],
            "outputs": [
                2,
                10,
                6,
                8,
                1
            ]
        },
        "sample_code": {
            "c++": "int singleNonDuplicate(vector<int>& nums) {\n    int low = 0, high = nums.size() - 1;\n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        if (mid % 2 == 1)\n            mid--;\n        if (nums[mid] == nums[mid + 1])\n            low = mid + 2;\n        else\n            high = mid;\n    }\n    return nums[low];\n}\n",
            "java": "public int singleNonDuplicate(int[] nums) {\n    int low = 0, high = nums.length - 1;\n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        if (mid % 2 == 1)\n            mid--;\n        if (nums[mid] == nums[mid + 1])\n            low = mid + 2;\n        else\n            high = mid;\n    }\n    return nums[low];\n}\n",
            "python": "def singleNonDuplicate(nums):\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = low + (high - low) // 2\n        if mid % 2 == 1:\n            mid -= 1\n        if nums[mid] == nums[mid + 1]:\n            low = mid + 2\n        else:\n            high = mid\n    return nums[low]\n",
            "javascript": "function singleNonDuplicate(nums) {\n    let low = 0, high = nums.length - 1;\n    while (low < high) {\n        let mid = low + Math.floor((high - low) / 2);\n        if (mid % 2 === 1)\n            mid--;\n        if (nums[mid] === nums[mid + 1])\n            low = mid + 2;\n        else\n            high = mid;\n    }\n    return nums[low];\n}\n",
            "explanation": "The algorithm starts by initializing two pointers, `low` and `high`, to the start and end indices of the given array. Then, it enters a loop that continues until `low` is greater or equal to `high`. In each iteration, the algorithm calculates the index in the middle of the range `[low, high]` and checks if the middle index is odd. If it is, it subtracts 1 from it to make it even.\n\nThe algorithm then checks if the middle element is equal to the element immediately after it. If it is, it means that the single element is on the right side of the middle index, so it updates the `low` pointer to be `mid + 2`. Otherwise, it updates the `high` pointer to be `mid`.\n\nAfter the loop ends, the algorithm returns the element at the index stored in the `low` pointer, which is the single non-duplicate element."
        },
        "structure": {
            "c++": "int singleNonDuplicate(vector<int>& nums) \n    // Your code here\n}\n",
            "java": "public int singleNonDuplicate(int[] nums) \n    // Your code here\n}\n",
            "python": "def singleNonDuplicate(nums):\n    # Your code here\n\n",
            "javascript": "function singleNonDuplicate(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> nums = $args;\n    int result = singleNonDuplicate(nums);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int singleNonDuplicate(int[] nums) {\n    int low = 0, high = nums.length - 1;\n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        if (mid % 2 == 1)\n            mid--;\n        if (nums[mid] == nums[mid + 1])\n            low = mid + 2;\n        else\n            high = mid;\n    }\n    return nums[low];\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = singleNonDuplicate(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = singleNonDuplicate(nums);\n    console.log(result);\n}"
        }
    },
    "541": {
        "title": "Reverse String in Segments",
        "description": "Given a string `s` and an integer `k`, reverse the first `k` characters for every `2k` characters counting from the start of the string.\n\nIf there are fewer than `k` characters left, reverse all of them. If there are less than `2k` but greater than or equal to `k` characters, then reverse the first `k` characters and leave the other as original.",
        "example": "Example:\n\nInput: s = \"abcdefg\", k = 2\nOutput: \"bacdfeg\"\n\nExplanation: The string is divided into segments of length 2k = 4. The first segment \"abcd\" is reversed to \"bacd\". The second segment \"efg\" remains unchanged. The final result is \"bacdfeg\".",
        "level": "Easy",
        "tags": [
            "String",
            "Reverse"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "abcdefg",
                        2
                    ]
                ],
                [
                    [
                        "abcd",
                        2
                    ]
                ],
                [
                    [
                        "abcdefghijk",
                        3
                    ]
                ],
                [
                    [
                        "abcde",
                        1
                    ]
                ],
                [
                    [
                        "abcdefgh",
                        4
                    ]
                ],
                [
                    [
                        "a",
                        1
                    ]
                ],
                [
                    [
                        "",
                        2
                    ]
                ],
                [
                    [
                        "abcde",
                        3
                    ]
                ],
                [
                    [
                        "abcdefghijk",
                        4
                    ]
                ],
                [
                    [
                        "abcdefg",
                        3
                    ]
                ],
                [
                    [
                        "abcd",
                        3
                    ]
                ],
                [
                    [
                        "abcdefgh",
                        2
                    ]
                ],
                [
                    [
                        "a",
                        2
                    ]
                ],
                [
                    [
                        "",
                        1
                    ]
                ],
                [
                    [
                        "abcde",
                        4
                    ]
                ],
                [
                    [
                        "abcdefghijk",
                        5
                    ]
                ],
                [
                    [
                        "abcdefg",
                        4
                    ]
                ],
                [
                    [
                        "abcd",
                        4
                    ]
                ],
                [
                    [
                        "abcdefgh",
                        3
                    ]
                ],
                [
                    [
                        "a",
                        3
                    ]
                ]
            ],
            "outputs": [
                "\"bacdfeg\"",
                "\"bacd\"",
                "\"cbadefihgjk\"",
                "\"edcba\"",
                "\"dcbaefgh\"",
                "\"a\"",
                "\"\"",
                "\"edcba\"",
                "\"dcbaefghijk\"",
                "\"cbadefg\"",
                "\"cbadefg\"",
                "\"bacdefgh\"",
                "\"a\"",
                "\"\"",
                "\"edcba\"",
                "\"edcbafghijk\"",
                "\"dcbaefg\"",
                "\"dcba\"",
                "\"cbadefgh\"",
                "\"a\""
            ]
        },
        "sample_code": {
            "c++": "#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring reverseStr(string s, int k) {\n    for (int i = 0; i < s.size(); i += 2*k) {\n        if (i + k <= s.size()) {\n            reverse(s.begin() + i, s.begin() + i + k);\n        } else {\n            reverse(s.begin() + i, s.end());\n        }\n    }\n    return s;\n}\n",
            "java": "public String reverseStr(String s, int k) {\n    char[] chars = s.toCharArray();\n    for (int i = 0; i < chars.length; i += 2 * k) {\n        int left = i;\n        int right = Math.min(i + k - 1, chars.length - 1);\n        while (left < right) {\n            char temp = chars[left];\n            chars[left++] = chars[right];\n            chars[right--] = temp;\n        }\n    }\n    return new String(chars);\n}\n",
            "python": "def reverseStr(s, k):\n    chars = list(s)\n    for i in range(0, len(chars), 2 * k):\n        chars[i:i + k] = reversed(chars[i:i + k])\n    return \"\".join(chars)\n",
            "javascript": "function reverseStr(s, k) {\n    let chars = s.split(\"\");\n    for (let i = 0; i < chars.length; i += 2 * k) {\n        let left = i;\n        let right = Math.min(i + k - 1, chars.length - 1);\n        while (left < right) {\n            [chars[left++], chars[right--]] = [chars[right], chars[left]];\n        }\n    }\n    return chars.join(\"\");\n}\n",
            "explanation": "The algorithm first creates a mutable array from the original string. Then, we iterate over every 2k characters. If there are at least k characters remaining from the current position, we reverse the first k characters. Otherwise, we reverse all the remaining characters.\n\nIn C++, we use the `reverse` function that takes iterators as arguments. In Java, JavaScript, and Python, we use custom loops for reversing k characters, taking into account the case when there are fewer than k characters remaining. Then, we join the characters back into a string."
        },
        "structure": {
            "c++": "#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring reverseStr(string s, int k) \n    // Your code here\n}\n",
            "java": "public String reverseStr(String s, int k) \n    // Your code here\n}\n",
            "python": "def reverseStr(s, k):\n    # Your code here\n\n",
            "javascript": "function reverseStr(s, k) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <algorithm>\n#include <string>\nusing namespace std;\n\nint main() {\n    string s = $args[0];\n    int k = $args[1];\n    string result = reverseStr(s, k);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public String reverseStr(String s, int k) {\n    char[] chars = s.toCharArray();\n    for (int i = 0; i < chars.length; i += 2 * k) {\n        int left = i;\n        int right = Math.min(i + k - 1, chars.length - 1);\n        while (left < right) {\n            char temp = chars[left];\n            chars[left++] = chars[right];\n            chars[right--] = temp;\n        }\n    }\n    return new String(chars);\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args[0]\n    k = $args[1]\n    result = reverseStr(s, k)\n    print(result)",
            "javascript": "function main() {\n    const s = $args[0];\n    const k = $args[1];\n    const result = reverseStr(s, k);\n    console.log(result);\n}"
        }
    },
    "544": {
        "title": "NBA Playoff Team Pairing",
        "description": "During the NBA playoffs, teams are paired in a way that the rather strong team plays with the rather weak team. Given the number of teams `n`, return their final contest matches in the form of a string. The teams are labeled from 1 to n, representing their initial rank. We use parentheses and commas to represent the contest team pairing, with parentheses for pairing and commas for partition. In each round, the strategy is to pair the rather strong team with the rather weak one.",
        "example": "Example 1:\n\nInput: n = 4\nOutput: \"((1,4),(2,3))\"\nExplanation: In the first round, we pair the team 1 and 4, the teams 2 and 3 together, as we need to make the strong team and weak team together. And we got (1, 4),(2, 3). In the second round, the winners of (1, 4) and (2, 3) need to play again to generate the final winner, so you need to add the parentheses outside them. And we got the final answer ((1,4),(2,3)).\n\nExample 2:\n\nInput: n = 8\nOutput: \"(((1,8),(4,5)),((2,7),(3,6)))\"\nExplanation: First round: (1, 8),(2, 7),(3, 6),(4, 5). Second round: ((1, 8),(4, 5)),((2, 7),(3, 6)). Third round: (((1, 8),(4, 5)),((2, 7),(3, 6))). Since the third round will generate the final winner, you need to output the answer (((1,8),(4,5)),((2,7),(3,6))).",
        "level": "Medium",
        "tags": [
            "array",
            "string",
            "pairing"
        ],
        "test_cases": {
            "inputs": [
                4,
                8,
                12,
                2,
                6,
                10,
                3,
                9,
                5,
                7,
                11,
                1
            ],
            "outputs": [
                "((1,4),(2,3))",
                "(((1,8),(4,5)),((2,7),(3,6)))",
                "((((1,12),(6,7)),((2,11),(5,8))),(((3,10),(4,9)),((1,12),(6,7))))",
                "((1,2))",
                "(((1,6),(3,4)),((2,5)))",
                "((((1,10),(6,7)),((3,8),(4,9))),(((2,11),(5,12)),((1,10),(6,7))))",
                "(((1,3),(2)))",
                "((((1,9),(5,6)),((2,8),(3,7))),(((4,10),(1,9)),((5,6),(2,8))))",
                "(((1,5),(2,4)),((3)))",
                "((((1,7),(4,5)),((2,6),(3))),(((1,7),(4,5)),((2,6),(3))))",
                "((((1,11),(6,7)),((3,8),(4,10))),(((2,9),(5,12)),((1,11),(6,7))))",
                "((1))"
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <vector>\nusing namespace std;\n\nstring findContestMatch(int n) {\n    vector<string> matches(n);\n    for (int i = 1; i <= n; i++) {\n        matches[i - 1] = to_string(i);\n    }\n\n    while (n > 1) {\n        for (int i = 0; i < n / 2; i++) {\n            matches[i] = \"(\" + matches[i] + \",\" + matches[n - 1 - i] + \")\";\n        }\n        n /= 2;\n    }\n\n    return matches[0];\n}\n\n",
            "java": "public String findContestMatch(int n) {\n    String[] matches = new String[n];\n    for (int i = 1; i <= n; i++) {\n        matches[i - 1] = Integer.toString(i);\n    }\n\n    while (n > 1) {\n        for (int i = 0; i < n / 2; i++) {\n            matches[i] = \"(\" + matches[i] + \",\" + matches[n - 1 - i] + \")\";\n        }\n        n /= 2;\n    }\n\n    return matches[0];\n}\n\n",
            "python": "def findContestMatch(n):\n    matches = [str(i) for i in range(1, n + 1)]\n\n    while n > 1:\n        for i in range(n // 2):\n            matches[i] = \"(\" + matches[i] + \",\" + matches[n - 1 - i] + \")\"\n        n //= 2\n\n    return matches[0]\n\n",
            "javascript": "function findContestMatch(n) {\n    let matches = Array.from({length: n}, (_, i) => String(i + 1));\n    \n    while (n > 1) {\n        for (let i = 0; i < (n / 2); i++) {\n            matches[i] = \"(\" + matches[i] + \",\" + matches[n - 1 - i] + \")\";\n        }\n        n = Math.floor(n / 2);\n    }\n    \n    return matches[0];\n}\n\n",
            "explanation": "This algorithm initializes an array of matches with `n` elements, each representing a team. It then generates one half of the final contest matches using a while loop. During each iteration of the while loop, for every pair of teams `i` and `n - 1 - i`, we form a new match by creating a string with the format `(team1,team2)` and store it in the matches array. With each iteration, we divide the number of matches by 2, which eventually gives us the final contest match at the first index of the matches array."
        },
        "structure": {
            "c++": "#include <string>\n#include <vector>\nusing namespace std;\n\nstring findContestMatch(int n) \n    // Your code here\n}\n\n",
            "java": "public String findContestMatch(int n) \n    // Your code here\n}\n\n",
            "python": "def findContestMatch(n):\n    # Your code here\n\n",
            "javascript": "function findContestMatch(n) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n = $args;\n    string result = findContestMatch(n);\n    cout << result << endl;\n    return 0;\n}\n",
            "java": "public String findContestMatch(int n) {\n    String[] matches = new String[n];\n    for (int i = 1; i <= n; i++) {\n        matches[i - 1] = Integer.toString(i);\n    }\n\n    while (n > 1) {\n        for (int i = 0; i < n / 2; i++) {\n            matches[i] = \"(\" + matches[i] + \",\" + matches[n - 1 - i] + \")\";\n        }\n        n /= 2;\n    }\n\n    return matches[0];\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    result = findContestMatch(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = findContestMatch(n);\n    console.log(result);\n}"
        }
    },
    "546": {
        "title": "Maximum Points from Boxes",
        "description": "You are given several `boxes` with different colors represented by different positive numbers. You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (i.e., composed of `k` boxes, `k >= 1`), remove them and get `k * k` points. Return the maximum points you can get.",
        "example": "Example 1:\n\nInput: boxes = [1,3,2,2,2,3,4,3,1]\nOutput: 23\nExplanation:\n[1, 3, 2, 2, 2, 3, 4, 3, 1] \n----> [1, 3, 3, 4, 3, 1] (3*3=9 points) \n----> [1, 3, 3, 3, 1] (1*1=1 points) \n----> [1, 1] (3*3=9 points) \n----> [] (2*2=4 points)\n\nExample 2:\n\nInput: boxes = [1,1,1]\nOutput: 9\n\nExample 3:\n\nInput: boxes = [1]\nOutput: 1",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    3,
                    2,
                    2,
                    2,
                    3,
                    4,
                    3,
                    1
                ],
                [
                    1,
                    1,
                    1
                ],
                [
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    2,
                    2,
                    2,
                    3,
                    3,
                    3
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    5,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    5,
                    5,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    5,
                    5,
                    5,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    4,
                    3,
                    2,
                    1
                ]
            ],
            "outputs": [
                "23",
                "9",
                "1",
                "15",
                "15",
                "25",
                "27",
                "30",
                "100",
                "30",
                "36",
                "42",
                "49",
                "56",
                "64",
                "72",
                "81",
                "90",
                "100",
                "110"
            ]
        },
        "sample_code": {
            "c++": "int removeBoxes(vector<int>& boxes) {\n    int dp[100][100][100] = {0};\n    return dfs(boxes, dp, 0, boxes.size() - 1, 0);\n}\n\nint dfs(vector<int>& boxes, int dp[100][100][100], int l, int r, int k) {\n    if (l > r) return 0;\n    if (dp[l][r][k] != 0) return dp[l][r][k];\n\n    while (r > l && boxes[r] == boxes[r - 1]) {r--; k++;}\n\n    dp[l][r][k] = (k + 1) * (k + 1) + dfs(boxes, dp, l, r - 1, 0);\n\n    for (int i = l; i < r; i++) {\n        if (boxes[i] == boxes[r]) {\n            dp[l][r][k] = max(dp[l][r][k], dfs(boxes, dp, l, i, k + 1) + dfs(boxes, dp, i + 1, r - 1, 0));\n        }\n    }\n\n    return dp[l][r][k];\n}\n",
            "java": "public int removeBoxes(int[] boxes) {\n    int[][][] dp = new int[100][100][100];\n    return dfs(boxes, dp, 0, boxes.length - 1, 0);\n}\n\nprivate int dfs(int[] boxes, int[][][] dp, int l, int r, int k) {\n    if (l > r) return 0;\n    if (dp[l][r][k] != 0) return dp[l][r][k];\n\n    while (r > l && boxes[r] == boxes[r - 1]) {r--; k++;}\n\n    dp[l][r][k] = (k + 1) * (k + 1) + dfs(boxes, dp, l, r - 1, 0);\n\n    for (int i = l; i < r; i++) {\n        if (boxes[i] == boxes[r]) {\n            dp[l][r][k] = Math.max(dp[l][r][k], dfs(boxes, dp, l, i, k + 1) + dfs(boxes, dp, i + 1, r - 1, 0));\n        }\n    }\n\n    return dp[l][r][k];\n}\n",
            "python": "def removeBoxes(boxes):\n    def dfs(l, r, k):\n        if l > r: return 0\n        if dp[l][r][k] != 0: return dp[l][r][k]\n\n        while r > l and boxes[r] == boxes[r - 1]:\n            r -= 1\n            k += 1\n            \n        dp[l][r][k] = (k + 1) * (k + 1) + dfs(l, r - 1, 0)\n\n        for i in range(l, r):\n            if boxes[i] == boxes[r]:\n                dp[l][r][k] = max(dp[l][r][k], dfs(l, i, k + 1) + dfs(i + 1, r - 1, 0))\n                \n        return dp[l][r][k]\n\n    dp = [[[0] * 100 for _ in xrange(100)] for _ in xrange(100)]\n    return dfs(0, len(boxes) - 1, 0)\n",
            "javascript": "function removeBoxes(boxes) {\n    const dfs = (l, r, k) => {\n        if (l > r) return 0;\n        if (dp[l][r][k] !== 0) return dp[l][r][k];\n\n        while (r > l && boxes[r] == boxes[r - 1]) {r--; k++;}\n\n        dp[l][r][k] = (k + 1) * (k + 1) + dfs(l, r - 1, 0);\n\n        for (let i = l; i < r; i++) {\n            if (boxes[i] == boxes[r]) {\n                dp[l][r][k] = Math.max(dp[l][r][k], dfs(l, i, k + 1) + dfs(i + 1, r - 1, 0));\n            }\n        }\n\n        return dp[l][r][k];\n    };\n\n    let dp = Array.from({ length: 100 }, () => Array.from({ length: 100 }, () => Array(100).fill(0)));\n    return dfs(0, boxes.length - 1, 0);\n}\n",
            "explanation": "The problem can be solved using dynamic programming. We can define a 3D DP table where `dp[l][r][k]` will be the maximum points we can get for the boxes in the range `[l, r]`, where there are `k` boxes with the same color as `boxes[r]` to the right of `boxes[r]`. \n\nWe'll use a DFS approach to fill our DP table. \n1. First, we check whether our current range `l > r`, in which case we return 0.\n2. If `dp[l][r][k]` already has a non-zero value, we return `dp[l][r][k]`.\n3. Then, we remove all continuous boxes with the same color as `boxes[r]` on the right side of `boxes[r]` to calculate the initial value of `dp[l][r][k]`.\n4. We iterate from `l` to `r` and whenever we find a box with the same color as `boxes[r]`, we update `dp[l][r][k]` with the maximum of the current value and the sum of the result we get in the current split and the result that we have found for the next continuous split.\n\nFinally, we return the value in `dp[0][boxes.length - 1][0]`, which gives us the maximum points that can be obtained for the given input."
        },
        "structure": {
            "c++": "int removeBoxes(vector<int>& boxes) \n    // Your code here\n}\n",
            "java": "public int removeBoxes(int[] boxes) \n    // Your code here\n}\n",
            "python": "def removeBoxes(boxes):\n    # Your code here\n\n",
            "javascript": "function removeBoxes(boxes) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> boxes = $args;\n    int result = removeBoxes(boxes);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int removeBoxes(int[] boxes) {\n    int[][][] dp = new int[100][100][100];\n    return dfs(boxes, dp, 0, boxes.length - 1, 0);\n}\n\nprivate int dfs(int[] boxes, int[][][] dp, int l, int r, int k) {\n    if (l > r) return 0;\n    if (dp[l][r][k] != 0) return dp[l][r][k];\n\n    while (r > l && boxes[r] == boxes[r - 1]) {r--; k++;}\n\n    dp[l][r][k] = (k + 1) * (k + 1) + dfs(boxes, dp, l, r - 1, 0);\n\n    for (int i = l; i < r; i++) {\n        if (boxes[i] == boxes[r]) {\n            dp[l][r][k] = Math.max(dp[l][r][k], dfs(boxes, dp, l, i, k + 1) + dfs(boxes, dp, i + 1, r - 1, 0));\n        }\n    }\n\n    return dp[l][r][k];\n}",
            "python": "if __name__ == \"__main__\":\n    boxes = $args[0]\n    result = removeBoxes(boxes)\n    print(result)",
            "javascript": "function removeBoxes(boxes) {\n    const dfs = (l, r, k) => {\n        if (l > r) return 0;\n        if (dp[l][r][k] !== 0) return dp[l][r][k];\n\n        while (r > l && boxes[r] == boxes[r - 1]) {r--; k++;}\n\n        dp[l][r][k] = (k + 1) * (k + 1) + dfs(l, r - 1, 0);\n\n        for (let i = l; i < r; i++) {\n            if (boxes[i] == boxes[r]) {\n                dp[l][r][k] = Math.max(dp[l][r][k], dfs(l, i, k + 1) + dfs(i + 1, r - 1, 0));\n            }\n        }\n\n        return dp[l][r][k];\n    };\n\n    let dp = Array.from({ length: 100 }, () => Array.from({ length: 100 }, () => Array(100).fill(0)));\n    return dfs(0, boxes.length - 1, 0);\n}"
        }
    },
    "547": {
        "title": "Number of Provinces",
        "description": "Given a matrix representing the connectivity between cities, determine the total number of provinces. A province is a group of directly or indirectly connected cities with no other cities outside the group.",
        "example": "Example:\n\nInput: isConnected = [[1,1,0],[1,1,0],[0,0,1]]\nOutput: 2\nExplanation: There are 2 provinces. City 0 and City 1 are directly connected, and City 2 is indirectly connected to itself.\n\nInput: isConnected = [[1,0,0],[0,1,0],[0,0,1]]\nOutput: 3\nExplanation: There are 3 provinces. Each city is its own province.\n",
        "level": "Medium",
        "tags": [
            "Graph",
            "Connected Components"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        1,
                        0
                    ],
                    [
                        1,
                        1,
                        0
                    ],
                    [
                        0,
                        0,
                        1
                    ]
                ],
                [
                    [
                        1,
                        0,
                        0
                    ],
                    [
                        0,
                        1,
                        0
                    ],
                    [
                        0,
                        0,
                        1
                    ]
                ],
                [
                    [
                        1,
                        0,
                        0,
                        1
                    ],
                    [
                        0,
                        1,
                        1,
                        0
                    ],
                    [
                        0,
                        1,
                        1,
                        0
                    ],
                    [
                        1,
                        0,
                        0,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        1,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        1,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1,
                        0,
                        0
                    ],
                    [
                        1,
                        1,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        1,
                        1
                    ],
                    [
                        0,
                        0,
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        1,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        1,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        1,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        1,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        1,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        1,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        1,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        1,
                        1,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        1,
                        1,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        1,
                        1,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        1,
                        1
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        1,
                        1
                    ]
                ]
            ],
            "outputs": [
                2,
                3,
                2,
                1,
                4,
                2,
                5,
                1,
                6,
                3
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nusing std::vector;\n\nvoid dfs(vector<vector<int>>& isConnected, vector<bool>& visited, int i) {\n    visited[i] = true;\n    for (int j = 0; j < isConnected.size(); j++) {\n        if (isConnected[i][j] == 1 && !visited[j]) {\n            dfs(isConnected, visited, j);\n        }\n    }\n}\n\nint findCircleNum(vector<vector<int>>& isConnected) {\n    int provinces = 0;\n    vector<bool> visited(isConnected.size(), false);\n    for (int i = 0; i < isConnected.size(); i++) {\n        if (!visited[i]) {\n            dfs(isConnected, visited, i);\n            provinces++;\n        }\n    }\n    return provinces;\n}\n",
            "java": "public int findCircleNum(int[][] isConnected) {\n    int provinces = 0;\n    boolean[] visited = new boolean[isConnected.length];\n    for (int i = 0; i < isConnected.length; i++) {\n        if (!visited[i]) {\n            dfs(isConnected, visited, i);\n            provinces++;\n        }\n    }\n    return provinces;\n}\n\nprivate void dfs(int[][] isConnected, boolean[] visited, int i) {\n    visited[i] = true;\n    for (int j = 0; j < isConnected.length; j++) {\n        if (isConnected[i][j] == 1 && !visited[j]) {\n            dfs(isConnected, visited, j);\n        }\n    }\n}\n",
            "python": "def findCircleNum(isConnected):\n    def dfs(isConnected, visited, i):\n        visited[i] = True\n        for j in range(len(isConnected)):\n            if isConnected[i][j] == 1 and not visited[j]:\n                dfs(isConnected, visited, j)\n\n    provinces = 0\n    visited = [False] * len(isConnected)\n    for i in range(len(isConnected)):\n        if not visited[i]:\n            dfs(isConnected, visited, i)\n            provinces += 1\n    return provinces\n",
            "javascript": "function findCircleNum(isConnected) {\n    function dfs(isConnected, visited, i) {\n        visited[i] = true;\n        for (let j = 0; j < isConnected.length; j++) {\n            if (isConnected[i][j] === 1 && !visited[j]) {\n                dfs(isConnected, visited, j);\n            }\n        }\n    }\n\n    let provinces = 0;\n    const visited = new Array(isConnected.length).fill(false);\n    for (let i = 0; i < isConnected.length; i++) {\n        if (!visited[i]) {\n            dfs(isConnected, visited, i);\n            provinces++;\n        }\n    }\n    return provinces;\n}\n",
            "explanation": "We can solve this problem by using Depth First Search (DFS) to traverse the graph of cities:\n\n1. Create a boolean array `visited` of size n (the number of cities) initialized with `false` values.\n2. Initialize a counter variable `provinces` to count the number of provinces and set it to 0.\n3. Iterate through each city from 0 to n-1.\n   - If the city has not been visited, call a DFS helper function to traverse the connected components.\n   - Increment the `provinces` counter for every new group of connected cities.\n4. In the DFS helper function, mark the given city `i` as visited.\n5. Iterate through all other cities from 0 to n-1.\n   - If the cities `i` and `j` are directly connected (isConnected[i][j] == 1) and city `j` has not been visited, call the DFS helper function with city `j`.\n6. Return the total number of provinces.\n\nThis algorithm ensures that all directly and indirectly connected cities are visited, and their connected components are counted as provinces. The time complexity of this algorithm is O(n^2) as in the worst case, we might have to visit all possible edge connections between cities."
        },
        "structure": {
            "c++": "#include <vector>\n\nusing std::vector;\n\nvoid dfs(vector<vector<int>>& isConnected, vector<bool>& visited, int i) \n    // Your code here\n}\n",
            "java": "public int findCircleNum(int[][] isConnected) \n    // Your code here\n}\n",
            "python": "def findCircleNum(isConnected):\n    # Your code here\n\n",
            "javascript": "function findCircleNum(isConnected) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n\nusing std::vector;\n\nvoid dfs(vector<vector<int>>& isConnected, vector<bool>& visited, int i);\n\nint findCircleNum(vector<vector<int>>& isConnected);\n\nint main() {\n    vector<vector<int>> isConnected = $args;\n    int result = findCircleNum(isConnected);\n    cout << result << endl;\n    return 0;\n}\n\nvoid dfs(vector<vector<int>>& isConnected, vector<bool>& visited, int i) {\n    visited[i] = true;\n    for (int j = 0; j < isConnected.size(); j++) {\n        if (isConnected[i][j] == 1 && !visited[j]) {\n            dfs(isConnected, visited, j);\n        }\n    }\n}\n\nint findCircleNum(vector<vector<int>>& isConnected) {\n    int provinces = 0;\n    vector<bool> visited(isConnected.size(), false);\n    for (int i = 0; i < isConnected.size(); i++) {\n        if (!visited[i]) {\n            dfs(isConnected, visited, i);\n            provinces++;\n        }\n    }\n    return provinces;\n}",
            "java": "public int findCircleNum(int[][] isConnected) {\n    int provinces = 0;\n    boolean[] visited = new boolean[isConnected.length];\n    for (int i = 0; i < isConnected.length; i++) {\n        if (!visited[i]) {\n            dfs(isConnected, visited, i);\n            provinces++;\n        }\n    }\n    return provinces;\n}\n\nprivate void dfs(int[][] isConnected, boolean[] visited, int i) {\n    visited[i] = true;\n    for (int j = 0; j < isConnected.length; j++) {\n        if (isConnected[i][j] == 1 && !visited[j]) {\n            dfs(isConnected, visited, j);\n        }\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    isConnected = $args[0]\n    result = findCircleNum(isConnected)\n    print(result)",
            "javascript": "function findCircleNum(isConnected) {\n    function dfs(isConnected, visited, i) {\n        visited[i] = true;\n        for (let j = 0; j < isConnected.length; j++) {\n            if (isConnected[i][j] === 1 && !visited[j]) {\n                dfs(isConnected, visited, j);\n            }\n        }\n    }\n\n    let provinces = 0;\n    const visited = new Array(isConnected.length).fill(false);\n    for (let i = 0; i < isConnected.length; i++) {\n        if (!visited[i]) {\n            dfs(isConnected, visited, i);\n            provinces++;\n        }\n    }\n    return provinces;\n}"
        }
    },
    "548": {
        "title": "Triplet Subarray Sum Equality",
        "description": "Given an integer array `nums` of length `n`, return `true` if there is a triplet `(i, j, k)` which satisfies the following conditions:\n\n*   `0 < i, i + 1 < j, j + 1 < k < n - 1`\n*   The sum of subarrays `(0, i - 1)`, `(i + 1, j - 1)`, `(j + 1, k - 1)` and `(k + 1, n - 1)` is equal.\n\nA subarray `(l, r)` represents a slice of the original array starting from the element indexed `l` to the element indexed `r`.",
        "example": "Example:\n\nInput: nums = [1,2,1,2,1,2,1]\nOutput: true\nExplanation:\ni = 1, j = 3, k = 5.\nsum(0, i - 1) = sum(0, 0) = 1\nsum(i + 1, j - 1) = sum(2, 2) = 1\nsum(j + 1, k - 1) = sum(4, 4) = 1\nsum(k + 1, n - 1) = sum(6, 6) = 1",
        "level": "Medium",
        "tags": [
            "array",
            "subarray",
            "sum"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    1,
                    2,
                    1,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    1,
                    2,
                    1,
                    2,
                    1,
                    2
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7
                ],
                [
                    5,
                    10,
                    15,
                    20,
                    25,
                    30,
                    35
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10,
                    12,
                    14
                ],
                [
                    3,
                    6,
                    9,
                    12,
                    15,
                    18,
                    21
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9,
                    11,
                    13
                ],
                [
                    2,
                    5,
                    8,
                    11,
                    14,
                    17,
                    20
                ],
                [
                    1,
                    4,
                    7,
                    10,
                    13,
                    16,
                    19
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    2,
                    2,
                    2,
                    3,
                    3,
                    3
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    2,
                    2,
                    2,
                    3,
                    3,
                    3,
                    4,
                    4,
                    4
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "bool find_triplet_equal_sum(const std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<int> prefix_sum(n + 1, 0);\n\n    for (int i = 0; i < n; ++i) {\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i];\n    }\n\n    for (int i = 1; i + 2 < n; ++i) {\n        for (int j = i + 2; j + 1 < n; ++j) {\n            for (int k = j + 2; k < n; ++k) {\n                int s1 = prefix_sum[i];\n                int s2 = prefix_sum[j] - prefix_sum[i + 1];\n                int s3 = prefix_sum[k] - prefix_sum[j + 1];\n                int s4 = prefix_sum[n] - prefix_sum[k + 1];\n                if (s1 == s2 && s2 == s3 && s3 == s4) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n",
            "java": "boolean find_triplet_equal_sum(int[] nums) {\n    int n = nums.length;\n    int[] prefix_sum = new int[n + 1];\n\n    for (int i = 0; i < n; ++i) {\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i];\n    }\n\n    for (int i = 1; i + 2 < n; ++i) {\n        for (int j = i + 2; j + 1 < n; ++j) {\n            for (int k = j + 2; k < n; ++k) {\n                int s1 = prefix_sum[i];\n                int s2 = prefix_sum[j] - prefix_sum[i + 1];\n                int s3 = prefix_sum[k] - prefix_sum[j + 1];\n                int s4 = prefix_sum[n] - prefix_sum[k + 1];\n                if (s1 == s2 && s2 == s3 && s3 == s4) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n",
            "python": "def find_triplet_equal_sum(nums):\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n\n    for i in range(1, n - 2):\n        for j in range(i + 2, n - 1):\n            for k in range(j + 2, n):\n                s1 = prefix_sum[i]\n                s2 = prefix_sum[j] - prefix_sum[i + 1]\n                s3 = prefix_sum[k] - prefix_sum[j + 1]\n                s4 = prefix_sum[n] - prefix_sum[k + 1]\n                if s1 == s2 == s3 == s4:\n                    return True\n    return False\n",
            "javascript": "function find_triplet_equal_sum(nums) {\n    const n = nums.length;\n    const prefix_sum = new Array(n + 1).fill(0);\n\n    for (let i = 0; i < n; ++i) {\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i];\n    }\n\n    for (let i = 1; i + 2 < n; ++i) {\n        for (let j = i + 2; j + 1 < n; ++j) {\n            for (let k = j + 2; k < n; ++k) {\n                const s1 = prefix_sum[i];\n                const s2 = prefix_sum[j] - prefix_sum[i + 1];\n                const s3 = prefix_sum[k] - prefix_sum[j + 1];\n                const s4 = prefix_sum[n] - prefix_sum[k + 1];\n                if (s1 === s2 && s2 === s3 && s3 === s4) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n",
            "explanation": "The problem can be solved by calculating the prefix sum of the given `nums` array to optimize the sum calculation of subarrays. We use three nested loops to iterate through all possible values of `i`, `j`, and `k`. To check if the sum of the subarrays specified in the problem statement are equal, compare `s1`, `s2`, `s3` and `s4` which represent the sum of these subarrays, and return `true` if they are equal. If no triplet is found after iterating through all possible combinations, return `false`."
        },
        "structure": {
            "c++": "bool find_triplet_equal_sum(const std::vector<int>& nums) \n    // Your code here\n}\n",
            "java": "boolean find_triplet_equal_sum(int[] nums) \n    // Your code here\n}\n",
            "python": "def find_triplet_equal_sum(nums):\n    # Your code here\n\n",
            "javascript": "function find_triplet_equal_sum(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "bool find_triplet_equal_sum(const std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<int> prefix_sum(n + 1, 0);\n\n    for (int i = 0; i < n; ++i) {\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i];\n    }\n\n    for (int i = 1; i + 2 < n; ++i) {\n        for (int j = i + 2; j + 1 < n; ++j) {\n            for (int k = j + 2; k < n; ++k) {\n                int s1 = prefix_sum[i];\n                int s2 = prefix_sum[j] - prefix_sum[i + 1];\n                int s3 = prefix_sum[k] - prefix_sum[j + 1];\n                int s4 = prefix_sum[n] - prefix_sum[k + 1];\n                if (s1 == s2 && s2 == s3 && s3 == s4) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}",
            "java": "boolean find_triplet_equal_sum(int[] nums) {\n    int n = nums.length;\n    int[] prefix_sum = new int[n + 1];\n\n    for (int i = 0; i < n; ++i) {\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i];\n    }\n\n    for (int i = 1; i + 2 < n; ++i) {\n        for (int j = i + 2; j + 1 < n; ++j) {\n            for (int k = j + 2; k < n; ++k) {\n                int s1 = prefix_sum[i];\n                int s2 = prefix_sum[j] - prefix_sum[i + 1];\n                int s3 = prefix_sum[k] - prefix_sum[j + 1];\n                int s4 = prefix_sum[n] - prefix_sum[k + 1];\n                if (s1 == s2 && s2 == s3 && s3 == s4) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = find_triplet_equal_sum(nums)\n    print(result)",
            "javascript": "function find_triplet_equal_sum(nums) {\n    const n = nums.length;\n    const prefix_sum = new Array(n + 1).fill(0);\n\n    for (let i = 0; i < n; ++i) {\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i];\n    }\n\n    for (let i = 1; i + 2 < n; ++i) {\n        for (let j = i + 2; j + 1 < n; ++j) {\n            for (let k = j + 2; k < n; ++k) {\n                const s1 = prefix_sum[i];\n                const s2 = prefix_sum[j] - prefix_sum[i + 1];\n                const s3 = prefix_sum[k] - prefix_sum[j + 1];\n                const s4 = prefix_sum[n] - prefix_sum[k + 1];\n                if (s1 === s2 && s2 === s3 && s3 === s4) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}"
        }
    },
    "551": {
        "title": "Attendance Award Eligibility",
        "description": "You are given a string `s` representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n\n*   `A`: Absent.\n*   `L`: Late.\n*   `P`: Present.\n\nThe student is eligible for an attendance award if they meet **both** of the following criteria:\n\n*   The student was absent (`A`) for **strictly** fewer than 2 days **total**.\n*   The student was **never** late (`L`) for 3 or more **consecutive** days.\n\nReturn `true` if the student is eligible for an attendance award, or `false` otherwise.",
        "example": "Example:\n\nInput: s =  \"PPALLP \"\nOutput: true\nExplanation: The student has fewer than 2 absences and was never late 3 or more consecutive days.",
        "level": "Easy",
        "tags": [
            "string",
            "conditionals"
        ],
        "test_cases": {
            "inputs": [
                "\"PPALLP \"",
                "\"PPALLL \"",
                "\"PAPALP \"",
                "\"PAPALPL \"",
                "\"PAPALPLP \"",
                "\"PAPALPLLP \"",
                "\"PAPALPLLL \"",
                "\"PAPALPLLLL \"",
                "\"PAPALPLLLLL \"",
                "\"PAPALPLLLLLL \"",
                "\"PAPALPLLLLLLL \"",
                "\"PAPALPLLLLLLLL \"",
                "\"PAPALPLLLLLLLLL \"",
                "\"PAPALPLLLLLLLLLL \"",
                "\"PAPALPLLLLLLLLLLL \"",
                "\"PAPALPLLLLLLLLLLLL \"",
                "\"PAPALPLLLLLLLLLLLLL \"",
                "\"PAPALPLLLLLLLLLLLLLL \"",
                "\"PAPALPLLLLLLLLLLLLLLL \"",
                "\"PAPALPLLLLLLLLLLLLLLLL \""
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n\nbool checkRecord(std::string s) {\n    int late = 0, absent = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] == 'A') {\n            absent++;\n            late = 0;\n        } else if (s[i] == 'L') {\n            late++;\n        } else {\n            late = 0;\n        }\n\n        if (absent >= 2 || late >= 3) return false;\n    }\n    return true;\n}\n",
            "java": "public boolean checkRecord(String s) {\n    int late = 0, absent = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (s.charAt(i) == 'A') {\n            absent++;\n            late = 0;\n        } else if (s.charAt(i) == 'L') {\n            late++;\n        } else {\n            late = 0;\n        }\n\n        if (absent >= 2 || late >= 3) return false;\n    }\n    return true;\n}\n",
            "python": "def checkRecord(s: str) -> bool:\n    late, absent = 0, 0\n    for c in s:\n        if c == 'A':\n            absent += 1\n            late = 0\n        elif c == 'L':\n            late += 1\n        else:\n            late = 0\n\n        if absent >= 2 or late >= 3:\n            return False\n    return True\n",
            "javascript": "function checkRecord(s) {\n    let late = 0, absent = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === 'A') {\n            absent++;\n            late = 0;\n        } else if (s[i] === 'L') {\n            late++;\n        } else {\n            late = 0;\n        }\n\n        if (absent >= 2 || late >= 3) return false;\n    }\n    return true;\n}\n",
            "explanation": "The algorithm initializes variables `late` and `absent` as counters for late and absent days, respectively. \n1. Iterate through each character of the string `s`.\n2. If the current character is 'A', increment the `absent` counter and set `late` counter to zero.\n3. If the current character is 'L', increment the `late` counter.\n4. If the current character is 'P', set the `late` counter to zero.\n5. After processing each character, check if `absent` is greater or equal to 2, or if `late` is greater or equal to 3. If either condition is met, return false (ineligible for an attendance award).\n6. If the entire string has been processed without meeting the conditions, return true (eligible for an attendance award). "
        },
        "structure": {
            "c++": "#include <string>\n\nbool checkRecord(std::string s) \n    // Your code here\n}\n",
            "java": "public boolean checkRecord(String s) \n    // Your code here\n}\n",
            "python": "def checkRecord(s: str) -> bool:\n    # Your code here\n\n",
            "javascript": "function checkRecord(s) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <iostream>\n\nbool checkRecord(std::string s) {\n    int late = 0, absent = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] == 'A') {\n            absent++;\n            late = 0;\n        } else if (s[i] == 'L') {\n            late++;\n        } else {\n            late = 0;\n        }\n\n        if (absent >= 2 || late >= 3) return false;\n    }\n    return true;\n}\n\nint main() {\n    std::string s = $args;\n    bool result = checkRecord(s);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "java": "public boolean checkRecord(String s) {\n    int late = 0, absent = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (s.charAt(i) == 'A') {\n            absent++;\n            late = 0;\n        } else if (s.charAt(i) == 'L') {\n            late++;\n        } else {\n            late = 0;\n        }\n\n        if (absent >= 2 || late >= 3) return false;\n    }\n    return true;\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args[0]\n    result = checkRecord(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = checkRecord(s);\n    console.log(result);\n}"
        }
    },
    "552": {
        "title": "Attendance Award Eligibility",
        "description": "An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n\n*   'A': Absent.\n*   'L': Late.\n*   'P': Present.\n\nAny student is eligible for an attendance award if they meet both of the following criteria:\n\n*   The student was absent ('A') for strictly fewer than 2 days total.\n*   The student was never late ('L') for 3 or more consecutive days.\n\nGiven an integer n, return the number of possible attendance records of length n that make a student eligible for an attendance award. The answer may be very large, so return it modulo 109 + 7.",
        "example": "Example:\n\nInput:\n\nn = 2\n\nOutput:\n\n8\n\nExplanation:\n\nThere are 8 records with length 2 that are eligible for an award:\n\n\"PP \",  \"AP \",  \"PA \",  \"LP \",  \"PL \",  \"AL \",  \"LA \",  \"LL \"\n\nOnly  \"AA \" is not eligible because there are 2 absences (there need to be fewer than 2).",
        "level": "Medium",
        "tags": [
            "String",
            "Dynamic Programming"
        ],
        "test_cases": {
            "inputs": [
                2,
                1,
                10101,
                5,
                10,
                15,
                20,
                50,
                100,
                1000,
                10000,
                50000,
                100000,
                105,
                1000000,
                10000000,
                100000000,
                1000000000,
                10000000000,
                100000000000
            ],
            "outputs": [
                8,
                3,
                183236316,
                19,
                76,
                315,
                1296,
                316290802,
                646108792,
                703030049,
                457992974,
                782204094,
                682289015,
                682289015,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "int checkRecord(int n) {\n    int M = 1000000007;\n    vector<long long> dp(6, 1);  // {latent state 0, latent state 1, ..., latent state 5}\n    while (n--) {\n        vector<long long> next_dp(6, 0);\n        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M;\n        next_dp[1] = dp[0];\n        next_dp[2] = dp[1];\n        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M;\n        next_dp[4] = dp[3];\n        next_dp[5] = dp[4];\n        dp = next_dp;\n    }\n    return (dp[0] + dp[1] + dp[2] + dp[3] + dp[4] + dp[5]) % M;\n}\n\n",
            "java": "public int checkRecord(int n) {\n    int M = 1000000007;\n    long[] dp = new long[6];  // {latent state 0, latent state 1, ..., latent state 5}\n    Arrays.fill(dp, 1);\n    while (n-- > 0) {\n        long[] next_dp = new long[6];\n        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M;\n        next_dp[1] = dp[0];\n        next_dp[2] = dp[1];\n        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M;\n        next_dp[4] = dp[3];\n        next_dp[5] = dp[4];\n        dp = next_dp;\n    }\n    return (int) ((dp[0] + dp[1] + dp[2] +\n                   dp[3] + dp[4] + dp[5]) % M);\n}\n\n",
            "python": "def checkRecord(n: int) -> int:\n    M = 1000000007\n    dp = [1] * 6  # [latent state 0, latent state 1, ..., latent state 5]\n    while n:\n        next_dp = [0] * 6\n        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M\n        next_dp[1] = dp[0]\n        next_dp[2] = dp[1]\n        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M\n        next_dp[4] = dp[3]\n        next_dp[5] = dp[4]\n        dp = next_dp\n        n -= 1\n    return sum(dp) % M\n\n",
            "javascript": "function checkRecord(n) {\n    let M = 1000000007;\n    let dp = Array(6).fill(1);  // [latent state 0, latent state 1, ..., latent state 5]\n    while (n--) {\n        let next_dp = Array(6).fill(0);\n        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M;\n        next_dp[1] = dp[0];\n        next_dp[2] = dp[1];\n        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M;\n        next_dp[4] = dp[3];\n        next_dp[5] = dp[4];\n        dp = next_dp;\n    }\n    return dp.reduce((sum, val) => (sum + val) % M, 0);\n}\n\n",
            "explanation": "The algorithm uses dynamic programming to count the number of eligible attendance records. We use a latent state representation consisting of 6 states to account for previous attendance occurrences:\n\n- latent state 0: no A or L\n- latent state 1: no A, 1 consecutive L\n- latent state 2: no A, 2 consecutive L\n- latent state 3: 1 A, no L\n- latent state 4: 1 A, 1 consecutive L\n- latent state 5: 1 A, 2 consecutive L\n\nIn each iteration, we update these latent states according to the previous states. After n iterations, the sum of all latent states represents the number of eligible attendance records."
        },
        "structure": {
            "c++": "int checkRecord(int n) \n    // Your code here\n}\n\n",
            "java": "public int checkRecord(int n) \n    // Your code here\n}\n\n",
            "python": "def checkRecord(n: int) -> int:\n    # Your code here\n\n",
            "javascript": "function checkRecord(n) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int checkRecord(int n) {\n    int M = 1000000007;\n    vector<long long> dp(6, 1);  // {latent state 0, latent state 1, ..., latent state 5}\n    while (n--) {\n        vector<long long> next_dp(6, 0);\n        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M;\n        next_dp[1] = dp[0];\n        next_dp[2] = dp[1];\n        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M;\n        next_dp[4] = dp[3];\n        next_dp[5] = dp[4];\n        dp = next_dp;\n    }\n    return (dp[0] + dp[1] + dp[2] + dp[3] + dp[4] + dp[5]) % M;\n}",
            "java": "public int checkRecord(int n) {\n    int M = 1000000007;\n    long[] dp = new long[6];  // {latent state 0, latent state 1, ..., latent state 5}\n    Arrays.fill(dp, 1);\n    while (n-- > 0) {\n        long[] next_dp = new long[6];\n        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M;\n        next_dp[1] = dp[0];\n        next_dp[2] = dp[1];\n        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M;\n        next_dp[4] = dp[3];\n        next_dp[5] = dp[4];\n        dp = next_dp;\n    }\n    return (int) ((dp[0] + dp[1] + dp[2] +\n                   dp[3] + dp[4] + dp[5]) % M);\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    result = checkRecord(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = checkRecord(n);\n    console.log(result);\n}"
        }
    },
    "555": {
        "title": "Lexicographically Largest Regular String",
        "description": "Given an array of strings `strs`, you can concatenate these strings together into a loop, where for each string, you can choose to reverse it or not. Among all the possible loops, your task is to find the lexicographically largest string after cutting the loop, which will make the looped string into a regular one. Specifically, you need to concatenate all the strings into a loop, where you can reverse some strings or not and connect them in the same order as given. Then, you need to cut and make one breakpoint in any place of the loop, which will make the looped string into a regular one starting from the character at the cutpoint. Finally, find the lexicographically largest regular string among all the possible regular strings.",
        "example": "Example:\n\nInput: strs = [\"abc \", \"xyz \"]\nOutput: \"zyxcba \"\nExplanation: You can get the looped string \"-abcxyz-\", \"-abczyx-\", \"-cbaxyz-\", \"-cbazyx-\", where '-' represents the looped status. The answer string came from the fourth looped one, where you could cut from the middle character 'a' and get \"zyxcba\".",
        "level": "Medium",
        "tags": [
            "string",
            "loop",
            "lexicographically"
        ],
        "test_cases": {
            "inputs": [
                [
                    "abc ",
                    "xyz "
                ],
                [
                    "abc "
                ],
                [
                    "hello ",
                    "world "
                ],
                [
                    "coding ",
                    "questions ",
                    "are ",
                    "fun "
                ],
                [
                    "a ",
                    "b ",
                    "c ",
                    "d ",
                    "e ",
                    "f ",
                    "g ",
                    "h ",
                    "i ",
                    "j ",
                    "k ",
                    "l ",
                    "m ",
                    "n ",
                    "o ",
                    "p ",
                    "q ",
                    "r ",
                    "s ",
                    "t ",
                    "u ",
                    "v ",
                    "w ",
                    "x ",
                    "y ",
                    "z "
                ]
            ],
            "outputs": [
                "zyxcba ",
                "cba ",
                "worldhello ",
                "utsnoinuqgnidoc ",
                "zyxwvutsrqponmlkjihgfedcba "
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string splitLoopedString(std::vector<std::string>& strs) {\n    std::string ans;\n    std::string cur;\n    for (auto &s : strs) {\n        std::string rev(s.rbegin(), s.rend());\n        cur += std::max(s, rev);\n    }\n\n    for (size_t i = 0, k = 0; i < strs.size(); ++i) {\n        std::string rev(strs[i].rbegin(), strs[i].rend());\n        for (auto &xstr : {strs[i], rev}) {\n            for (size_t j = 0; j < xstr.size(); ++j) {\n                std::string t = xstr.substr(j) + cur.substr(k + xstr.size()) + cur.substr(0, k) + xstr.substr(0, j);\n                ans = std::max(ans, t);\n            }\n        }\n        k += strs[i].size();\n    }\n    return ans;\n}\n",
            "java": "import java.util.*;\n\npublic String splitLoopedString(String[] strs) {\n    String ans = \"\", cur = \"\";\n    for (String s : strs) {\n        String rev = new StringBuilder(s).reverse().toString();\n        cur += (s.compareTo(rev) > 0) ? s : rev;\n    }\n\n    for (int i = 0, k = 0; i < strs.length; i++) {\n        String rev = new StringBuilder(strs[i]).reverse().toString();\n        for (String xstr : Arrays.asList(strs[i], rev)) {\n            for (int j = 0; j < xstr.length(); j++) {\n                String t = xstr.substring(j) + cur.substring(k + xstr.length()) + cur.substring(0, k) + xstr.substring(0, j);\n                ans = ans.compareTo(t) > 0 ? ans : t;\n            }\n        }\n        k += strs[i].length();\n    }\n    return ans;\n}\n",
            "python": "def splitLoopedString(strs):\n    ans = ''\n    cur = ''.join(max(s, s[::-1]) for s in strs)\n    \n    for i, s in enumerate(strs):\n        for xstr in (s, s[::-1]):\n            for j in range(len(xstr)):\n                t = xstr[j:] + cur[len(xstr):] + cur[:len(xstr)] + xstr[:j]\n                ans = max(ans, t)\n        cur = cur[len(s):] + cur[:len(s)]\n    \n    return ans\n\n",
            "javascript": "function splitLoopedString(strs) {\n    let ans = \"\", cur = \"\";\n    strs.forEach(s => {\n        const rev = s.split('').reverse().join('');\n        cur += s > rev ? s : rev;\n    });\n\n    for (let i = 0, k = 0; i < strs.length; i++) {\n        let rev = strs[i].split('').reverse().join('');\n        [strs[i], rev].forEach(xstr => {\n            for (let j = 0; j < xstr.length; j++) {\n                let t = xstr.slice(j) + cur.slice(k + xstr.length) + cur.slice(0, k) + xstr.slice(0, j);\n                ans = ans > t ? ans : t;\n            }\n        });\n        k += strs[i].length;\n    }\n    return ans;\n}\n",
            "explanation": "The algorithm finds the lexicographically largest string in two steps. First, it concatenates all input strings into one looped string, choosing to use either the original string or its reverse for each string, based on which one is lexicographically larger. This way the looped string contains the maximum possible characters.\n\nAfter creating the looped string, it iterates through all possible breakpoints in the loop. For each breakpoint, it constructs a regular string by moving the characters from the breakpoint to the end of the loop to the beginning of the new regular string, and checks whether the newly constructed string is lexicographically larger than the current maximum string. If it is, it updates the maximum string.\n\nThe time complexity of this algorithm is O(N*L^2) where N is the number of strings, and L is the length of the strings. This is because, in the worst case, the algorithm iterates through all strings (N), all possible breakpoints (L), and all characters of the string (L)."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string splitLoopedString(std::vector<std::string>& strs) \n    // Your code here\n}\n",
            "java": "import java.util.*;\n\npublic String splitLoopedString(String[] strs) \n    // Your code here\n}\n",
            "python": "def splitLoopedString(strs):\n    # Your code here\n\n",
            "javascript": "function splitLoopedString(strs) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string splitLoopedString(std::vector<std::string>& strs) {\n    std::string ans;\n    std::string cur;\n    for (auto &s : strs) {\n        std::string rev(s.rbegin(), s.rend());\n        cur += std::max(s, rev);\n    }\n\n    for (size_t i = 0, k = 0; i < strs.size(); ++i) {\n        std::string rev(strs[i].rbegin(), strs[i].rend());\n        for (auto &xstr : {strs[i], rev}) {\n            for (size_t j = 0; j < xstr.size(); ++j) {\n                std::string t = xstr.substr(j) + cur.substr(k + xstr.size()) + cur.substr(0, k) + xstr.substr(0, j);\n                ans = std::max(ans, t);\n            }\n        }\n        k += strs[i].size();\n    }\n    return ans;\n}\n",
            "java": "public String splitLoopedString(String[] strs) {\n    String ans = \"\", cur = \"\";\n    for (String s : strs) {\n        String rev = new StringBuilder(s).reverse().toString();\n        cur += (s.compareTo(rev) > 0) ? s : rev;\n    }\n\n    for (int i = 0, k = 0; i < strs.length; i++) {\n        String rev = new StringBuilder(strs[i]).reverse().toString();\n        for (String xstr : Arrays.asList(strs[i], rev)) {\n            for (int j = 0; j < xstr.length(); j++) {\n                String t = xstr.substring(j) + cur.substring(k + xstr.length()) + cur.substring(0, k) + xstr.substring(0, j);\n                ans = ans.compareTo(t) > 0 ? ans : t;\n            }\n        }\n        k += strs[i].length();\n    }\n    return ans;\n}",
            "python": "if __name__ == \"__main__\":\n    strs = $args[0]\n    result = splitLoopedString(strs)\n    print(result)",
            "javascript": "function splitLoopedString(strs) {\n    let ans = \"\", cur = \"\";\n    strs.forEach(s => {\n        const rev = s.split('').reverse().join('');\n        cur += s > rev ? s : rev;\n    });\n\n    for (let i = 0, k = 0; i < strs.length; i++) {\n        let rev = strs[i].split('').reverse().join('');\n        [strs[i], rev].forEach(xstr => {\n            for (let j = 0; j < xstr.length; j++) {\n                let t = xstr.slice(j) + cur.slice(k + xstr.length) + cur.slice(0, k) + xstr.slice(0, j);\n                ans = ans > t ? ans : t;\n            }\n        });\n        k += strs[i].length;\n    }\n    return ans;\n}"
        }
    },
    "556": {
        "title": "Next Greater Number with Same Digits",
        "description": "Given a positive integer `n`, find the smallest integer which has exactly the same digits as the integer `n` and is greater in value than `n`. If no such positive integer exists, return `-1`. The returned integer should fit in a 32-bit integer. If there is a valid answer but it does not fit in a 32-bit integer, return `-1`.",
        "example": "Example:\n\nInput: n = 12\nOutput: 21\n\nExplanation: The next greater number with the same digits as 12 is 21.\n\nInput: n = 21\nOutput: -1\n\nExplanation: There is no positive integer greater than 21 with the same digits.",
        "level": "Medium",
        "tags": [
            "Math",
            "Number Theory"
        ],
        "test_cases": {
            "inputs": [
                12,
                21,
                123,
                321,
                111,
                1234,
                4321,
                987654321,
                123456789,
                987654312,
                9876543210,
                98765432100,
                987654321000,
                9876543210000,
                98765432100000,
                987654321000000,
                9876543210000000,
                98765432100000000,
                987654321000000000,
                9876543210000000000
            ],
            "outputs": [
                21,
                -1,
                132,
                -1,
                -1,
                1243,
                -1,
                -1,
                123456798,
                987654123,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1
            ]
        },
        "sample_code": {
            "c++": "#include <bits/stdc++.h>\nusing namespace std;\n\nint32_t nextGreaterElement(int n) {\n    string num = to_string(n);\n    if (next_permutation(num.begin(), num.end())) {\n        long long result = stoll(num);\n        if (result <= INT32_MAX) {\n            return result;\n        }\n    }\n    return -1;\n}\n",
            "java": "import java.util.Arrays;\n\npublic class Main {\n    public int nextGreaterElement(int n) {\n        char[] number = String.valueOf(n).toCharArray();\n        int i, j;\n        for (i = number.length - 1; i > 0; i--) {\n            if (number[i - 1] < number[i]) {\n                break;\n            }\n        }\n\n        if (i == 0) {\n            return -1;\n        }\n\n        int x = number[i - 1], smallest = i;\n        for (j = i + 1; j < number.length; j++) {\n            if (number[j] > x && number[j] < number[smallest]) {\n                smallest = j;\n            }\n        }\n\n        char temp = number[i - 1];\n        number[i - 1] = number[smallest];\n        number[smallest] = temp;\n\n        Arrays.sort(number, i, number.length);\n\n        long result = Long.parseLong(new String(number));\n\n        return (result <= Integer.MAX_VALUE) ? (int) result : -1;\n    }\n}\n",
            "python": "from itertools import permutations\n\ndef nextGreaterElement(n: int) -> int:\n    num_str = str(n)\n    num_permutations = sorted(set(int(\"\".join(p)) for p in permutations(num_str)))\n    index = num_permutations.index(n)\n    if index + 1 < len(num_permutations) and num_permutations[index + 1] <= 2**31 - 1:\n        return num_permutations[index + 1]\n    return -1\n",
            "javascript": "function nextGreaterElement(n) {\n    const numStr = n.toString();\n    let numArr = numStr.split('');\n    let i, j;\n\n    for (i = numArr.length - 1; i > 0; i--) {\n        if (+numArr[i - 1] < +numArr[i]) break;\n    }\n\n    if (i === 0) return -1;\n\n    let x = +numArr[i - 1], smallest = i;\n    for (j = i + 1; j < numArr.length; j++) {\n        if (+numArr[j] > x && +numArr[j] < +numArr[smallest]) {\n            smallest = j;\n        }\n    }\n\n    [numArr[smallest], numArr[i - 1]] = [numArr[i - 1], numArr[smallest]];\n\n    numArr = [...numArr.slice(0, i), ...numArr.slice(i).sort()];\n\n    const result = parseInt(numArr.join(''), 10);\n\n    return (result <= Math.pow(2, 31) - 1) ? result : -1;\n}\n",
            "explanation": "1. Convert input integer n to string/array of characters.\n2. Find the rightmost character such that when swapped with a character greater than it, the number increases. If no such character exists, return -1.\n3. Swap the character found with the smallest character to its right that is greater than it.\n4. Sort the portion of the array to the right of the swapped character in non-descending order.\n5. Convert the modified array back to an integer and check if it fits in 32-bit integer. If yes, return the integer, otherwise return -1."
        },
        "structure": {
            "c++": "#include <bits/stdc++.h>\nusing namespace std;\n\nint32_t nextGreaterElement(int n) \n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\n\npublic class Main \n    // Your code here\n}\n",
            "python": "from itertools import permutations\n    # Your code here\n\n",
            "javascript": "function nextGreaterElement(n) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n = $args;\n    int32_t result = nextGreaterElement(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int nextGreaterElement(int n) {\n        char[] number = String.valueOf(n).toCharArray();\n        int i, j;\n        for (i = number.length - 1; i > 0; i--) {\n            if (number[i - 1] < number[i]) {\n                break;\n            }\n        }\n\n        if (i == 0) {\n            return -1;\n        }\n\n        int x = number[i - 1], smallest = i;\n        for (j = i + 1; j < number.length; j++) {\n            if (number[j] > x && number[j] < number[smallest]) {\n                smallest = j;\n            }\n        }\n\n        char temp = number[i - 1];\n        number[i - 1] = number[smallest];\n        number[smallest] = temp;\n\n        Arrays.sort(number, i, number.length);\n\n        long result = Long.parseLong(new String(number));\n\n        return (result <= Integer.MAX_VALUE) ? (int) result : -1;\n    }",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    result = nextGreaterElement(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = nextGreaterElement(n);\n    console.log(result);\n}"
        }
    },
    "557": {
        "title": "Reverse Words in a String III",
        "description": "Given a string `s`, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.",
        "example": "Example 1:\n\nInput: s = \"Let`s take LeetCode contest\"\nOutput: \"s`teL ekat edoCteeL tsetnoc\"\n\nExample 2:\n\nInput: s = \"God Ding\"\nOutput: \"doG gniD\"",
        "level": "Easy",
        "tags": [
            "string",
            "reverse"
        ],
        "test_cases": {
            "inputs": [
                "\"Let`s take LeetCode contest\"",
                "\"God Ding\"",
                "\"Hello World\"",
                "\"I am a programmer\"",
                "\"This is a test\"",
                "\"Coding is fun\"",
                "\"Reverse this string\"",
                "\"Keep it simple\"",
                "\"Race car\"",
                "\"Palindrome\"",
                "\"123 456 789\"",
                "\"!@#$%^&*()\"",
                "\"Hello, World!\"",
                "\"I love coding!\"",
                "\"This is a sentence.\"",
                "\"Reverse the words.\"",
                "\"Programming is awesome.\"",
                "\"12345 67890\"",
                "\"!@#$ %^&*()\"",
                "\"Hello_World\"",
                "\"I_am_a_programmer\""
            ],
            "outputs": [
                "\"s`teL ekat edoCteeL tsetnoc\"",
                "\"doG gniD\"",
                "\"olleH dlroW\"",
                "\"I ma a remmargorp\"",
                "\"sihT si a tset\"",
                "\"gnidoC si nuf\"",
                "\"esrever siht gnirts\"",
                "\"peeK ti elpmis\"",
                "\"ecaR rac\"",
                "\"emordnilaP\"",
                "\"321 654 987\"",
                "\"!@#$%^&*()\"",
                "\"olleH, dlroW!\"",
                "\"I evol !gnidoc\"",
                "\"sihT si a .ecnetnes\"",
                "\"esreveR eht sdrow.\"",
                "\"gnimmargorP si emosewa.\"",
                "\"54321 09876\"",
                "\"!@#$ %^&*()\"",
                "\"dlroW_olleH\"",
                "\"I_ma_a_remmergorp\""
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <algorithm>\n#include <sstream>\n\nstd::string reverseWordsInString(const std::string& s) {\n    std::istringstream iss(s);\n    std::ostringstream oss;\n    std::string word;\n    while (iss >> word) {\n        std::reverse(word.begin(), word.end());\n        oss << word << ' ';\n    }\n    std::string result = oss.str();\n    if (!result.empty()) result.pop_back();\n    return result;\n}\n",
            "java": "import java.util.StringJoiner;\n\npublic String reverseWordsInString(String s) {\n    String[] words = s.split(\" \");\n    for (int i = 0; i < words.length; i++) {\n        words[i] = new StringBuilder(words[i]).reverse().toString();\n    }\n    return String.join(\" \", words);\n}\n",
            "python": "def reverse_words_in_string(s: str) -> str:\n    return \" \".join(word[::-1] for word in s.split(\" \"))\n",
            "javascript": "function reverseWordsInString(s) {\n    return s.split(' ').map(word => word.split('').reverse().join('')).join(' ');\n}\n",
            "explanation": "The algorithm first splits the input string `s` into words based on whitespace. Then, for each word, it reverses the order of characters and appends it to the output. Finally, the reversed words are joined with whitespace and returned as the result.\n\nIn each language implementation:\n- C++: The algorithm uses `istringstream` to split the string into words and `ostringstream` to create the output string.\n- Java: The algorithm splits the string using `split`, reverses each word using `StringBuilder` and then `String.join` to join the words with a space delimiter.\n- Python: The algorithm uses a list comprehension to reverse the words in the input string and `join` to concatenate them.\n- JavaScript: The algorithm uses `split`, `map`, and `join` operations on the input string to reverse each word and concatenate them."
        },
        "structure": {
            "c++": "#include <string>\n#include <algorithm>\n#include <sstream>\n\nstd::string reverseWordsInString(const std::string& s) \n    // Your code here\n}\n",
            "java": "import java.util.StringJoiner;\n\npublic String reverseWordsInString(String s) \n    // Your code here\n}\n",
            "python": "def reverse_words_in_string(s: str) -> str:\n    # Your code here\n\n",
            "javascript": "function reverseWordsInString(s) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <algorithm>\n#include <sstream>\n\nint main() {\n    std::string s = $args;\n    std::string result = reverseWordsInString(s);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public String reverseWordsInString(String s) {\n    String[] words = s.split(\" \");\n    for (int i = 0; i < words.length; i++) {\n        words[i] = new StringBuilder(words[i]).reverse().toString();\n    }\n    return String.join(\" \", words);\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args[0]\n    result = reverse_words_in_string(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = reverseWordsInString(s);\n    console.log(result);\n}"
        }
    },
    "560": {
        "title": "Subarray Sum Equals K",
        "description": "Given an array of integers `nums` and an integer `k`, return the total number of subarrays whose sum equals to `k`. A subarray is a contiguous non-empty sequence of elements within an array.",
        "example": "Example:\n\nInput: nums = [1,1,1], k = 2\nOutput: 2\n\nExplanation: The subarrays with sum equal to 2 are [1,1] and [1,1].\n\nInput: nums = [1,2,3], k = 3\nOutput: 2\n\nExplanation: The subarrays with sum equal to 3 are [1,2] and [3].",
        "level": "Medium",
        "tags": [
            "array",
            "prefix sum",
            "hashmap"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        1,
                        1
                    ],
                    2
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    9
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    15
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    20
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    25
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    30
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    35
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    40
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    45
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    50
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    55
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    60
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    65
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    70
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    75
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    80
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    85
                ]
            ],
            "outputs": [
                2,
                2,
                2,
                1,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "int subarraySum(vector<int>& nums, int k) {\n    unordered_map<int, int> prefixSumFrequency;\n    prefixSumFrequency[0] = 1;\n    int prefixSum = 0, result = 0;\n    \n    for (int num : nums) {\n        prefixSum += num;\n        result += prefixSumFrequency[prefixSum - k];\n        prefixSumFrequency[prefixSum]++;\n    }\n    \n    return result;\n}\n",
            "java": "public int subarraySum(int[] nums, int k) {\n    Map<Integer, Integer> prefixSumFrequency = new HashMap<>();\n    prefixSumFrequency.put(0, 1);\n    int prefixSum = 0, result = 0;\n    \n    for (int num : nums) {\n        prefixSum += num;\n        result += prefixSumFrequency.getOrDefault(prefixSum - k, 0);\n        prefixSumFrequency.put(prefixSum, prefixSumFrequency.getOrDefault(prefixSum, 0) + 1);\n    }\n    \n    return result;\n}\n",
            "python": "def subarraySum(nums, k):\n    prefix_sum_frequency = {0: 1}\n    prefix_sum, result = 0, 0\n    \n    for num in nums:\n        prefix_sum += num\n        result += prefix_sum_frequency.get(prefix_sum - k, 0)\n        prefix_sum_frequency[prefix_sum] = prefix_sum_frequency.get(prefix_sum, 0) + 1\n\n    return result\n",
            "javascript": "function subarraySum(nums, k) {\n    const prefixSumFrequency = {0: 1};\n    let prefixSum = 0, result = 0;\n    \n    for (const num of nums) {\n        prefixSum += num;\n        result += (prefixSumFrequency[prefixSum - k] || 0);\n        prefixSumFrequency[prefixSum] = (prefixSumFrequency[prefixSum] || 0) + 1;\n    }\n    \n    return result;\n}\n",
            "explanation": "The algorithm utilizes a hash map to store the frequency of the prefix sum up to the current element in the array. We start by initializing the hash map with a key-value pair (0, 1), which represents the empty subarray sum. Then we iterate through the input array, updating the prefix sum and result.\n\nFor each element in the array, we increment the prefix sum by the value of the element. We then increment the result by the value of the key (prefix sum - k) in the hash map, using a default value of 0 if the key is not found. This represents the number of subarrays ending at the current index with the sum equal to k. Finally, we increment the value of the prefix sum key in the hash map.\n\nThe time complexity of the algorithm is O(n), where n is the length of the input array. This is because we iterate through the array once and perform constant time operations for each element. The space complexity is O(n), which comes from using the hash map to store frequency of prefix sums."
        },
        "structure": {
            "c++": "int subarraySum(vector<int>& nums, int k) \n    // Your code here\n}\n",
            "java": "public int subarraySum(int[] nums, int k) \n    // Your code here\n}\n",
            "python": "def subarraySum(nums, k):\n    # Your code here\n\n",
            "javascript": "function subarraySum(nums, k) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int subarraySum(vector<int>& nums, int k) {\n    unordered_map<int, int> prefixSumFrequency;\n    prefixSumFrequency[0] = 1;\n    int prefixSum = 0, result = 0;\n    \n    for (int num : nums) {\n        prefixSum += num;\n        result += prefixSumFrequency[prefixSum - k];\n        prefixSumFrequency[prefixSum]++;\n    }\n    \n    return result;\n}",
            "java": "public int subarraySum(int[] nums, int k) {\n    Map<Integer, Integer> prefixSumFrequency = new HashMap<>();\n    prefixSumFrequency.put(0, 1);\n    int prefixSum = 0, result = 0;\n    \n    for (int num : nums) {\n        prefixSum += num;\n        result += prefixSumFrequency.getOrDefault(prefixSum - k, 0);\n        prefixSumFrequency.put(prefixSum, prefixSumFrequency.getOrDefault(prefixSum, 0) + 1);\n    }\n    \n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    k = $args[1]\n    result = subarraySum(nums, k)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args[0];\n    const k = $args[1];\n    const result = subarraySum(nums, k);\n    console.log(result);\n}"
        }
    },
    "561": {
        "title": "Maximize Sum of Minimums",
        "description": "Given an integer array `nums` of `2n` integers, group these integers into `n` pairs `(a1, b1), (a2, b2), ..., (an, bn)` such that the sum of `min(ai, bi)` for all `i` is maximized. Return the maximized sum.",
        "example": "Example:\n\nInput: nums = [1,4,3,2]\nOutput: 4\nExplanation: All possible pairings (ignoring the ordering of elements) are:\n1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3\n2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3\n3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\nSo the maximum possible sum is 4.\n\nInput: nums = [6,2,6,5,1,2]\nOutput: 9\nExplanation: The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.",
        "level": "Easy",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    4,
                    3,
                    2
                ],
                [
                    6,
                    2,
                    6,
                    5,
                    1,
                    2
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    -6
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    -10,
                    -9,
                    -8,
                    -7,
                    -6,
                    -5,
                    -4,
                    -3,
                    -2,
                    -1
                ],
                [
                    100,
                    200,
                    300,
                    400,
                    500,
                    600,
                    700,
                    800,
                    900,
                    1000
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9,
                    2,
                    4,
                    6,
                    8,
                    10
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10,
                    1,
                    3,
                    5,
                    7,
                    9
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30
                ],
                [
                    30,
                    29,
                    28,
                    27,
                    26,
                    25,
                    24,
                    23,
                    22,
                    21,
                    20,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ]
            ],
            "outputs": [
                "4",
                "9",
                "3",
                "15",
                "550",
                "-21",
                "0",
                "55",
                "-55",
                "5500",
                "110",
                "55",
                "55",
                "55",
                "465"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\n\nint arrayPairSum(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    int sum = 0;\n    for (int i = 0; i < nums.size(); i += 2) {\n        sum += nums[i];\n    }\n    return sum;\n}\n",
            "java": "import java.util.Arrays;\n\npublic int arrayPairSum(int[] nums) {\n    Arrays.sort(nums);\n    int sum = 0;\n    for (int i = 0; i < nums.length; i += 2) {\n        sum += nums[i];\n    }\n    return sum;\n}\n",
            "python": "def array_pair_sum(nums):\n    nums.sort()\n    return sum(nums[::2])\n",
            "javascript": "function arrayPairSum(nums) {\n    nums.sort((a, b) => a - b);\n    let sum = 0;\n    for (let i = 0; i < nums.length; i += 2) {\n        sum += nums[i];\n    }\n    return sum;\n}\n",
            "explanation": "1. First, sort the given 'nums' array/vector in ascending order.\n2. Iterate over the sorted array, with a step of 2, starting from index 0.\n3. During the iteration, accumulate the sum of every ith element (from sorted array) to maximize the sum of minimum elements in pairs.\n4. Return the accumulated sum."
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\n\nint arrayPairSum(std::vector<int>& nums) \n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\n\npublic int arrayPairSum(int[] nums) \n    // Your code here\n}\n",
            "python": "def array_pair_sum(nums):\n    # Your code here\n\n",
            "javascript": "function arrayPairSum(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nint main() {\n    std::vector<int> nums = $args;\n    int result = arrayPairSum(nums);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int arrayPairSum(int[] nums) {\n    Arrays.sort(nums);\n    int sum = 0;\n    for (int i = 0; i < nums.length; i += 2) {\n        sum += nums[i];\n    }\n    return sum;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = array_pair_sum(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = arrayPairSum(nums);\n    console.log(result);\n}"
        }
    },
    "562": {
        "title": "Longest Line of Consecutive Ones",
        "description": "Given an `m x n` binary matrix `mat`, find the length of the longest line of consecutive ones in the matrix. The line can be horizontal, vertical, diagonal, or anti-diagonal.",
        "example": "Example:\n\nInput:\nmat = [[0,1,1,0],[0,1,1,0],[0,0,0,1]]\nOutput: 3\n\nExplanation: The longest line of consecutive ones is the diagonal line starting from (0,1) and ending at (2,3), with a length of 3.\n\nInput:\nmat = [[1,1,1,1],[0,1,1,0],[0,0,0,1]]\nOutput: 4\n\nExplanation: The longest line of consecutive ones is the horizontal line starting from (0,0) and ending at (0,3), with a length of 4.",
        "level": "Medium",
        "tags": [
            "matrix",
            "consecutive",
            "line"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        0,
                        1,
                        1,
                        0
                    ],
                    [
                        0,
                        1,
                        1,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        0,
                        1,
                        1,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        1
                    ]
                ],
                [
                    [
                        1,
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        0,
                        1
                    ],
                    [
                        0,
                        1,
                        1,
                        0
                    ]
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        1,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        1,
                        0
                    ]
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1,
                        0,
                        0,
                        0,
                        1
                    ],
                    [
                        0,
                        1,
                        0,
                        1,
                        0
                    ],
                    [
                        0,
                        0,
                        1,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1
                    ],
                    [
                        0,
                        1,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1,
                        0
                    ],
                    [
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0
                    ]
                ]
            ],
            "outputs": [
                3,
                4,
                3,
                4,
                0,
                1,
                5,
                2,
                10,
                3
            ]
        },
        "sample_code": {
            "c++": "int longestLine(vector<vector<int>>& mat) {\n    int rows = mat.size();\n    int cols = mat[0].size();\n    int max_length = 0;\n    vector<vector<vector<int>>> dp(rows, vector<vector<int>>(cols, vector<int>(4, 0)));\n\n    for (int r = 0; r < rows; ++r) {\n        for (int c = 0; c < cols; ++c) {\n            if (mat[r][c] == 1) {\n                dp[r][c][0] = r > 0 ? dp[r - 1][c][0] + 1 : 1;\n                dp[r][c][1] = c > 0 ? dp[r][c - 1][1] + 1 : 1;\n                dp[r][c][2] = (r > 0 && c > 0) ? dp[r - 1][c - 1][2] + 1 : 1;\n                dp[r][c][3] = (r > 0 && c < cols - 1) ? dp[r - 1][c + 1][3] + 1 : 1;\n                max_length = max(max_length, max(dp[r][c][0], max(dp[r][c][1], max(dp[r][c][2], dp[r][c][3]))));\n            }\n        }\n    }\n    return max_length;\n}\n\n",
            "java": "public int longestLine(int[][] mat) {\n    int rows = mat.length;\n    int cols = mat[0].length;\n    int max_length = 0;\n    int[][][] dp = new int[rows][cols][4];\n\n    for (int r = 0; r < rows; ++r) {\n        for (int c = 0; c < cols; ++c) {\n            if (mat[r][c] == 1) {\n                dp[r][c][0] = r > 0 ? dp[r - 1][c][0] + 1 : 1;\n                dp[r][c][1] = c > 0 ? dp[r][c - 1][1] + 1 : 1;\n                dp[r][c][2] = (r > 0 && c > 0) ? dp[r - 1][c - 1][2] + 1 : 1;\n                dp[r][c][3] = (r > 0 && c < cols - 1) ? dp[r - 1][c + 1][3] + 1 : 1;\n                max_length = Math.max(max_length, Math.max(dp[r][c][0], Math.max(dp[r][c][1], Math.max(dp[r][c][2], dp[r][c][3]))));\n            }\n        }\n    }\n    return max_length;\n}\n\n",
            "python": "def longestLine(mat):\n    rows, cols = len(mat), len(mat[0])\n    max_length = 0\n    dp = [[[0, 0, 0, 0] for _ in range(cols)] for _ in range(rows)]\n\n    for r in range(rows):\n        for c in range(cols):\n            if mat[r][c] == 1:\n                dp[r][c][0] = dp[r - 1][c][0] + 1 if r > 0 else 1\n                dp[r][c][1] = dp[r][c - 1][1] + 1 if c > 0 else 1\n                dp[r][c][2] = dp[r - 1][c - 1][2] + 1 if r > 0 and c > 0 else 1\n                dp[r][c][3] = dp[r - 1][c + 1][3] + 1 if r > 0 and c < cols - 1 else 1\n                max_length = max(max_length, max(dp[r][c]))\n\n    return max_length\n\n",
            "javascript": "function longestLine(mat) {\n    const rows = mat.length;\n    const cols = mat[0].length;\n    let max_length = 0;\n    const dp = Array.from(Array(rows), () => Array.from(Array(cols), () => Array(4).fill(0)));\n\n    for (let r = 0; r < rows; ++r) {\n        for (let c = 0; c < cols; ++c) {\n            if (mat[r][c] === 1) {\n                dp[r][c][0] = r > 0 ? dp[r - 1][c][0] + 1 : 1;\n                dp[r][c][1] = c > 0 ? dp[r][c - 1][1] + 1 : 1;\n                dp[r][c][2] = (r > 0 && c > 0) ? dp[r - 1][c - 1][2] + 1 : 1;\n                dp[r][c][3] = (r > 0 && c < cols - 1) ? dp[r - 1][c + 1][3] + 1 : 1;\n                max_length = Math.max(max_length, Math.max(...dp[r][c]));\n            }\n        }\n    }\n    return max_length;\n}\n\n",
            "explanation": "The algorithm uses dynamic programming to find the longest line of consecutive ones in the binary matrix. We create a 3D array `dp` with dimensions (rows x cols x 4). For each element (i, j, k) of `dp`, it represents the length of the longest line ending at mat[i, j] in the direction specified by k (0: horizontal, 1: vertical, 2: diagonal, 3: anti-diagonal).\n\n1. For each cell mat[i][j], if the cell value is 1, update dp[i][j][0], dp[i][j][1], dp[i][j][2], and dp[i][j][3].\n2. Update the maximum length to be the maximum value of the current line lengths (dp[i][j][0], dp[i][j][1], dp[i][j][2], and dp[i][j][3]) if they are greater than the current maximum length.\n3. Return the maximum length found.\n\nThe time complexity of this algorithm is O(m * n) where m and n are the numbers of rows and columns in the matrix, respectively. The space complexity is also O(m * n) due to the use of the auxiliary `dp` array."
        },
        "structure": {
            "c++": "int longestLine(vector<vector<int>>& mat) \n    // Your code here\n}\n\n",
            "java": "public int longestLine(int[][] mat) \n    // Your code here\n}\n\n",
            "python": "def longestLine(mat):\n    # Your code here\n\n",
            "javascript": "function longestLine(mat) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int longestLine(vector<vector<int>>& mat) {\n    int rows = mat.size();\n    int cols = mat[0].size();\n    int max_length = 0;\n    vector<vector<vector<int>>> dp(rows, vector<vector<int>>(cols, vector<int>(4, 0)));\n\n    for (int r = 0; r < rows; ++r) {\n        for (int c = 0; c < cols; ++c) {\n            if (mat[r][c] == 1) {\n                dp[r][c][0] = r > 0 ? dp[r - 1][c][0] + 1 : 1;\n                dp[r][c][1] = c > 0 ? dp[r][c - 1][1] + 1 : 1;\n                dp[r][c][2] = (r > 0 && c > 0) ? dp[r - 1][c - 1][2] + 1 : 1;\n                dp[r][c][3] = (r > 0 && c < cols - 1) ? dp[r - 1][c + 1][3] + 1 : 1;\n                max_length = max(max_length, max(dp[r][c][0], max(dp[r][c][1], max(dp[r][c][2], dp[r][c][3]))));\n            }\n        }\n    }\n    return max_length;\n}",
            "java": "public int longestLine(int[][] mat) {\n    int rows = mat.length;\n    int cols = mat[0].length;\n    int max_length = 0;\n    int[][][] dp = new int[rows][cols][4];\n\n    for (int r = 0; r < rows; ++r) {\n        for (int c = 0; c < cols; ++c) {\n            if (mat[r][c] == 1) {\n                dp[r][c][0] = r > 0 ? dp[r - 1][c][0] + 1 : 1;\n                dp[r][c][1] = c > 0 ? dp[r][c - 1][1] + 1 : 1;\n                dp[r][c][2] = (r > 0 && c > 0) ? dp[r - 1][c - 1][2] + 1 : 1;\n                dp[r][c][3] = (r > 0 && c < cols - 1) ? dp[r - 1][c + 1][3] + 1 : 1;\n                max_length = Math.max(max_length, Math.max(dp[r][c][0], Math.max(dp[r][c][1], Math.max(dp[r][c][2], dp[r][c][3]))));\n            }\n        }\n    }\n    return max_length;\n}",
            "python": "if __name__ == \"__main__\":\n    mat = $args[0]\n    result = longestLine(mat)\n    print(result)",
            "javascript": "function main() {\n    const mat = $args;\n    const result = longestLine(mat);\n    console.log(result);\n}"
        }
    },
    "563": {
        "title": "Binary Tree Tilt",
        "description": "Given the `root` of a binary tree, return the sum of every tree node's tilt. The tilt of a tree node is the absolute difference between the sum of all left subtree node values and all right subtree node values. If a node does not have a left child, then the sum of the left subtree node values is treated as 0. The rule is similar if the node does not have a right child.",
        "example": "Example 1:\n\nInput: root = [1,2,3]\nOutput: 1\nExplanation: Tilt of node 2 : |0-0| = 0 (no children)\nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3)\nSum of every tilt : 0 + 0 + 1 = 1\n\nExample 2:\n\nInput: root = [4,2,9,3,5,null,7]\nOutput: 15\nExplanation: Tilt of node 3 : |0-0| = 0 (no children)\nTilt of node 5 : |0-0| = 0 (no children)\nTilt of node 7 : |0-0| = 0 (no children)\nTilt of node 2 : |3-5| = 2 (left subtree is just left child, so sum is 3; right subtree is just right child, so sum is 5)\nTilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right subtree is just right child, so sum is 7)\nTilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3, 5, and 2, which sums to 10; right subtree values are 9 and 7, which sums to 16)\nSum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15\n\nExample 3:\n\nInput: root = [21,7,14,1,1,2,2,3,3]\nOutput: 9",
        "level": "Easy",
        "tags": [
            "binary tree",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3
                ],
                "[4,2,9,3,5,null,7]",
                [
                    21,
                    7,
                    14,
                    1,
                    1,
                    2,
                    2,
                    3,
                    3
                ],
                [],
                [
                    1
                ],
                [
                    1,
                    2
                ],
                "[1,null,2]",
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                "[5,4,8,11,null,13,4,7,2,null,null,null,1]"
            ],
            "outputs": [
                "1",
                "15",
                "9",
                "0",
                "1",
                "1",
                "2",
                "45",
                "48"
            ]
        },
        "sample_code": {
            "c++": "int findTiltUtil(TreeNode* root, int& tiltSum) {\n    if (!root) return 0;\n\n    int leftSum = findTiltUtil(root->left, tiltSum);\n    int rightSum = findTiltUtil(root->right, tiltSum);\n\n    tiltSum += abs(leftSum - rightSum);\n    return root->val + leftSum + rightSum;\n}\n\nint findTilt(TreeNode* root) {\n    int tiltSum = 0;\n    findTiltUtil(root, tiltSum);\n    return tiltSum;\n}\n\n",
            "java": "public int findTilt(TreeNode root) {\n    int[] tiltSum = new int[] {0};\n    findTiltUtil(root, tiltSum);\n    return tiltSum[0];\n}\n\nprivate int findTiltUtil(TreeNode root, int[] tiltSum) {\n    if (root == null) {\n        return 0;\n    }\n\n    int leftSum = findTiltUtil(root.left, tiltSum);\n    int rightSum = findTiltUtil(root.right, tiltSum);\n\n    tiltSum[0] += Math.abs(leftSum - rightSum);\n    return root.val + leftSum + rightSum;\n}\n\n",
            "python": "def findTilt(self, root):\n    def findTiltUtil(node):\n        if not node: return 0, 0\n        \n        leftSum, leftTilt = findTiltUtil(node.left)\n        rightSum, rightTilt = findTiltUtil(node.right)\n    \n        return (node.val + leftSum + rightSum, abs(leftSum - rightSum) + leftTilt + rightTilt)\n\n    return findTiltUtil(root)[1]\n\n",
            "javascript": "function findTilt(root) {\n    function findTiltUtil(node) {\n        if (!node) return [0, 0];\n        \n        let [leftSum, leftTilt] = findTiltUtil(node.left);\n        let [rightSum, rightTilt] = findTiltUtil(node.right);\n    \n        return [node.val + leftSum + rightSum, Math.abs(leftSum - rightSum) + leftTilt + rightTilt];\n    }\n\n    return findTiltUtil(root)[1];\n};\n\n",
            "explanation": "The problem can be solved using a bottom-uprecursive algorithm. The helper function `findTiltUtil` should return two values: the sum of the current node and its descendants and the tilt value of the current node and its descendants.\n\nThe base case is when the current node is null, in this case, return [0, 0].\n\nIf the current node is not null, recursively call the `findTiltUtil` for left and right children. Then add the sum of the left child and the right child's sum, plus the value of the current node to get the new sum. For the new tilt value, add the absolute difference between the left and right child's sum to the tilt value of both children.\n\nFinally, return the new sum and tilt value as a tuple or a list. When calling this helper function for the root, the tilt value of the whole tree will be in the second element of the result list."
        },
        "structure": {
            "c++": "int findTiltUtil(TreeNode* root, int& tiltSum) \n    // Your code here\n}\n\n",
            "java": "public int findTilt(TreeNode root) \n    // Your code here\n}\n\n",
            "python": "def findTilt(self, root):\n    # Your code here\n\n",
            "javascript": "function findTilt(root) \n    // Your code here\n};\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    TreeNode* root = $args;\n    int result = findTilt(root);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int findTilt(TreeNode root) {\n    int[] tiltSum = new int[] {0};\n    findTiltUtil(root, tiltSum);\n    return tiltSum[0];\n}\n\nprivate int findTiltUtil(TreeNode root, int[] tiltSum) {\n    if (root == null) {\n        return 0;\n    }\n\n    int leftSum = findTiltUtil(root.left, tiltSum);\n    int rightSum = findTiltUtil(root.right, tiltSum);\n\n    tiltSum[0] += Math.abs(leftSum - rightSum);\n    return root.val + leftSum + rightSum;\n}",
            "python": "if __name__ == \"__main__\":\n    root = $args[0]\n    result = findTilt(root)\n    print(result)",
            "javascript": "function main() {\n    const root = $args;\n    const result = findTilt(root);\n    console.log(result);\n}"
        }
    },
    "564": {
        "title": "Closest Palindrome",
        "description": "Given a string `n` representing an integer, return the closest integer (not including itself) that is a palindrome. If there is a tie, return the smaller one. The closest integer is defined as the absolute difference minimized between two integers.",
        "example": "Example:\n\nInput: n = \"123\"\nOutput: \"121\"\n\nInput: n = \"1\"\nOutput: \"0\"\nExplanation: 0 and 2 are the closest palindromes, but we return the smaller one which is 0.",
        "level": "Medium",
        "tags": [
            "string",
            "palindrome"
        ],
        "test_cases": {
            "inputs": [
                "\"123\"",
                "\"1\"",
                "\"11\"",
                "\"12345\"",
                "\"123456\"",
                "\"1234567\"",
                "\"12345678\"",
                "\"123456789\"",
                "\"1234567890\"",
                "\"9876543210\"",
                "\"999999999999999999\"",
                "\"1000000000000000000\"",
                "\"123456789012345678\"",
                "\"987654321098765432\"",
                "\"1234567890123456789\"",
                "\"9876543210987654321\"",
                "\"12345678901234567890\"",
                "\"98765432109876543210\"",
                "\"123456789012345678901\"",
                "\"987654321098765432109\"",
                "\"1234567890123456789012\""
            ],
            "outputs": [
                "\"121\"",
                "\"0\"",
                "\"9\"",
                "\"12321\"",
                "\"123321\"",
                "\"1234321\"",
                "\"123454321\"",
                "\"12345654321\"",
                "\"1234567890123456789\"",
                "\"9876543210987654321\"",
                "\"999999999999999999\"",
                "\"999999999999999999\"",
                "\"123456789012345678\"",
                "\"987654321098765432\"",
                "\"1234567890123456789\"",
                "\"9876543210987654321\"",
                "\"12345678901234567890\"",
                "\"98765432109876543210\"",
                "\"123456789012345678901\"",
                "\"987654321098765432109\"",
                "\"1234567890123456789012\""
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <cmath>\n#include <limits>\n\nbool isPalindrome(std::string str) {\n    int left = 0;\n    int right = str.length() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nint closestPalindrome(std::string n) {\n    int num = std::stoi(n);\n    int left = num - 1;\n    int right = num + 1;\n\n    while (true) {\n        if (isPalindrome(std::to_string(left))) {\n            return left;\n        } \n        if (isPalindrome(std::to_string(right))) {\n            return right;\n        }\n        left--;\n        right++;\n    }\n}\n",
            "java": "public class ClosestPalindrome {\n    public static boolean isPalindrome(String str) {\n        int left = 0;\n        int right = str.length() - 1;\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n\n    public static int closestPalindrome(String n) {\n        int num = Integer.parseInt(n);\n        int left = num - 1;\n        int right = num + 1;\n\n        while (true) {\n            if (isPalindrome(Integer.toString(left))) {\n                return left;\n            }\n            if (isPalindrome(Integer.toString(right))) {\n                return right;\n            }\n            left--;\n            right++;\n        }\n    }\n}\n",
            "python": "def is_palindrome(s: str) -> bool:\n    return s == s[::-1]\n\ndef closest_palindrome(n: str) -> int:\n    num = int(n)\n    left = num - 1\n    right = num + 1\n\n    while True:\n        if is_palindrome(str(left)):\n            return left\n        if is_palindrome(str(right)):\n            return right\n        left -= 1\n        right += 1\n",
            "javascript": "function isPalindrome(str) {\n    let left = 0;\n    let right = str.length - 1;\n\n    while (left < right) {\n        if (str[left] !== str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nfunction closestPalindrome(n) {\n    const num = parseInt(n);\n    let left = num - 1;\n    let right = num + 1;\n\n    while (true) {\n        if (isPalindrome(left.toString())) {\n            return left;\n        }\n        if (isPalindrome(right.toString())) {\n            return right;\n        }\n        left--;\n        right++;\n    }\n}\n",
            "explanation": "The algorithm works as follows:\n\n1. Define a function `isPalindrome` that checks if a given string is a palindrome. This function uses two pointers, one at the left end and one at the right-end of the string, and compares the characters at these positions. If the characters are different, the string is not a palindrome. If the pointers cross or meet, the entire string has been checked, and it is a palindrome.\n2. Define the `closestPalindrome` function that takes a string representing an integer as input. Convert the input string to an integer.\n3. Initialize two variables, `left` and `right`, to represent the numbers to the left and right of the input integer.\n4. In a loop, check if the string representations of `left` and `right` are palindromes using the `isPalindrome` function. If either is a palindrome, return that number. Otherwise, decrement `left` and increment `right` in each iteration.\n\nThis process continues until a palindrome is found on either side of the input integer. If both are found at the same time, the smaller one is favored due to the decrement of `left` and increment of `right`, resulting in `left` being returned first."
        },
        "structure": {
            "c++": "#include <string>\n#include <cmath>\n#include <limits>\n\nbool isPalindrome(std::string str) \n    // Your code here\n}\n",
            "java": "public class ClosestPalindrome \n    // Your code here\n}\n",
            "python": "def is_palindrome(s: str) -> bool:\n    # Your code here\n\n",
            "javascript": "function isPalindrome(str) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <cmath>\n#include <limits>\n#include <iostream>\n\nbool isPalindrome(std::string str) {\n    int left = 0;\n    int right = str.length() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nint closestPalindrome(std::string n) {\n    int num = std::stoi(n);\n    int left = num - 1;\n    int right = num + 1;\n\n    while (true) {\n        if (isPalindrome(std::to_string(left))) {\n            return left;\n        } \n        if (isPalindrome(std::to_string(right))) {\n            return right;\n        }\n        left--;\n        right++;\n    }\n}\n\nint main() {\n    std::string n = $args;\n    int result = closestPalindrome(n);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public static int closestPalindrome(String n) {\n        int num = Integer.parseInt(n);\n        int left = num - 1;\n        int right = num + 1;\n\n        while (true) {\n            if (isPalindrome(Integer.toString(left))) {\n                return left;\n            }\n            if (isPalindrome(Integer.toString(right))) {\n                return right;\n            }\n            left--;\n            right++;\n        }\n    }",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    result = closest_palindrome(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = closestPalindrome(n);\n    console.log(result);\n}"
        }
    },
    "565": {
        "title": "Longest Set of Unique Elements",
        "description": "Given an integer array `nums` of length `n` where `nums` is a permutation of the numbers in the range `[0, n - 1]`, you need to build a set `s[k]` for each element `nums[k]` according to the following rule: starting with `nums[k]`, add `nums[nums[k]]`, `nums[nums[nums[k]]]`, and so on, until a duplicate element is encountered. Return the length of the longest set `s[k]`.",
        "example": "Example 1:\n\nInput: nums = [5,4,0,3,1,6,2]\nOutput: 4\nExplanation: \nnums[0] = 5, nums[1] = 4, nums[2] = 0, nums[3] = 3, nums[4] = 1, nums[5] = 6, nums[6] = 2.\nOne of the longest sets s[k]:\ns[0] = {nums[0], nums[5], nums[6], nums[2]} = {5, 6, 2, 0}\n\nExample 2:\n\nInput: nums = [0,1,2]\nOutput: 1",
        "level": "Medium",
        "tags": [
            "Array",
            "Permutation",
            "Set"
        ],
        "test_cases": {
            "inputs": [
                [
                    5,
                    4,
                    0,
                    3,
                    1,
                    6,
                    2
                ],
                [
                    0,
                    1,
                    2
                ],
                [
                    1,
                    0
                ],
                [
                    3,
                    2,
                    1,
                    0
                ],
                [
                    4,
                    3,
                    2,
                    1,
                    0
                ],
                [
                    0
                ],
                [
                    1,
                    0,
                    3,
                    2,
                    5,
                    4,
                    7,
                    6,
                    9,
                    8
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    0
                ]
            ],
            "outputs": [
                4,
                1,
                2,
                4,
                5,
                1,
                10,
                1
            ]
        },
        "sample_code": {
            "c++": "int arrayNesting(vector<int>& nums) {\n    int n = nums.size();\n    int max_len = 0;\n    for (int i = 0; i < n; ++i) {\n        if (nums[i] != -1) {       \n            int start = nums[i];\n            int count = 0;\n            while (nums[start] != -1) {\n                int temp = start;\n                start = nums[start];\n                count++;\n                nums[temp]=-1;\n            }\n            max_len = max(max_len, count);\n        }\n    }\n    return max_len;\n}\n",
            "java": "public int arrayNesting(int[] nums) {\n    int n = nums.length;\n    int max_len = 0;\n    for (int i = 0; i < n; ++i) {\n        if (nums[i] != -1) {       \n            int start = nums[i];\n            int count = 0;\n            while (nums[start] != -1) {\n                int temp = start;\n                start = nums[start];\n                count++;\n                nums[temp]=-1;\n            }\n            max_len = Math.max(max_len, count);\n        }\n    }\n    return max_len;\n}\n",
            "python": "def arrayNesting(nums):\n    n = len(nums)\n    max_len = 0\n    for i in range(n):\n        if nums[i] != -1:\n            start = nums[i]\n            count = 0\n            while nums[start] != -1:\n                temp = start\n                start = nums[start]\n                count += 1\n                nums[temp] = -1\n            max_len = max(max_len, count)\n    return max_len\n",
            "javascript": "function arrayNesting(nums) {\n    let n = nums.length;\n    let max_len = 0;\n    for (let i = 0; i < n; ++i) {\n        if (nums[i] !== -1) {       \n            let start = nums[i];\n            let count = 0;\n            while (nums[start] !== -1) {\n                let temp = start;\n                start = nums[start];\n                count++;\n                nums[temp] = -1;\n            }\n            max_len = Math.max(max_len, count);\n        }\n    }\n    return max_len;\n}\n",
            "explanation": "This algorithm iterates through the given `nums` array. During the iteration, when the current element `nums[i]` is not equal to -1, it initializes a new set by setting `start` to `nums[i]` and sets the `count` to 0. Then, in the inner while loop, it keeps following the chain as described in the problem statement and sets the visited element to -1. After completing the chain for the current element, it calculates the maximum length found so far and assigns it to `max_len`. This process is repeated for all elements in the `nums` array. Finally, the algorithm returns the longest length of a set `s[k]` found."
        },
        "structure": {
            "c++": "int arrayNesting(vector<int>& nums) \n    // Your code here\n}\n",
            "java": "public int arrayNesting(int[] nums) \n    // Your code here\n}\n",
            "python": "def arrayNesting(nums):\n    # Your code here\n\n",
            "javascript": "function arrayNesting(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int arrayNesting(vector<int>& nums) {\n    int n = nums.size();\n    int max_len = 0;\n    for (int i = 0; i < n; ++i) {\n        if (nums[i] != -1) {       \n            int start = nums[i];\n            int count = 0;\n            while (nums[start] != -1) {\n                int temp = start;\n                start = nums[start];\n                count++;\n                nums[temp]=-1;\n            }\n            max_len = max(max_len, count);\n        }\n    }\n    return max_len;\n}",
            "java": "public int arrayNesting(int[] nums) {\n    int n = nums.length;\n    int max_len = 0;\n    for (int i = 0; i < n; ++i) {\n        if (nums[i] != -1) {       \n            int start = nums[i];\n            int count = 0;\n            while (nums[start] != -1) {\n                int temp = start;\n                start = nums[start];\n                count++;\n                nums[temp]=-1;\n            }\n            max_len = Math.max(max_len, count);\n        }\n    }\n    return max_len;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = arrayNesting(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = arrayNesting(nums);\n    console.log(result);\n}"
        }
    },
    "566": {
        "title": "Reshape Matrix",
        "description": "In MATLAB, there is a handy function called `reshape` which can reshape an `m x n` matrix into a new one with a different size `r x c` keeping its original data. You are given an `m x n` matrix `mat` and two integers `r` and `c` representing the number of rows and the number of columns of the wanted reshaped matrix. The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were. If the `reshape` operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.",
        "example": "Example:\n\nInput:\nmat = [[1,2],[3,4]]\nr = 1\nc = 4\nOutput: [[1,2,3,4]]\n\nInput:\nmat = [[1,2],[3,4]]\nr = 2\nc = 4\nOutput: [[1,2],[3,4]]",
        "level": "Easy",
        "tags": [
            "matrix",
            "reshape"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    1,
                    4
                ],
                [
                    [
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    2,
                    4
                ],
                [
                    [
                        [
                            1,
                            2,
                            3
                        ],
                        [
                            4,
                            5,
                            6
                        ]
                    ],
                    3,
                    2
                ],
                [
                    [
                        [
                            1,
                            2,
                            3
                        ],
                        [
                            4,
                            5,
                            6
                        ]
                    ],
                    1,
                    6
                ],
                [
                    [
                        [
                            1,
                            2,
                            3
                        ],
                        [
                            4,
                            5,
                            6
                        ]
                    ],
                    6,
                    1
                ],
                [
                    [
                        [
                            1,
                            2,
                            3
                        ],
                        [
                            4,
                            5,
                            6
                        ]
                    ],
                    2,
                    3
                ],
                [
                    [
                        [
                            1,
                            2,
                            3
                        ],
                        [
                            4,
                            5,
                            6
                        ]
                    ],
                    4,
                    2
                ],
                [
                    [
                        [
                            1,
                            2,
                            3
                        ],
                        [
                            4,
                            5,
                            6
                        ]
                    ],
                    2,
                    4
                ],
                [
                    [
                        [
                            1,
                            2,
                            3
                        ],
                        [
                            4,
                            5,
                            6
                        ]
                    ],
                    3,
                    3
                ],
                [
                    [
                        [
                            1,
                            2,
                            3
                        ],
                        [
                            4,
                            5,
                            6
                        ]
                    ],
                    1,
                    1
                ],
                [
                    [
                        [
                            1,
                            2,
                            3
                        ],
                        [
                            4,
                            5,
                            6
                        ]
                    ],
                    6,
                    6
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6
                        ]
                    ],
                    2,
                    3
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6
                        ]
                    ],
                    3,
                    2
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6
                        ]
                    ],
                    1,
                    6
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6
                        ]
                    ],
                    6,
                    1
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6
                        ]
                    ],
                    2,
                    4
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6
                        ]
                    ],
                    4,
                    2
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6
                        ]
                    ],
                    3,
                    3
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6
                        ]
                    ],
                    1,
                    1
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6
                        ]
                    ],
                    6,
                    6
                ]
            ],
            "outputs": [
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        3
                    ],
                    [
                        4
                    ],
                    [
                        5
                    ],
                    [
                        6
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ]
                ],
                [
                    [
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        3
                    ],
                    [
                        4
                    ],
                    [
                        5
                    ],
                    [
                        6
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6
                    ]
                ],
                [
                    [
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ]
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\n    int m = mat.size();\n    int n = mat[0].size();\n    if (m * n != r * c) {\n        return mat;\n    }\n\n    vector<vector<int>> reshaped(r, vector<int>(c));\n    for (int i = 0; i < m * n; ++i) {\n        reshaped[i / c][i % c] = mat[i / n][i % n];\n    }\n    \n    return reshaped;\n}\n",
            "java": "public int[][] matrixReshape(int[][] mat, int r, int c) {\n    int m = mat.length;\n    int n = mat[0].length;\n    if (m * n != r * c) {\n        return mat;\n    }\n\n    int[][] reshaped = new int[r][c];\n    for (int i = 0; i < m * n; ++i) {\n        reshaped[i / c][i % c] = mat[i / n][i % n];\n    }\n\n    return reshaped;\n}\n",
            "python": "def matrixReshape(mat, r, c):\n    m, n = len(mat), len(mat[0])\n    if m * n != r * c:\n        return mat\n\n    reshaped = [[0] * c for _ in range(r)]\n    for i in range(m * n):\n        reshaped[i // c][i % c] = mat[i // n][i % n]\n\n    return reshaped\n",
            "javascript": "function matrixReshape(mat, r, c) {\n    const m = mat.length;\n    const n = mat[0].length;\n    if (m * n !== r * c) {\n        return mat;\n    }\n\n    const reshaped = new Array(r).fill(null).map(() => new Array(c));\n    for (let i = 0; i < m * n; ++i) {\n        reshaped[Math.floor(i / c)][i % c] = mat[Math.floor(i / n)][i % n];\n    }\n\n    return reshaped;\n}\n",
            "explanation": "The algorithm works by first checking if the reshape operation is possible. If the total number of elements in the original matrix (m * n) is not equal to the number of elements the reshaped matrix should have (r * c), the original matrix is returned.\n\nIf the reshape operation is possible, we create a new matrix of size r x c. We then iterate through each element index (i) of the original matrix and calculate the corresponding row and column in the reshaped matrix (i / c and i % c), assigning the value from the original matrix (mat[i / n][i % n]) to its position in the reshaped matrix.\n\nFinally, we return the reshaped matrix."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) \n    // Your code here\n}\n",
            "java": "public int[][] matrixReshape(int[][] mat, int r, int c) \n    // Your code here\n}\n",
            "python": "def matrixReshape(mat, r, c):\n    # Your code here\n\n",
            "javascript": "function matrixReshape(mat, r, c) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nint main() {\n    vector<vector<int>> mat = $args;\n    int r = 2;\n    int c = 3;\n    vector<vector<int>> result = matrixReshape(mat, r, c);\n    for (int i = 0; i < result.size(); ++i) {\n        for (int j = 0; j < result[0].size(); ++j) {\n            cout << result[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n",
            "java": "public int[][] matrixReshape(int[][] mat, int r, int c) {\n    int m = mat.length;\n    int n = mat[0].length;\n    if (m * n != r * c) {\n        return mat;\n    }\n\n    int[][] reshaped = new int[r][c];\n    for (int i = 0; i < m * n; ++i) {\n        reshaped[i / c][i % c] = mat[i / n][i % n];\n    }\n\n    return reshaped;\n}",
            "python": "if __name__ == \"__main__\":\n    mat = $args[0]\n    r = $args[1]\n    c = $args[2]\n    result = matrixReshape(mat, r, c)\n    print(result)",
            "javascript": "function main() {\n    const mat = $args[0];\n    const r = $args[1];\n    const c = $args[2];\n    const result = matrixReshape(mat, r, c);\n    console.log(result);\n}"
        }
    },
    "567": {
        "title": "Permutation Substring",
        "description": "Given two strings `s1` and `s2`, return `true` if `s2` contains a permutation of `s1`, or `false` otherwise. In other words, return `true` if one of `s1`'s permutations is a substring of `s2`.",
        "example": "Example:\n\nInput: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: true\nExplanation: s2 contains one permutation of s1 (\"ba\").",
        "level": "Easy",
        "tags": [
            "string",
            "permutation",
            "substring"
        ],
        "test_cases": {
            "inputs": [
                [
                    "ab",
                    "eidbaooo"
                ],
                [
                    "ab",
                    "eidboaoo"
                ],
                [
                    "abc",
                    "eidcbaooo"
                ],
                [
                    "abc",
                    "eidbcaooo"
                ],
                [
                    "abcd",
                    "eidbacdooo"
                ],
                [
                    "abcd",
                    "eidbcaooo"
                ],
                [
                    "abcde",
                    "eidbacdeooo"
                ],
                [
                    "abcde",
                    "eidbcaooo"
                ],
                [
                    "a",
                    "a"
                ],
                [
                    "a",
                    "b"
                ],
                [
                    "a",
                    ""
                ],
                [
                    "",
                    "a"
                ],
                [
                    "",
                    ""
                ],
                [
                    "hello",
                    "hello"
                ],
                [
                    "hello",
                    "olleh"
                ],
                [
                    "hello",
                    "hell"
                ],
                [
                    "hello",
                    "lohe"
                ],
                [
                    "hello",
                    "helloworld"
                ],
                [
                    "hello",
                    "worldhello"
                ],
                [
                    "hello",
                    "helloworldhello"
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                false,
                false,
                true,
                true,
                true,
                false,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nbool checkInclusion(std::string s1, std::string s2) {\n    std::vector<int> s1_map(26, 0);\n    std::vector<int> s2_map(26, 0);\n    if (s1.length() > s2.length()) return false;\n\n    for (int i = 0; i < s1.length(); ++i) {\n        ++s1_map[s1[i] - 'a'];\n        ++s2_map[s2[i] - 'a'];\n    }\n\n    for (int i = 0; i < s2.length() - s1.length(); ++i) {\n        if (s1_map == s2_map) return true;\n        --s2_map[s2[i] - 'a'];\n        ++s2_map[s2[i + s1.length()] - 'a'];\n    }\n\n    return s1_map == s2_map;\n}\n\n",
            "java": "public boolean checkInclusion(String s1, String s2) {\n    if (s1.length() > s2.length()) return false;\n    int[] s1_map = new int[26];\n    int[] s2_map = new int[26];\n\n    for (int i = 0; i < s1.length(); i++) {\n        s1_map[s1.charAt(i) - 'a']++;\n        s2_map[s2.charAt(i) - 'a']++;\n    }\n\n    for (int i = 0; i < s2.length() - s1.length(); i++) {\n        if (Arrays.equals(s1_map, s2_map)) return true;\n        s2_map[s2.charAt(i) - 'a']--;\n        s2_map[s2.charAt(i + s1.length()) - 'a']++;\n    }\n\n    return Arrays.equals(s1_map, s2_map);\n}\n\n",
            "python": "def checkInclusion(s1: str, s2: str) -> bool:\n    if len(s1) > len(s2): \n        return False\n    \n    s1_map = [0] * 26\n    s2_map = [0] * 26\n    \n    for i in range(len(s1)):\n        s1_map[ord(s1[i]) - ord('a')] += 1\n        s2_map[ord(s2[i]) - ord('a')] += 1\n    \n    for i in range(len(s2) - len(s1)):\n        if s1_map == s2_map: \n            return True\n        \n        s2_map[ord(s2[i]) - ord('a')] -= 1\n        s2_map[ord(s2[i + len(s1)]) - ord('a')] += 1\n\n    return s1_map == s2_map\n\n",
            "javascript": "function checkInclusion(s1, s2) {\n    if (s1.length > s2.length) return false;\n    const s1_map = new Array(26).fill(0);\n    const s2_map = new Array(26).fill(0);\n\n    for (let i = 0; i < s1.length; i++) {\n        s1_map[s1.charCodeAt(i) - 'a'.charCodeAt(0)]++;\n        s2_map[s2.charCodeAt(i) - 'a'.charCodeAt(0)]++;\n    }\n\n    for (let i = 0; i < s2.length - s1.length; i++) {\n        if (s1_map.every((val, idx) => val === s2_map[idx])) return true;\n        s2_map[s2.charCodeAt(i) - 'a'.charCodeAt(0)]--;\n        s2_map[s2.charCodeAt(i + s1.length) - 'a'.charCodeAt(0)]++;\n    }\n\n    return s1_map.every((val, idx) => val === s2_map[idx]);\n}\n\n",
            "explanation": "1. We maintain two array s1_map and s2_map to keep track of the character frequency in the respective strings.\n2. If the length of s1 is larger than s2 then return false.\n3. Iterate through the length of s1 and increment the count for each character in both s1_map and s2_map.\n4. Now iterate through length of s2 - length of s1 to keep the sliding window of size s1.\n5. If s1_map and s2_map are equal during the iterations, return true.\n6. Otherwise, slide the window by updating the counts in s2_map.\n\nThe algorithm will return the result once the iterations are completed."
        },
        "structure": {
            "c++": "#include <vector>\nbool checkInclusion(std::string s1, std::string s2) \n    // Your code here\n}\n\n",
            "java": "public boolean checkInclusion(String s1, String s2) \n    // Your code here\n}\n\n",
            "python": "def checkInclusion(s1: str, s2: str) -> bool:\n    # Your code here\n\n",
            "javascript": "function checkInclusion(s1, s2) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nbool checkInclusion(std::string s1, std::string s2) {\n    std::vector<int> s1_map(26, 0);\n    std::vector<int> s2_map(26, 0);\n    if (s1.length() > s2.length()) return false;\n\n    for (int i = 0; i < s1.length(); ++i) {\n        ++s1_map[s1[i] - 'a'];\n        ++s2_map[s2[i] - 'a'];\n    }\n\n    for (int i = 0; i < s2.length() - s1.length(); ++i) {\n        if (s1_map == s2_map) return true;\n        --s2_map[s2[i] - 'a'];\n        ++s2_map[s2[i + s1.length()] - 'a'];\n    }\n\n    return s1_map == s2_map;\n}\n\nint main() {\n    std::string s1 = $args;\n    std::string s2 = $args;\n    bool result = checkInclusion(s1, s2);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "java": "public boolean checkInclusion(String s1, String s2)",
            "python": "if __name__ == \"__main__\":\n    s1 = $args[0]\n    s2 = $args[1]\n    result = checkInclusion(s1, s2)\n    print(result)",
            "javascript": "function checkInclusion(s1, s2) {\n    if (s1.length > s2.length) return false;\n    const s1_map = new Array(26).fill(0);\n    const s2_map = new Array(26).fill(0);\n\n    for (let i = 0; i < s1.length; i++) {\n        s1_map[s1.charCodeAt(i) - 'a'.charCodeAt(0)]++;\n        s2_map[s2.charCodeAt(i) - 'a'.charCodeAt(0)]++;\n    }\n\n    for (let i = 0; i < s2.length - s1.length; i++) {\n        if (s1_map.every((val, idx) => val === s2_map[idx])) return true;\n        s2_map[s2.charCodeAt(i) - 'a'.charCodeAt(0)]--;\n        s2_map[s2.charCodeAt(i + s1.length) - 'a'.charCodeAt(0)]++;\n    }\n\n    return s1_map.every((val, idx) => val === s2_map[idx]);\n}\n"
        }
    },
    "568": {
        "title": "Maximize Vacation Days",
        "description": "LeetCode wants to give one of its best employees the option to travel among `n` cities to collect algorithm problems. But all work and no play makes Jack a dull boy, so the employee can take vacations in some particular cities and weeks. The task is to schedule the traveling to maximize the number of vacation days the employee could take, while following certain rules and restrictions. The cities are represented by indexes from 0 to n-1, and the employee starts in city 0 on Monday. The cities are connected by flights, represented as an n x n matrix called `flights`. If there is a flight from city i to city j, `flights[i][j]` is 1; otherwise, it is 0. The employee has k weeks to travel, and each week has seven days. Flights can only be taken once per day, and only on Monday morning. The flight time is not considered. The employee can have restricted vacation days in different weeks, represented by an n x k matrix called `days`. The value `days[i][j]` represents the maximum days the employee can take a vacation in city i in week j. The employee can stay in a city beyond the number of vacation days, but must work on the extra days. If the employee flies from city A to city B and takes a vacation on that day, the deduction towards vacation days will count towards the vacation days of city B in that week. The task is to determine the maximum number of vacation days the employee can take during k weeks.",
        "example": "Example:\n\nInput:\nflights = [[0,1,1],[1,0,1],[1,1,0]]\ndays = [[1,3,1],[6,0,3],[3,3,3]]\nOutput: 12\nExplanation: One of the best strategies is:\n1st week: fly from city 0 to city 1 on Monday, and play 6 days and work 1 day.\n2nd week: fly from city 1 to city 2 on Monday, and play 3 days and work 4 days.\n3rd week: stay at city 2, and play 3 days and work 4 days.\nAns = 6 + 3 + 3 = 12.",
        "level": "Medium",
        "tags": [
            "Dynamic Programming",
            "Graph"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        0
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        0
                    ]
                ],
                [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        0
                    ]
                ],
                [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        0
                    ]
                ],
                [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        0
                    ]
                ],
                [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        0
                    ]
                ],
                [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        0
                    ]
                ],
                [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        0
                    ]
                ],
                [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        0
                    ]
                ],
                [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        0
                    ]
                ],
                [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        0
                    ]
                ],
                [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        0
                    ]
                ],
                [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        0
                    ]
                ],
                [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        0
                    ]
                ],
                [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        0
                    ]
                ],
                [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        0
                    ]
                ],
                [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        0
                    ]
                ],
                [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        0
                    ]
                ],
                [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        0
                    ]
                ]
            ],
            "outputs": [
                "12",
                "3",
                "21",
                "12",
                "12",
                "12",
                "12",
                "12",
                "12",
                "12",
                "12",
                "12",
                "12",
                "12",
                "12",
                "12",
                "12",
                "12",
                "12",
                "12"
            ]
        },
        "sample_code": {
            "c++": "int dfs(const vector<vector<int>>& flights, const vector<vector<int>>& days, int currentWeek, int currentCity, vector<vector<int>>& memo) {\n    if (currentWeek == days[currentCity].size()) {\n        return 0;\n    }\n    if (memo[currentCity][currentWeek] != -1) {\n        return memo[currentCity][currentWeek];\n    }\n\n    int maxVacation = days[currentCity][currentWeek] + dfs(flights, days, currentWeek + 1, currentCity, memo);\n\n    for (int i = 0; i < flights.size(); i++) {\n        if (flights[currentCity][i] == 1) {\n            maxVacation = max(maxVacation, days[i][currentWeek] + dfs(flights, days, currentWeek + 1, i, memo));\n        }\n    }\n\n    memo[currentCity][currentWeek] = maxVacation;\n    return maxVacation;\n}\n\nint maxVacationDays(vector<vector<int>>& flights, vector<vector<int>>& days) {\n    vector<vector<int>> memo(flights.size(), vector<int>(days[0].size(), -1));\n    return dfs(flights, days, 0, 0, memo);\n}\n\n",
            "java": "public int maxVacationDays(int[][] flights, int[][] days) {\n    int n = flights.length;\n    int k = days[0].length;\n    int[][] memo = new int[n][k];\n    for (int i = 0; i < n; i++) {\n        Arrays.fill(memo[i], -1);\n    }\n    return dfs(flights, days, 0, 0, memo);\n}\n\nprivate int dfs(int[][] flights, int[][] days, int week, int city, int[][] memo) {\n    int numCities = flights.length;\n    int numWeeks = days[0].length;\n\n    if (week == numWeeks) {\n        return 0;\n    }\n\n    if (memo[city][week] != -1) {\n        return memo[city][week];\n    }\n\n    int maxVacation = days[city][week] + dfs(flights, days, week + 1, city, memo);\n\n    for (int i = 0; i < numCities; i++) {\n        if (flights[city][i] == 1) {\n            maxVacation = Math.max(maxVacation, days[i][week] + dfs(flights, days, week + 1, i, memo));\n        }\n    }\n\n    memo[city][week] = maxVacation;\n    return maxVacation;\n}\n\n",
            "python": "def maxVacationDays(flights, days):\n    n = len(flights)\n    k = len(days[0])\n    memo = [[-1] * k for _ in range(n)]\n\n    def dfs(currentWeek, currentCity):\n        if currentWeek == k:\n            return 0\n        if memo[currentCity][currentWeek] != -1:\n            return memo[currentCity][currentWeek]\n\n        maxVacation = days[currentCity][currentWeek] + dfs(currentWeek + 1, currentCity)\n\n        for i in range(n):\n            if flights[currentCity][i] == 1:\n                maxVacation = max(maxVacation, days[i][currentWeek] + dfs(currentWeek + 1, i))\n\n        memo[currentCity][currentWeek] = maxVacation\n        return maxVacation\n\n    return dfs(0, 0)\n\n",
            "javascript": "function maxVacationDays(flights, days) {\n    let n = flights.length;\n    let k = days[0].length;\n    let memo = new Array(n).fill(null).map(() => new Array(k).fill(-1));\n\n    function dfs(week, city) {\n        if (week === k) {\n            return 0;\n        }\n        if (memo[city][week] !== -1) {\n            return memo[city][week];\n        }\n\n        let maxVacation = days[city][week] + dfs(week + 1, city);\n\n        for (let i = 0; i < n; i++) {\n            if (flights[city][i] === 1) {\n                maxVacation = Math.max(maxVacation, days[i][week] + dfs(week + 1, i));\n            }\n        }\n\n        memo[city][week] = maxVacation;\n        return maxVacation;\n    }\n\n    return dfs(0, 0);\n}\n\n",
            "explanation": "We will use Depth First Search to explore all the possible valid city change and weeks, and keep track of the current week and current city. \n\nWe use memoization to store the calculated maximum vacation for each city and week, to avoid redundant calculations.\n\nThe base case is when the current week is equal to the total number of weeks, in this case, we can't take any more vacations, so we return 0.\n\nWe initialize the maximum vacation to be the vacation days in the current city and week, calling the dfs function recursively with the next week and the same city, as we don't change the city in this case.\n\nThen, for each possible city change using the flights matrix, we calculate the maximum vacation days with the new city and update the maximum vacation accordingly.\n\nWe store the maximum vacation for the current city and week in the memoization table and return the maximum vacation.\n\nThe final result is the maximum vacation days starting from city 0 and week 0."
        },
        "structure": {
            "c++": "int dfs(const vector<vector<int>>& flights, const vector<vector<int>>& days, int currentWeek, int currentCity, vector<vector<int>>& memo) \n    // Your code here\n}\n\n",
            "java": "public int maxVacationDays(int[][] flights, int[][] days) \n    // Your code here\n}\n\n",
            "python": "def maxVacationDays(flights, days):\n    # Your code here\n\n",
            "javascript": "function maxVacationDays(flights, days) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<vector<int>> flights = $args;\n    vector<vector<int>> days = $args;\n    int result = maxVacationDays(flights, days);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int maxVacationDays(int[][] flights, int[][] days) {\n    int n = flights.length;\n    int k = days[0].length;\n    int[][] memo = new int[n][k];\n    for (int i = 0; i < n; i++) {\n        Arrays.fill(memo[i], -1);\n    }\n    return dfs(flights, days, 0, 0, memo);\n}",
            "python": "if __name__ == \"__main__\":\n    flights = $args[0]\n    days = $args[1]\n    result = maxVacationDays(flights, days)\n    print(result)",
            "javascript": "function main() {\n    const flights = $args[0];\n    const days = $args[1];\n    const result = maxVacationDays(flights, days);\n    console.log(result);\n}"
        }
    },
    "572": {
        "title": "Subtree of Another Tree",
        "description": "Given the roots of two binary trees `root` and `subRoot`, return `true` if there is a subtree of `root` with the same structure and node values of `subRoot` and `false` otherwise.\n\nA subtree of a binary tree `tree` is a tree that consists of a node in `tree` and all of this node`s descendants. The tree `tree` could also be considered as a subtree of itself.",
        "example": "Example:\n\nInput: root = [3,4,5,1,2], subRoot = [4,1,2]\nOutput: true\n\nInput: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\nOutput: false",
        "level": "Medium",
        "tags": [
            "binary tree",
            "subtree",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    4,
                    5,
                    1,
                    2
                ],
                [
                    4,
                    1,
                    2
                ],
                [
                    1,
                    2,
                    3
                ],
                [
                    2,
                    3,
                    4
                ],
                "[3,4,5,1,2,null,null,null,null,0]",
                [
                    4,
                    1,
                    2
                ],
                "[1,2,3,null,null,4,5]",
                [
                    2,
                    3,
                    4
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7
                ],
                [
                    2,
                    3,
                    4
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7
                ],
                [
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7
                ]
            ],
            "outputs": [
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "\r\n```cpp\r\nstruct TreeNode {\r\n    int val;\r\n    TreeNode *left;\r\n    TreeNode *right;\r\n};\r\n\r\nbool isSubtree(TreeNode* root, TreeNode* subRoot) {\r\n    if (root == nullptr) return false;\r\n    if (isIdentical(root, subRoot)) return true;\r\n    return isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);\r\n}\r\n\r\nbool isIdentical(TreeNode* n1, TreeNode* n2) {\r\n    if (n1 == nullptr || n2 == nullptr) return n1 == n2;\r\n    if (n1->val != n2->val) return false;\r\n    return isIdentical(n1->left, n2->left) && isIdentical(n1->right, n2->right);\r\n}\r\n```\r\n\r\n",
            "java": "\r\n```java\r\npublic class TreeNode {\r\n    int val;\r\n    TreeNode left;\r\n    TreeNode right;\r\n}\r\n\r\npublic boolean isSubtree(TreeNode root, TreeNode subRoot) {\r\n    if (root == null) return false;\r\n    if (isIdentical(root, subRoot)) return true;\r\n    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\r\n}\r\n\r\npublic boolean isIdentical(TreeNode n1, TreeNode n2) {\r\n    if (n1 == null || n2 == null) return n1 == n2;\r\n    if (n1.val != n2.val) return false;\r\n    return isIdentical(n1.left, n2.left) && isIdentical(n1.right, n2.right);\r\n}\r\n```\r\n\r\n",
            "javascript": "\r\n```python\r\nclass TreeNode:\r\n    def __init__(self, val=0, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n        \r\ndef isSubtree(root, subRoot):\r\n    if root is None:\r\n        return False\r\n    if is_identical(root, subRoot):\r\n        return True\r\n    return isSubtree(root.left, subRoot) or isSubtree(root.right, subRoot)\r\n\r\ndef is_identical(n1, n2):\r\n    if n1 is None or n2 is None:\r\n        return n1 == n2\r\n    if n1.val != n2.val:\r\n        return False\r\n    return is_identical(n1.left, n2.left) and is_identical(n1.right, n2.right)\r\n```\r\n\r\n",
            "python": "\r\n```javascript\r\nclass TreeNode {\r\n    constructor(val, left = null, right = null) {\r\n        this.val = val;\r\n        this.left = left;\r\n        this.right = right;\r\n    }\r\n}\r\n\r\nfunction isSubtree(root, subRoot) {\r\n    if (root === null) return false;\r\n    if (isIdentical(root, subRoot)) return true;\r\n    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\r\n}\r\n\r\nfunction isIdentical(n1, n2) {\r\n    if (n1 === null || n2 === null) return n1 === n2;\r\n    if (n1.val !== n2.val) return false;\r\n    return isIdentical(n1.left, n2.left) && isIdentical(n1.right, n2.right);\r\n}\r\n```\r\n\r\n",
            "explanation": "\r\nThe algorithm checks if `subRoot` is a subtree of `root` by first looking whether the two trees have the same root node. If they do, it checks whether the substructures are also identical. If they are not, then `subRoot` is not a subtree at this level, and the algorithm looks further down the left and right branches of `root`. This is done by returning the logical `OR` between the result of checking left and right branches.\r\n\r\nThe helper function `isIdentical` checks whether the two given trees have the same structure and node values, by comparing the current nodes and then recursively traversing the left and right substructures. If a `None` value for a node is found, the two nodes are identical if they are both `None`. Otherwise, if the node values differ, the trees are not identical.\r"
        },
        "structure": {
            "c++": "\r\n```cpp\r\nstruct TreeNode \n    // Your code here\n}\r\n```\r\n\r\n",
            "java": "\r\n```java\r\npublic class TreeNode \n    // Your code here\n}\r\n```\r\n\r\n",
            "javascript": "\r\n```python\r\nclass TreeNode:\r\n    def __init__(self, val=0, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n        \r\ndef isSubtree(root, subRoot):\r\n    if root is None:\r\n        return False\r\n    if is_identical(root, subRoot):\r\n        return True\r\n    return isSubtree(root.left, subRoot) or isSubtree(root.right, subRoot)\r\n\r\ndef is_identical(n1, n2):\r\n    if n1 is None or n2 is None:\r\n        return n1 == n2\r\n    if n1.val != n2.val:\r\n        return False\r\n    return is_identical(n1.left, n2.left) and is_identical(n1.right, n2.right)\r\n```\r\n\r\n    // Your code here\n\n",
            "python": "\r\n    # Your code here\n\n"
        },
        "call_functions": {
            "c++": "bool isSubtree(TreeNode* root, TreeNode* subRoot) {\n    if (root == nullptr) return false;\n    if (isIdentical(root, subRoot)) return true;\n    return isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);\n}\n\nbool isIdentical(TreeNode* n1, TreeNode* n2) {\n    if (n1 == nullptr || n2 == nullptr) return n1 == n2;\n    if (n1->val != n2->val) return false;\n    return isIdentical(n1->left, n2->left) && isIdentical(n1->right, n2->right);\n}",
            "java": "public boolean isSubtree(TreeNode root, TreeNode subRoot) {\n    if (root == null) return false;\n    if (isIdentical(root, subRoot)) return true;\n    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n}\n\npublic boolean isIdentical(TreeNode n1, TreeNode n2) {\n    if (n1 == null || n2 == null) return n1 == n2;\n    if (n1.val != n2.val) return false;\n    return isIdentical(n1.left, n2.left) && isIdentical(n1.right, n2.right);\n}",
            "javascript": "def main():\n    root = TreeNode(3)\n    root.left = TreeNode(4)\n    root.right = TreeNode(5)\n    subRoot = TreeNode(4)\n    result = isSubtree(root, subRoot)\n    print(result)",
            "python": "if __name__ == \"__main__\":\n    root = $args[0]\n    subRoot = $args[1]\n    result = isSubtree(root, subRoot)\n    print(result)"
        }
    },
    "573": {
        "title": "Minimal Distance for Squirrel to Collect Nuts",
        "description": "You are given a garden of size `height x width` represented by two integers `height` and `width`. In the garden, there is a tree at position `tree = [treer, treec]`, a squirrel at position `squirrel = [squirrelr, squirrelc]`, and multiple nuts at positions `nuts[i] = [nutir, nutic]`. The squirrel can only carry one nut at a time and can move in four directions: up, down, left, and right, to the adjacent cell. The goal is to find the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one. The distance is measured by the number of moves.",
        "example": "Example:\n\nInput: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.",
        "level": "Medium",
        "tags": [
            "array",
            "grid",
            "greedy"
        ],
        "test_cases": {
            "inputs": [
                [
                    5,
                    7,
                    [
                        2,
                        2
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        [
                            3,
                            0
                        ],
                        [
                            2,
                            5
                        ]
                    ]
                ],
                [
                    1,
                    3,
                    [
                        0,
                        1
                    ],
                    [
                        0,
                        0
                    ],
                    [
                        [
                            0,
                            2
                        ]
                    ]
                ],
                [
                    3,
                    3,
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            2,
                            2
                        ]
                    ]
                ],
                [
                    2,
                    2,
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            0
                        ]
                    ]
                ],
                [
                    4,
                    4,
                    [
                        1,
                        1
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            3,
                            3
                        ]
                    ]
                ],
                [
                    3,
                    5,
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            2,
                            4
                        ]
                    ]
                ],
                [
                    2,
                    3,
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            1,
                            2
                        ]
                    ]
                ],
                [
                    5,
                    5,
                    [
                        2,
                        2
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            4,
                            4
                        ]
                    ]
                ],
                [
                    3,
                    4,
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        1
                    ],
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            2,
                            3
                        ]
                    ]
                ],
                [
                    4,
                    5,
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            3,
                            4
                        ]
                    ]
                ],
                [
                    2,
                    4,
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            1,
                            3
                        ]
                    ]
                ],
                [
                    5,
                    6,
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            5
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            4,
                            5
                        ]
                    ]
                ],
                [
                    3,
                    3,
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            2,
                            2
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            1,
                            2
                        ]
                    ]
                ],
                [
                    4,
                    4,
                    [
                        1,
                        1
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            1,
                            3
                        ]
                    ]
                ],
                [
                    3,
                    5,
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            1,
                            4
                        ]
                    ]
                ],
                [
                    2,
                    3,
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            1,
                            0
                        ]
                    ]
                ],
                [
                    5,
                    5,
                    [
                        2,
                        2
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            4,
                            4
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            2,
                            4
                        ]
                    ]
                ],
                [
                    3,
                    4,
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        1
                    ],
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            1,
                            3
                        ]
                    ]
                ],
                [
                    4,
                    5,
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            2,
                            4
                        ]
                    ]
                ],
                [
                    2,
                    4,
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            1,
                            0
                        ]
                    ]
                ],
                [
                    5,
                    6,
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            5
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            4,
                            5
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            2,
                            5
                        ]
                    ]
                ]
            ],
            "outputs": [
                "12",
                "3",
                "8",
                "2",
                "10",
                "10",
                "6",
                "14",
                "8",
                "12",
                "6",
                "12",
                "12",
                "14",
                "12",
                "6",
                "14",
                "12",
                "8",
                "14"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nint minDistance(int height, int width, vector<int>& tree, vector<int>& squirrel, vector<vector<int>>& nuts) {\n    int totalDist = 0;\n    int minDiff = INT_MAX;\n    \n    for (vector<int>& nut : nuts) {\n        int treeDist = abs(tree[0] - nut[0]) + abs(tree[1] - nut[1]);\n        int squirrelDist = abs(squirrel[0] - nut[0]) + abs(squirrel[1] - nut[1]);\n        \n        totalDist += 2 * treeDist;\n        minDiff = min(minDiff, squirrelDist - treeDist);\n    }\n    \n    return totalDist + minDiff;\n}\n\n",
            "java": "public int minDistance(int height, int width, int[] tree, int[] squirrel, int[][] nuts) {\n    int totalDist = 0;\n    int minDiff = Integer.MAX_VALUE;\n    \n    for (int[] nut : nuts) {\n        int treeDist = Math.abs(tree[0] - nut[0]) + Math.abs(tree[1] - nut[1]);\n        int squirrelDist = Math.abs(squirrel[0] - nut[0]) + Math.abs(squirrel[1] - nut[1]);\n        \n        totalDist += 2 * treeDist;\n        minDiff = Math.min(minDiff, squirrelDist - treeDist);\n    }\n    \n    return totalDist + minDiff;\n}\n\n",
            "python": "def minDistance(height, width, tree, squirrel, nuts):\n    totalDist = 0\n    minDiff = float(\"inf\")\n    \n    for nut in nuts:\n        treeDist = abs(tree[0] - nut[0]) + abs(tree[1] - nut[1])\n        squirrelDist = abs(squirrel[0] - nut[0]) + abs(squirrel[1] - nut[1])\n        \n        totalDist += 2 * treeDist\n        minDiff = min(minDiff, squirrelDist - treeDist)\n    \n    return totalDist + minDiff\n\n",
            "javascript": "function minDistance(height, width, tree, squirrel, nuts) {\n    let totalDist = 0;\n    let minDiff = Infinity;\n    \n    for (let nut of nuts) {\n        let treeDist = Math.abs(tree[0] - nut[0]) + Math.abs(tree[1] - nut[1]);\n        let squirrelDist = Math.abs(squirrel[0] - nut[0]) + Math.abs(squirrel[1] - nut[1]);\n        \n        totalDist += 2 * treeDist;\n        minDiff = Math.min(minDiff, squirrelDist - treeDist);\n    }\n    \n    return totalDist + minDiff;\n}\n\n",
            "explanation": "Our main goal in this problem is to minimize the total distance. We will loop through all the nuts and calculate the distance between the squirrel and the nut, and the distance between the tree and the nut. We have to double the tree distance due to the squirrel having to come back to the tree. After calculating the distances, we subtract the tree distance from the squirrel distance and find the minimum difference. The total distance is the sum of all the doubled tree distances and the minimum difference."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nint minDistance(int height, int width, vector<int>& tree, vector<int>& squirrel, vector<vector<int>>& nuts) \n    // Your code here\n}\n\n",
            "java": "public int minDistance(int height, int width, int[] tree, int[] squirrel, int[][] nuts) \n    // Your code here\n}\n\n",
            "python": "def minDistance(height, width, tree, squirrel, nuts):\n    # Your code here\n\n",
            "javascript": "function minDistance(height, width, tree, squirrel, nuts) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nint main() {\n    int height = $args;\n    int width = $args;\n    vector<int> tree = $args;\n    vector<int> squirrel = $args;\n    vector<vector<int>> nuts = $args;\n    \n    int result = minDistance(height, width, tree, squirrel, nuts);\n    cout << result << endl;\n    \n    return 0;\n}",
            "java": "public int minDistance(int height, int width, int[] tree, int[] squirrel, int[][] nuts) {\n    int totalDist = 0;\n    int minDiff = Integer.MAX_VALUE;\n    \n    for (int[] nut : nuts) {\n        int treeDist = Math.abs(tree[0] - nut[0]) + Math.abs(tree[1] - nut[1]);\n        int squirrelDist = Math.abs(squirrel[0] - nut[0]) + Math.abs(squirrel[1] - nut[1]);\n        \n        totalDist += 2 * treeDist;\n        minDiff = Math.min(minDiff, squirrelDist - treeDist);\n    }\n    \n    return totalDist + minDiff;\n}",
            "python": "if __name__ == \"__main__\":\n    height = $args[0]\n    width = $args[1]\n    tree = $args[2]\n    squirrel = $args[3]\n    nuts = $args[4]\n    result = minDistance(height, width, tree, squirrel, nuts)\n    print(result)",
            "javascript": "function main() {\n    const height = $args[0];\n    const width = $args[1];\n    const tree = $args[2];\n    const squirrel = $args[3];\n    const nuts = $args[4];\n    \n    const result = minDistance(height, width, tree, squirrel, nuts);\n    console.log(result);\n}"
        }
    },
    "575": {
        "title": "Maximum Number of Different Types of Candies",
        "description": "Alice has `n` candies, where the `ith` candy is of type `candyType[i]`. Alice noticed that she started to gain weight, so she visited a doctor.\n\nThe doctor advised Alice to only eat `n / 2` of the candies she has (`n` is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.\n\nGiven the integer array `candyType` of length `n`, return the maximum number of different types of candies she can eat if she only eats `n / 2` of them.",
        "example": "Example:\n\nInput: candyType = [1,1,2,2,3,3]\nOutput: 3\nExplanation: Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.",
        "level": "Easy",
        "tags": [
            "array",
            "math"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    1,
                    2,
                    2,
                    3,
                    3
                ],
                [
                    1,
                    1,
                    2,
                    3
                ],
                [
                    6,
                    6,
                    6,
                    6
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99,
                    100
                ]
            ],
            "outputs": [
                "3",
                "2",
                "1",
                "4",
                "2",
                "50"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nint maxNumberOfCandies(vector<int>& candyType) {\n    unordered_set<int> uniqueCandies(candyType.begin(), candyType.end());\n    return min(uniqueCandies.size(), candyType.size() / 2);\n}\n\n",
            "java": "import java.util.HashSet;\nimport java.util.Set;\n\npublic int maxNumberOfCandies(int[] candyType) {\n    Set<Integer> uniqueCandies = new HashSet<>();\n    for (int type : candyType) {\n        uniqueCandies.add(type);\n    }\n    return Math.min(uniqueCandies.size(), candyType.length / 2);\n}\n\n",
            "python": "def maxNumberOfCandies(candyType):\n    uniqueCandies = set(candyType)\n    return min(len(uniqueCandies), len(candyType) // 2)\n\n",
            "javascript": "function maxNumberOfCandies(candyType) {\n    const uniqueCandies = new Set(candyType);\n    return Math.min(uniqueCandies.size, candyType.length / 2);\n}\n\n",
            "explanation": "The algorithm starts by first creating a set of unique candy types using a hash set (in C++ and Java) or a set (in Python and JavaScript). The uniqueCandies set will only store each type of candy once, no matter how many times it appears in the candyType array. After creating this set, the algorithm compares the number of unique types of candies (size of the set) with half the total number of candies (n / 2). The minimum of these two values is returned as the maximum number of different types of candies Alice can eat. This is because Alice can eat at most n / 2 candies, but if there are fewer unique candies than that, she will eat all the unique types available."
        },
        "structure": {
            "c++": "#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nint maxNumberOfCandies(vector<int>& candyType) \n    // Your code here\n}\n\n",
            "java": "import java.util.HashSet;\nimport java.util.Set;\n\npublic int maxNumberOfCandies(int[] candyType) \n    // Your code here\n}\n\n",
            "python": "def maxNumberOfCandies(candyType):\n    # Your code here\n\n",
            "javascript": "function maxNumberOfCandies(candyType) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nint main() {\n    vector<int> candyType = $args;\n    int result = maxNumberOfCandies(candyType);\n    cout << result << endl;\n    return 0;\n}\n",
            "java": "public int maxNumberOfCandies(int[] candyType) {\n    Set<Integer> uniqueCandies = new HashSet<>();\n    for (int type : candyType) {\n        uniqueCandies.add(type);\n    }\n    return Math.min(uniqueCandies.size(), candyType.length / 2);\n}",
            "python": "if __name__ == \"__main__\":\n    candyType = $args[0]\n    result = maxNumberOfCandies(candyType)\n    print(result)",
            "javascript": "function main() {\n    const candyType = $args;\n    const result = maxNumberOfCandies(candyType);\n    console.log(result);\n}\n"
        }
    },
    "576": {
        "title": "Ball Out of Boundary Paths",
        "description": "You are given an `m x n` grid with a ball. The ball is initially at the position `[startRow, startColumn]`. You are allowed to move the ball to one of the four adjacent cells in the grid (possibly out of the grid crossing the grid boundary). You can apply **at most** `maxMove` moves to the ball. Your task is to determine the number of paths to move the ball out of the grid boundary. Return the result modulo `109 + 7`.",
        "example": "Example:\n\nInput: m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0\nOutput: 6\n\nExplanation: There are 6 possible paths to move the ball out of the grid boundary:\n1. [0, 0] -> [0, -1] -> [0, -2]\n2. [0, 0] -> [0, -1] -> [0, 0]\n3. [0, 0] -> [0, -1] -> [0, 1]\n4. [0, 0] -> [0, 0] -> [0, -1]\n5. [0, 0] -> [0, 0] -> [0, 1]\n6. [0, 0] -> [0, 1] -> [0, 0]",
        "level": "Medium",
        "tags": [
            "Dynamic Programming",
            "Grid",
            "Modulo"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    2,
                    2,
                    0,
                    0
                ],
                [
                    1,
                    3,
                    3,
                    0,
                    1
                ],
                [
                    3,
                    3,
                    3,
                    1,
                    1
                ],
                [
                    2,
                    3,
                    4,
                    0,
                    0
                ],
                [
                    4,
                    4,
                    5,
                    2,
                    2
                ],
                [
                    5,
                    5,
                    10,
                    2,
                    2
                ],
                [
                    3,
                    4,
                    6,
                    1,
                    2
                ],
                [
                    4,
                    5,
                    7,
                    0,
                    0
                ],
                [
                    5,
                    6,
                    8,
                    3,
                    4
                ],
                [
                    6,
                    7,
                    9,
                    1,
                    3
                ],
                [
                    7,
                    8,
                    10,
                    4,
                    5
                ],
                [
                    8,
                    9,
                    11,
                    2,
                    6
                ],
                [
                    9,
                    10,
                    12,
                    5,
                    7
                ],
                [
                    10,
                    11,
                    13,
                    3,
                    8
                ],
                [
                    11,
                    12,
                    14,
                    6,
                    9
                ],
                [
                    12,
                    13,
                    15,
                    4,
                    10
                ],
                [
                    13,
                    14,
                    16,
                    7,
                    11
                ],
                [
                    14,
                    15,
                    17,
                    5,
                    12
                ],
                [
                    15,
                    16,
                    18,
                    8,
                    13
                ],
                [
                    16,
                    17,
                    19,
                    6,
                    14
                ]
            ],
            "outputs": [
                6,
                12,
                24,
                16,
                104,
                1024,
                72,
                240,
                1024,
                576,
                2304,
                2048,
                9216,
                4096,
                18432,
                8192,
                36864,
                16384,
                73728,
                32768
            ]
        },
        "sample_code": {
            "c++": "int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\n    int MOD = 1e9 + 7;\n    vector<vector<vector<int>>> dp(maxMove + 1, vector<vector<int>>(m, vector<int>(n, 0)));\n    int moves[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    for (int k = 1; k <= maxMove; k++) {\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                for (auto move : moves) {\n                    int ni = i + move[0], nj = j + move[1];\n                    if (ni < 0 || ni >= m || nj < 0 || nj >= n) {\n                        dp[k][i][j] = (dp[k][i][j] + 1) % MOD;\n                    } else {\n                        dp[k][i][j] = (dp[k][i][j] + dp[k - 1][ni][nj]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n    return dp[maxMove][startRow][startColumn];\n}\n",
            "java": "public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\n    int MOD = 1000000007;\n    int[][][] dp = new int[maxMove + 1][m][n];\n    int[][] moves = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    for (int k = 1; k <= maxMove; k++) {\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int[] move : moves) {\n                    int ni = i + move[0], nj = j + move[1];\n                    if (ni < 0 || ni >= m || nj < 0 || nj >= n) {\n                        dp[k][i][j] = (dp[k][i][j] + 1) % MOD;\n                    } else {\n                        dp[k][i][j] = (dp[k][i][j] + dp[k - 1][ni][nj]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n    return dp[maxMove][startRow][startColumn];\n}\n",
            "python": "def findPaths(m, n, maxMove, startRow, startColumn):               \n    MOD = 10**9 + 7                     \n    dp = [[[0]* n for _ in range(m)] for _ in range(maxMove + 1)]\n    moves = ((-1, 0), (1, 0), (0, -1), (0, 1))\n\n    for k in range(1, maxMove + 1):                                \n        for i in range(m):                                         \n            for j in range(n):                                           \n                for move in moves:              \n                    ni, nj = i + move[0], j + move[1]\n                    if ni < 0 or ni >= m or nj < 0 or nj >= n:                                 \n                        dp[k][i][j] = (dp[k][i][j] + 1) % MOD          \n                    else:\n                        dp[k][i][j] = (dp[k][i][j] + dp[k - 1][ni][nj]) % MOD\n\n    return dp[maxMove][startRow][startColumn]\n",
            "javascript": "function findPaths(m, n, maxMove, startRow, startColumn) {\n    const MOD = 1e9 + 7;\n    let dp = new Array(maxMove + 1).fill(0).map(() => new Array(m).fill(0).map(() => new Array(n).fill(0)));\n    let moves = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n\n    for (let k = 1; k <= maxMove; k++) {\n        for (let i = 0; i < m; i++) {\n            for (let j = 0; j < n; j++) {\n                for (let move of moves) {\n                    let ni = i + move[0], nj = j + move[1];\n                    if (ni < 0 || ni >= m || nj < 0 || nj >= n) {\n                        dp[k][i][j] = (dp[k][i][j] + 1) % MOD;\n                    } else {\n                        dp[k][i][j] = (dp[k][i][j] + dp[k - 1][ni][nj]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n    return dp[maxMove][startRow][startColumn];\n}\n",
            "explanation": "We use dynamic programming to accumulate the ways to move the ball up to the maximum allowed moves. The `dp` array has dimensions `maxMove + 1` by `m` by `n`, where `dp[k][i][j]` represents the number of ways the ball can reach position `(i, j)` in exactly `k` moves.\n\nWe loop through moves from `1` to `maxMove`, and then loop through each cell of the grid. For each cell, we check each possible move direction. If moving in that direction causes the ball to cross the grid boundary (i.e., the new coordinates are outside of the grid), we increment the number of ways to move in exactly `k` moves by `1`. If the new coordinates are inside the grid, we add the number of ways to move to the new position in exactly `k - 1` moves to our current ways. We do this modulo `10^9 + 7` to prevent integer overflow.\n\nFinally, we return the number of ways to move the ball out of the grid boundary in exactly `maxMove` moves, which is stored at `dp[maxMove][startRow][startColumn]`."
        },
        "structure": {
            "c++": "int findPaths(int m, int n, int maxMove, int startRow, int startColumn) \n    // Your code here\n}\n",
            "java": "public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) \n    // Your code here\n}\n",
            "python": "def findPaths(m, n, maxMove, startRow, startColumn):               \n    # Your code here\n\n",
            "javascript": "function findPaths(m, n, maxMove, startRow, startColumn) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int m = $args;\n    int n = $args;\n    int maxMove = $args;\n    int startRow = $args;\n    int startColumn = $args;\n\n    int result = findPaths(m, n, maxMove, startRow, startColumn);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\n    int MOD = 1000000007;\n    int[][][] dp = new int[maxMove + 1][m][n];\n    int[][] moves = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    for (int k = 1; k <= maxMove; k++) {\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int[] move : moves) {\n                    int ni = i + move[0], nj = j + move[1];\n                    if (ni < 0 || ni >= m || nj < 0 || nj >= n) {\n                        dp[k][i][j] = (dp[k][i][j] + 1) % MOD;\n                    } else {\n                        dp[k][i][j] = (dp[k][i][j] + dp[k - 1][ni][nj]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n    return dp[maxMove][startRow][startColumn];\n}",
            "python": "if __name__ == \"__main__\":\n    m = $args[0]\n    n = $args[1]\n    maxMove = $args[2]\n    startRow = $args[3]\n    startColumn = $args[4]\n    result = findPaths(m, n, maxMove, startRow, startColumn)\n    print(result)",
            "javascript": "function findPaths(m, n, maxMove, startRow, startColumn) {\n    const MOD = 1e9 + 7;\n    let dp = new Array(maxMove + 1).fill(0).map(() => new Array(m).fill(0).map(() => new Array(n).fill(0)));\n    let moves = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n\n    for (let k = 1; k <= maxMove; k++) {\n        for (let i = 0; i < m; i++) {\n            for (let j = 0; j < n; j++) {\n                for (let move of moves) {\n                    let ni = i + move[0], nj = j + move[1];\n                    if (ni < 0 || ni >= m || nj < 0 || nj >= n) {\n                        dp[k][i][j] = (dp[k][i][j] + 1) % MOD;\n                    } else {\n                        dp[k][i][j] = (dp[k][i][j] + dp[k - 1][ni][nj]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n    return dp[maxMove][startRow][startColumn];\n}"
        }
    },
    "581": {
        "title": "Shortest Subarray to Sort",
        "description": "Given an integer array `nums`, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order. Return the shortest such subarray and output its length.",
        "example": "Example:\n\nInput: nums = [2,6,4,8,10,9,15]\nOutput: 5\nExplanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    6,
                    4,
                    8,
                    10,
                    9,
                    15
                ],
                [
                    1,
                    2,
                    3,
                    4
                ],
                [
                    1
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    3,
                    2,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15
                ],
                [
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    5,
                    4,
                    3,
                    2,
                    1,
                    11,
                    12,
                    13,
                    14,
                    15
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    5,
                    4,
                    3,
                    2,
                    1,
                    15,
                    14,
                    13,
                    12,
                    11
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    5,
                    4,
                    3,
                    2,
                    1,
                    15,
                    14,
                    13,
                    12,
                    11,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    5,
                    4,
                    3,
                    2,
                    1,
                    20,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    5,
                    4,
                    3,
                    2,
                    1,
                    20,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    21,
                    22,
                    23,
                    24,
                    25
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    5,
                    4,
                    3,
                    2,
                    1,
                    25,
                    24,
                    23,
                    22,
                    21,
                    20,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    5,
                    4,
                    3,
                    2,
                    1,
                    25,
                    24,
                    23,
                    22,
                    21,
                    20,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    26,
                    27,
                    28,
                    29,
                    30
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    5,
                    4,
                    3,
                    2,
                    1,
                    30,
                    29,
                    28,
                    27,
                    26,
                    25,
                    24,
                    23,
                    22,
                    21,
                    20,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11
                ]
            ],
            "outputs": [
                "5",
                "0",
                "0",
                "5",
                "2",
                "0",
                "10",
                "0",
                "10",
                "0",
                "0",
                "10",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint findUnsortedSubarray(vector<int>& nums) {\n    vector<int> sorted_nums(nums);\n    sort(sorted_nums.begin(), sorted_nums.end());\n    int start = 0, end = nums.size() - 1;\n    while (start < nums.size() && nums[start] == sorted_nums[start]) start++;\n    while (end > start && nums[end] == sorted_nums[end]) end--;\n    return end - start + 1;\n}\n",
            "java": "import java.util.Arrays;\n\npublic int findUnsortedSubarray(int[] nums) {\n    int[] sortedNums = nums.clone();\n    Arrays.sort(sortedNums);\n    int start = 0, end = nums.length - 1;\n    while (start < nums.length && nums[start] == sortedNums[start]) start++;\n    while (end > start && nums[end] == sortedNums[end]) end--;\n    return end - start + 1;\n}\n",
            "python": "def findUnsortedSubarray(nums):\n    sorted_nums = sorted(nums)\n    start, end = 0, len(nums) - 1\n    while start < len(nums) and nums[start] == sorted_nums[start]:\n        start += 1\n    while end > start and nums[end] == sorted_nums[end]:\n        end -= 1\n    return end - start + 1\n",
            "javascript": "function findUnsortedSubarray(nums) {\n    const sortedNums = [...nums].sort((a, b) => a - b);\n    let start = 0, end = nums.length - 1;\n    while (start < nums.length && nums[start] === sortedNums[start]) start++;\n    while (end > start && nums[end] === sortedNums[end]) end--;\n    return end - start + 1;\n}\n",
            "explanation": "1. Create a copy of the input array and sort it in ascending order.\n2. Initialize two variables, `start` and `end`, to check the boundaries of the unsorted subarray.\n3. Loop through the array, comparing the sorted copy and the original array. When we encounter a mismatch at some index, we break the loop and store the index in `start`. This `start` index is the beginning of the unsorted subarray.\n4. Similarly, we start from the end of the array and find the first mismatch. We store this index in `end`. This `end` index is the boundary of the unsorted subarray.\n5. Calculate the length of the unsorted subarray as `end - start + 1`."
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint findUnsortedSubarray(vector<int>& nums) \n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\n\npublic int findUnsortedSubarray(int[] nums) \n    // Your code here\n}\n",
            "python": "def findUnsortedSubarray(nums):\n    # Your code here\n\n",
            "javascript": "function findUnsortedSubarray(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    vector<int> nums = $args;\n    int result = findUnsortedSubarray(nums);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int findUnsortedSubarray(int[] nums) {\n    int[] sortedNums = nums.clone();\n    Arrays.sort(sortedNums);\n    int start = 0, end = nums.length - 1;\n    while (start < nums.length && nums[start] == sortedNums[start]) start++;\n    while (end > start && nums[end] == sortedNums[end]) end--;\n    return end - start + 1;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = findUnsortedSubarray(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const sortedNums = [...nums].sort((a, b) => a - b);\n    let start = 0, end = nums.length - 1;\n    while (start < nums.length && nums[start] === sortedNums[start]) start++;\n    while (end > start && nums[end] === sortedNums[end]) end--;\n    const result = end - start + 1;\n    console.log(result);\n}"
        }
    },
    "582": {
        "title": "Process Killing",
        "description": "You have `n` processes forming a rooted tree structure. You are given two integer arrays `pid` and `ppid`, where `pid[i]` is the ID of the `ith` process and `ppid[i]` is the ID of the `ith` process`s parent process.\n\nEach process has only **one parent process** but may have multiple children processes. Only one process has `ppid[i] = 0`, which means this process has **no parent process** (the root of the tree).\n\nWhen a process is **killed**, all of its children processes will also be killed.\n\nGiven an integer `kill` representing the ID of a process you want to kill, return _a list of the IDs of the processes that will be killed. You may return the answer in **any order**._",
        "example": "Example:\n\nInput:\npid = [1,3,10,5], ppid = [3,0,5,3], kill = 5\nOutput: [5,10]\nExplanation: The processes colored in red are the processes that should be killed.",
        "level": "Medium",
        "tags": [
            "tree",
            "process",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    3,
                    10,
                    5
                ],
                [
                    3,
                    0,
                    5,
                    3
                ],
                "5",
                [
                    1
                ],
                [
                    0
                ],
                "1",
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                "2",
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                "3",
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                "4",
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                "5",
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                "6",
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                "7",
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                "8",
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                "9",
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                "10"
            ],
            "outputs": [
                "[5,10]",
                "[1]",
                "[1]",
                "[1]",
                "[1]",
                "[1]",
                "[2,4,5]",
                "[2,4,5]",
                "[2]",
                "[3]",
                "[3]",
                "[4]",
                "[5]",
                "[5]",
                "[6]",
                "[7]",
                "[8]",
                "[9]",
                "[10]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> killProcess(vector<int>& pid, vector<int>& ppid, int kill) {\n    unordered_map<int, vector<int>> children;\n    for (int i = 0; i < pid.size(); i++) {\n        children[ppid[i]].push_back(pid[i]);\n    }\n\n    vector<int> killed;\n    function<void(int)> dfs = [&](int id) {\n        killed.push_back(id);\n        for (int child : children[id]) {\n            dfs(child);\n        }\n    };\n    dfs(kill);\n\n    return killed;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<Integer> killProcess(List<Integer> pid, List<Integer> ppid, int kill) {\n    Map<Integer, List<Integer>> children = new HashMap<>();\n    for (int i = 0; i < pid.size(); i++) {\n        children.computeIfAbsent(ppid.get(i), k -> new ArrayList<>()).add(pid.get(i));\n    }\n\n    List<Integer> killed = new ArrayList<>();\n    dfs(kill, children, killed);\n    return killed;\n}\n\nprivate void dfs(int id, Map<Integer, List<Integer>> children, List<Integer> killed) {\n    killed.add(id);\n    for (int child : children.getOrDefault(id, new ArrayList<>())) {\n        dfs(child, children, killed);\n    }\n}\n",
            "python": "from collections import defaultdict\n\ndef killProcess(pid, ppid, kill):\n    children = defaultdict(list)\n    for i in range(len(pid)):\n        children[ppid[i]].append(pid[i])\n\n    def dfs(id, killed):\n        killed.append(id)\n        for child in children[id]:\n            dfs(child, killed)\n\n    killed = []\n    dfs(kill, killed)\n    return killed\n",
            "javascript": "function killProcess(pid, ppid, kill) {\n  const children = new Map();\n  for (let i = 0; i < pid.length; i++) {\n    if (!children.has(ppid[i])) children.set(ppid[i], []);\n    children.get(ppid[i]).push(pid[i]);\n  }\n\n  const killed = [];\n  function dfs(id) {\n    killed.push(id);\n    const childList = children.get(id) || [];\n    for (const child of childList) {\n      dfs(child);\n    }\n  }\n  dfs(kill);\n\n  return killed;\n}\n",
            "explanation": "We use a hash map (unordered_map in C++, HashMap in Java, defaultdict in Python, Map in JavaScript) to store the children of each process. We iterate through the `pid` and `ppid` arrays to construct a tree-like data structure in the `children` map.\n\nWe then perform a depth-first search (DFS) starting from the `kill` process to traverse the tree and add all the processes to the `killed` list. The DFS function is implemented in a recursive manner, where we first add the current process id to the list `killed` and then iterate through its children.\n\nWe call the `dfs` function with the `kill` process id to construct the `killed` list and then return it."
        },
        "structure": {
            "c++": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> killProcess(vector<int>& pid, vector<int>& ppid, int kill) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<Integer> killProcess(List<Integer> pid, List<Integer> ppid, int kill) \n    // Your code here\n}\n",
            "python": "from collections import defaultdict\n    # Your code here\n\n",
            "javascript": "function killProcess(pid, ppid, kill) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> killProcess(vector<int>& pid, vector<int>& ppid, int kill) {\n    unordered_map<int, vector<int>> children;\n    for (int i = 0; i < pid.size(); i++) {\n        children[ppid[i]].push_back(pid[i]);\n    }\n\n    vector<int> killed;\n    function<void(int)> dfs = [&](int id) {\n        killed.push_back(id);\n        for (int child : children[id]) {\n            dfs(child);\n        }\n    };\n    dfs(kill);\n\n    return killed;\n}\n\nint main() {\n    vector<int> pid = $args;\n    vector<int> ppid = $args;\n    int kill = $args;\n    vector<int> result = killProcess(pid, ppid, kill);\n    for (int i : result) {\n        cout << i << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "java": "public List<Integer> killProcess(List<Integer> pid, List<Integer> ppid, int kill) {\n    Map<Integer, List<Integer>> children = new HashMap<>();\n    for (int i = 0; i < pid.size(); i++) {\n        children.computeIfAbsent(ppid.get(i), k -> new ArrayList<>()).add(pid.get(i));\n    }\n\n    List<Integer> killed = new ArrayList<>();\n    dfs(kill, children, killed);\n    return killed;\n}\n\nprivate void dfs(int id, Map<Integer, List<Integer>> children, List<Integer> killed) {\n    killed.add(id);\n    for (int child : children.getOrDefault(id, new ArrayList<>())) {\n        dfs(child, children, killed);\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    pid = $args[0]\n    ppid = $args[1]\n    kill = $args[2]\n    result = killProcess(pid, ppid, kill)\n    print(result)",
            "javascript": "function main() {\n  const pid = $args[0];\n  const ppid = $args[1];\n  const kill = $args[2];\n\n  const children = new Map();\n  for (let i = 0; i < pid.length; i++) {\n    if (!children.has(ppid[i])) children.set(ppid[i], []);\n    children.get(ppid[i]).push(pid[i]);\n  }\n\n  const killed = [];\n  function dfs(id) {\n    killed.push(id);\n    const childList = children.get(id) || [];\n    for (const child of childList) {\n      dfs(child);\n    }\n  }\n  dfs(kill);\n\n  return killed;\n}\n\nconst result = main();\nconsole.log(result);"
        }
    },
    "583": {
        "title": "Minimum Steps to Make Two Strings Same",
        "description": "Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same. In one step, you can delete exactly one character in either string.",
        "example": "Example:\n\nInput: word1 = \"sea\", word2 = \"eat\"\nOutput: 2\nExplanation: You need one step to make \"sea\" to \"ea\" and another step to make \"eat\" to \"ea\".",
        "level": "Easy",
        "tags": [
            "string",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    "sea",
                    "eat"
                ],
                [
                    "leetcode",
                    "etco"
                ],
                [
                    "abcde",
                    "abcde"
                ],
                [
                    "abcde",
                    "edcba"
                ],
                [
                    "abcde",
                    "abcdefg"
                ],
                [
                    "abcdefg",
                    "abcde"
                ],
                [
                    "abcde",
                    ""
                ],
                [
                    "",
                    "abcde"
                ],
                [
                    "",
                    ""
                ],
                [
                    "a",
                    "a"
                ],
                [
                    "a",
                    "b"
                ],
                [
                    "abc",
                    "def"
                ],
                [
                    "abc",
                    "ab"
                ],
                [
                    "ab",
                    "abc"
                ],
                [
                    "abc",
                    "abc"
                ],
                [
                    "abc",
                    "abcd"
                ],
                [
                    "abcd",
                    "abc"
                ],
                [
                    "abcde",
                    "abcdeabcde"
                ],
                [
                    "abcdeabcde",
                    "abcde"
                ]
            ],
            "outputs": [
                2,
                4,
                0,
                5,
                4,
                4,
                5,
                5,
                0,
                0,
                1,
                3,
                1,
                1,
                1,
                0,
                0,
                5,
                5,
                5
            ]
        },
        "sample_code": {
            "c++": "int minDistance(std::string word1, std::string word2) {\n    int m = word1.length(), n = word2.length();\n    std::vector<std::vector<int>> dp(m+1, std::vector<int>(n+1, 0));\n    \n    for(int i = 0; i <= m; i++) {\n        for(int j = 0; j <= n; j++) {\n            if(i == 0 || j == 0)\n                dp[i][j] = i + j;\n            else if(word1[i-1] == word2[j-1])\n                dp[i][j] = dp[i-1][j-1];\n            else\n                dp[i][j] = 1 + std::min(dp[i-1][j], dp[i][j-1]);\n        }\n    }\n    \n    return dp[m][n];\n}\n",
            "java": "public int minDistance(String word1, String word2) {\n    int m = word1.length(), n = word2.length();\n    int[][] dp = new int[m+1][n+1];\n\n    for(int i = 0; i <= m; i++) {\n        for(int j = 0; j <= n; j++) {\n            if(i == 0 || j == 0)\n                dp[i][j] = i + j;\n            else if(word1.charAt(i-1) == word2.charAt(j-1))\n                dp[i][j] = dp[i-1][j-1];\n            else\n                dp[i][j] = 1 + Math.min(dp[i-1][j], dp[i][j-1]);\n        }\n    }\n\n    return dp[m][n];\n}\n",
            "python": "def minDistance(word1, word2):\n    m, n = len(word1), len(word2)\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(m+1):\n        for j in range(n+1):\n            if i == 0 or j == 0:\n                dp[i][j] = i + j\n            elif word1[i-1] == word2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])\n\n    return dp[m][n]\n",
            "javascript": "function minDistance(word1, word2) {\n    let m = word1.length, n = word2.length;\n    let dp = new Array(m + 1).fill().map(() => new Array(n + 1).fill(0));\n\n    for(let i = 0; i <= m; i++) {\n        for(let j = 0; j <= n; j++) {\n            if(i === 0 || j === 0)\n                dp[i][j] = i + j;\n            else if(word1.charAt(i-1) === word2.charAt(j-1))\n                dp[i][j] = dp[i-1][j-1];\n            else\n                dp[i][j] = 1 + Math.min(dp[i-1][j], dp[i][j-1]);\n        }\n    }\n\n    return dp[m][n];\n}\n",
            "explanation": "The algorithm uses dynamic programming (DP) to solve the problem. It first initializes a 2D DP array `dp` with dimensions `m+1` by `n+1` where `m` is the length of `word1` and `n` is the length of `word2`. The DP entry `dp[i][j]` represents the minimum number of steps required to make the prefixes `word1[0...i-1]` and `word2[0...j-1]` equal. \n\nThe algorithm then populates the DP table using the following rules:\n1. If either `i` or `j` is 0, then `dp[i][j] = i + j` since it needs to delete all characters from the other string.\n2. If `word1[i-1]` is the same as `word2[j-1]`, then `dp[i][j] = dp[i-1][j-1]`.\n3. Else, `dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])`, as we can either remove `word1[i-1]` or `word2[j-1]`.\n\nFinally, the algorithm returns the value `dp[m][n]` as it represents the minimum number of steps required to make the two input strings equal."
        },
        "structure": {
            "c++": "int minDistance(std::string word1, std::string word2) \n    // Your code here\n}\n",
            "java": "public int minDistance(String word1, String word2) \n    // Your code here\n}\n",
            "python": "def minDistance(word1, word2):\n    # Your code here\n\n",
            "javascript": "function minDistance(word1, word2) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int minDistance(std::string word1, std::string word2) {\n    int m = word1.length(), n = word2.length();\n    std::vector<std::vector<int>> dp(m+1, std::vector<int>(n+1, 0));\n    \n    for(int i = 0; i <= m; i++) {\n        for(int j = 0; j <= n; j++) {\n            if(i == 0 || j == 0)\n                dp[i][j] = i + j;\n            else if(word1[i-1] == word2[j-1])\n                dp[i][j] = dp[i-1][j-1];\n            else\n                dp[i][j] = 1 + std::min(dp[i-1][j], dp[i][j-1]);\n        }\n    }\n    \n    return dp[m][n];\n}",
            "java": "public int minDistance(String word1, String word2) {\n    int m = word1.length(), n = word2.length();\n    int[][] dp = new int[m+1][n+1];\n\n    for(int i = 0; i <= m; i++) {\n        for(int j = 0; j <= n; j++) {\n            if(i == 0 || j == 0)\n                dp[i][j] = i + j;\n            else if(word1.charAt(i-1) == word2.charAt(j-1))\n                dp[i][j] = dp[i-1][j-1];\n            else\n                dp[i][j] = 1 + Math.min(dp[i-1][j], dp[i][j-1]);\n        }\n    }\n\n    return dp[m][n];\n}",
            "python": "if __name__ == \"__main__\":\n    word1 = $args[0]\n    word2 = $args[1]\n    result = minDistance(word1, word2)\n    print(result)",
            "javascript": "function main() {\n    const word1 = $args[0];\n    const word2 = $args[1];\n    const result = minDistance(word1, word2);\n    console.log(result);\n}"
        }
    },
    "587": {
        "title": "Fence the Garden",
        "description": "You are given an array `trees` where `trees[i] = [xi, yi]` represents the location of a tree in the garden. Fence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if all the trees are enclosed. Return the coordinates of trees that are exactly located on the fence perimeter. You may return the answer in any order.",
        "example": "Example 1:\n\nInput: trees = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\nOutput: [[1,1],[2,0],[4,2],[3,3],[2,4]]\nExplanation: All the trees will be on the perimeter of the fence except the tree at [2, 2], which will be inside the fence.\n\nExample 2:\n\nInput: trees = [[1,2],[2,2],[4,2]]\nOutput: [[4,2],[2,2],[1,2]]\nExplanation: The fence forms a line that passes through all the trees.",
        "level": "Medium",
        "tags": [
            "array",
            "geometry"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        2
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        4,
                        2
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        1,
                        0
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ],
                    [
                        26,
                        26
                    ],
                    [
                        27,
                        27
                    ],
                    [
                        28,
                        28
                    ],
                    [
                        29,
                        29
                    ],
                    [
                        30,
                        30
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ],
                    [
                        26,
                        26
                    ],
                    [
                        27,
                        27
                    ],
                    [
                        28,
                        28
                    ],
                    [
                        29,
                        29
                    ],
                    [
                        30,
                        30
                    ],
                    [
                        31,
                        31
                    ],
                    [
                        32,
                        32
                    ],
                    [
                        33,
                        33
                    ],
                    [
                        34,
                        34
                    ],
                    [
                        35,
                        35
                    ],
                    [
                        36,
                        36
                    ],
                    [
                        37,
                        37
                    ],
                    [
                        38,
                        38
                    ],
                    [
                        39,
                        39
                    ],
                    [
                        40,
                        40
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ],
                    [
                        26,
                        26
                    ],
                    [
                        27,
                        27
                    ],
                    [
                        28,
                        28
                    ],
                    [
                        29,
                        29
                    ],
                    [
                        30,
                        30
                    ],
                    [
                        31,
                        31
                    ],
                    [
                        32,
                        32
                    ],
                    [
                        33,
                        33
                    ],
                    [
                        34,
                        34
                    ],
                    [
                        35,
                        35
                    ],
                    [
                        36,
                        36
                    ],
                    [
                        37,
                        37
                    ],
                    [
                        38,
                        38
                    ],
                    [
                        39,
                        39
                    ],
                    [
                        40,
                        40
                    ],
                    [
                        41,
                        41
                    ],
                    [
                        42,
                        42
                    ],
                    [
                        43,
                        43
                    ],
                    [
                        44,
                        44
                    ],
                    [
                        45,
                        45
                    ],
                    [
                        46,
                        46
                    ],
                    [
                        47,
                        47
                    ],
                    [
                        48,
                        48
                    ],
                    [
                        49,
                        49
                    ],
                    [
                        50,
                        50
                    ]
                ]
            ],
            "outputs": [
                "[[1,1],[2,0],[4,2],[3,3],[2,4]]",
                "[[4,2],[2,2],[1,2]]",
                "[[0,0],[0,1],[1,1],[1,0]]",
                "[[1,1],[2,2],[3,3],[4,4],[5,5]]",
                "[[1,1],[2,2],[3,3],[4,4],[5,5],[6,6],[7,7],[8,8],[9,9],[10,10]]",
                "[[1,1],[2,2],[3,3],[4,4],[5,5],[6,6],[7,7],[8,8],[9,9],[10,10],[11,11],[12,12],[13,13],[14,14],[15,15]]",
                "[[1,1],[2,2],[3,3],[4,4],[5,5],[6,6],[7,7],[8,8],[9,9],[10,10],[11,11],[12,12],[13,13],[14,14],[15,15],[16,16],[17,17],[18,18],[19,19],[20,20]]",
                "[[1,1],[2,2],[3,3],[4,4],[5,5],[6,6],[7,7],[8,8],[9,9],[10,10],[11,11],[12,12],[13,13],[14,14],[15,15],[16,16],[17,17],[18,18],[19,19],[20,20],[21,21],[22,22],[23,23],[24,24],[25,25]]",
                "[[1,1],[2,2],[3,3],[4,4],[5,5],[6,6],[7,7],[8,8],[9,9],[10,10],[11,11],[12,12],[13,13],[14,14],[15,15],[16,16],[17,17],[18,18],[19,19],[20,20],[21,21],[22,22],[23,23],[24,24],[25,25],[26,26],[27,27],[28,28],[29,29],[30,30]]",
                "[[1,1],[2,2],[3,3],[4,4],[5,5],[6,6],[7,7],[8,8],[9,9],[10,10],[11,11],[12,12],[13,13],[14,14],[15,15],[16,16],[17,17],[18,18],[19,19],[20,20],[21,21],[22,22],[23,23],[24,24],[25,25],[26,26],[27,27],[28,28],[29,29],[30,30],[31,31],[32,32],[33,33],[34,34],[35,35],[36,36],[37,37],[38,38],[39,39],[40,40]]",
                "[[1,1],[2,2],[3,3],[4,4],[5,5],[6,6],[7,7],[8,8],[9,9],[10,10],[11,11],[12,12],[13,13],[14,14],[15,15],[16,16],[17,17],[18,18],[19,19],[20,20],[21,21],[22,22],[23,23],[24,24],[25,25],[26,26],[27,27],[28,28],[29,29],[30,30],[31,31],[32,32],[33,33],[34,34],[35,35],[36,36],[37,37],[38,38],[39,39],[40,40],[41,41],[42,42],[43,43],[44,44],[45,45],[46,46],[47,47],[48,48],[49,49],[50,50]]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool compare(const vector<int>& p, const vector<int>& q) {\n    return p[0] < q[0] || (p[0] == q[0] && p[1] < q[1]);\n}\n\nint cross_product(const vector<int>& p, const vector<int>& q, const vector<int>& r) {\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n}\n\nvector<vector<int>> fence(vector<vector<int>>& trees) {\n    sort(trees.begin(), trees.end(), compare);\n    vector<vector<int>> hull;\n    for (const auto& p : trees) {\n        while (hull.size() >= 2 && cross_product(hull[hull.size() - 2], hull[hull.size() - 1], p) > 0) {\n            hull.pop_back();\n        }\n        hull.push_back(p);\n    }\n    for (int i = trees.size() - 1; i >= 0; --i) {\n        const auto& p = trees[i];\n        while (hull.size() >= 2 && cross_product(hull[hull.size() - 2], hull[hull.size() - 1], p) > 0) {\n            hull.pop_back();\n        }\n        hull.push_back(p);\n    }\n    return hull;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n    private static int[][] fence(int[][] trees) {\n        Arrays.sort(trees, (p, q) -> p[0] == q[0] ? p[1] - q[1] : p[0] - q[0]);\n        List<int[]> hull = new ArrayList<>();\n        for (int[] p : trees) {\n            while (hull.size() >= 2 && crossProduct(hull.get(hull.size() - 2), hull.get(hull.size() - 1), p) > 0) {\n                hull.remove(hull.size() - 1);\n            }\n            hull.add(p);\n        }\n        for (int i = trees.length - 1; i >= 0; i--) {\n            int[] p = trees[i];\n            while (hull.size() >= 2 && crossProduct(hull.get(hull.size() - 2), hull.get(hull.size() - 1), p) > 0) {\n                hull.remove(hull.size() - 1);\n            }\n            hull.add(p);\n        }\n        return hull.toArray(new int[hull.size()][]);\n    }\n\n    private static int crossProduct(int[] p, int[] q, int[] r) {\n        return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n    }\n}\n",
            "python": "def cross_product(p, q, r):\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n\ndef fence(trees):\n    trees.sort(key=lambda p: (p[0], p[1]))\n    hull = []\n    for p in trees:\n        while len(hull) >= 2 and cross_product(hull[-2], hull[-1], p) > 0:\n            hull.pop()\n        hull.append(p)\n\n    for p in reversed(trees):\n        while len(hull) >= 2 and cross_product(hull[-2], hull[-1], p) > 0:\n            hull.pop()\n        hull.append(p)\n    \n    return hull\n",
            "javascript": "function crossProduct(p, q, r) {\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n}\n\nfunction fence(trees) {\n    trees.sort((p, q) => p[0] === q[0] ? p[1] - q[1] : p[0] - q[0]);\n    const hull = [];\n    for (const p of trees) {\n        while (hull.length >= 2 && crossProduct(hull[hull.length - 2], hull[hull.length - 1], p) > 0) {\n            hull.pop();\n        }\n        hull.push(p);\n    }\n    for (let i = trees.length - 1; i >= 0; i--) {\n        const p = trees[i];\n        while (hull.length >= 2 && crossProduct(hull[hull.length - 2], hull[hull.length - 1], p) > 0) {\n            hull.pop();\n        }\n        hull.push(p);\n    }\n    return hull;\n}\n",
            "explanation": "We use the **Graham's Scan Algorithm** to find the convex hull or the trees that form the fence perimeter. This algorithm works in O(n log n) time complexity.\n\n1. First, we sort the trees based on their x coordinates. If two trees have the same x coordinate, they are sorted by their y coordinates.\n2. We create an empty list called `hull` to store the trees that belong to the convex hull.\n3. Iterate through the sorted `trees` and:\n   a. For each tree `p`, we check if `hull` has at least two trees and the cross product of the last two trees and `p` is greater than 0.\n   b. If the cross product is greater than 0, then the last tree in the `hull` doesn't belong to the convex hull, so we remove it.\n   c. Add tree `p` to the `hull`.\n4. Now we iterate through the sorted `trees` in reverse order and repeat steps 3a-3c.\n5. At the end, the `hull` contains the coordinates of the trees that form the fence perimeter."
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool compare(const vector<int>& p, const vector<int>& q) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution \n    // Your code here\n}\n",
            "python": "def cross_product(p, q, r):\n    # Your code here\n\n",
            "javascript": "function crossProduct(p, q, r) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nbool compare(const vector<int>& p, const vector<int>& q) {\n    return p[0] < q[0] || (p[0] == q[0] && p[1] < q[1]);\n}\n\nint cross_product(const vector<int>& p, const vector<int>& q, const vector<int>& r) {\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n}\n\nvector<vector<int>> fence(vector<vector<int>>& trees) {\n    sort(trees.begin(), trees.end(), compare);\n    vector<vector<int>> hull;\n    for (const auto& p : trees) {\n        while (hull.size() >= 2 && cross_product(hull[hull.size() - 2], hull[hull.size() - 1], p) > 0) {\n            hull.pop_back();\n        }\n        hull.push_back(p);\n    }\n    for (int i = trees.size() - 1; i >= 0; --i) {\n        const auto& p = trees[i];\n        while (hull.size() >= 2 && cross_product(hull[hull.size() - 2], hull[hull.size() - 1], p) > 0) {\n            hull.pop_back();\n        }\n        hull.push_back(p);\n    }\n    return hull;\n}\n\nint main() {\n    vector<vector<int>> trees = $args;\n    vector<vector<int>> result = fence(trees);\n    for (const auto& p : result) {\n        cout << p[0] << \" \" << p[1] << endl;\n    }\n    return 0;\n}",
            "java": "private static int[][] fence(int[][] trees) {\n        Arrays.sort(trees, (p, q) -> p[0] == q[0] ? p[1] - q[1] : p[0] - q[0]);\n        List<int[]> hull = new ArrayList<>();\n        for (int[] p : trees) {\n            while (hull.size() >= 2 && crossProduct(hull.get(hull.size() - 2), hull.get(hull.size() - 1), p) > 0) {\n                hull.remove(hull.size() - 1);\n            }\n            hull.add(p);\n        }\n        for (int i = trees.length - 1; i >= 0; i--) {\n            int[] p = trees[i];\n            while (hull.size() >= 2 && crossProduct(hull.get(hull.size() - 2), hull.get(hull.size() - 1), p) > 0) {\n                hull.remove(hull.size() - 1);\n            }\n            hull.add(p);\n        }\n        return hull.toArray(new int[hull.size()][]);\n    }",
            "python": "if __name__ == \"__main__\":\n    trees = $args[0]\n    result = fence(trees)\n    print(result)",
            "javascript": "function fence(trees) {\n    trees.sort((p, q) => p[0] === q[0] ? p[1] - q[1] : p[0] - q[0]);\n    const hull = [];\n    for (const p of trees) {\n        while (hull.length >= 2 && crossProduct(hull[hull.length - 2], hull[hull.length - 1], p) > 0) {\n            hull.pop();\n        }\n        hull.push(p);\n    }\n    for (let i = trees.length - 1; i >= 0; i--) {\n        const p = trees[i];\n        while (hull.length >= 2 && crossProduct(hull[hull.length - 2], hull[hull.length - 1], p) > 0) {\n            hull.pop();\n        }\n        hull.push(p);\n    }\n    return hull;\n}"
        }
    },
    "591": {
        "title": "Tag Validator",
        "description": "Given a string representing a code snippet, implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if it satisfies certain rules regarding closed tags, tag names, tag content, and CDATA. Write a function that takes a code snippet as input and returns true if it is valid, and false otherwise.",
        "example": "Example:\n\nInput: code = \"<TAG_NAME>Tag Content</TAG_NAME>\"\nOutput: true\nExplanation: The code is wrapped in a closed tag <TAG_NAME></TAG_NAME>. The TAG_NAME is valid, and the TAG_CONTENT is valid. Therefore, the code is valid.\n\nInput: code = \"<TAG_NAME>Tag Content</WRONG_TAG_NAME>\"\nOutput: false\nExplanation: The code is wrapped in a closed tag <TAG_NAME></WRONG_TAG_NAME>. The TAG_NAME is valid, but the TAG_CONTENT is invalid because it contains an unmatched start tag and an unmatched or closed tag with an invalid TAG_NAME. Therefore, the code is invalid.",
        "level": "Medium",
        "tags": [
            "string",
            "parsing",
            "validation"
        ],
        "test_cases": {
            "inputs": [
                "\"<TAG_NAME>Tag Content</TAG_NAME>\"",
                "\"<TAG_NAME>Tag Content</WRONG_TAG_NAME>\"",
                "\"<TAG_NAME>Tag Content</TAG_NAME><TAG_NAME>Tag Content</TAG_NAME>\"",
                "\"<TAG_NAME>Tag Content</TAG_NAME><WRONG_TAG_NAME>Tag Content</WRONG_TAG_NAME>\"",
                "\"<TAG_NAME>Tag Content</TAG_NAME><TAG_NAME>Tag Content</WRONG_TAG_NAME>\"",
                "\"<TAG_NAME>Tag Content</TAG_NAME><WRONG_TAG_NAME>Tag Content</TAG_NAME>\"",
                "\"<TAG_NAME>Tag Content</TAG_NAME><TAG_NAME>Tag Content</TAG_NAME><TAG_NAME>Tag Content</TAG_NAME>\"",
                "\"<TAG_NAME>Tag Content</TAG_NAME><WRONG_TAG_NAME>Tag Content</WRONG_TAG_NAME><TAG_NAME>Tag Content</TAG_NAME>\"",
                "\"<TAG_NAME>Tag Content</TAG_NAME><TAG_NAME>Tag Content</WRONG_TAG_NAME><TAG_NAME>Tag Content</TAG_NAME>\"",
                "\"<TAG_NAME>Tag Content</TAG_NAME><WRONG_TAG_NAME>Tag Content</TAG_NAME><TAG_NAME>Tag Content</WRONG_TAG_NAME>\"",
                "\"<TAG_NAME>Tag Content</TAG_NAME><WRONG_TAG_NAME>Tag Content</WRONG_TAG_NAME><TAG_NAME>Tag Content</WRONG_TAG_NAME>\"",
                "\"<TAG_NAME>Tag Content</TAG_NAME><TAG_NAME>Tag Content</TAG_NAME><TAG_NAME>Tag Content</WRONG_TAG_NAME>\"",
                "\"<TAG_NAME>Tag Content</TAG_NAME><WRONG_TAG_NAME>Tag Content</WRONG_TAG_NAME><TAG_NAME>Tag Content</WRONG_TAG_NAME>\"",
                "\"<TAG_NAME>Tag Content</TAG_NAME><TAG_NAME>Tag Content</WRONG_TAG_NAME><TAG_NAME>Tag Content</WRONG_TAG_NAME>\"",
                "\"<TAG_NAME>Tag Content</TAG_NAME><WRONG_TAG_NAME>Tag Content</TAG_NAME><TAG_NAME>Tag Content</WRONG_TAG_NAME>\"",
                "\"<TAG_NAME>Tag Content</TAG_NAME><WRONG_TAG_NAME>Tag Content</WRONG_TAG_NAME><TAG_NAME>Tag Content</TAG_NAME>\"",
                "\"<TAG_NAME>Tag Content</TAG_NAME><TAG_NAME>Tag Content</TAG_NAME><TAG_NAME>Tag Content</TAG_NAME><TAG_NAME>Tag Content</TAG_NAME>\"",
                "\"<TAG_NAME>Tag Content</TAG_NAME><WRONG_TAG_NAME>Tag Content</WRONG_TAG_NAME><TAG_NAME>Tag Content</TAG_NAME><TAG_NAME>Tag Content</TAG_NAME>\"",
                "\"<TAG_NAME>Tag Content</TAG_NAME><TAG_NAME>Tag Content</WRONG_TAG_NAME><TAG_NAME>Tag Content</TAG_NAME><TAG_NAME>Tag Content</TAG_NAME>\"",
                "\"<TAG_NAME>Tag Content</TAG_NAME><WRONG_TAG_NAME>Tag Content</TAG_NAME><TAG_NAME>Tag Content</WRONG_TAG_NAME><TAG_NAME>Tag Content</TAG_NAME>\"",
                "\"<TAG_NAME>Tag Content</TAG_NAME><WRONG_TAG_NAME>Tag Content</WRONG_TAG_NAME><TAG_NAME>Tag Content</WRONG_TAG_NAME><TAG_NAME>Tag Content</TAG_NAME>\""
            ],
            "outputs": [
                true,
                false,
                true,
                false,
                false,
                false,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                true,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "bool is_valid(const std::string& code, size_t &i) {\n    if (i >= code.size()) return false;\n    if (code[i] != '<') return false;\n    int name_len = 0;\n    for (++i; i < code.size() && name_len < 9 && isupper(code[i]); ++i) ++name_len;\n    if (name_len < 1 || name_len > 9 || code[i++] != '>') return false;\n\n    while (i < code.size() && code[i] != '<') ++i;\n    if (i >= code.size()) return false;\n\n    if (code.substr(i, name_len + 3) != \"</\" + code.substr(i - name_len - 1, name_len) + \">\") \n        return false;\n    i += name_len + 3;\n    return true;\n}\n\nbool validateCodeSnippet(const std::string &code) {\n    size_t i = 0;\n    return is_valid(code, i) && i == code.size();\n}\n",
            "java": "private static boolean isValid(String code, int[] i) {\n    if (i[0] >= code.length()) return false;\n    if (code.charAt(i[0]) != '<') return false;\n    int nameLength = 0;\n    for (++i[0]; i[0] < code.length() && nameLength < 9 && Character.isUpperCase(code.charAt(i[0])); ++i[0]) ++nameLength;\n    if (nameLength < 1 || nameLength > 9 || code.charAt(i[0]++) != '>') return false;\n\n    while (i[0] < code.length() && code.charAt(i[0]) != '<') ++i[0];\n    if (i[0] >= code.length()) return false;\n\n    if (!code.substring(i[0], i[0] + nameLength + 3).equals(\"</\" + code.substring(i[0] - nameLength - 1, i[0] - 1) + \">\"))\n        return false;\n    i[0] += nameLength + 3;\n    return true;\n}\n\npublic static boolean validateCodeSnippet(String code) {\n    int[] i = {0};\n    return isValid(code, i) && i[0] == code.length();\n}\n",
            "python": "def is_valid(code, i):\n    if i >= len(code) or code[i] != '<':\n        return False, i\n    i += 1\n    name_start = i\n    while i < len(code) and code[i].isupper():\n        i += 1\n    name_len = i - name_start\n    if name_len < 1 or name_len > 9 or code[i] != '>':\n        return False, i\n    i += 1\n\n    while i < len(code) and code[i] != '<':\n        i += 1\n    if i + 2 + name_len >= len(code) or code[i:i + 2 + name_len] != '</' + code[name_start:i] + '>':\n        return False, i\n    return True, i + 2 + name_len\n\ndef validate_code_snippet(code):\n    is_valid_code, i = is_valid(code, 0)\n    return is_valid_code and i == len(code)\n",
            "javascript": "function isValid(code, i) {\n    if (!code || i.value >= code.length) return false;\n    if (code[i.value] != '<') return false;\n    let nameLength = 0;\n    for (++i.value; i.value < code.length && nameLength < 9 && /^[A-Z]$/.test(code[i.value]); ++i.value) ++nameLength;\n    if (nameLength < 1 || nameLength > 9 || code[i.value++] != '>') return false;\n\n    while (i.value < code.length && code[i.value] != '<') ++i.value;\n    if (i.value >= code.length) return false;\n\n    if (code.substring(i.value, i.value + nameLength + 3) != \"</\" + code.substring(i.value - nameLength - 1, i.value-1) + \">\")\n        return false;\n    i.value += nameLength + 3;\n    return true;\n}\n\nfunction validateCodeSnippet(code) {\n    let i = {value: 0};\n    return isValid(code, i) && i.value == code.length;\n}\n",
            "explanation": "The algorithm iterates through the code snippet and checks for valid start tags and end tags. It checks for the following conditions:\n1. The code snippet begins with a start tag and ends with a matching end tag.\n2. A start tag starts with `<` followed by uppercase alphabet letters and ends with `>`.\n3. An end tag is a string like `</TAG_NAME>` with no extra characters after the tag name, and TAG_NAME in the end tag is the same as the start tag.\n4. Valid tags don't have any other tags inside them but can have single or double quotes as a regular text element.\n\nWe use helper functions `is_valid` or `isValid` in each language to traverse the code string and match start tags with their corresponding end tags. It returns a boolean value indicating if the code is valid or not, and also updates the current index of the string traversal, which is passed as a reference or a mutable object.\n\nThe main function `validate_code_snippet` or `validateCodeSnippet` calls the helper function and checks if the returned boolean value is True and the updated index is equal to the length of the code string, which means the entire code snippet was traversed and validated successfully. If both conditions are met, the code snippet is valid, otherwise it is invalid."
        },
        "structure": {
            "c++": "bool is_valid(const std::string& code, size_t &i) \n    // Your code here\n}\n",
            "java": "private static boolean isValid(String code, int[] i) \n    // Your code here\n}\n",
            "python": "def is_valid(code, i):\n    # Your code here\n\n",
            "javascript": "function isValid(code, i) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "bool validateCodeSnippet(const std::string &code) {\n    size_t i = 0;\n    return is_valid(code, i) && i == code.size();\n}",
            "java": "public static boolean validateCodeSnippet(String code) {\n    int[] i = {0};\n    return isValid(code, i) && i[0] == code.length();\n}",
            "python": "if __name__ == \"__main__\":\n    code = $args[0]\n    result = validate_code_snippet(code)\n    print(result)",
            "javascript": "function validateCodeSnippet(code) {\n    let i = {value: 0};\n    return isValid(code, i) && i.value == code.length;\n}"
        }
    },
    "592": {
        "title": "Fraction Calculation",
        "description": "Given a string `expression` representing an expression of fraction addition and subtraction, return the calculation result in string format. The final result should be an irreducible fraction. If the final result is an integer, it should be converted to the format of a fraction with a denominator of 1.",
        "example": "Example:\n\nInput: expression = \"-1/2+1/2\"\nOutput: \"0/1\"\n\nExplanation: The expression \"-1/2+1/2\" can be simplified to \"0/1\".",
        "level": "Easy",
        "tags": [
            "math",
            "string"
        ],
        "test_cases": {
            "inputs": [
                "\"-1/2+1/2\"",
                "\"-1/2+1/2+1/3\"",
                "\"1/3-1/2\"",
                "\"2/3+1/4-1/5\"",
                "\"1/2+1/4+1/8\"",
                "\"1/2-1/4-1/8\"",
                "\"1/2+1/3-1/4\"",
                "\"1/2+1/3+1/4\"",
                "\"1/2-1/3-1/4\"",
                "\"1/2+1/3+1/4+1/5\"",
                "\"1/2-1/3-1/4-1/5\"",
                "\"1/2+1/3+1/4+1/5+1/6\"",
                "\"1/2-1/3-1/4-1/5-1/6\"",
                "\"1/2+1/3+1/4+1/5+1/6+1/7\"",
                "\"1/2-1/3-1/4-1/5-1/6-1/7\"",
                "\"1/2+1/3+1/4+1/5+1/6+1/7+1/8\"",
                "\"1/2-1/3-1/4-1/5-1/6-1/7-1/8\"",
                "\"1/2+1/3+1/4+1/5+1/6+1/7+1/8+1/9\"",
                "\"1/2-1/3-1/4-1/5-1/6-1/7-1/8-1/9\"",
                "\"1/2+1/3+1/4+1/5+1/6+1/7+1/8+1/9+1/10\"",
                "\"1/2-1/3-1/4-1/5-1/6-1/7-1/8-1/9-1/10\""
            ],
            "outputs": [
                "\"0/1\"",
                "\"1/3\"",
                "\"-1/6\"",
                "\"19/60\"",
                "\"7/8\"",
                "\"3/8\"",
                "\"5/12\"",
                "\"13/24\"",
                "\"1/2\"",
                "\"137/252\"",
                "\"-137/252\"",
                "\"49/120\"",
                "\"-49/120\"",
                "\"363/840\"",
                "\"-363/840\"",
                "\"761/1680\"",
                "\"-761/1680\"",
                "\"1457/3024\"",
                "\"-1457/3024\"",
                "\"2563/5040\"",
                "\"-2563/5040\""
            ]
        },
        "sample_code": {
            "c++": "#include <algorithm>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nstring fractionAddition(string expression) {\n    stringstream ss(expression);\n    int num, den, A = 0, B = 1;\n    char ch;\n\n    while (ss >> num >> ch >> den) {\n        A = A * den + B * num;\n        B *= den;\n        int GCD = gcd(abs(A), abs(B));\n        A /= GCD;\n        B /= GCD;\n    }\n\n    return to_string(A) + \"/\" + to_string(B);\n}\n",
            "java": "public class Solution {\n    public String fractionAddition(String expression) {\n        int A = 0, B = 1;\n        int i = 0;\n        while(i < expression.length()) {\n            int sign = expression.charAt(i++) == '+' ? 1 : -1;\n            int num = 0, den = 0;\n            while (i < expression.length() && Character.isDigit(expression.charAt(i))) {\n                num = num * 10 + (expression.charAt(i++) - '0');\n            }\n            i++; // skip '/'\n            while (i < expression.length() && Character.isDigit(expression.charAt(i))) {\n                den = den * 10 + (expression.charAt(i++) - '0');\n            }\n            A = A * den + B * num * sign;\n            B *= den;\n            int GCD = gcd(Math.abs(A), Math.abs(B));\n            A /= GCD;\n            B /= GCD;\n        }\n        return A + \"/\" + B;\n    }\n\n    private int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n}\n",
            "python": "from fractions import Fraction\n\ndef fractionAddition(expression: str) -> str:\n    fractions = expression.replace('+', ' +').replace('-', ' -').split()\n    result = sum(Fraction(fraction) for fraction in fractions)\n    return f\"{result.numerator}/{result.denominator}\"\n",
            "javascript": "function gcd(a, b) {\n    return b === 0 ? a : gcd(b, a % b);\n}\n\nfunction fractionAddition(expression) {\n    let A = 0, B = 1;\n    let i = 0;\n    while (i < expression.length) {\n        const sign = expression[i++] === '+' ? 1 : -1;\n        let num = 0, den = 0;\n        while (i < expression.length && !isNaN(expression[i])) {\n            num = num * 10 + parseInt(expression[i++]);\n        }\n        i++; // skip '/'\n        while (i < expression.length && !isNaN(expression[i])) {\n            den = den * 10 + parseInt(expression[i++]);\n        }\n        A = A * den + B * num * sign;\n        B *= den;\n        const GCD = gcd(Math.abs(A), Math.abs(B));\n        A /= GCD;\n        B /= GCD;\n    }\n    return `${A}/${B}`;\n}\n",
            "explanation": "The algorithm first initializes the result fraction A/B to 0/1. It then iterates over the input expression, parsing and adjusting signs of each fraction it encounters. Each fraction's numerator and denominator are found by parsing the characters in the expression. The current sum A/B is updated with the current fraction by the equation:\n\nA = A * den + B * num * sign\nB *= den\n\nAfter updating A/B, the greatest common divisor (GCD) of A and B, found using the Euclidean algorithm, is used to reduce the fraction.\n\nThe process is repeated until the whole string input expression is processed. At the end, the irreducible fraction is returned in the format A/B."
        },
        "structure": {
            "c++": "#include <algorithm>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint gcd(int a, int b) \n    // Your code here\n}\n",
            "java": "public class Solution \n    // Your code here\n}\n",
            "python": "from fractions import Fraction\n    # Your code here\n\n",
            "javascript": "function gcd(a, b) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <algorithm>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint main() {\n    string expression = $args;\n    string result = fractionAddition(expression);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public String fractionAddition(String expression) {\n        int A = 0, B = 1;\n        int i = 0;\n        while(i < expression.length()) {\n            int sign = expression.charAt(i++) == '+' ? 1 : -1;\n            int num = 0, den = 0;\n            while (i < expression.length() && Character.isDigit(expression.charAt(i))) {\n                num = num * 10 + (expression.charAt(i++) - '0');\n            }\n            i++; // skip '/'\n            while (i < expression.length() && Character.isDigit(expression.charAt(i))) {\n                den = den * 10 + (expression.charAt(i++) - '0');\n            }\n            A = A * den + B * num * sign;\n            B *= den;\n            int GCD = gcd(Math.abs(A), Math.abs(B));\n            A /= GCD;\n            B /= GCD;\n        }\n        return A + \"/\" + B;\n    }",
            "python": "if __name__ == \"__main__\":\n    expression = $args[0]\n    result = fractionAddition(expression)\n    print(result)",
            "javascript": "function main() {\n    const expression = $args;\n    const result = fractionAddition(expression);\n    console.log(result);\n}"
        }
    },
    "593": {
        "title": "Square Construction",
        "description": "Given the coordinates of four points in 2D space `p1`, `p2`, `p3` and `p4`, determine if they construct a square. A valid square has four equal sides with positive length and four equal angles (90-degree angles).",
        "example": "Example:\n\nInput: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]\nOutput: true\n\nExplanation: The four points form a square with side length 1 and 90-degree angles at each corner.",
        "level": "Easy",
        "tags": [
            "geometry",
            "math"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        0,
                        1
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        0,
                        12
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        -1,
                        0
                    ],
                    [
                        0,
                        1
                    ],
                    [
                        0,
                        -1
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        0,
                        0
                    ],
                    [
                        0,
                        0
                    ],
                    [
                        0,
                        0
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        4,
                        4
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        5,
                        5
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        6,
                        6
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        7,
                        7
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        8,
                        8
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        9,
                        9
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        10,
                        10
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        11,
                        11
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        12,
                        12
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        13,
                        13
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        14,
                        14
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        15,
                        15
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        16,
                        16
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        17,
                        17
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        18,
                        18
                    ]
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "bool validSquare(vector<int>& p1, vector<int>& p2, vector<int>& p3, vector<int>& p4) {\n    set<int> dist;\n    vector<vector<int>> points{p1, p2, p3, p4};\n    \n    for (int i = 0; i < 4; i++) {\n        for (int j = i + 1; j < 4; j++) {\n            dist.insert(pow(points[i][0] - points[j][0], 2) + pow(points[i][1] - points[j][1], 2));\n        }\n    }\n    \n    return dist.size() == 2 && *dist.begin() != 0;\n}\n",
            "java": "public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {\n    Set<Integer> dist = new HashSet<>();\n    int[][] points = {p1, p2, p3, p4};\n\n    for (int i = 0; i < 4; i++) {\n        for (int j = i + 1; j < 4; j++) {\n            dist.add((points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]));\n        }\n    }\n\n    return dist.size() == 2 && !dist.contains(0);\n}\n",
            "python": "def validSquare(p1, p2, p3, p4):\n    def dist_sq(p, q):\n        return (p[0] - q[0])**2 + (p[1] - q[1])**2\n\n    points = [p1, p2, p3, p4]\n    dists = set()\n\n    for i in range(4):\n        for j in range(i + 1, 4):\n            dists.add(dist_sq(points[i], points[j]))\n\n    return len(dists) == 2 and 0 not in dists\n",
            "javascript": "function validSquare(p1, p2, p3, p4) {\n    function distSq(p, q) {\n        return (p[0] - q[0]) ** 2 + (p[1] - q[1]) ** 2;\n    }\n\n    let points = [p1, p2, p3, p4];\n    let dists = new Set();\n\n    for (let i = 0; i < 4; i++) {\n        for (let j = i + 1; j < 4; j++) {\n            dists.add(distSq(points[i], points[j]));\n        }\n    }\n\n    return dists.size === 2 && !dists.has(0);\n}\n",
            "explanation": "1. Create a function to calculate the distance between two points in 2D space.\n2. Create a set to store unique distances between points.\n3. Iterate through all distinct pairs of points, calculating the distance between them and adding the result to the set.\n4. Check if the size of the set is 2, meaning that there are exactly two unique distances, and that the smallest distance is not 0, indicating that no two points are the same.\n5. If the above conditions are met, the four points form a square. Otherwise, they do not."
        },
        "structure": {
            "c++": "bool validSquare(vector<int>& p1, vector<int>& p2, vector<int>& p3, vector<int>& p4) \n    // Your code here\n}\n",
            "java": "public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) \n    // Your code here\n}\n",
            "python": "def validSquare(p1, p2, p3, p4):\n    # Your code here\n\n",
            "javascript": "function validSquare(p1, p2, p3, p4) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "bool validSquare(vector<int>& p1, vector<int>& p2, vector<int>& p3, vector<int>& p4) {\n    set<int> dist;\n    vector<vector<int>> points{p1, p2, p3, p4};\n    \n    for (int i = 0; i < 4; i++) {\n        for (int j = i + 1; j < 4; j++) {\n            dist.insert(pow(points[i][0] - points[j][0], 2) + pow(points[i][1] - points[j][1], 2));\n        }\n    }\n    \n    return dist.size() == 2 && *dist.begin() != 0;\n}",
            "java": "public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {\n    Set<Integer> dist = new HashSet<>();\n    int[][] points = {p1, p2, p3, p4};\n\n    for (int i = 0; i < 4; i++) {\n        for (int j = i + 1; j < 4; j++) {\n            dist.add((points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]));\n        }\n    }\n\n    return dist.size() == 2 && !dist.contains(0);\n}",
            "python": "if __name__ == \"__main__\":\n    p1 = $args[0]\n    p2 = $args[1]\n    p3 = $args[2]\n    p4 = $args[3]\n    result = validSquare(p1, p2, p3, p4)\n    print(result)",
            "javascript": "function validSquare(p1, p2, p3, p4) {\n    function distSq(p, q) {\n        return (p[0] - q[0]) ** 2 + (p[1] - q[1]) ** 2;\n    }\n\n    let points = [p1, p2, p3, p4];\n    let dists = new Set();\n\n    for (let i = 0; i < 4; i++) {\n        for (let j = i + 1; j < 4; j++) {\n            dists.add(distSq(points[i], points[j]));\n        }\n    }\n\n    return dists.size === 2 && !dists.has(0);\n}"
        }
    },
    "598": {
        "title": "Maximum Integers in Matrix",
        "description": "You are given an `m x n` matrix `M` initialized with all `0`'s and an array of operations `ops`, where `ops[i] = [ai, bi]` means `M[x][y]` should be incremented by one for all `0 <= x < ai` and `0 <= y < bi`. Count and return the number of maximum integers in the matrix after performing all the operations.",
        "example": "Example 1:\n\nInput: m = 3, n = 3, ops = [[2,2],[3,3]]\nOutput: 4\nExplanation: The maximum integer in M is 2, and there are four of it in M. So return 4.",
        "level": "Easy",
        "tags": [
            "matrix",
            "operations"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    3,
                    [
                        [
                            2,
                            2
                        ],
                        [
                            3,
                            3
                        ]
                    ]
                ],
                [
                    3,
                    3,
                    [
                        [
                            2,
                            2
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            2,
                            2
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            2,
                            2
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            3,
                            3
                        ]
                    ]
                ],
                [
                    3,
                    3,
                    []
                ],
                [
                    4,
                    4,
                    [
                        [
                            1,
                            1
                        ],
                        [
                            2,
                            2
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            4,
                            4
                        ]
                    ]
                ],
                [
                    2,
                    2,
                    [
                        [
                            1,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            2,
                            2
                        ]
                    ]
                ]
            ],
            "outputs": [
                4,
                4,
                9,
                16,
                4
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nint maxCount(int m, int n, vector<vector<int>>& ops) {\n    for (vector<int>& op : ops) {\n        m = min(m, op[0]);\n        n = min(n, op[1]);\n    }\n    return m * n;\n}\n",
            "java": "public int maxCount(int m, int n, int[][] ops) {\n    for (int[] op : ops) {\n        m = Math.min(m, op[0]);\n        n = Math.min(n, op[1]);\n    }\n    return m * n;\n}\n",
            "python": "def maxCount(m: int, n: int, ops: List[List[int]]) -> int:\n    for op in ops:\n        m = min(m, op[0])\n        n = min(n, op[1])\n    return m * n\n",
            "javascript": "function maxCount(m, n, ops) {\n    for (let op of ops) {\n        m = Math.min(m, op[0]);\n        n = Math.min(n, op[1]);\n    }\n    return m * n;\n}\n",
            "explanation": "The algorithm consists of iterating through each operation in the ops array and updating the values of m and n to be the minimum of their current value and the corresponding values in the operation. This is because the maximum integers will always be in the top-left corner of the matrix (0 <= x < ai and 0 <= y < bi). Once all operations have been considered, we multiply the final values of m and n to get the count of maximum integers in the matrix."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nint maxCount(int m, int n, vector<vector<int>>& ops) \n    // Your code here\n}\n",
            "java": "public int maxCount(int m, int n, int[][] ops) \n    // Your code here\n}\n",
            "python": "def maxCount(m: int, n: int, ops: List[List[int]]) -> int:\n    # Your code here\n\n",
            "javascript": "function maxCount(m, n, ops) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nint main() {\n    int m = $args;\n    int n = $args;\n    vector<vector<int>> ops = $args;\n    int result = maxCount(m, n, ops);\n    cout << result << endl;\n    return 0;\n}"
        }
    },
    "599": {
        "title": "Common Strings with Least Index Sum",
        "description": "Given two arrays of strings `list1` and `list2`, find the common strings with the least index sum. A common string is a string that appeared in both `list1` and `list2`. A common string with the least index sum is a common string such that if it appeared at `list1[i]` and `list2[j]` then `i + j` should be the minimum value among all the other common strings. Return all the common strings with the least index sum. Return the answer in any order.",
        "example": "Example:\n\nInput: list1 = [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"], list2 = [\"Piatti\", \"The Grill at Torrey Pines\", \"Hungry Hunter Steakhouse\", \"Shogun\"]\nOutput: [\"Shogun\"]\nExplanation: The only common string is \"Shogun\".",
        "level": "Easy",
        "tags": [
            "array",
            "string"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "Shogun",
                        "Tapioca Express",
                        "Burger King",
                        "KFC"
                    ],
                    [
                        "Piatti",
                        "The Grill at Torrey Pines",
                        "Hungry Hunter Steakhouse",
                        "Shogun"
                    ]
                ],
                [
                    [
                        "Shogun",
                        "Tapioca Express",
                        "Burger King",
                        "KFC"
                    ],
                    [
                        "KFC",
                        "Shogun",
                        "Burger King"
                    ]
                ],
                [
                    [
                        "happy",
                        "sad",
                        "good"
                    ],
                    [
                        "sad",
                        "happy",
                        "good"
                    ]
                ],
                [
                    [
                        "apple",
                        "banana",
                        "orange"
                    ],
                    [
                        "kiwi",
                        "banana",
                        "grape"
                    ]
                ],
                [
                    [
                        "cat",
                        "dog",
                        "bird"
                    ],
                    [
                        "bird",
                        "fish",
                        "cat"
                    ]
                ],
                [
                    [
                        "red",
                        "blue",
                        "green"
                    ],
                    [
                        "yellow",
                        "purple",
                        "green"
                    ]
                ],
                [
                    [
                        "one",
                        "two",
                        "three"
                    ],
                    [
                        "four",
                        "five",
                        "six"
                    ]
                ],
                [
                    [
                        "hello",
                        "world",
                        "foo"
                    ],
                    [
                        "bar",
                        "baz",
                        "hello"
                    ]
                ],
                [
                    [
                        "alpha",
                        "beta",
                        "gamma"
                    ],
                    [
                        "delta",
                        "epsilon",
                        "gamma"
                    ]
                ],
                [
                    [
                        "cat",
                        "dog",
                        "bird"
                    ],
                    [
                        "fish",
                        "cat",
                        "bird"
                    ]
                ],
                [
                    [
                        "apple",
                        "banana",
                        "orange"
                    ],
                    [
                        "kiwi",
                        "banana",
                        "grape"
                    ]
                ],
                [
                    [
                        "red",
                        "blue",
                        "green"
                    ],
                    [
                        "yellow",
                        "purple",
                        "green"
                    ]
                ],
                [
                    [
                        "one",
                        "two",
                        "three"
                    ],
                    [
                        "four",
                        "five",
                        "six"
                    ]
                ],
                [
                    [
                        "hello",
                        "world",
                        "foo"
                    ],
                    [
                        "bar",
                        "baz",
                        "hello"
                    ]
                ],
                [
                    [
                        "alpha",
                        "beta",
                        "gamma"
                    ],
                    [
                        "delta",
                        "epsilon",
                        "gamma"
                    ]
                ],
                [
                    [
                        "cat",
                        "dog",
                        "bird"
                    ],
                    [
                        "fish",
                        "cat",
                        "bird"
                    ]
                ],
                [
                    [
                        "apple",
                        "banana",
                        "orange"
                    ],
                    [
                        "kiwi",
                        "banana",
                        "grape"
                    ]
                ],
                [
                    [
                        "red",
                        "blue",
                        "green"
                    ],
                    [
                        "yellow",
                        "purple",
                        "green"
                    ]
                ],
                [
                    [
                        "one",
                        "two",
                        "three"
                    ],
                    [
                        "four",
                        "five",
                        "six"
                    ]
                ],
                [
                    [
                        "hello",
                        "world",
                        "foo"
                    ],
                    [
                        "bar",
                        "baz",
                        "hello"
                    ]
                ],
                [
                    [
                        "alpha",
                        "beta",
                        "gamma"
                    ],
                    [
                        "delta",
                        "epsilon",
                        "gamma"
                    ]
                ]
            ],
            "outputs": [
                [
                    "Shogun"
                ],
                [
                    "Shogun"
                ],
                [
                    "sad",
                    "happy"
                ],
                [
                    "banana"
                ],
                [
                    "bird",
                    "cat"
                ],
                [
                    "green"
                ],
                [],
                [
                    "hello"
                ],
                [
                    "gamma"
                ],
                [
                    "cat",
                    "bird"
                ],
                [
                    "banana"
                ],
                [
                    "green"
                ],
                [],
                [
                    "hello"
                ],
                [
                    "gamma"
                ],
                [
                    "cat",
                    "bird"
                ],
                [
                    "banana"
                ],
                [
                    "green"
                ],
                [],
                [
                    "hello"
                ],
                [
                    "gamma"
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <unordered_map>\n#include <string>\n\nstd::vector<std::string> findRestaurant(std::vector<std::string>& list1, std::vector<std::string>& list2) {\n    std::unordered_map<std::string, int> restaurantMap;\n    for (int i = 0; i < list1.size(); i++) {\n        restaurantMap[list1[i]] = i;\n    }\n\n    int minSum = INT_MAX;\n    std::vector<std::string> result;\n    for (int j = 0; j < list2.size(); j++) {\n        if (restaurantMap.count(list2[j])) {\n            int sum = j + restaurantMap[list2[j]];\n            if (sum < minSum) {\n                result.clear();\n                result.push_back(list2[j]);\n                minSum = sum;\n            } else if (sum == minSum) {\n                result.push_back(list2[j]);\n            }\n        }\n    }\n    return result;\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic List<String> findRestaurant(String[] list1, String[] list2) {\n    HashMap<String, Integer> restaurantMap = new HashMap<>();\n    for (int i = 0; i < list1.length; i++) {\n        restaurantMap.put(list1[i], i);\n    }\n\n    int minSum = Integer.MAX_VALUE;\n    List<String> result = new ArrayList<>();\n    for (int j = 0; j < list2.length; j++) {\n        Integer index = restaurantMap.get(list2[j]);\n        if (index != null) {\n            int sum = j + index;\n            if (sum < minSum) {\n                result.clear();\n                result.add(list2[j]);\n                minSum = sum;\n            } else if (sum == minSum) {\n                result.add(list2[j]);\n            }\n        }\n    }\n    return result;\n}\n\n",
            "python": "from typing import List\n\ndef findRestaurant(list1: List[str], list2: List[str]) -> List[str]:\n    restaurantMap = {restaurant: i for i, restaurant in enumerate(list1)}\n\n    minSum = float(\"inf\")\n    result = []\n    for j, restaurant in enumerate(list2):\n        if restaurant in restaurantMap:\n            totalSum = j + restaurantMap[restaurant]\n            if totalSum < minSum:\n                result = [restaurant]\n                minSum = totalSum\n            elif totalSum == minSum:\n                result.append(restaurant)\n\n    return result\n\n",
            "javascript": "function findRestaurant(list1, list2) {\n    let restaurantMap = new Map();\n    for (let i = 0; i < list1.length; i++) {\n        restaurantMap.set(list1[i], i);\n    }\n\n    let minSum = Infinity;\n    let result = [];\n    for (let j = 0; j < list2.length; j++) {\n        if (restaurantMap.has(list2[j])) {\n            let sum = j + restaurantMap.get(list2[j]);\n            if (sum < minSum) {\n                result = [list2[j]];\n                minSum = sum;\n            } else if (sum == minSum) {\n                result.push(list2[j]);\n            }\n        }\n    }\n    return result;\n}\n\n",
            "explanation": "1. Create a hashmap to store the restaurants and their indices (or just index for Python and JavaScript) in list1.\n2. Initialize a variable, minSum, to store the minimum sum of indices, and a result list to store the common restaurants with the least index sum.\n3. Iterate through list2; for each restaurant, check if it is in the hashmap.\n   a. If it is, calculate the sum of its index in list1 and list2.\n   b. If the sum is less than the current minSum, clear the result list, add the current restaurant to the result list, and update minSum.\n   c. If the sum is equal to minSum, add the restaurant to the result list.\n5. Return the result list."
        },
        "structure": {
            "c++": "#include <vector>\n#include <unordered_map>\n#include <string>\n\nstd::vector<std::string> findRestaurant(std::vector<std::string>& list1, std::vector<std::string>& list2) \n    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic List<String> findRestaurant(String[] list1, String[] list2) \n    // Your code here\n}\n\n",
            "python": "from typing import List\n    # Your code here\n\n",
            "javascript": "function findRestaurant(list1, list2) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <unordered_map>\n#include <string>\n#include <iostream>\n\nint main() {\n    std::vector<std::string> list1 = $args;\n    std::vector<std::string> list2 = $args;\n    std::vector<std::string> result = findRestaurant(list1, list2);\n    for (const auto& restaurant : result) {\n        std::cout << restaurant << std::endl;\n    }\n    return 0;\n}\n",
            "java": "public List<String> findRestaurant(String[] list1, String[] list2) {\n    HashMap<String, Integer> restaurantMap = new HashMap<>();\n    for (int i = 0; i < list1.length; i++) {\n        restaurantMap.put(list1[i], i);\n    }\n\n    int minSum = Integer.MAX_VALUE;\n    List<String> result = new ArrayList<>();\n    for (int j = 0; j < list2.length; j++) {\n        Integer index = restaurantMap.get(list2[j]);\n        if (index != null) {\n            int sum = j + index;\n            if (sum < minSum) {\n                result.clear();\n                result.add(list2[j]);\n                minSum = sum;\n            } else if (sum == minSum) {\n                result.add(list2[j]);\n            }\n        }\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    list1 = $args[0]\n    list2 = $args[1]\n    result = findRestaurant(list1, list2)\n    print(result)",
            "javascript": "function findRestaurant(list1, list2) {\n    let restaurantMap = new Map();\n    for (let i = 0; i < list1.length; i++) {\n        restaurantMap.set(list1[i], i);\n    }\n\n    let minSum = Infinity;\n    let result = [];\n    for (let j = 0; j < list2.length; j++) {\n        if (restaurantMap.has(list2[j])) {\n            let sum = j + restaurantMap.get(list2[j]);\n            if (sum < minSum) {\n                result = [list2[j]];\n                minSum = sum;\n            } else if (sum == minSum) {\n                result.push(list2[j]);\n            }\n        }\n    }\n    return result;\n}"
        }
    },
    "600": {
        "title": "Non-Consecutive Binary Numbers",
        "description": "Given a positive integer `n`, return the number of integers in the range `[0, n]` whose binary representations **do not** contain consecutive ones.",
        "example": "Example:\n\nInput: n = 5\nOutput: 5\nExplanation: Here are the non-negative integers <= 5 with their corresponding binary representations:\n0 : 0\n1 : 1\n2 : 10\n3 : 11\n4 : 100\n5 : 101\nAmong them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule.",
        "level": "Easy",
        "tags": [
            "bit manipulation",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                1,
                5,
                10,
                15,
                20,
                50,
                100,
                1000,
                10000,
                100000,
                1000000,
                10000000,
                100000000,
                1000000000,
                109
            ],
            "outputs": [
                2,
                5,
                8,
                13,
                15,
                34,
                89,
                610,
                4181,
                28657,
                196418,
                1346269,
                9227465,
                63245986,
                5702887
            ]
        },
        "sample_code": {
            "c++": "int findIntegers(int n) {\n    int dp[32][2] = {0};\n    dp[0][0] = dp[0][1] = 1;\n\n    for (int i = 1; i < 32; i++) {\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1];\n        dp[i][1] = dp[i - 1][0];\n    }\n\n    int ans = 0, prev_bit = 0;\n    for (int i = 30; i >= 0; i--) {\n        if (n & (1 << i)) {\n            ans += dp[i][0];\n            if (prev_bit) break;\n            prev_bit = 1;\n        } else {\n            prev_bit = 0;\n        }\n    }\n\n    return ans + 1;\n}\n",
            "java": "public int findIntegers(int n) {\n    int[][] dp = new int[32][2];\n    dp[0][0] = 1;\n    dp[0][1] = 1;\n\n    for (int i = 1; i < 32; i++) {\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1];\n        dp[i][1] = dp[i - 1][0];\n    }\n\n    int ans = 0, prev_bit = 0;\n    for (int i = 30; i >= 0; i--) {\n        if ((n & (1 << i)) != 0) {\n            ans += dp[i][0];\n            if (prev_bit == 1) break;\n            prev_bit = 1;\n        } else {\n            prev_bit = 0;\n        }\n    }\n\n    return ans + 1;\n}\n\n",
            "python": "def findIntegers(n: int) -> int:\n    dp = [[0, 0] for _ in range(32)]\n    dp[0][0], dp[0][1] = 1, 1\n\n    for i in range(1, 32):\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1]\n        dp[i][1] = dp[i - 1][0]\n\n    ans = 0\n    prev_bit = 0\n    for i in range(30, -1, -1):\n        if n & (1 << i):\n            ans += dp[i][0]\n            if prev_bit:\n                break\n            prev_bit = 1\n        else:\n            prev_bit = 0\n\n    return ans + 1\n\n",
            "javascript": "function findIntegers(n) {\n    let dp = new Array(32).fill(0).map(() => Array(2).fill(0));\n    dp[0][0] = 1;\n    dp[0][1] = 1;\n\n    for (let i = 1; i < 32; i++) {\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1];\n        dp[i][1] = dp[i - 1][0];\n    }\n\n    let ans = 0, prev_bit = 0;\n    for (let i = 30; i >= 0; i--) {\n        if (n & (1 << i)) {\n            ans += dp[i][0];\n            if (prev_bit === 1) break;\n            prev_bit = 1;\n        } else {\n            prev_bit = 0;\n        }\n    }\n\n    return ans + 1;\n}\n\n",
            "explanation": "The algorithm uses dynamic programming to count the number of valid integers with no consecutive 1s in their binary representation. It initializes an array `dp` with the dimensions [32][2], where the first dimension represents the length of the binary representation and the second dimension represents whether the last bit is a 1 (consecutive 1s) or a 0.\n\nFor every index i from `1` to `32`, dp[i][0] represents the count of valid integers without leading 1s, while dp[i][1] represents the count of valid integers without consecutive 1s ending with a 1. Starting from the highest bit and moving to the lowest bit, the algorithm checks if bit `i` is set in the given number `n`. If the bit is set, the algorithm increments the counter `ans` by the number of valid integers with that bit position.\n\nIf the previous bit was set, the algorithm breaks the loop because consecutive 1s were found. Finally, the algorithm returns the count of valid integers incremented by 1 to account for the integer 0, which always satisfies the condition."
        },
        "structure": {
            "c++": "int findIntegers(int n) \n    // Your code here\n}\n",
            "java": "public int findIntegers(int n) \n    // Your code here\n}\n\n",
            "python": "def findIntegers(n: int) -> int:\n    # Your code here\n\n",
            "javascript": "function findIntegers(n) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = findIntegers(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int findIntegers(int n) {\n    int[][] dp = new int[32][2];\n    dp[0][0] = 1;\n    dp[0][1] = 1;\n\n    for (int i = 1; i < 32; i++) {\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1];\n        dp[i][1] = dp[i - 1][0];\n    }\n\n    int ans = 0, prev_bit = 0;\n    for (int i = 30; i >= 0; i--) {\n        if ((n & (1 << i)) != 0) {\n            ans += dp[i][0];\n            if (prev_bit == 1) break;\n            prev_bit = 1;\n        } else {\n            prev_bit = 0;\n        }\n    }\n\n    return ans + 1;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    result = findIntegers(n)\n    print(result)",
            "javascript": "function findIntegers(n) {\n    let dp = new Array(32).fill(0).map(() => Array(2).fill(0));\n    dp[0][0] = 1;\n    dp[0][1] = 1;\n\n    for (let i = 1; i < 32; i++) {\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1];\n        dp[i][1] = dp[i - 1][0];\n    }\n\n    let ans = 0, prev_bit = 0;\n    for (let i = 30; i >= 0; i--) {\n        if (n & (1 << i)) {\n            ans += dp[i][0];\n            if (prev_bit === 1) break;\n            prev_bit = 1;\n        } else {\n            prev_bit = 0;\n        }\n    }\n\n    return ans + 1;\n}"
        }
    },
    "609": {
        "title": "Duplicate Files in File System",
        "description": "Given a list `paths` of directory info, including the directory path, and all the files with contents in this directory, return all the duplicate files in the file system in terms of their paths. A group of duplicate files consists of at least two files that have the same content. A single directory info string in the input list has the following format: `root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)`. It means there are n files (f1.txt, f2.txt ... fn.txt) with content (f1_content, f2_content ... fn_content) respectively in the directory `root/d1/d2/.../dm`. Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory. The output is a list of groups of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format: `directory_path/file_name.txt`.",
        "example": "Example:\n\nInput:\npaths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]\nOutput:\n[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]\n\nInput:\npaths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]\nOutput:\n[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]",
        "level": "Medium",
        "tags": [
            "file system",
            "duplicate files",
            "content comparison"
        ],
        "test_cases": {
            "inputs": [
                [
                    "root/a 1.txt(abcd) 2.txt(efgh)",
                    "root/c 3.txt(abcd)",
                    "root/c/d 4.txt(efgh)",
                    "root 4.txt(efgh)"
                ],
                [
                    "root/a 1.txt(abcd) 2.txt(efgh)",
                    "root/c 3.txt(abcd)",
                    "root/c/d 4.txt(efgh)"
                ],
                [
                    "root 1.txt(abcd)",
                    "root 2.txt(abcd)",
                    "root 3.txt(abcd)"
                ],
                [
                    "root/a 1.txt(abcd) 2.txt(efgh)",
                    "root/b 3.txt(abcd)",
                    "root/c 4.txt(abcd)"
                ],
                [
                    "root/a 1.txt(abcd) 2.txt(efgh)",
                    "root/a/b 3.txt(abcd)",
                    "root/a/b/c 4.txt(abcd)"
                ],
                [
                    "root/a 1.txt(abcd) 2.txt(efgh)",
                    "root/a/b 3.txt(abcd)",
                    "root/a/b/c 4.txt(efgh)"
                ],
                [
                    "root/a 1.txt(abcd) 2.txt(efgh)",
                    "root/a/b 3.txt(abcd)",
                    "root/a/b/c 4.txt(efgh)",
                    "root/a/b/c/d 5.txt(abcd)"
                ],
                [
                    "root/a 1.txt(abcd) 2.txt(efgh)",
                    "root/a/b 3.txt(abcd)",
                    "root/a/b/c 4.txt(efgh)",
                    "root/a/b/c/d 5.txt(efgh)"
                ],
                [
                    "root/a 1.txt(abcd) 2.txt(efgh)",
                    "root/a/b 3.txt(abcd)",
                    "root/a/b/c 4.txt(efgh)",
                    "root/a/b/c/d 5.txt(efgh)",
                    "root/a/b/c/d/e 6.txt(abcd)"
                ],
                [
                    "root/a 1.txt(abcd) 2.txt(efgh)",
                    "root/a/b 3.txt(abcd)",
                    "root/a/b/c 4.txt(efgh)",
                    "root/a/b/c/d 5.txt(efgh)",
                    "root/a/b/c/d/e 6.txt(efgh)"
                ],
                [
                    "root/a 1.txt(abcd) 2.txt(efgh)",
                    "root/a/b 3.txt(abcd)",
                    "root/a/b/c 4.txt(efgh)",
                    "root/a/b/c/d 5.txt(efgh)",
                    "root/a/b/c/d/e 6.txt(efgh)",
                    "root/a/b/c/d/e/f 7.txt(abcd)"
                ],
                [
                    "root/a 1.txt(abcd) 2.txt(efgh)",
                    "root/a/b 3.txt(abcd)",
                    "root/a/b/c 4.txt(efgh)",
                    "root/a/b/c/d 5.txt(efgh)",
                    "root/a/b/c/d/e 6.txt(efgh)",
                    "root/a/b/c/d/e/f 7.txt(efgh)"
                ],
                [
                    "root/a 1.txt(abcd) 2.txt(efgh)",
                    "root/a/b 3.txt(abcd)",
                    "root/a/b/c 4.txt(efgh)",
                    "root/a/b/c/d 5.txt(efgh)",
                    "root/a/b/c/d/e 6.txt(efgh)",
                    "root/a/b/c/d/e/f 7.txt(efgh)",
                    "root/a/b/c/d/e/f/g 8.txt(abcd)"
                ],
                [
                    "root/a 1.txt(abcd) 2.txt(efgh)",
                    "root/a/b 3.txt(abcd)",
                    "root/a/b/c 4.txt(efgh)",
                    "root/a/b/c/d 5.txt(efgh)",
                    "root/a/b/c/d/e 6.txt(efgh)",
                    "root/a/b/c/d/e/f 7.txt(efgh)",
                    "root/a/b/c/d/e/f/g 8.txt(efgh)"
                ],
                [
                    "root/a 1.txt(abcd) 2.txt(efgh)",
                    "root/a/b 3.txt(abcd)",
                    "root/a/b/c 4.txt(efgh)",
                    "root/a/b/c/d 5.txt(efgh)",
                    "root/a/b/c/d/e 6.txt(efgh)",
                    "root/a/b/c/d/e/f 7.txt(efgh)",
                    "root/a/b/c/d/e/f/g 8.txt(efgh)",
                    "root/a/b/c/d/e/f/g/h 9.txt(abcd)"
                ],
                [
                    "root/a 1.txt(abcd) 2.txt(efgh)",
                    "root/a/b 3.txt(abcd)",
                    "root/a/b/c 4.txt(efgh)",
                    "root/a/b/c/d 5.txt(efgh)",
                    "root/a/b/c/d/e 6.txt(efgh)",
                    "root/a/b/c/d/e/f 7.txt(efgh)",
                    "root/a/b/c/d/e/f/g 8.txt(efgh)",
                    "root/a/b/c/d/e/f/g/h 9.txt(efgh)"
                ],
                [
                    "root/a 1.txt(abcd) 2.txt(efgh)",
                    "root/a/b 3.txt(abcd)",
                    "root/a/b/c 4.txt(efgh)",
                    "root/a/b/c/d 5.txt(efgh)",
                    "root/a/b/c/d/e 6.txt(efgh)",
                    "root/a/b/c/d/e/f 7.txt(efgh)",
                    "root/a/b/c/d/e/f/g 8.txt(efgh)",
                    "root/a/b/c/d/e/f/g/h 9.txt(efgh)",
                    "root/a/b/c/d/e/f/g/h/i 10.txt(abcd)"
                ],
                [
                    "root/a 1.txt(abcd) 2.txt(efgh)",
                    "root/a/b 3.txt(abcd)",
                    "root/a/b/c 4.txt(efgh)",
                    "root/a/b/c/d 5.txt(efgh)",
                    "root/a/b/c/d/e 6.txt(efgh)",
                    "root/a/b/c/d/e/f 7.txt(efgh)",
                    "root/a/b/c/d/e/f/g 8.txt(efgh)",
                    "root/a/b/c/d/e/f/g/h 9.txt(efgh)",
                    "root/a/b/c/d/e/f/g/h/i 10.txt(efgh)"
                ]
            ],
            "outputs": [
                "[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]",
                "[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]",
                "[\"root/1.txt\",\"root/2.txt\",\"root/3.txt\"]",
                "[\"root/a/1.txt\",\"root/a/2.txt\",\"root/a/3.txt\"]",
                "[\"root/a/1.txt\",\"root/a/2.txt\",\"root/a/3.txt\"]",
                "[\"root/a/1.txt\",\"root/a/2.txt\",\"root/a/3.txt\"]",
                "[\"root/a/1.txt\",\"root/a/2.txt\",\"root/a/3.txt\",\"root/a/4.txt\"]",
                "[\"root/a/1.txt\",\"root/a/2.txt\",\"root/a/3.txt\",\"root/a/4.txt\"]",
                "[\"root/a/1.txt\",\"root/a/2.txt\",\"root/a/3.txt\",\"root/a/4.txt\",\"root/a/5.txt\"]",
                "[\"root/a/1.txt\",\"root/a/2.txt\",\"root/a/3.txt\",\"root/a/4.txt\",\"root/a/5.txt\"]",
                "[\"root/a/1.txt\",\"root/a/2.txt\",\"root/a/3.txt\",\"root/a/4.txt\",\"root/a/5.txt\",\"root/a/6.txt\"]",
                "[\"root/a/1.txt\",\"root/a/2.txt\",\"root/a/3.txt\",\"root/a/4.txt\",\"root/a/5.txt\",\"root/a/6.txt\"]",
                "[\"root/a/1.txt\",\"root/a/2.txt\",\"root/a/3.txt\",\"root/a/4.txt\",\"root/a/5.txt\",\"root/a/6.txt\",\"root/a/7.txt\"]",
                "[\"root/a/1.txt\",\"root/a/2.txt\",\"root/a/3.txt\",\"root/a/4.txt\",\"root/a/5.txt\",\"root/a/6.txt\",\"root/a/7.txt\"]",
                "[\"root/a/1.txt\",\"root/a/2.txt\",\"root/a/3.txt\",\"root/a/4.txt\",\"root/a/5.txt\",\"root/a/6.txt\",\"root/a/7.txt\",\"root/a/8.txt\"]",
                "[\"root/a/1.txt\",\"root/a/2.txt\",\"root/a/3.txt\",\"root/a/4.txt\",\"root/a/5.txt\",\"root/a/6.txt\",\"root/a/7.txt\",\"root/a/8.txt\"]",
                "[\"root/a/1.txt\",\"root/a/2.txt\",\"root/a/3.txt\",\"root/a/4.txt\",\"root/a/5.txt\",\"root/a/6.txt\",\"root/a/7.txt\",\"root/a/8.txt\",\"root/a/9.txt\"]",
                "[\"root/a/1.txt\",\"root/a/2.txt\",\"root/a/3.txt\",\"root/a/4.txt\",\"root/a/5.txt\",\"root/a/6.txt\",\"root/a/7.txt\",\"root/a/8.txt\",\"root/a/9.txt\"]",
                "[\"root/a/1.txt\",\"root/a/2.txt\",\"root/a/3.txt\",\"root/a/4.txt\",\"root/a/5.txt\",\"root/a/6.txt\",\"root/a/7.txt\",\"root/a/8.txt\",\"root/a/9.txt\",\"root/a/10.txt\"]",
                "[\"root/a/1.txt\",\"root/a/2.txt\",\"root/a/3.txt\",\"root/a/4.txt\",\"root/a/5.txt\",\"root/a/6.txt\",\"root/a/7.txt\",\"root/a/8.txt\",\"root/a/9.txt\",\"root/a/10.txt\"]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n\nstd::vector<std::vector<std::string>> findDuplicate(std::vector<std::string>& paths) {\n    std::unordered_map<std::string, std::vector<std::string>> content_map;\n    for (const std::string &path : paths) {\n        std::istringstream iss(path);\n        std::string directory;\n        iss >> directory;\n        std::string file;\n        while (iss >> file) {\n            size_t start = file.find('(');\n            size_t end = file.find(')');\n            std::string content = file.substr(start + 1, end - start - 1);\n            std::string file_path = directory + \"/\" + file.substr(0, start);\n            content_map[content].push_back(file_path);\n        }\n    }\n    std::vector<std::vector<std::string>> result;\n    for (const auto &entry : content_map) {\n        if (entry.second.size() > 1) {\n            result.push_back(entry.second);\n        }\n    }\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic List<List<String>> findDuplicate(String[] paths) {\n    HashMap<String, List<String>> contentMap = new HashMap<>();\n    for (String path : paths) {\n        String[] parts = path.split(\" \");\n        String directory = parts[0];\n        for (int i = 1; i < parts.length; i++) {\n            int start = parts[i].indexOf('(');\n            int end = parts[i].indexOf(')');\n            String content = parts[i].substring(start + 1, end);\n            String filePath = directory + \"/\" + parts[i].substring(0, start);\n            contentMap.computeIfAbsent(content, k -> new ArrayList<>()).add(filePath);\n        }\n    }\n    List<List<String>> result = new ArrayList<>();\n    for (List<String> filePaths : contentMap.values()) {\n        if (filePaths.size() > 1) {\n            result.add(filePaths);\n        }\n    }\n    return result;\n}\n",
            "python": "from collections import defaultdict\n\ndef find_duplicate(paths):\n    content_map = defaultdict(list)\n    for path in paths:\n        parts = path.split()\n        directory = parts[0]\n        for file in parts[1:]:\n            start = file.index('(')\n            end = file.index(')')\n            content = file[start + 1:end]\n            file_path = directory + '/' + file[:start]\n            content_map[content].append(file_path)\n\n    result = [file_paths for file_paths in content_map.values() if len(file_paths) > 1]\n    return result\n",
            "javascript": "function findDuplicate(paths) {\n    const contentMap = new Map();\n\n    for (const path of paths) {\n        const parts = path.split(' ');\n        const directory = parts[0];\n        for (let i = 1; i < parts.length; i++) {\n            const start = parts[i].indexOf('(');\n            const end = parts[i].indexOf(')');\n            const content = parts[i].substring(start + 1, end);\n            const filePath = directory + '/' + parts[i].substring(0, start);\n\n            if (!contentMap.has(content)) {\n                contentMap.set(content, []);\n            }\n            contentMap.get(content).push(filePath);\n        }\n    }\n    const result = [];\n    for (const filePaths of contentMap.values()) {\n        if (filePaths.length > 1) {\n            result.push(filePaths);\n        }\n    }\n    return result;\n}\n",
            "explanation": "The algorithm proceeds as follows:\n\n1. Create a hash map (content_map) with the content as the key and the list of corresponding file paths as the value.\n2. Iterate through the paths list.\n3. For each path, split it into components (directory and files).\n4. Iterate through the files, and for each file, find the content between the parentheses and the file path.\n5. Add the file path to the corresponding content entry in the content_map.\n6. After processing all the paths, iterate through the content_map entries and add the lists with more than 1 file path to the result.\n\nThis algorithm has a time complexity of O(N), where N is the total number of files, as it processes each file once."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n\nstd::vector<std::vector<std::string>> findDuplicate(std::vector<std::string>& paths) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic List<List<String>> findDuplicate(String[] paths) \n    // Your code here\n}\n",
            "python": "from collections import defaultdict\n    # Your code here\n\n",
            "javascript": "function findDuplicate(paths) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n\nint main() {\n    std::vector<std::string> paths = $args;\n    std::vector<std::vector<std::string>> result = findDuplicate(paths);\n    // Print the result\n    for (const auto &group : result) {\n        for (const std::string &file_path : group) {\n            std::cout << file_path << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}",
            "java": "public List<List<String>> findDuplicate(String[] paths) {\n    HashMap<String, List<String>> contentMap = new HashMap<>();\n    for (String path : paths) {\n        String[] parts = path.split(\" \");\n        String directory = parts[0];\n        for (int i = 1; i < parts.length; i++) {\n            int start = parts[i].indexOf('(');\n            int end = parts[i].indexOf(')');\n            String content = parts[i].substring(start + 1, end);\n            String filePath = directory + \"/\" + parts[i].substring(0, start);\n            contentMap.computeIfAbsent(content, k -> new ArrayList<>()).add(filePath);\n        }\n    }\n    List<List<String>> result = new ArrayList<>();\n    for (List<String> filePaths : contentMap.values()) {\n        if (filePaths.size() > 1) {\n            result.add(filePaths);\n        }\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    paths = $args[0]\n    result = find_duplicate(paths)\n    print(result)",
            "javascript": "function findDuplicate(paths) {\n    const contentMap = new Map();\n\n    for (const path of paths) {\n        const parts = path.split(' ');\n        const directory = parts[0];\n        for (let i = 1; i < parts.length; i++) {\n            const start = parts[i].indexOf('(');\n            const end = parts[i].indexOf(')');\n            const content = parts[i].substring(start + 1, end);\n            const filePath = directory + '/' + parts[i].substring(0, start);\n\n            if (!contentMap.has(content)) {\n                contentMap.set(content, []);\n            }\n            contentMap.get(content).push(filePath);\n        }\n    }\n    const result = [];\n    for (const filePaths of contentMap.values()) {\n        if (filePaths.length > 1) {\n            result.push(filePaths);\n        }\n    }\n    return result;\n}"
        }
    },
    "611": {
        "title": "Triangle Triplets",
        "description": "Given an integer array `nums`, return the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.",
        "example": "Example 1:\n\nInput: nums = [2,2,3,4]\nOutput: 3\nExplanation: Valid combinations are: \n2,3,4 (using the first 2)\n2,3,4 (using the second 2)\n2,2,3\n\nExample 2:\n\nInput: nums = [4,2,3,4]\nOutput: 4",
        "level": "Medium",
        "tags": [
            "Array",
            "Math"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    2,
                    3,
                    4
                ],
                [
                    4,
                    2,
                    3,
                    4
                ],
                [
                    1,
                    1,
                    1,
                    1
                ],
                [
                    5,
                    7,
                    9,
                    11
                ],
                [
                    0,
                    0,
                    0,
                    0
                ],
                [
                    3,
                    4,
                    5,
                    6
                ],
                [
                    10,
                    20,
                    30,
                    40
                ],
                [
                    2,
                    2,
                    2,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4
                ],
                [
                    5,
                    5,
                    5,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ]
            ],
            "outputs": [
                3,
                4,
                4,
                0,
                0,
                4,
                0,
                1,
                1,
                10,
                45,
                45
            ]
        },
        "sample_code": {
            "c++": "int triangleNumber(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    int count = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n        for (int j = i + 1; j < nums.size(); ++j) {\n            for (int k = j + 1; k < nums.size(); ++k) {\n                if (nums[i] + nums[j] > nums[k]) {\n                    ++count;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n    }\n    return count;\n}\n",
            "java": "public int triangleNumber(int[] nums) {\n    Arrays.sort(nums);\n    int count = 0;\n    for (int i = 0; i < nums.length; ++i) {\n        for (int j = i + 1; j < nums.length; ++j) {\n            for (int k = j + 1; k < nums.length; ++k) {\n                if (nums[i] + nums[j] > nums[k]) {\n                    count++;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n    }\n    return count;\n}\n",
            "python": "def triangleNumber(nums: list) -> int:\n    nums.sort()\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            for k in range(j + 1, len(nums)):\n                if nums[i] + nums[j] > nums[k]:\n                    count += 1\n                else:\n                    break\n    return count\n",
            "javascript": "function triangleNumber(nums) {\n    nums.sort((a, b) => a - b);\n    let count = 0;\n    for (let i = 0; i < nums.length; ++i) {\n        for (let j = i + 1; j < nums.length; ++j) {\n            for (let k = j + 1; k < nums.length; ++k) {\n                if (nums[i] + nums[j] > nums[k]) {\n                    count++;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n    }\n    return count;\n}\n",
            "explanation": "1. Sort the given array in ascending order.\n2. Iterate through the sorted array using three nested loops i, j, and k, where i < j < k. The loops go through possible triplet candidates (nums[i], nums[j], nums[k]).\n3. For each triplet, check if nums[i] + nums[j] > nums[k]. If true, it satisfies the triangle inequality property, and we increase the count.\n4. If nums[i] + nums[j] is not greater than nums[k], it means no other k value will satisfy the triangle inequality with the current i and j values. So, we break the innermost loop.\n5. Return the count, which is the number of valid triplets."
        },
        "structure": {
            "c++": "int triangleNumber(vector<int>& nums) \n    // Your code here\n}\n",
            "java": "public int triangleNumber(int[] nums) \n    // Your code here\n}\n",
            "python": "def triangleNumber(nums: list) -> int:\n    # Your code here\n\n",
            "javascript": "function triangleNumber(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int triangleNumber(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    int count = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n        for (int j = i + 1; j < nums.size(); ++j) {\n            for (int k = j + 1; k < nums.size(); ++k) {\n                if (nums[i] + nums[j] > nums[k]) {\n                    ++count;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n    }\n    return count;\n}",
            "java": "public int triangleNumber(int[] nums) {\n    Arrays.sort(nums);\n    int count = 0;\n    for (int i = 0; i < nums.length; ++i) {\n        for (int j = i + 1; j < nums.length; ++j) {\n            for (int k = j + 1; k < nums.length; ++k) {\n                if (nums[i] + nums[j] > nums[k]) {\n                    count++;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n    }\n    return count;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = triangleNumber(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = triangleNumber(nums);\n    console.log(result);\n}"
        }
    },
    "616": {
        "title": "Add Bold Tags to Substrings",
        "description": "You are given a string `s` and an array of strings `words`. You should add a closed pair of bold tags **and** to wrap the substrings in `s` that exist in `words`. If two such substrings overlap, you should wrap them together with only one pair of closed bold-tag. If two substrings wrapped by bold tags are consecutive, you should combine them. Return `s` after adding the bold tags.",
        "example": "Example:\n\nInput: s = \"abcxyz123 \", words = [\"abc \", \"123 \"]\nOutput: \"**abc**xyz**123** \"\nExplanation: The two strings of words are substrings of s as following: \"abcxyz123 \". We add ** before each substring and ** after each substring.\n\nInput: s = \"aaabbb \", words = [\"aa \", \"b \"]\nOutput: \"**aaabbb** \"\nExplanation: \"aa \" appears as a substring two times: \"aaabbb \" and \"aaabbb \". \"b \" appears as a substring three times: \"aaabbb \", \"aaabbb \", and \"aaabbb \". We add ** before each substring and ** after each substring: \"**a**a**a****b****b****b** \". Since the first two **'s overlap, we merge them: \"**aaa****b****b****b** \". Since now the four **'s are consecutive, we merge them: \"**aaabbb** \".",
        "level": "Medium",
        "tags": [
            "string",
            "substring",
            "tagging"
        ],
        "test_cases": {
            "inputs": [
                [
                    "abcxyz123 ",
                    [
                        "abc ",
                        "123 "
                    ]
                ],
                [
                    "aaabbb ",
                    [
                        "aa ",
                        "b "
                    ]
                ],
                [
                    "hello world",
                    [
                        "hello",
                        "world"
                    ]
                ],
                [
                    "programming is fun",
                    [
                        "programming",
                        "is",
                        "fun"
                    ]
                ],
                [
                    "bold tags",
                    [
                        "bold",
                        "tags"
                    ]
                ],
                [
                    "abcdefg",
                    [
                        "abc",
                        "def",
                        "g"
                    ]
                ],
                [
                    "aaaaa",
                    [
                        "a"
                    ]
                ],
                [
                    "1234567890",
                    [
                        "123",
                        "456",
                        "789",
                        "0"
                    ]
                ],
                [
                    "this is a test",
                    [
                        "this",
                        "is",
                        "a",
                        "test"
                    ]
                ],
                [
                    "coding is cool",
                    [
                        "coding",
                        "is",
                        "cool"
                    ]
                ]
            ],
            "outputs": [
                "**abc**xyz**123** ",
                "**aaabbb** ",
                "**hello** **world**",
                "**programming** **is** **fun**",
                "**bold** **tags**",
                "**abcdefg**",
                "**aaaaa**",
                "**1234567890**",
                "**this** **is** **a** **test**",
                "**coding** **is** **cool**"
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <vector>\n\nstd::string addBoldTag(std::string s, std::vector<std::string>& words) {\n    int n = s.size();\n    std::vector<bool> marked(n, false);\n    for (const auto& word : words) {\n        int pos = s.find(word, 0);\n        while (pos != std::string::npos) {\n            std::fill(marked.begin() + pos, marked.begin() + pos + word.size(), true);\n            pos = s.find(word, pos + 1);\n        }\n    }\n    std::string result;\n    for (int i = 0; i < n; ++i) {\n        if (marked[i] && (i == 0 || !marked[i - 1])) {\n            result += \"<b>\";\n        }\n        result += s[i];\n        if (marked[i] && (i == n - 1 || !marked[i + 1])) {\n            result += \"</b>\";\n        }\n    }\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.Arrays;\n\npublic String addBoldTag(String s, String[] words) {\n    int n = s.length();\n    boolean[] marked = new boolean[n];\n    for (String word : words) {\n        int pos = s.indexOf(word, 0);\n        while (pos != -1) {\n            Arrays.fill(marked, pos, pos + word.length(), true);\n            pos = s.indexOf(word, pos + 1);\n        }\n    }\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < n; i++) {\n        if (marked[i] && (i == 0 || !marked[i - 1])) {\n            result.append(\"<b>\");\n        }\n        result.append(s.charAt(i));\n        if (marked[i] && (i == n - 1 || !marked[i + 1])) {\n            result.append(\"</b>\");\n        }\n    }\n    return result.toString();\n}\n",
            "python": "def addBoldTag(s: str, words: list) -> str:\n    n = len(s)\n    marked = [False] * n\n    for word in words:\n        pos = s.find(word)\n        while pos != -1:\n            for i in range(pos, pos + len(word)):\n                marked[i] = True\n            pos = s.find(word, pos + 1)\n    result = []\n    i = 0\n    while i < n:\n        if marked[i]:\n            result.append(\"<b>\")\n            while i < n and marked[i]:\n                result.append(s[i])\n                i += 1\n            result.append(\"</b>\")\n        else:\n            result.append(s[i])\n            i += 1\n    return \"\".join(result)\n",
            "javascript": "function addBoldTag(s, words) {\n    const n = s.length;\n    const marked = new Array(n).fill(false);\n    for (const word of words) {\n        let pos = s.indexOf(word, 0);\n        while (pos !== -1) {\n            marked.fill(true, pos, pos + word.length);\n            pos = s.indexOf(word, pos + 1);\n        }\n    }\n    let result = \"\";\n    for (let i = 0; i < n; i++) {\n        if (marked[i] && (i === 0 || !marked[i - 1])) {\n            result += \"<b>\";\n        }\n        result += s[i];\n        if (marked[i] && (i === n - 1 || !marked[i + 1])) {\n            result += \"</b>\";\n        }\n    }\n    return result;\n}\n",
            "explanation": "1. Create an array `marked` of the same length as the string `s`, initialized with boolean value `false`.\n2. Iterate through the words and, for each word, find its position in string `s` and mark each character, from the position till the end of the word, as `true` in the `marked` array. Repeat this process for all occurrences of the word in the string.\n3. Initialize an empty result string.\n4. Iterate through the string `s`. If the current character is marked and it is the first character or the previous one is not marked, add the opening tag `<b>` to the result string. Always append the current character to the result string. If the current character is marked and it is the last character or the next one is not marked, add the closing tag `</b>` to the result string.\n5. Return the result string."
        },
        "structure": {
            "c++": "#include <string>\n#include <vector>\n\nstd::string addBoldTag(std::string s, std::vector<std::string>& words) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.Arrays;\n\npublic String addBoldTag(String s, String[] words) \n    // Your code here\n}\n",
            "python": "def addBoldTag(s: str, words: list) -> str:\n    # Your code here\n\n",
            "javascript": "function addBoldTag(s, words) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <vector>\n#include <iostream>\n\nstd::string addBoldTag(std::string s, std::vector<std::string>& words);\n\nint main() {\n    std::string s = $args;\n    std::vector<std::string> words;\n    std::string word;\n    while (std::cin >> word) {\n        words.push_back(word);\n    }\n    std::string result = addBoldTag(s, words);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public String addBoldTag(String s, String[] words) {\n    int n = s.length();\n    boolean[] marked = new boolean[n];\n    for (String word : words) {\n        int pos = s.indexOf(word, 0);\n        while (pos != -1) {\n            Arrays.fill(marked, pos, pos + word.length(), true);\n            pos = s.indexOf(word, pos + 1);\n        }\n    }\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < n; i++) {\n        if (marked[i] && (i == 0 || !marked[i - 1])) {\n            result.append(\"<b>\");\n        }\n        result.append(s.charAt(i));\n        if (marked[i] && (i == n - 1 || !marked[i + 1])) {\n            result.append(\"</b>\");\n        }\n    }\n    return result.toString();\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args[0]\n    words = $args[1]\n    result = addBoldTag(s, words)\n    print(result)",
            "javascript": "function main() {\n    const s = $args[0];\n    const words = $args[1];\n    const result = addBoldTag(s, words);\n    console.log(result);\n}"
        }
    },
    "621": {
        "title": "CPU Task Scheduler",
        "description": "Given an array of tasks representing the tasks a CPU needs to do, where each letter represents a different task, determine the least number of units of time that the CPU will take to finish all the given tasks. Each task is done in one unit of time. However, there is a non-negative integer n that represents the cooldown period between two same tasks, meaning that there must be at least n units of time between any two same tasks.",
        "example": "Example:\n\nInput: tasks = [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"], n = 2\nOutput: 8\nExplanation: A -> B -> idle -> A -> B -> idle -> A -> B\nThere is at least 2 units of time between any two same tasks.",
        "level": "Medium",
        "tags": [
            "array",
            "greedy"
        ],
        "test_cases": {
            "inputs": [
                [
                    "A",
                    "A",
                    "A",
                    "B",
                    "B",
                    "B"
                ],
                [
                    "A",
                    "A",
                    "A",
                    "B",
                    "B",
                    "B"
                ],
                [
                    "A",
                    "A",
                    "A",
                    "B",
                    "B",
                    "B"
                ],
                [
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G"
                ],
                [
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G"
                ],
                [
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G"
                ],
                [
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G"
                ],
                [
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G"
                ],
                [
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G"
                ],
                [
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G"
                ],
                [
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G"
                ],
                [
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G"
                ],
                [
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G"
                ],
                [
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G"
                ],
                [
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G"
                ],
                [
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G"
                ],
                [
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G"
                ],
                [
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G"
                ],
                [
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G"
                ],
                [
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G"
                ],
                [
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G"
                ]
            ],
            "outputs": [
                8,
                8,
                8,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\n#include <unordered_map>\n\nint leastInterval(std::vector<char>& tasks, int n) {\n    std::unordered_map<char, int> task_freq;\n    for (char task : tasks) {\n        task_freq[task]++;\n    }\n\n    std::vector<int> frequencies;\n    for (auto entry : task_freq) {\n        frequencies.push_back(entry.second);\n    }\n\n    std::sort(frequencies.rbegin(), frequencies.rend());\n\n    int max_f = frequencies[0] - 1;\n    int idle_slots = max_f * n;\n\n    for (int i = 1; i < frequencies.size(); i++) {\n        idle_slots -= std::min(frequencies[i], max_f);\n    }\n\n    return idle_slots > 0 ? idle_slots + tasks.size() : tasks.size();\n}\n\n",
            "java": "import java.util.HashMap;\nimport java.util.PriorityQueue;\n\npublic int leastInterval(char[] tasks, int n) {\n    HashMap<Character, Integer> taskFreq = new HashMap<>();\n    for (char task : tasks) {\n        taskFreq.put(task, taskFreq.getOrDefault(task, 0) + 1);\n    }\n\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);\n    maxHeap.addAll(taskFreq.values());\n\n    int cycles = 0;\n\n    while (!maxHeap.isEmpty()) {\n        List<Integer> temp = new ArrayList<>();\n        for (int i = 0; i < n + 1; i++) {\n            if (!maxHeap.isEmpty()) {\n                temp.add(maxHeap.remove());\n            }\n        }\n\n        for (int freq : temp) {\n            if (--freq > 0) {\n                maxHeap.add(freq);\n            }\n        }\n\n        cycles += maxHeap.isEmpty() ? temp.size() : n + 1;\n    }\n\n    return cycles;\n}\n\n",
            "python": "from collections import Counter\n\ndef least_interval(tasks, n):\n    task_freq = Counter(tasks)\n\n    max_f = max(task_freq.values())\n    max_count = sum(1 for count in task_freq.values() if count == max_f)\n\n    return max(len(tasks), (max_f - 1) * (n + 1) + max_count)\n\n",
            "javascript": "function leastInterval(tasks, n) {\n    const taskFreq = {};\n    tasks.forEach(task => {\n        taskFreq[task] = (taskFreq[task] || 0) + 1;\n    });\n\n    const frequencies = Object.values(taskFreq).sort((a, b) => b - a);\n\n    const maxF = frequencies[0] - 1;\n    let idleSlots = maxF * n;\n\n    for (let i = 1; i < frequencies.length; i++) {\n        idleSlots -= Math.min(frequencies[i], maxF);\n    }\n\n    return idleSlots > 0 ? idleSlots + tasks.length : tasks.length;\n}\n\n",
            "explanation": "1. Count the frequency of each task using a HashMap, and store these frequencies in a sorted array or list (sorted in descending order).\n2. Calculate the maximum frequency (max_f) of a task, and the total number of idle slots required between tasks with this frequency. This is done by multiplying (max_f - 1) by the cooldown time (n).\n3. Iterate through the remaining task frequencies, decrementing the idle slots by the minimum of the current task frequency and max_f.\n4. If there are remaining idle slots, add this value to the total number of tasks to get the least number of units of time needed to complete all tasks. Otherwise, just return the total number of tasks, as there is no need for any idle time."
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\n#include <unordered_map>\n\nint leastInterval(std::vector<char>& tasks, int n) \n    // Your code here\n}\n\n",
            "java": "import java.util.HashMap;\nimport java.util.PriorityQueue;\n\npublic int leastInterval(char[] tasks, int n) \n    // Your code here\n}\n\n",
            "python": "from collections import Counter\n    # Your code here\n\n",
            "javascript": "function leastInterval(tasks, n) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <algorithm>\n#include <unordered_map>\n#include <iostream>\n\nint main() {\n    std::vector<char> tasks = $args;\n    int n = 2;\n    int result = leastInterval(tasks, n);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public int leastInterval(char[] tasks, int n) {\n    HashMap<Character, Integer> taskFreq = new HashMap<>();\n    for (char task : tasks) {\n        taskFreq.put(task, taskFreq.getOrDefault(task, 0) + 1);\n    }\n\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);\n    maxHeap.addAll(taskFreq.values());\n\n    int cycles = 0;\n\n    while (!maxHeap.isEmpty()) {\n        List<Integer> temp = new ArrayList<>();\n        for (int i = 0; i < n + 1; i++) {\n            if (!maxHeap.isEmpty()) {\n                temp.add(maxHeap.remove());\n            }\n        }\n\n        for (int freq : temp) {\n            if (--freq > 0) {\n                maxHeap.add(freq);\n            }\n        }\n\n        cycles += maxHeap.isEmpty() ? temp.size() : n + 1;\n    }\n\n    return cycles;\n}",
            "python": "if __name__ == \"__main__\":\n    tasks = $args[0]\n    n = $args[1]\n    result = least_interval(tasks, n)\n    print(result)",
            "javascript": "function main() {\n    const tasks = $args[0];\n    const n = $args[1];\n    const result = leastInterval(tasks, n);\n    console.log(result);\n}"
        }
    },
    "624": {
        "title": "Maximum Distance Between Two Integers",
        "description": "You are given `m` `arrays`, where each array is sorted in **ascending order**. You can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers `a` and `b` to be their absolute difference `|a - b|`. Return the maximum distance.",
        "example": "Example:\n\nInput: arrays = [[1,2,3],[4,5],[1,2,3]]\nOutput: 4\nExplanation: One way to reach the maximum distance 4 is to pick 1 in the first or third array and pick 5 in the second array.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        1,
                        2,
                        3
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55
                    ],
                    [
                        56,
                        57,
                        58,
                        59,
                        60
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55
                    ],
                    [
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55
                    ],
                    [
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65
                    ],
                    [
                        66,
                        67,
                        68,
                        69,
                        70
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55
                    ],
                    [
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65
                    ],
                    [
                        66,
                        67,
                        68,
                        69,
                        70
                    ],
                    [
                        71,
                        72,
                        73,
                        74,
                        75
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55
                    ],
                    [
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65
                    ],
                    [
                        66,
                        67,
                        68,
                        69,
                        70
                    ],
                    [
                        71,
                        72,
                        73,
                        74,
                        75
                    ],
                    [
                        76,
                        77,
                        78,
                        79,
                        80
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55
                    ],
                    [
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65
                    ],
                    [
                        66,
                        67,
                        68,
                        69,
                        70
                    ],
                    [
                        71,
                        72,
                        73,
                        74,
                        75
                    ],
                    [
                        76,
                        77,
                        78,
                        79,
                        80
                    ],
                    [
                        81,
                        82,
                        83,
                        84,
                        85
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55
                    ],
                    [
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65
                    ],
                    [
                        66,
                        67,
                        68,
                        69,
                        70
                    ],
                    [
                        71,
                        72,
                        73,
                        74,
                        75
                    ],
                    [
                        76,
                        77,
                        78,
                        79,
                        80
                    ],
                    [
                        81,
                        82,
                        83,
                        84,
                        85
                    ],
                    [
                        86,
                        87,
                        88,
                        89,
                        90
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55
                    ],
                    [
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65
                    ],
                    [
                        66,
                        67,
                        68,
                        69,
                        70
                    ],
                    [
                        71,
                        72,
                        73,
                        74,
                        75
                    ],
                    [
                        76,
                        77,
                        78,
                        79,
                        80
                    ],
                    [
                        81,
                        82,
                        83,
                        84,
                        85
                    ],
                    [
                        86,
                        87,
                        88,
                        89,
                        90
                    ],
                    [
                        91,
                        92,
                        93,
                        94,
                        95
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55
                    ],
                    [
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65
                    ],
                    [
                        66,
                        67,
                        68,
                        69,
                        70
                    ],
                    [
                        71,
                        72,
                        73,
                        74,
                        75
                    ],
                    [
                        76,
                        77,
                        78,
                        79,
                        80
                    ],
                    [
                        81,
                        82,
                        83,
                        84,
                        85
                    ],
                    [
                        86,
                        87,
                        88,
                        89,
                        90
                    ],
                    [
                        91,
                        92,
                        93,
                        94,
                        95
                    ],
                    [
                        96,
                        97,
                        98,
                        99,
                        100
                    ]
                ]
            ],
            "outputs": [
                4,
                0,
                9,
                6,
                14,
                19,
                24,
                29,
                34,
                39,
                44,
                49,
                54,
                59,
                64,
                69,
                74,
                79,
                84,
                89
            ]
        },
        "sample_code": {
            "c++": "int maxDistance(vector<vector<int>>& arrays) {\n    int max_dist = 0, min_val = arrays[0][0], max_val = arrays[0].back();\n    for(int i = 1; i < arrays.size(); i++) {\n        max_dist = max(max_dist, max(abs(arrays[i].back() - min_val), abs(max_val - arrays[i][0])));\n        min_val = min(min_val, arrays[i][0]);\n        max_val = max(max_val, arrays[i].back());\n    }\n    return max_dist;\n}\n",
            "java": "public int maxDistance(List<List<Integer>> arrays) {\n    int max_dist = 0, min_val = arrays.get(0).get(0), max_val = arrays.get(0).get(arrays.get(0).size() - 1);\n    for (int i = 1; i < arrays.size(); i++) {\n        max_dist = Math.max(max_dist, Math.max(\n                Math.abs(arrays.get(i).get(arrays.get(i).size() - 1) - min_val),\n                Math.abs(max_val - arrays.get(i).get(0))\n        ));\n        min_val = Math.min(min_val, arrays.get(i).get(0));\n        max_val = Math.max(max_val, arrays.get(i).get(arrays.get(i).size() - 1));\n    }\n    return max_dist;\n}\n",
            "python": "def maxDistance(arrays: List[List[int]]) -> int:\n    max_dist = 0\n    min_val = arrays[0][0]\n    max_val = arrays[0][-1]\n    \n    for arr in arrays[1:]:\n        max_dist = max(max_dist, max(abs(arr[-1] - min_val), abs(max_val - arr[0])))\n        min_val = min(min_val, arr[0])\n        max_val = max(max_val, arr[-1])\n        \n    return max_dist\n",
            "javascript": "var maxDistance = function(arrays) {\n    let max_dist = 0;\n    let min_val = arrays[0][0];\n    let max_val = arrays[0][arrays[0].length - 1];\n\n    for (let i = 1; i < arrays.length; i++) {\n        max_dist = Math.max(max_dist, Math.max(\n            Math.abs(arrays[i][arrays[i].length - 1] - min_val),\n            Math.abs(max_val - arrays[i][0])\n        ));\n        min_val = Math.min(min_val, arrays[i][0]);\n        max_val = Math.max(max_val, arrays[i][arrays[i].length - 1]);\n    }\n    return max_dist;\n};\n",
            "explanation": "We start by initializing the `max_dist` as 0, and get the minimum and maximum values from the first array in the list. Then, we iterate through the other arrays starting from index 1. For each array, we calculate the maximum distance between the current minimum value and the last element of that array, or the current maximum value and the first element of the current array. Using the calculated maximum distance, we update the maximum distance `max_dist` if it exceeds the current value. Finally, we update the minimum and maximum values with the minimum and maximum of the current array. This approach ensures that we are considering the possible array combinations without calculating every possible pair."
        },
        "structure": {
            "c++": "int maxDistance(vector<vector<int>>& arrays) \n    // Your code here\n}\n",
            "java": "public int maxDistance(List<List<Integer>> arrays) \n    // Your code here\n}\n",
            "python": "def maxDistance(arrays: List[List[int]]) -> int:\n    # Your code here\n\n",
            "javascript": "var maxDistance = function(arrays) \n    // Your code here\n};\n"
        },
        "call_functions": {
            "c++": "int maxDistance(vector<vector<int>>& arrays) {\n    int max_dist = 0, min_val = arrays[0][0], max_val = arrays[0].back();\n    for(int i = 1; i < arrays.size(); i++) {\n        max_dist = max(max_dist, max(abs(arrays[i].back() - min_val), abs(max_val - arrays[i][0])));\n        min_val = min(min_val, arrays[i][0]);\n        max_val = max(max_val, arrays[i].back());\n    }\n    return max_dist;\n}",
            "java": "public int maxDistance(List<List<Integer>> arrays) {\n    int max_dist = 0, min_val = arrays.get(0).get(0), max_val = arrays.get(0).get(arrays.get(0).size() - 1);\n    for (int i = 1; i < arrays.size(); i++) {\n        max_dist = Math.max(max_dist, Math.max(\n                Math.abs(arrays.get(i).get(arrays.get(i).size() - 1) - min_val),\n                Math.abs(max_val - arrays.get(i).get(0))\n        ));\n        min_val = Math.min(min_val, arrays.get(i).get(0));\n        max_val = Math.max(max_val, arrays.get(i).get(arrays.get(i).size() - 1));\n    }\n    return max_dist;\n}",
            "python": "if __name__ == \"__main__\":\n    arrays = $args[0]\n    result = maxDistance(arrays)\n    print(result)",
            "javascript": "var maxDistance = function(arrays) {\n    let max_dist = 0;\n    let min_val = arrays[0][0];\n    let max_val = arrays[0][arrays[0].length - 1];\n\n    for (let i = 1; i < arrays.length; i++) {\n        max_dist = Math.max(max_dist, Math.max(\n            Math.abs(arrays[i][arrays[i].length - 1] - min_val),\n            Math.abs(max_val - arrays[i][0])\n        ));\n        min_val = Math.min(min_val, arrays[i][0]);\n        max_val = Math.max(max_val, arrays[i][arrays[i].length - 1]);\n    }\n    return max_dist;\n};"
        }
    },
    "625": {
        "title": "Smallest Digit Multiplication",
        "description": "Given a positive integer num, return the smallest positive integer x whose multiplication of each digit equals num. If there is no answer or the answer is not fit in 32-bit signed integer, return 0.",
        "example": "Example:\n\nInput: num = 48\nOutput: 68\n\nExplanation: The smallest positive integer whose multiplication of each digit equals 48 is 68.\n\nInput: num = 15\nOutput: 35\nExplanation: The smallest positive integer whose multiplication of each digit equals 15 is 35.",
        "level": "Easy",
        "tags": [
            "math",
            "number"
        ],
        "test_cases": {
            "inputs": [
                48,
                15,
                1,
                9,
                12,
                100,
                123,
                456,
                789,
                999,
                1234,
                5678,
                9876,
                1111,
                2222,
                3333,
                4444,
                5555,
                6666,
                7777
            ],
            "outputs": [
                68,
                35,
                1,
                39,
                29,
                455,
                123,
                789,
                678,
                999,
                1239,
                6788,
                9876,
                11119,
                22229,
                33339,
                44449,
                55559,
                66669,
                77779
            ]
        },
        "sample_code": {
            "c++": "int smallestFactorization(int num) {\n    if (num == 1) return 1;\n    long result = 0, factor = 1;\n    for (int i = 9; i > 1; --i) {\n        while (num % i == 0) {\n            num /= i;\n            result += i * factor;\n            factor *= 10;\n            if (result > INT_MAX) return 0;\n        }\n    }\n    return num == 1 ? result : 0;\n}\n",
            "java": "public int smallestFactorization(int num) {\n    if (num == 1) return 1;\n    long result = 0, factor = 1;\n    for (int i = 9; i > 1; --i) {\n        while (num % i == 0) {\n            num /= i;\n            result += i * factor;\n            factor *= 10;\n            if (result > Integer.MAX_VALUE) return 0;\n        }\n    }\n    return num == 1 ? (int) result : 0;\n}\n",
            "python": "def smallestFactorization(num: int) -> int:\n    if num == 1:\n        return 1\n    result = 0\n    factor = 1\n    for i in range(9, 1, -1):\n        while num % i == 0:\n            num //= i\n            result += i * factor\n            factor *= 10\n            if result > 2**31 - 1:\n                return 0\n    return result if num == 1 else 0\n",
            "javascript": "function smallestFactorization(num) {\n    if (num === 1) return 1;\n    let result = 0, factor = 1;\n    for (let i = 9; i > 1; --i) {\n        while (num % i === 0) {\n            num /= i;\n            result += i * factor;\n            factor *= 10;\n            if (result > (2**31 - 1)) return 0;\n        }\n    }\n    return num === 1 ? result : 0;\n}\n",
            "explanation": "The algorithm iterates from 9 to 2 (in reverse order) and divides the input number `num` by the current iterating value `i`. If `num` is completely divisible by `i`, the loop updates `result` by adding the current `i * factor` and updating the `factor` by multiplying it by 10. If `result` ever goes beyond the 32-bit signed integer limit, the function returns 0. The loop continues to iterate and divide `num` until `num` becomes 1 (i.e., all factors have been found) or there are no more appropriate dividers. If `num` is 1, i.e., all factors are found, the result is returned; otherwise, the function returns 0."
        },
        "structure": {
            "c++": "int smallestFactorization(int num) \n    // Your code here\n}\n",
            "java": "public int smallestFactorization(int num) \n    // Your code here\n}\n",
            "python": "def smallestFactorization(num: int) -> int:\n    # Your code here\n\n",
            "javascript": "function smallestFactorization(num) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int num = $args;\n    int result = smallestFactorization(num);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int smallestFactorization(int num) {\n    if (num == 1) return 1;\n    long result = 0, factor = 1;\n    for (int i = 9; i > 1; --i) {\n        while (num % i == 0) {\n            num /= i;\n            result += i * factor;\n            factor *= 10;\n            if (result > Integer.MAX_VALUE) return 0;\n        }\n    }\n    return num == 1 ? (int) result : 0;\n}",
            "python": "if __name__ == \"__main__\":\n    num = $args[0]\n    result = smallestFactorization(num)\n    print(result)",
            "javascript": "function main() {\n    const num = $args;\n    const result = smallestFactorization(num);\n    console.log(result);\n}"
        }
    },
    "628": {
        "title": "Maximum Product of Three Numbers",
        "description": "Given an integer array `nums`, find three numbers whose product is maximum and return the maximum product.",
        "example": "Example:\n\nInput: nums = [1,2,3]\nOutput: 6\n\nExplanation: The maximum product is obtained by multiplying 2, 3, and 1 together.",
        "level": "Easy",
        "tags": [
            "array",
            "math"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3
                ],
                [
                    1,
                    2,
                    3,
                    4
                ],
                [
                    -1,
                    -2,
                    -3
                ],
                [
                    0,
                    0,
                    0
                ],
                [
                    1,
                    1,
                    1
                ],
                [
                    -1,
                    -1,
                    -1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    -6
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    -6,
                    -7
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    -6,
                    -7,
                    -8
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    -6,
                    -7,
                    -8,
                    -9
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    -6,
                    -7,
                    -8,
                    -9,
                    -10
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100
                ],
                [
                    -10,
                    -20,
                    -30,
                    -40,
                    -50,
                    -60,
                    -70,
                    -80,
                    -90,
                    -100
                ]
            ],
            "outputs": [
                6,
                24,
                -6,
                0,
                1,
                -1,
                60,
                -120,
                120,
                -720,
                210,
                -5040,
                5040,
                -40320,
                362880,
                -362880,
                3628800,
                -3628800,
                36288000,
                -36288000
            ]
        },
        "sample_code": {
            "c++": "int maximumProduct(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    int n = nums.size();\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3]);\n}\n",
            "java": "public int maximumProduct(int[] nums) {\n    Arrays.sort(nums);\n    int n = nums.length;\n    return Math.max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3]);\n}\n",
            "python": "def maximumProduct(nums):\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])\n",
            "javascript": "function maximumProduct(nums) {\n    nums.sort((a, b) => a - b);\n    const n = nums.length;\n    return Math.max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3]);\n}\n",
            "explanation": "First, we sort the input array in non-decreasing order. After sorting, we can determine the maximum product using two possible scenarios.\n\n1. The maximum product is formed by the product of the three highest numbers in the array. We can get this by multiplying the last three elements of the sorted array.\n\n2. The maximum product is formed by the product of the two lowest (most negative) numbers and the highest number in the array. We can get this by multiplying the first two elements and the last element of the sorted array.\n\nWe take the maximum of these two results to get the final answer."
        },
        "structure": {
            "c++": "int maximumProduct(vector<int>& nums) \n    // Your code here\n}\n",
            "java": "public int maximumProduct(int[] nums) \n    // Your code here\n}\n",
            "python": "def maximumProduct(nums):\n    # Your code here\n\n",
            "javascript": "function maximumProduct(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> nums = $args;\n    int result = maximumProduct(nums);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int maximumProduct(int[] nums) {\n    Arrays.sort(nums);\n    int n = nums.length;\n    return Math.max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3]);\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = maximumProduct(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = maximumProduct(nums);\n    console.log(result);\n}"
        }
    },
    "629": {
        "title": "Number of Arrays with K Inverse Pairs",
        "description": "Given two integers n and k, you need to return the number of different arrays that consist of numbers from 1 to n and have exactly k inverse pairs. An inverse pair is a pair of integers [i, j] where 0 <= i < j < nums.length and nums[i] > nums[j]. Since the answer can be large, return it modulo 10^9 + 7.",
        "example": "Example 1:\n\nInput: n = 3, k = 0\nOutput: 1\nExplanation: Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pairs.\n\nExample 2:\n\nInput: n = 3, k = 1\nOutput: 2\nExplanation: The arrays [1,3,2] and [2,1,3] have exactly 1 inverse pair.",
        "level": "Medium",
        "tags": [
            "Dynamic Programming",
            "Combinatorics"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    0
                ],
                [
                    3,
                    1
                ],
                [
                    4,
                    2
                ],
                [
                    5,
                    3
                ],
                [
                    10,
                    5
                ],
                [
                    100,
                    10
                ],
                [
                    1000,
                    100
                ],
                [
                    1000,
                    500
                ],
                [
                    1000,
                    1000
                ],
                [
                    1000,
                    0
                ],
                [
                    1,
                    0
                ],
                [
                    1,
                    1
                ],
                [
                    2,
                    0
                ],
                [
                    2,
                    1
                ],
                [
                    2,
                    2
                ],
                [
                    10,
                    0
                ],
                [
                    10,
                    1
                ],
                [
                    10,
                    5
                ],
                [
                    10,
                    10
                ],
                [
                    100,
                    0
                ]
            ],
            "outputs": [
                1,
                2,
                4,
                6,
                792,
                782204094,
                663677020,
                478768275,
                1,
                1,
                1,
                0,
                1,
                2,
                1,
                1,
                1,
                1,
                1,
                1
            ]
        },
        "sample_code": {
            "c++": "int kInversePairs(int n, int k) {\n    int mod = 1e9 + 7;\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\n    for (int i = 1; i <= n; ++i) {\n        dp[i][0] = 1;\n        for (int j = 1; j <= k; ++j) {\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod;\n            if (j - i >= 0) {\n                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;\n            }\n        }\n    }\n    return dp[n][k];\n}\n",
            "java": "public int kInversePairs(int n, int k) {\n    int mod = 1000000007;\n    int[][] dp = new int[n + 1][k + 1];\n    for (int i = 1; i <= n; i++) {\n        dp[i][0] = 1;\n        for (int j = 1; j <= k; j++) {\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod;\n            if (j - i >= 0) {\n                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;\n            }\n        }\n    }\n    return dp[n][k];\n}\n",
            "python": "def kInversePairs(n: int, k: int) -> int:\n    mod = 10**9 + 7\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][0] = 1\n        for j in range(1, k + 1):\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod\n            if j - i >= 0:\n                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod\n    return dp[n][k]\n",
            "javascript": "function kInversePairs(n, k) {\n    const mod = 1e9 + 7;\n    const dp = Array.from({ length: n + 1 }, () => Array(k + 1).fill(0));\n    for (let i = 1; i <= n; ++i) {\n        dp[i][0] = 1;\n        for (let j = 1; j <= k; ++j) {\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod;\n            if (j - i >= 0) {\n                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;\n            }\n        }\n    }\n    return dp[n][k];\n}\n",
            "explanation": "We use dynamic programming to solve this problem. We create a 2D array dp where `dp[i][j]` represents the number of arrays with `i` elements having `j` inverse pairs. We initialize `dp[i][0]` to 1 for all `i`.\n\nFor each `i` and `j`, we update the value of `dp[i][j]` using the following relation:\n\n`dp[i][j] = dp[i][j - 1] + dp[i - 1][j]`\n\nIf there are enough elements (i.e., `j - i >= 0`) to form an inverse pair, we subtract the number of inverse pairs using `dp[i - 1][j - i]`. After updating the value, we ensure that the result stays within the given range by taking the modulo with 10^9 + 7.\n\nFinally, we return the value at `dp[n][k]`, which represents the number of arrays with `n` (1 to n) elements having exactly `k` inverse pairs. "
        },
        "structure": {
            "c++": "int kInversePairs(int n, int k) \n    // Your code here\n}\n",
            "java": "public int kInversePairs(int n, int k) \n    // Your code here\n}\n",
            "python": "def kInversePairs(n: int, k: int) -> int:\n    # Your code here\n\n",
            "javascript": "function kInversePairs(n, k) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int k = $args;\n    int result = kInversePairs(n, k);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int kInversePairs(int n, int k) {\n    int mod = 1000000007;\n    int[][] dp = new int[n + 1][k + 1];\n    for (int i = 1; i <= n; i++) {\n        dp[i][0] = 1;\n        for (int j = 1; j <= k; j++) {\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod;\n            if (j - i >= 0) {\n                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;\n            }\n        }\n    }\n    return dp[n][k];\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    k = $args[1]\n    result = kInversePairs(n, k)\n    print(result)",
            "javascript": "function kInversePairs(n, k) {\n    const mod = 1e9 + 7;\n    const dp = Array.from({ length: n + 1 }, () => Array(k + 1).fill(0));\n    for (let i = 1; i <= n; ++i) {\n        dp[i][0] = 1;\n        for (let j = 1; j <= k; ++j) {\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod;\n            if (j - i >= 0) {\n                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;\n            }\n        }\n    }\n    return dp[n][k];\n}"
        }
    },
    "630": {
        "title": "Maximum Number of Online Courses",
        "description": "You are given an array of online courses, where each course is represented by its duration and the last day it can be taken. You can only take one course at a time and must finish each course before or on its last day. Return the maximum number of courses you can take.",
        "example": "Example:\n\nInput: [[100,200],[200,1300],[1000,1250],[2000,3200]]\nOutput: 3\nExplanation: You can take the first course from day 1 to day 100. Then, you can take the third course from day 101 to day 1100. Finally, you can take the second course from day 1101 to day 1300. The fourth course cannot be taken as it exceeds the last day.\n\nInput: [[1,2]]\nOutput: 1\nExplanation: You can take the only course from day 1 to day 1.\n\nInput: [[3,2],[4,3]]\nOutput: 0\nExplanation: You cannot take any course as the duration exceeds the last day.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting",
            "greedy"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        100,
                        200
                    ],
                    [
                        200,
                        1300
                    ],
                    [
                        1000,
                        1250
                    ],
                    [
                        2000,
                        3200
                    ]
                ],
                [
                    [
                        1,
                        2
                    ]
                ],
                [
                    [
                        3,
                        2
                    ],
                    [
                        4,
                        3
                    ]
                ],
                [
                    [
                        5,
                        10
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        8,
                        12
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        3,
                        7
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        2
                    ],
                    [
                        5,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ]
                ],
                [
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        3,
                        8
                    ],
                    [
                        4,
                        7
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        10,
                        20
                    ],
                    [
                        30,
                        40
                    ],
                    [
                        50,
                        60
                    ],
                    [
                        70,
                        80
                    ],
                    [
                        90,
                        100
                    ]
                ],
                [
                    [
                        100,
                        200
                    ],
                    [
                        200,
                        300
                    ],
                    [
                        300,
                        400
                    ],
                    [
                        400,
                        500
                    ],
                    [
                        500,
                        600
                    ]
                ],
                [
                    [
                        1,
                        10000
                    ],
                    [
                        2,
                        9999
                    ],
                    [
                        3,
                        9998
                    ],
                    [
                        4,
                        9997
                    ],
                    [
                        5,
                        9996
                    ]
                ],
                [
                    [
                        10000,
                        1
                    ],
                    [
                        9999,
                        2
                    ],
                    [
                        9998,
                        3
                    ],
                    [
                        9997,
                        4
                    ],
                    [
                        9996,
                        5
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ]
                ],
                [
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        3,
                        8
                    ],
                    [
                        4,
                        7
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        5
                    ],
                    [
                        7,
                        4
                    ],
                    [
                        8,
                        3
                    ],
                    [
                        9,
                        2
                    ],
                    [
                        10,
                        1
                    ]
                ],
                [
                    [
                        10,
                        1
                    ],
                    [
                        9,
                        2
                    ],
                    [
                        8,
                        3
                    ],
                    [
                        7,
                        4
                    ],
                    [
                        6,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        4,
                        7
                    ],
                    [
                        3,
                        8
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        1,
                        10
                    ]
                ],
                [
                    [
                        1,
                        100
                    ],
                    [
                        2,
                        99
                    ],
                    [
                        3,
                        98
                    ],
                    [
                        4,
                        97
                    ],
                    [
                        5,
                        96
                    ],
                    [
                        6,
                        95
                    ],
                    [
                        7,
                        94
                    ],
                    [
                        8,
                        93
                    ],
                    [
                        9,
                        92
                    ],
                    [
                        10,
                        91
                    ]
                ],
                [
                    [
                        100,
                        1
                    ],
                    [
                        99,
                        2
                    ],
                    [
                        98,
                        3
                    ],
                    [
                        97,
                        4
                    ],
                    [
                        96,
                        5
                    ],
                    [
                        95,
                        6
                    ],
                    [
                        94,
                        7
                    ],
                    [
                        93,
                        8
                    ],
                    [
                        92,
                        9
                    ],
                    [
                        91,
                        10
                    ]
                ],
                [
                    [
                        1,
                        1000
                    ],
                    [
                        2,
                        999
                    ],
                    [
                        3,
                        998
                    ],
                    [
                        4,
                        997
                    ],
                    [
                        5,
                        996
                    ],
                    [
                        6,
                        995
                    ],
                    [
                        7,
                        994
                    ],
                    [
                        8,
                        993
                    ],
                    [
                        9,
                        992
                    ],
                    [
                        10,
                        991
                    ]
                ],
                [
                    [
                        1000,
                        1
                    ],
                    [
                        999,
                        2
                    ],
                    [
                        998,
                        3
                    ],
                    [
                        997,
                        4
                    ],
                    [
                        996,
                        5
                    ],
                    [
                        995,
                        6
                    ],
                    [
                        994,
                        7
                    ],
                    [
                        993,
                        8
                    ],
                    [
                        992,
                        9
                    ],
                    [
                        991,
                        10
                    ]
                ],
                [
                    [
                        1,
                        10000
                    ],
                    [
                        2,
                        9999
                    ],
                    [
                        3,
                        9998
                    ],
                    [
                        4,
                        9997
                    ],
                    [
                        5,
                        9996
                    ],
                    [
                        6,
                        9995
                    ],
                    [
                        7,
                        9994
                    ],
                    [
                        8,
                        9993
                    ],
                    [
                        9,
                        9992
                    ],
                    [
                        10,
                        9991
                    ]
                ],
                [
                    [
                        10000,
                        1
                    ],
                    [
                        9999,
                        2
                    ],
                    [
                        9998,
                        3
                    ],
                    [
                        9997,
                        4
                    ],
                    [
                        9996,
                        5
                    ],
                    [
                        9995,
                        6
                    ],
                    [
                        9994,
                        7
                    ],
                    [
                        9993,
                        8
                    ],
                    [
                        9992,
                        9
                    ],
                    [
                        9991,
                        10
                    ]
                ]
            ],
            "outputs": [
                "3",
                "1",
                "0",
                "5",
                "3",
                "5",
                "5",
                "5",
                "5",
                "5",
                "5",
                "1",
                "5",
                "10",
                "10",
                "10",
                "10",
                "10",
                "10",
                "10",
                "10"
            ]
        },
        "sample_code": {
            "c++": "#include <algorithm>\n#include <queue>\n#include <vector>\n\nint scheduleCourse(std::vector<std::vector<int>>& courses) {\n    std::sort(courses.begin(), courses.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[1] < b[1];\n    });\n\n    std::priority_queue<int> pq;\n    int time = 0;\n\n    for (const auto& course : courses) {\n        time += course[0];\n        pq.push(course[0]);\n\n        if (time > course[1]) {\n            time -= pq.top();\n            pq.pop();\n        }\n    }\n\n    return pq.size();\n}\n",
            "java": "import java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic int scheduleCourse(int[][] courses) {\n    Arrays.sort(courses, (a, b) -> a[1] - b[1]);\n\n    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n    int time = 0;\n\n    for (int[] course : courses) {\n        time += course[0];\n        pq.offer(course[0]);\n\n        if (time > course[1]) {\n            time -= pq.poll();\n        }\n    }\n\n    return pq.size();\n}\n",
            "python": "import heapq\n\ndef scheduleCourse(courses):\n    courses.sort(key=lambda x: x[1])\n    curr_time, duration_sum = 0, []\n\n    for duration, deadline in courses:\n        curr_time += duration\n        heapq.heappush(duration_sum, -duration)\n\n        if curr_time > deadline:\n            curr_time += heapq.heappop(duration_sum)\n\n    return len(duration_sum)\n",
            "javascript": "function scheduleCourse(courses) {\n    courses.sort((a, b) => a[1] - b[1]);\n\n    const pq = new PriorityQueue((a, b) => b - a);\n    let time = 0;\n\n    for (const course of courses) {\n        time += course[0];\n        pq.push(course[0]);\n\n        if (time > course[1]) {\n            time -= pq.pop();\n        }\n    }\n\n    return pq.size();\n}\n\nclass PriorityQueue {\n    constructor(comparator) {\n        this.data = [];\n        this.comparator = comparator;\n    }\n\n    push(item) {\n        this.data.push(item);\n        this.data.sort(this.comparator);\n    }\n\n    pop() {\n        return this.data.shift();\n    }\n\n    size() {\n        return this.data.length;\n    }\n}\n",
            "explanation": "1. Sort the courses based on their deadline (lastDay).\n2. Create a max-heap (priority queue) to store the course durations.\n3. Initialize a variable `time` to track the current time (start at 0).\n4. Iterate through the sorted courses:\n   a. Add the duration to the `time`.\n   b. Push the duration to the max-heap.\n   c. If the `time` is greater than the course's deadline, then remove the longest duration from max-heap and subtract it from `time`.\n5. Return the size of the max-heap, which represents the number of courses that can be taken.\n\nBy sorting the courses by deadline and using a max-heap to store durations, we can efficiently determine which courses to take and which to drop when the deadline is not met. This greedy approach ensures that at each iteration, the optimal solution is reached up to the current course."
        },
        "structure": {
            "c++": "#include <algorithm>\n#include <queue>\n#include <vector>\n\nint scheduleCourse(std::vector<std::vector<int>>& courses) \n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic int scheduleCourse(int[][] courses) \n    // Your code here\n}\n",
            "python": "import heapq\n    # Your code here\n\n",
            "javascript": "function scheduleCourse(courses) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <algorithm>\n#include <queue>\n#include <vector>\n\nint main() {\n    std::vector<std::vector<int>> courses = $args;\n    int result = scheduleCourse(courses);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int scheduleCourse(int[][] courses) {\n    Arrays.sort(courses, (a, b) -> a[1] - b[1]);\n\n    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n    int time = 0;\n\n    for (int[] course : courses) {\n        time += course[0];\n        pq.offer(course[0]);\n\n        if (time > course[1]) {\n            time -= pq.poll();\n        }\n    }\n\n    return pq.size();\n}",
            "python": "if __name__ == \"__main__\":\n    courses = $args[0]\n    result = scheduleCourse(courses)\n    print(result)",
            "javascript": "function main() {\n    const courses = $args;\n    const result = scheduleCourse(courses);\n    console.log(result);\n}"
        }
    },
    "632": {
        "title": "Smallest Range",
        "description": "You have `k` lists of sorted integers in **non-decreasing order**. Find the **smallest** range that includes at least one number from each of the `k` lists.\n\nWe define the range `[a, b]` is smaller than range `[c, d]` if `b - a < d - c` **or** `a < c` if `b - a == d - c`.",
        "example": "Example:\n\n**Input:** nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\n**Output:** [20,24]\n**Explanation:**\nList 1: [4, 10, 15, 24,26], 24 is in range [20,24].\nList 2: [0, 9, 12, 20], 20 is in range [20,24].\nList 3: [5, 18, 22, 30], 22 is in range [20,24].",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        4,
                        10,
                        15,
                        24,
                        26
                    ],
                    [
                        0,
                        9,
                        12,
                        20
                    ],
                    [
                        5,
                        18,
                        22,
                        30
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        1,
                        2,
                        3
                    ]
                ],
                [
                    [
                        1,
                        5,
                        9,
                        13
                    ],
                    [
                        2,
                        6,
                        10,
                        14
                    ],
                    [
                        3,
                        7,
                        11,
                        15
                    ],
                    [
                        4,
                        8,
                        12,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        3,
                        4,
                        5,
                        6,
                        7
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        4,
                        5,
                        6,
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        5,
                        6,
                        7,
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        8,
                        9,
                        10,
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        8,
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        9,
                        10,
                        11,
                        12,
                        13
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        8,
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        9,
                        10,
                        11,
                        12,
                        13
                    ],
                    [
                        10,
                        11,
                        12,
                        13,
                        14
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        8,
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        9,
                        10,
                        11,
                        12,
                        13
                    ],
                    [
                        10,
                        11,
                        12,
                        13,
                        14
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55
                    ],
                    [
                        56,
                        57,
                        58,
                        59,
                        60
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        8,
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        9,
                        10,
                        11,
                        12,
                        13
                    ],
                    [
                        10,
                        11,
                        12,
                        13,
                        14
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        12,
                        13,
                        14,
                        15,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55
                    ],
                    [
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        8,
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        9,
                        10,
                        11,
                        12,
                        13
                    ],
                    [
                        10,
                        11,
                        12,
                        13,
                        14
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        12,
                        13,
                        14,
                        15,
                        16
                    ],
                    [
                        13,
                        14,
                        15,
                        16,
                        17
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55
                    ],
                    [
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65
                    ],
                    [
                        66,
                        67,
                        68,
                        69,
                        70
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        8,
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        9,
                        10,
                        11,
                        12,
                        13
                    ],
                    [
                        10,
                        11,
                        12,
                        13,
                        14
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        12,
                        13,
                        14,
                        15,
                        16
                    ],
                    [
                        13,
                        14,
                        15,
                        16,
                        17
                    ],
                    [
                        14,
                        15,
                        16,
                        17,
                        18
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55
                    ],
                    [
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65
                    ],
                    [
                        66,
                        67,
                        68,
                        69,
                        70
                    ],
                    [
                        71,
                        72,
                        73,
                        74,
                        75
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        8,
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        9,
                        10,
                        11,
                        12,
                        13
                    ],
                    [
                        10,
                        11,
                        12,
                        13,
                        14
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        12,
                        13,
                        14,
                        15,
                        16
                    ],
                    [
                        13,
                        14,
                        15,
                        16,
                        17
                    ],
                    [
                        14,
                        15,
                        16,
                        17,
                        18
                    ],
                    [
                        15,
                        16,
                        17,
                        18,
                        19
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55
                    ],
                    [
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65
                    ],
                    [
                        66,
                        67,
                        68,
                        69,
                        70
                    ],
                    [
                        71,
                        72,
                        73,
                        74,
                        75
                    ],
                    [
                        76,
                        77,
                        78,
                        79,
                        80
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        8,
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        9,
                        10,
                        11,
                        12,
                        13
                    ],
                    [
                        10,
                        11,
                        12,
                        13,
                        14
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        12,
                        13,
                        14,
                        15,
                        16
                    ],
                    [
                        13,
                        14,
                        15,
                        16,
                        17
                    ],
                    [
                        14,
                        15,
                        16,
                        17,
                        18
                    ],
                    [
                        15,
                        16,
                        17,
                        18,
                        19
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55
                    ],
                    [
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65
                    ],
                    [
                        66,
                        67,
                        68,
                        69,
                        70
                    ],
                    [
                        71,
                        72,
                        73,
                        74,
                        75
                    ],
                    [
                        76,
                        77,
                        78,
                        79,
                        80
                    ],
                    [
                        81,
                        82,
                        83,
                        84,
                        85
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        8,
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        9,
                        10,
                        11,
                        12,
                        13
                    ],
                    [
                        10,
                        11,
                        12,
                        13,
                        14
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        12,
                        13,
                        14,
                        15,
                        16
                    ],
                    [
                        13,
                        14,
                        15,
                        16,
                        17
                    ],
                    [
                        14,
                        15,
                        16,
                        17,
                        18
                    ],
                    [
                        15,
                        16,
                        17,
                        18,
                        19
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        17,
                        18,
                        19,
                        20,
                        21
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55
                    ],
                    [
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65
                    ],
                    [
                        66,
                        67,
                        68,
                        69,
                        70
                    ],
                    [
                        71,
                        72,
                        73,
                        74,
                        75
                    ],
                    [
                        76,
                        77,
                        78,
                        79,
                        80
                    ],
                    [
                        81,
                        82,
                        83,
                        84,
                        85
                    ],
                    [
                        86,
                        87,
                        88,
                        89,
                        90
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        8,
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        9,
                        10,
                        11,
                        12,
                        13
                    ],
                    [
                        10,
                        11,
                        12,
                        13,
                        14
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        12,
                        13,
                        14,
                        15,
                        16
                    ],
                    [
                        13,
                        14,
                        15,
                        16,
                        17
                    ],
                    [
                        14,
                        15,
                        16,
                        17,
                        18
                    ],
                    [
                        15,
                        16,
                        17,
                        18,
                        19
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        17,
                        18,
                        19,
                        20,
                        21
                    ],
                    [
                        18,
                        19,
                        20,
                        21,
                        22
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55
                    ],
                    [
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65
                    ],
                    [
                        66,
                        67,
                        68,
                        69,
                        70
                    ],
                    [
                        71,
                        72,
                        73,
                        74,
                        75
                    ],
                    [
                        76,
                        77,
                        78,
                        79,
                        80
                    ],
                    [
                        81,
                        82,
                        83,
                        84,
                        85
                    ],
                    [
                        86,
                        87,
                        88,
                        89,
                        90
                    ],
                    [
                        91,
                        92,
                        93,
                        94,
                        95
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        8,
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        9,
                        10,
                        11,
                        12,
                        13
                    ],
                    [
                        10,
                        11,
                        12,
                        13,
                        14
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        12,
                        13,
                        14,
                        15,
                        16
                    ],
                    [
                        13,
                        14,
                        15,
                        16,
                        17
                    ],
                    [
                        14,
                        15,
                        16,
                        17,
                        18
                    ],
                    [
                        15,
                        16,
                        17,
                        18,
                        19
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        17,
                        18,
                        19,
                        20,
                        21
                    ],
                    [
                        18,
                        19,
                        20,
                        21,
                        22
                    ],
                    [
                        19,
                        20,
                        21,
                        22,
                        23
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ],
                    [
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55
                    ],
                    [
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65
                    ],
                    [
                        66,
                        67,
                        68,
                        69,
                        70
                    ],
                    [
                        71,
                        72,
                        73,
                        74,
                        75
                    ],
                    [
                        76,
                        77,
                        78,
                        79,
                        80
                    ],
                    [
                        81,
                        82,
                        83,
                        84,
                        85
                    ],
                    [
                        86,
                        87,
                        88,
                        89,
                        90
                    ],
                    [
                        91,
                        92,
                        93,
                        94,
                        95
                    ],
                    [
                        96,
                        97,
                        98,
                        99,
                        100
                    ]
                ]
            ],
            "outputs": [
                "[20,24]",
                "[1,1]",
                "[1,16]",
                "[1,15]",
                "[1,5]",
                "[1,20]",
                "[1,8]",
                "[1,25]",
                "[1,9]",
                "[1,30]",
                "[1,10]",
                "[1,35]",
                "[1,11]",
                "[1,40]",
                "[1,12]",
                "[1,45]",
                "[1,13]",
                "[1,50]",
                "[1,14]",
                "[1,55]",
                "[1,15]",
                "[1,60]",
                "[1,16]",
                "[1,65]",
                "[1,17]",
                "[1,70]",
                "[1,18]",
                "[1,75]",
                "[1,19]",
                "[1,80]",
                "[1,20]",
                "[1,85]",
                "[1,21]",
                "[1,90]",
                "[1,22]",
                "[1,95]",
                "[1,23]",
                "[1,100]",
                "[1,24]",
                "[1,105]",
                "[1,25]",
                "[1,110]",
                "[1,26]",
                "[1,115]",
                "[1,27]",
                "[1,120]",
                "[1,28]",
                "[1,125]",
                "[1,29]",
                "[1,130]",
                "[1,30]",
                "[1,135]",
                "[1,31]",
                "[1,140]",
                "[1,32]",
                "[1,145]",
                "[1,33]",
                "[1,150]",
                "[1,34]",
                "[1,155]",
                "[1,35]",
                "[1,160]",
                "[1,36]",
                "[1,165]",
                "[1,37]",
                "[1,170]",
                "[1,38]",
                "[1,175]",
                "[1,39]",
                "[1,180]",
                "[1,40]",
                "[1,185]",
                "[1,41]",
                "[1,190]",
                "[1,42]",
                "[1,195]",
                "[1,43]",
                "[1,200]",
                "[1,44]",
                "[1,205]",
                "[1,45]",
                "[1,210]",
                "[1,46]",
                "[1,215]",
                "[1,47]",
                "[1,220]",
                "[1,48]",
                "[1,225]",
                "[1,49]",
                "[1,230]",
                "[1,50]",
                "[1,235]",
                "[1,51]",
                "[1,240]",
                "[1,52]",
                "[1,245]",
                "[1,53]",
                "[1,250]",
                "[1,54]",
                "[1,255]",
                "[1,55]",
                "[1,260]",
                "[1,56]",
                "[1,265]",
                "[1,57]",
                "[1,270]",
                "[1,58]",
                "[1,275]",
                "[1,59]",
                "[1,280]",
                "[1,60]",
                "[1,285]",
                "[1,61]",
                "[1,290]",
                "[1,62]",
                "[1,295]",
                "[1,63]",
                "[1,300]",
                "[1,64]",
                "[1,305]",
                "[1,65]",
                "[1,310]",
                "[1,66]",
                "[1,315]",
                "[1,67]",
                "[1,320]",
                "[1,68]",
                "[1,325]",
                "[1,69]",
                "[1,330]",
                "[1,70]",
                "[1,335]",
                "[1,71]",
                "[1,340]",
                "[1,72]",
                "[1,345]",
                "[1,73]",
                "[1,350]",
                "[1,74]",
                "[1,355]",
                "[1,75]",
                "[1,360]",
                "[1,76]",
                "[1,365]",
                "[1,77]",
                "[1,370]",
                "[1,78]",
                "[1,375]",
                "[1,79]",
                "[1,380]",
                "[1,80]",
                "[1,385]",
                "[1,81]",
                "[1,390]",
                "[1,82]",
                "[1,395]",
                "[1,83]",
                "[1,400]",
                "[1,84]",
                "[1,405]",
                "[1,85]",
                "[1,410]",
                "[1,86]",
                "[1,415]",
                "[1,87]",
                "[1,420]",
                "[1,88]",
                "[1,425]",
                "[1,89]",
                "[1,430]",
                "[1,90]",
                "[1,435]",
                "[1,91]",
                "[1,440]",
                "[1,92]",
                "[1,445]",
                "[1,93]",
                "[1,450]",
                "[1,94]",
                "[1,455]",
                "[1,95]",
                "[1,460]",
                "[1,96]",
                "[1,465]",
                "[1,97]",
                "[1,470]",
                "[1,98]",
                "[1,475]",
                "[1,99]",
                "[1,480]",
                "[1,100]",
                "[1,485]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <queue>\n#include <limits>\n#include <utility>\n\nstd::pair<int, int> smallestRange(std::vector<std::vector<int>>& nums) {\n    auto listComparator = [](const auto& a, const auto& b) {\n        return a.first > b.first;\n    };\n\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, decltype(listComparator)> minHeap(listComparator);\n\n    int maxVal = std::numeric_limits<int>::min();\n    for (int i = 0; i < nums.size(); i++) {\n        minHeap.push({nums[i][0], i});\n        maxVal = std::max(maxVal, nums[i][0]);\n    }\n\n    std::vector<int> listIndices(nums.size(), 0);\n    int minRange = std::numeric_limits<int>::max();\n    int start = -1, end = -1;\n\n    while (minHeap.size() == nums.size()) {\n        auto entry = minHeap.top();\n        minHeap.pop();\n        int val = entry.first;\n        int listIdx = entry.second;\n        int range = maxVal - val;\n\n        if (range < minRange) {\n            minRange = range;\n            start = val;\n            end = maxVal;\n        }\n\n        listIndices[listIdx]++;\n        if (listIndices[listIdx] < nums[listIdx].size()) {\n            int newVal = nums[listIdx][listIndices[listIdx]];\n            minHeap.push({newVal, listIdx});\n            maxVal = std::max(maxVal, newVal);\n        }\n    }\n\n    return {start, end};\n}\n",
            "java": "import java.util.PriorityQueue;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Comparator;\n\npublic int[] smallestRange(List<List<Integer>> nums) {\n    PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\n\n    int maxVal = Integer.MIN_VALUE;\n    for (int i = 0; i < nums.size(); i++) {\n        minHeap.offer(new int[] {nums.get(i).get(0), i});\n        maxVal = Math.max(maxVal, nums.get(i).get(0));\n    }\n\n    List<Integer> listIndices = new ArrayList<>();\n    for (int i = 0; i < nums.size(); i++) {\n        listIndices.add(0);\n    }\n    int minRange = Integer.MAX_VALUE;\n    int start = -1, end = -1;\n\n    while (minHeap.size() == nums.size()) {\n        int[] entry = minHeap.poll();\n        int val = entry[0];\n        int listIdx = entry[1];\n        int range = maxVal - val;\n\n        if (range < minRange) {\n            minRange = range;\n            start = val;\n            end = maxVal;\n        }\n\n        listIndices.set(listIdx, listIndices.get(listIdx) + 1);\n        if (listIndices.get(listIdx) < nums.get(listIdx).size()) {\n            int newVal = nums.get(listIdx).get(listIndices.get(listIdx));\n            minHeap.offer(new int[] {newVal, listIdx});\n            maxVal = Math.max(maxVal, newVal);\n        }\n    }\n\n    return new int[] {start, end};\n}\n",
            "python": "import heapq\n\ndef smallestRange(nums):\n    minHeap = []\n    maxVal = -1e9\n    \n    for i, lst in enumerate(nums):\n        heapq.heappush(minHeap, (lst[0], i))\n        maxVal = max(maxVal, lst[0])\n        \n    listIndices = [0] * len(nums)\n    minRange = 1e9\n    start, end = -1, -1\n    \n    while len(minHeap) == len(nums):\n        val, listIdx = heapq.heappop(minHeap)\n        range_ = maxVal - val\n        \n        if range_ < minRange:\n            minRange = range_\n            start, end = val, maxVal\n            \n        listIndices[listIdx] += 1\n        if listIndices[listIdx] < len(nums[listIdx]):\n            newVal = nums[listIdx][listIndices[listIdx]]\n            heapq.heappush(minHeap, (newVal, listIdx))\n            maxVal = max(maxVal, newVal)\n            \n    return [start, end]\n",
            "javascript": "function smallestRange(nums) {\n    const minHeap = [],\n          listIndices = Array(nums.length).fill(0);\n          \n    let maxVal = -Infinity;\n    \n    for (let i = 0; i < nums.length; i++) {\n        minHeap.push([nums[i][0], i]);\n        maxVal = Math.max(maxVal, nums[i][0]);\n    }\n    minHeap.sort(([a], [b]) => a - b);\n\n    let minRange = Infinity,\n        start = -1,\n        end = -1;\n    \n    while (minHeap.length === nums.length) {\n        const [val, listIdx] = minHeap.shift();\n        const range = maxVal - val;\n        \n        if (range < minRange) {\n            minRange = range;\n            start = val;\n            end = maxVal;\n        }\n\n        listIndices[listIdx]++;\n        if (listIndices[listIdx] < nums[listIdx].length) {\n            const newVal = nums[listIdx][listIndices[listIdx]];\n            minHeap.push([newVal, listIdx]);\n            minHeap.sort(([a], [b]) => a - b);\n            maxVal = Math.max(maxVal, newVal);\n        }\n    }\n\n    return [start, end];\n}\n",
            "explanation": "1. The algorithm starts by initializing a min heap, listIndices, maxVal, and the range [start, end]. \n2. Then, for each list in nums, we add the first element and its index into the min heap and update maxVal when necessary. Meanwhile, we fill listIndices with zeros.\n3. We loop as long as min heap size is equal to the number of lists. Within the loop:\n   a. We get the smallest value and its list index from the min heap.\n   b. If it produces a smaller range, we update the range [start, end].\n   c. We increment the relevant list index and update the current value when necessary.\n   d. We push the newVal along with its listIdx into the min heap and update maxVal if needed.\n4. Finally, the updated range is returned.\n\n "
        },
        "structure": {
            "c++": "#include <vector>\n#include <queue>\n#include <limits>\n#include <utility>\n\nstd::pair<int, int> smallestRange(std::vector<std::vector<int>>& nums) \n    // Your code here\n}\n",
            "java": "import java.util.PriorityQueue;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Comparator;\n\npublic int[] smallestRange(List<List<Integer>> nums) \n    // Your code here\n}\n",
            "python": "import heapq\n    # Your code here\n\n",
            "javascript": "function smallestRange(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <queue>\n#include <limits>\n#include <utility>\n\nstd::pair<int, int> smallestRange(std::vector<std::vector<int>>& nums) {\n    auto listComparator = [](const auto& a, const auto& b) {\n        return a.first > b.first;\n    };\n\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, decltype(listComparator)> minHeap(listComparator);\n\n    int maxVal = std::numeric_limits<int>::min();\n    for (int i = 0; i < nums.size(); i++) {\n        minHeap.push({nums[i][0], i});\n        maxVal = std::max(maxVal, nums[i][0]);\n    }\n\n    std::vector<int> listIndices(nums.size(), 0);\n    int minRange = std::numeric_limits<int>::max();\n    int start = -1, end = -1;\n\n    while (minHeap.size() == nums.size()) {\n        auto entry = minHeap.top();\n        minHeap.pop();\n        int val = entry.first;\n        int listIdx = entry.second;\n        int range = maxVal - val;\n\n        if (range < minRange) {\n            minRange = range;\n            start = val;\n            end = maxVal;\n        }\n\n        listIndices[listIdx]++;\n        if (listIndices[listIdx] < nums[listIdx].size()) {\n            int newVal = nums[listIdx][listIndices[listIdx]];\n            minHeap.push({newVal, listIdx});\n            maxVal = std::max(maxVal, newVal);\n        }\n    }\n\n    return {start, end};\n}\n\nint main() {\n    std::vector<std::vector<int>> nums = $args;\n    std::pair<int, int> result = smallestRange(nums);\n    std::cout << result.first << \" \" << result.second << std::endl;\n    return 0;\n}",
            "java": "public int[] smallestRange(List<List<Integer>> nums) {\n    PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\n\n    int maxVal = Integer.MIN_VALUE;\n    for (int i = 0; i < nums.size(); i++) {\n        minHeap.offer(new int[] {nums.get(i).get(0), i});\n        maxVal = Math.max(maxVal, nums.get(i).get(0));\n    }\n\n    List<Integer> listIndices = new ArrayList<>();\n    for (int i = 0; i < nums.size(); i++) {\n        listIndices.add(0);\n    }\n    int minRange = Integer.MAX_VALUE;\n    int start = -1, end = -1;\n\n    while (minHeap.size() == nums.size()) {\n        int[] entry = minHeap.poll();\n        int val = entry[0];\n        int listIdx = entry[1];\n        int range = maxVal - val;\n\n        if (range < minRange) {\n            minRange = range;\n            start = val;\n            end = maxVal;\n        }\n\n        listIndices.set(listIdx, listIndices.get(listIdx) + 1);\n        if (listIndices.get(listIdx) < nums.get(listIdx).size()) {\n            int newVal = nums.get(listIdx).get(listIndices.get(listIdx));\n            minHeap.offer(new int[] {newVal, listIdx});\n            maxVal = Math.max(maxVal, newVal);\n        }\n    }\n\n    return new int[] {start, end};\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = smallestRange(nums)\n    print(result)",
            "javascript": "function smallestRange(nums) {\n    const minHeap = [],\n          listIndices = Array(nums.length).fill(0);\n          \n    let maxVal = -Infinity;\n    \n    for (let i = 0; i < nums.length; i++) {\n        minHeap.push([nums[i][0], i]);\n        maxVal = Math.max(maxVal, nums[i][0]);\n    }\n    minHeap.sort(([a], [b]) => a - b);\n\n    let minRange = Infinity,\n        start = -1,\n        end = -1;\n    \n    while (minHeap.length === nums.length) {\n        const [val, listIdx] = minHeap.shift();\n        const range = maxVal - val;\n        \n        if (range < minRange) {\n            minRange = range;\n            start = val;\n            end = maxVal;\n        }\n\n        listIndices[listIdx]++;\n        if (listIndices[listIdx] < nums[listIdx].length) {\n            const newVal = nums[listIdx][listIndices[listIdx]];\n            minHeap.push([newVal, listIdx]);\n            minHeap.sort(([a], [b]) => a - b);\n            maxVal = Math.max(maxVal, newVal);\n        }\n    }\n\n    return [start, end];\n}"
        }
    },
    "633": {
        "title": "Sum of Squares",
        "description": "Given a non-negative integer `c`, decide whether there're two integers `a` and `b` such that `a2 + b2 = c`. Write a function that takes an integer `c` as input and returns `true` if there exist two integers `a` and `b` such that `a2 + b2 = c`, otherwise returns `false`.",
        "example": "Example:\n\nInput: c = 5\nOutput: true\nExplanation: 1 * 1 + 2 * 2 = 5\n\nInput: c = 3\nOutput: false",
        "level": "Easy",
        "tags": [
            "Math",
            "Number Theory"
        ],
        "test_cases": {
            "inputs": [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19
            ],
            "outputs": [
                true,
                true,
                true,
                false,
                true,
                true,
                false,
                true,
                true,
                true,
                true,
                false,
                true,
                true,
                false,
                true,
                true,
                true,
                true,
                false
            ]
        },
        "sample_code": {
            "c++": "#include <cmath>\n\nbool judgeSquareSum(int c) {\n    for (int a = 0; a <= sqrt(c); ++a) {\n        int b = sqrt(c - a * a);\n        if (a * a + b * b == c) {\n            return true;\n        }\n    }\n    return false;\n}\n",
            "java": "class Solution {\n    public boolean judgeSquareSum(int c) {\n        for (int a = 0; a <= Math.sqrt(c); ++a) {\n            int b = (int) Math.sqrt(c - a * a);\n            if (a * a + b * b == c) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n",
            "python": "def judge_square_sum(c):\n    for a in range(int(c ** 0.5) + 1):\n        b = int((c - a * a) ** 0.5)\n        if a * a + b * b == c:\n            return True\n    return False\n",
            "javascript": "function judgeSquareSum(c) {\n    for (let a = 0; a <= Math.sqrt(c); ++a) {\n        let b = Math.floor(Math.sqrt(c - a * a));\n        if (a * a + b * b === c) {\n            return true;\n        }\n    }\n    return false;\n}\n",
            "explanation": "1. Initialize a variable `a` with a value of 0.\n2. Iterate through each possible value of `a` until the square root of `c`.\n3. For each value of `a`, calculate the square root of `c - a * a`, rounding down to an integer value (using floor function).\n4. Check if a\u00c2\u00b2 + b\u00c2\u00b2 equals c, if yes, return true, indicating the existence of integers `a` and `b`.\n5. If the loop is completed without finding such pair of integers, return false."
        },
        "structure": {
            "c++": "#include <cmath>\n\nbool judgeSquareSum(int c) \n    // Your code here\n}\n",
            "java": "class Solution \n    // Your code here\n}\n",
            "python": "def judge_square_sum(c):\n    # Your code here\n\n",
            "javascript": "function judgeSquareSum(c) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <cmath>\n#include <iostream>\n\nbool judgeSquareSum(int c) {\n    for (int a = 0; a <= sqrt(c); ++a) {\n        int b = sqrt(c - a * a);\n        if (a * a + b * b == c) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    int c = $args;\n    bool result = judgeSquareSum(c);\n    cout << boolalpha << result << endl;\n    return 0;\n}"
        }
    },
    "634": {
        "title": "Number of Derangements",
        "description": "In combinatorial mathematics, a derangement is a permutation of the elements of a set, such that no element appears in its original position. You are given an integer n. There is originally an array consisting of n integers from 1 to n in ascending order. Return the number of derangements it can generate. Since the answer may be huge, return it modulo 109 + 7.",
        "example": "Example:\n\nInput: n = 3\nOutput: 2\nExplanation: The original array is [1,2,3]. The two derangements are [2,3,1] and [3,1,2].",
        "level": "Medium",
        "tags": [
            "Math",
            "Permutation"
        ],
        "test_cases": {
            "inputs": [
                3,
                4,
                5,
                6,
                10
            ],
            "outputs": [
                2,
                9,
                44,
                265,
                133496
            ]
        },
        "sample_code": {
            "c++": "int findDerangement(int n) {\n    long MOD = 1e9 + 7;\n    vector<long> dp(n + 1, 0);\n    dp[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD;\n    }\n    return (int)dp[n];\n}\n",
            "java": "public int findDerangement(int n) {\n    final int MOD = 1000000007;\n    long[] dp = new long[n + 1];\n    dp[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD;\n    }\n    return (int)dp[n];\n}\n",
            "python": "def findDerangement(n: int) -> int:\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[2] = 1\n    for i in range(3, n + 1):\n        dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n",
            "javascript": "function findDerangement(n) {\n    const MOD = 1000000007;\n    let dp = new Array(n + 1).fill(0);\n    dp[2] = 1;\n    for (let i = 3; i <= n; ++i) {\n        dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD;\n    }\n    return dp[n];\n}\n",
            "explanation": "To find the number of derangements, we can use the mathematical formula:\n\n    D(n) = (n - 1) * [D(n - 1) + D(n - 2)]\n\nHere, `D(n)` represents the number of derangements of length `n`. The base cases are D(1) = 0 and D(2) = 1.\n\nWe initialize a dynamic programming (DP) array `dp` where `dp[i]` represents the number of derangements of i elements.\n\nThe algorithm goes as follows:\n\n1. Start a for-loop (for C++/Java: i = 3, for Python/JavaScript: i = range(3, n + 1))\n2. For each value of i, calculate `dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD`\n3. Return the value of `dp[n]` as the final answer.\n\nThe result will be the number of derangements with elements up to n."
        },
        "structure": {
            "c++": "int findDerangement(int n) \n    // Your code here\n}\n",
            "java": "public int findDerangement(int n) \n    // Your code here\n}\n",
            "python": "def findDerangement(n: int) -> int:\n    # Your code here\n\n",
            "javascript": "function findDerangement(n) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = findDerangement(n);\n    cout << result << endl;\n    return 0;\n}"
        }
    },
    "636": {
        "title": "Exclusive Time of Functions",
        "description": "You are given a list of logs representing function calls in a single-threaded CPU program. Each log contains the function ID, whether it started or ended, and the timestamp. Your task is to calculate the exclusive time of each function, which is the sum of execution times for all function calls in the program.",
        "example": "Example 1:\n\nInput: n = 2, logs = [\"0:start:0 \", \"1:start:2 \", \"1:end:5 \", \"0:end:6 \"]\nOutput: [3,4]\nExplanation: Function 0 starts at time 0 and ends at time 6, with a total execution time of 6 - 0 = 6. Function 1 starts at time 2 and ends at time 5, with a total execution time of 5 - 2 = 3. Therefore, the exclusive time for function 0 is 6 - 3 = 3, and the exclusive time for function 1 is 3.",
        "level": "Medium",
        "tags": [
            "stack",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    [
                        "0:start:0 ",
                        "1:start:2 ",
                        "1:end:5 ",
                        "0:end:6 "
                    ]
                ],
                [
                    1,
                    [
                        "0:start:0 ",
                        "0:start:2 ",
                        "0:end:5 ",
                        "0:start:6 ",
                        "0:end:6 ",
                        "0:end:7 "
                    ]
                ],
                [
                    2,
                    [
                        "0:start:0 ",
                        "0:start:2 ",
                        "0:end:5 ",
                        "1:start:6 ",
                        "1:end:6 ",
                        "0:end:7 "
                    ]
                ],
                [
                    3,
                    [
                        "0:start:0 ",
                        "1:start:2 ",
                        "2:start:3 ",
                        "2:end:4 ",
                        "1:end:5 ",
                        "0:end:6 "
                    ]
                ],
                [
                    4,
                    [
                        "0:start:0 ",
                        "1:start:2 ",
                        "2:start:3 ",
                        "3:start:4 ",
                        "3:end:5 ",
                        "2:end:6 ",
                        "1:end:7 ",
                        "0:end:8 "
                    ]
                ],
                [
                    5,
                    [
                        "0:start:0 ",
                        "1:start:2 ",
                        "2:start:3 ",
                        "3:start:4 ",
                        "4:start:5 ",
                        "4:end:6 ",
                        "3:end:7 ",
                        "2:end:8 ",
                        "1:end:9 ",
                        "0:end:10 "
                    ]
                ],
                [
                    1,
                    [
                        "0:start:0 ",
                        "0:end:1 "
                    ]
                ],
                [
                    2,
                    [
                        "0:start:0 ",
                        "1:start:1 ",
                        "1:end:2 ",
                        "0:end:3 "
                    ]
                ],
                [
                    3,
                    [
                        "0:start:0 ",
                        "1:start:1 ",
                        "2:start:2 ",
                        "2:end:3 ",
                        "1:end:4 ",
                        "0:end:5 "
                    ]
                ],
                [
                    4,
                    [
                        "0:start:0 ",
                        "1:start:1 ",
                        "2:start:2 ",
                        "3:start:3 ",
                        "3:end:4 ",
                        "2:end:5 ",
                        "1:end:6 ",
                        "0:end:7 "
                    ]
                ],
                [
                    5,
                    [
                        "0:start:0 ",
                        "1:start:1 ",
                        "2:start:2 ",
                        "3:start:3 ",
                        "4:start:4 ",
                        "4:end:5 ",
                        "3:end:6 ",
                        "2:end:7 ",
                        "1:end:8 ",
                        "0:end:9 "
                    ]
                ],
                [
                    10,
                    [
                        "0:start:0 ",
                        "1:start:1 ",
                        "2:start:2 ",
                        "3:start:3 ",
                        "4:start:4 ",
                        "5:start:5 ",
                        "6:start:6 ",
                        "7:start:7 ",
                        "8:start:8 ",
                        "9:start:9 ",
                        "9:end:10 ",
                        "8:end:11 ",
                        "7:end:12 ",
                        "6:end:13 ",
                        "5:end:14 ",
                        "4:end:15 ",
                        "3:end:16 ",
                        "2:end:17 ",
                        "1:end:18 ",
                        "0:end:19 "
                    ]
                ],
                [
                    20,
                    [
                        "0:start:0 ",
                        "1:start:1 ",
                        "2:start:2 ",
                        "3:start:3 ",
                        "4:start:4 ",
                        "5:start:5 ",
                        "6:start:6 ",
                        "7:start:7 ",
                        "8:start:8 ",
                        "9:start:9 ",
                        "10:start:10 ",
                        "11:start:11 ",
                        "12:start:12 ",
                        "13:start:13 ",
                        "14:start:14 ",
                        "15:start:15 ",
                        "16:start:16 ",
                        "17:start:17 ",
                        "18:start:18 ",
                        "19:start:19 ",
                        "19:end:20 ",
                        "18:end:21 ",
                        "17:end:22 ",
                        "16:end:23 ",
                        "15:end:24 ",
                        "14:end:25 ",
                        "13:end:26 ",
                        "12:end:27 ",
                        "11:end:28 ",
                        "10:end:29 ",
                        "9:end:30 ",
                        "8:end:31 ",
                        "7:end:32 ",
                        "6:end:33 ",
                        "5:end:34 ",
                        "4:end:35 ",
                        "3:end:36 ",
                        "2:end:37 ",
                        "1:end:38 ",
                        "0:end:39 "
                    ]
                ]
            ],
            "outputs": [
                [
                    3,
                    4
                ],
                [
                    8
                ],
                [
                    7,
                    1
                ],
                [
                    7,
                    1,
                    1
                ],
                [
                    9,
                    2,
                    2,
                    1
                ],
                [
                    11,
                    3,
                    3,
                    2,
                    1
                ],
                [
                    1
                ],
                [
                    2,
                    1
                ],
                [
                    3,
                    2,
                    1
                ],
                [
                    4,
                    3,
                    2,
                    1
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    39,
                    38,
                    37,
                    36,
                    35,
                    34,
                    33,
                    32,
                    31,
                    30,
                    29,
                    28,
                    27,
                    26,
                    25,
                    24,
                    23,
                    22,
                    21,
                    20
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <stack>\n\nstd::vector<int> exclusiveTime(int n, std::vector<std::string>& logs) {\n    std::vector<int> res(n, 0);\n    std::stack<int> s;\n    int prev_time = 0;\n    \n    for (const auto& log : logs) {\n        auto colon1 = log.find(':');\n        auto colon2 = log.rfind(':');\n        \n        int id = std::stoi(log.substr(0, colon1));\n        std::string type = log.substr(colon1 + 1, colon2 - colon1 - 1);\n        int time = std::stoi(log.substr(colon2 + 1));\n        \n        if (type == \"start\") {\n            if (!s.empty()) {\n                res[s.top()] += time - prev_time;\n            }\n            s.push(id);\n            prev_time = time;\n        } else {\n            res[s.top()] += time - prev_time + 1;\n            s.pop();\n            prev_time = time + 1;\n        }\n    }\n    \n    return res;\n}\n",
            "java": "import java.util.List;\nimport java.util.Stack;\n\npublic int[] exclusiveTime(int n, List<String> logs) {\n    int[] res = new int[n];\n    Stack<Integer> stack = new Stack<>();\n    int prevTime = 0;\n\n    for (String log : logs) {\n        String[] parts = log.split(\":\");\n        int id = Integer.parseInt(parts[0]);\n        String type = parts[1];\n        int time = Integer.parseInt(parts[2]);\n\n        if (type.equals(\"start\")) {\n            if (!stack.isEmpty()) {\n                res[stack.peek()] += time - prevTime;\n            }\n            stack.push(id);\n            prevTime = time;\n        } else {\n            res[stack.pop()] += time - prevTime + 1;\n            prevTime = time + 1;\n        }\n    }\n\n    return res;\n}\n",
            "python": "def exclusiveTime(n, logs):\n    res = [0] * n\n    stack = []\n    prev_time = 0\n\n    for log in logs:\n        parts = log.split(':')\n        id = int(parts[0])\n        type = parts[1]\n        time = int(parts[2])\n\n        if type == \"start\":\n            if stack:\n                res[stack[-1]] += time - prev_time\n            stack.append(id)\n            prev_time = time\n        else:\n            res[stack.pop()] += time - prev_time + 1\n            prev_time = time + 1\n\n    return res\n",
            "javascript": "function exclusiveTime(n, logs) {\n    const res = new Array(n).fill(0);\n    const stack = [];\n    let prevTime = 0;\n\n    for (const log of logs) {\n        const parts = log.split(':');\n        const id = parseInt(parts[0]);\n        const type = parts[1];\n        const time = parseInt(parts[2]);\n\n        if (type === \"start\") {\n            if (stack.length > 0) {\n                res[stack[stack.length - 1]] += time - prevTime;\n            }\n            stack.push(id);\n            prevTime = time;\n        } else {\n            res[stack.pop()] += time - prevTime + 1;\n            prevTime = time + 1;\n        }\n    }\n\n    return res;\n}\n",
            "explanation": "The algorithm uses a stack to keep track of the active function calls. We iterate through the logs and parse each log to obtain the `id`, `type`, and `timestamp`. \n\nIf the current log type is \"start\", we check if the stack is not empty, and if so, we update the result entry for the function at the top of the stack by adding the time elapsed since the previous timestamp, `time - prev_time`. Then we push the new function's ID onto the stack and update the `prev_time` to the current `time`.\n\nIf the current log type is \"end\", we update the result entry for the function at the top of the stack by adding the time elapsed plus one, `time - prev_time + 1`. Then we pop the function's ID off the stack and update the `prev_time` to `time + 1`.\n\nAfter processing all logs, the result array contains the exclusive time for each function."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <stack>\n\nstd::vector<int> exclusiveTime(int n, std::vector<std::string>& logs) \n    // Your code here\n}\n",
            "java": "import java.util.List;\nimport java.util.Stack;\n\npublic int[] exclusiveTime(int n, List<String> logs) \n    // Your code here\n}\n",
            "python": "def exclusiveTime(n, logs):\n    # Your code here\n\n",
            "javascript": "function exclusiveTime(n, logs) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <stack>\n\nint main() {\n    int n = $args;\n    std::vector<std::string> logs;\n    std::vector<int> result = exclusiveTime(n, logs);\n    for (const auto& res : result) {\n        std::cout << res << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}",
            "java": "public int[] exclusiveTime(int n, List<String> logs) {\n    int[] res = new int[n];\n    Stack<Integer> stack = new Stack<>();\n    int prevTime = 0;\n\n    for (String log : logs) {\n        String[] parts = log.split(\":\");\n        int id = Integer.parseInt(parts[0]);\n        String type = parts[1];\n        int time = Integer.parseInt(parts[2]);\n\n        if (type.equals(\"start\")) {\n            if (!stack.isEmpty()) {\n                res[stack.peek()] += time - prevTime;\n            }\n            stack.push(id);\n            prevTime = time;\n        } else {\n            res[stack.pop()] += time - prevTime + 1;\n            prevTime = time + 1;\n        }\n    }\n\n    return res;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    logs = $args[1]\n    result = exclusiveTime(n, logs)\n    print(result)",
            "javascript": "function exclusiveTime(n, logs) {\n    const res = new Array(n).fill(0);\n    const stack = [];\n    let prevTime = 0;\n\n    for (const log of logs) {\n        const parts = log.split(':');\n        const id = parseInt(parts[0]);\n        const type = parts[1];\n        const time = parseInt(parts[2]);\n\n        if (type === \"start\") {\n            if (stack.length > 0) {\n                res[stack[stack.length - 1]] += time - prevTime;\n            }\n            stack.push(id);\n            prevTime = time;\n        } else {\n            res[stack.pop()] += time - prevTime + 1;\n            prevTime = time + 1;\n        }\n    }\n\n    return res;\n}"
        }
    },
    "640": {
        "title": "Solving Linear Equations",
        "description": "Given a linear equation in the form of a string, solve the equation and return the value of 'x' in the form of a string 'x=#value'. The equation contains only '+' and '-' operations, the variable 'x', and its coefficient. If there is no solution for the equation, return 'No solution'. If there are infinite solutions for the equation, return 'Infinite solutions'. If there is exactly one solution for the equation, we ensure that the value of 'x' is an integer.",
        "example": "Example:\n\nInput: equation = \"x+5-3+x=6+x-2\"\nOutput: \"x=2\"\n\nInput: equation = \"x=x\"\nOutput: \"Infinite solutions\"\n\nInput: equation = \"2x=x\"\nOutput: \"x=0\"",
        "level": "Medium",
        "tags": [
            "math",
            "equation-solving"
        ],
        "test_cases": {
            "inputs": [
                "\"x+5-3+x=6+x-2\"",
                "\"x=x\"",
                "\"2x=x\"",
                "\"3x+2=2x+3\"",
                "\"4x-5=3x+2\"",
                "\"x+2=3x-4\"",
                "\"2x-3=4x+5\"",
                "\"5x+7=3x-2\"",
                "\"-x+5=2x-3\"",
                "\"-2x-3=-4x+5\"",
                "\"-3x+2=-2x+3\"",
                "\"-4x-5=-3x+2\"",
                "\"-x+2=-3x-4\"",
                "\"-2x+3=-4x-5\"",
                "\"-5x+7=-3x-2\"",
                "\"x+5=2x-3\"",
                "\"2x-3=4x-5\"",
                "\"3x+2=2x-3\"",
                "\"4x-5=3x-2\"",
                "\"5x+7=3x+2\""
            ],
            "outputs": [
                "\"x=2\"",
                "\"Infinite solutions\"",
                "\"x=0\"",
                "\"x=1\"",
                "\"x=7\"",
                "\"x=3\"",
                "\"x=-4\"",
                "\"x=-3\"",
                "\"x=4\"",
                "\"x=2\"",
                "\"x=1\"",
                "\"x=-2\"",
                "\"x=-3\"",
                "\"x=4\"",
                "\"x=-2\"",
                "\"x=8\"",
                "\"x=-4\"",
                "\"x=-1\"",
                "\"x=2\"",
                "\"x=5\""
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <sstream>\nusing namespace std;\n\nstring solveEquation(string equation) {\n    int coef = 0, val = 0, left = 1, operate = 1;\n    istringstream in(equation + \"+\");\n    char op;\n    int n;\n    string s;\n    while (in >> op) {\n        if (op == '=') {\n            left = -1;\n            operate = 1;\n        } else {\n            in >> n >> s;\n            (s.size() == 0 ? val : coef) += (op == '+' ? 1 : -1) * left * operate * n;\n            operate = s.size();\n        }\n    }\n\n    if (coef == 0) {\n        return val == 0 ? \"Infinite solutions\" : \"No solution\";\n    } else {\n        return \"x=\" + to_string(-val / coef);\n    }\n}\n\n",
            "java": "public String solveEquation(String equation) {\n    int coefficient = 0, value = 0, left = 1, operator = 1;\n    String[] parts = (equation + \"+\").split(\"(?<=[+-])\");\n    for (String part : parts) {\n        if (part.equals(\"=\")) {\n            left = -1;\n            operator = 1;\n        } else {\n            String[] nums = part.split(\"x\");\n            int n = Integer.parseInt(nums[0]);\n            (nums.length == 1 ? value : coefficient) += left * operator * n;\n            operator = nums.length;\n        }\n    }\n\n    if (coefficient == 0) {\n        return value == 0 ? \"Infinite solutions\" : \"No solution\";\n    }\n    return \"x=\" + -value / coefficient;\n}\n\n",
            "python": "def solve_equation(equation: str) -> str:\n    coef = val = left = operate = 0\n    equation += '+'\n    parts = [s.strip()+c for c in equation if c in '+-' for s in equation.split(c)]\n    for part in parts:\n        if part == '=':\n            left = -1\n            operate = 1\n        else:\n            n, x = part.split('x')\n            value_to_change = 1 if n else int(n)\n            if x:\n                coef += (1 if part[0] == '+' else -1) * left * operate * value_to_change\n            else:\n                val += (1 if part[0] == '+' else -1) * left * operate * value_to_change\n            operate = 1 - x.find('x')\n\n    if coef == 0:\n        return \"Infinite solutions\" if val == 0 else \"No solution\"\n    return \"x=\" + str(-val // coef)\n\n",
            "javascript": "function solveEquation(equation) {\n    let coef = 0, val = 0, left = 1, operate = 1;\n    let parts = equation.replace(/([+-])/g, ' $1').split('=');\n    let leftPart = parts[0].split(' ');\n    let rightPart = parts[1].split(' ');\n\n    for (let part of leftPart.concat(rightPart)) {\n        if (part === '+') {\n            operate = 1;\n        } else if (part === '-') {\n            operate = -1;\n        } else if (part.includes('x')) {\n            coef += parseInt(part.replace('x', '') || '1', 10) * operate * left;\n        } else {\n            val += parseInt(part, 10) * operate * left;\n        }\n    }\n\n    if (coef === 0) {\n        return val === 0 ? \"Infinite solutions\" : \"No solution\";\n    } else {\n        return \"x=\" + (-val / coef).toString();\n    }\n}\n\n",
            "explanation": "The algorithm used to solve this problem is based on processing the given equation as a string and having separate variables to track the coefficients for both 'x' and the values separately.\n\n1. Initialize variables to track coefficients (`coef`), values (`val`), position (`left`), and operation (`operate`).\n2. Iterate through the equation, updating position and operation when encountering a `=\"+` or `\"=\"`. Otherwise, separate the terms involving x and the constant values, updating their coefficients accordingly.\n3. After processing the equation, check if the coefficient for x is 0.\n   - If yes, return \"Infinite solutions\" if the value is also 0; otherwise, return \"No solution\".\n   - If no, divide the value by the coefficient and return the result as \"x=#value\".\n\nNote that the function for each language has some differences in parsing the input string and managing the internal data as needed but follows the same strategy throughout."
        },
        "structure": {
            "c++": "#include <string>\n#include <sstream>\nusing namespace std;\n\nstring solveEquation(string equation) \n    // Your code here\n}\n\n",
            "java": "public String solveEquation(String equation) \n    // Your code here\n}\n\n",
            "python": "def solve_equation(equation: str) -> str:\n    # Your code here\n\n",
            "javascript": "function solveEquation(equation) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <sstream>\nusing namespace std;\n\nint main() {\n    string equation = $args;\n    string result = solveEquation(equation);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public String solveEquation(String equation) {\n    int coefficient = 0, value = 0, left = 1, operator = 1;\n    String[] parts = (equation + \"+\").split(\"(?<=[+-])\");\n    for (String part : parts) {\n        if (part.equals(\"=\")) {\n            left = -1;\n            operator = 1;\n        } else {\n            String[] nums = part.split(\"x\");\n            int n = Integer.parseInt(nums[0]);\n            (nums.length == 1 ? value : coefficient) += left * operator * n;\n            operator = nums.length;\n        }\n    }\n\n    if (coefficient == 0) {\n        return value == 0 ? \"Infinite solutions\" : \"No solution\";\n    }\n    return \"x=\" + -value / coefficient;\n}",
            "python": "if __name__ == \"__main__\":\n    equation = $args[0]\n    result = solve_equation(equation)\n    print(result)",
            "javascript": "function main() {\n    const equation = $args;\n    const result = solveEquation(equation);\n    console.log(result);\n}"
        }
    },
    "642": {
        "title": "Search Autocomplete System",
        "description": "Design a search autocomplete system for a search engine. Users may input a sentence (at least one word and end with a special character `'#'`). You are given a string array `sentences` and an integer array `times` both of length `n` where `sentences[i]` is a previously typed sentence and `times[i]` is the corresponding number of times the sentence was typed. For each input character except `'#'`, return the top `3` historical hot sentences that have the same prefix as the part of the sentence already typed. The hot degree for a sentence is defined as the number of times a user typed the exactly same sentence before. The returned top `3` hot sentences should be sorted by hot degree (The first is the hottest one). If several sentences have the same hot degree, use ASCII-code order (smaller one appears first). If less than `3` hot sentences exist, return as many as you can. When the input is a special character, it means the sentence ends, and in this case, you need to return an empty list.",
        "example": "Example:\n\nInput:\n[\"AutocompleteSystem \", \"input \", \"input \", \"input \", \"input \"]\n[[[\"i love you \", \"island \", \"iroman \", \"i love leetcode \"], [5, 3, 2, 2]], [\"i \"], [\"  \"], [\"a \"], [\"# \"]]\nOutput:\n[null, [\"i love you \", \"island \", \"i love leetcode \"], [\"i love you \", \"i love leetcode \"], [], []]\n\nExplanation:\nAutocompleteSystem obj = new AutocompleteSystem([\"i love you \", \"island \", \"iroman \", \"i love leetcode \"], [5, 3, 2, 2]);\nobj.input(\"i \"); // return [\"i love you \", \"island \", \"i love leetcode \"]. There are four sentences that have prefix \"i \". Among them, \"ironman \" and \"i love leetcode \" have the same hot degree. Since ' ' has ASCII code 32 and 'r' has ASCII code 114, \"i love leetcode \" should be in front of \"ironman \". Also, we only need to output the top 3 hot sentences, so \"ironman \" will be ignored.\nobj.input(\"  \"); // return [\"i love you \", \"i love leetcode \"]. There are only two sentences that have prefix \"i  \".\nobj.input(\"a \"); // return []. There are no sentences that have prefix \"i a \".\nobj.input(\"# \"); // return []. The user finished the input, the sentence \"i a \" should be saved as a historical sentence in the system. And the following input will be counted as a new search.",
        "level": "Medium",
        "tags": [
            "Design",
            "Trie",
            "Sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    "AutocompleteSystem ",
                    "input ",
                    "input ",
                    "input ",
                    "input "
                ],
                [
                    [
                        [
                            "i love you ",
                            "island ",
                            "iroman ",
                            "i love leetcode "
                        ],
                        [
                            5,
                            3,
                            2,
                            2
                        ]
                    ],
                    [
                        "i "
                    ],
                    [
                        "  "
                    ],
                    [
                        "a "
                    ],
                    [
                        "# "
                    ]
                ],
                [
                    [
                        "hello world ",
                        "hello there ",
                        "hello everyone ",
                        "hello world again "
                    ],
                    [
                        3,
                        2,
                        1,
                        1
                    ]
                ],
                [
                    [
                        "apple ",
                        "app ",
                        "application ",
                        "applesauce "
                    ],
                    [
                        5,
                        3,
                        2,
                        2
                    ]
                ],
                [
                    [
                        "cat ",
                        "car ",
                        "cartoon ",
                        "catnip "
                    ],
                    [
                        4,
                        3,
                        2,
                        2
                    ]
                ],
                [
                    [
                        "programming ",
                        "program ",
                        "programmer ",
                        "programmatic "
                    ],
                    [
                        5,
                        3,
                        2,
                        2
                    ]
                ],
                [
                    [
                        "python ",
                        "java ",
                        "javascript ",
                        "ruby "
                    ],
                    [
                        5,
                        3,
                        2,
                        2
                    ]
                ],
                [
                    [
                        "coding ",
                        "code ",
                        "coder ",
                        "codec "
                    ],
                    [
                        5,
                        3,
                        2,
                        2
                    ]
                ],
                [
                    [
                        "algorithm ",
                        "data structure ",
                        "sorting ",
                        "searching "
                    ],
                    [
                        5,
                        3,
                        2,
                        2
                    ]
                ],
                [
                    [
                        "leetcode ",
                        "interview ",
                        "problem ",
                        "solution "
                    ],
                    [
                        5,
                        3,
                        2,
                        2
                    ]
                ],
                [
                    [
                        "computer ",
                        "laptop ",
                        "desktop ",
                        "keyboard "
                    ],
                    [
                        5,
                        3,
                        2,
                        2
                    ]
                ],
                [
                    [
                        "network ",
                        "router ",
                        "switch ",
                        "firewall "
                    ],
                    [
                        5,
                        3,
                        2,
                        2
                    ]
                ],
                [
                    [
                        "database ",
                        "sql ",
                        "mysql ",
                        "mongodb "
                    ],
                    [
                        5,
                        3,
                        2,
                        2
                    ]
                ],
                [
                    [
                        "web ",
                        "html ",
                        "css ",
                        "javascript "
                    ],
                    [
                        5,
                        3,
                        2,
                        2
                    ]
                ],
                [
                    [
                        "server ",
                        "client ",
                        "request ",
                        "response "
                    ],
                    [
                        5,
                        3,
                        2,
                        2
                    ]
                ],
                [
                    [
                        "programming language ",
                        "compiler ",
                        "interpreter ",
                        "runtime "
                    ],
                    [
                        5,
                        3,
                        2,
                        2
                    ]
                ],
                [
                    [
                        "operating system ",
                        "kernel ",
                        "process ",
                        "memory "
                    ],
                    [
                        5,
                        3,
                        2,
                        2
                    ]
                ],
                [
                    [
                        "machine learning ",
                        "artificial intelligence ",
                        "neural network ",
                        "deep learning "
                    ],
                    [
                        5,
                        3,
                        2,
                        2
                    ]
                ],
                [
                    [
                        "data science ",
                        "big data ",
                        "data analysis ",
                        "data visualization "
                    ],
                    [
                        5,
                        3,
                        2,
                        2
                    ]
                ],
                [
                    [
                        "cloud computing ",
                        "virtualization ",
                        "containerization ",
                        "microservices "
                    ],
                    [
                        5,
                        3,
                        2,
                        2
                    ]
                ],
                [
                    [
                        "agile ",
                        "scrum ",
                        "kanban ",
                        "lean "
                    ],
                    [
                        5,
                        3,
                        2,
                        2
                    ]
                ]
            ],
            "outputs": [
                "null",
                "[\"i love you \", \"island \", \"i love leetcode \"]",
                "[\"hello world \", \"hello there \", \"hello everyone \"]",
                "[\"apple \", \"app \", \"application \"]",
                "[\"cat \", \"car \", \"cartoon \"]",
                "[\"programming \", \"program \", \"programmer \"]",
                "[\"python \", \"java \", \"javascript \"]",
                "[\"coding \", \"code \", \"coder \"]",
                "[\"algorithm \", \"data structure \", \"sorting \"]",
                "[\"leetcode \", \"interview \", \"problem \"]",
                "[\"computer \", \"laptop \", \"desktop \"]",
                "[\"network \", \"router \", \"switch \"]",
                "[\"database \", \"sql \", \"mysql \"]",
                "[\"web \", \"html \", \"css \"]",
                "[\"server \", \"client \", \"request \"]",
                "[\"programming language \", \"compiler \", \"interpreter \"]",
                "[\"operating system \", \"kernel \", \"process \"]",
                "[\"machine learning \", \"artificial intelligence \", \"neural network \"]",
                "[\"data science \", \"big data \", \"data analysis \"]",
                "[\"cloud computing \", \"virtualization \", \"containerization \"]",
                "[\"agile \", \"scrum \", \"kanban \"]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n#include <queue>\n\nclass AutocompleteSystem {\n    struct TrieNode {\n        std::unordered_map<char, TrieNode*> children;\n        std::string sentence;\n        int times;\n        TrieNode() : times(0) {}\n    };\n\n    void insert(const std::string &sentence, int times) {\n        TrieNode *curr = root;\n        for (char c : sentence) {\n            if (!curr->children[c]) {\n                curr->children[c] = new TrieNode();\n            }\n            curr = curr->children[c];\n        }\n        curr->times += times;\n        curr->sentence = sentence;\n    }\n\n    struct cmp {\n        bool operator()(const TrieNode* a, const TrieNode* b) const {\n            if (a->times == b->times) {\n                return a->sentence > b->sentence;\n            }\n            return a->times < b->times;\n        }\n    };\n\n    TrieNode *root;\n    TrieNode *current;\n    std::string search;\n\npublic:\n    AutocompleteSystem(std::vector<std::string>& sentences, std::vector<int>& times) {\n        root = new TrieNode();\n        for (int i = 0; i < sentences.size(); ++i) {\n            insert(sentences[i], times[i]);\n        }\n        current = root;\n    }\n    \n    std::vector<std::string> input(char c) {\n        if (c == '#') {\n            insert(search, 1);\n            search = \"\";\n            current = root;\n            return {};\n        }\n        search += c;\n        if (!current) {\n            return {};\n        }\n        current = current->children[c];\n        if (!current) {\n            return {};\n        }\n        std::priority_queue<TrieNode*, std::vector<TrieNode*>, cmp> pq;\n        for (auto &[char_, node] : current->children) {\n            if (node->times) {\n                pq.push(node);\n            }\n        }\n        \n        std::vector<std::string> res;\n        while (!pq.empty() && res.size() < 3) {\n            res.push_back(pq.top()->sentence);\n            pq.pop();\n        }\n        return res;\n    }\n};\n\n",
            "java": "import java.util.*;\n\nclass AutocompleteSystem {\n    class TrieNode {\n        HashMap<Character, TrieNode> children = new HashMap<>();\n        String sentence;\n        int times;\n\n        TrieNode() {\n            sentence = null;\n            times = 0;\n        }\n    }\n\n    private void insert(String sentence, int times) {\n        TrieNode curr = root;\n        for (char c : sentence.toCharArray()) {\n            curr.children.putIfAbsent(c, new TrieNode());\n            curr = curr.children.get(c);\n        }\n        curr.sentence = sentence;\n        curr.times += times;\n    }\n\n    private class NodeComparator implements Comparator<TrieNode> {\n        public int compare(TrieNode a, TrieNode b) {\n            if (a.times == b.times) {\n                return a.sentence.compareTo(b.sentence);\n            }\n            return b.times - a.times;\n        }\n    }\n\n    TrieNode root, curr;\n    String search;\n\n    public AutocompleteSystem(String[] sentences, int[] times) {\n        root = new TrieNode();\n        curr = root;\n        search = \"\";\n        for (int i = 0; i < sentences.length; ++i) {\n            insert(sentences[i], times[i]);\n        }\n    }\n    \n    public List<String> input(char c) {\n        List<String> res = new ArrayList<>();\n        if (c == '#') {\n            insert(search, 1);\n            search = \"\";\n            curr = root;\n            return res;\n        }\n        search += c;\n        if (!curr.children.containsKey(c)) {\n            curr = null;\n            return res;\n        }\n        curr = curr.children.get(c);\n        PriorityQueue<TrieNode> pq = new PriorityQueue<>(new NodeComparator());\n        for (TrieNode node : curr.children.values()) {\n            if (node.times > 0) {\n                pq.add(node);\n            }\n        }\n        while (!pq.isEmpty() && res.size() < 3) {\n            res.add(pq.poll().sentence);\n        }\n        return res;\n    }\n}\n\n",
            "python": "from typing import List\nimport heapq\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.sentence = \"\"\n        self.times = 0\n\nclass AutocompleteSystem:\n\n    def __init__(self, sentences: List[str], times: List[int]):\n        self.root = TrieNode()\n        self.current = self.root\n        self.search = \"\"\n        \n        for i in range(len(sentences)):\n            self.insert(sentences[i], times[i])\n\n    def insert(self, sentence: str, times: int):\n        curr = self.root\n        for c in sentence:\n            if c not in curr.children:\n                curr.children[c] = TrieNode()\n            curr = curr.children[c]\n        curr.sentence = sentence\n        curr.times += times\n\n    def input(self, c: str) -> List[str]:\n        if c == '#':\n            self.insert(self.search, 1)\n            self.search = \"\"\n            self.current = self.root\n            return []\n        \n        self.search += c\n        if not self.current:\n            return []\n        \n        if c not in self.current.children:\n            self.current = None\n            return []\n        \n        self.current = self.current.children[c]\n        heap = []\n        for child in self.current.children.values():\n            if child.times:\n                heapq.heappush(heap, (-child.times, child.sentence))\n        \n        res = []\n        for _ in range(3):\n            if not heap:\n                break\n            res.append(heapq.heappop(heap)[1])\n        return res\n\n",
            "javascript": "class TrieNode {\n    constructor() {\n        this.children = {};\n        this.sentence = \"\";\n        this.times = 0;\n    }\n}\n\nclass AutocompleteSystem {\n    constructor(sentences, times) {\n        this.root = new TrieNode();\n        this.current = this.root;\n        this.search = \"\";\n        \n        for (let i = 0; i < sentences.length; ++i) {\n            this.insert(sentences[i], times[i]);\n        }\n    }\n    \n    insert(sentence, times) {\n        let curr = this.root;\n        for (let c of sentence) {\n            if (!curr.children[c]) {\n                curr.children[c] = new TrieNode();\n            }\n            curr = curr.children[c];\n        }\n        curr.sentence = sentence;\n        curr.times += times;\n    }\n    \n    input(c) {\n        if (c === '#') {\n            this.insert(this.search, 1);\n            this.search = \"\";\n            this.current = this.root;\n            return [];\n        }\n        \n        this.search += c;\n        if (!this.current) {\n            return [];\n        }\n        \n        if (!this.current.children[c]) {\n            this.current = null;\n            return [];\n        }\n        \n        this.current = this.current.children[c];\n        const heap = [];\n        for (let node of Object.values(this.current.children)) {\n            if (node.times) {\n                heap.push([node]);\n            }\n        }\n        \n        heap.sort((a, b) => {\n            if (a.times === b.times) {\n                return a.sentence.localeCompare(b.sentence);\n            }\n            return b.times - a.times;\n        });\n        \n        const res = [];\n        for (let i = 0; i < 3 && i < heap.length; ++i) {\n            res.push(heap[i].sentence);\n        }\n        return res;\n    }\n}\n\n",
            "explanation": "The algorithm implemented is a trie-based solution. The `AutocompleteSystem` class has a TrieNode structure and methods to insert sentences into the trie, as well as to find and return the top 3 historical hot sentences.\n\nThe TrieNode structure has a `children` dictionary that stores the characters and their child TrieNode references, a sentence attribute to store the sentence corresponding to the node (if it is the end of a sentence), and a times attribute to store the hot degree of the sentence.\n\nThe `insert` method takes a sentence and times as input and inserts the sentence into the trie structure by following the appropriate path based on each character.\n\nThe `input` method processes each character in the user input to search for matching historical hot sentences. If the user input is a special character '#' it stores the inputted sentence in the system and returns an empty list. When the user input is not a special character, the `input` method finds matching historical hot sentences by traversing the trie based on the characters of the user input. A priority queue (or sorting for JavaScript) is used to prioritize and return the top 3 hot historical sentences according to their hot degree and ASCII-code order."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n#include <queue>\n\nclass AutocompleteSystem \n    // Your code here\n};\n\n",
            "java": "import java.util.*;\n\nclass AutocompleteSystem \n    // Your code here\n}\n\n",
            "python": "from typing import List\n    # Your code here\n\n",
            "javascript": "class TrieNode \n    // Your code here\n}\n\n"
        },
        "call_functions": {}
    },
    "645": {
        "title": "Duplicate and Missing Number",
        "description": "You have a set of integers `s`, which originally contains all the numbers from `1` to `n`. Unfortunately, due to some error, one of the numbers in `s` got duplicated to another number in the set, which results in **repetition of one** number and **loss of another** number.\n\nYou are given an integer array `nums` representing the data status of this set after the error.\n\nFind the number that occurs twice and the number that is missing and return them in the form of an array.",
        "example": "Example:\n\nInput: nums = [1,2,2,4]\nOutput: [2,3]\n\nInput: nums = [1,1]\nOutput: [1,2]",
        "level": "Easy",
        "tags": [
            "Array",
            "Math"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    2,
                    4
                ],
                [
                    1,
                    1,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99,
                    100
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99,
                    100,
                    1000
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99,
                    100,
                    101,
                    102,
                    103,
                    104,
                    105,
                    106,
                    107,
                    108,
                    109,
                    110,
                    111,
                    112,
                    113,
                    114,
                    115,
                    116,
                    117,
                    118,
                    119,
                    120,
                    121,
                    122,
                    123,
                    124,
                    125,
                    126,
                    127,
                    128,
                    129,
                    130,
                    131,
                    132,
                    133,
                    134,
                    135,
                    136,
                    137,
                    138,
                    139,
                    140,
                    141,
                    142,
                    143,
                    144,
                    145,
                    146,
                    147,
                    148,
                    149,
                    150,
                    151,
                    152,
                    153,
                    154,
                    155,
                    156,
                    157,
                    158,
                    159,
                    160,
                    161,
                    162,
                    163,
                    164,
                    165,
                    166,
                    167,
                    168,
                    169,
                    170,
                    171,
                    172,
                    173,
                    174,
                    175,
                    176,
                    177,
                    178,
                    179,
                    180,
                    181,
                    182,
                    183,
                    184,
                    185,
                    186,
                    187,
                    188,
                    189,
                    190,
                    191,
                    192,
                    193,
                    194,
                    195,
                    196,
                    197,
                    198,
                    199,
                    200
                ]
            ],
            "outputs": [
                [
                    2,
                    3
                ],
                [
                    1,
                    2
                ],
                [
                    10,
                    1
                ],
                [
                    100,
                    101
                ],
                [
                    100,
                    1000
                ],
                [
                    100,
                    101
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> findErrorNums(vector<int>& nums) {\n    vector<int> result;\n    for (int i = 0; i < nums.size(); i++) {\n        int index = abs(nums[i]) - 1;\n        if (nums[index] > 0) {\n            nums[index] = -nums[index];\n        } else {\n            result.push_back(index + 1);\n        }\n    }\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] > 0) {\n            result.push_back(i + 1);\n            break;\n        }\n    }\n    return result;\n}\n",
            "java": "public int[] findErrorNums(int[] nums) {\n    int[] result = new int[2];\n    for (int num : nums) {\n        int index = Math.abs(num) - 1;\n        if (nums[index] > 0) {\n            nums[index] = -nums[index];\n        } else {\n            result[0] = index + 1;\n        }\n    }\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] > 0) {\n            result[1] = i + 1;\n            break;\n        }\n    }\n    return result;\n}\n",
            "python": "def findErrorNums(nums):\n    result = []\n    for num in nums:\n        index = abs(num) - 1\n        if nums[index] > 0:\n            nums[index] = -nums[index]\n        else:\n            result.append(index + 1)\n    for i, num in enumerate(nums):\n        if num > 0:\n            result.append(i + 1)\n            break\n    return result\n",
            "javascript": "function findErrorNums(nums) {\n    let result = [];\n    for (let num of nums) {\n        let index = Math.abs(num) - 1;\n        if (nums[index] > 0) {\n            nums[index] = -nums[index];\n        } else {\n            result.push(index + 1);\n        }\n    }\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] > 0) {\n            result.push(i + 1);\n            break;\n        }\n    }\n    return result;\n}\n",
            "explanation": "1. Iterate through the given array, creating and using the index as the absolute value of the current number minus one. By doing this, we visit the indices in a specific order that allows us to mark numbers we have already visited.\n2. If the value at the index is positive, we negate it. If it's negative, it means we found the duplicate number. Store the duplicate number (index + 1) in the result array.\n3. Iterate through the array again to find the first positive value. This index plus one will be the missing number, as others should have been negated in the previous steps.\n4. Add the missing number to the result array and return it."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> findErrorNums(vector<int>& nums) \n    // Your code here\n}\n",
            "java": "public int[] findErrorNums(int[] nums) \n    // Your code here\n}\n",
            "python": "def findErrorNums(nums):\n    # Your code here\n\n",
            "javascript": "function findErrorNums(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> findErrorNums(vector<int>& nums) {\n    vector<int> result;\n    for (int i = 0; i < nums.size(); i++) {\n        int index = abs(nums[i]) - 1;\n        if (nums[index] > 0) {\n            nums[index] = -nums[index];\n        } else {\n            result.push_back(index + 1);\n        }\n    }\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] > 0) {\n            result.push_back(i + 1);\n            break;\n        }\n    }\n    return result;\n}\n\nint main() {\n    vector<int> nums = $args;\n    vector<int> result = findErrorNums(nums);\n    for (int i = 0; i < result.size(); i++) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}"
        }
    },
    "646": {
        "title": "Longest Chain of Pairs",
        "description": "You are given an array of `n` pairs `pairs` where `pairs[i] = [lefti, righti]` and `lefti < righti`. A pair `p2 = [c, d]` **follows** a pair `p1 = [a, b]` if `b < c`. A **chain** of pairs can be formed in this fashion. Return the length of the longest chain that can be formed. You do not need to use up all the given intervals. You can select pairs in any order.",
        "example": "Example:\n\nInput: pairs = [[1,2],[2,3],[3,4]]\nOutput: 2\nExplanation: The longest chain is [1,2] -> [3,4].",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ],
                    [
                        19,
                        20
                    ]
                ]
            ],
            "outputs": [
                2,
                3,
                4,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\n\nint findLongestChain(std::vector<std::vector<int>>& pairs) {\n    std::sort(pairs.begin(), pairs.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[1] < b[1];\n    });\n\n    int max_chain_length = 0, last_right = INT_MIN;\n    for (const auto& pair : pairs) {\n        if (pair[0] > last_right) {\n            last_right = pair[1];\n            max_chain_length++;\n        }\n    }\n    \n    return max_chain_length;\n}\n\n",
            "java": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic int findLongestChain(int[][] pairs) {\n    Arrays.sort(pairs, Comparator.comparingInt(a -> a[1]));\n\n    int max_chain_length = 0, last_right = Integer.MIN_VALUE;\n    for (int[] pair : pairs) {\n        if (pair[0] > last_right) {\n            last_right = pair[1];\n            max_chain_length++;\n        }\n    }\n    \n    return max_chain_length;\n}\n\n",
            "python": "def findLongestChain(pairs):\n    pairs.sort(key=lambda x: x[1])\n\n    max_chain_length = 0\n    last_right = float('-inf')\n    for pair in pairs:\n        if pair[0] > last_right:\n            last_right = pair[1]\n            max_chain_length += 1\n\n    return max_chain_length\n\n",
            "javascript": "function findLongestChain(pairs) {\n    pairs.sort((a, b) => a[1] - b[1]);\n\n    let max_chain_length = 0, last_right = Number.MIN_SAFE_INTEGER;\n    for (const pair of pairs) {\n        if (pair[0] > last_right) {\n            last_right = pair[1];\n            max_chain_length++;\n        }\n    }\n\n    return max_chain_length;\n}\n\n",
            "explanation": "The algorithm first sorts the array of pairs based on their second element. It then iterates through the pairs checking if the first element of the current pair is larger than the second element of the previous pair (i.e., if the current pair can follow the previous pair in the chain). If it can, it updates `last_right` to be the second element of the current pair and increments the max_chain_length. The time complexity of the algorithm is O(n*log(n)) due to sorting. In the worst case, it might create a chain of length n."
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\n\nint findLongestChain(std::vector<std::vector<int>>& pairs) \n    // Your code here\n}\n\n",
            "java": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic int findLongestChain(int[][] pairs) \n    // Your code here\n}\n\n",
            "python": "def findLongestChain(pairs):\n    # Your code here\n\n",
            "javascript": "function findLongestChain(pairs) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<std::vector<int>> pairs = $args;\n    int result = findLongestChain(pairs);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public int findLongestChain(int[][] pairs) {\n    Arrays.sort(pairs, Comparator.comparingInt(a -> a[1]));\n\n    int max_chain_length = 0, last_right = Integer.MIN_VALUE;\n    for (int[] pair : pairs) {\n        if (pair[0] > last_right) {\n            last_right = pair[1];\n            max_chain_length++;\n        }\n    }\n    \n    return max_chain_length;\n}",
            "python": "if __name__ == \"__main__\":\n    pairs = $args[0]\n    result = findLongestChain(pairs)\n    print(result)",
            "javascript": "function main() {\n    const pairs = $args;\n    const result = findLongestChain(pairs);\n    console.log(result);\n}"
        }
    },
    "648": {
        "title": "Replace Successors with Roots",
        "description": "Given a dictionary consisting of many roots and a sentence consisting of words separated by spaces, replace all the successors in the sentence with the root forming it. If a successor can be replaced by more than one root, replace it with the root that has the shortest length. Return the sentence after the replacement.",
        "example": "Example:\n\nInput:\n\ndictionary = [\"cat \", \"bat \", \"rat \"], sentence = \"the cattle was rattled by the battery \"\n\nOutput:\n\n\"the cat was rat by the bat \"\n\nExplanation:\n\nIn the given example, the sentence contains the successors 'cattle', 'rattled', and 'battery'. The root 'cat' can replace 'cattle', 'rat' can replace 'rattled', and 'bat' can replace 'battery'. Since 'cat' is the shortest root, it is used to replace 'cattle'. Similarly, 'rat' replaces 'rattled' and 'bat' replaces 'battery'. The final sentence after replacement is 'the cat was rat by the bat'.",
        "level": "Medium",
        "tags": [
            "string",
            "dictionary",
            "replacement"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "cat ",
                        "bat ",
                        "rat "
                    ],
                    "the cattle was rattled by the battery "
                ],
                [
                    [
                        "a ",
                        "b ",
                        "c "
                    ],
                    "aadsfasf absbs bbab cadsfafs "
                ],
                [
                    [
                        "an ",
                        "another ",
                        "and "
                    ],
                    "an apple is another fruit and an orange "
                ],
                [
                    [
                        "the ",
                        "quick ",
                        "brown ",
                        "fox "
                    ],
                    "the quick brown fox jumps over the lazy dog "
                ],
                [
                    [
                        "hello ",
                        "world ",
                        "code ",
                        "challenge "
                    ],
                    "hello world code challenge"
                ]
            ],
            "outputs": [
                "the cat was rat by the bat ",
                "a a b c ",
                "an apple is another fruit and an orange ",
                "the quick brown fox jumps over the lazy dog ",
                "hello world code challenge"
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <vector>\n#include <unordered_set>\n\nstd::string replaceWords(std::vector<std::string>& dict, std::string sentence) {\n    std::unordered_set<std::string> roots(dict.begin(), dict.end());\n    std::istringstream iss(sentence);\n    std::string word, result;\n\n    while (iss >> word) {\n        std::string prefix;\n        for (int i = 1; i <= word.length(); ++i) {\n            prefix = word.substr(0, i);\n            if (roots.count(prefix)) {\n                break;\n            }\n        }\n        result += prefix + \" \";\n    }\n    result.pop_back();\n    return result;\n}\n",
            "java": "import java.util.List;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Arrays;\n\npublic String replaceWords(List<String> dict, String sentence) {\n    Set<String> roots = new HashSet<>(dict);\n    String[] words = sentence.split(\" \");\n    StringBuilder result = new StringBuilder();\n\n    for (String word : words) {\n        String prefix = \"\";\n        for (int i = 1; i <= word.length(); ++i) {\n            prefix = word.substring(0, i);\n            if (roots.contains(prefix)) {\n                break;\n            }\n        }\n        result.append(prefix).append(\" \");\n    }\n\n    return result.toString().trim();\n}\n",
            "python": "def replaceWords(dict, sentence):\n    roots = set(dict)\n    words = sentence.split()\n    result = []\n\n    for word in words:\n        prefix = ''\n        for i in range(1, len(word) + 1):\n            prefix = word[:i]\n            if prefix in roots:\n                break\n        result.append(prefix)\n\n    return ' '.join(result)\n",
            "javascript": "function replaceWords(dict, sentence) {\n    const roots = new Set(dict);\n    const words = sentence.split(' ');\n    const result = [];\n\n    for (const word of words) {\n        let prefix = '';\n        for (let i = 1; i <= word.length; ++i) {\n            prefix = word.substring(0, i);\n            if (roots.has(prefix)) {\n                break;\n            }\n        }\n        result.push(prefix);\n    }\n\n    return result.join(' ');\n}\n",
            "explanation": "1. Create a set of roots from the given dictionary to easily look up if a word fragment is in the roots.\n2. Split the sentence into words.\n3. Iterate through each word, create a prefix variable that will keep track of the word fragment:\n   a. Start with an empty prefix.\n   b. Iterate through the characters of the word, adding one character at a time to the prefix.\n   c. Check if the prefix is in the roots set.\n   d. If a root is found, break the iteration.\n4. Add the final prefix to the result list.\n5. Join the result list into a string, separating words with spaces.\n6. Return the final result string."
        },
        "structure": {
            "c++": "#include <string>\n#include <vector>\n#include <unordered_set>\n\nstd::string replaceWords(std::vector<std::string>& dict, std::string sentence) \n    // Your code here\n}\n",
            "java": "import java.util.List;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Arrays;\n\npublic String replaceWords(List<String> dict, String sentence) \n    // Your code here\n}\n",
            "python": "def replaceWords(dict, sentence):\n    # Your code here\n\n",
            "javascript": "function replaceWords(dict, sentence) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <vector>\n#include <unordered_set>\n\nint main() {\n    std::vector<std::string> dict = $args;\n    std::string sentence = $args;\n    std::string result = replaceWords(dict, sentence);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public String replaceWords(List<String> dict, String sentence) {\n    Set<String> roots = new HashSet<>(dict);\n    String[] words = sentence.split(\" \");\n    StringBuilder result = new StringBuilder();\n\n    for (String word : words) {\n        String prefix = \"\";\n        for (int i = 1; i <= word.length(); ++i) {\n            prefix = word.substring(0, i);\n            if (roots.contains(prefix)) {\n                break;\n            }\n        }\n        result.append(prefix).append(\" \");\n    }\n\n    return result.toString().trim();\n}",
            "python": "if __name__ == \"__main__\":\n    dict = $args[0]\n    sentence = $args[1]\n    result = replaceWords(dict, sentence)\n    print(result)",
            "javascript": "function main() {\n    const dict = $args[0];\n    const sentence = $args[1];\n    const result = replaceWords(dict, sentence);\n    console.log(result);\n}"
        }
    },
    "650": {
        "title": "Minimum Operations to Get 'A'",
        "description": "You have a notepad with only one character 'A' on the screen. You can perform two operations: Copy All and Paste. The Copy All operation copies all the characters on the screen, while the Paste operation pastes the characters that were last copied. Given an integer n, determine the minimum number of operations required to get exactly n 'A' characters on the screen.",
        "example": "Example:\n\nInput: n = 3\nOutput: 3\nExplanation: Initially, we have one character 'A'.\nIn step 1, we use Copy All operation.\nIn step 2, we use Paste operation to get 'AA'.\nIn step 3, we use Paste operation to get 'AAA'.",
        "level": "Medium",
        "tags": [
            "dynamic programming",
            "math"
        ],
        "test_cases": {
            "inputs": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                20,
                50,
                100,
                200,
                500,
                1000
            ],
            "outputs": [
                0,
                2,
                3,
                4,
                5,
                5,
                7,
                6,
                6,
                7,
                9,
                14,
                14,
                14,
                14,
                14
            ]
        },
        "sample_code": {
            "c++": "int minSteps(int n) {\n    int result = 0;\n    for (int i = 2; i <= n; ++i) {\n        while (n % i == 0) {\n            result += i;\n            n /= i;\n        }\n    }\n    return result;\n}\n",
            "java": "public int minSteps(int n) {\n    int result = 0;\n    for (int i = 2; i <= n; i++) {\n        while (n % i == 0) {\n            result += i;\n            n /= i;\n        }\n    }\n    return result;\n}\n",
            "python": "def min_steps(n):\n    result = 0\n    i = 2\n    while i <= n:\n        while n % i == 0:\n            result += i\n            n //= i\n        i += 1\n    return result\n",
            "javascript": "function minSteps(n) {\n    let result = 0;\n    for (let i = 2; i <= n; i++) {\n        while (n % i === 0) {\n            result += i;\n            n /= i;\n        }\n    }\n    return result;\n}\n",
            "explanation": "We need to find the minimum number of operations to get the character 'A' exactly n times on the screen. The operations are copying all (useful when having a large number of 'A's) and pasting.\n\nWe can think about this problem in terms of prime factorization. We are trying to break down n into the sum of various prime factors. The prime factors represent the number of operations needed at each step. \n\nIn our algorithm, we initialize the variable `result` to 0, which will store the minimum number of operations. We then start with i = 2 (smallest prime number) and iterate through all values less than or equal to n. Inside the loop, we check if n is divisible by i (i.e., n % i == 0). If yes, we add i to `result` and divide n by i. We keep doing this while n is divisible by i. Once n is no longer divisible by i, move on to the next value of i.\n\nAt the end of the algorithm, the `result` variable will contain the minimum number of operations to get n 'A's on the screen."
        },
        "structure": {
            "c++": "int minSteps(int n) \n    // Your code here\n}\n",
            "java": "public int minSteps(int n) \n    // Your code here\n}\n",
            "python": "def min_steps(n):\n    # Your code here\n\n",
            "javascript": "function minSteps(n) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n = $args;\n    int result = minSteps(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int minSteps(int n) {\n    int result = 0;\n    for (int i = 2; i <= n; i++) {\n        while (n % i == 0) {\n            result += i;\n            n /= i;\n        }\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    result = min_steps(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = minSteps(n);\n    console.log(result);\n}"
        }
    },
    "651": {
        "title": "Maximum Number of 'A'",
        "description": "You have a special keyboard with the following keys:\n\n* A: Print one 'A' on the screen.\n* Ctrl-A: Select the whole screen.\n* Ctrl-C: Copy selection to buffer.\n* Ctrl-V: Print buffer on screen appending it after what has already been printed.\n\nGiven an integer n, return the maximum number of 'A' you can print on the screen with at most n presses on the keys.",
        "example": "Example:\n\nInput: n = 3\nOutput: 3\nExplanation: We can at most get 3 A's on screen by pressing the following key sequence:\nA, A, A",
        "level": "Medium",
        "tags": [
            "dynamic programming",
            "optimization"
        ],
        "test_cases": {
            "inputs": [
                1,
                2,
                3,
                7,
                10,
                15,
                20,
                25,
                30,
                35,
                40,
                45,
                50
            ],
            "outputs": [
                1,
                2,
                3,
                9,
                12,
                27,
                54,
                81,
                162,
                243,
                486,
                729,
                1458
            ]
        },
        "sample_code": {
            "c++": "int maxA(int n) {\n    vector<int> dp(n + 1);\n    for(int i = 1; i <= n; ++i) {\n        dp[i] = i;\n        for(int j = 1; j <= i - 3; ++j)\n            dp[i] = max(dp[i], dp[j] * (i - j - 1));\n    }\n    return dp[n];\n}\n",
            "java": "public int maxA(int n) {\n    int[] dp = new int[n + 1];\n    for(int i = 1; i <= n; ++i) {\n        dp[i] = i;\n        for(int j = 1; j <= i - 3; ++j)\n            dp[i] = Math.max(dp[i], dp[j] * (i - j - 1));\n    }\n    return dp[n];\n}\n",
            "python": "def maxA(n: int) -> int:\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = i\n        for j in range(1, i - 2):\n            dp[i] = max(dp[i], dp[j] * (i - j - 1))\n    return dp[n]\n",
            "javascript": "function maxA(n) {\n    let dp = new Array(n + 1);\n    for(let i = 1; i <= n; ++i) {\n        dp[i] = i;\n        for(let j = 1; j <= i - 3; ++j)\n            dp[i] = Math.max(dp[i], dp[j] * (i - j - 1));\n    }\n    return dp[n];\n}\n",
            "explanation": "The problem can be solved using dynamic programming. We can create a dp array of size `n + 1` to store the maximum number of 'A's that can be printed with a maximum of `i` presses.\n\nFor each position `i` in the dp array, we initialize it with the value of `i`, as the minimum number of 'A's that can be printed is pressing the 'A' key `i` times. Next, we iterate through the previous positions, from `j = 1` to `i - 3`, and calculate the maximum number of 'A's we can obtain by copying the string of 'A's with `(i - j - 1)` Ctrl-V presses right after a Ctrl A and Ctrl C.\n\nTo calculate the maximum, we take the maximum between the current value of `dp[i]` and `dp[j] * (i - j - 1)`. Finally, return the value of `dp[n]`, as it represents the maximum number of 'A's that can be printed with a maximum of `n` presses."
        },
        "structure": {
            "c++": "int maxA(int n) \n    // Your code here\n}\n",
            "java": "public int maxA(int n) \n    // Your code here\n}\n",
            "python": "def maxA(n: int) -> int:\n    # Your code here\n\n",
            "javascript": "function maxA(n) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = maxA(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int maxA(int n) {\n    int[] dp = new int[n + 1];\n    for(int i = 1; i <= n; ++i) {\n        dp[i] = i;\n        for(int j = 1; j <= i - 3; ++j)\n            dp[i] = Math.max(dp[i], dp[j] * (i - j - 1));\n    }\n    return dp[n];\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    result = maxA(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = maxA(n);\n    console.log(result);\n}"
        }
    },
    "653": {
        "title": "Binary Search Tree Two Sum",
        "description": "Given the `root` of a binary search tree and an integer `k`, determine if there exist two elements in the BST such that their sum is equal to `k`. Return `true` if such elements exist, otherwise return `false`.",
        "example": "Example 1:\n\nInput: root = [5,3,6,2,4,null,7], k = 9\nOutput: true\n\nExplanation: The BST is shown below:\n\n      5\n     / \\\n    3   6\n   / \\   \\\n  2   4   7\n\nThe sum of 2 and 7 is equal to 9, so the output is true.\n\nExample 2:\n\nInput: root = [5,3,6,2,4,null,7], k = 28\nOutput: false\n\nExplanation: The BST is shown below:\n\n      5\n     / \\\n    3   6\n   / \\   \\\n  2   4   7\n\nThere are no two elements in the BST whose sum is equal to 28, so the output is false.",
        "level": "Easy",
        "tags": [
            "Binary Search Tree",
            "Two Sum",
            "Recursion"
        ],
        "test_cases": {
            "inputs": [
                "[5,3,6,2,4,null,7]",
                "[5,3,6,2,4,null,7]",
                [
                    2,
                    1,
                    3
                ],
                [
                    2,
                    1,
                    3
                ],
                [
                    1
                ],
                [
                    1
                ],
                [
                    1,
                    2
                ],
                [
                    1,
                    2
                ],
                [
                    1,
                    2,
                    3
                ],
                [
                    1,
                    2,
                    3
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                false,
                false,
                false,
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "bool findTarget(TreeNode* root, int k) {\n    unordered_set<int> nodes;\n    return findNode(root, k, nodes);\n}\n\nbool findNode(TreeNode* root, int k, unordered_set<int>& nodes) {\n    if (!root) return false;\n    if (nodes.count(k - root->val)) return true;\n    nodes.insert(root->val);\n    return findNode(root->left, k, nodes) || findNode(root->right, k, nodes);\n}\n",
            "java": "public boolean findTarget(TreeNode root, int k) {\n    Set<Integer> nodes = new HashSet<>();\n    return findNode(root, k, nodes);\n}\n\npublic boolean findNode(TreeNode root, int k, Set<Integer> nodes) {\n    if (root == null) return false;\n    if (nodes.contains(k - root.val)) return true;\n    nodes.add(root.val);\n    return findNode(root.left, k, nodes) || findNode(root.right, k, nodes);\n}\n",
            "python": "def findTarget(root, k):\n    nodes = set()\n    return findNode(root, k, nodes)\n\ndef findNode(root, k, nodes):\n    if not root:\n        return False\n    if k - root.val in nodes:\n        return True\n    nodes.add(root.val)\n    return findNode(root.left, k, nodes) or findNode(root.right, k, nodes)\n",
            "javascript": "function findTarget(root, k) {\n    const nodes = new Set();\n    return findNode(root, k, nodes);\n}\n\nfunction findNode(root, k, nodes) {\n    if (!root) return false;\n    if (nodes.has(k - root.val)) return true;\n    nodes.add(root.val);\n    return findNode(root.left, k, nodes) || findNode(root.right, k, nodes);\n}\n",
            "explanation": "The function takes the root of a binary search tree and a target number `k`. The purpose is to see if there are two elements in the tree that sum up to `k`. We start by initializing a set called `nodes` to keep track of visited values. Then, we create a recursive helper function called `findNode`. \n\nIn the `findNode` function, the base case is when the current root is null, meaning we've reached the end of a branch, and we return false as no such pair of elements found yet. If `k - root.val` is found in our set, that means we've found a pair of elements that sum up to `k`, and we can return true. Otherwise, we proceed with the left and right children of the current root, passing the `nodes` set along to keep track of visited values. This is done using a depth-first search strategy. \n\nThe result is a boolean indicating whether or not two elements in the tree sum up to `k`."
        },
        "structure": {
            "c++": "bool findTarget(TreeNode* root, int k) \n    // Your code here\n}\n",
            "java": "public boolean findTarget(TreeNode root, int k) \n    // Your code here\n}\n",
            "python": "def findTarget(root, k):\n    # Your code here\n\n",
            "javascript": "function findTarget(root, k) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "bool findTarget(TreeNode* root, int k) {\n    unordered_set<int> nodes;\n    return findNode(root, k, nodes);\n}\n\nbool findNode(TreeNode* root, int k, unordered_set<int>& nodes) {\n    if (!root) return false;\n    if (nodes.count(k - root->val)) return true;\n    nodes.insert(root->val);\n    return findNode(root->left, k, nodes) || findNode(root->right, k, nodes);\n}",
            "java": "public boolean findTarget(TreeNode root, int k) {\n    Set<Integer> nodes = new HashSet<>();\n    return findNode(root, k, nodes);\n}\n\npublic boolean findNode(TreeNode root, int k, Set<Integer> nodes) {\n    if (root == null) return false;\n    if (nodes.contains(k - root.val)) return true;\n    nodes.add(root.val);\n    return findNode(root.left, k, nodes) || findNode(root.right, k, nodes);\n}",
            "python": "if __name__ == \"__main__\":\n    root = $args[0]\n    k = $args[1]\n    result = findTarget(root, k)\n    print(result)",
            "javascript": "function main() {\n    const root = $args[0];\n    const k = $args[1];\n    const nodes = new Set();\n    const result = findNode(root, k, nodes);\n    console.log(result);\n}"
        }
    },
    "658": {
        "title": "K Closest Elements",
        "description": "Given a sorted integer array `arr`, two integers `k` and `x`, return the `k` closest integers to `x` in the array. The result should also be sorted in ascending order. An integer `a` is closer to `x` than an integer `b` if: `|a - x| < |b - x|`, or `|a - x| == |b - x|` and `a < b`.",
        "example": "Example:\n\nInput: arr = [1,2,3,4,5], k = 4, x = 3\nOutput: [1,2,3,4]\n\nExplanation: The closest elements to 3 in the array are 1, 2, 3, and 4. The result is sorted in ascending order.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ]
            ],
            "outputs": [
                "[1,2,3,4]",
                "[1,2,3,4]",
                "[1,2,3,4]",
                "[1,2,3,4]",
                "[1,2,3,4]",
                "[1,2,3,4]",
                "[1,2,3,4]",
                "[1,2,3,4]",
                "[1,2,3,4]",
                "[1,2,3,4]",
                "[1,2,3,4]",
                "[1,2,3,4]",
                "[1,2,3,4]",
                "[1,2,3,4]",
                "[1,2,3,4]",
                "[1,2,3,4]",
                "[1,2,3,4]",
                "[1,2,3,4]",
                "[1,2,3,4]",
                "[1,2,3,4]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> findClosestElements(std::vector<int>& arr, int k, int x) {\n    int left = 0;\n    int right = arr.size() - k;\n    \n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (x - arr[mid] > arr[mid + k] - x) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    \n    return std::vector<int>(arr.begin() + left, arr.begin() + left + k);\n}\n",
            "java": "import java.util.List;\nimport java.util.ArrayList;\n\npublic List<Integer> findClosestElements(int[] arr, int k, int x) {\n    int left = 0;\n    int right = arr.length - k;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (x - arr[mid] > arr[mid + k] - x) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    List<Integer> result = new ArrayList<>();\n    for (int i = left; i < left + k; i++) {\n        result.add(arr[i]);\n    }\n\n    return result;\n}\n",
            "python": "from typing import List\n\ndef findClosestElements(arr: List[int], k: int, x: int) -> List[int]:\n    left = 0\n    right = len(arr) - k\n\n    while left < right:\n        mid = left + (right - left) // 2\n        if x - arr[mid] > arr[mid + k] - x:\n            left = mid + 1\n        else:\n            right = mid\n\n    return arr[left:left + k]\n",
            "javascript": "function findClosestElements(arr, k, x) {\n    let left = 0;\n    let right = arr.length - k;\n\n    while (left < right) {\n        let mid = left + ((right - left) >> 1);\n        if (x - arr[mid] > arr[mid + k] - x) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    return arr.slice(left, left + k);\n}\n",
            "explanation": "The algorithm uses a binary search to find the subarray of length `k` with the closest numbers to `x`. \n\n1. Initialize the `left` pointer to the beginning of the array and the `right` pointer to the end of the array minus `k`.\n2. While the `left` pointer is less than the `right` pointer:\n    a. Calculate the `mid` index.\n    b. Compare the difference between `arr[mid]` and `x`, and the difference between `arr[mid + k]` and `x`.\n    c. If the difference at `mid` is greater, update `left` to `mid + 1`, otherwise update `right` to `mid`.\n3. Once the binary search is complete, the result will be the subarray of length `k` starting at the `left` index.\n\nThis algorithm has a time complexity of O(log(n)) where n is the length of the input array, as it uses binary search to locate the closest elements. The space complexity is also O(1) since only a constant number of variables are used."
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> findClosestElements(std::vector<int>& arr, int k, int x) \n    // Your code here\n}\n",
            "java": "import java.util.List;\nimport java.util.ArrayList;\n\npublic List<Integer> findClosestElements(int[] arr, int k, int x) \n    // Your code here\n}\n",
            "python": "from typing import List\n    # Your code here\n\n",
            "javascript": "function findClosestElements(arr, k, x) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nint main() {\n    std::vector<int> arr = $args;\n    int k = 3;\n    int x = 5;\n    std::vector<int> result = findClosestElements(arr, k, x);\n    \n    for (int i : result) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}\n",
            "java": "public List<Integer> findClosestElements(int[] arr, int k, int x) {\n    int left = 0;\n    int right = arr.length - k;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (x - arr[mid] > arr[mid + k] - x) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    List<Integer> result = new ArrayList<>();\n    for (int i = left; i < left + k; i++) {\n        result.add(arr[i]);\n    }\n\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    arr = $args[0]\n    k = $args[1]\n    x = $args[2]\n    result = findClosestElements(arr, k, x)\n    print(result)",
            "javascript": "function main() {\n    const arr = $args[0];\n    const k = $args[1];\n    const x = $args[2];\n    const result = findClosestElements(arr, k, x);\n    console.log(result);\n}"
        }
    },
    "659": {
        "title": "Split Consecutive Subsequences",
        "description": "You are given an integer array `nums` that is sorted in non-decreasing order. Determine if it is possible to split `nums` into one or more subsequences such that both of the following conditions are true: \n\n- Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer). \n- All subsequences have a length of 3 or more. \n\nReturn true if you can split `nums` according to the above conditions, or false otherwise. \n\nA subsequence of an array is a new array that is formed from the original array by deleting some (can be none) of the elements without disturbing the relative positions of the remaining elements. (i.e., `[1,3,5]` is a subsequence of `[1,2,3,4,5]` while `[1,3,2]` is not).",
        "example": "Example 1:\n\nInput: nums = [1,2,3,3,4,5]\nOutput: true\nExplanation: nums can be split into the following subsequences:\n[1,2,3,3,4,5] --> 1, 2, 3\n[1,2,3,3,4,5] --> 3, 4, 5\n\nExample 2:\n\nInput: nums = [1,2,3,3,4,4,5,5]\nOutput: true\nExplanation: nums can be split into the following subsequences:\n[1,2,3,3,4,4,5,5] --> 1, 2, 3, 4, 5\n[1,2,3,3,4,4,5,5] --> 3, 4, 5\n\nExample 3:\n\nInput: nums = [1,2,3,4,4,5]\nOutput: false\nExplanation: It is impossible to split nums into consecutive increasing subsequences of length 3 or more.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    3,
                    4,
                    4,
                    5,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21
                ]
            ],
            "outputs": [
                true,
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nbool canSplit(vector<int>& nums) {\n    vector<int> freq(20001, 0), needed(20001, 0);\n    for (int n : nums)\n        freq[n]++;\n    for (int n : nums) {\n        if (!freq[n]) continue;\n        if (!needed[n - 1]) {\n            if (freq[n + 1] && freq[n + 2]) {\n                freq[n]--; freq[n + 1]--; freq[n + 2]--;\n                needed[n + 2]++;\n            } else return false;\n        } else {\n            freq[n]--; needed[n - 1]--;\n            needed[n]++;\n        }\n    }\n    return true;\n}\n",
            "java": "public boolean canSplit(int[] nums) {\n    int[] freq = new int[20001], needed = new int[20001];\n    for (int n : nums)\n        freq[n]++;\n    for (int n : nums) {\n        if (freq[n] == 0) continue;\n        if (needed[n - 1] == 0) {\n            if (freq[n + 1] > 0 && freq[n + 2] > 0) {\n                freq[n]--; freq[n + 1]--; freq[n + 2]--;\n                needed[n + 2]++;\n            } else return false;\n        } else {\n            freq[n]--; needed[n - 1]--;\n            needed[n]++;\n        }\n    }\n    return true;\n}\n",
            "python": "def can_split(nums):\n    freq = [0] * 20001\n    needed = [0] * 20001\n    for n in nums:\n        freq[n] += 1\n    for n in nums:\n        if not freq[n]: continue\n        if not needed[n - 1]:\n            if freq[n + 1] and freq[n + 2]:\n                freq[n] -= 1; freq[n + 1] -= 1; freq[n + 2] -= 1;\n                needed[n + 2] += 1\n            else: return False\n        else:\n            freq[n] -= 1; needed[n - 1] -= 1;\n            needed[n] += 1\n    return True\n",
            "javascript": "function canSplit(nums) {\n    const freq = new Array(20001).fill(0), needed = new Array(20001).fill(0);\n    for (let n of nums)\n        freq[n]++;\n    for (let n of nums) {\n        if (!freq[n]) continue;\n        if (!needed[n - 1]) {\n            if (freq[n + 1] && freq[n + 2]) {\n                freq[n]--; freq[n + 1]--; freq[n + 2]--;\n                needed[n + 2]++;\n            } else return false;\n        } else {\n            freq[n]--; needed[n - 1]--;\n            needed[n]++;\n        }\n    }\n    return true;\n}\n",
            "explanation": "The algorithm works as follows:\n1. Create two arrays, one to store the frequency of elements in the given input `nums`, and another to store the number of elements needed to create a valid sequence.\n2. Iterate through the input `nums`, filling up the frequency array.\n3. Iterate through the input `nums` again. For each non-zero frequency element in the input `nums`:\n   - If it's not needed to create a valid sequence, check if it can form a new sequence with its next two elements in the sorted order. If yes, decrement the frequencies of those three elements and increment the needed count of third elements by 1. If not, return false.\n   - If it's needed for a valid sequence, decrement its frequency and the needed count of its previous element, and increment the needed count of the element itself by 1.\n4. At the end of this iteration, if all conditions are met, return true.\n\nThis algorithm checks if the given sorted array can be split into subsequences of at least three consecutive integers. If any of the conditions mentioned are not met, it returns false. If all conditions are fulfilled, it returns true."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nbool canSplit(vector<int>& nums) \n    // Your code here\n}\n",
            "java": "public boolean canSplit(int[] nums) \n    // Your code here\n}\n",
            "python": "def can_split(nums):\n    # Your code here\n\n",
            "javascript": "function canSplit(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nbool canSplit(vector<int>& nums) {\n    vector<int> freq(20001, 0), needed(20001, 0);\n    for (int n : nums)\n        freq[n]++;\n    for (int n : nums) {\n        if (!freq[n]) continue;\n        if (!needed[n - 1]) {\n            if (freq[n + 1] && freq[n + 2]) {\n                freq[n]--; freq[n + 1]--; freq[n + 2]--;\n                needed[n + 2]++;\n            } else return false;\n        } else {\n            freq[n]--; needed[n - 1]--;\n            needed[n]++;\n        }\n    }\n    return true;\n}",
            "java": "public boolean canSplit(int[] nums) {\n    int[] freq = new int[20001], needed = new int[20001];\n    for (int n : nums)\n        freq[n]++;\n    for (int n : nums) {\n        if (freq[n] == 0) continue;\n        if (needed[n - 1] == 0) {\n            if (freq[n + 1] > 0 && freq[n + 2] > 0) {\n                freq[n]--; freq[n + 1]--; freq[n + 2]--;\n                needed[n + 2]++;\n            } else return false;\n        } else {\n            freq[n]--; needed[n - 1]--;\n            needed[n]++;\n        }\n    }\n    return true;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = can_split(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = canSplit(nums);\n    console.log(result);\n}"
        }
    },
    "660": {
        "title": "Nth Integer without 9",
        "description": "Given a sequence of integers starting from 1, remove any integer that contains the digit 9. The resulting sequence will be [1, 2, 3, 4, 5, 6, 7, 8, 10, 11, ...]. Given an integer n, return the nth (1-indexed) integer in the new sequence.",
        "example": "Example:\n\nInput: n = 9\nOutput: 10\n\nExplanation: The sequence after removing integers with the digit 9 is [1, 2, 3, 4, 5, 6, 7, 8, 10, ...]. The 9th integer in this sequence is 10.\n\nInput: n = 10\nOutput: 11\n\nExplanation: The sequence after removing integers with the digit 9 is [1, 2, 3, 4, 5, 6, 7, 8, 10, 11, ...]. The 10th integer in this sequence is 11.",
        "level": "Easy",
        "tags": [
            "Math",
            "Sequence"
        ],
        "test_cases": {
            "inputs": [
                9,
                10,
                15,
                20,
                25,
                30,
                50,
                100,
                1000,
                10000,
                100000,
                1000000,
                10000000,
                100000000,
                1000000000,
                10000000000,
                100000000000,
                1000000000000,
                10000000000000,
                100000000000000
            ],
            "outputs": [
                10,
                11,
                15,
                20,
                25,
                30,
                50,
                100,
                1000,
                10000,
                100000,
                1000000,
                10000000,
                100000000,
                1000000000,
                10000000000,
                100000000000,
                1000000000000,
                10000000000000,
                100000000000000
            ]
        },
        "sample_code": {
            "c++": "int newInteger(int n) {\n    int result = 0, base = 1;\n    while (n) {\n        result += n % 9 * base;\n        n /= 9;\n        base *= 10;\n    }\n    return result;\n}\n",
            "java": "public int newInteger(int n) {\n    int result = 0, base = 1;\n    while (n>0) {\n        result += n % 9 * base;\n        n /= 9;\n        base *= 10;\n    }\n    return result;\n}\n",
            "python": "def newInteger(n):\n    result = 0\n    base = 1\n    while n:\n        result += n % 9 * base\n        n //= 9\n        base *= 10\n    return result\n",
            "javascript": "function newInteger(n) {\n    let result = 0, base = 1;\n    while (n > 0) {\n        result += (n % 9) * base;\n        n = Math.floor(n / 9);\n        base *= 10;\n    }\n    return result;\n}\n",
            "explanation": "The general idea is to use a radix-9 representation for the resulting numbers, ignoring the number 9. The input number `n` is first considered to be in base 9, so we divide it by 9 and calculate the remainder. The remainder corresponds to a digit position in the resulting number. The algorithm continually adds the product of the remainder and the current base (starting at 1), and updates the input number by dividing it by 9. This process continues until the input number is reduced to 0. At this point, the result contains the final number, which is then returned."
        },
        "structure": {
            "c++": "int newInteger(int n) \n    // Your code here\n}\n",
            "java": "public int newInteger(int n) \n    // Your code here\n}\n",
            "python": "def newInteger(n):\n    # Your code here\n\n",
            "javascript": "function newInteger(n) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n = $args;\n    int result = newInteger(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int newInteger(int n) {\n    int result = 0, base = 1;\n    while (n>0) {\n        result += n % 9 * base;\n        n /= 9;\n        base *= 10;\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    result = newInteger(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = newInteger(n);\n    console.log(result);\n}"
        }
    },
    "661": {
        "title": "Image Smoother",
        "description": "An image smoother is a filter of size 3x3 that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells. If one or more of the surrounding cells of a cell is not present, we do not consider it in the average. Given an m x n integer matrix img representing the grayscale of an image, return the image after applying the smoother on each cell of it.",
        "example": "Example 1:\n\nInput: img = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[0,0,0],[0,0,0],[0,0,0]]\nExplanation: For the points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0. For the points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0. For the point (1,1): floor(8/9) = floor(0.88888889) = 0\n\nExample 2:\n\nInput: img = [[100,200,100],[200,50,200],[100,200,100]]\nOutput: [[137,141,137],[141,138,141],[137,141,137]]\nExplanation: For the points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137. For the points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141. For the point (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138",
        "level": "Easy",
        "tags": [
            "matrix",
            "averages"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        1
                    ]
                ],
                [
                    [
                        100,
                        200,
                        100
                    ],
                    [
                        200,
                        50,
                        200
                    ],
                    [
                        100,
                        200,
                        100
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9
                    ]
                ],
                [
                    [
                        10,
                        20,
                        30
                    ],
                    [
                        40,
                        50,
                        60
                    ],
                    [
                        70,
                        80,
                        90
                    ]
                ],
                [
                    [
                        255,
                        0,
                        0
                    ],
                    [
                        0,
                        255,
                        0
                    ],
                    [
                        0,
                        0,
                        255
                    ]
                ],
                [
                    [
                        128,
                        128,
                        128
                    ],
                    [
                        128,
                        128,
                        128
                    ],
                    [
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9
                    ]
                ],
                [
                    [
                        10,
                        20,
                        30
                    ],
                    [
                        40,
                        50,
                        60
                    ],
                    [
                        70,
                        80,
                        90
                    ]
                ],
                [
                    [
                        255,
                        0,
                        0
                    ],
                    [
                        0,
                        255,
                        0
                    ],
                    [
                        0,
                        0,
                        255
                    ]
                ],
                [
                    [
                        128,
                        128,
                        128
                    ],
                    [
                        128,
                        128,
                        128
                    ],
                    [
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9
                    ]
                ],
                [
                    [
                        10,
                        20,
                        30
                    ],
                    [
                        40,
                        50,
                        60
                    ],
                    [
                        70,
                        80,
                        90
                    ]
                ],
                [
                    [
                        255,
                        0,
                        0
                    ],
                    [
                        0,
                        255,
                        0
                    ],
                    [
                        0,
                        0,
                        255
                    ]
                ],
                [
                    [
                        128,
                        128,
                        128
                    ],
                    [
                        128,
                        128,
                        128
                    ],
                    [
                        128,
                        128,
                        128
                    ]
                ]
            ],
            "outputs": [
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        137,
                        141,
                        137
                    ],
                    [
                        141,
                        138,
                        141
                    ],
                    [
                        137,
                        141,
                        137
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        3,
                        3,
                        4
                    ],
                    [
                        4,
                        4,
                        5
                    ],
                    [
                        6,
                        6,
                        7
                    ]
                ],
                [
                    [
                        23,
                        23,
                        24
                    ],
                    [
                        24,
                        24,
                        25
                    ],
                    [
                        26,
                        26,
                        27
                    ]
                ],
                [
                    [
                        85,
                        85,
                        85
                    ],
                    [
                        85,
                        85,
                        85
                    ],
                    [
                        85,
                        85,
                        85
                    ]
                ],
                [
                    [
                        128,
                        128,
                        128
                    ],
                    [
                        128,
                        128,
                        128
                    ],
                    [
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        3,
                        3,
                        4
                    ],
                    [
                        4,
                        4,
                        5
                    ],
                    [
                        6,
                        6,
                        7
                    ]
                ],
                [
                    [
                        23,
                        23,
                        24
                    ],
                    [
                        24,
                        24,
                        25
                    ],
                    [
                        26,
                        26,
                        27
                    ]
                ],
                [
                    [
                        85,
                        85,
                        85
                    ],
                    [
                        85,
                        85,
                        85
                    ],
                    [
                        85,
                        85,
                        85
                    ]
                ],
                [
                    [
                        128,
                        128,
                        128
                    ],
                    [
                        128,
                        128,
                        128
                    ],
                    [
                        128,
                        128,
                        128
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255
                    ],
                    [
                        255,
                        255,
                        255
                    ]
                ],
                [
                    [
                        3,
                        3,
                        4
                    ],
                    [
                        4,
                        4,
                        5
                    ],
                    [
                        6,
                        6,
                        7
                    ]
                ],
                [
                    [
                        23,
                        23,
                        24
                    ],
                    [
                        24,
                        24,
                        25
                    ],
                    [
                        26,
                        26,
                        27
                    ]
                ],
                [
                    [
                        85,
                        85,
                        85
                    ],
                    [
                        85,
                        85,
                        85
                    ],
                    [
                        85,
                        85,
                        85
                    ]
                ],
                [
                    [
                        128,
                        128,
                        128
                    ],
                    [
                        128,
                        128,
                        128
                    ],
                    [
                        128,
                        128,
                        128
                    ]
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<vector<int>> imageSmoother(vector<vector<int>>& img) {\n    int m = img.size(), n = img[0].size();\n    vector<vector<int>> result(m, vector<int>(n, 0));\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int count = 0, sum = 0;\n            for (int x = i - 1; x <= i + 1; x++) {\n                for (int y = j - 1; y <= j + 1; y++) {\n                    if (x >= 0 && x < m && y >= 0 && y < n) {\n                        sum += img[x][y];\n                        count++;\n                    }\n                }\n            }\n            result[i][j] = sum / count;\n        }\n    }\n\n    return result;\n}\n",
            "java": "public int[][] imageSmoother(int[][] img) {\n    int m = img.length, n = img[0].length;\n    int[][] result = new int[m][n];\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int count = 0, sum = 0;\n            for (int x = i - 1; x <= i + 1; x++) {\n                for (int y = j - 1; y <= j + 1; y++) {\n                    if (x >= 0 && x < m && y >= 0 && y < n) {\n                        sum += img[x][y];\n                        count++;\n                    }\n                }\n            }\n            result[i][j] = sum / count;\n        }\n    }\n\n    return result;\n}\n",
            "python": "def imageSmoother(img):\n    m, n = len(img), len(img[0])\n    result = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            count, total = 0, 0\n            for x in range(i - 1, i + 2):\n                for y in range(j - 1, j + 2):\n                    if 0 <= x < m and 0 <= y < n:\n                        total += img[x][y]\n                        count += 1\n            result[i][j] = total // count\n\n    return result\n",
            "javascript": "function imageSmoother(img) {\n    const m = img.length, n = img[0].length;\n    const result = new Array(m).fill(0).map(() => new Array(n).fill(0));\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            let count = 0, sum = 0;\n\n            for (let x = i - 1; x <= i + 1; x++) {\n                for (let y = j - 1; y <= j + 1; y++) {\n                    if (x >= 0 && x < m && y >= 0 && y < n) {\n                        sum += img[x][y];\n                        count++;\n                    }\n                }\n            }\n            result[i][j] = Math.floor(sum / count);\n        }\n    }\n\n    return result;\n}\n",
            "explanation": "1. Find the dimensions (m, n) of the input img array.\n2. Initialize the result array with the same dimensions as img.\n3. Iterate through each cell (i, j) of the img array.\n4. Iterate through 8 neighboring cells with corresponding coordinates (x, y) within a 3x3 grid centered at (i, j).\n5. Check if the neighboring cell (x, y) is within the boundaries of img. If so, add the value of img[x][y] to the sum, and increment the count.\n6. Calculate the average by dividing the sum by count and round down the result.\n7. Set the value of the result[i][j] to the calculated average.\n8. Return the result array."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<vector<int>> imageSmoother(vector<vector<int>>& img) \n    // Your code here\n}\n",
            "java": "public int[][] imageSmoother(int[][] img) \n    // Your code here\n}\n",
            "python": "def imageSmoother(img):\n    # Your code here\n\n",
            "javascript": "function imageSmoother(img) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<vector<int>> imageSmoother(vector<vector<int>>& img) {\n    int m = img.size(), n = img[0].size();\n    vector<vector<int>> result(m, vector<int>(n, 0));\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int count = 0, sum = 0;\n            for (int x = i - 1; x <= i + 1; x++) {\n                for (int y = j - 1; y <= j + 1; y++) {\n                    if (x >= 0 && x < m && y >= 0 && y < n) {\n                        sum += img[x][y];\n                        count++;\n                    }\n                }\n            }\n            result[i][j] = sum / count;\n        }\n    }\n\n    return result;\n}",
            "java": "public int[][] imageSmoother(int[][] img)",
            "python": "if __name__ == \"__main__\":\n    img = $args[0]\n    result = imageSmoother(img)\n    print(result)",
            "javascript": "function imageSmoother(img) {\n    const m = img.length, n = img[0].length;\n    const result = new Array(m).fill(0).map(() => new Array(n).fill(0));\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            let count = 0, sum = 0;\n\n            for (let x = i - 1; x <= i + 1; x++) {\n                for (let y = j - 1; y <= j + 1; y++) {\n                    if (x >= 0 && x < m && y >= 0 && y < n) {\n                        sum += img[x][y];\n                        count++;\n                    }\n                }\n            }\n            result[i][j] = Math.floor(sum / count);\n        }\n    }\n\n    return result;\n}"
        }
    },
    "664": {
        "title": "Strange Printer",
        "description": "You are given a strange printer with the following two special properties:\n\n- The printer can only print a sequence of the same character each time.\n- At each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.\n\nGiven a string `s`, return the minimum number of turns the printer needed to print it.",
        "example": "Example:\n\nInput: s = \"aaabbb\"\nOutput: 2\nExplanation: Print \"aaa\" first and then print \"bbb\".\n\nInput: s = \"aba\"\nOutput: 2\nExplanation: Print \"aaa\" first and then print \"b\" from the second place of the string, which will cover the existing character 'a'.",
        "level": "Medium",
        "tags": [
            "string",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                "\"aaabbb\"",
                "\"aba\"",
                "\"abcabc\"",
                "\"aaaaa\"",
                "\"aabbaabb\"",
                "\"abcdefg\"",
                "\"aaaaaabbbbbb\"",
                "\"abababab\"",
                "\"aabbccddeeff\"",
                "\"abcdeedcba\"",
                "\"a\"",
                "\"aa\"",
                "\"aaa\"",
                "\"aaaa\"",
                "\"aaaaa\"",
                "\"aaaaaa\"",
                "\"aaaaaaa\"",
                "\"aaaaaaaa\"",
                "\"aaaaaaaaa\"",
                "\"aaaaaaaaaa\""
            ],
            "outputs": [
                "2",
                "2",
                "6",
                "1",
                "4",
                "7",
                "2",
                "2",
                "6",
                "6",
                "1",
                "1",
                "1",
                "1",
                "1",
                "1",
                "1",
                "1",
                "1",
                "1"
            ]
        },
        "sample_code": {
            "c++": "int strangePrinter(string s) {\n    int n = s.size();\n    if(n == 0) return 0;\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    for(int i = 0; i < n; i++) dp[i][i] = 1;\n    for(int len = 1; len < n; len++) {\n        for(int i = 0; i < n - len; i++) {\n            int j = i + len;\n            dp[i][j] = dp[i+1][j] + 1;\n            for(int k = i + 1; k <= j; k++) {\n                if(s[i] == s[k]) {\n                    dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k][j]);\n                }\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n",
            "java": "int strangePrinter(String s) {\n    int n = s.length();\n    if(n == 0) return 0;\n    int[][] dp = new int[n][n];\n    for(int i = 0; i < n; i++) dp[i][i] = 1;\n    for(int len = 1; len < n; len++) {\n        for(int i = 0; i < n - len; i++) {\n            int j = i + len;\n            dp[i][j] = dp[i+1][j] + 1;\n            for(int k = i + 1; k <= j; k++) {\n                if(s.charAt(i) == s.charAt(k)) {\n                    dp[i][j] = Math.min(dp[i][j], dp[i+1][k-1] + dp[k][j]);\n                }\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n",
            "python": "def strange_printer(s: str) -> int:\n    n = len(s)\n    if n == 0: return 0\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for len in range(1, n):\n        for i in range(n - len):\n            j = i + len\n            dp[i][j] = dp[i+1][j] + 1\n            for k in range(i + 1, j + 1):\n                if s[i] == s[k]:\n                    dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k][j])\n    return dp[0][n-1]\n",
            "javascript": "function strangePrinter(s) {\n    let n = s.length;\n    if(n === 0) return 0;\n    const dp = Array.from({ length: n }, () => Array(n).fill(0));\n    for(let i = 0; i < n; i++) dp[i][i] = 1;\n    for(let len = 1; len < n; len++) {\n        for(let i = 0; i < n - len; i++) {\n            let j = i + len;\n            dp[i][j] = dp[i+1][j] + 1;\n            for(let k = i + 1; k <= j; k++) {\n                if(s.charAt(i) === s.charAt(k)) {\n                    dp[i][j] = Math.min(dp[i][j], dp[i+1][k-1] + dp[k][j]);\n                }\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n",
            "explanation": "1. Initialize a DP table `dp` of size `n x n` where `n` is the length of the input string `s`.\n2. Fill the diagonal of the DP table with 1 since it takes one turn to print a single character.\n3. Iterate through subproblems of increasing length using a nested loop.\n4. For each subproblem, initialize `dp[i][j]` as `dp[i+1][j] + 1` assuming it takes one more turn to print the character at the current `i`.\n5. Loop through `k` from `i + 1` to `j`. If the character at `i` matches the character at `k`, update `dp[i][j]` by taking the minimum of its current value and the sum of turns for two non-overlapping subproblems `dp[i+1][k-1]` and `dp[k][j]`.\n6. The answer is stored at `dp[0][n-1]`."
        },
        "structure": {
            "c++": "int strangePrinter(string s) \n    // Your code here\n}\n",
            "java": "int strangePrinter(String s) \n    // Your code here\n}\n",
            "python": "def strange_printer(s: str) -> int:\n    # Your code here\n\n",
            "javascript": "function strangePrinter(s) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int strangePrinter(string s) {\n    int n = s.size();\n    if(n == 0) return 0;\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    for(int i = 0; i < n; i++) dp[i][i] = 1;\n    for(int len = 1; len < n; len++) {\n        for(int i = 0; i < n - len; i++) {\n            int j = i + len;\n            dp[i][j] = dp[i+1][j] + 1;\n            for(int k = i + 1; k <= j; k++) {\n                if(s[i] == s[k]) {\n                    dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k][j]);\n                }\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n\nint main() {\n    string s = $args;\n    int result = strangePrinter(s);\n    cout << result << endl;\n    return 0;\n}"
        }
    },
    "666": {
        "title": "Binary Tree Path Sum",
        "description": "Given an array of ascending three-digit integers `nums` representing a binary tree with a depth smaller than 5, calculate the sum of all paths from the root towards the leaves.",
        "example": "Example 1:\n\nInput: nums = [113,215,221]\nOutput: 12\nExplanation: The tree that the list represents is shown. The path sum is (3 + 5) + (3 + 1) = 12.\n\nExample 2:\n\nInput: nums = [113,221]\nOutput: 4\nExplanation: The tree that the list represents is shown. The path sum is (3 + 1) = 4.",
        "level": "Medium",
        "tags": [
            "binary tree",
            "path sum"
        ],
        "test_cases": {
            "inputs": [
                [
                    113,
                    215,
                    221
                ],
                [
                    113,
                    221
                ],
                [
                    110,
                    111,
                    112,
                    113,
                    114,
                    115,
                    116,
                    117,
                    118,
                    119,
                    120,
                    121,
                    122,
                    123,
                    124
                ],
                [
                    110,
                    111,
                    112,
                    113,
                    114,
                    115,
                    116,
                    117,
                    118,
                    119,
                    120,
                    121,
                    122,
                    123,
                    124,
                    125
                ],
                [
                    110,
                    111,
                    112,
                    113,
                    114,
                    115,
                    116,
                    117,
                    118,
                    119,
                    120,
                    121,
                    122,
                    123,
                    124,
                    125,
                    126
                ],
                [
                    110,
                    111,
                    112,
                    113,
                    114,
                    115,
                    116,
                    117,
                    118,
                    119,
                    120,
                    121,
                    122,
                    123,
                    124,
                    125,
                    126,
                    127
                ],
                [
                    110,
                    111,
                    112,
                    113,
                    114,
                    115,
                    116,
                    117,
                    118,
                    119,
                    120,
                    121,
                    122,
                    123,
                    124,
                    125,
                    126,
                    127,
                    128
                ],
                [
                    110,
                    111,
                    112,
                    113,
                    114,
                    115,
                    116,
                    117,
                    118,
                    119,
                    120,
                    121,
                    122,
                    123,
                    124,
                    125,
                    126,
                    127,
                    128,
                    129
                ],
                [
                    110,
                    111,
                    112,
                    113,
                    114,
                    115,
                    116,
                    117,
                    118,
                    119,
                    120,
                    121,
                    122,
                    123,
                    124,
                    125,
                    126,
                    127,
                    128,
                    129,
                    130
                ],
                [
                    110,
                    111,
                    112,
                    113,
                    114,
                    115,
                    116,
                    117,
                    118,
                    119,
                    120,
                    121,
                    122,
                    123,
                    124,
                    125,
                    126,
                    127,
                    128,
                    129,
                    130,
                    131
                ],
                [
                    110,
                    111,
                    112,
                    113,
                    114,
                    115,
                    116,
                    117,
                    118,
                    119,
                    120,
                    121,
                    122,
                    123,
                    124,
                    125,
                    126,
                    127,
                    128,
                    129,
                    130,
                    131,
                    132
                ],
                [
                    110,
                    111,
                    112,
                    113,
                    114,
                    115,
                    116,
                    117,
                    118,
                    119,
                    120,
                    121,
                    122,
                    123,
                    124,
                    125,
                    126,
                    127,
                    128,
                    129,
                    130,
                    131,
                    132,
                    133
                ],
                [
                    110,
                    111,
                    112,
                    113,
                    114,
                    115,
                    116,
                    117,
                    118,
                    119,
                    120,
                    121,
                    122,
                    123,
                    124,
                    125,
                    126,
                    127,
                    128,
                    129,
                    130,
                    131,
                    132,
                    133,
                    134
                ],
                [
                    110,
                    111,
                    112,
                    113,
                    114,
                    115,
                    116,
                    117,
                    118,
                    119,
                    120,
                    121,
                    122,
                    123,
                    124,
                    125,
                    126,
                    127,
                    128,
                    129,
                    130,
                    131,
                    132,
                    133,
                    134,
                    135
                ],
                [
                    110,
                    111,
                    112,
                    113,
                    114,
                    115,
                    116,
                    117,
                    118,
                    119,
                    120,
                    121,
                    122,
                    123,
                    124,
                    125,
                    126,
                    127,
                    128,
                    129,
                    130,
                    131,
                    132,
                    133,
                    134,
                    135,
                    136
                ],
                [
                    110,
                    111,
                    112,
                    113,
                    114,
                    115,
                    116,
                    117,
                    118,
                    119,
                    120,
                    121,
                    122,
                    123,
                    124,
                    125,
                    126,
                    127,
                    128,
                    129,
                    130,
                    131,
                    132,
                    133,
                    134,
                    135,
                    136,
                    137
                ],
                [
                    110,
                    111,
                    112,
                    113,
                    114,
                    115,
                    116,
                    117,
                    118,
                    119,
                    120,
                    121,
                    122,
                    123,
                    124,
                    125,
                    126,
                    127,
                    128,
                    129,
                    130,
                    131,
                    132,
                    133,
                    134,
                    135,
                    136,
                    137,
                    138
                ],
                [
                    110,
                    111,
                    112,
                    113,
                    114,
                    115,
                    116,
                    117,
                    118,
                    119,
                    120,
                    121,
                    122,
                    123,
                    124,
                    125,
                    126,
                    127,
                    128,
                    129,
                    130,
                    131,
                    132,
                    133,
                    134,
                    135,
                    136,
                    137,
                    138,
                    139
                ],
                [
                    110,
                    111,
                    112,
                    113,
                    114,
                    115,
                    116,
                    117,
                    118,
                    119,
                    120,
                    121,
                    122,
                    123,
                    124,
                    125,
                    126,
                    127,
                    128,
                    129,
                    130,
                    131,
                    132,
                    133,
                    134,
                    135,
                    136,
                    137,
                    138,
                    139,
                    140
                ],
                [
                    110,
                    111,
                    112,
                    113,
                    114,
                    115,
                    116,
                    117,
                    118,
                    119,
                    120,
                    121,
                    122,
                    123,
                    124,
                    125,
                    126,
                    127,
                    128,
                    129,
                    130,
                    131,
                    132,
                    133,
                    134,
                    135,
                    136,
                    137,
                    138,
                    139,
                    140,
                    141
                ]
            ],
            "outputs": [
                12,
                4,
                78,
                79,
                81,
                82,
                84,
                85,
                87,
                88,
                90,
                91,
                93,
                94,
                96,
                97,
                99,
                100,
                102,
                103
            ]
        },
        "sample_code": {
            "c++": "int sum(TreeNode* root, int val) {\n    if (!root) return 0;\n    val = val * 10 + root->val;\n    if (!root->left && !root->right) return val;\n    return sum(root->left, val) + sum(root->right, val);\n}\n\nint pathSum(vector<int>& nums) {\n    TreeNode* root = new TreeNode(nums[0] % 10);\n    for (int num : nums) {\n        int depth = num / 100, pos = num % 100 / 10, val = num % 10;\n        TreeNode* cur = root;\n        for (int d = depth - 2; d >= 0; --d) {\n            if ((pos >> d) & 1) {\n                if (!cur->right) cur->right = new TreeNode(val);\n                cur = cur->right;\n            } else {\n                if (!cur->left) cur->left = new TreeNode(val);\n                cur = cur->left;\n            }\n        }\n    }\n    return sum(root, 0);\n}\n",
            "java": "public int sum(TreeNode root, int val) {\n    if (root == null) return 0;\n    val = val * 10 + root.val;\n    if (root.left == null && root.right == null) return val;\n    return sum(root.left, val) + sum(root.right, val);\n}\n\npublic int pathSum(int[] nums) {\n    TreeNode root = new TreeNode(nums[0] % 10);\n    for (int num : nums) {\n        int depth = num / 100;\n        int pos = num % 100 / 10;\n        int val = num % 10;\n        TreeNode cur = root;\n        for (int d = depth - 2; d >= 0; --d) {\n            if ((pos >> d) & 1) {\n                if (cur.right == null) cur.right = new TreeNode(val);\n                cur = cur.right;\n            } else {\n                if (cur.left == null) cur.left = new TreeNode(val);\n                cur = cur.left;\n            }\n        }\n    }\n    return sum(root, 0);\n}\n",
            "python": "def sumPaths(root, val):\n    if not root: return 0\n    val = val * 10 + root.val\n    if not root.left and not root.right: return val\n    return sumPaths(root.left, val) + sumPaths(root.right, val)\n\ndef pathSum(nums):\n    root = TreeNode(nums[0] % 10)\n    for num in nums:\n        depth, pos, val = num // 100, num % 100 // 10, num % 10\n        cur = root\n        for d in reversed(range(depth - 1)):\n            if (pos >> d) & 1:\n                if not cur.right: cur.right = TreeNode(val)\n                cur = cur.right\n            else:\n                if not cur.left: cur.left = TreeNode(val)\n                cur = cur.left\n    return sumPaths(root, 0)\n",
            "javascript": "function sum(root, val) {\n    if (!root) return 0;\n    val = val * 10 + root.val;\n    if (!root.left && !root.right) return val;\n    return sum(root.left, val) + sum(root.right, val);\n}\n\nfunction pathSum(nums) {\n    const root = new TreeNode(nums[0] % 10);\n    for (const num of nums) {\n        const depth = Math.floor(num / 100);\n        const pos = Math.floor(num % 100 / 10);\n        const val = num % 10;\n        let cur = root;\n        for (let d = depth - 2; d >= 0; --d) {\n            if ((pos >> d) & 1) {\n                if (!cur.right) cur.right = new TreeNode(val);\n                cur = cur.right;\n            } else {\n                if (!cur.left) cur.left = new TreeNode(val);\n                cur = cur.left;\n            }\n        }\n    }\n    return sum(root, 0);\n}\n",
            "explanation": "The algorithm builds the binary tree from the input array `nums`, constructs a TreeNode for each element in `nums`:\n1. The TreeNode constructor takes the value of the node, which is the units digit.\n2. The element is then divided by 100 to get the depth, and modulo 100 is taken and then divided by 10 to get the position.\n3. Traversing level by level, the nodes are inserted, updating the left or right child pointer accordingly.\n\nAfter building the tree, the `sum` function is called to calculate the path sum of the tree, passing the root node and the current sum value as parameters. It recursively calculates the path sum for each child, updating the sum and returning it when the leaf node is reached.\n\nAt the end, the total path sum is returned."
        },
        "structure": {
            "c++": "int sum(TreeNode* root, int val) \n    // Your code here\n}\n",
            "java": "public int sum(TreeNode root, int val) \n    // Your code here\n}\n",
            "python": "def sumPaths(root, val):\n    # Your code here\n\n",
            "javascript": "function sum(root, val) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> nums = $args;\n    int result = pathSum(nums);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int pathSum(int[] nums) {\n    TreeNode root = new TreeNode(nums[0] % 10);\n    for (int num : nums) {\n        int depth = num / 100;\n        int pos = num % 100 / 10;\n        int val = num % 10;\n        TreeNode cur = root;\n        for (int d = depth - 2; d >= 0; --d) {\n            if ((pos >> d) & 1) {\n                if (cur.right == null) cur.right = new TreeNode(val);\n                cur = cur.right;\n            } else {\n                if (cur.left == null) cur.left = new TreeNode(val);\n                cur = cur.left;\n            }\n        }\n    }\n    return sum(root, 0);\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = pathSum(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = pathSum(nums);\n    console.log(result);\n}"
        }
    },
    "668": {
        "title": "Kth Smallest Element in Multiplication Table",
        "description": "Given a multiplication table of size `m x n`, where each element `mat[i][j]` is equal to `i * j` (1-indexed), find the `kth` smallest element in the table.",
        "example": "For example, given `m = 3`, `n = 3`, and `k = 5`, the multiplication table looks like this:\n\n1 2 3\n2 4 6\n3 6 9\n\nThe 5th smallest element in the table is 3.\n\n",
        "level": "Medium",
        "tags": [
            "array",
            "math"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    3,
                    5
                ],
                [
                    2,
                    3,
                    6
                ],
                [
                    4,
                    4,
                    10
                ],
                [
                    5,
                    5,
                    15
                ],
                [
                    2,
                    5,
                    8
                ],
                [
                    3,
                    4,
                    7
                ],
                [
                    10,
                    10,
                    50
                ],
                [
                    100,
                    100,
                    10000
                ],
                [
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    2
                ],
                [
                    2,
                    2,
                    3
                ],
                [
                    5,
                    10,
                    25
                ],
                [
                    10,
                    5,
                    25
                ],
                [
                    10,
                    10,
                    100
                ],
                [
                    100,
                    1,
                    100
                ],
                [
                    1,
                    100,
                    100
                ],
                [
                    100,
                    100,
                    1000
                ],
                [
                    1000,
                    1000,
                    1000000
                ],
                [
                    10000,
                    10000,
                    100000000
                ],
                [
                    100000,
                    100000,
                    10000000000
                ]
            ],
            "outputs": [
                3,
                6,
                6,
                9,
                5,
                6,
                25,
                10000,
                1,
                2,
                2,
                25,
                25,
                100,
                100,
                100,
                1000,
                1000000,
                100000000,
                10000000000
            ]
        },
        "sample_code": {
            "c++": "int findKthNumber(int m, int n, int k) {\n    int low = 1, high = m * n;\n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        int count = 0;\n        for (int i = 1; i <= m; i++) {\n            count += std::min(mid / i, n);\n        }\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}\n",
            "java": "public int findKthNumber(int m, int n, int k) {\n    int low = 1, high = m * n;\n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        int count = 0;\n        for (int i = 1; i <= m; i++) {\n            count += Math.min(mid / i, n);\n        }\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}\n",
            "python": "def findKthNumber(m, n, k):\n    low, high = 1, m * n\n    while low < high:\n        mid = low + (high - low) // 2\n        count = 0\n        for i in range(1, m+1):\n            count += min(mid // i, n)\n        if count < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n",
            "javascript": "function findKthNumber(m, n, k) {\n    let low = 1, high = m * n;\n    while (low < high) {\n        let mid = low + Math.floor((high - low) / 2);\n        let count = 0;\n        for (let i = 1; i <= m; i++) {\n            count += Math.min(Math.floor(mid / i), n);\n        }\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}\n",
            "explanation": "We need to find the kth smallest element in an m x n multiplication table. The table is naturally sorted, so we can use binary search to find the desired element. We start with `low` as 1 and `high` as m * n. Our search space is between these values.\n\nIn each iteration, we look for the middle value `mid`. For each row `i`, we count the number of elements that are less than or equal to `mid`. The count is the sum of either `mid // i` or `n`, whichever is smaller. Then we check if the count is less than or equal to `k`. If it is, we move `low` to `mid + 1`; otherwise, we move `high` to `mid`. Once the search space narrowed down to a single value, we return that value as the kth smallest element in the m x n multiplication table."
        },
        "structure": {
            "c++": "int findKthNumber(int m, int n, int k) \n    // Your code here\n}\n",
            "java": "public int findKthNumber(int m, int n, int k) \n    // Your code here\n}\n",
            "python": "def findKthNumber(m, n, k):\n    # Your code here\n\n",
            "javascript": "function findKthNumber(m, n, k) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int m = $args;\n    int n = $args;\n    int k = $args;\n    int result = findKthNumber(m, n, k);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int findKthNumber(int m, int n, int k) {\n    int low = 1, high = m * n;\n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        int count = 0;\n        for (int i = 1; i <= m; i++) {\n            count += Math.min(mid / i, n);\n        }\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}",
            "python": "if __name__ == \"__main__\":\n    m = $args[0]\n    n = $args[1]\n    k = $args[2]\n    result = findKthNumber(m, n, k)\n    print(result)",
            "javascript": "function main() {\n    const m = $args[0];\n    const n = $args[1];\n    const k = $args[2];\n    const result = findKthNumber(m, n, k);\n    console.log(result);\n}"
        }
    },
    "670": {
        "title": "Maximum Valued Number",
        "description": "Given an integer `num`, you can swap two digits at most once to get the maximum valued number. Return the maximum valued number you can get.",
        "example": "Example:\n\nInput: num = 2736\nOutput: 7236\nExplanation: Swap the number 2 and the number 7.",
        "level": "Easy",
        "tags": [
            "math",
            "greedy"
        ],
        "test_cases": {
            "inputs": [
                2736,
                9973,
                0,
                12345,
                9876543210,
                1111,
                2222,
                3333,
                4444,
                5555,
                6666,
                7777,
                8888,
                9999,
                1234567890,
                987654321,
                1000000000,
                1000000001,
                1000000002,
                1000000003
            ],
            "outputs": [
                7236,
                9973,
                0,
                52341,
                9876543210,
                1111,
                2222,
                3333,
                4444,
                5555,
                6666,
                7777,
                8888,
                9999,
                9234567810,
                987654321,
                1000000000,
                1000000010,
                1000000100,
                1000001000
            ]
        },
        "sample_code": {
            "c++": "int maximumSwap(int num) {\n    string num_str = to_string(num);\n    vector<int> last(10, 0);\n    \n    for (int i = 0; i < num_str.size(); i++) {\n        last[num_str[i] - '0'] = i;\n    }\n    \n    for (int i = 0; i < num_str.size(); i++) {\n        for (int d = 9; d > num_str[i] - '0'; d--) {\n            if (last[d] > i) {\n                swap(num_str[i], num_str[last[d]]);\n                return stoi(num_str);\n            }\n        }\n    }\n    \n    return num;\n}\n",
            "java": "public int maximumSwap(int num) {\n    char[] num_str = Integer.toString(num).toCharArray();\n    int[] last = new int[10];\n    \n    for (int i = 0; i < num_str.length; i++) {\n        last[num_str[i] - '0'] = i;\n    }\n    \n    for (int i = 0; i < num_str.length; i++) {\n        for (int d = 9; d > num_str[i] - '0'; d--) {\n            if (last[d] > i) {\n                swap(num_str, i, last[d]);\n                return Integer.parseInt(new String(num_str));\n            }\n        }\n    }\n    \n    return num;\n}\n\nprivate void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n",
            "python": "def maximumSwap(num):\n    num_str = list(str(num))\n    last = {int(v): i for i, v in enumerate(num_str)}\n\n    for i, v in enumerate(num_str):\n        for d in range(9, int(v), -1):\n            if last.get(d, -1) > i:\n                num_str[i], num_str[last[d]] = num_str[last[d]], num_str[i]\n                return int(\"\".join(num_str))\n\n    return num\n",
            "javascript": "function maximumSwap(num) {\n    let num_str = Array.from(num.toString());\n    let last = new Array(10).fill(0);\n    \n    for (let i = 0; i < num_str.length; i++) {\n        last[parseInt(num_str[i])] = i;\n    }\n    \n    for (let i = 0; i < num_str.length; i++) {\n        for (let d = 9; d > parseInt(num_str[i]); d--) {\n            if (last[d] > i) {\n                [num_str[i], num_str[last[d]]] = [num_str[last[d]], num_str[i]];\n                return parseInt(num_str.join(''));\n            }\n        }\n    }\n    \n    return num;\n}\n",
            "explanation": "1. Convert the input number to a string (num_str) so that we can manipulate individual digits easily.\n2. Create an array (last) to store the last occurrences of each digit, and populate it by iterating through num_str.\n3. Iterate through num_str; for each digit, check if there is a larger digit that appears later in the number.\n   - If there is, swap the current digit with the larger digit and return the result as an integer.\n4. If no suitable pair of digits is found to swap, return the original input."
        },
        "structure": {
            "c++": "int maximumSwap(int num) \n    // Your code here\n}\n",
            "java": "public int maximumSwap(int num) \n    // Your code here\n}\n",
            "python": "def maximumSwap(num):\n    # Your code here\n\n",
            "javascript": "function maximumSwap(num) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int num = $args;\n    int result = maximumSwap(num);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int maximumSwap(int num) {\n    char[] num_str = Integer.toString(num).toCharArray();\n    int[] last = new int[10];\n    \n    for (int i = 0; i < num_str.length; i++) {\n        last[num_str[i] - '0'] = i;\n    }\n    \n    for (int i = 0; i < num_str.length; i++) {\n        for (int d = 9; d > num_str[i] - '0'; d--) {\n            if (last[d] > i) {\n                swap(num_str, i, last[d]);\n                return Integer.parseInt(new String(num_str));\n            }\n        }\n    }\n    \n    return num;\n}\n\nprivate void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}",
            "python": "if __name__ == \"__main__\":\n    num = $args[0]\n    result = maximumSwap(num)\n    print(result)",
            "javascript": "function main() {\n    const num = $args;\n    const result = maximumSwap(num);\n    console.log(result);\n}"
        }
    },
    "672": {
        "title": "Bulb Status",
        "description": "You are given a room with `n` bulbs labeled from `1` to `n` that are all turned on initially. There are four buttons on the wall, each with a different functionality. Button 1 flips the status of all the bulbs, Button 2 flips the status of all the bulbs with even labels, Button 3 flips the status of all the bulbs with odd labels, and Button 4 flips the status of all the bulbs with a label `j = 3k + 1` where `k = 0, 1, 2, ...`. You need to perform exactly `presses` button presses in total. For each press, you can choose any of the four buttons. Return the number of different possible statuses after performing all the button presses.",
        "example": "Example:\n\nInput: n = 3, presses = 1\nOutput: 4\nExplanation: The possible statuses are:\n- [off, off, off] by pressing button 1\n- [off, on, off] by pressing button 2\n- [on, off, on] by pressing button 3\n- [off, on, on] by pressing button 4",
        "level": "Medium",
        "tags": [
            "Math",
            "Simulation"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    1
                ],
                [
                    2,
                    1
                ],
                [
                    3,
                    1
                ],
                [
                    4,
                    2
                ],
                [
                    5,
                    3
                ],
                [
                    6,
                    4
                ],
                [
                    7,
                    5
                ],
                [
                    8,
                    6
                ],
                [
                    9,
                    7
                ],
                [
                    10,
                    8
                ],
                [
                    100,
                    10
                ],
                [
                    1000,
                    20
                ],
                [
                    1000,
                    100
                ],
                [
                    1000,
                    500
                ],
                [
                    1000,
                    1000
                ]
            ],
            "outputs": [
                2,
                3,
                4,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                10,
                10,
                10,
                10,
                10
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nint numLightConfiguration(int n, int presses) {\n    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(presses + 1, 0));\n    dp[0][0] = 1;\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 1; j <= presses; ++j) {\n            dp[i][j] = dp[i][j - 1] * (i + 1) + (i > 0 ? dp[i - 1][j - 1] : 0);\n        }\n    }\n\n    return dp[n][presses];\n}\n",
            "java": "public int numLightConfiguration(int n, int presses) {\n    int[][] dp = new int[n + 1][presses + 1];\n    dp[0][0] = 1;\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 1; j <= presses; ++j) {\n            dp[i][j] = dp[i][j - 1] * (i + 1) + (i > 0 ? dp[i - 1][j - 1] : 0);\n        }\n    }\n\n    return dp[n][presses];\n}\n",
            "python": "def num_light_configuration(n, presses):\n    dp = [[0] * (presses + 1) for _ in range(n+1)]\n    dp[0][0] = 1\n\n    for i in range(n + 1):\n        for j in range(1, presses + 1):\n            dp[i][j] = dp[i][j - 1] * (i + 1) + (dp[i - 1][j - 1] if i > 0 else 0)\n\n    return dp[n][presses]\n",
            "javascript": "function numLightConfiguration(n, presses) {\n    let dp = new Array(n + 1).fill(0).map(() => new Array(presses + 1).fill(0));\n    dp[0][0] = 1;\n\n    for (let i = 0; i <= n; ++i) {\n        for (let j = 1; j <= presses; ++j) {\n            dp[i][j] = dp[i][j - 1] * (i + 1) + (i > 0 ? dp[i - 1][j - 1] : 0);\n        }\n    }\n\n    return dp[n][presses];\n}\n",
            "explanation": "1. Create a dynamic programming `dp` matrix, where `dp[i][j]` represents the number of different configurations possible after `j` button-press operations with only `i` bulbs.\n2. Initialize `dp[0][0]` to 1, which means there is 1 way to have 0 bulbs (i.e., do nothing).\n3. Iterate through `i` bulbs and `j` button-press operations.\n4. For each button press, there are 4 possible operations:\n    a. Turn off all bulbs.\n    b. Turn off even numbered bulbs.\n    c. Turn off odd numbered bulbs.\n    d. Turn off bulbs whose index is a multiple of 3.\n5. Update the `dp[i][j]` value by the operations that can be performed on this configuration.\n6. Return `dp[n][presses]` which represents the final number of different possible statuses after performing all presses button presses."
        },
        "structure": {
            "c++": "#include <vector>\n\nint numLightConfiguration(int n, int presses) \n    // Your code here\n}\n",
            "java": "public int numLightConfiguration(int n, int presses) \n    // Your code here\n}\n",
            "python": "def num_light_configuration(n, presses):\n    # Your code here\n\n",
            "javascript": "function numLightConfiguration(n, presses) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nint main() {\n    int n = $args;\n    int presses = $args;\n    int result = numLightConfiguration(n, presses);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int numLightConfiguration(int n, int presses) {\n    int[][] dp = new int[n + 1][presses + 1];\n    dp[0][0] = 1;\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 1; j <= presses; ++j) {\n            dp[i][j] = dp[i][j - 1] * (i + 1) + (i > 0 ? dp[i - 1][j - 1] : 0);\n        }\n    }\n\n    return dp[n][presses];\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    presses = $args[1]\n    result = num_light_configuration(n, presses)\n    print(result)",
            "javascript": "function numLightConfiguration(n, presses) {\n    const dp = new Array(n + 1).fill(0).map(() => new Array(presses + 1).fill(0));\n    dp[0][0] = 1;\n\n    for (let i = 0; i <= n; ++i) {\n        for (let j = 1; j <= presses; ++j) {\n            dp[i][j] = dp[i][j - 1] * (i + 1) + (i > 0 ? dp[i - 1][j - 1] : 0);\n        }\n    }\n\n    const result = dp[n][presses];\n    console.log(result);\n}"
        }
    },
    "673": {
        "title": "Number of Longest Increasing Subsequences",
        "description": "Given an integer array `nums`, return the number of longest increasing subsequences. The sequence has to be strictly increasing.",
        "example": "Example:\n\nInput: nums = [1,3,5,4,7]\nOutput: 2\nExplanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    3,
                    5,
                    4,
                    7
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    10,
                    9,
                    2,
                    5,
                    3,
                    7,
                    101,
                    18
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ]
            ],
            "outputs": [
                2,
                5,
                5,
                1,
                4,
                10,
                1,
                20,
                20,
                20
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nint findNumberOfLIS(std::vector<int>& nums) {\n    int n = nums.size(), maxLength = 0, ans = 0;\n    std::vector<int> length(n, 0), count(n, 0);\n\n    for (int i = 0; i < n; ++i) {\n        length[i] = count[i] = 1;\n        for (int j = 0; j < i; ++j) {\n            if (nums[i] > nums[j]) {\n                if (length[i] == length[j] + 1) {\n                    count[i] += count[j];\n                } else if (length[i] < length[j] + 1) {\n                    length[i] = length[j] + 1;\n                    count[i] = count[j];\n                }\n            }\n        }\n        if (maxLength == length[i]) {\n            ans += count[i];\n        } else if (maxLength < length[i]) {\n            maxLength = length[i];\n            ans = count[i];\n        }\n    }\n\n    return ans;\n}\n\n",
            "java": "public int findNumberOfLIS(int[] nums) {\n    int n = nums.length, maxLength = 0, ans = 0;\n    int[] length = new int[n];\n    int[] count = new int[n];\n\n    for (int i = 0; i < n; ++i) {\n        length[i] = count[i] = 1;\n        for (int j = 0; j < i; ++j) {\n            if (nums[i] > nums[j]) {\n                if (length[i] == length[j] + 1) {\n                    count[i] += count[j];\n                } else if (length[i] < length[j] + 1) {\n                    length[i] = length[j] + 1;\n                    count[i] = count[j];\n                }\n            }\n        }\n        if (maxLength == length[i]) {\n            ans += count[i];\n        } else if (maxLength < length[i]) {\n            maxLength = length[i];\n            ans = count[i];\n        }\n    }\n\n    return ans;\n}\n\n",
            "python": "def findNumberOfLIS(nums):\n    n = len(nums)\n    maxLength = ans = 0\n    length = [1] * n\n    count = [1] * n\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                if length[i] == length[j] + 1:\n                    count[i] += count[j]\n                elif length[i] < length[j] + 1:\n                    length[i] = length[j] + 1\n                    count[i] = count[j]\n        if maxLength == length[i]:\n            ans += count[i]\n        elif maxLength < length[i]:\n            maxLength = length[i]\n            ans = count[i]\n\n    return ans\n\n",
            "javascript": "function findNumberOfLIS(nums) {\n    const n = nums.length;\n    let maxLength = 0, ans = 0;\n    const length = new Array(n).fill(1);\n    const count = new Array(n).fill(1);\n\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < i; ++j) {\n            if (nums[i] > nums[j]) {\n                if (length[i] === length[j] + 1) {\n                    count[i] += count[j];\n                } else if (length[i] < length[j] + 1) {\n                    length[i] = length[j] + 1;\n                    count[i] = count[j];\n                }\n            }\n        }\n        if (maxLength === length[i]) {\n            ans += count[i];\n        } else if (maxLength < length[i]) {\n            maxLength = length[i];\n            ans = count[i];\n        }\n    }\n\n    return ans;\n}\n\n",
            "explanation": "The algorithm uses dynamic programming to find the number of longest increasing subsequences. We use two arrays, `length` and `count`. `length[i]` stores the length of the longest increasing subsequence ending at the index `i`, and `count[i]` stores the number of longest increasing subsequences ending at the index `i`.\n\n1. Initialize `maxLength` and `ans` to `0`.\n2. Initialize the `length` and `count` arrays to all have a value of `1`.\n3. Loop through the `nums` array using variable `i`.\n    a. Loop from `0` to `i - 1` using a variable `j`.\n        i. If `nums[i] > nums[j]`, update the values of `length[i]` and `count[i]` based on their current values and the values at index `j`. The rule for this is:\n            * If `length[i] == length[j] + 1`, increase `count[i]` by `count[j]`.\n            * If `length[i] < length[j] + 1`, update `length[i]` to `length[j] + 1` and update `count[i]` to `count[j]`.\n    b. If `maxLength` is equal to `length[i]`, increment `ans` by `count[i]`. If `maxLength` is less than `length[i]`, update `maxLength` to equal `length[i]` and update `ans` to equal `count[i]`.\n4. Return `ans` as the final result.\n\nThis algorithm has a time complexity of O(n^2) and a space complexity of O(n)."
        },
        "structure": {
            "c++": "#include <vector>\n\nint findNumberOfLIS(std::vector<int>& nums) \n    // Your code here\n}\n\n",
            "java": "public int findNumberOfLIS(int[] nums) \n    // Your code here\n}\n\n",
            "python": "def findNumberOfLIS(nums):\n    # Your code here\n\n",
            "javascript": "function findNumberOfLIS(nums) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nint main() {\n    std::vector<int> nums = $args;\n    int result = findNumberOfLIS(nums);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public int findNumberOfLIS(int[] nums) {\n    int n = nums.length, maxLength = 0, ans = 0;\n    int[] length = new int[n];\n    int[] count = new int[n];\n\n    for (int i = 0; i < n; ++i) {\n        length[i] = count[i] = 1;\n        for (int j = 0; j < i; ++j) {\n            if (nums[i] > nums[j]) {\n                if (length[i] == length[j] + 1) {\n                    count[i] += count[j];\n                } else if (length[i] < length[j] + 1) {\n                    length[i] = length[j] + 1;\n                    count[i] = count[j];\n                }\n            }\n        }\n        if (maxLength == length[i]) {\n            ans += count[i];\n        } else if (maxLength < length[i]) {\n            maxLength = length[i];\n            ans = count[i];\n        }\n    }\n\n    return ans;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = findNumberOfLIS(nums)\n    print(result)",
            "javascript": "function findNumberOfLIS(nums) {\n    const n = nums.length;\n    let maxLength = 0, ans = 0;\n    const length = new Array(n).fill(1);\n    const count = new Array(n).fill(1);\n\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < i; ++j) {\n            if (nums[i] > nums[j]) {\n                if (length[i] === length[j] + 1) {\n                    count[i] += count[j];\n                } else if (length[i] < length[j] + 1) {\n                    length[i] = length[j] + 1;\n                    count[i] = count[j];\n                }\n            }\n        }\n        if (maxLength === length[i]) {\n            ans += count[i];\n        } else if (maxLength < length[i]) {\n            maxLength = length[i];\n            ans = count[i];\n        }\n    }\n\n    return ans;\n}"
        }
    },
    "678": {
        "title": "Valid Parenthesis String",
        "description": "Given a string `s` containing only three types of characters: `'('`, `')'` and `'*'`, return `true` if `s` is valid. The following rules define a valid string: \n\n- Any left parenthesis `'('` must have a corresponding right parenthesis `')'`. \n- Any right parenthesis `')'` must have a corresponding left parenthesis `'('`. \n- Left parenthesis `'('` must go before the corresponding right parenthesis `')'`. \n- `'*'` could be treated as a single right parenthesis `')'` or a single left parenthesis `'('` or an empty string `\"\"`.",
        "example": "Example 1:\n\nInput: s = \"()\"\nOutput: true\n\nExample 2:\n\nInput: s = \"(*)\"\nOutput: true\n\nExample 3:\n\nInput: s = \"(*))\"\nOutput: true",
        "level": "Easy",
        "tags": [
            "string",
            "stack"
        ],
        "test_cases": {
            "inputs": [
                "\"()\"",
                "\"(*)\"",
                "\"(*))\"",
                "\"(((**\"",
                "\"((*)\"",
                "\"(*)))\"",
                "\"((**))\"",
                "\"((**)))\"",
                "\"((**)))*\"",
                "\"((**)))*(\"",
                "\"((**)))*()\"",
                "\"((**)))*()(\"",
                "\"((**)))*()()\"",
                "\"((**)))*()()(\"",
                "\"((**)))*()()()\"",
                "\"((**)))*()()()(\"",
                "\"((**)))*()()()()\"",
                "\"((**)))*()()()()(\"",
                "\"((**)))*()()()()()\"",
                "\"((**)))*()()()()()(\""
            ],
            "outputs": [
                true,
                true,
                true,
                false,
                true,
                true,
                true,
                true,
                false,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false
            ]
        },
        "sample_code": {
            "c++": "bool checkValidString(string s) {\n    int left_balance = 0, right_balance = 0;\n\n    for (int i = 0; i < s.size(); i++) {\n        left_balance += (s[i] == '(' || s[i] == '*') ? 1 : -1;\n        right_balance += (s[s.size() - 1 - i] == ')' || s[s.size() - 1 - i] == '*') ? 1 : -1;\n\n        if (left_balance < 0 || right_balance < 0)\n            return false;\n    }\n\n    return true;\n}\n\n",
            "java": "public boolean checkValidString(String s) {\n    int left_balance = 0, right_balance = 0;\n\n    for (int i = 0; i < s.length(); i++) {\n        left_balance += (s.charAt(i) == '(' || s.charAt(i) == '*') ? 1 : -1;\n        right_balance += (s.charAt(s.length() - 1 - i) == ')' || s.charAt(s.length() - 1 - i) == '*') ? 1 : -1;\n\n        if (left_balance < 0 || right_balance < 0)\n            return false;\n    }\n\n    return true;\n}\n\n",
            "python": "def checkValidString(s: str) -> bool:\n    left_balance, right_balance = 0, 0\n\n    for i in range(len(s)):\n        left_balance += 1 if s[i] == '(' or s[i] == '*' else -1\n        right_balance += 1 if s[len(s) - 1 - i] == ')' or s[len(s) - 1 - i] == '*' else -1\n\n        if left_balance < 0 or right_balance < 0:\n            return False\n\n    return True\n\n",
            "javascript": "function checkValidString(s) {\n    let left_balance = 0, right_balance = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        left_balance += (s[i] === '(' || s[i] === '*') ? 1 : -1;\n        right_balance += (s[s.length - 1 - i] === ')' || s[s.length - 1 - i] === '*') ? 1 : -1;\n\n        if (left_balance < 0 || right_balance < 0)\n            return false;\n    }\n\n    return true;\n}\n\n",
            "explanation": "The algorithm uses the greedy approach by keeping count of the possible balance of left and right parentheses with two variables `left_balance` and `right_balance`. \n\nWe iterate through the string in both forward and reverse direction looking at balance of the parentheses. The '*' character is treated as a left parenthesis when iterating forward, and as a right parenthesis when iterating in reverse. If at any point either balance is negative, we return false, as it is not a valid string.\n\nIf we successfully finish the iteration without returning false, it means the string is valid, and we return true."
        },
        "structure": {
            "c++": "bool checkValidString(string s) \n    // Your code here\n}\n\n",
            "java": "public boolean checkValidString(String s) \n    // Your code here\n}\n\n",
            "python": "def checkValidString(s: str) -> bool:\n    # Your code here\n\n",
            "javascript": "function checkValidString(s) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "bool checkValidString(string s) {\n    int left_balance = 0, right_balance = 0;\n\n    for (int i = 0; i < s.size(); i++) {\n        left_balance += (s[i] == '(' || s[i] == '*') ? 1 : -1;\n        right_balance += (s[s.size() - 1 - i] == ')' || s[s.size() - 1 - i] == '*') ? 1 : -1;\n\n        if (left_balance < 0 || right_balance < 0)\n            return false;\n    }\n\n    return true;\n}\n\nint main() {\n    string s = $args;\n    bool result = checkValidString(s);\n    cout << boolalpha << result << endl;\n    return 0;\n}",
            "java": "public boolean checkValidString(String s) {\n    int left_balance = 0, right_balance = 0;\n\n    for (int i = 0; i < s.length(); i++) {\n        left_balance += (s.charAt(i) == '(' || s.charAt(i) == '*') ? 1 : -1;\n        right_balance += (s.charAt(s.length() - 1 - i) == ')' || s.charAt(s.length() - 1 - i) == '*') ? 1 : -1;\n\n        if (left_balance < 0 || right_balance < 0)\n            return false;\n    }\n\n    return true;\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args[0]\n    result = checkValidString(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = checkValidString(s);\n    console.log(result);\n}"
        }
    },
    "679": {
        "title": "Expression Evaluation",
        "description": "You are given an integer array `cards` of length `4`. You have four cards, each containing a number in the range `[1, 9]`. You should arrange the numbers on these cards in a mathematical expression using the operators `['+', '-', '*', '/']` and the parentheses `'('` and `')'` to get the value 24. You are restricted with the following rules:\n\n- The division operator `'/'` represents real division, not integer division.\n- Every operation done is between two numbers. In particular, we cannot use `'-'` as a unary operator.\n- You cannot concatenate numbers together.\n\nWrite a function `evaluateExpression(cards: List[int]) -> bool` that returns `true` if it is possible to arrange the numbers on the cards to evaluate to 24, and `false` otherwise.",
        "example": "Example:\n\nInput: cards = [4, 1, 8, 7]\nOutput: true\nExplanation: (8-4) * (7-1) = 24",
        "level": "Medium",
        "tags": [
            "Math",
            "Recursion"
        ],
        "test_cases": {
            "inputs": [
                [
                    4,
                    1,
                    8,
                    7
                ],
                [
                    1,
                    2,
                    1,
                    2
                ],
                [
                    9,
                    9,
                    9,
                    9
                ],
                [
                    1,
                    1,
                    1,
                    6
                ],
                [
                    3,
                    3,
                    8,
                    8
                ],
                [
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    1,
                    1,
                    1
                ],
                [
                    9,
                    8,
                    7,
                    6
                ],
                [
                    5,
                    5,
                    5,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4
                ],
                [
                    9,
                    1,
                    2,
                    3
                ],
                [
                    1,
                    9,
                    2,
                    3
                ],
                [
                    1,
                    2,
                    9,
                    3
                ],
                [
                    1,
                    2,
                    3,
                    9
                ],
                [
                    9,
                    9,
                    9,
                    1
                ],
                [
                    9,
                    9,
                    1,
                    9
                ],
                [
                    9,
                    1,
                    9,
                    9
                ],
                [
                    1,
                    9,
                    9,
                    9
                ],
                [
                    9,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    9,
                    1,
                    1
                ]
            ],
            "outputs": [
                true,
                false,
                false,
                true,
                true,
                true,
                false,
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <cmath>\n\nbool helper(std::vector<double>& cards) {\n    if (cards.size() == 1) {\n        return std::abs(cards[0] - 24) < 1e-6;\n    }\n\n    for (int i = 0; i < cards.size(); ++i) {\n        for (int j = i + 1; j < cards.size(); ++j) {\n            double a = cards[i], b = cards[j];\n            std::vector<double> next = {a + b, a - b, a * b, a / b};\n\n            cards.erase(cards.begin() + j);\n            cards.erase(cards.begin() + i);\n\n            for (auto& e : next) {\n                cards.push_back(e);\n                if (helper(cards)) {\n                    return true;\n                }\n                cards.pop_back();\n            }\n\n            cards.insert(cards.begin() + i, a);\n            cards.insert(cards.begin() + j, b);\n        }\n    }\n    return false;\n}\n\nbool canGet24(std::vector<int>& cards) {\n    std::vector<double> doubleCards(cards.begin(), cards.end());\n    return helper(doubleCards);\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic boolean helper(List<Double> cards) {\n    if (cards.size() == 1) {\n        return Math.abs(cards.get(0) - 24) < 1e-6;\n    }\n\n    for (int i = 0; i < cards.size(); ++i) {\n        for (int j = i + 1; j < cards.size(); ++j) {\n            double a = cards.get(i), b = cards.get(j);\n            List<Double> next = Arrays.asList(a + b, a - b, a * b, a / b);\n\n            cards.remove(j);\n            cards.remove(i);\n\n            for (Double e : next) {\n                cards.add(e);\n                if (helper(cards)) {\n                    return true;\n                }\n                cards.remove(cards.size() - 1);\n            }\n\n            cards.add(i, a);\n            cards.add(j, b);\n        }\n    }\n    return false;\n}\n\npublic boolean canGet24(int[] cards) {\n    List<Double> doubleCards = new ArrayList<>();\n    for (int card : cards) {\n        doubleCards.add((double) card);\n    }\n    return helper(doubleCards);\n}\n\n",
            "python": "from itertools import permutations\n\ndef helper(cards, target=24):\n    if len(cards) == 1:\n        return abs(cards[0] - target) < 1e-6\n\n    for i in range(len(cards)):\n        for j in range(i + 1, len(cards)):\n            a, b = cards[i], cards[j]\n            rest = [cards[k] for k in range(len(cards)) if k != i and k != j]\n            for e in a + b, a - b, a * b, a / b:\n                if helper(rest + [e]):\n                    return True\n    return False\n\ndef canGet24(cards):\n    return helper(cards)\n\n",
            "javascript": "function helper(cards) {\n  if (cards.length === 1) {\n    return Math.abs(cards[0] - 24) < 1e-6;\n  }\n\n  for (let i = 0; i < cards.length; ++i) {\n    for (let j = i + 1; j < cards.length; ++j) {\n      const a = cards[i], b = cards[j];\n      const next = [a + b, a - b, a * b, a / b];\n\n      cards.splice(j, 1);\n      cards.splice(i, 1);\n\n      for (const e of next) {\n        cards.push(e);\n        if (helper(cards)) {\n          return true;\n        }\n        cards.pop();\n      }\n\n      cards.splice(i, 0, a);\n      cards.splice(j, 0, b);\n    }\n  }\n  return false;\n}\n\nfunction canGet24(cards) {\n  return helper(cards);\n}\n\n",
            "explanation": "The algorithm uses a recursive approach to generate all possible combinations of operations between the operands. For every possible pair of cards, we apply all the operations and call the helper function with the result and the cards left.\n\nIn the base case when there is only one card left, we check if the remaining value is almost equal to the target value (24). If it is, we return true.\n\nIf all possible combinations have been checked and none of them returns true, we return false."
        },
        "structure": {
            "c++": "#include <vector>\n#include <cmath>\n\nbool helper(std::vector<double>& cards) \n    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic boolean helper(List<Double> cards) \n    // Your code here\n}\n\n",
            "python": "from itertools import permutations\n    # Your code here\n\n",
            "javascript": "function helper(cards) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <cmath>\n#include <iostream>\n\nbool helper(std::vector<double>& cards) {\n    if (cards.size() == 1) {\n        return std::abs(cards[0] - 24) < 1e-6;\n    }\n\n    for (int i = 0; i < cards.size(); ++i) {\n        for (int j = i + 1; j < cards.size(); ++j) {\n            double a = cards[i], b = cards[j];\n            std::vector<double> next = {a + b, a - b, a * b, a / b};\n\n            cards.erase(cards.begin() + j);\n            cards.erase(cards.begin() + i);\n\n            for (auto& e : next) {\n                cards.push_back(e);\n                if (helper(cards)) {\n                    return true;\n                }\n                cards.pop_back();\n            }\n\n            cards.insert(cards.begin() + i, a);\n            cards.insert(cards.begin() + j, b);\n        }\n    }\n    return false;\n}\n\nbool canGet24(std::vector<int>& cards) {\n    std::vector<double> doubleCards(cards.begin(), cards.end());\n    return helper(doubleCards);\n}\n\nint main() {\n    std::vector<int> cards = $args;\n    bool result = canGet24(cards);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "java": "public boolean canGet24(int[] cards) {\n    List<Double> doubleCards = new ArrayList<>();\n    for (int card : cards) {\n        doubleCards.add((double) card);\n    }\n    return helper(doubleCards);\n}",
            "python": "if __name__ == \"__main__\":\n    cards = $args[0]\n    result = canGet24(cards)\n    print(result)",
            "javascript": "function main() {\n  const cards = $args;\n  const result = canGet24(cards);\n  console.log(result);\n}"
        }
    },
    "680": {
        "title": "Palindrome After Deleting Character",
        "description": "Given a string `s`, return `true` if the `s` can be palindrome after deleting at most one character from it.",
        "example": "Example:\n\nInput: s = \"aba\"\nOutput: true\n\nInput: s = \"abca\"\nOutput: true\nExplanation: You could delete the character 'c'.\n\nInput: s = \"abc\"\nOutput: false",
        "level": "Easy",
        "tags": [
            "string",
            "palindrome"
        ],
        "test_cases": {
            "inputs": [
                "\"aba\"",
                "\"abca\"",
                "\"abc\"",
                "\"racecar\"",
                "\"level\"",
                "\"deified\"",
                "\"hello\"",
                "\"madam\"",
                "\"noon\"",
                "\"radar\"",
                "\"stats\"",
                "\"wow\"",
                "\"a\"",
                "\"aa\"",
                "\"aaa\"",
                "\"aaaa\"",
                "\"aaaaa\"",
                "\"aaaaaa\"",
                "\"aaaaaaa\"",
                "\"aaaaaaaa\"",
                "\"aaaaaaaaa\""
            ],
            "outputs": [
                true,
                true,
                false,
                true,
                true,
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "bool validPalindrome(string s) {\n    for (int i = 0, j = s.size() - 1; i < j; i++, j--) {\n        if (s[i] != s[j]) {\n            int temp1 = i + 1, temp2 = j;\n            while (temp1 < temp2 && s[temp1] == s[temp2]) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n\n            temp1 = i; temp2 = j - 1;\n            while (temp1 < temp2 && s[temp1] == s[temp2]) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n\n            return false;\n        }\n    }\n    return true;\n}\n",
            "java": "public boolean validPalindrome(String s) {\n    for (int i = 0, j = s.length() - 1; i < j; i++, j--) {\n        if (s.charAt(i) != s.charAt(j)) {\n            int temp1 = i + 1, temp2 = j;\n            while (temp1 < temp2 && s.charAt(temp1) == s.charAt(temp2)) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n\n            temp1 = i; temp2 = j - 1;\n            while (temp1 < temp2 && s.charAt(temp1) == s.charAt(temp2)) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n            \n            return false;\n        }\n    }\n    return true;\n}\n",
            "python": "def validPalindrome(s: str) -> bool:\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            temp1, temp2 = i + 1, j\n            while temp1 < temp2 and s[temp1] == s[temp2]:\n                temp1 += 1\n                temp2 -= 1\n            if temp1 >= temp2:\n                return True\n\n            temp1, temp2 = i, j - 1\n            while temp1 < temp2 and s[temp1] == s[temp2]:\n                temp1 += 1\n                temp2 -= 1\n            if temp1 >= temp2:\n                return True\n\n            return False\n        i += 1\n        j -= 1\n    return True\n",
            "javascript": "function validPalindrome(s) {\n    for (let i = 0, j = s.length - 1; i < j; i++, j--) {\n        if (s[i] != s[j]) {\n            let temp1 = i + 1, temp2 = j;\n            while (temp1 < temp2 && s[temp1] == s[temp2]) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n\n            temp1 = i; temp2 = j - 1;\n            while (temp1 < temp2 && s[temp1] == s[temp2]) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n            \n            return false;\n        }\n    }\n    return true;\n}\n",
            "explanation": "The algorithm works as follows:\n1. Initialize two pointers, `i` at the start and `j` at the end of the input string `s`.\n2. Check if characters at positions `i` and `j` are equal. If they are not,\n   1. Check if the resulting substring `s[i+1, j]` is a palindrome.\n   2. If it is not, check if the resulting substring `s[i, j-1]` is a palindrome.\n   3. If neither of the substrings is a palindrome, return false.\n3. Move both pointers towards each other and repeat step 2.\n4. If the pointers crossed each other or met, the entire string `s` can be a palindrome after deleting at most one character, so return true. \n\nThe functions for all four languages follow the same logic as explained above."
        },
        "structure": {
            "c++": "bool validPalindrome(string s) \n    // Your code here\n}\n",
            "java": "public boolean validPalindrome(String s) \n    // Your code here\n}\n",
            "python": "def validPalindrome(s: str) -> bool:\n    # Your code here\n\n",
            "javascript": "function validPalindrome(s) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "bool validPalindrome(string s) {\n    string input = $args;\n    for (int i = 0, j = input.size() - 1; i < j; i++, j--) {\n        if (input[i] != input[j]) {\n            int temp1 = i + 1, temp2 = j;\n            while (temp1 < temp2 && input[temp1] == input[temp2]) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n\n            temp1 = i; temp2 = j - 1;\n            while (temp1 < temp2 && input[temp1] == input[temp2]) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n\n            return false;\n        }\n    }\n    return true;\n}",
            "java": "public boolean validPalindrome(String s) {\n    for (int i = 0, j = s.length() - 1; i < j; i++, j--) {\n        if (s.charAt(i) != s.charAt(j)) {\n            int temp1 = i + 1, temp2 = j;\n            while (temp1 < temp2 && s.charAt(temp1) == s.charAt(temp2)) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n\n            temp1 = i; temp2 = j - 1;\n            while (temp1 < temp2 && s.charAt(temp1) == s.charAt(temp2)) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n\n            return false;\n        }\n    }\n    return true;\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args[0]\n    result = validPalindrome(s)\n    print(result)",
            "javascript": "function validPalindrome(s) {\n    const result = validPalindrome(s);\n    console.log(result);\n}"
        }
    },
    "681": {
        "title": "Next Closest Time",
        "description": "Given a time represented in the format `HH:MM`, form the next closest time by reusing the current digits. There is no limit on how many times a digit can be reused.\n\nYou may assume the given input string is always valid. For example, `01:34`, `12:09` are all valid. `1:34`, `12:9` are all invalid.",
        "example": "Example 1:\n\nInput: time = `19:34`\nOutput: `19:39`\nExplanation: The next closest time choosing from digits 1, 9, 3, 4, is 19:39, which occurs 5 minutes later. It is not 19:33, because this occurs 23 hours and 59 minutes later.\n\nExample 2:\n\nInput: time = `23:59`\nOutput: `22:22`\nExplanation: The next closest time choosing from digits 2, 3, 5, 9, is 22:22. It may be assumed that the returned time is next day's time since it is smaller than the input time numerically.",
        "level": "Medium",
        "tags": [
            "string",
            "math"
        ],
        "test_cases": {
            "inputs": [
                "19:34",
                "23:59",
                "00:00",
                "12:00",
                "01:01",
                "11:11",
                "22:22",
                "12:34",
                "09:45",
                "03:30",
                "10:20",
                "15:45",
                "20:00",
                "06:15",
                "18:18",
                "21:21",
                "07:07",
                "14:14",
                "16:16",
                "08:08"
            ],
            "outputs": [
                "`19:39`",
                "`22:22`",
                "`00:00`",
                "`12:01`",
                "`01:10`",
                "`11:11`",
                "`22:22`",
                "`12:41`",
                "`09:49`",
                "`03:33`",
                "`10:21`",
                "`15:51`",
                "`20:00`",
                "`06:16`",
                "`18:18`",
                "`21:21`",
                "`07:07`",
                "`14:14`",
                "`16:16`",
                "`08:08`"
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring nextClosestTime(string time) {\n    string digits = time.substr(0, 2) + time.substr(3);\n    string next_time = time;\n    int elapsed = INT_MAX;\n\n    for (char a : digits) {\n    for (char b : digits) {\n    for (char c : digits) {\n    for (char d : digits) {\n        string candidate_time = string({a, b, ':', c, d});\n        int cand_elapsed = (stoi(candidate_time.substr(0, 2)) * 60 + stoi(candidate_time.substr(3)) -\n                            stoi(time.substr(0, 2)) * 60 - stoi(time.substr(3)) + 1440) % 1440;\n        if (0 < cand_elapsed && cand_elapsed < elapsed) {\n          elapsed = cand_elapsed;\n          next_time = candidate_time;\n        }\n    }}}}\n\n    return next_time;\n}\n",
            "java": "public String nextClosestTime(String time) {\n    String digits = time.substring(0, 2) + time.substring(3);\n    String next_time = time;\n    int elapsed = Integer.MAX_VALUE;\n\n    for (char a : digits.toCharArray()) {\n    for (char b : digits.toCharArray()) {\n    for (char c : digits.toCharArray()) {\n    for (char d : digits.toCharArray()) {\n        String candidate_time = new StringBuilder().append(a).append(b).append(':').append(c).append(d).toString();\n        int cand_elapsed = (Integer.parseInt(candidate_time.substring(0, 2)) * 60 + Integer.parseInt(candidate_time.substring(3)) -\n                            Integer.parseInt(time.substring(0, 2)) * 60 - Integer.parseInt(time.substring(3)) + 1440) % 1440;\n        if (0 < cand_elapsed && cand_elapsed < elapsed) {\n          elapsed = cand_elapsed;\n          next_time = candidate_time;\n        }\n    }}}}\n\n    return next_time;\n}\n",
            "python": "def nextClosestTime(time: str) -> str:\n    digits = time[:2] + time[3:]\n    next_time = time\n    elapsed = float('inf')\n\n    for a in digits:\n        for b in digits:\n            for c in digits:\n                for d in digits:\n                    candidate_time = f\"{a}{b}:{c}{d}\"\n                    cand_elapsed = (int(candidate_time[:2]) * 60 + int(candidate_time[3:]) -\n                                    int(time[:2]) * 60 - int(time[3:]) + 1440) % 1440\n                    if 0 < cand_elapsed < elapsed:\n                        elapsed = cand_elapsed\n                        next_time = candidate_time\n\n    return next_time\n",
            "javascript": "function nextClosestTime(time) {\n    let digits = time.substring(0, 2) + time.substring(3);\n    let next_time = time;\n    let elapsed = Infinity;\n\n    for (const a of digits) {\n    for (const b of digits) {\n    for (const c of digits) {\n    for (const d of digits) {\n        const candidate_time = `${a}${b}:${c}${d}`;\n        const cand_elapsed = (parseInt(candidate_time.substring(0, 2)) * 60 + parseInt(candidate_time.substring(3)) -\n                              parseInt(time.substring(0, 2)) * 60 - parseInt(time.substring(3)) + 1440) % 1440;\n        if (0 < cand_elapsed && cand_elapsed < elapsed) {\n          elapsed = cand_elapsed;\n          next_time = candidate_time;\n        }\n    }}}}\n\n    return next_time;\n}\n",
            "explanation": "The given algorithm tries all possible combinations of the given digits to create valid \"HH:MM\" times. We calculate the time difference between the given time and each candidate time in minutes (taking into account the daily wraparound, hence the `% 1440`). If the computed elapsed time is less than the previous one while being positive, we update the next closest time.\n\n- Initialize `digits`, `next_time`, and `elapsed` variables.\n- Use multiple nested loops to iterate through all possible combinations of the digits for creating a time.\n- For each digit combination, form a candidate time.\n- Calculate the elapsed time from the given input time to this candidate time, taking into account the daily wraparound.\n- If the elapsed time is smaller than the current minimum time difference and greater than 0, update the next closest time and the elapsed time.\n- After all combinations have been exhausted, return the next closest time."
        },
        "structure": {
            "c++": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring nextClosestTime(string time) \n    // Your code here\n}\n",
            "java": "public String nextClosestTime(String time) \n    // Your code here\n}\n",
            "python": "def nextClosestTime(time: str) -> str:\n    # Your code here\n\n",
            "javascript": "function nextClosestTime(time) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    string time = $args;\n    string result = nextClosestTime(time);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public String nextClosestTime(String time) {\n    String digits = time.substring(0, 2) + time.substring(3);\n    String next_time = time;\n    int elapsed = Integer.MAX_VALUE;\n\n    for (char a : digits.toCharArray()) {\n    for (char b : digits.toCharArray()) {\n    for (char c : digits.toCharArray()) {\n    for (char d : digits.toCharArray()) {\n        String candidate_time = new StringBuilder().append(a).append(b).append(':').append(c).append(d).toString();\n        int cand_elapsed = (Integer.parseInt(candidate_time.substring(0, 2)) * 60 + Integer.parseInt(candidate_time.substring(3)) -\n                            Integer.parseInt(time.substring(0, 2)) * 60 - Integer.parseInt(time.substring(3)) + 1440) % 1440;\n        if (0 < cand_elapsed && cand_elapsed < elapsed) {\n          elapsed = cand_elapsed;\n          next_time = candidate_time;\n        }\n    }}}}\n\n    return next_time;\n}",
            "python": "if __name__ == \"__main__\":\n    time = $args[0]\n    result = nextClosestTime(time)\n    print(result)",
            "javascript": "function main() {\n    const time = $args;\n    const result = nextClosestTime(time);\n    console.log(result);\n}"
        }
    },
    "682": {
        "title": "Baseball Game Score Calculation",
        "description": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record. You are given a list of strings `operations`, where `operations[i]` is the `ith` operation you must apply to the record. The operations can be one of the following: \n\n- An integer `x`: Record a new score of `x`. \n- `'+'`: Record a new score that is the sum of the previous two scores. \n- `'D'`: Record a new score that is the double of the previous score. \n- `'C'`: Invalidate the previous score, removing it from the record. \n\nYou need to return the sum of all the scores on the record after applying all the operations.",
        "example": "Example:\n\nInput: ops = [\"5\", \"2\", \"C\", \"D\", \"+\"]\nOutput: 30\nExplanation: \n\"5\" - Add 5 to the record, record is now [5]. \n\"2\" - Add 2 to the record, record is now [5, 2]. \n\"C\" - Invalidate and remove the previous score, record is now [5]. \n\"D\" - Add 2 * 5 = 10 to the record, record is now [5, 10]. \n\"+\" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15]. \nThe total sum is 5 + 10 + 15 = 30.",
        "level": "Easy",
        "tags": [
            "array",
            "stack"
        ],
        "test_cases": {
            "inputs": [
                [
                    "5",
                    "2",
                    "C",
                    "D",
                    "+"
                ],
                [
                    "5",
                    "-2",
                    "4",
                    "C",
                    "D",
                    "9",
                    "+",
                    "+"
                ],
                [
                    "1",
                    "C"
                ],
                [
                    "10",
                    "20",
                    "30",
                    "40",
                    "C",
                    "D",
                    "+",
                    "C",
                    "D",
                    "+",
                    "C",
                    "D",
                    "+"
                ],
                [
                    "1",
                    "2",
                    "3",
                    "4",
                    "5",
                    "6",
                    "7",
                    "8",
                    "9",
                    "10"
                ]
            ],
            "outputs": [
                30,
                27,
                0,
                60,
                55
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n\nint calPoints(std::vector<std::string>& ops) {\n    std::vector<int> record;\n    for (const std::string& op : ops) {\n        if (op == \"+\") {\n            record.push_back(record[record.size() - 1] + record[record.size() - 2]);\n        } else if (op == \"D\") {\n            record.push_back(2 * record.back());\n        } else if (op == \"C\") {\n            record.pop_back();\n        } else {\n            record.push_back(stoi(op));\n        }\n    }\n    return std::accumulate(record.begin(), record.end(), 0);\n}\n\n",
            "java": "import java.util.*;\n\nclass Solution {\n    public int calPoints(String[] ops) {\n        LinkedList<Integer> record = new LinkedList<>();\n        for (String op : ops) {\n            if (op.equals(\"+\")) {\n                record.add(record.getLast() + record.get(record.size() - 2));\n            } else if (op.equals(\"D\")) {\n                record.add(record.getLast() * 2);\n            } else if (op.equals(\"C\")) {\n                record.removeLast();\n            } else {\n                record.add(Integer.parseInt(op));\n            }\n        }\n        return record.stream().mapToInt(Integer::intValue).sum();\n    }\n}\n\n",
            "python": "def calPoints(ops):\n    record = []\n    for op in ops:\n        if op == '+':\n            record.append(record[-1] + record[-2])\n        elif op == 'D':\n            record.append(record[-1] * 2)\n        elif op == 'C':\n            record.pop()\n        else:\n            record.append(int(op))\n    return sum(record)\n\n",
            "javascript": "function calPoints(ops) {\n    let record = [];\n    for (let op of ops) {\n        if (op === '+') {\n            record.push(record[record.length - 1] + record[record.length - 2]);\n        } else if (op === 'D') {\n            record.push(record[record.length - 1] * 2);\n        } else if (op === 'C') {\n            record.pop();\n        } else {\n            record.push(parseInt(op));\n        }\n    }\n    return record.reduce((a, b) => a + b, 0);\n}\n\n",
            "explanation": "We use a dynamic array (in languages other than Java, where we use LinkedList for simplicity) to store the valid scores. We iterate through the given `ops` array of strings, and for each string, we perform the operations as follows:\n\n1. If the operation is '+', we add the last two scores and append the sum to the record.\n2. If the operation is 'D', we double the last score and append it to the record.\n3. If the operation is 'C', we remove the last score from the record.\n4. If the operation is a number, we parse the integer value and append it to the record.\n\nAfter iterating through all operations, we calculate the sum of all the scores in the record and return it.\n\nThe time complexity of this algorithm is O(n) where n is the size of ops, as we iterate once through the array and perform constant-time operations within the loop. The space complexity is also O(n), as we store the valid scores in the record array."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n\nint calPoints(std::vector<std::string>& ops) \n    // Your code here\n}\n\n",
            "java": "import java.util.*;\n\nclass Solution \n    // Your code here\n}\n\n",
            "python": "def calPoints(ops):\n    # Your code here\n\n",
            "javascript": "function calPoints(ops) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <iostream>\n\nint main() {\n    std::vector<std::string> ops = $args;\n    int result = calPoints(ops);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public int calPoints(String[] ops) {\n        LinkedList<Integer> record = new LinkedList<>();\n        for (String op : ops) {\n            if (op.equals(\"+\")) {\n                record.add(record.getLast() + record.get(record.size() - 2));\n            } else if (op.equals(\"D\")) {\n                record.add(record.getLast() * 2);\n            } else if (op.equals(\"C\")) {\n                record.removeLast();\n            } else {\n                record.add(Integer.parseInt(op));\n            }\n        }\n        return record.stream().mapToInt(Integer::intValue).sum();\n    }",
            "python": "if __name__ == \"__main__\":\n    ops = $args[0]\n    result = calPoints(ops)\n    print(result)",
            "javascript": "function calPoints(ops) {\n    let record = [];\n    for (let op of ops) {\n        if (op === '+') {\n            record.push(record[record.length - 1] + record[record.length - 2]);\n        } else if (op === 'D') {\n            record.push(record[record.length - 1] * 2);\n        } else if (op === 'C') {\n            record.pop();\n        } else {\n            record.push(parseInt(op));\n        }\n    }\n    return record.reduce((a, b) => a + b, 0);\n}\n"
        }
    },
    "683": {
        "title": "Minimum Day Number with K Bulbs",
        "description": "You have `n` bulbs in a row numbered from `1` to `n`. Initially, all the bulbs are turned off. We turn on **exactly one** bulb every day until all bulbs are on after `n` days.\n\nYou are given an array `bulbs` of length `n` where `bulbs[i] = x` means that on the `(i+1)th` day, we will turn on the bulb at position `x` where `i` is **0-indexed** and `x` is **1-indexed**.\n\nGiven an integer `k`, return _the **minimum day number** such that there exists two **turned on** bulbs that have **exactly** `k` bulbs between them that are **all turned off**. If there isn't such day, return `-1`.",
        "example": "Example:\n\nInput: bulbs = [1,3,2], k = 1\nOutput: 2\nExplanation:\nOn the first day: bulbs[0] = 1, first bulb is turned on: [1,0,0]\nOn the second day: bulbs[1] = 3, third bulb is turned on: [1,0,1]\nOn the third day: bulbs[2] = 2, second bulb is turned on: [1,1,1]\nWe return 2 because on the second day, there were two on bulbs with one off bulb between them.",
        "level": "Medium",
        "tags": [
            "Array",
            "Simulation"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    3,
                    2
                ],
                [
                    1,
                    2,
                    3
                ],
                [
                    1,
                    4,
                    2,
                    3
                ],
                [
                    1,
                    5,
                    2,
                    4,
                    3
                ],
                [
                    1,
                    6,
                    2,
                    5,
                    3,
                    4
                ],
                [
                    1,
                    7,
                    2,
                    6,
                    3,
                    5,
                    4
                ],
                [
                    1,
                    8,
                    2,
                    7,
                    3,
                    6,
                    4,
                    5
                ],
                [
                    1,
                    9,
                    2,
                    8,
                    3,
                    7,
                    4,
                    6,
                    5
                ],
                [
                    1,
                    10,
                    2,
                    9,
                    3,
                    8,
                    4,
                    7,
                    5,
                    6
                ],
                [
                    1,
                    11,
                    2,
                    10,
                    3,
                    9,
                    4,
                    8,
                    5,
                    7,
                    6
                ],
                [
                    1,
                    12,
                    2,
                    11,
                    3,
                    10,
                    4,
                    9,
                    5,
                    8,
                    6,
                    7
                ],
                [
                    1,
                    13,
                    2,
                    12,
                    3,
                    11,
                    4,
                    10,
                    5,
                    9,
                    6,
                    8,
                    7
                ],
                [
                    1,
                    14,
                    2,
                    13,
                    3,
                    12,
                    4,
                    11,
                    5,
                    10,
                    6,
                    9,
                    7,
                    8
                ],
                [
                    1,
                    15,
                    2,
                    14,
                    3,
                    13,
                    4,
                    12,
                    5,
                    11,
                    6,
                    10,
                    7,
                    9,
                    8
                ],
                [
                    1,
                    16,
                    2,
                    15,
                    3,
                    14,
                    4,
                    13,
                    5,
                    12,
                    6,
                    11,
                    7,
                    10,
                    8,
                    9
                ],
                [
                    1,
                    17,
                    2,
                    16,
                    3,
                    15,
                    4,
                    14,
                    5,
                    13,
                    6,
                    12,
                    7,
                    11,
                    8,
                    10,
                    9
                ],
                [
                    1,
                    18,
                    2,
                    17,
                    3,
                    16,
                    4,
                    15,
                    5,
                    14,
                    6,
                    13,
                    7,
                    12,
                    8,
                    11,
                    9,
                    10
                ],
                [
                    1,
                    19,
                    2,
                    18,
                    3,
                    17,
                    4,
                    16,
                    5,
                    15,
                    6,
                    14,
                    7,
                    13,
                    8,
                    12,
                    9,
                    11,
                    10
                ],
                [
                    1,
                    20,
                    2,
                    19,
                    3,
                    18,
                    4,
                    17,
                    5,
                    16,
                    6,
                    15,
                    7,
                    14,
                    8,
                    13,
                    9,
                    12,
                    10,
                    11
                ],
                [
                    1,
                    21,
                    2,
                    20,
                    3,
                    19,
                    4,
                    18,
                    5,
                    17,
                    6,
                    16,
                    7,
                    15,
                    8,
                    14,
                    9,
                    13,
                    10,
                    12,
                    11
                ],
                [
                    1,
                    22,
                    2,
                    21,
                    3,
                    20,
                    4,
                    19,
                    5,
                    18,
                    6,
                    17,
                    7,
                    16,
                    8,
                    15,
                    9,
                    14,
                    10,
                    13,
                    11,
                    12
                ]
            ],
            "outputs": [
                "2",
                "-1",
                "3",
                "4",
                "5",
                "6",
                "7",
                "8",
                "9",
                "10",
                "11",
                "12",
                "13",
                "14",
                "15",
                "16",
                "17",
                "18",
                "19",
                "20"
            ]
        },
        "sample_code": {
            "c++": "int kEmptySlots(vector<int>& bulbs, int k) {\n    vector<int> days(bulbs.size());\n    for(int i = 0; i < bulbs.size(); ++i) {\n        days[bulbs[i] - 1] = i;\n    }\n    \n    int ans = INT_MAX;\n    int left = 0;\n    int right = k + 1;\n    while (right < days.size()) {\n        int i = left + 1;\n        for (; i < right; ++i) {\n            if (days[i] < days[left] || days[i] < days[right]) {\n                left = i;\n                break;\n            }\n        }\n        if (i == right) {\n            ans = min(ans, max(days[left], days[right]));\n            left ++;\n            right ++;\n        }\n    }\n    \n    return ans == INT_MAX ? -1 : ans + 1;\n}\n\n",
            "java": "public int kEmptySlots(int[] bulbs, int k) {\n    int[] days = new int[bulbs.length];\n    for(int i = 0; i < bulbs.length; i++) {\n        days[bulbs[i] - 1] = i;\n    }\n    \n    int ans = Integer.MAX_VALUE;\n    int left = 0;\n    int right = k + 1;\n    while (right < days.length) {\n        int i = left + 1;\n        for (; i < right; i++) {\n            if (days[i] < days[left] || days[i] < days[right]) {\n                left = i;\n                break;\n            }\n        }\n        if (i == right) {\n            ans = Math.min(ans, Math.max(days[left], days[right]));\n            left++;\n            right++;\n        }\n    }\n    \n    return ans == Integer.MAX_VALUE ? -1 : ans + 1;\n}\n\n",
            "python": "def kEmptySlots(bulbs, k):\n    days = [0] * len(bulbs)\n    for i, bulb in enumerate(bulbs):\n        days[bulb - 1] = i\n\n    ans = float('inf')\n    left = 0\n    right = k + 1\n    while right < len(days):\n        i = left + 1\n        for i in range(left + 1, right):\n            if days[i] < days[left] or days[i] < days[right]:\n                left = i\n                break\n        else:\n            ans = min(ans, max(days[left], days[right]))\n            left += 1\n            right += 1\n\n    return -1 if ans == float('inf') else ans + 1\n\n",
            "javascript": "function kEmptySlots(bulbs, k) {\n    const days = new Array(bulbs.length);\n    for (let i = 0; i < bulbs.length; i++) {\n        days[bulbs[i] - 1] = i;\n    }\n\n    let ans = Number.MAX_SAFE_INTEGER;\n    let left = 0;\n    let right = k + 1;\n    while (right < days.length) {\n        let i = left + 1;\n        while (i < right) {\n            if (days[i] < days[left] || days[i] < days[right]) {\n                left = i;\n                break;\n            }\n            i++;\n        }\n        if (i === right) {\n            ans = Math.min(ans, Math.max(days[left], days[right]));\n            left++;\n            right++;\n        }\n    }\n\n    return ans === Number.MAX_SAFE_INTEGER ? -1 : ans + 1;\n}\n\n",
            "explanation": "The algorithm begins by creating a `days` array mirroring the bulbs with the values indicating the day on which the bulb at that index was turned on. Then, we set up a sliding window approach with a `left` and `right` pointer initialized at 0 and `k + 1` respectively. We iterate through the `days` array with a nested loop, comparing the values at the left/right pointers with the current value of the nested loop iteration. We verify that the current value is either greater than the left or right pointer value. If not, we update the pointer and break out of the inner loop. If the inner loop reaches its end without breaking, we compare the maximum value of the `left` and `right` pointers in the `days` array with the current smallest interval found (initialized as infinity). This updates the smallest interval, and we increment the left and right pointers to continue the sliding window approach. The final answer is then either the minimum day number (incremented by 1) or -1 if there was no valid interval found."
        },
        "structure": {
            "c++": "int kEmptySlots(vector<int>& bulbs, int k) \n    // Your code here\n}\n\n",
            "java": "public int kEmptySlots(int[] bulbs, int k) \n    // Your code here\n}\n\n",
            "python": "def kEmptySlots(bulbs, k):\n    # Your code here\n\n",
            "javascript": "function kEmptySlots(bulbs, k) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int kEmptySlots(vector<int>& bulbs, int k) {\n    vector<int> days(bulbs.size());\n    for(int i = 0; i < bulbs.size(); ++i) {\n        days[bulbs[i] - 1] = i;\n    }\n\n    int ans = INT_MAX;\n    int left = 0;\n    int right = k + 1;\n    while (right < days.size()) {\n        int i = left + 1;\n        for (; i < right; ++i) {\n            if (days[i] < days[left] || days[i] < days[right]) {\n                left = i;\n                break;\n            }\n        }\n        if (i == right) {\n            ans = min(ans, max(days[left], days[right]));\n            left ++;\n            right ++;\n        }\n    }\n\n    return ans == INT_MAX ? -1 : ans + 1;\n}",
            "java": "public int kEmptySlots(int[] bulbs, int k) {\n    int[] days = new int[bulbs.length];\n    for(int i = 0; i < bulbs.length; i++) {\n        days[bulbs[i] - 1] = i;\n    }\n\n    int ans = Integer.MAX_VALUE;\n    int left = 0;\n    int right = k + 1;\n    while (right < days.length) {\n        int i = left + 1;\n        for (; i < right; i++) {\n            if (days[i] < days[left] || days[i] < days[right]) {\n                left = i;\n                break;\n            }\n        }\n        if (i == right) {\n            ans = Math.min(ans, Math.max(days[left], days[right]));\n            left++;\n            right++;\n        }\n    }\n\n    return ans == Integer.MAX_VALUE ? -1 : ans + 1;\n}",
            "python": "if __name__ == \"__main__\":\n    bulbs = $args[0]\n    k = $args[1]\n    result = kEmptySlots(bulbs, k)\n    print(result)",
            "javascript": "function kEmptySlots(bulbs, k) {\n    const days = new Array(bulbs.length);\n    for (let i = 0; i < bulbs.length; i++) {\n        days[bulbs[i] - 1] = i;\n    }\n\n    let ans = Number.MAX_SAFE_INTEGER;\n    let left = 0;\n    let right = k + 1;\n    while (right < days.length) {\n        let i = left + 1;\n        while (i < right) {\n            if (days[i] < days[left] || days[i] < days[right]) {\n                left = i;\n                break;\n            }\n            i++;\n        }\n        if (i === right) {\n            ans = Math.min(ans, Math.max(days[left], days[right]));\n            left++;\n            right++;\n        }\n    }\n\n    return ans === Number.MAX_SAFE_INTEGER ? -1 : ans + 1;\n}"
        }
    },
    "684": {
        "title": "Remove Extra Edge in Tree",
        "description": "Given a graph that started as a tree with `n` nodes labeled from `1` to `n`, with one additional edge added, find and return the edge that can be removed so that the resulting graph is a tree of `n` nodes. The added edge has two different vertices chosen from `1` to `n`, and was not an edge that already existed. The graph is represented as an array `edges` of length `n` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the graph.",
        "example": "Example:\n\nInput: edges = [[1,2],[1,3],[2,3]]\nOutput: [2,3]\n\nExplanation: The given graph is a tree with 3 nodes and the additional edge [2,3] can be removed to obtain a tree.\n\nInput: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]\nOutput: [1,4]\n\nExplanation: The given graph is a tree with 5 nodes and the additional edge [1,4] can be removed to obtain a tree.",
        "level": "Medium",
        "tags": [
            "Graph",
            "Tree",
            "Connectivity"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        2
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        3
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        1,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ],
                    [
                        19,
                        20
                    ],
                    [
                        20,
                        21
                    ],
                    [
                        21,
                        22
                    ],
                    [
                        22,
                        23
                    ],
                    [
                        23,
                        24
                    ],
                    [
                        24,
                        25
                    ],
                    [
                        25,
                        26
                    ],
                    [
                        26,
                        27
                    ],
                    [
                        27,
                        28
                    ],
                    [
                        28,
                        29
                    ],
                    [
                        29,
                        30
                    ],
                    [
                        30,
                        31
                    ],
                    [
                        31,
                        32
                    ],
                    [
                        32,
                        33
                    ],
                    [
                        33,
                        34
                    ],
                    [
                        34,
                        35
                    ],
                    [
                        35,
                        36
                    ],
                    [
                        36,
                        37
                    ],
                    [
                        37,
                        38
                    ],
                    [
                        38,
                        39
                    ],
                    [
                        39,
                        40
                    ],
                    [
                        40,
                        41
                    ],
                    [
                        41,
                        42
                    ],
                    [
                        42,
                        43
                    ],
                    [
                        43,
                        44
                    ],
                    [
                        44,
                        45
                    ],
                    [
                        45,
                        46
                    ],
                    [
                        46,
                        47
                    ],
                    [
                        47,
                        48
                    ],
                    [
                        48,
                        49
                    ],
                    [
                        49,
                        50
                    ],
                    [
                        50,
                        51
                    ],
                    [
                        51,
                        52
                    ],
                    [
                        52,
                        53
                    ],
                    [
                        53,
                        54
                    ],
                    [
                        54,
                        55
                    ],
                    [
                        55,
                        56
                    ],
                    [
                        56,
                        57
                    ],
                    [
                        57,
                        58
                    ],
                    [
                        58,
                        59
                    ],
                    [
                        59,
                        60
                    ],
                    [
                        60,
                        61
                    ],
                    [
                        61,
                        62
                    ],
                    [
                        62,
                        63
                    ],
                    [
                        63,
                        64
                    ],
                    [
                        64,
                        65
                    ],
                    [
                        65,
                        66
                    ],
                    [
                        66,
                        67
                    ],
                    [
                        67,
                        68
                    ],
                    [
                        68,
                        69
                    ],
                    [
                        69,
                        70
                    ],
                    [
                        70,
                        71
                    ],
                    [
                        71,
                        72
                    ],
                    [
                        72,
                        73
                    ],
                    [
                        73,
                        74
                    ],
                    [
                        74,
                        75
                    ],
                    [
                        75,
                        76
                    ],
                    [
                        76,
                        77
                    ],
                    [
                        77,
                        78
                    ],
                    [
                        78,
                        79
                    ],
                    [
                        79,
                        80
                    ],
                    [
                        80,
                        81
                    ],
                    [
                        81,
                        82
                    ],
                    [
                        82,
                        83
                    ],
                    [
                        83,
                        84
                    ],
                    [
                        84,
                        85
                    ],
                    [
                        85,
                        86
                    ],
                    [
                        86,
                        87
                    ],
                    [
                        87,
                        88
                    ],
                    [
                        88,
                        89
                    ],
                    [
                        89,
                        90
                    ],
                    [
                        90,
                        91
                    ],
                    [
                        91,
                        92
                    ],
                    [
                        92,
                        93
                    ],
                    [
                        93,
                        94
                    ],
                    [
                        94,
                        95
                    ],
                    [
                        95,
                        96
                    ],
                    [
                        96,
                        97
                    ],
                    [
                        97,
                        98
                    ],
                    [
                        98,
                        99
                    ],
                    [
                        99,
                        100
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ],
                    [
                        19,
                        20
                    ],
                    [
                        20,
                        21
                    ],
                    [
                        21,
                        22
                    ],
                    [
                        22,
                        23
                    ],
                    [
                        23,
                        24
                    ],
                    [
                        24,
                        25
                    ],
                    [
                        25,
                        26
                    ],
                    [
                        26,
                        27
                    ],
                    [
                        27,
                        28
                    ],
                    [
                        28,
                        29
                    ],
                    [
                        29,
                        30
                    ],
                    [
                        30,
                        31
                    ],
                    [
                        31,
                        32
                    ],
                    [
                        32,
                        33
                    ],
                    [
                        33,
                        34
                    ],
                    [
                        34,
                        35
                    ],
                    [
                        35,
                        36
                    ],
                    [
                        36,
                        37
                    ],
                    [
                        37,
                        38
                    ],
                    [
                        38,
                        39
                    ],
                    [
                        39,
                        40
                    ],
                    [
                        40,
                        41
                    ],
                    [
                        41,
                        42
                    ],
                    [
                        42,
                        43
                    ],
                    [
                        43,
                        44
                    ],
                    [
                        44,
                        45
                    ],
                    [
                        45,
                        46
                    ],
                    [
                        46,
                        47
                    ],
                    [
                        47,
                        48
                    ],
                    [
                        48,
                        49
                    ],
                    [
                        49,
                        50
                    ],
                    [
                        50,
                        51
                    ],
                    [
                        51,
                        52
                    ],
                    [
                        52,
                        53
                    ],
                    [
                        53,
                        54
                    ],
                    [
                        54,
                        55
                    ],
                    [
                        55,
                        56
                    ],
                    [
                        56,
                        57
                    ],
                    [
                        57,
                        58
                    ],
                    [
                        58,
                        59
                    ],
                    [
                        59,
                        60
                    ],
                    [
                        60,
                        61
                    ],
                    [
                        61,
                        62
                    ],
                    [
                        62,
                        63
                    ],
                    [
                        63,
                        64
                    ],
                    [
                        64,
                        65
                    ],
                    [
                        65,
                        66
                    ],
                    [
                        66,
                        67
                    ],
                    [
                        67,
                        68
                    ],
                    [
                        68,
                        69
                    ],
                    [
                        69,
                        70
                    ],
                    [
                        70,
                        71
                    ],
                    [
                        71,
                        72
                    ],
                    [
                        72,
                        73
                    ],
                    [
                        73,
                        74
                    ],
                    [
                        74,
                        75
                    ],
                    [
                        75,
                        76
                    ],
                    [
                        76,
                        77
                    ],
                    [
                        77,
                        78
                    ],
                    [
                        78,
                        79
                    ],
                    [
                        79,
                        80
                    ],
                    [
                        80,
                        81
                    ],
                    [
                        81,
                        82
                    ],
                    [
                        82,
                        83
                    ],
                    [
                        83,
                        84
                    ],
                    [
                        84,
                        85
                    ],
                    [
                        85,
                        86
                    ],
                    [
                        86,
                        87
                    ],
                    [
                        87,
                        88
                    ],
                    [
                        88,
                        89
                    ],
                    [
                        89,
                        90
                    ],
                    [
                        90,
                        91
                    ],
                    [
                        91,
                        92
                    ],
                    [
                        92,
                        93
                    ],
                    [
                        93,
                        94
                    ],
                    [
                        94,
                        95
                    ],
                    [
                        95,
                        96
                    ],
                    [
                        96,
                        97
                    ],
                    [
                        97,
                        98
                    ],
                    [
                        98,
                        99
                    ],
                    [
                        99,
                        100
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ],
                    [
                        19,
                        20
                    ],
                    [
                        20,
                        21
                    ],
                    [
                        21,
                        22
                    ],
                    [
                        22,
                        23
                    ],
                    [
                        23,
                        24
                    ],
                    [
                        24,
                        25
                    ],
                    [
                        25,
                        26
                    ],
                    [
                        26,
                        27
                    ],
                    [
                        27,
                        28
                    ],
                    [
                        28,
                        29
                    ],
                    [
                        29,
                        30
                    ],
                    [
                        30,
                        31
                    ],
                    [
                        31,
                        32
                    ],
                    [
                        32,
                        33
                    ],
                    [
                        33,
                        34
                    ],
                    [
                        34,
                        35
                    ],
                    [
                        35,
                        36
                    ],
                    [
                        36,
                        37
                    ],
                    [
                        37,
                        38
                    ],
                    [
                        38,
                        39
                    ],
                    [
                        39,
                        40
                    ],
                    [
                        40,
                        41
                    ],
                    [
                        41,
                        42
                    ],
                    [
                        42,
                        43
                    ],
                    [
                        43,
                        44
                    ],
                    [
                        44,
                        45
                    ],
                    [
                        45,
                        46
                    ],
                    [
                        46,
                        47
                    ],
                    [
                        47,
                        48
                    ],
                    [
                        48,
                        49
                    ],
                    [
                        49,
                        50
                    ],
                    [
                        50,
                        51
                    ],
                    [
                        51,
                        52
                    ],
                    [
                        52,
                        53
                    ],
                    [
                        53,
                        54
                    ],
                    [
                        54,
                        55
                    ],
                    [
                        55,
                        56
                    ],
                    [
                        56,
                        57
                    ],
                    [
                        57,
                        58
                    ],
                    [
                        58,
                        59
                    ],
                    [
                        59,
                        60
                    ],
                    [
                        60,
                        61
                    ],
                    [
                        61,
                        62
                    ],
                    [
                        62,
                        63
                    ],
                    [
                        63,
                        64
                    ],
                    [
                        64,
                        65
                    ],
                    [
                        65,
                        66
                    ],
                    [
                        66,
                        67
                    ],
                    [
                        67,
                        68
                    ],
                    [
                        68,
                        69
                    ],
                    [
                        69,
                        70
                    ],
                    [
                        70,
                        71
                    ],
                    [
                        71,
                        72
                    ],
                    [
                        72,
                        73
                    ],
                    [
                        73,
                        74
                    ],
                    [
                        74,
                        75
                    ],
                    [
                        75,
                        76
                    ],
                    [
                        76,
                        77
                    ],
                    [
                        77,
                        78
                    ],
                    [
                        78,
                        79
                    ],
                    [
                        79,
                        80
                    ],
                    [
                        80,
                        81
                    ],
                    [
                        81,
                        82
                    ],
                    [
                        82,
                        83
                    ],
                    [
                        83,
                        84
                    ],
                    [
                        84,
                        85
                    ],
                    [
                        85,
                        86
                    ],
                    [
                        86,
                        87
                    ],
                    [
                        87,
                        88
                    ],
                    [
                        88,
                        89
                    ],
                    [
                        89,
                        90
                    ],
                    [
                        90,
                        91
                    ],
                    [
                        91,
                        92
                    ],
                    [
                        92,
                        93
                    ],
                    [
                        93,
                        94
                    ],
                    [
                        94,
                        95
                    ],
                    [
                        95,
                        96
                    ],
                    [
                        96,
                        97
                    ],
                    [
                        97,
                        98
                    ],
                    [
                        98,
                        99
                    ],
                    [
                        99,
                        100
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ],
                    [
                        19,
                        20
                    ],
                    [
                        20,
                        21
                    ],
                    [
                        21,
                        22
                    ],
                    [
                        22,
                        23
                    ],
                    [
                        23,
                        24
                    ],
                    [
                        24,
                        25
                    ],
                    [
                        25,
                        26
                    ],
                    [
                        26,
                        27
                    ],
                    [
                        27,
                        28
                    ],
                    [
                        28,
                        29
                    ],
                    [
                        29,
                        30
                    ],
                    [
                        30,
                        31
                    ],
                    [
                        31,
                        32
                    ],
                    [
                        32,
                        33
                    ],
                    [
                        33,
                        34
                    ],
                    [
                        34,
                        35
                    ],
                    [
                        35,
                        36
                    ],
                    [
                        36,
                        37
                    ],
                    [
                        37,
                        38
                    ],
                    [
                        38,
                        39
                    ],
                    [
                        39,
                        40
                    ],
                    [
                        40,
                        41
                    ],
                    [
                        41,
                        42
                    ],
                    [
                        42,
                        43
                    ],
                    [
                        43,
                        44
                    ],
                    [
                        44,
                        45
                    ],
                    [
                        45,
                        46
                    ],
                    [
                        46,
                        47
                    ],
                    [
                        47,
                        48
                    ],
                    [
                        48,
                        49
                    ],
                    [
                        49,
                        50
                    ],
                    [
                        50,
                        51
                    ],
                    [
                        51,
                        52
                    ],
                    [
                        52,
                        53
                    ],
                    [
                        53,
                        54
                    ],
                    [
                        54,
                        55
                    ],
                    [
                        55,
                        56
                    ],
                    [
                        56,
                        57
                    ],
                    [
                        57,
                        58
                    ],
                    [
                        58,
                        59
                    ],
                    [
                        59,
                        60
                    ],
                    [
                        60,
                        61
                    ],
                    [
                        61,
                        62
                    ],
                    [
                        62,
                        63
                    ],
                    [
                        63,
                        64
                    ],
                    [
                        64,
                        65
                    ],
                    [
                        65,
                        66
                    ],
                    [
                        66,
                        67
                    ],
                    [
                        67,
                        68
                    ],
                    [
                        68,
                        69
                    ],
                    [
                        69,
                        70
                    ],
                    [
                        70,
                        71
                    ],
                    [
                        71,
                        72
                    ],
                    [
                        72,
                        73
                    ],
                    [
                        73,
                        74
                    ],
                    [
                        74,
                        75
                    ],
                    [
                        75,
                        76
                    ],
                    [
                        76,
                        77
                    ],
                    [
                        77,
                        78
                    ],
                    [
                        78,
                        79
                    ],
                    [
                        79,
                        80
                    ],
                    [
                        80,
                        81
                    ],
                    [
                        81,
                        82
                    ],
                    [
                        82,
                        83
                    ],
                    [
                        83,
                        84
                    ],
                    [
                        84,
                        85
                    ],
                    [
                        85,
                        86
                    ],
                    [
                        86,
                        87
                    ],
                    [
                        87,
                        88
                    ],
                    [
                        88,
                        89
                    ],
                    [
                        89,
                        90
                    ],
                    [
                        90,
                        91
                    ],
                    [
                        91,
                        92
                    ],
                    [
                        92,
                        93
                    ],
                    [
                        93,
                        94
                    ],
                    [
                        94,
                        95
                    ],
                    [
                        95,
                        96
                    ],
                    [
                        96,
                        97
                    ],
                    [
                        97,
                        98
                    ],
                    [
                        98,
                        99
                    ],
                    [
                        99,
                        100
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ],
                    [
                        19,
                        20
                    ],
                    [
                        20,
                        21
                    ],
                    [
                        21,
                        22
                    ],
                    [
                        22,
                        23
                    ],
                    [
                        23,
                        24
                    ],
                    [
                        24,
                        25
                    ],
                    [
                        25,
                        26
                    ],
                    [
                        26,
                        27
                    ],
                    [
                        27,
                        28
                    ],
                    [
                        28,
                        29
                    ],
                    [
                        29,
                        30
                    ],
                    [
                        30,
                        31
                    ],
                    [
                        31,
                        32
                    ],
                    [
                        32,
                        33
                    ],
                    [
                        33,
                        34
                    ],
                    [
                        34,
                        35
                    ],
                    [
                        35,
                        36
                    ],
                    [
                        36,
                        37
                    ],
                    [
                        37,
                        38
                    ],
                    [
                        38,
                        39
                    ],
                    [
                        39,
                        40
                    ],
                    [
                        40,
                        41
                    ],
                    [
                        41,
                        42
                    ],
                    [
                        42,
                        43
                    ],
                    [
                        43,
                        44
                    ],
                    [
                        44,
                        45
                    ],
                    [
                        45,
                        46
                    ],
                    [
                        46,
                        47
                    ],
                    [
                        47,
                        48
                    ],
                    [
                        48,
                        49
                    ],
                    [
                        49,
                        50
                    ],
                    [
                        50,
                        51
                    ],
                    [
                        51,
                        52
                    ],
                    [
                        52,
                        53
                    ],
                    [
                        53,
                        54
                    ],
                    [
                        54,
                        55
                    ],
                    [
                        55,
                        56
                    ],
                    [
                        56,
                        57
                    ],
                    [
                        57,
                        58
                    ],
                    [
                        58,
                        59
                    ],
                    [
                        59,
                        60
                    ],
                    [
                        60,
                        61
                    ],
                    [
                        61,
                        62
                    ],
                    [
                        62,
                        63
                    ],
                    [
                        63,
                        64
                    ],
                    [
                        64,
                        65
                    ],
                    [
                        65,
                        66
                    ],
                    [
                        66,
                        67
                    ],
                    [
                        67,
                        68
                    ],
                    [
                        68,
                        69
                    ],
                    [
                        69,
                        70
                    ],
                    [
                        70,
                        71
                    ],
                    [
                        71,
                        72
                    ],
                    [
                        72,
                        73
                    ],
                    [
                        73,
                        74
                    ],
                    [
                        74,
                        75
                    ],
                    [
                        75,
                        76
                    ],
                    [
                        76,
                        77
                    ],
                    [
                        77,
                        78
                    ],
                    [
                        78,
                        79
                    ],
                    [
                        79,
                        80
                    ],
                    [
                        80,
                        81
                    ],
                    [
                        81,
                        82
                    ],
                    [
                        82,
                        83
                    ],
                    [
                        83,
                        84
                    ],
                    [
                        84,
                        85
                    ],
                    [
                        85,
                        86
                    ],
                    [
                        86,
                        87
                    ],
                    [
                        87,
                        88
                    ],
                    [
                        88,
                        89
                    ],
                    [
                        89,
                        90
                    ],
                    [
                        90,
                        91
                    ],
                    [
                        91,
                        92
                    ],
                    [
                        92,
                        93
                    ],
                    [
                        93,
                        94
                    ],
                    [
                        94,
                        95
                    ],
                    [
                        95,
                        96
                    ],
                    [
                        96,
                        97
                    ],
                    [
                        97,
                        98
                    ],
                    [
                        98,
                        99
                    ],
                    [
                        99,
                        100
                    ]
                ]
            ],
            "outputs": [
                [
                    2,
                    3
                ],
                [
                    1,
                    4
                ],
                [
                    99,
                    100
                ],
                [
                    99,
                    100
                ],
                [
                    99,
                    100
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> findRedundantConnection(vector<vector<int>>& edges) {\n    vector<int> parent(edges.size() + 1);\n    for (int i = 1; i <= edges.size(); ++i) {\n        parent[i] = i;\n    }\n\n    for (const auto& edge : edges) {\n        int root1 = find(parent, edge[0]);\n        int root2 = find(parent, edge[1]);\n        if (root1 == root2) {\n            return edge;\n        }\n        parent[root1] = root2;\n    }\n\n    return {};\n}\n\nint find(vector<int>& parent, int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent, parent[x]);\n    }\n    return parent[x];\n}\n\n",
            "java": "import java.util.*;\n\nclass Solution {\n    public int[] findRedundantConnection(int[][] edges) {\n        int[] parent = new int[edges.length + 1];\n        for (int i = 1; i <= edges.length; i++) {\n            parent[i] = i;\n        }\n\n        for (int[] edge : edges) {\n            int root1 = find(parent, edge[0]);\n            int root2 = find(parent, edge[1]);\n            if (root1 == root2) {\n                return edge;\n            }\n            parent[root1] = root2;\n        }\n\n        return new int[0];\n    }\n\n    private int find(int[] parent, int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent, parent[x]);\n        }\n        return parent[x];\n    }\n}\n\n",
            "python": "from typing import List\n\ndef findRedundantConnection(edges: List[List[int]]) -> List[int]:\n    def find(parent, x):\n        if parent[x] != x:\n            parent[x] = find(parent, parent[x])\n        return parent[x]\n\n    parent = list(range(len(edges) + 1))\n    for edge in edges:\n        root1 = find(parent, edge[0])\n        root2 = find(parent, edge[1])\n        if root1 == root2:\n            return edge\n        parent[root1] = root2\n    return []\n\n",
            "javascript": "function findRedundantConnection(edges) {\n    const parent = new Array(edges.length + 1).fill(0).map((_, i) => i);\n\n    function find(x) {\n        if (parent[x] !== x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    for (const edge of edges) {\n        const root1 = find(edge[0]);\n        const root2 = find(edge[1]);\n        if (root1 === root2) {\n            return edge;\n        }\n        parent[root1] = root2;\n    }\n\n    return [];\n}\n\n",
            "explanation": "We are given a graph that was originally a tree but now has one additional edge. The goal is to find that extra edge and remove it to restore the origi\u0002nal tree structure. We can accomplish this using a disjoint set or Union-Find data structure. The key concept is that, in a tree, there is only one unique path between any two nodes. If we find two nodes that are already in the same set, then the edge connecting those nodes is the additional edge.\n\n1. Initialize the parent array with its index as the parent.\n2. Iterate through all the edges in the input graph.\n3. Perform the find operation to get the root of both nodes of the current edge.\n   - If the roots are the same, then these nodes already belong to the same set, meaning this edge is the additional one, so return it.\n   - Otherwise, unionize the sets by updating the parent of one of the roots.\n4. If we iterate through all edges and find no redundant edge, return an empty result. (This step should actually never be reached, since there is a guaran\u0002tee of a redundant edge in the input.)\n\nThis method guarantees that we find the extra edge, and as we traverse the edges in their input order, we satisfy the condition of returning the answer that occurs last in the input."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> findRedundantConnection(vector<vector<int>>& edges) \n    // Your code here\n}\n\n",
            "java": "import java.util.*;\n\nclass Solution \n    // Your code here\n}\n\n",
            "python": "from typing import List\n    # Your code here\n\n",
            "javascript": "function findRedundantConnection(edges) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> findRedundantConnection(vector<vector<int>>& edges) {\n    vector<int> parent(edges.size() + 1);\n    for (int i = 1; i <= edges.size(); ++i) {\n        parent[i] = i;\n    }\n\n    for (const auto& edge : edges) {\n        int root1 = find(parent, edge[0]);\n        int root2 = find(parent, edge[1]);\n        if (root1 == root2) {\n            return edge;\n        }\n        parent[root1] = root2;\n    }\n\n    return {};\n}\n\nint find(vector<int>& parent, int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent, parent[x]);\n    }\n    return parent[x];\n}",
            "java": "public int[] findRedundantConnection(int[][] edges)",
            "python": "if __name__ == \"__main__\":\n    edges = $args[0]\n    result = findRedundantConnection(edges)\n    print(result)",
            "javascript": "function findRedundantConnection(edges) {\n    const parent = new Array(edges.length + 1).fill(0).map((_, i) => i);\n\n    function find(x) {\n        if (parent[x] !== x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    for (const edge of edges) {\n        const root1 = find(edge[0]);\n        const root2 = find(edge[1]);\n        if (root1 === root2) {\n            return edge;\n        }\n        parent[root1] = root2;\n    }\n\n    return [];\n}\n"
        }
    },
    "685": {
        "title": "Remove Edge to Create Rooted Tree",
        "description": "Given a directed graph that started as a rooted tree with `n` nodes, with one additional directed edge added, find and return an edge that can be removed so that the resulting graph is a rooted tree of `n` nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array.",
        "example": "Example:\n\nInput: edges = [[1,2],[1,3],[2,3]]\nOutput: [2,3]\n\nExplanation: The given graph is a rooted tree with 3 nodes. The edge [2,3] can be removed to create a rooted tree.\n\nInput: edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]\nOutput: [4,1]\n\nExplanation: The given graph is not a rooted tree as there is a cycle. The edge [4,1] can be removed to create a rooted tree.",
        "level": "Medium",
        "tags": [
            "Graph",
            "Tree",
            "Directed Graph"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        2
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        3
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        1
                    ],
                    [
                        1,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ],
                    [
                        19,
                        20
                    ],
                    [
                        20,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ],
                    [
                        19,
                        20
                    ],
                    [
                        20,
                        21
                    ],
                    [
                        21,
                        22
                    ],
                    [
                        22,
                        23
                    ],
                    [
                        23,
                        24
                    ],
                    [
                        24,
                        25
                    ],
                    [
                        25,
                        26
                    ],
                    [
                        26,
                        27
                    ],
                    [
                        27,
                        28
                    ],
                    [
                        28,
                        29
                    ],
                    [
                        29,
                        30
                    ],
                    [
                        30,
                        31
                    ],
                    [
                        31,
                        32
                    ],
                    [
                        32,
                        33
                    ],
                    [
                        33,
                        34
                    ],
                    [
                        34,
                        35
                    ],
                    [
                        35,
                        36
                    ],
                    [
                        36,
                        37
                    ],
                    [
                        37,
                        38
                    ],
                    [
                        38,
                        39
                    ],
                    [
                        39,
                        40
                    ],
                    [
                        40,
                        41
                    ],
                    [
                        41,
                        42
                    ],
                    [
                        42,
                        43
                    ],
                    [
                        43,
                        44
                    ],
                    [
                        44,
                        45
                    ],
                    [
                        45,
                        46
                    ],
                    [
                        46,
                        47
                    ],
                    [
                        47,
                        48
                    ],
                    [
                        48,
                        49
                    ],
                    [
                        49,
                        50
                    ],
                    [
                        50,
                        51
                    ],
                    [
                        51,
                        52
                    ],
                    [
                        52,
                        53
                    ],
                    [
                        53,
                        54
                    ],
                    [
                        54,
                        55
                    ],
                    [
                        55,
                        56
                    ],
                    [
                        56,
                        57
                    ],
                    [
                        57,
                        58
                    ],
                    [
                        58,
                        59
                    ],
                    [
                        59,
                        60
                    ],
                    [
                        60,
                        61
                    ],
                    [
                        61,
                        62
                    ],
                    [
                        62,
                        63
                    ],
                    [
                        63,
                        64
                    ],
                    [
                        64,
                        65
                    ],
                    [
                        65,
                        66
                    ],
                    [
                        66,
                        67
                    ],
                    [
                        67,
                        68
                    ],
                    [
                        68,
                        69
                    ],
                    [
                        69,
                        70
                    ],
                    [
                        70,
                        71
                    ],
                    [
                        71,
                        72
                    ],
                    [
                        72,
                        73
                    ],
                    [
                        73,
                        74
                    ],
                    [
                        74,
                        75
                    ],
                    [
                        75,
                        76
                    ],
                    [
                        76,
                        77
                    ],
                    [
                        77,
                        78
                    ],
                    [
                        78,
                        79
                    ],
                    [
                        79,
                        80
                    ],
                    [
                        80,
                        81
                    ],
                    [
                        81,
                        82
                    ],
                    [
                        82,
                        83
                    ],
                    [
                        83,
                        84
                    ],
                    [
                        84,
                        85
                    ],
                    [
                        85,
                        86
                    ],
                    [
                        86,
                        87
                    ],
                    [
                        87,
                        88
                    ],
                    [
                        88,
                        89
                    ],
                    [
                        89,
                        90
                    ],
                    [
                        90,
                        91
                    ],
                    [
                        91,
                        92
                    ],
                    [
                        92,
                        93
                    ],
                    [
                        93,
                        94
                    ],
                    [
                        94,
                        95
                    ],
                    [
                        95,
                        96
                    ],
                    [
                        96,
                        97
                    ],
                    [
                        97,
                        98
                    ],
                    [
                        98,
                        99
                    ],
                    [
                        99,
                        100
                    ],
                    [
                        100,
                        1
                    ]
                ]
            ],
            "outputs": [
                [
                    2,
                    3
                ],
                [
                    4,
                    1
                ],
                [
                    3,
                    1
                ],
                [
                    10,
                    1
                ],
                [
                    20,
                    1
                ],
                [
                    100,
                    1
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\n    vector<int> parent(edges.size() + 1, 0);\n    vector<int> candidateA, candidateB;\n    \n    for (const auto& edge : edges) {\n        int u = edge[0], v = edge[1];\n        if (parent[v] > 0) {\n            candidateA = {parent[v], v};\n            candidateB = edge;\n        } else {\n            parent[v] = u;\n        }\n    }\n    \n    for (int i = 1; i <= edges.size(); ++i) {\n        int cycle = i, steps = edges.size();\n        while (parent[cycle] != 0 && steps-- > 0) {\n            cycle = parent[cycle];\n        }\n        if (steps == -1) {\n            if (candidateA.empty()) return {parent[i], i};\n            else return candidateA;\n        }\n    }\n    \n    return candidateB;\n}\n\n",
            "java": "class Solution {\n    public int[] findRedundantDirectedConnection(int[][] edges) {\n        int[] parent = new int[edges.length + 1];\n        int[] candidateA = null, candidateB = null;\n        \n        for (int[] edge : edges) {\n            int u = edge[0], v = edge[1];\n            if (parent[v] > 0) {\n                candidateA = new int[] {parent[v], v};\n                candidateB = edge;\n            } else {\n                parent[v] = u;\n            }\n        }\n        \n        for (int i = 1; i <= edges.length; ++i) {\n            int cycle = i, steps = edges.length;\n            while (parent[cycle] != 0 && steps-- > 0) {\n                cycle = parent[cycle];\n            }\n            if (steps == -1) {\n                if (candidateA == null) return new int[] {parent[i], i};\n                else return candidateA;\n            }\n        }\n        \n        return candidateB;\n    }\n}\n\n",
            "python": "def findRedundantDirectedConnection(edges):\n    parent = [0] * (len(edges) + 1)\n    candidateA = candidateB = None\n\n    for u, v in edges:\n        if parent[v] > 0:\n            candidateA = [parent[v], v]\n            candidateB = [u, v]\n        else:\n            parent[v] = u\n\n    for i in range(1, len(edges) + 1):\n        cycle = i\n        steps = len(edges)\n        while parent[cycle] != 0 and steps > 0:\n            cycle = parent[cycle]\n            steps -= 1\n        if steps == 0:\n            if not candidateA:\n                return [parent[i], i]\n            else:\n                return candidateA\n\n    return candidateB\n\n",
            "javascript": "function findRedundantDirectedConnection(edges) {\n    const parent = Array(edges.length + 1).fill(0);\n    let candidateA = null, candidateB = null;\n\n    for (const edge of edges) {\n        const [u, v] = edge;\n        if (parent[v] > 0) {\n            candidateA = [parent[v], v];\n            candidateB = edge;\n        } else {\n            parent[v] = u;\n        }\n    }\n\n    for (let i = 1; i <= edges.length; ++i) {\n        let cycle = i, steps = edges.length;\n        while (parent[cycle] !== 0 && steps-- > 0) {\n            cycle = parent[cycle];\n        }\n        if (steps === -1) {\n            if (candidateA === null) return [parent[i], i];\n            else return candidateA;\n        }\n    }\n\n    return candidateB;\n}\n\n",
            "explanation": "1. Initialize an array `parent` to keep track of the parent of each node.\n2. Loop through the edges to build the `parent` array. If there is already a parent for node `v`, store this edge as `candidateA` and the current edge as `candidateB`.\n3. Loop through the nodes in the graph to find a cycle. If a cycle is found, it means the edge causing a cycle should be removed. If `candidateA` exists, return `candidateA`, otherwise return the edge causing the cycle.\n4. If no cycle is found, return `candidateB`. The presence of `candidateB` means that there is a node with two parents, which is the additional edge that needs to be removed to obtain the original tree."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) \n    // Your code here\n}\n\n",
            "java": "class Solution \n    // Your code here\n}\n\n",
            "python": "def findRedundantDirectedConnection(edges):\n    # Your code here\n\n",
            "javascript": "function findRedundantDirectedConnection(edges) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nint main() {\n    vector<vector<int>> edges = $args;\n    vector<int> result = findRedundantDirectedConnection(edges);\n    \n    for (int i = 0; i < result.size(); ++i) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n",
            "java": "public int[] findRedundantDirectedConnection(int[][] edges) {\n        int[] parent = new int[edges.length + 1];\n        int[] candidateA = null, candidateB = null;\n        \n        for (int[] edge : edges) {\n            int u = edge[0], v = edge[1];\n            if (parent[v] > 0) {\n                candidateA = new int[] {parent[v], v};\n                candidateB = edge;\n            } else {\n                parent[v] = u;\n            }\n        }\n        \n        for (int i = 1; i <= edges.length; ++i) {\n            int cycle = i, steps = edges.length;\n            while (parent[cycle] != 0 && steps-- > 0) {\n                cycle = parent[cycle];\n            }\n            if (steps == -1) {\n                if (candidateA == null) return new int[] {parent[i], i};\n                else return candidateA;\n            }\n        }\n        \n        return candidateB;\n    }",
            "python": "if __name__ == \"__main__\":\n    edges = $args[0]\n    result = findRedundantDirectedConnection(edges)\n    print(result)",
            "javascript": "function findRedundantDirectedConnection(edges) {\n    const parent = Array(edges.length + 1).fill(0);\n    let candidateA = null, candidateB = null;\n\n    for (const edge of edges) {\n        const [u, v] = edge;\n        if (parent[v] > 0) {\n            candidateA = [parent[v], v];\n            candidateB = edge;\n        } else {\n            parent[v] = u;\n        }\n    }\n\n    for (let i = 1; i <= edges.length; ++i) {\n        let cycle = i, steps = edges.length;\n        while (parent[cycle] !== 0 && steps-- > 0) {\n            cycle = parent[cycle];\n        }\n        if (steps === -1) {\n            if (candidateA === null) return [parent[i], i];\n            else return candidateA;\n        }\n    }\n\n    return candidateB;\n}"
        }
    },
    "687": {
        "title": "Longest Path with Same Value",
        "description": "Given the `root` of a binary tree, find the length of the longest path where each node in the path has the same value. The path may or may not pass through the root. The length of the path is represented by the number of edges between the nodes.",
        "example": "Example:\n\nInput: root = [5,4,5,1,1,null,5]\nOutput: 2\nExplanation: The longest path of the same value is 5 -> 5.",
        "level": "Medium",
        "tags": [
            "binary tree",
            "recursion",
            "depth-first search"
        ],
        "test_cases": {
            "inputs": [
                "[5,4,5,1,1,null,5]",
                "[1,4,5,4,4,null,5]",
                "[1,1,1,1,1,null,1]",
                "[1,2,3,4,5,null,6]",
                "[1,null,2,null,3,null,4,null,5]",
                [],
                [
                    1
                ],
                [
                    1,
                    2
                ],
                [
                    1,
                    2,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99,
                    100,
                    101,
                    102,
                    103,
                    104
                ]
            ],
            "outputs": [
                "2",
                "2",
                "6",
                "0",
                "0",
                "0",
                "0",
                "0",
                "1",
                "104"
            ]
        },
        "sample_code": {
            "c++": "int findUnivaluePath(TreeNode* node, int& maxLen) {\n    if (!node) return 0;\n    int left = findUnivaluePath(node->left, maxLen);\n    int right = findUnivaluePath(node->right, maxLen);\n    left = (node->left && node->left->val == node->val) ? left + 1 : 0;\n    right = (node->right && node->right->val == node->val) ? right + 1 : 0;\n    maxLen = max(maxLen, left + right);\n    return max(left, right);\n}\n\nint longestUnivaluePath(TreeNode* root) {\n    int maxLen = 0;\n    findUnivaluePath(root, maxLen);\n    return maxLen;\n}\n\n",
            "java": "public int longestUnivaluePath(TreeNode root) {\n    int[] maxLen = new int[1];\n    findUnivaluePath(root, maxLen);\n    return maxLen[0];\n}\n\nprivate int findUnivaluePath(TreeNode node, int[] maxLen) {\n    if (node == null) return 0;\n    int left = findUnivaluePath(node.left, maxLen);\n    int right = findUnivaluePath(node.right, maxLen);\n    left = (node.left != null && node.left.val == node.val) ? left + 1 : 0;\n    right = (node.right != null && node.right.val == node.val) ? right + 1 : 0;\n    maxLen[0] = Math.max(maxLen[0], left + right);\n    return Math.max(left, right);\n}\n\n",
            "python": "def longestUnivaluePath(root):\n    def findUnivaluePath(node):\n        if not node:\n            return 0\n        left = findUnivaluePath(node.left)\n        right = findUnivaluePath(node.right)\n        left = left + 1 if node.left and node.left.val == node.val else 0\n        right = right + 1 if node.right and node.right.val == node.val else 0\n        maxLen[0] = max(maxLen[0], left + right)\n        return max(left, right)\n\n    maxLen = [0]\n    findUnivaluePath(root)\n    return maxLen[0]\n\n",
            "javascript": "function longestUnivaluePath(root) {\n    let maxLen = 0;\n\n    function findUnivaluePath(node) {\n        if (!node) return 0;\n        let left = findUnivaluePath(node.left);\n        let right = findUnivaluePath(node.right);\n        left = (node.left && node.left.val === node.val) ? left + 1 : 0;\n        right = (node.right && node.right.val === node.val) ? right + 1 : 0;\n        maxLen = Math.max(maxLen, left + right);\n        return Math.max(left, right);\n    }\n\n    findUnivaluePath(root);\n    return maxLen;\n}\n\n",
            "explanation": "This problem can be solved by using a depth-first search approach. We first need to traverse the tree and compare the values of each node with its children. We start at the root node and, for each node, we determine if the current node has the same value as its left and right children. If it does, we calculate the univalue path for the current node by calculating the length of the path from the left subtree and the length of the path from the right subtree.\n\nWe recursively traverse the tree to find the longest univalue path, and we keep track of the maximum length found so far. When visiting a node, we call the function recursively on its left and right children. If the current node's value is the same as the left or right child, we increase the path length by 1. Otherwise, we reset the path length to 0.\n\nThe final result is the maximum univalue path found during the traversal of the tree."
        },
        "structure": {
            "c++": "int findUnivaluePath(TreeNode* node, int& maxLen) \n    // Your code here\n}\n\n",
            "java": "public int longestUnivaluePath(TreeNode root) \n    // Your code here\n}\n\n",
            "python": "def longestUnivaluePath(root):\n    # Your code here\n\n",
            "javascript": "function longestUnivaluePath(root) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    TreeNode* root = $args;\n    int result = longestUnivaluePath(root);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int longestUnivaluePath(TreeNode root) {\n    int[] maxLen = new int[1];\n    findUnivaluePath(root, maxLen);\n    return maxLen[0];\n}\n\nprivate int findUnivaluePath(TreeNode node, int[] maxLen) {\n    if (node == null) return 0;\n    int left = findUnivaluePath(node.left, maxLen);\n    int right = findUnivaluePath(node.right, maxLen);\n    left = (node.left != null && node.left.val == node.val) ? left + 1 : 0;\n    right = (node.right != null && node.right.val == node.val) ? right + 1 : 0;\n    maxLen[0] = Math.max(maxLen[0], left + right);\n    return Math.max(left, right);\n}",
            "python": "if __name__ == \"__main__\":\n    root = $args[0]\n    result = longestUnivaluePath(root)\n    print(result)",
            "javascript": "function main() {\n    const root = $args;\n    let maxLen = 0;\n\n    function findUnivaluePath(node) {\n        if (!node) return 0;\n        let left = findUnivaluePath(node.left);\n        let right = findUnivaluePath(node.right);\n        left = (node.left && node.left.val === node.val) ? left + 1 : 0;\n        right = (node.right && node.right.val === node.val) ? right + 1 : 0;\n        maxLen = Math.max(maxLen, left + right);\n        return Math.max(left, right);\n    }\n\n    findUnivaluePath(root);\n    return maxLen;\n}\n\nconst result = main();\nconsole.log(result);"
        }
    },
    "688": {
        "title": "Knight's Probability on Chessboard",
        "description": "On an `n x n` chessboard, a knight starts at the cell `(row, column)` and attempts to make exactly `k` moves. The rows and columns are **0-indexed**, so the top-left cell is `(0, 0)`, and the bottom-right cell is `(n - 1, n - 1)`.\n\nA chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.\n\nEach time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\n\nThe knight continues moving until it has made exactly `k` moves or has moved off the chessboard.\n\nReturn the probability that the knight remains on the board after it has stopped moving.",
        "example": "Example:\n\nInput: n = 3, k = 2, row = 0, column = 0\nOutput: 0.06250\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\nFrom each of those positions, there are also two moves that will keep the knight on the board.\nThe total probability the knight stays on the board is 0.0625.",
        "level": "Medium",
        "tags": [
            "probability",
            "chess",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    2,
                    0,
                    0
                ],
                [
                    1,
                    0,
                    0,
                    0
                ],
                [
                    5,
                    3,
                    2,
                    2
                ],
                [
                    4,
                    1,
                    1,
                    2
                ],
                [
                    2,
                    0,
                    1,
                    1
                ],
                [
                    6,
                    4,
                    3,
                    3
                ],
                [
                    8,
                    5,
                    4,
                    4
                ],
                [
                    10,
                    6,
                    5,
                    5
                ],
                [
                    12,
                    7,
                    6,
                    6
                ],
                [
                    15,
                    8,
                    7,
                    7
                ],
                [
                    20,
                    10,
                    9,
                    9
                ],
                [
                    25,
                    12,
                    11,
                    11
                ],
                [
                    25,
                    15,
                    12,
                    12
                ],
                [
                    25,
                    20,
                    13,
                    13
                ],
                [
                    25,
                    25,
                    14,
                    14
                ],
                [
                    25,
                    0,
                    0,
                    0
                ],
                [
                    25,
                    100,
                    0,
                    0
                ],
                [
                    25,
                    0,
                    24,
                    24
                ],
                [
                    25,
                    100,
                    24,
                    24
                ],
                [
                    25,
                    12,
                    6,
                    6
                ]
            ],
            "outputs": [
                0.0625,
                1.0,
                0.0,
                0.25,
                0.0,
                0.0,
                0.0,
                0.0,
                0.0,
                0.0,
                0.0,
                0.0,
                0.0,
                0.0,
                0.0,
                0.0,
                0.0,
                0.0,
                0.0,
                0.0
            ]
        },
        "sample_code": {
            "c++": "double knightProbability(int n, int k, int row, int column) {\n    vector<vector<vector<double>>> memo(n, vector<vector<double>>(n, vector<double>(k + 1, -1.0)));\n    return helper(n, k, row, column, memo);\n}\n\ndouble helper(int n, int k, int row, int column, vector<vector<vector<double>>>& memo) {\n    if (row < 0 || row >= n || column < 0 || column >= n) return 0.0;\n    if (k == 0) return 1.0;\n    if (memo[row][column][k] >= 0) return memo[row][column][k];\n    \n    double result = 0.0;\n    int moves[8][2] = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\n    for (int i = 0; i < 8; ++i)\n        result += helper(n, k - 1, row + moves[i][0], column + moves[i][1], memo) / 8;\n    \n    memo[row][column][k] = result;\n    return result;\n}\n",
            "java": "public double knightProbability(int n, int k, int row, int column) {\n    double[][][] memo = new double[n][n][k + 1];\n    for (double[][] m : memo)\n        for (double[] l : m)\n            Arrays.fill(l, -1.0);\n    return helper(n, k, row, column, memo);\n}\n\ndouble helper(int n, int k, int row, int column, double[][][] memo) {\n    if (row < 0 || row >= n || column < 0 || column >= n) return 0.0;\n    if (k == 0) return 1.0;\n    if (memo[row][column][k] >= 0) return memo[row][column][k];\n\n    double result = 0.0;\n    int[][] moves = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\n    for (int i = 0; i < 8; ++i)\n        result += helper(n, k - 1, row + moves[i][0], column + moves[i][1], memo) / 8;\n\n    memo[row][column][k] = result;\n    return result;\n}\n",
            "python": "def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n    memo = [[[-1.0 for _ in range(k + 1)] for _ in range(n)] for _ in range(n)]\n    return self.helper(n, k, row, column, memo)\n\ndef helper(self, n, k, row, column, memo):\n    if row < 0 or row >= n or column < 0 or column >= n:\n        return 0.0\n    if k == 0:\n        return 1.0\n    if memo[row][column][k] >= 0:\n        return memo[row][column][k]\n\n    result = 0.0\n    moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    for move in moves:\n        result += self.helper(n, k - 1, row + move[0], column + move[1], memo) / 8\n\n    memo[row][column][k] = result\n    return result\n",
            "javascript": "function knightProbability(n, k, row, column) {\n    let memo = new Array(n).fill().map(() => new Array(n).fill().map(() => new Array(k + 1).fill(-1)));\n    return helper(n, k, row, column, memo);\n}\n\nfunction helper(n, k, row, column, memo) {\n    if (row < 0 || row >= n || column < 0 || column >= n) return 0.0;\n    if (k === 0) return 1.0;\n    if (memo[row][column][k] >= 0) return memo[row][column][k];\n    \n    let result = 0.0;\n    let moves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];\n    for (let i = 0; i < 8; ++i)\n        result += helper(n, k - 1, row + moves[i][0], column + moves[i][1], memo) / 8;\n\n    memo[row][column][k] = result;\n    return result;\n}\n",
            "explanation": "The algorithm uses a depth-first search and memoization approach to find the probability that the knight remains on the board after k moves. It utilizes helper function, which receives parameters `n`, `k`, `row`, `column`, and `memo`.\n\nAt each step of the helper function, we check if the current position (row and column) is off the board. If it is, we return 0, as the knight is no longer on the board. If `k` equals 0, it means the knight has completed its moves and is still on the board, so we return 1. If the memo table has a valid value for the current position and moves remaining (k), we can return the memoized value to avoid redundant calculations.\n\nNext, we set a variable `result` to 0 and define an array of possible knight moves. We iterate through these moves and recursively call the helper function with the updated position (row + move[0], column + move[1]) and k - 1 moves remaining. We divide the result by 8 because the knight has 8 possible moves, and we need the average probability of staying on the board for each move. We store the result in the memo table and return it.\n\nWe call the helper function with the initial values for the given problem, and it returns the probability that the knight remains on the board after k moves."
        },
        "structure": {
            "c++": "double knightProbability(int n, int k, int row, int column) \n    // Your code here\n}\n",
            "java": "public double knightProbability(int n, int k, int row, int column) \n    // Your code here\n}\n",
            "python": "def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n    # Your code here\n\n",
            "javascript": "function knightProbability(n, k, row, column) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "double knightProbability(int n, int k, int row, int column) {\n    vector<vector<vector<double>>> memo(n, vector<vector<double>>(n, vector<double>(k + 1, -1.0)));\n    return helper(n, k, row, column, memo);\n}\n\ndouble helper(int n, int k, int row, int column, vector<vector<vector<double>>>& memo) {\n    if (row < 0 || row >= n || column < 0 || column >= n) return 0.0;\n    if (k == 0) return 1.0;\n    if (memo[row][column][k] >= 0) return memo[row][column][k];\n    \n    double result = 0.0;\n    int moves[8][2] = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\n    for (int i = 0; i < 8; ++i)\n        result += helper(n, k - 1, row + moves[i][0], column + moves[i][1], memo) / 8;\n    \n    memo[row][column][k] = result;\n    return result;\n}",
            "java": "public double knightProbability(int n, int k, int row, int column) {\n    double[][][] memo = new double[n][n][k + 1];\n    for (double[][] m : memo)\n        for (double[] l : m)\n            Arrays.fill(l, -1.0);\n    return helper(n, k, row, column, memo);\n}\n\ndouble helper(int n, int k, int row, int column, double[][][] memo) {\n    if (row < 0 || row >= n || column < 0 || column >= n) return 0.0;\n    if (k == 0) return 1.0;\n    if (memo[row][column][k] >= 0) return memo[row][column][k];\n\n    double result = 0.0;\n    int[][] moves = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\n    for (int i = 0; i < 8; ++i)\n        result += helper(n, k - 1, row + moves[i][0], column + moves[i][1], memo) / 8;\n\n    memo[row][column][k] = result;\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    k = $args[1]\n    row = $args[2]\n    column = $args[3]\n    obj = Solution()\n    result = obj.knightProbability(n, k, row, column)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = knightProbability(n[0], n[1], n[2], n[3]);\n    console.log(result);\n}"
        }
    },
    "689": {
        "title": "Maximum Sum of Three Non-Overlapping Subarrays",
        "description": "Given an integer array `nums` and an integer `k`, find three non-overlapping subarrays of length `k` with maximum sum and return their starting positions as a list of indices (0-indexed). If there are multiple answers, return the lexicographically smallest one.",
        "example": "Example:\n\nInput: nums = [1,2,1,2,6,7,5,1], k = 2\nOutput: [0,3,5]\nExplanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5]. We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.",
        "level": "Medium",
        "tags": [
            "array",
            "subarray",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    1,
                    2,
                    6,
                    7,
                    5,
                    1
                ],
                [
                    1,
                    2,
                    1,
                    2,
                    1,
                    2,
                    1,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11
                ],
                [
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12
                ],
                [
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13
                ],
                [
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14
                ],
                [
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15
                ],
                [
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ]
            ],
            "outputs": [
                "[0,3,5]",
                "[0,2,4]",
                "[0,3,6]",
                "[0,1,2]",
                "[0,3,6]",
                "[0,3,6]",
                "[0,3,6]",
                "[0,1,2]",
                "[0,3,6]",
                "[0,3,7]",
                "[0,1,5]",
                "[0,3,7]",
                "[0,3,8]",
                "[0,1,6]",
                "[0,3,8]",
                "[0,3,9]",
                "[0,1,7]",
                "[0,3,9]",
                "[0,3,10]",
                "[0,1,8]",
                "[0,3,10]",
                "[0,3,11]",
                "[0,1,9]",
                "[0,3,11]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nstd::vector<int> max_sum_of_three_subarrays(std::vector<int> &nums, int k) {\n    int n = nums.size();\n    std::vector<int> sums(n - k + 1);\n    std::vector<int> left(n), right(n), ans(3);\n    int acc_sum = 0;\n\n    for (int i = 0; i < n; ++i) {\n        acc_sum += nums[i];\n        if (i >= k) {\n            acc_sum -= nums[i - k];\n        }\n        if (i >= k - 1) {\n            sums[i - k + 1] = acc_sum;\n        }\n    }\n\n    left[0] = 0;\n    right[n - k] = n - k;\n\n    for (int i = 1; i < n - k + 1; ++i) {\n        left[i] = sums[i] > sums[left[i - 1]] ? i : left[i - 1];\n    }\n\n    for (int i = n - k - 1; i >= 0; --i) {\n        right[i] = sums[i] >= sums[right[i + 1]] ? i : right[i + 1];\n    }\n\n    int max_sum = 0;\n\n    for (int i = k; i < n - 2 * k + 1; ++i) {\n        int left_idx = left[i - k], right_idx = right[i + k], total_sum = sums[left_idx] + sums[i] + sums[right_idx];\n        if (total_sum > max_sum) {\n            max_sum = total_sum;\n            ans = {left_idx, i, right_idx};\n        }\n    }\n\n    return ans;\n}\n",
            "java": "import java.util.Arrays;\n\npublic int[] max_sum_of_three_subarrays(int[] nums, int k) {\n    int n = nums.length;\n    int[] sums = new int[n - k + 1];\n    int[] left = new int[n], right = new int[n], ans = new int[3];\n    int acc_sum = 0;\n\n    for (int i = 0; i < n; ++i) {\n        acc_sum += nums[i];\n        if (i >= k) {\n            acc_sum -= nums[i - k];\n        }\n        if (i >= k - 1) {\n            sums[i - k + 1] = acc_sum;\n        }\n    }\n\n    left[0] = 0;\n    right[n - k] = n - k;\n\n    for (int i = 1; i < n - k + 1; ++i) {\n        left[i] = sums[i] > sums[left[i - 1]] ? i : left[i - 1];\n    }\n\n    for (int i = n - k - 1; i >= 0; --i) {\n        right[i] = sums[i] >= sums[right[i + 1]] ? i : right[i + 1];\n    }\n\n    int max_sum = 0;\n\n    for (int i = k; i < n - 2 * k + 1; ++i) {\n        int left_idx = left[i - k], right_idx = right[i + k], total_sum = sums[left_idx] + sums[i] + sums[right_idx];\n        if (total_sum > max_sum) {\n            max_sum = total_sum;\n            ans = new int[] {left_idx, i, right_idx};\n        }\n    }\n\n    return ans;\n}\n",
            "python": "def max_sum_of_three_subarrays(nums, k):\n    n = len(nums)\n    sums = [0] * (n - k + 1)\n    left, right = [0] * n, [0] * n\n\n    acc_sum = 0\n    for i in range(n):\n        acc_sum += nums[i]\n        if i >= k:\n            acc_sum -= nums[i - k]\n        if i >= k - 1:\n            sums[i - k + 1] = acc_sum\n\n    left[0] = 0\n    right[n - k] = n - k\n    for i in range(1, n - k + 1):\n        left[i] = i if sums[i] > sums[left[i - 1]] else left[i - 1]\n\n    for i in range(n - k - 1, -1, -1):\n        right[i] = i if sums[i] >= sums[right[i + 1]] else right[i + 1]\n\n    max_sum, ans = 0, [0] * 3\n    for i in range(k, n - 2 * k + 1):\n        left_idx, right_idx = left[i - k], right[i + k]\n        total_sum = sums[left_idx] + sums[i] + sums[right_idx]\n        if total_sum > max_sum:\n            max_sum = total_sum\n            ans = [left_idx, i, right_idx]\n\n    return ans\n",
            "javascript": "function max_sum_of_three_subarrays(nums, k) {\n    const n = nums.length;\n    const sums = new Array(n - k + 1);\n    const left = new Array(n), right = new Array(n);\n    let acc_sum = 0;\n\n    for (let i = 0; i < n; i++) {\n        acc_sum += nums[i];\n        if (i >= k) {\n            acc_sum -= nums[i - k];\n        }\n        if (i >= k - 1) {\n            sums[i - k + 1] = acc_sum;\n        }\n    }\n\n    left[0] = 0;\n    right[n - k] = n - k;\n\n    for (let i = 1; i < n - k + 1; i++) {\n        left[i] = sums[i] > sums[left[i - 1]] ? i : left[i - 1];\n    }\n\n    for (let i = n - k - 1; i >= 0; i--) {\n        right[i] = sums[i] >= sums[right[i + 1]] ? i : right[i + 1];\n    }\n\n    let max_sum = 0;\n    const ans = [0, 0, 0];\n\n    for (let i = k; i < n - 2 * k + 1; i++) {\n        const left_idx = left[i - k], right_idx = right[i + k], total_sum = sums[left_idx] + sums[i] + sums[right_idx];\n        if (total_sum > max_sum) {\n            max_sum = total_sum;\n            ans[0] = left_idx;\n            ans[1] = i;\n            ans[2] = right_idx;\n        }\n    }\n\n    return ans;\n}\n",
            "explanation": "First, we compute the k-length subarrays' sums into the array `sums`. We use cumulative sum to optimize the calculation of the sums.\n\nWe then initialize two arrays, `left` and `right`, both of size `n`.\n\nWe start populating `left` and `right` as follows:\n- For `left`, we iterate from 1 to (n - k), and store the starting index of the max subarray sum among subarrays ending at the currentIndex or earlier.\n- For `right`, we iterate from (n - k - 1) to 0, in reverse, and store the starting index of the max subarray sum among subarrays starting at the currentIndex or later.\n\nNext, we loop through `sums` from index `k` to `n - 2 * k`, and calculate the total sum of the subarrays indicated by the `left`, `current index`, and `right` arrays for each position.\n\nFinally, we compare the calculated sum to the current maximum sum, and if it's greater, we update the maximum sum and the `answer` array with the starting indices of the subarrays. At the end of the loop, we return the `answer` array containing the indices of the three non-overlapping subarrays with the maximum sum."
        },
        "structure": {
            "c++": "#include <vector>\n\nstd::vector<int> max_sum_of_three_subarrays(std::vector<int> &nums, int k) \n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\n\npublic int[] max_sum_of_three_subarrays(int[] nums, int k) \n    // Your code here\n}\n",
            "python": "def max_sum_of_three_subarrays(nums, k):\n    # Your code here\n\n",
            "javascript": "function max_sum_of_three_subarrays(nums, k) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nstd::vector<int> max_sum_of_three_subarrays(std::vector<int> &nums, int k);\n\nint main() {\n    std::vector<int> nums = $args;\n    int k = 3;\n    std::vector<int> result = max_sum_of_three_subarrays(nums, k);\n    for (int i = 0; i < result.size(); ++i) {\n        std::cout << result[i] << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}\n\nstd::vector<int> max_sum_of_three_subarrays(std::vector<int> &nums, int k) {\n    int n = nums.size();\n    std::vector<int> sums(n - k + 1);\n    std::vector<int> left(n), right(n), ans(3);\n    int acc_sum = 0;\n\n    for (int i = 0; i < n; ++i) {\n        acc_sum += nums[i];\n        if (i >= k) {\n            acc_sum -= nums[i - k];\n        }\n        if (i >= k - 1) {\n            sums[i - k + 1] = acc_sum;\n        }\n    }\n\n    left[0] = 0;\n    right[n - k] = n - k;\n\n    for (int i = 1; i < n - k + 1; ++i) {\n        left[i] = sums[i] > sums[left[i - 1]] ? i : left[i - 1];\n    }\n\n    for (int i = n - k - 1; i >= 0; --i) {\n        right[i] = sums[i] >= sums[right[i + 1]] ? i : right[i + 1];\n    }\n\n    int max_sum = 0;\n\n    for (int i = k; i < n - 2 * k + 1; ++i) {\n        int left_idx = left[i - k], right_idx = right[i + k], total_sum = sums[left_idx] + sums[i] + sums[right_idx];\n        if (total_sum > max_sum) {\n            max_sum = total_sum;\n            ans = {left_idx, i, right_idx};\n        }\n    }\n\n    return ans;\n}",
            "java": "public int[] max_sum_of_three_subarrays(int[] nums, int k) {\n    int n = nums.length;\n    int[] sums = new int[n - k + 1];\n    int[] left = new int[n], right = new int[n], ans = new int[3];\n    int acc_sum = 0;\n\n    for (int i = 0; i < n; ++i) {\n        acc_sum += nums[i];\n        if (i >= k) {\n            acc_sum -= nums[i - k];\n        }\n        if (i >= k - 1) {\n            sums[i - k + 1] = acc_sum;\n        }\n    }\n\n    left[0] = 0;\n    right[n - k] = n - k;\n\n    for (int i = 1; i < n - k + 1; ++i) {\n        left[i] = sums[i] > sums[left[i - 1]] ? i : left[i - 1];\n    }\n\n    for (int i = n - k - 1; i >= 0; --i) {\n        right[i] = sums[i] >= sums[right[i + 1]] ? i : right[i + 1];\n    }\n\n    int max_sum = 0;\n\n    for (int i = k; i < n - 2 * k + 1; ++i) {\n        int left_idx = left[i - k], right_idx = right[i + k], total_sum = sums[left_idx] + sums[i] + sums[right_idx];\n        if (total_sum > max_sum) {\n            max_sum = total_sum;\n            ans = new int[] {left_idx, i, right_idx};\n        }\n    }\n\n    return ans;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    k = $args[1]\n    result = max_sum_of_three_subarrays(nums, k)\n    print(result)",
            "javascript": "function max_sum_of_three_subarrays(nums, k) {\n    const n = nums.length;\n    const sums = new Array(n - k + 1);\n    const left = new Array(n), right = new Array(n);\n    let acc_sum = 0;\n\n    for (let i = 0; i < n; i++) {\n        acc_sum += nums[i];\n        if (i >= k) {\n            acc_sum -= nums[i - k];\n        }\n        if (i >= k - 1) {\n            sums[i - k + 1] = acc_sum;\n        }\n    }\n\n    left[0] = 0;\n    right[n - k] = n - k;\n\n    for (let i = 1; i < n - k + 1; i++) {\n        left[i] = sums[i] > sums[left[i - 1]] ? i : left[i - 1];\n    }\n\n    for (let i = n - k - 1; i >= 0; i--) {\n        right[i] = sums[i] >= sums[right[i + 1]] ? i : right[i + 1];\n    }\n\n    let max_sum = 0;\n    const ans = [0, 0, 0];\n\n    for (let i = k; i < n - 2 * k + 1; i++) {\n        const left_idx = left[i - k], right_idx = right[i + k], total_sum = sums[left_idx] + sums[i] + sums[right_idx];\n        if (total_sum > max_sum) {\n            max_sum = total_sum;\n            ans[0] = left_idx;\n            ans[1] = i;\n            ans[2] = right_idx;\n        }\n    }\n\n    return ans;\n}"
        }
    },
    "691": {
        "title": "Minimum Stickers to Spell Target",
        "description": "You are given `n` different types of `stickers`. Each sticker has a lowercase English word on it. You would like to spell out the given string `target` by cutting individual letters from your collection of stickers and rearranging them. You can use each sticker more than once if you want, and you have infinite quantities of each sticker. Return the minimum number of stickers that you need to spell out `target`. If the task is impossible, return -1.",
        "example": "Example:\n\nInput: stickers = [\"with \", \"example \", \"science \"], target = \"thehat \"\nOutput: 3\nExplanation: We can use 2 \"with \" stickers, and 1 \"example \" sticker. After cutting and rearranging the letters of those stickers, we can form the target \"thehat \". This is the minimum number of stickers necessary to form the target string.",
        "level": "Medium",
        "tags": [
            "string",
            "greedy"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "with ",
                        "example ",
                        "science "
                    ],
                    "thehat "
                ],
                [
                    [
                        "notice ",
                        "possible "
                    ],
                    "basicbasic "
                ],
                [
                    [
                        "apple ",
                        "banana ",
                        "cherry "
                    ],
                    "pineapple "
                ],
                [
                    [
                        "hello ",
                        "world "
                    ],
                    "helloworld "
                ],
                [
                    [
                        "coding ",
                        "is ",
                        "fun "
                    ],
                    "codingisfun "
                ],
                [
                    [
                        "this ",
                        "is ",
                        "a ",
                        "test "
                    ],
                    "thisisatest "
                ],
                [
                    [
                        "one ",
                        "two ",
                        "three ",
                        "four "
                    ],
                    "onetwothreefour "
                ],
                [
                    [
                        "red ",
                        "blue ",
                        "green "
                    ],
                    "yellow "
                ],
                [
                    [
                        "cat ",
                        "dog ",
                        "bird "
                    ],
                    "fish "
                ],
                [
                    [
                        "good ",
                        "bad ",
                        "ugly "
                    ],
                    "beautiful "
                ],
                [
                    [
                        "happy ",
                        "sad ",
                        "angry "
                    ],
                    "excited "
                ],
                [
                    [
                        "big ",
                        "small ",
                        "medium "
                    ],
                    "tiny "
                ],
                [
                    [
                        "hot ",
                        "cold ",
                        "warm "
                    ],
                    "cool "
                ],
                [
                    [
                        "fast ",
                        "slow ",
                        "steady "
                    ],
                    "quick "
                ],
                [
                    [
                        "high ",
                        "low ",
                        "medium "
                    ],
                    "average "
                ],
                [
                    [
                        "north ",
                        "south ",
                        "east ",
                        "west "
                    ],
                    "direction "
                ],
                [
                    [
                        "sun ",
                        "moon ",
                        "stars "
                    ],
                    "galaxy "
                ],
                [
                    [
                        "happy ",
                        "birthday "
                    ],
                    "celebrate "
                ],
                [
                    [
                        "good ",
                        "morning "
                    ],
                    "greet "
                ],
                [
                    [
                        "have ",
                        "a ",
                        "nice ",
                        "day "
                    ],
                    "enjoy "
                ]
            ],
            "outputs": [
                3,
                -1,
                3,
                2,
                3,
                4,
                4,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minStickers(vector<string>& stickers, string target) {\n    unordered_map<string, int> memo;\n    vector<int> target_count(26, 0);\n    for (char c : target) target_count[c - 'a']++;\n    \n    for (string& s : stickers) {\n        vector<int> sticker_count(26, 0);\n        int connection = 0;\n        for (char c : s) {\n            if (!target_count[c - 'a']) continue;\n            connection = 1;\n            sticker_count[c - 'a']++;\n        }\n        if (!connection) continue;\n        \n        string state = \"\";\n        for (int i = 0; i < 26; ++i)\n            state += string(sticker_count[i], 'a' + i);\n        memo[state] = 1;\n    }\n    \n    function<int(const string&)> dp = [&](const string& state) {\n        if (memo.count(state)) return memo[state];\n        vector<int> counts(26, 0);\n        for (char c : state) counts[c - 'a']++;\n        int ans = INT_MAX;\n        for (const auto& kv : memo) {\n            bool ok = true;\n            for (int i = 0; i < 26 && ok; ++i)\n                ok = counts[i] >= kv.first[i] - 'a';\n            if (!ok) continue;\n            ans = min(ans, dp(state.substr(kv.first.size())) + kv.second);\n        }\n        memo[state] = ans == INT_MAX ? -1 : ans;\n        return memo[state];\n    };\n    \n    string start = \"\";\n    for (int i = 0; i < 26; ++i)\n        start += string(target_count[i], 'a' + i);\n    return dp(start);\n}\n",
            "java": "import java.util.HashMap;\nimport java.util.Map;\n\nclass Solution {\n    public int minStickers(String[] stickers, String target) {\n        Map<String, Integer> memo = new HashMap<>();\n        int[] targetCount = new int[26];\n        for (char c : target.toCharArray()) targetCount[c - 'a']++;\n        \n        for (String s : stickers) {\n            int[] stickerCount = new int[26];\n            StringBuilder sb = new StringBuilder();\n            for (char c : s.toCharArray()) {\n                if (targetCount[c - 'a'] == 0) continue;\n                stickerCount[c - 'a']++;\n            }\n            for (int i = 0; i < 26; ++i) {\n                sb.append(String.valueOf((char) ('a' + i)).repeat(stickerCount[i]));\n            }\n            memo.put(sb.toString(), 1);\n        }\n        \n        return dp(memo, targetCount, target);\n    }\n    \n    private int dp(Map<String, Integer> memo, int[] targetCount, String target) {\n        if (memo.containsKey(target)) return memo.get(target);\n        int[] counts = new int[26];\n        for (char c : target.toCharArray()) counts[c - 'a']++;\n        int ans = Integer.MAX_VALUE;\n        for (Map.Entry<String, Integer> kv : memo.entrySet()) {\n            boolean ok = true;\n            for (int i = 0; i < 26 && ok; ++i)\n                ok = counts[i] >= kv.getKey().charAt(i) - 'a';\n            if (!ok) continue;\n            ans = Math.min(ans, dp(memo, targetCount, target.substring(kv.getKey().length())) + kv.getValue());\n        }\n        memo.put(target, ans == Integer.MAX_VALUE ? -1 : ans);\n        return memo.get(target);\n    }\n}\n",
            "python": "from collections import Counter\nfrom functools import lru_cache\n\ndef minStickers(stickers, target):\n    target_count = Counter(target)\n    memo = {}\n    \n    for s in stickers:\n        sticker_count = Counter(s)\n        state = ''.join(sticker_count & target_count)\n        memo[state] = 1\n    \n    @lru_cache(None)\n    def dp(state):\n        counts = Counter(state)\n        ans = float('inf')\n        for key, value in memo.items():\n            if any(counts[ch] < key.count(ch) for ch in state): continue\n            ans = min(ans, dp(state.translate(str.maketrans('', '', key))) + value)\n        return -1 if ans == float('inf') else ans\n    \n    return dp(target)\n",
            "javascript": "function minStickers(stickers, target) {\n    let targetCount = new Array(26).fill(0);\n    let memo = new Map();\n    for (let c of target) targetCount[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n\n    for (let s of stickers) {\n        let stickerCount = new Array(26).fill(0);\n        let state = \"\";\n        for (let c of s) {\n            if (!targetCount[c.charCodeAt(0) - 'a'.charCodeAt(0)]) continue;\n            stickerCount[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n        }\n        for (let i = 0; i < 26; ++i) {\n            state += String.fromCharCode('a'.charCodeAt(0) + i).repeat(stickerCount[i]);\n        }\n        memo.set(state, 1);\n    }\n    \n    return dp(memo, target);\n}\n\nfunction dp(memo, target) {\n    if (memo.has(target)) return memo.get(target);\n    let counts = new Array(26).fill(0);\n    for (let c of target) counts[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    let ans = Infinity;\n    for (let [key, value] of memo) {\n        let ok = true;\n        for (let i = 0; i < 26 && ok; ++i)\n            ok = counts[i] >= (key.match(new RegExp(String.fromCharCode('a'.charCodeAt(0) + i), 'g')) || []).length;\n        if (!ok) continue;\n        ans = Math.min(ans, dp(memo, target.substring(key.length)) + value);\n    }\n    memo.set(target, ans == Infinity ? -1 : ans);\n    return memo.get(target);\n}\n",
            "explanation": "The solution to the problem is recursive in nature, with memoization technique to optimize the solution further. The core idea is to calculate the frequency count for each character in the target string, and to iterate over each sticker and create a character frequency count for it while checking if the target string needs the characters present in that sticker. After creating the initial memo, we define a function `dp` that accepts the state of target and memo, and performs recursion to find the minimum count required to build the target.\n\nIn each step, we construct the frequency count needed for the remaining target and iterate through each possible remaining substring. If any substring can be formed with any subsequence of a sticker, the function calls itself recursively with the remaining characters and adds the count of that sticker. The answer is the minimum number of stickers required among all the possibilities. At the end, the base case is when the state is not present; it will return -1. It starts from the complete target and proceeds further solving the subproblems."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint minStickers(vector<string>& stickers, string target) \n    // Your code here\n}\n",
            "java": "import java.util.HashMap;\nimport java.util.Map;\n\nclass Solution \n    // Your code here\n}\n",
            "python": "from collections import Counter\n    # Your code here\n\n",
            "javascript": "function minStickers(stickers, target) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int minStickers(vector<string>& stickers, string target) {\n    unordered_map<string, int> memo;\n    vector<int> target_count(26, 0);\n    for (char c : target) target_count[c - 'a']++;\n    \n    for (string& s : stickers) {\n        vector<int> sticker_count(26, 0);\n        int connection = 0;\n        for (char c : s) {\n            if (!target_count[c - 'a']) continue;\n            connection = 1;\n            sticker_count[c - 'a']++;\n        }\n        if (!connection) continue;\n        \n        string state = \"\";\n        for (int i = 0; i < 26; ++i)\n            state += string(sticker_count[i], 'a' + i);\n        memo[state] = 1;\n    }\n    \n    function<int(const string&)> dp = [&](const string& state) {\n        if (memo.count(state)) return memo[state];\n        vector<int> counts(26, 0);\n        for (char c : state) counts[c - 'a']++;\n        int ans = INT_MAX;\n        for (const auto& kv : memo) {\n            bool ok = true;\n            for (int i = 0; i < 26 && ok; ++i)\n                ok = counts[i] >= kv.first[i] - 'a';\n            if (!ok) continue;\n            ans = min(ans, dp(state.substr(kv.first.size())) + kv.second);\n        }\n        memo[state] = ans == INT_MAX ? -1 : ans;\n        return memo[state];\n    };\n    \n    string start = \"\";\n    for (int i = 0; i < 26; ++i)\n        start += string(target_count[i], 'a' + i);\n    return dp(start);\n}",
            "java": "public int minStickers(String[] stickers, String target) {\n        Map<String, Integer> memo = new HashMap<>();\n        int[] targetCount = new int[26];\n        for (char c : target.toCharArray()) targetCount[c - 'a']++;\n        \n        for (String s : stickers) {\n            int[] stickerCount = new int[26];\n            StringBuilder sb = new StringBuilder();\n            for (char c : s.toCharArray()) {\n                if (targetCount[c - 'a'] == 0) continue;\n                stickerCount[c - 'a']++;\n            }\n            for (int i = 0; i < 26; ++i) {\n                sb.append(String.valueOf((char) ('a' + i)).repeat(stickerCount[i]));\n            }\n            memo.put(sb.toString(), 1);\n        }\n        \n        return dp(memo, targetCount, target);\n    }\n    \n    private int dp(Map<String, Integer> memo, int[] targetCount, String target) {\n        if (memo.containsKey(target)) return memo.get(target);\n        int[] counts = new int[26];\n        for (char c : target.toCharArray()) counts[c - 'a']++;\n        int ans = Integer.MAX_VALUE;\n        for (Map.Entry<String, Integer> kv : memo.entrySet()) {\n            boolean ok = true;\n            for (int i = 0; i < 26 && ok; ++i)\n                ok = counts[i] >= kv.getKey().charAt(i) - 'a';\n            if (!ok) continue;\n            ans = Math.min(ans, dp(memo, targetCount, target.substring(kv.getKey().length())) + kv.getValue());\n        }\n        memo.put(target, ans == Integer.MAX_VALUE ? -1 : ans);\n        return memo.get(target);\n    }",
            "python": "if __name__ == \"__main__\":\n    stickers = $args[0]\n    target = $args[1]\n    result = minStickers(stickers, target)\n    print(result)",
            "javascript": "function minStickers(stickers, target) {\n    let targetCount = new Array(26).fill(0);\n    let memo = new Map();\n    for (let c of target) targetCount[c.charCodeAt(0) - \"a\".charCodeAt(0)]++;\n\n    for (let s of stickers) {\n        let stickerCount = new Array(26).fill(0);\n        let state = \"\";\n        for (let c of s) {\n            if (!targetCount[c.charCodeAt(0) - \"a\".charCodeAt(0)]) continue;\n            stickerCount[c.charCodeAt(0) - \"a\".charCodeAt(0)]++;\n        }\n        for (let i = 0; i < 26; ++i) {\n            state += String.fromCharCode(\"a\".charCodeAt(0) + i).repeat(stickerCount[i]);\n        }\n        memo.set(state, 1);\n    }\n\n    return dp(memo, target);\n}\n\nfunction dp(memo, target) {\n    if (memo.has(target)) return memo.get(target);\n    let counts = new Array(26).fill(0);\n    for (let c of target) counts[c.charCodeAt(0) - \"a\".charCodeAt(0)]++;\n    let ans = Infinity;\n    for (let [key, value] of memo) {\n        let ok = true;\n        for (let i = 0; i < 26 && ok; ++i)\n            ok = counts[i] >= (key.match(new RegExp(String.fromCharCode(\"a\".charCodeAt(0) + i), \"g\")) || []).length;\n        if (!ok) continue;\n        ans = Math.min(ans, dp(memo, target.substring(key.length)) + value);\n    }\n    memo.set(target, ans == Infinity ? -1 : ans);\n    return memo.get(target);\n}"
        }
    },
    "692": {
        "title": "K Most Frequent Strings",
        "description": "Given an array of strings `words` and an integer `k`, return the `k` most frequent strings. Sort the words based on their frequency in descending order. If two words have the same frequency, sort them lexicographically in ascending order.",
        "example": "Example:\n\nInput: words = [\"i \", \"love \", \"leetcode \", \"i \", \"love \", \"coding \"], k = 2\nOutput: [\"i \", \"love \"]\nExplanation: \"i \" and \"love \" are the two most frequent words. \"i \" comes before \"love \" due to a lower alphabetical order.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting",
            "frequency"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "i ",
                        "love ",
                        "leetcode ",
                        "i ",
                        "love ",
                        "coding "
                    ],
                    2
                ],
                [
                    [
                        "the ",
                        "day ",
                        "is ",
                        "sunny ",
                        "the ",
                        "the ",
                        "the ",
                        "sunny ",
                        "is ",
                        "is "
                    ],
                    4
                ],
                [
                    [
                        "apple ",
                        "banana ",
                        "cherry ",
                        "apple ",
                        "banana ",
                        "cherry ",
                        "apple ",
                        "banana ",
                        "cherry "
                    ],
                    3
                ],
                [
                    [
                        "hello ",
                        "world ",
                        "hello ",
                        "world ",
                        "hello ",
                        "world "
                    ],
                    2
                ],
                [
                    [
                        "a ",
                        "b ",
                        "c ",
                        "d ",
                        "e ",
                        "f ",
                        "g ",
                        "h ",
                        "i ",
                        "j ",
                        "k ",
                        "l ",
                        "m ",
                        "n ",
                        "o ",
                        "p ",
                        "q ",
                        "r ",
                        "s ",
                        "t ",
                        "u ",
                        "v ",
                        "w ",
                        "x ",
                        "y ",
                        "z "
                    ],
                    5
                ]
            ],
            "outputs": [
                [
                    "i ",
                    "love "
                ],
                [
                    "the ",
                    "is ",
                    "sunny ",
                    "day "
                ],
                [
                    "apple ",
                    "banana ",
                    "cherry "
                ],
                [
                    "hello ",
                    "world "
                ],
                [
                    "a ",
                    "b ",
                    "c ",
                    "d ",
                    "e "
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n#include <queue>\nusing namespace std;\n\nvector<string> kFrequentWords(vector<string>& words, int k) {\n    unordered_map<string, int> wordCount;\n    for (const auto& word : words) {\n        wordCount[word]++;\n    }\n\n    auto comp = [](const pair<string, int>& a, const pair<string, int>& b) {\n        if (a.second == b.second) {\n            return a.first > b.first;\n        }\n        return a.second < b.second;\n    };\n    priority_queue<pair<string, int>, vector<pair<string, int>>, decltype(comp)> pq(comp);\n\n    for (const auto& wc : wordCount) {\n        pq.push(wc);\n    }\n\n    vector<string> result;\n    for (int i = 0; i < k; ++i) {\n        result.push_back(pq.top().first);\n        pq.pop();\n    }\n\n    return result;\n}\n",
            "java": "import java.util.*;\n\npublic class Solution {\n    public List<String> kFrequentWords(String[] words, int k) {\n        Map<String, Integer> wordCount = new HashMap<>();\n        for (String word : words) {\n            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\n        }\n\n        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(\n                (a, b) -> a.getValue() == b.getValue()\n                        ? a.getKey().compareTo(b.getKey())\n                        : b.getValue() - a.getValue()\n        );\n        pq.addAll(wordCount.entrySet());\n\n        List<String> result = new ArrayList<>();\n        for (int i = 0; i < k; i++) {\n            result.add(pq.poll().getKey());\n        }\n        return result;\n    }\n}\n",
            "python": "import heapq\nfrom collections import Counter\n\ndef k_frequent_words(words, k):\n    word_count = Counter(words)\n    heap = [(-count, word) for word, count in word_count.items()]\n    heapq.heapify(heap)\n\n    result = []\n    for _ in range(k):\n        result.append(heapq.heappop(heap)[1])\n\n    return result\n",
            "javascript": "function kFrequentWords(words, k) {\n    const wordCount = new Map();\n    for (const word of words) {\n        wordCount.set(word, (wordCount.get(word) || 0) + 1);\n    }\n\n    const pq = Array.from(wordCount.entries()).sort((a, b) => {\n        if (a[1] === b[1]) {\n            return a[0].localeCompare(b[0]);\n        }\n        return b[1] - a[1];\n    });\n\n    const result = [];\n    for (let i = 0; i < k; i++) {\n        result.push(pq[i][0]);\n    }\n    return result;\n}\n",
            "explanation": "1. Count the frequency of each word in the given `words` array using a hashmap or a dictionary.\n2. Create a priority queue (also called heap) that sorts the words by their frequency, and for those with the same frequency it sorts lexicographically.\n3. Add all word frequency pairs to the priority queue.\n4. Pop the top `k` elements from the priority queue and store the words in the result list.\n5. Return the result list containing the top `k` frequent words sorted as required."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n#include <queue>\nusing namespace std;\n\nvector<string> kFrequentWords(vector<string>& words, int k) \n    // Your code here\n}\n",
            "java": "import java.util.*;\n\npublic class Solution \n    // Your code here\n}\n",
            "python": "import heapq\n    # Your code here\n\n",
            "javascript": "function kFrequentWords(words, k) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n#include <queue>\nusing namespace std;\n\nvector<string> kFrequentWords(vector<string>& words, int k) {\n    unordered_map<string, int> wordCount;\n    for (const auto& word : words) {\n        wordCount[word]++;\n    }\n\n    auto comp = [](const pair<string, int>& a, const pair<string, int>& b) {\n        if (a.second == b.second) {\n            return a.first > b.first;\n        }\n        return a.second < b.second;\n    };\n    priority_queue<pair<string, int>, vector<pair<string, int>>, decltype(comp)> pq(comp);\n\n    for (const auto& wc : wordCount) {\n        pq.push(wc);\n    }\n\n    vector<string> result;\n    for (int i = 0; i < k; ++i) {\n        result.push_back(pq.top().first);\n        pq.pop();\n    }\n\n    return result;\n}",
            "java": "public List<String> kFrequentWords(String[] words, int k) {\n        Map<String, Integer> wordCount = new HashMap<>();\n        for (String word : words) {\n            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\n        }\n\n        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(\n                (a, b) -> a.getValue() == b.getValue()\n                        ? a.getKey().compareTo(b.getKey())\n                        : b.getValue() - a.getValue()\n        );\n        pq.addAll(wordCount.entrySet());\n\n        List<String> result = new ArrayList<>();\n        for (int i = 0; i < k; i++) {\n            result.add(pq.poll().getKey());\n        }\n        return result;\n    }",
            "python": "if __name__ == \"__main__\":\n    words = $args[0]\n    k = $args[1]\n    result = k_frequent_words(words, k)\n    print(result)",
            "javascript": "function kFrequentWords(words, k) {\n    const wordCount = new Map();\n    for (const word of words) {\n        wordCount.set(word, (wordCount.get(word) || 0) + 1);\n    }\n\n    const pq = Array.from(wordCount.entries()).sort((a, b) => {\n        if (a[1] === b[1]) {\n            return a[0].localeCompare(b[0]);\n        }\n        return b[1] - a[1];\n    });\n\n    const result = [];\n    for (let i = 0; i < k; i++) {\n        result.push(pq[i][0]);\n    }\n    return result;\n}"
        }
    },
    "693": {
        "title": "Alternating Bits",
        "description": "Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.",
        "example": "Example 1:\n\nInput: n = 5\nOutput: true\nExplanation: The binary representation of 5 is: 101\n\nExample 2:\n\nInput: n = 7\nOutput: false\nExplanation: The binary representation of 7 is: 111.\n\nExample 3:\n\nInput: n = 11\nOutput: false\nExplanation: The binary representation of 11 is: 1011.",
        "level": "Easy",
        "tags": [
            "bit manipulation"
        ],
        "test_cases": {
            "inputs": [
                5,
                7,
                11,
                1,
                2,
                3,
                15,
                16,
                17,
                31,
                32,
                33,
                63,
                64,
                65,
                127,
                128,
                129,
                255,
                256
            ],
            "outputs": [
                true,
                false,
                false,
                true,
                true,
                false,
                false,
                true,
                false,
                false,
                true,
                false,
                false,
                true,
                false,
                false,
                true,
                false,
                false,
                true
            ]
        },
        "sample_code": {
            "c++": "bool hasAlternatingBits(int n) {\n    int prevBit = n % 2;\n    n /= 2;\n    while (n > 0) {\n        int currBit = n % 2;\n        if (currBit == prevBit) return false;\n        prevBit = currBit;\n        n /= 2;\n    }\n    return true;\n}\n\n",
            "java": "public boolean hasAlternatingBits(int n) {\n    int prevBit = n % 2;\n    n /= 2;\n    while (n > 0) {\n        int currBit = n % 2;\n        if (currBit == prevBit) return false;\n        prevBit = currBit;\n        n /= 2;\n    }\n    return true;\n}\n\n",
            "python": "def has_alternating_bits(n):\n    prev_bit = n % 2\n    n //= 2\n    while n > 0:\n        curr_bit = n % 2\n        if curr_bit == prev_bit:\n            return False\n        prev_bit = curr_bit\n        n //= 2\n    return True\n\n",
            "javascript": "function hasAlternatingBits(n) {\n    let prevBit = n % 2;\n    n = Math.floor(n / 2);\n    while (n > 0) {\n        let currBit = n % 2;\n        if (currBit === prevBit) return false;\n        prevBit = currBit;\n        n = Math.floor(n / 2);\n    }\n    return true;\n}\n\n",
            "explanation": "The algorithm initializes `prevBit` with the least significant bit of `n`. Then, it divides `n` by 2 to eliminate the least significant bit. While `n` is greater than 0, the algorithm retrieves the least significant bit of `n` and compares it to `prevBit`. If they are equal, it means the adjacent bits are not alternating, so the function returns false. Otherwise, it assigns the least significant bit to `prevBit` and divides `n` by 2 again to move on to the next bit. When `n` becomes 0, it means all adjacent bits in the given integer are alternating, and the function returns true."
        },
        "structure": {
            "c++": "bool hasAlternatingBits(int n) \n    // Your code here\n}\n\n",
            "java": "public boolean hasAlternatingBits(int n) \n    // Your code here\n}\n\n",
            "python": "def has_alternating_bits(n):\n    # Your code here\n\n",
            "javascript": "function hasAlternatingBits(n) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nbool hasAlternatingBits(int n) {\n    int prevBit = n % 2;\n    n /= 2;\n    while (n > 0) {\n        int currBit = n % 2;\n        if (currBit == prevBit) return false;\n        prevBit = currBit;\n        n /= 2;\n    }\n    return true;\n}\n\nint main() {\n    int n = $args;\n    bool result = hasAlternatingBits(n);\n    cout << boolalpha << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    int n = $args;\n    boolean result = hasAlternatingBits(n);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    result = has_alternating_bits(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = hasAlternatingBits(n);\n    console.log(result);\n}\n"
        }
    },
    "696": {
        "title": "Count Substrings with Equal Number of 0s and 1s",
        "description": "Given a binary string `s`, return the number of non-empty substrings that have the same number of `0`'s and `1`'s, and all the `0`'s and all the `1`'s in these substrings are grouped consecutively.\n\nSubstrings that occur multiple times are counted the number of times they occur.",
        "example": "Example:\n\nInput: s = \"00110011\"\nOutput: 6\nExplanation: There are 6 substrings that have equal number of consecutive 1's and 0's: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\".\nNotice that some of these substrings repeat and are counted the number of times they occur.\nAlso, \"00110011\" is not a valid substring because all the 0's (and 1's) are not grouped together.",
        "level": "Medium",
        "tags": [
            "string",
            "substring",
            "counting"
        ],
        "test_cases": {
            "inputs": [
                "\"00110011\"",
                "\"10101\"",
                "\"1111\"",
                "\"0000\"",
                "\"0101010101\"",
                "\"1100110011\"",
                "\"1010101010\"",
                "\"111000111000\"",
                "\"000111000111\"",
                "\"0101010101010101\"",
                "\"1100110011001100\"",
                "\"1010101010101010\"",
                "\"1111000011110000\"",
                "\"0000111100001111\"",
                "\"01010101010101010101\"",
                "\"11001100110011001100\"",
                "\"10101010101010101010\"",
                "\"11110000111100001111\"",
                "\"00001111000011110000\"",
                "\"0101010101010101010101\""
            ],
            "outputs": [
                "6",
                "4",
                "0",
                "0",
                "10",
                "12",
                "10",
                "12",
                "12",
                "20",
                "24",
                "20",
                "16",
                "16",
                "30",
                "36",
                "30",
                "32",
                "32",
                "40"
            ]
        },
        "sample_code": {
            "c++": "int countBinarySubstrings(string s) {\n    int prev = 0, curr = 1, result = 0;\n    for (int i = 1; i < s.length(); i++) {\n        if (s[i] == s[i - 1]) {\n            curr++;\n        } else {\n            result += min(prev, curr);\n            prev = curr;\n            curr = 1;\n        }\n    }\n    return result + min(prev, curr);\n}\n",
            "java": "public int countBinarySubstrings(String s) {\n    int prev = 0, curr = 1, result = 0;\n    for (int i = 1; i < s.length(); i++) {\n        if (s.charAt(i) == s.charAt(i - 1)) {\n            curr++;\n        } else {\n            result += Math.min(prev, curr);\n            prev = curr;\n            curr = 1;\n        }\n    }\n    return result + Math.min(prev, curr);\n}\n",
            "python": "def count_binary_substrings(s: str) -> int:\n    prev, curr, result = 0, 1, 0\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            curr += 1\n        else:\n            result += min(prev, curr)\n            prev, curr = curr, 1\n    return result + min(prev, curr)\n",
            "javascript": "function countBinarySubstrings(s) {\n    let prev = 0, curr = 1, result = 0;\n    for (let i = 1; i < s.length; i++) {\n        if (s[i] === s[i - 1]) {\n            curr++;\n        } else {\n            result += Math.min(prev, curr);\n            prev = curr;\n            curr = 1;\n        }\n    }\n    return result + Math.min(prev, curr);\n}\n",
            "explanation": "Iterate through the binary string s. Keep track of the count of consecutive equal characters (curr) and the count of consecutive equal characters in the previous group (prev). When we encounter a character different from the previous one, add the minimum of prev and curr to the result. Update prev to the value of curr and reset curr to 1. After the iteration, add the minimum of prev and curr to the result and return the result. This will count all valid binary substrings with consecutive groups of 0's and 1's."
        },
        "structure": {
            "c++": "int countBinarySubstrings(string s) \n    // Your code here\n}\n",
            "java": "public int countBinarySubstrings(String s) \n    // Your code here\n}\n",
            "python": "def count_binary_substrings(s: str) -> int:\n    # Your code here\n\n",
            "javascript": "function countBinarySubstrings(s) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    string s = $args;\n    int result = countBinarySubstrings(s);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int countBinarySubstrings(String s) {\n    int prev = 0, curr = 1, result = 0;\n    for (int i = 1; i < s.length(); i++) {\n        if (s.charAt(i) == s.charAt(i - 1)) {\n            curr++;\n        } else {\n            result += Math.min(prev, curr);\n            prev = curr;\n            curr = 1;\n        }\n    }\n    return result + Math.min(prev, curr);\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args[0]\n    result = count_binary_substrings(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = countBinarySubstrings(s);\n    console.log(result);\n}"
        }
    },
    "699": {
        "title": "Tallest Stack of Squares",
        "description": "You are given a 2D integer array `positions` where `positions[i] = [lefti, sideLengthi]` represents the `ith` square with a side length of `sideLengthi` that is dropped with its left edge aligned with X-coordinate `lefti`. Each square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands **on the top side of another square** or **on the X-axis**. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved. After each square is dropped, you must record the **height of the current tallest stack of squares**. Return an integer array `ans` where `ans[i]` represents the height described above after dropping the `ith` square.",
        "example": "Example:\n\nInput: positions = [[1,2],[2,3],[6,1]]\nOutput: [2,5,5]\nExplanation: After the first drop, the tallest stack is square 1 with a height of 2. After the second drop, the tallest stack is squares 1 and 2 with a height of 5. After the third drop, the tallest stack is still squares 1 and 2 with a height of 5. Thus, we return an answer of [2, 5, 5].",
        "level": "Medium",
        "tags": [
            "array",
            "stack",
            "simulation"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        6,
                        1
                    ]
                ],
                [
                    [
                        100,
                        100
                    ],
                    [
                        200,
                        100
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ]
                ],
                [
                    [
                        10,
                        5
                    ],
                    [
                        20,
                        10
                    ],
                    [
                        30,
                        15
                    ],
                    [
                        40,
                        20
                    ]
                ],
                [
                    [
                        5,
                        5
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        25,
                        25
                    ]
                ],
                [
                    [
                        1,
                        1
                    ]
                ],
                [
                    [
                        100,
                        100
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ]
                ],
                [
                    [
                        10,
                        10
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        30,
                        30
                    ],
                    [
                        40,
                        40
                    ],
                    [
                        50,
                        50
                    ],
                    [
                        60,
                        60
                    ],
                    [
                        70,
                        70
                    ],
                    [
                        80,
                        80
                    ],
                    [
                        90,
                        90
                    ],
                    [
                        100,
                        100
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ]
                ],
                [
                    [
                        15,
                        15
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ]
                ],
                [
                    [
                        20,
                        20
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ]
                ],
                [
                    [
                        25,
                        25
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ],
                    [
                        26,
                        26
                    ],
                    [
                        27,
                        27
                    ],
                    [
                        28,
                        28
                    ],
                    [
                        29,
                        29
                    ],
                    [
                        30,
                        30
                    ]
                ],
                [
                    [
                        30,
                        30
                    ],
                    [
                        29,
                        29
                    ],
                    [
                        28,
                        28
                    ],
                    [
                        27,
                        27
                    ],
                    [
                        26,
                        26
                    ],
                    [
                        25,
                        25
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        1,
                        1
                    ]
                ]
            ],
            "outputs": [
                [
                    2,
                    5,
                    5
                ],
                [
                    100,
                    100
                ],
                [
                    1,
                    3,
                    6,
                    10,
                    15
                ],
                [
                    5,
                    15,
                    30,
                    50
                ],
                [
                    5,
                    15,
                    30,
                    50,
                    75
                ],
                [
                    1
                ],
                [
                    100
                ],
                [
                    1,
                    3,
                    6,
                    10,
                    15,
                    21,
                    28,
                    36,
                    45,
                    55
                ],
                [
                    10,
                    30,
                    60,
                    100,
                    150,
                    210,
                    280,
                    360,
                    450,
                    550
                ],
                [
                    1,
                    3,
                    6,
                    10,
                    15,
                    21,
                    28,
                    36,
                    45,
                    55,
                    66,
                    78,
                    91,
                    105,
                    120,
                    136,
                    153,
                    171,
                    190,
                    210
                ],
                [
                    15,
                    36,
                    66,
                    105,
                    153,
                    210,
                    276,
                    351,
                    435,
                    528,
                    630,
                    741,
                    861,
                    990,
                    1128,
                    1275,
                    1431,
                    1596,
                    1770,
                    1953
                ],
                [
                    1,
                    3,
                    6,
                    10,
                    15,
                    21,
                    28,
                    36,
                    45,
                    55,
                    66,
                    78,
                    91,
                    105,
                    120,
                    136,
                    153,
                    171,
                    190,
                    210,
                    231,
                    253,
                    276,
                    300,
                    325,
                    351,
                    378,
                    406,
                    435,
                    465
                ],
                [
                    25,
                    50,
                    84,
                    128,
                    182,
                    247,
                    323,
                    410,
                    508,
                    617,
                    737,
                    868,
                    1010,
                    1163,
                    1317,
                    1472,
                    1628,
                    1785,
                    1943,
                    2102,
                    2262,
                    2423,
                    2585,
                    2748,
                    2912,
                    3077,
                    3243,
                    3410,
                    3578,
                    3747,
                    3917
                ]
            ]
        },
        "sample_code": {
            "c++": "#include<vector>\nusing namespace std;\n\nvector<int> fallingSquares(vector<vector<int>>& positions) {\n    vector<int> ans;\n    vector<pair<int, int>> intervals;\n\n    for (auto p : positions) {\n        int L = p[0];\n        int R = p[0] + p[1];\n        int h = p[1];\n        for (auto it : intervals) {\n            if (it.first < R && L < it.second) {\n                h = max(h, p[1] + it.first);\n            }\n        }\n\n        int maxHeight = h;\n        for (auto it : intervals) {\n            maxHeight = max(maxHeight, it.first);\n        }\n\n        ans.push_back(maxHeight);\n        intervals.push_back(make_pair(h, R));\n    }\n    \n    return ans;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic int[] fallingSquares(int[][] positions) {\n    int[] ans = new int[positions.length];\n    List<int[]> intervals = new ArrayList<>();\n\n    for (int i = 0; i < positions.length; i++) {\n        int L = positions[i][0];\n        int R = positions[i][0] + positions[i][1];\n        int h = positions[i][1];\n        for (int[] interval : intervals) {\n            if (interval[1] > L && R > interval[1]) {\n                h = Math.max(h, positions[i][1] + interval[0]);\n            }\n        }\n\n        int maxHeight = h;\n        for (int[] interval : intervals) {\n            maxHeight = Math.max(maxHeight, interval[0]);\n        }\n\n        ans[i] = maxHeight;\n        intervals.add(new int[]{h, R});\n    }\n    \n    return ans;\n}\n",
            "python": "def fallingSquares(positions):\n    ans = []\n    intervals = []\n\n    for p in positions:\n        L, size = p\n        R = L + size\n        h = size\n        for h2, R2 in intervals:\n            if R2 > L and R > R2:\n                h = max(h, size + h2)\n\n        maxHeight = max((h2 for h2, R2 in intervals), default=0)\n        ans.append(max(maxHeight, h))\n        intervals.append((h, R))\n\n    return ans\n",
            "javascript": "function fallingSquares(positions) {\n    let ans = [];\n    let intervals = [];\n\n    for (let p of positions) {\n        let L = p[0];\n        let R = p[0] + p[1];\n        let h = p[1];\n        for (let it of intervals) {\n            if (it[1] > L && R > it[1]) {\n                h = Math.max(h, p[1] + it[0]);\n            }\n        }\n\n        let maxHeight = h;\n        for (let it of intervals) {\n            maxHeight = Math.max(maxHeight, it[0]);\n        }\n\n        ans.push(maxHeight);\n        intervals.push([h, R]);\n    }\n    \n    return ans;\n}\n",
            "explanation": "The function follows this algorithm:\n1. Initialize an empty list `intervals` to store the height and right edge of each landed square, and an empty list `ans` to store the maximum height after each square has been dropped.\n2. Loop through each square in `positions`.\n3. For each square, find its left `L` and right `R` edge, and initialize its height `h` to its side length.\n4. Loop through all intervals in `intervals`. Check if the current square intersects any existing square, and update the height `h` to its previous height plus the height of the intersected square.\n5. Calculate the current maximum height by looping through all intervals and updating the maxHeight variable.\n6. Append the new maxHeight to the answer array `ans`.\n7. After dropping the current square, append its height and right edge to the `intervals` list.\n8. Return the list `ans` as the final answer."
        },
        "structure": {
            "c++": "#include<vector>\nusing namespace std;\n\nvector<int> fallingSquares(vector<vector<int>>& positions) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic int[] fallingSquares(int[][] positions) \n    // Your code here\n}\n",
            "python": "def fallingSquares(positions):\n    # Your code here\n\n",
            "javascript": "function fallingSquares(positions) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include<vector>\nusing namespace std;\n\nvector<int> fallingSquares(vector<vector<int>>& positions) {\n    vector<int> ans;\n    vector<pair<int, int>> intervals;\n\n    for (auto p : positions) {\n        int L = p[0];\n        int R = p[0] + p[1];\n        int h = p[1];\n        for (auto it : intervals) {\n            if (it.first < R && L < it.second) {\n                h = max(h, p[1] + it.first);\n            }\n        }\n\n        int maxHeight = h;\n        for (auto it : intervals) {\n            maxHeight = max(maxHeight, it.first);\n        }\n\n        ans.push_back(maxHeight);\n        intervals.push_back(make_pair(h, R));\n    }\n    \n    return ans;\n}",
            "java": "public int[] fallingSquares(int[][] positions) {\n    int[] ans = new int[positions.length];\n    List<int[]> intervals = new ArrayList<>();\n\n    for (int i = 0; i < positions.length; i++) {\n        int L = positions[i][0];\n        int R = positions[i][0] + positions[i][1];\n        int h = positions[i][1];\n        for (int[] interval : intervals) {\n            if (interval[1] > L && R > interval[1]) {\n                h = Math.max(h, positions[i][1] + interval[0]);\n            }\n        }\n\n        int maxHeight = h;\n        for (int[] interval : intervals) {\n            maxHeight = Math.max(maxHeight, interval[0]);\n        }\n\n        ans[i] = maxHeight;\n        intervals.add(new int[]{h, R});\n    }\n\n    return ans;\n}",
            "python": "if __name__ == \"__main__\":\n    positions = $args[0]\n    result = fallingSquares(positions)\n    print(result)",
            "javascript": "function fallingSquares(positions) {\n    let ans = [];\n    let intervals = [];\n\n    for (let p of positions) {\n        let L = p[0];\n        let R = p[0] + p[1];\n        let h = p[1];\n        for (let it of intervals) {\n            if (it[1] > L && R > it[1]) {\n                h = Math.max(h, p[1] + it[0]);\n            }\n        }\n\n        let maxHeight = h;\n        for (let it of intervals) {\n            maxHeight = Math.max(maxHeight, it[0]);\n        }\n\n        ans.push(maxHeight);\n        intervals.push([h, R]);\n    }\n    \n    return ans;\n}"
        }
    },
    "702": {
        "title": "Search in Unknown Size Sorted Array",
        "description": "You are given a sorted array of unique elements with an unknown size. You do not have direct access to the array, but you can use the `ArrayReader` interface to access it. The `ArrayReader` interface has a method `get(i)` that returns the value at the `ith` index (0-indexed) of the secret array, or returns `231 - 1` if the index is out of bounds. You are also given an integer `target`. Write a function to find the index `k` of the hidden array where `secret[k] == target`, or return `-1` if the target is not found. Your algorithm should have a runtime complexity of O(log n).",
        "example": "Example:\n\nInput: secret = [-1,0,3,5,9,12], target = 9\nOutput: 4\nExplanation: 9 exists in secret and its index is 4.",
        "level": "Medium",
        "tags": [
            "Binary Search",
            "Array"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        -1,
                        0,
                        3,
                        5,
                        9,
                        12
                    ],
                    9
                ],
                [
                    [
                        -1,
                        0,
                        3,
                        5,
                        9,
                        12
                    ],
                    2
                ],
                [
                    [
                        1,
                        3,
                        5,
                        7,
                        9,
                        11,
                        13,
                        15,
                        17,
                        19
                    ],
                    7
                ],
                [
                    [
                        1,
                        3,
                        5,
                        7,
                        9,
                        11,
                        13,
                        15,
                        17,
                        19
                    ],
                    20
                ],
                [
                    [
                        1,
                        3,
                        5,
                        7,
                        9,
                        11,
                        13,
                        15,
                        17,
                        19
                    ],
                    -1
                ],
                [
                    [
                        2,
                        4,
                        6,
                        8,
                        10,
                        12,
                        14,
                        16,
                        18,
                        20
                    ],
                    10
                ],
                [
                    [
                        2,
                        4,
                        6,
                        8,
                        10,
                        12,
                        14,
                        16,
                        18,
                        20
                    ],
                    1
                ],
                [
                    [
                        2,
                        4,
                        6,
                        8,
                        10,
                        12,
                        14,
                        16,
                        18,
                        20
                    ],
                    21
                ],
                [
                    [
                        2,
                        4,
                        6,
                        8,
                        10,
                        12,
                        14,
                        16,
                        18,
                        20
                    ],
                    -1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    -1
                ],
                [
                    [
                        1
                    ],
                    1
                ],
                [
                    [
                        1
                    ],
                    2
                ],
                [
                    [
                        1,
                        3,
                        5,
                        7,
                        9,
                        11,
                        13,
                        15,
                        17,
                        19,
                        21,
                        23,
                        25,
                        27,
                        29,
                        31,
                        33,
                        35,
                        37,
                        39,
                        41,
                        43,
                        45,
                        47,
                        49,
                        51,
                        53,
                        55,
                        57,
                        59,
                        61,
                        63,
                        65,
                        67,
                        69,
                        71,
                        73,
                        75,
                        77,
                        79,
                        81,
                        83,
                        85,
                        87,
                        89,
                        91,
                        93,
                        95,
                        97,
                        99
                    ],
                    99
                ],
                [
                    [
                        1,
                        3,
                        5,
                        7,
                        9,
                        11,
                        13,
                        15,
                        17,
                        19,
                        21,
                        23,
                        25,
                        27,
                        29,
                        31,
                        33,
                        35,
                        37,
                        39,
                        41,
                        43,
                        45,
                        47,
                        49,
                        51,
                        53,
                        55,
                        57,
                        59,
                        61,
                        63,
                        65,
                        67,
                        69,
                        71,
                        73,
                        75,
                        77,
                        79,
                        81,
                        83,
                        85,
                        87,
                        89,
                        91,
                        93,
                        95,
                        97,
                        99
                    ],
                    100
                ],
                [
                    [
                        1,
                        3,
                        5,
                        7,
                        9,
                        11,
                        13,
                        15,
                        17,
                        19,
                        21,
                        23,
                        25,
                        27,
                        29,
                        31,
                        33,
                        35,
                        37,
                        39,
                        41,
                        43,
                        45,
                        47,
                        49,
                        51,
                        53,
                        55,
                        57,
                        59,
                        61,
                        63,
                        65,
                        67,
                        69,
                        71,
                        73,
                        75,
                        77,
                        79,
                        81,
                        83,
                        85,
                        87,
                        89,
                        91,
                        93,
                        95,
                        97,
                        99
                    ],
                    -1
                ],
                [
                    [
                        1,
                        3,
                        5,
                        7,
                        9,
                        11,
                        13,
                        15,
                        17,
                        19,
                        21,
                        23,
                        25,
                        27,
                        29,
                        31,
                        33,
                        35,
                        37,
                        39,
                        41,
                        43,
                        45,
                        47,
                        49,
                        51,
                        53,
                        55,
                        57,
                        59,
                        61,
                        63,
                        65,
                        67,
                        69,
                        71,
                        73,
                        75,
                        77,
                        79,
                        81,
                        83,
                        85,
                        87,
                        89,
                        91,
                        93,
                        95,
                        97,
                        99
                    ],
                    50
                ],
                [
                    [
                        1,
                        3,
                        5,
                        7,
                        9,
                        11,
                        13,
                        15,
                        17,
                        19,
                        21,
                        23,
                        25,
                        27,
                        29,
                        31,
                        33,
                        35,
                        37,
                        39,
                        41,
                        43,
                        45,
                        47,
                        49,
                        51,
                        53,
                        55,
                        57,
                        59,
                        61,
                        63,
                        65,
                        67,
                        69,
                        71,
                        73,
                        75,
                        77,
                        79,
                        81,
                        83,
                        85,
                        87,
                        89,
                        91,
                        93,
                        95,
                        97,
                        99
                    ],
                    1
                ],
                [
                    [
                        1,
                        3,
                        5,
                        7,
                        9,
                        11,
                        13,
                        15,
                        17,
                        19,
                        21,
                        23,
                        25,
                        27,
                        29,
                        31,
                        33,
                        35,
                        37,
                        39,
                        41,
                        43,
                        45,
                        47,
                        49,
                        51,
                        53,
                        55,
                        57,
                        59,
                        61,
                        63,
                        65,
                        67,
                        69,
                        71,
                        73,
                        75,
                        77,
                        79,
                        81,
                        83,
                        85,
                        87,
                        89,
                        91,
                        93,
                        95,
                        97,
                        99
                    ],
                    99
                ]
            ],
            "outputs": [
                4,
                -1,
                3,
                -1,
                -1,
                4,
                -1,
                -1,
                -1,
                4,
                0,
                9,
                -1,
                0,
                -1,
                49,
                -1,
                -1,
                -1,
                48,
                0,
                48,
                -1,
                48,
                48,
                48
            ]
        },
        "sample_code": {
            "c++": "int search(const ArrayReader& reader, int target) {\n    int left = 0, right = 1;\n    while (reader.get(right) < target) {\n        left = right;\n        right <<= 1;\n    }\n\n    while (left <= right) {\n        int mid = left + ((right - left) >> 1);\n        int val = reader.get(mid);\n        if (val == target)\n            return mid;\n        if (val > target)\n            right = mid - 1;\n        else\n            left = mid + 1;\n    }\n    return -1;\n}\n",
            "java": "public int search(ArrayReader reader, int target) {\n    int left = 0, right = 1;\n    while (reader.get(right) < target) {\n        left = right;\n        right <<= 1;\n    }\n\n    while (left <= right) {\n        int mid = left + ((right - left) >> 1);\n        int val = reader.get(mid);\n        if (val == target)\n            return mid;\n        if (val > target)\n            right = mid - 1;\n        else\n            left = mid + 1;\n    }\n    return -1;\n}\n",
            "python": "def search(reader, target):\n    left, right = 0, 1\n    while reader.get(right) < target:\n        left = right\n        right <<= 1\n\n    while left <= right:\n        mid = left + ((right - left) >> 1)\n        val = reader.get(mid)\n        if val == target:\n            return mid\n        if val > target:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return -1\n",
            "javascript": "function search(reader, target) {\n    let left = 0, right = 1;\n    while (reader.get(right) < target) {\n        left = right;\n        right <<= 1;\n    }\n\n    while (left <= right) {\n        let mid = left + ((right - left) >> 1);\n        let val = reader.get(mid);\n        if (val === target)\n            return mid;\n        if (val > target)\n            right = mid - 1;\n        else\n            left = mid + 1;\n    }\n    return -1;\n}\n",
            "explanation": "We are using a binary search like algorithm to find the index. Initially, we set `left` to 0 and `right` to 1. Then we keep doubling the value of `right` (i.e., shifting it left by 1) until the value at `right` is greater than or equal to the target. This way, we can determine the range of the target value in the array, which is `[left, right]`. \n\nNow we apply a binary search algorithm. We calculate the middle index and check the value at that index. If the value at the middle index is equal to the target, we return the middle index. If the value is greater than the target, we update `right` to `mid - 1`; if the value is smaller than the target, we update `left` to `mid + 1`. We do this until `left` becomes greater than `right`. If we cannot find the target value, we return -1.\n\nThe time complexity of this algorithm is O(log n) as we are reducing the search space by half each iteration."
        },
        "structure": {
            "c++": "int search(const ArrayReader& reader, int target) \n    // Your code here\n}\n",
            "java": "public int search(ArrayReader reader, int target) \n    // Your code here\n}\n",
            "python": "def search(reader, target):\n    # Your code here\n\n",
            "javascript": "function search(reader, target) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int target = $args;\n    int result = search(reader, target);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int search(ArrayReader reader, int target) {\n    int left = 0, right = 1;\n    while (reader.get(right) < target) {\n        left = right;\n        right <<= 1;\n    }\n\n    while (left <= right) {\n        int mid = left + ((right - left) >> 1);\n        int val = reader.get(mid);\n        if (val == target)\n            return mid;\n        if (val > target)\n            right = mid - 1;\n        else\n            left = mid + 1;\n    }\n    return -1;\n}",
            "python": "if __name__ == \"__main__\":\n    reader = $args[0]\n    target = $args[1]\n    result = search(reader, target)\n    print(result)",
            "javascript": "function search(reader, target) {\n    const result = search(reader, target);\n    console.log(result);\n}"
        }
    },
    "703": {
        "title": "Kth Largest Element in a Stream",
        "description": "Design a class to find the `kth` largest element in a stream. Given an integer `k` and a stream of integers `nums`, implement the `KthLargest` class. The `KthLargest` class should have two methods: `KthLargest(int k, int[] nums)` to initialize the object with the integer `k` and the stream of integers `nums`, and `int add(int val)` to append the integer `val` to the stream and return the element representing the `kth` largest element in the stream.",
        "example": "Example:\n\nInput:\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8\n\nExplanation:\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4 as the 3rd largest element is 4\nkthLargest.add(5);   // return 5 as the 3rd largest element is still 4\nkthLargest.add(10);  // return 5 as the 3rd largest element is still 4\nkthLargest.add(9);   // return 8 as the 3rd largest element is now 8\nkthLargest.add(4);   // return 8 as the 3rd largest element is still 8",
        "level": "Medium",
        "tags": [
            "Heap",
            "Priority Queue"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    [
                        4,
                        5,
                        8,
                        2
                    ]
                ],
                [
                    3,
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ]
                ],
                [
                    2,
                    [
                        10,
                        9,
                        8,
                        7,
                        6
                    ]
                ],
                [
                    1,
                    [
                        100,
                        200,
                        300,
                        400,
                        500
                    ]
                ],
                [
                    5,
                    [
                        5,
                        4,
                        3,
                        2,
                        1
                    ]
                ],
                [
                    4,
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ]
                ],
                [
                    3,
                    [
                        9,
                        8,
                        7,
                        6,
                        5
                    ]
                ],
                [
                    2,
                    [
                        1,
                        3,
                        5,
                        7,
                        9
                    ]
                ],
                [
                    1,
                    [
                        2,
                        4,
                        6,
                        8,
                        10
                    ]
                ],
                [
                    5,
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    3,
                    [
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1
                    ]
                ],
                [
                    2,
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ]
                ],
                [
                    1,
                    [
                        5,
                        4,
                        3,
                        2,
                        1,
                        1,
                        2,
                        3,
                        4,
                        5
                    ]
                ],
                [
                    5,
                    [
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1
                    ]
                ],
                [
                    4,
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    3,
                    [
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1,
                        1,
                        2,
                        3,
                        4,
                        5
                    ]
                ],
                [
                    2,
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5,
                        5,
                        5,
                        5,
                        5,
                        5
                    ]
                ],
                [
                    1,
                    [
                        5,
                        4,
                        3,
                        2,
                        1,
                        1,
                        2,
                        3,
                        4,
                        5,
                        5,
                        5,
                        5,
                        5,
                        5,
                        5
                    ]
                ],
                [
                    5,
                    [
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1
                    ]
                ],
                [
                    4,
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1
                    ]
                ],
                [
                    3,
                    [
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1,
                        1,
                        2,
                        3,
                        4,
                        5,
                        5,
                        5,
                        5,
                        5,
                        5
                    ]
                ]
            ],
            "outputs": [
                "null",
                "3",
                "9",
                "500",
                "3",
                "1",
                "7",
                "9",
                "10",
                "6",
                "9",
                "4",
                "5",
                "2",
                "7",
                "9",
                "5",
                "5",
                "1",
                "7"
            ]
        },
        "sample_code": {
            "c++": "#include <queue>\n#include <vector>\n\nclass KthLargest {\npublic:\n    int k;\n    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;\n\n    KthLargest(int k, std::vector<int>& nums) {\n        this->k = k;\n        for (int num : nums) {\n            add(num);\n        }\n    }\n    \n    int add(int val) {\n        minHeap.push(val);\n        if (minHeap.size() > k) {\n            minHeap.pop();\n        }\n        return minHeap.top();\n    }\n};\n",
            "java": "import java.util.PriorityQueue;\n\nclass KthLargest {\n    int k;\n    PriorityQueue<Integer> minHeap;\n\n    public KthLargest(int k, int[] nums) {\n        this.k = k;\n        minHeap = new PriorityQueue<>(k);\n        for (int num : nums) {\n            add(num);\n        }\n    }\n\n    public int add(int val) {\n        minHeap.offer(val);\n        if (minHeap.size() > k) {\n            minHeap.poll();\n        }\n        return minHeap.peek();\n    }\n}\n",
            "python": "import heapq\n\nclass KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.min_heap = nums\n        heapq.heapify(self.min_heap)\n        \n        while len(self.min_heap) > k:\n            heapq.heappop(self.min_heap)\n\n    def add(self, val: int) -> int:\n        if len(self.min_heap) < self.k:\n            heapq.heappush(self.min_heap, val)\n        elif val > self.min_heap[0]:\n            heapq.heappushpop(self.min_heap, val)\n        return self.min_heap[0]\n",
            "javascript": "class KthLargest {\n    constructor(k, nums) {\n        this.k = k;\n        this.minHeap = new MinHeap();\n        for (let num of nums) {\n            this.add(num);\n        }\n    }\n    \n    add(val) {\n        this.minHeap.offer(val);\n        if (this.minHeap.size() > this.k) {\n            this.minHeap.poll();\n        }\n        return this.minHeap.peek();\n    }\n}\n\nclass MinHeap {\n    constructor() {\n        this.heap = [];\n    }\n\n    offer(val) {\n        this.heap.push(val);\n        this.heap.sort((a, b) => a - b);\n    }\n\n    poll() {\n        return this.heap.shift();\n    }\n\n    peek() {\n        return this.heap[0];\n    }\n\n    size() {\n        return this.heap.length;\n    }\n}\n",
            "explanation": "We will use a min-heap to solve this problem. We initialize the KthLargest class with an integer `k` and an array `nums`. In the constructor, we loop through the `nums` array and call the `add` function for every element.\n\nThe `add` function does the following:\n1. Pushes the new value into the min-heap.\n2. If the size of the min-heap is greater than `k`, we pop an element from the min-heap (i.e., remove the smallest element).\n3. We return the top element of the min-heap which represents the k-th largest element in the stream.\n\nFor the JavaScript implementation, we also need to create a separate MinHeap class covering the basic functions (offer, poll, peek, size) to maintain minimum priority queue.\n\nAll implementations follow the same algorithm, with small syntax differences between programming languages."
        },
        "structure": {
            "c++": "#include <queue>\n#include <vector>\n\nclass KthLargest \n    // Your code here\n};\n",
            "java": "import java.util.PriorityQueue;\n\nclass KthLargest \n    // Your code here\n}\n",
            "python": "import heapq\n    # Your code here\n\n",
            "javascript": "class KthLargest \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\n\nint main() {\n    int k = $args.k;\n    std::vector<int> nums = $args.nums;\n    KthLargest obj(k, nums);\n    int result = obj.add($args.val);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int add(int val) {\n        minHeap.offer(val);\n        if (minHeap.size() > k) {\n            minHeap.poll();\n        }\n        return minHeap.peek();\n    }",
            "python": "if __name__ == \"__main__\":\n    k = $args[0]\n    nums = $args[1]\n    kth_largest = KthLargest(k, nums)\n    val = $args[2]\n    result = kth_largest.add(val)\n    print(result)",
            "javascript": "function main() {\n    const k = $args[0];\n    const nums = $args.slice(1);\n    const kthLargest = new KthLargest(k, nums);\n    const result = kthLargest.add(5);\n    console.log(result);\n}"
        }
    },
    "704": {
        "title": "Search Target in Sorted Array",
        "description": "Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return `-1`.",
        "example": "Example:\n\nInput: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\nExplanation: 9 exists in nums and its index is 4",
        "level": "Easy",
        "tags": [
            "array",
            "binary search"
        ],
        "test_cases": {
            "inputs": [
                [
                    -1,
                    0,
                    3,
                    5,
                    9,
                    12
                ],
                [
                    -1,
                    0,
                    3,
                    5,
                    9,
                    12
                ],
                [
                    -1,
                    0,
                    3,
                    5,
                    9,
                    12
                ],
                [
                    -1,
                    0,
                    3,
                    5,
                    9,
                    12
                ],
                [
                    -1,
                    0,
                    3,
                    5,
                    9,
                    12
                ],
                [
                    -1,
                    0,
                    3,
                    5,
                    9,
                    12
                ],
                [
                    -1,
                    0,
                    3,
                    5,
                    9,
                    12
                ],
                [
                    -1,
                    0,
                    3,
                    5,
                    9,
                    12
                ],
                [
                    -1,
                    0,
                    3,
                    5,
                    9,
                    12
                ],
                [
                    -1,
                    0,
                    3,
                    5,
                    9,
                    12
                ],
                [
                    -1,
                    0,
                    3,
                    5,
                    9,
                    12
                ],
                [
                    -1,
                    0,
                    3,
                    5,
                    9,
                    12
                ],
                [
                    -1,
                    0,
                    3,
                    5,
                    9,
                    12
                ],
                [
                    -1,
                    0,
                    3,
                    5,
                    9,
                    12
                ],
                [
                    -1,
                    0,
                    3,
                    5,
                    9,
                    12
                ],
                [
                    -1,
                    0,
                    3,
                    5,
                    9,
                    12
                ],
                [
                    -1,
                    0,
                    3,
                    5,
                    9,
                    12
                ],
                [
                    -1,
                    0,
                    3,
                    5,
                    9,
                    12
                ],
                [
                    -1,
                    0,
                    3,
                    5,
                    9,
                    12
                ],
                [
                    -1,
                    0,
                    3,
                    5,
                    9,
                    12
                ]
            ],
            "outputs": [
                "4",
                "-1",
                "0",
                "5",
                "1",
                "-1",
                "2",
                "-1",
                "3",
                "-1",
                "4",
                "-1",
                "5",
                "-1",
                "-1",
                "-1",
                "-1",
                "-1",
                "-1",
                "-1"
            ]
        },
        "sample_code": {
            "c++": "int search(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}\n\n",
            "java": "public int search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}\n\n",
            "python": "def search(nums: List[int], target: int) -> int:\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\n",
            "javascript": "function search(nums, target) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        const mid = Math.floor(left + (right - left) / 2);\n        if (nums[mid] === target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}\n\n",
            "explanation": "The algorithm implements a binary search, since the input array is sorted in ascending order. We start with two pointers, `left` and `right`, representing the beginning and the end of the search range, respectively. We then find the middle element of the array (or subarray) by calculating the average of `left` and `right` and round it down.\n\nIf the middle element matches the target, we return its index. If the middle element is smaller than the target, we set `left` to the next index (`mid + 1`). If the middle element is greater than the target, we set `right` to the previous index (`mid - 1`). We continue iterating until we find the target or the pointers cross (`left > right`), in which case we return `-1` because the target is not in the array. The time complexity of this algorithm is O(log n)."
        },
        "structure": {
            "c++": "int search(vector<int>& nums, int target) \n    // Your code here\n}\n\n",
            "java": "public int search(int[] nums, int target) \n    // Your code here\n}\n\n",
            "python": "def search(nums: List[int], target: int) -> int:\n    # Your code here\n\n",
            "javascript": "function search(nums, target) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int search(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}",
            "java": "public int search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    target = $args[1]\n    result = search(nums, target)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args[0];\n    const target = $args[1];\n    const result = search(nums, target);\n    console.log(result);\n}"
        }
    },
    "709": {
        "title": "Lowercase Replacement",
        "description": "Given a string `s`, return the string after replacing every uppercase letter with the same lowercase letter.",
        "example": "Example:\n\nInput: s = \"Hello \"\nOutput: \"hello \"\n\nInput: s = \"here \"\nOutput: \"here \"\n\nInput: s = \"LOVELY \"\nOutput: \"lovely \"",
        "level": "Easy",
        "tags": [
            "string",
            "character manipulation"
        ],
        "test_cases": {
            "inputs": [
                "Hello ",
                "here ",
                "LOVELY ",
                "ABC",
                "xyz",
                "Hello World",
                "123",
                "AbCdEfG",
                "HELLO",
                "lovely",
                "HeLlO",
                "hElLo",
                "hELLO",
                "HeLLo",
                "hElLO",
                "HELlo",
                "hELLo",
                "hElLo",
                "hElLo",
                "hElLo"
            ],
            "outputs": [
                "hello ",
                "here ",
                "lovely ",
                "abc",
                "xyz",
                "hello world",
                "123",
                "abcdefg",
                "hello",
                "lovely",
                "hello",
                "hello",
                "hello",
                "hello",
                "hello",
                "hello",
                "hello",
                "hello",
                "hello",
                "hello"
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n\nstd::string toLowerCase(std::string s) {\n    for (char& c : s) {\n        if (c >= 'A' && c <= 'Z') {\n            c = c - 'A' + 'a';\n        }\n    }\n    return s;\n}\n",
            "java": "public String toLowerCase(String s) {\n    char[] chars = s.toCharArray();\n    for (int i = 0; i < chars.length; i++) {\n        if (chars[i] >= 'A' && chars[i] <= 'Z') {\n            chars[i] = (char)(chars[i] - 'A' + 'a');\n        }\n    }\n    return new String(chars);\n}\n",
            "python": "def toLowerCase(s: str) -> str:\n    return s.lower()\n",
            "javascript": "function toLowerCase(s) {\n    let result = '';\n    for (let i = 0; i < s.length; i++) {\n        let charCode = s.charCodeAt(i);\n        if (charCode >= 65 && charCode <= 90) {\n            charCode += 32;\n        }\n        result += String.fromCharCode(charCode);\n    }\n    return result;\n}\n",
            "explanation": "The algorithm goes through each character in the input string and checks if the character is an uppercase letter. If it is, it converts the letter to lowercase, otherwise it keeps the character unchanged. In C++ and Java, we use a loop to go through each character and update it in-place. In Python, the built-in `str.lower()` function is used. In JavaScript, we need to create a new string by concatenating the resulting characters. For each language, the modified string is returned."
        },
        "structure": {
            "c++": "#include <string>\n\nstd::string toLowerCase(std::string s) \n    // Your code here\n}\n",
            "java": "public String toLowerCase(String s) \n    // Your code here\n}\n",
            "python": "def toLowerCase(s: str) -> str:\n    # Your code here\n\n",
            "javascript": "function toLowerCase(s) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <iostream>\n\nint main() {\n    std::string s = $args;\n    std::string result = toLowerCase(s);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public String toLowerCase(String s) {\n    char[] chars = s.toCharArray();\n    for (int i = 0; i < chars.length; i++) {\n        if (chars[i] >= 'A' && chars[i] <= 'Z') {\n            chars[i] = (char)(chars[i] - 'A' + 'a');\n        }\n    }\n    return new String(chars);\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args[0]\n    result = toLowerCase(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = toLowerCase(s);\n    console.log(result);\n}"
        }
    },
    "710": {
        "title": "Random Integer Picker",
        "description": "You are given an integer `n` and an array of **unique** integers `blacklist`. Design an algorithm to pick a random integer in the range `[0, n - 1]` that is **not** in `blacklist`. Any integer that is in the mentioned range and not in `blacklist` should be **equally likely** to be returned. Implement the `Solution` class with the following methods:\n\n- `Solution(int n, int[] blacklist)`: Initializes the object with the integer `n` and the blacklisted integers `blacklist`.\n- `int pick()`: Returns a random integer in the range `[0, n - 1]` and not in `blacklist`.",
        "example": "Example:\n\nInput:\nSolution solution = new Solution(7, [2, 3, 5]);\nsolution.pick(); // return 0\nsolution.pick(); // return 4\nsolution.pick(); // return 1\nsolution.pick(); // return 6\nsolution.pick(); // return 1\nsolution.pick(); // return 0\nsolution.pick(); // return 4\n\nExplanation:\nFor every call of pick, any integer from [0, 1, 4, 6] should be equally likely to be returned (i.e., with probability 1/4).",
        "level": "Medium",
        "tags": [
            "Array",
            "Random Number Generation"
        ],
        "test_cases": {
            "inputs": [
                [
                    7,
                    [
                        2,
                        3,
                        5
                    ]
                ],
                [
                    10,
                    [
                        1,
                        3,
                        5,
                        7,
                        9
                    ]
                ],
                [
                    5,
                    [
                        0,
                        1,
                        2,
                        3,
                        4
                    ]
                ],
                [
                    100,
                    [
                        10,
                        20,
                        30,
                        40,
                        50
                    ]
                ],
                [
                    15,
                    [
                        5,
                        10,
                        15
                    ]
                ],
                [
                    8,
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7
                    ]
                ],
                [
                    20,
                    [
                        2,
                        4,
                        6,
                        8,
                        10,
                        12,
                        14,
                        16,
                        18
                    ]
                ],
                [
                    50,
                    [
                        1,
                        3,
                        5,
                        7,
                        9,
                        11,
                        13,
                        15,
                        17,
                        19,
                        21,
                        23,
                        25,
                        27,
                        29,
                        31,
                        33,
                        35,
                        37,
                        39,
                        41,
                        43,
                        45,
                        47,
                        49
                    ]
                ],
                [
                    3,
                    []
                ],
                [
                    1000,
                    [
                        500,
                        600,
                        700,
                        800,
                        900
                    ]
                ]
            ],
            "outputs": [
                [
                    null,
                    0,
                    4,
                    1,
                    6,
                    1,
                    0,
                    4
                ],
                [
                    null,
                    0,
                    2,
                    4,
                    6,
                    8,
                    0,
                    2,
                    4,
                    6,
                    8
                ],
                [
                    null,
                    3,
                    0,
                    4,
                    3,
                    0,
                    4,
                    3,
                    0,
                    4,
                    3
                ],
                [
                    null,
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    null,
                    0,
                    1,
                    2,
                    3,
                    4,
                    0,
                    1,
                    2,
                    3,
                    4
                ],
                [
                    null,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    null,
                    0,
                    1,
                    3,
                    5,
                    7,
                    9,
                    11,
                    13,
                    15,
                    17
                ],
                [
                    null,
                    0,
                    2,
                    4,
                    6,
                    8,
                    10,
                    12,
                    14,
                    16,
                    18,
                    0,
                    2,
                    4,
                    6,
                    8,
                    10,
                    12,
                    14,
                    16,
                    18
                ],
                [
                    null,
                    0,
                    1,
                    2
                ],
                [
                    null,
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <unordered_map>\n#include <vector>\n#include <algorithm>\n#include <random>\n\nclass Solution {\npublic:\n    Solution(int n, std::vector<int>& blacklist) {\n        std::sort(blacklist.begin(), blacklist.end());\n        auto it = blacklist.begin();\n        int idx = 0;\n        for (int i = 0; i < blacklist.size(); ++i) {\n            int black = *it++;\n            while (idx < black) {\n                mapping[idx++] = n - 1;\n                --n;\n            }\n            ++idx;\n            --n;\n        }\n        last = n;\n    }\n    \n    int pick() {\n        int num = rand() % last;\n        auto res = mapping.find(num);\n        return res == mapping.end() ? num : res->second;\n    }\n\nprivate:\n    std::unordered_map<int, int> mapping;\n    int last;\n};\n",
            "java": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Random;\n\nclass Solution {\n    private HashMap<Integer, Integer> mapping;\n    private int last;\n    private Random random;\n\n    public Solution(int n, int[] blacklist) {\n        Arrays.sort(blacklist);\n        mapping = new HashMap<>();\n        int idx = 0;\n        for (int i = 0; i < blacklist.length; ++i) {\n            int black = blacklist[i];\n            while (idx < black) {\n                mapping.put(idx++, --n);\n            }\n            idx++;\n            n--;\n        }\n        last = n;\n        random = new Random();\n    }\n\n    public int pick() {\n        int num = random.nextInt(last);\n        return mapping.getOrDefault(num, num);\n    }\n}\n",
            "python": "import random\n\nclass Solution:\n    def __init__(self, n: int, blacklist: List[int]):\n        blacklist.sort()\n        self.mapping = dict()\n        idx = 0\n        for black in blacklist:\n            while idx < black:\n                self.mapping[idx] = n - 1\n                idx += 1\n                n -= 1\n            idx += 1\n            n -= 1\n        self.last = n\n\n    def pick(self) -> int:\n        num = random.randrange(self.last)\n        return self.mapping.get(num, num)\n",
            "javascript": "class Solution {\n    constructor(n, blacklist) {\n        blacklist.sort((a, b) => a - b);\n        this.mapping = new Map();\n        let idx = 0;\n        for (let i = 0; i < blacklist.length; ++i) {\n            let black = blacklist[i];\n            while (idx < black) {\n                this.mapping.set(idx++, n - 1);\n                n--;\n            }\n            idx++;\n            n--;\n        }\n        this.last = n;\n    }\n\n    pick() {\n        const num = Math.floor(Math.random() * this.last);\n        return this.mapping.has(num) ? this.mapping.get(num) : num;\n    }\n}\n",
            "explanation": "We create a mapping from the non-blacklisted range `[0, n - blacklist.size())` to the full available range `[0, n)`. For each non-blacklisted number `num`, the mapping contains the non-blacklisted number that corresponds to its position `num - blacklist[i]` in the full available range. We initialize the mapping by iterating over the sorted `blacklist`, and we pick a random integer in the non-blacklisted range and use the mapping to get the corresponding available number. To minimize the number of calls to the random function, we only call it once per `pick()` call. This ensures that any integer in the non-blacklisted range is equally likely to be returned."
        },
        "structure": {
            "c++": "#include <unordered_map>\n#include <vector>\n#include <algorithm>\n#include <random>\n\nclass Solution \n    // Your code here\n};\n",
            "java": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Random;\n\nclass Solution \n    // Your code here\n}\n",
            "python": "import random\n    # Your code here\n\n",
            "javascript": "class Solution \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <unordered_map>\n#include <vector>\n#include <algorithm>\n#include <random>\n#include <iostream>\n\nint main() {\n    int n = $args;\n    std::vector<int> blacklist = {1, 2, 3}; // Replace with actual blacklist values\n    Solution obj(n, blacklist);\n    int result = obj.pick();\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int pick()",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    blacklist = $args[1]\n    obj = Solution(n, blacklist)\n    result = obj.pick()\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const blacklist = [];\n    const solution = new Solution(n, blacklist);\n    const result = solution.pick();\n    console.log(result);\n}"
        }
    },
    "712": {
        "title": "Lowest ASCII Sum of Deleted Characters",
        "description": "Given two strings `s1` and `s2`, you need to find the lowest ASCII sum of deleted characters to make the two strings equal. The ASCII sum of a character is the ASCII value of that character. You can delete any character from the strings to make them equal.",
        "example": "Example:\n\nInput: s1 = \"sea\", s2 = \"eat\"\nOutput: 231\nExplanation: Deleting 's' from 'sea' adds the ASCII value of 's' (115) to the sum. Deleting 't' from 'eat' adds 116 to the sum. At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.",
        "level": "Medium",
        "tags": [
            "string",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    "sea",
                    "eat"
                ],
                [
                    "delete",
                    "leet"
                ],
                [
                    "abc",
                    "def"
                ],
                [
                    "xyz",
                    "xyz"
                ],
                [
                    "hello",
                    "world"
                ],
                [
                    "programming",
                    "coding"
                ],
                [
                    "algorithm",
                    "logarithm"
                ],
                [
                    "python",
                    "java"
                ],
                [
                    "leetcode",
                    "codeleet"
                ],
                [
                    "abcde",
                    "edcba"
                ],
                [
                    "",
                    ""
                ],
                [
                    "a",
                    "a"
                ],
                [
                    "ab",
                    "ba"
                ],
                [
                    "abc",
                    "cba"
                ],
                [
                    "abcd",
                    "dcba"
                ],
                [
                    "abcde",
                    "edcba"
                ],
                [
                    "abcdef",
                    "fedcba"
                ],
                [
                    "abcdefg",
                    "gfedcba"
                ],
                [
                    "abcdefgh",
                    "hgfedcba"
                ],
                [
                    "abcdefghi",
                    "ihgfedcba"
                ]
            ],
            "outputs": [
                231,
                403,
                294,
                0,
                1116,
                1352,
                1352,
                1352,
                136,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "int minimumDeleteSum(std::string s1, std::string s2) {\n    int dp[1001][1001] = {0};\n    for (int i = 1; i <= s1.size(); i++) {\n        dp[i][0] = dp[i - 1][0] + s1[i - 1];\n    }\n    for (int j = 1; j <= s2.size(); j++) {\n        dp[0][j] = dp[0][j - 1] + s2[j - 1];\n    }\n    for (int i = 1; i <= s1.size(); i++) {\n        for (int j = 1; j <= s2.size(); j++) {\n            if (s1[i - 1] == s2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = std::min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);\n            }\n        }\n    }\n    return dp[s1.size()][s2.size()];\n}\n",
            "java": "public int minimumDeleteSum(String s1, String s2) {\n    int[][] dp = new int[s1.length() + 1][s2.length() + 1];\n    for (int i = 1; i <= s1.length(); i++) {\n        dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1);\n    }\n    for (int j = 1; j <= s2.length(); j++) {\n        dp[0][j] = dp[0][j - 1] + s2.charAt(j - 1);\n    }\n    for (int i = 1; i <= s1.length(); i++) {\n        for (int j = 1; j <= s2.length(); j++) {\n            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(dp[i - 1][j] + s1.charAt(i - 1), dp[i][j - 1] + s2.charAt(j - 1));\n            }\n        }\n    }\n    return dp[s1.length()][s2.length()];\n}\n",
            "python": "def minimumDeleteSum(s1: str, s2: str) -> int:\n    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n    for i in range(1, len(s1) + 1):\n        dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])\n    for j in range(1, len(s2) + 1):\n        dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])\n    for i in range(1, len(s1) + 1):\n        for j in range(1, len(s2) + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j] + ord(s1[i - 1]), dp[i][j - 1] + ord(s2[j - 1]))\n    return dp[len(s1)][len(s2)]\n",
            "javascript": "function minimumDeleteSum(s1, s2) {\n    const dp = Array.from({ length: s1.length + 1 }, () => Array(s2.length + 1).fill(0));\n    for (let i = 1; i <= s1.length; i++) {\n        dp[i][0] = dp[i - 1][0] + s1.charCodeAt(i - 1);\n    }\n    for (let j = 1; j <= s2.length; j++) {\n        dp[0][j] = dp[0][j - 1] + s2.charCodeAt(j - 1);\n    }\n    for (let i = 1; i <= s1.length; i++) {\n        for (let j = 1; j <= s2.length; j++) {\n            if (s1.charAt(i - 1) === s2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(dp[i - 1][j] + s1.charCodeAt(i - 1), dp[i][j - 1] + s2.charCodeAt(j - 1));\n            }\n        }\n    }\n    return dp[s1.length][s2.length];\n}\n",
            "explanation": "For this problem, we use dynamic programming. First, we create a 2D array `dp` to store the intermediate results. Each cell dp[i][j] in the `dp` array represents the lowest ASCII sum of deleted characters to make the first i characters of s1 and the first j characters of s2 equal.\n\nWe initialize the first column of the `dp` array to the ASCII sum of s1 characters and the first row to the ASCII sum of s2 characters. Then, we loop through the entire `dp` array, updating the values lexicographically. If the characters at the respective indexes of s1 and s2 are the same, we just copy the value of dp[i-1][j-1] to dp[i][j]. If they are different, we calculate the minimum between deleting the character from s1 (dp[i-1][j] + ASCII value of the character) and deleting the character from s2 (dp[i][j-1] + ASCII value of the character).\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the lowest ASCII sum needed to make s1 and s2 equal."
        },
        "structure": {
            "c++": "int minimumDeleteSum(std::string s1, std::string s2) \n    // Your code here\n}\n",
            "java": "public int minimumDeleteSum(String s1, String s2) \n    // Your code here\n}\n",
            "python": "def minimumDeleteSum(s1: str, s2: str) -> int:\n    # Your code here\n\n",
            "javascript": "function minimumDeleteSum(s1, s2) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int minimumDeleteSum(std::string s1, std::string s2) {\n    int dp[1001][1001] = {0};\n    for (int i = 1; i <= s1.size(); i++) {\n        dp[i][0] = dp[i - 1][0] + s1[i - 1];\n    }\n    for (int j = 1; j <= s2.size(); j++) {\n        dp[0][j] = dp[0][j - 1] + s2[j - 1];\n    }\n    for (int i = 1; i <= s1.size(); i++) {\n        for (int j = 1; j <= s2.size(); j++) {\n            if (s1[i - 1] == s2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = std::min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);\n            }\n        }\n    }\n    return dp[s1.size()][s2.size()];\n}",
            "java": "public int minimumDeleteSum(String s1, String s2) {\n    int[][] dp = new int[s1.length() + 1][s2.length() + 1];\n    for (int i = 1; i <= s1.length(); i++) {\n        dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1);\n    }\n    for (int j = 1; j <= s2.length(); j++) {\n        dp[0][j] = dp[0][j - 1] + s2.charAt(j - 1);\n    }\n    for (int i = 1; i <= s1.length(); i++) {\n        for (int j = 1; j <= s2.length(); j++) {\n            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(dp[i - 1][j] + s1.charAt(i - 1), dp[i][j - 1] + s2.charAt(j - 1));\n            }\n        }\n    }\n    return dp[s1.length()][s2.length()];\n}",
            "python": "if __name__ == \"__main__\":\n    s1 = $args[0]\n    s2 = $args[1]\n    result = minimumDeleteSum(s1, s2)\n    print(result)",
            "javascript": "function main() {\n    const s1 = $args[0];\n    const s2 = $args[1];\n    const result = minimumDeleteSum(s1, s2);\n    console.log(result);\n}"
        }
    },
    "713": {
        "title": "Contiguous Subarrays with Product Less Than K",
        "description": "Given an array of integers `nums` and an integer `k`, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than `k`.",
        "example": "Example:\n\nInput: nums = [10,5,2,6], k = 100\nOutput: 8\nExplanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]. Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.",
        "level": "Medium",
        "tags": [
            "array",
            "subarray",
            "product"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        10,
                        5,
                        2,
                        6
                    ],
                    100
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    0
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    10
                ],
                [
                    [
                        2,
                        4,
                        6,
                        8,
                        10
                    ],
                    100
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    100
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    100
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    10000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    100000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1000000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    10000000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    100000000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1000000000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    10000000000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    100000000000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1000000000000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    10000000000000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    100000000000000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1000000000000000
                ]
            ],
            "outputs": [
                8,
                0,
                9,
                15,
                0,
                15,
                0,
                15,
                15,
                15,
                15,
                15,
                15,
                15,
                15,
                15,
                15,
                15,
                15,
                15
            ]
        },
        "sample_code": {
            "c++": "int numSubarrayProductLessThanK(vector<int>& nums, int k) {\n    if (k <= 1) return 0;\n    int prod = 1, count = 0, left = 0;\n    for (int right = 0; right < nums.size(); right++) {\n        prod *= nums[right];\n        while (prod >= k) prod /= nums[left++];\n        count += right - left + 1;\n    }\n    return count;\n}\n",
            "java": "public int numSubarrayProductLessThanK(int[] nums, int k) {\n    if (k <= 1) return 0;\n    int prod = 1, count = 0, left = 0;\n    for (int right = 0; right < nums.length; right++) {\n        prod *= nums[right];\n        while (prod >= k) prod /= nums[left++];\n        count += right - left + 1;\n    }\n    return count;\n}\n",
            "python": "def numSubarrayProductLessThanK(nums, k):\n    if k <= 1:\n        return 0\n    prod = 1\n    count = 0\n    left = 0\n    for right in range(len(nums)):\n        prod *= nums[right]\n        while prod >= k:\n            prod /= nums[left]\n            left += 1\n        count += right - left + 1\n    return count\n",
            "javascript": "function numSubarrayProductLessThanK(nums, k) {\n    if (k <= 1) return 0;\n    let prod = 1, count = 0, left = 0;\n    for (let right = 0; right < nums.length; right++) {\n        prod *= nums[right];\n        while (prod >= k) prod /= nums[left++];\n        count += right - left + 1;\n    }\n    return count;\n}\n",
            "explanation": "The algorithm uses a sliding window approach to find the contiguous subarrays with the product less than k. It initializes a product variable to 1, and count variable to 0.  We also have left and right pointers for our sliding window.\n\nFor each number in the array, we multiply the product by the current number. Inside a loop, we check if the product is greater than or equal to k; if it is, we divide the product by the number at the left pointer and move the left pointer to the right.\n\nAfter adjusting the product and the left pointer, we can calculate the length of the current window. We increment the count by the length of the window.\n\nAt the end, we return the total count of subarrays with product less than k."
        },
        "structure": {
            "c++": "int numSubarrayProductLessThanK(vector<int>& nums, int k) \n    // Your code here\n}\n",
            "java": "public int numSubarrayProductLessThanK(int[] nums, int k) \n    // Your code here\n}\n",
            "python": "def numSubarrayProductLessThanK(nums, k):\n    # Your code here\n\n",
            "javascript": "function numSubarrayProductLessThanK(nums, k) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int numSubarrayProductLessThanK(vector<int>& nums, int k) {\n    if (k <= 1) return 0;\n    int prod = 1, count = 0, left = 0;\n    for (int right = 0; right < nums.size(); right++) {\n        prod *= nums[right];\n        while (prod >= k) prod /= nums[left++];\n        count += right - left + 1;\n    }\n    return count;\n}",
            "java": "public int numSubarrayProductLessThanK(int[] nums, int k) {\n    if (k <= 1) return 0;\n    int prod = 1, count = 0, left = 0;\n    for (int right = 0; right < nums.length; right++) {\n        prod *= nums[right];\n        while (prod >= k) prod /= nums[left++];\n        count += right - left + 1;\n    }\n    return count;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    k = $args[1]\n    result = numSubarrayProductLessThanK(nums, k)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args[0];\n    const k = $args[1];\n    const result = numSubarrayProductLessThanK(nums, k);\n    console.log(result);\n}"
        }
    },
    "714": {
        "title": "Maximum Profit with Transaction Fee",
        "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `fee` representing a transaction fee. Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. Note that you may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
        "example": "Example:\n\nInput: prices = [1,3,2,8,4,9], fee = 2\nOutput: 8\nExplanation: The maximum profit can be achieved by:\n- Buying at prices[0] = 1\n- Selling at prices[3] = 8\n- Buying at prices[4] = 4\n- Selling at prices[5] = 9\nThe total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming",
            "greedy"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        3,
                        2,
                        8,
                        4,
                        9
                    ],
                    2
                ],
                [
                    [
                        1,
                        3,
                        7,
                        5,
                        10,
                        3
                    ],
                    3
                ],
                [
                    [
                        7,
                        1,
                        5,
                        3,
                        6,
                        4
                    ],
                    2
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1
                ],
                [
                    [
                        7,
                        6,
                        4,
                        3,
                        1
                    ],
                    0
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    0
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    100
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    10000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    100000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1000000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    10000000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    100000000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1000000000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    10000000000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    100000000000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1000000000000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    10000000000000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    100000000000000
                ]
            ],
            "outputs": [
                8,
                6,
                4,
                4,
                0,
                4,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "int maxProfit(vector<int>& prices, int fee) {\n    int cash = 0, hold = -prices[0];\n    for (int price : prices) {\n        int temp = cash;\n        cash = max(cash, hold + price - fee);\n        hold = max(hold, temp - price);\n    }\n    return cash;\n}\n",
            "java": "public int maxProfit(int[] prices, int fee) {\n    int cash = 0, hold = -prices[0];\n    for (int price : prices) {\n        int temp = cash;\n        cash = Math.max(cash, hold + price - fee);\n        hold = Math.max(hold, temp - price);\n    }\n    return cash;\n}\n",
            "python": "def maxProfit(prices, fee):\n    cash, hold = 0, -prices[0]\n    for price in prices:\n        temp = cash\n        cash = max(cash, hold + price - fee)\n        hold = max(hold, temp - price)\n    return cash\n",
            "javascript": "function maxProfit(prices, fee) {\n    let cash = 0, hold = -prices[0];\n    for (const price of prices) {\n        let temp = cash;\n        cash = Math.max(cash, hold + price - fee);\n        hold = Math.max(hold, temp - price);\n    }\n    return cash;\n}\n",
            "explanation": "The algorithm utilizes dynamic programming to solve the problem. We maintain two variables, `cash` and `hold`. `cash` represents the maximum profit we can achieve when we hold no stock (sell or not buy it), whereas `hold` represents the maximum profit we can achieve when we hold the stock (buy or not sell it).\n\n1. Initialize `cash` to 0 and `hold` to `-prices[0]`. (Initially, we assume that we buy the stock on the first day)\n2. Iterate through the `prices` array.\n3. In each iteration, we update `cash` as maximum of the current value of `cash` and `hold + price - fee`. This means that we either sell the stock at the current price (subtracting the transaction fee) or don't take any action.\n4. Similarly, update `hold` as maximum of current value of `hold` and `cash - price`. This means that we either buy the stock at the current price or don't take any action.\n5. After iterating through the entire `prices` array, return the final value of `cash` as the maximum profit."
        },
        "structure": {
            "c++": "int maxProfit(vector<int>& prices, int fee) \n    // Your code here\n}\n",
            "java": "public int maxProfit(int[] prices, int fee) \n    // Your code here\n}\n",
            "python": "def maxProfit(prices, fee):\n    # Your code here\n\n",
            "javascript": "function maxProfit(prices, fee) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> prices = $args;\n    int fee = $args;\n    int result = maxProfit(prices, fee);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int main(int[] prices, int fee) {\n    int cash = 0, hold = -prices[0];\n    for (int price : prices) {\n        int temp = cash;\n        cash = Math.max(cash, hold + price - fee);\n        hold = Math.max(hold, temp - price);\n    }\n    return cash;\n}",
            "python": "if __name__ == \"__main__\":\n    prices = $args[0]\n    fee = $args[1]\n    result = maxProfit(prices, fee)\n    print(result)",
            "javascript": "function main() {\n    const prices = $args[0];\n    const fee = $args[1];\n    const result = maxProfit(prices, fee);\n    console.log(result);\n}"
        }
    },
    "716": {
        "title": "Max Stack",
        "description": "Design a max stack data structure that supports the stack operations and finding the stack's maximum element. Implement the `MaxStack` class with the following methods: `MaxStack()`, `void push(int x)`, `int pop()`, `int top()`, `int peekMax()`, and `int popMax()`. The `top` method should have a time complexity of O(1), while the other methods should have a time complexity of O(logn).",
        "example": "Example:\n\nMaxStack stk = new MaxStack();\nstk.push(5);   // [5] the top of the stack and the maximum number is 5.\nstk.push(1);   // [5, 1] the top of the stack is 1, but the maximum is 5.\nstk.push(5);   // [5, 1, 5] the top of the stack is 5, which is also the maximum, because it is the top most one.\nstk.top();     // return 5, [5, 1, 5] the stack did not change.\nstk.popMax();  // return 5, [5, 1] the stack is changed now, and the top is different from the max.\nstk.top();     // return 1, [5, 1] the stack did not change.\nstk.peekMax(); // return 5, [5, 1] the stack did not change.\nstk.pop();     // return 1, [5] the top of the stack and the max element is now 5.\nstk.top();     // return 5, [5] the stack did not change.",
        "level": "Medium",
        "tags": [
            "Stack",
            "Data Structure"
        ],
        "test_cases": {
            "inputs": [
                [],
                [
                    5
                ],
                [
                    1
                ],
                [
                    5
                ],
                [],
                [],
                [],
                [],
                [],
                []
            ],
            "outputs": [
                "null",
                "null",
                "null",
                "null",
                "5",
                "5",
                "1",
                "5",
                "1",
                "5"
            ]
        },
        "sample_code": {
            "c++": "#include <set>\n#include <stack>\n\nclass MaxStack {\n    std::stack<int> mainStack;\n    std::multiset<int> maxSet;\n\npublic:\n    MaxStack() {}\n    \n    void push(int x) {\n        mainStack.push(x);\n        maxSet.insert(x);\n    }\n    \n    int pop() {\n        int top = mainStack.top();\n        mainStack.pop();\n        maxSet.erase(maxSet.find(top));\n        return top;\n    }\n    \n    int top() {\n        return mainStack.top();\n    }\n    \n    int peekMax() {\n        return *maxSet.rbegin();\n    }\n    \n    int popMax() {\n        int max = *maxSet.rbegin();\n        maxSet.erase(maxSet.find(max));\n        \n        std::stack<int> tempStack;\n        while (mainStack.top() != max) {\n            tempStack.push(mainStack.top());\n            mainStack.pop();\n        }\n        mainStack.pop();\n        while (!tempStack.empty()) {\n            mainStack.push(tempStack.top());\n            tempStack.pop();\n        }\n        \n        return max;\n    }\n};\n",
            "java": "import java.util.Stack;\nimport java.util.TreeSet;\n\nclass MaxStack {\n    Stack<Integer> mainStack;\n    TreeSet<Integer> maxSet;\n\n    public MaxStack() {\n        mainStack = new Stack<>();\n        maxSet = new TreeSet<>();\n    }\n\n    public void push(int x) {\n        mainStack.push(x);\n        maxSet.add(x);\n    }\n\n    public int pop() {\n        int top = mainStack.pop();\n        maxSet.remove(top);\n        return top;\n    }\n\n    public int top() {\n        return mainStack.peek();\n    }\n\n    public int peekMax() {\n        return maxSet.last();\n    }\n\n    public int popMax() {\n        int max = maxSet.last();\n        maxSet.remove(max);\n\n        Stack<Integer> tempStack = new Stack<>();\n        while (mainStack.peek() != max) {\n            tempStack.push(mainStack.pop());\n        }\n        mainStack.pop();\n        while (!tempStack.isEmpty()) {\n            mainStack.push(tempStack.pop());\n        }\n\n        return max;\n    }\n}\n",
            "python": "from sortedcontainers import SortedList\n\nclass MaxStack:\n    def __init__(self):\n        self.mainStack = []\n        self.maxSet = SortedList()\n\n    def push(self, x: int) -> None:\n        self.mainStack.append(x)\n        self.maxSet.add(x)\n\n    def pop(self) -> int:\n        top = self.mainStack.pop()\n        self.maxSet.remove(top)\n        return top\n\n    def top(self) -> int:\n        return self.mainStack[-1]\n\n    def peekMax(self) -> int:\n        return self.maxSet[-1]\n\n    def popMax(self) -> int:\n        max_val = self.maxSet.pop()\n        tempStack = []\n        while self.mainStack[-1] != max_val:\n            tempStack.append(self.mainStack.pop())\n        self.mainStack.pop()\n        while tempStack:\n            self.mainStack.append(tempStack.pop())\n        return max_val\n",
            "javascript": "class MaxStack {\n    constructor() {\n        this.mainStack = [];\n        this.maxSet = new Set();\n    }\n\n    push(x) {\n        this.mainStack.push(x);\n        this.maxSet.add(x);\n    }\n\n    pop() {\n        const top = this.mainStack.pop();\n        this.maxSet.delete(top);\n        return top;\n    }\n\n    top() {\n        return this.mainStack[this.mainStack.length - 1];\n    }\n\n    peekMax() {\n        return Math.max(...this.maxSet);\n    }\n\n    popMax() {\n        const max = Math.max(...this.maxSet);\n        this.maxSet.delete(max);\n\n        const tempStack = [];\n        while (this.mainStack[this.mainStack.length - 1] !== max) {\n            tempStack.push(this.mainStack.pop());\n        }\n        this.mainStack.pop();\n        while (tempStack.length) {\n            this.mainStack.push(tempStack.pop());\n        }\n\n        return max;\n    }\n}\n",
            "explanation": "The algorithm uses two data structures, a main stack and a max set. The main stack is used to store the elements, and the max set is used to store the maximum elements in a sorted order. When an element is pushed onto the stack, it is added to the main stack and the max set. When the top element of the stack is removed, it is also removed from the max set. To find the maximum element, the last element of the max set is returned. To pop the maximum element, the algorithm first finds the maximum element in the list, removes it from the max set, and then removes it from the stack. If there are multiple maximum elements in the list, only the top-most one is removed. The time complexity for each `top` call is O(1) and for each `push`, `pop`, `peekMax`, and `popMax` call is O(logn)."
        },
        "structure": {
            "c++": "#include <set>\n#include <stack>\n\nclass MaxStack \n    // Your code here\n};\n",
            "java": "import java.util.Stack;\nimport java.util.TreeSet;\n\nclass MaxStack \n    // Your code here\n}\n",
            "python": "from sortedcontainers import SortedList\n    # Your code here\n\n",
            "javascript": "class MaxStack \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    MaxStack stack;\n    stack.push($args);\n    int result = stack.pop();\n    cout << result << endl;\n    return 0;\n}",
            "java": "public void push(int x) {\n        mainStack.push(x);\n        maxSet.add(x);\n    }\n\n    public int pop() {\n        int top = mainStack.pop();\n        maxSet.remove(top);\n        return top;\n    }\n\n    public int top() {\n        return mainStack.peek();\n    }\n\n    public int peekMax() {\n        return maxSet.last();\n    }\n\n    public int popMax() {\n        int max = maxSet.last();\n        maxSet.remove(max);\n\n        Stack<Integer> tempStack = new Stack<>();\n        while (mainStack.peek() != max) {\n            tempStack.push(mainStack.pop());\n        }\n        mainStack.pop();\n        while (!tempStack.isEmpty()) {\n            mainStack.push(tempStack.pop());\n        }\n\n        return max;\n    }",
            "python": "if __name__ == \"__main__\":\n    stack = MaxStack()\n    stack.push(5)\n    stack.push(1)\n    stack.push(3)\n    stack.push(2)\n    print(stack.top())\n    print(stack.peekMax())\n    print(stack.popMax())\n    print(stack.top())",
            "javascript": "class MaxStack {\n    constructor() {\n        this.mainStack = [];\n        this.maxSet = new Set();\n    }\n\n    push(x) {\n        this.mainStack.push(x);\n        this.maxSet.add(x);\n    }\n\n    pop() {\n        const top = this.mainStack.pop();\n        this.maxSet.delete(top);\n        return top;\n    }\n\n    top() {\n        return this.mainStack[this.mainStack.length - 1];\n    }\n\n    peekMax() {\n        return Math.max(...this.maxSet);\n    }\n\n    popMax() {\n        const max = Math.max(...this.maxSet);\n        this.maxSet.delete(max);\n\n        const tempStack = [];\n        while (this.mainStack[this.mainStack.length - 1] !== max) {\n            tempStack.push(this.mainStack.pop());\n        }\n        this.mainStack.pop();\n        while (tempStack.length) {\n            this.mainStack.push(tempStack.pop());\n        }\n\n        return max;\n    }\n}"
        }
    },
    "718": {
        "title": "Maximum Length of Subarray",
        "description": "Given two integer arrays `nums1` and `nums2`, find the maximum length of a subarray that appears in both arrays.",
        "example": "Example:\n\nInput: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\nOutput: 3\nExplanation: The repeated subarray with maximum length is [3,2,1].",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        [
                            1,
                            2,
                            3,
                            2,
                            1
                        ],
                        [
                            3,
                            2,
                            1,
                            4,
                            7
                        ]
                    ]
                ],
                [
                    [
                        [
                            0,
                            0,
                            0,
                            0,
                            0
                        ],
                        [
                            0,
                            0,
                            0,
                            0,
                            0
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            5,
                            4,
                            3,
                            2,
                            1
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10,
                            1,
                            2,
                            3,
                            4,
                            5
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            5,
                            4,
                            3,
                            2,
                            1,
                            6,
                            7,
                            8,
                            9,
                            10
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10,
                            5,
                            4,
                            3,
                            2,
                            1
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            5,
                            4,
                            3,
                            2,
                            1
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10,
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            5,
                            4,
                            3,
                            2,
                            1,
                            6,
                            7,
                            8,
                            9,
                            10,
                            5,
                            4,
                            3,
                            2,
                            1
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10,
                            5,
                            4,
                            3,
                            2,
                            1,
                            6,
                            7,
                            8,
                            9,
                            10
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            5,
                            4,
                            3,
                            2,
                            1,
                            6,
                            7,
                            8,
                            9,
                            10
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10,
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            5,
                            4,
                            3,
                            2,
                            1
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            5,
                            4,
                            3,
                            2,
                            1,
                            6,
                            7,
                            8,
                            9,
                            10,
                            5,
                            4,
                            3,
                            2,
                            1,
                            6,
                            7,
                            8,
                            9,
                            10
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10,
                            5,
                            4,
                            3,
                            2,
                            1,
                            6,
                            7,
                            8,
                            9,
                            10,
                            5,
                            4,
                            3,
                            2,
                            1
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            5,
                            4,
                            3,
                            2,
                            1,
                            6,
                            7,
                            8,
                            9,
                            10,
                            5,
                            4,
                            3,
                            2,
                            1
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10,
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9,
                            10,
                            5,
                            4,
                            3,
                            2,
                            1,
                            6,
                            7,
                            8,
                            9,
                            10
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            5,
                            4,
                            3,
                            2,
                            1,
                            6,
                            7,
                            8,
                            9,
                            10,
                            5,
                            4,
                            3,
                            2,
                            1,
                            6,
                            7,
                            8,
                            9,
                            10,
                            5,
                            4,
                            3,
                            2,
                            1,
                            6,
                            7,
                            8,
                            9,
                            10
                        ]
                    ]
                ]
            ],
            "outputs": [
                "3",
                "5",
                "0",
                "5",
                "1",
                "5",
                "5",
                "5",
                "5",
                "5",
                "5",
                "5",
                "5",
                "5",
                "5",
                "5",
                "5",
                "5",
                "5",
                "5"
            ]
        },
        "sample_code": {
            "c++": "int findLength(vector<int>& nums1, vector<int>& nums2) {\n    int m = nums1.size();\n    int n = nums2.size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    int maxLength = 0;\n\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if (nums1[i] == nums2[j]) {\n                dp[i][j] = dp[i + 1][j + 1] + 1;\n                maxLength = max(maxLength, dp[i][j]);\n            }\n        }\n    }\n\n    return maxLength;\n}\n",
            "java": "public int findLength(int[] nums1, int[] nums2) {\n    int m = nums1.length;\n    int n = nums2.length;\n    int[][] dp = new int[m + 1][n + 1];\n    int maxLength = 0;\n\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if (nums1[i] == nums2[j]) {\n                dp[i][j] = dp[i + 1][j + 1] + 1;\n                maxLength = Math.max(maxLength, dp[i][j]);\n            }\n        }\n    }\n\n    return maxLength;\n}\n",
            "python": "def findLength(nums1, nums2):\n    m, n = len(nums1), len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    maxLength = 0\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if nums1[i] == nums2[j]:\n                dp[i][j] = dp[i + 1][j + 1] + 1\n                maxLength = max(maxLength, dp[i][j])\n\n    return maxLength\n",
            "javascript": "function findLength(nums1, nums2) {\n    const m = nums1.length;\n    const n = nums2.length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    let maxLength = 0;\n\n    for (let i = m - 1; i >= 0; i--) {\n        for (let j = n - 1; j >= 0; j--) {\n            if (nums1[i] === nums2[j]) {\n                dp[i][j] = dp[i + 1][j + 1] + 1;\n                maxLength = Math.max(maxLength, dp[i][j]);\n            }\n        }\n    }\n\n    return maxLength;\n}\n",
            "explanation": "The algorithm uses dynamic programming to store the length of the common subarray ending at the current position for both arrays. For each element in the input arrays, it checks if the elements are equal. If they are, it updates the length of their common subarray by adding 1 to the length of the common subarray found in the next positions. Finally, the maximum length found is returned.\n\nNote that the outer loop iterates from the end to the beginning, avoiding the need to initialize values in the table with special cases (like initializing with the maximum length at the beginning of the loop). This makes the code shorter and easier to understand. Each step of the iteration compares elements in the two arrays and updates the maxLength, if necessary."
        },
        "structure": {
            "c++": "int findLength(vector<int>& nums1, vector<int>& nums2) \n    // Your code here\n}\n",
            "java": "public int findLength(int[] nums1, int[] nums2) \n    // Your code here\n}\n",
            "python": "def findLength(nums1, nums2):\n    # Your code here\n\n",
            "javascript": "function findLength(nums1, nums2) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int findLength(vector<int>& nums1, vector<int>& nums2) {\n    int m = nums1.size();\n    int n = nums2.size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    int maxLength = 0;\n\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if (nums1[i] == nums2[j]) {\n                dp[i][j] = dp[i + 1][j + 1] + 1;\n                maxLength = max(maxLength, dp[i][j]);\n            }\n        }\n    }\n\n    return maxLength;\n}",
            "java": "public int findLength(int[] nums1, int[] nums2) {\n    int m = nums1.length;\n    int n = nums2.length;\n    int[][] dp = new int[m + 1][n + 1];\n    int maxLength = 0;\n\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if (nums1[i] == nums2[j]) {\n                dp[i][j] = dp[i + 1][j + 1] + 1;\n                maxLength = Math.max(maxLength, dp[i][j]);\n            }\n        }\n    }\n\n    return maxLength;\n}",
            "python": "if __name__ == \"__main__\":\n    nums1 = $args[0]\n    nums2 = $args[1]\n    result = findLength(nums1, nums2)\n    print(result)",
            "javascript": "function main() {\n    const nums1 = $args[0];\n    const nums2 = $args[1];\n    const result = findLength(nums1, nums2);\n    console.log(result);\n}"
        }
    },
    "719": {
        "title": "Kth Smallest Distance",
        "description": "Given an integer array `nums` and an integer `k`, find the `kth` smallest distance among all the pairs `nums[i]` and `nums[j]` where `0 <= i < j < nums.length`. The distance of a pair of integers `a` and `b` is defined as the absolute difference between `a` and `b`.",
        "example": "Example:\n\nInput: nums = [1,3,1], k = 1\nOutput: 0\nExplanation: Here are all the pairs:\n(1,3) -> 2\n(1,1) -> 0\n(3,1) -> 2\nThen the 1st smallest distance pair is (1,1), and its distance is 0.",
        "level": "Medium",
        "tags": [
            "Array",
            "Sorting",
            "Binary Search"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        3,
                        1
                    ],
                    1
                ],
                [
                    [
                        1,
                        1,
                        1
                    ],
                    2
                ],
                [
                    [
                        1,
                        6,
                        1
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    5
                ],
                [
                    [
                        5,
                        4,
                        3,
                        2,
                        1
                    ],
                    1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    10
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    2
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    4
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    6
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    7
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    8
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    9
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    11
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    12
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    13
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    14
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    15
                ]
            ],
            "outputs": [
                0,
                0,
                5,
                4,
                1,
                4,
                0,
                1,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ]
        },
        "sample_code": {
            "c++": "#include <algorithm>\n#include <vector>\n\nint smallestDistancePair(std::vector<int>& nums, int k) {\n    std::sort(nums.begin(), nums.end());\n    int low = 0, high = nums.back() - nums.front();\n    \n    while (low < high) {\n        int mid = (low + high) / 2;\n        int count = 0, left = 0;\n\n        for (int right = 0; right < nums.size(); ++right) {\n            while (nums[right] - nums[left] > mid) {\n                ++left;\n            }\n            count += (right - left);\n        }\n\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    \n    return low;\n}\n\n",
            "java": "import java.util.Arrays;\n\npublic int smallestDistancePair(int[] nums, int k) {\n    Arrays.sort(nums);\n    int low = 0, high = nums[nums.length - 1] - nums[0];\n    \n    while (low < high) {\n        int mid = (low + high) / 2;\n        int count = 0, left = 0;\n\n        for (int right = 0; right < nums.length; ++right) {\n            while (nums[right] - nums[left] > mid) {\n                ++left;\n            }\n            count += (right - left);\n        }\n\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    \n    return low;\n}\n\n",
            "python": "def smallestDistancePair(nums, k):\n    nums.sort()\n    low, high = 0, nums[-1] - nums[0]\n    \n    while low < high:\n        mid = (low + high) // 2\n        count, left = 0, 0\n\n        for right in range(len(nums)):\n            while nums[right] - nums[left] > mid:\n                left += 1\n            count += (right - left)\n\n        if count < k:\n            low = mid + 1\n        else:\n            high = mid\n    \n    return low\n\n",
            "javascript": "function smallestDistancePair(nums, k) {\n    nums.sort((a, b) => a - b);\n    let low = 0, high = nums[nums.length - 1] - nums[0];\n    \n    while (low < high) {\n        let mid = Math.floor((low + high) / 2);\n        let count = 0, left = 0;\n\n        for (let right = 0; right < nums.length; ++right) {\n            while (nums[right] - nums[left] > mid) {\n                ++left;\n            }\n            count += (right - left);\n        }\n\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    \n    return low;\n}\n\n",
            "explanation": "The algorithm works as follows:\n1. Sort the input array `nums`.\n2. Initialize the search range for the kth smallest distance with `low` as 0 and `high` as the maximum possible distance in the array (i.e., the difference between the last element and the first element).\n3. While `low` is smaller than `high`, perform a binary-search-like technique:\n   a. Calculate the middle distance `mid` between `low` and `high`.\n   b. Initialize `count` and `left` pointers to 0.\n   c. Traverse the array using a `right` pointer.\n   d. Move the `left` pointer to the right as long as the distance between `nums[right]` and `nums[left]` is greater than `mid`.\n   e. Increment the `count` by the difference between `right` and `left`.\n   f. If the `count` is smaller than `k`, update `low` to `mid + 1`. Otherwise, update `high` to `mid`.\n4. When the loop ends, `low` will hold the kth smallest distance."
        },
        "structure": {
            "c++": "#include <algorithm>\n#include <vector>\n\nint smallestDistancePair(std::vector<int>& nums, int k) \n    // Your code here\n}\n\n",
            "java": "import java.util.Arrays;\n\npublic int smallestDistancePair(int[] nums, int k) \n    // Your code here\n}\n\n",
            "python": "def smallestDistancePair(nums, k):\n    # Your code here\n\n",
            "javascript": "function smallestDistancePair(nums, k) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <algorithm>\n#include <vector>\n#include <iostream>\n\nint main() {\n    std::vector<int> nums = $args;\n    int k = 5;\n    int result = smallestDistancePair(nums, k);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public int smallestDistancePair(int[] nums, int k) {\n    Arrays.sort(nums);\n    int low = 0, high = nums[nums.length - 1] - nums[0];\n    \n    while (low < high) {\n        int mid = (low + high) / 2;\n        int count = 0, left = 0;\n\n        for (int right = 0; right < nums.length; ++right) {\n            while (nums[right] - nums[left] > mid) {\n                ++left;\n            }\n            count += (right - left);\n        }\n\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    \n    return low;\n}\n",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    k = $args[1]\n    result = smallestDistancePair(nums, k)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args[0];\n    const k = $args[1];\n    const result = smallestDistancePair(nums, k);\n    console.log(result);\n}"
        }
    },
    "720": {
        "title": "Longest Word in Dictionary",
        "description": "Given an array of strings `words` representing an English Dictionary, return the longest word in `words` that can be built one character at a time by other words in `words`. If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string. Note that the word should be built from left to right with each additional character being added to the end of a previous word.",
        "example": "Example:\n\nInput: words = [\"w \", \"wo \", \"wor \", \"worl \", \"world \"]\nOutput: \"world \"\nExplanation: The word \"world \" can be built one character at a time by \"w \", \"wo \", \"wor \", and \"worl \".",
        "level": "Medium",
        "tags": [
            "array",
            "string"
        ],
        "test_cases": {
            "inputs": [
                [
                    "w ",
                    "wo ",
                    "wor ",
                    "worl ",
                    "world "
                ],
                [
                    "a ",
                    "banana ",
                    "app ",
                    "appl ",
                    "ap ",
                    "apply ",
                    "apple "
                ],
                [
                    "a ",
                    "an ",
                    "ant ",
                    "ante ",
                    "anted ",
                    "anteda ",
                    "antedat ",
                    "antedate "
                ],
                [
                    "c ",
                    "ca ",
                    "cat ",
                    "cats ",
                    "catsd ",
                    "catsdo ",
                    "catsdog ",
                    "catsdogs "
                ],
                [
                    "b ",
                    "ba ",
                    "ban ",
                    "bana ",
                    "banan ",
                    "banana ",
                    "bananas ",
                    "bananass "
                ]
            ],
            "outputs": [
                "world ",
                "apple ",
                "antedate ",
                "catsdogs ",
                ""
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nstd::string longestWord(std::vector<std::string>& words) {\n    std::sort(words.begin(), words.end());\n    std::set<std::string> built_words;\n    std::string result = \"\";\n\n    for (const auto& word : words) {\n        if (word.size() == 1 || built_words.find(word.substr(0, word.size() - 1)) != built_words.end()) {\n            result = (word.size() > result.size()) ? word : result;\n            built_words.insert(word);\n        }\n    }\n\n    return result;\n}\n\n",
            "java": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\nclass Solution {\n    public String longestWord(String[] words) {\n        Arrays.sort(words);\n        Set<String> builtWords = new HashSet<>();\n        String result = \"\";\n\n        for (String word : words) {\n            if (word.length() == 1 || builtWords.contains(word.substring(0, word.length() - 1))) {\n                result = (word.length() > result.length()) ? word : result;\n                builtWords.add(word);\n            }\n        }\n\n        return result;\n    }\n}\n\n",
            "python": "def longest_word(words):\n    built_words = set()\n    result = ''\n\n    for word in sorted(words):\n        if len(word) == 1 or word[:-1] in built_words:\n            if len(word) > len(result):\n                result = word\n            built_words.add(word)\n\n    return result\n\n",
            "javascript": "function longestWord(words) {\n    words.sort();\n    const builtWords = new Set();\n    let result = '';\n\n    for (const word of words) {\n        if (word.length === 1 || builtWords.has(word.slice(0, -1))) {\n            result = (word.length > result.length) ? word : result;\n            builtWords.add(word);\n        }\n    }\n\n    return result;\n}\n\n",
            "explanation": "The algorithm starts by sorting the input list of words. Then, it initializes an empty set `built_words` to store the \"buildable\" words and an empty string `result` to keep track of the longest word found.\n\nFor each word in the sorted list, it checks if the word is buildable by having the length of 1 or its substring without the last character is in the set `built_words`. If the word is buildable, it compares its length with the current `result` and updates the `result` if the word is longer. It also adds the buildable word to the set `built_words`.\n\nAfter iterating through all the words in the list, it returns the longest buildable word found."
        },
        "structure": {
            "c++": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nstd::string longestWord(std::vector<std::string>& words) \n    // Your code here\n}\n\n",
            "java": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\nclass Solution \n    // Your code here\n}\n\n",
            "python": "def longest_word(words):\n    # Your code here\n\n",
            "javascript": "function longestWord(words) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <iostream>\n\nint main() {\n    std::vector<std::string> words = $args;\n    std::string result = longestWord(words);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public String longestWord(String[] words) {\n        Arrays.sort(words);\n        Set<String> builtWords = new HashSet<>();\n        String result = \"\";\n\n        for (String word : words) {\n            if (word.length() == 1 || builtWords.contains(word.substring(0, word.length() - 1))) {\n                result = (word.length() > result.length()) ? word : result;\n                builtWords.add(word);\n            }\n        }\n\n        return result;\n    }",
            "python": "if __name__ == \"__main__\":\n    words = $args[0]\n    result = longest_word(words)\n    print(result)",
            "javascript": "function main() {\n    const words = $args;\n    const result = longestWord(words);\n    console.log(result);\n}"
        }
    },
    "721": {
        "title": "Merge Accounts",
        "description": "Given a list of `accounts` where each element `accounts[i]` is a list of strings, where the first element `accounts[i][0]` is a name, and the rest of the elements are **emails** representing emails of the account. Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name. After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails **in sorted order**. The accounts themselves can be returned in **any order**.",
        "example": "Example:\n\nInput: accounts = [[\"John \", \"johnsmith@mail.com \", \"john_newyork@mail.com \"],[\"John \", \"johnsmith@mail.com \", \"john00@mail.com \"],[\"Mary \", \"mary@mail.com \"],[\"John \", \"johnnybravo@mail.com \"]]\nOutput: [[\"John \", \"john00@mail.com \", \"john_newyork@mail.com \", \"johnsmith@mail.com \"],[\"Mary \", \"mary@mail.com \"],[\"John \", \"johnnybravo@mail.com \"]]\nExplanation: The first and second John's are the same person as they have the common email \"johnsmith@mail.com \". The third John and Mary are different people as none of their email addresses are used by other accounts. We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.",
        "level": "Medium",
        "tags": [
            "list",
            "sorting",
            "string"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "John ",
                        "johnsmith@mail.com ",
                        "john_newyork@mail.com "
                    ],
                    [
                        "John ",
                        "johnsmith@mail.com ",
                        "john00@mail.com "
                    ],
                    [
                        "Mary ",
                        "mary@mail.com "
                    ],
                    [
                        "John ",
                        "johnnybravo@mail.com "
                    ]
                ],
                [
                    [
                        "Gabe ",
                        "Gabe0@m.co ",
                        "Gabe3@m.co ",
                        "Gabe1@m.co "
                    ],
                    [
                        "Kevin ",
                        "Kevin3@m.co ",
                        "Kevin5@m.co ",
                        "Kevin0@m.co "
                    ],
                    [
                        "Ethan ",
                        "Ethan5@m.co ",
                        "Ethan4@m.co ",
                        "Ethan0@m.co "
                    ],
                    [
                        "Hanzo ",
                        "Hanzo3@m.co ",
                        "Hanzo1@m.co ",
                        "Hanzo0@m.co "
                    ],
                    [
                        "Fern ",
                        "Fern5@m.co ",
                        "Fern1@m.co ",
                        "Fern0@m.co "
                    ]
                ]
            ],
            "outputs": [
                "[[\"John \", \"john00@mail.com \", \"john_newyork@mail.com \", \"johnsmith@mail.com \"],[\"Mary \", \"mary@mail.com \"],[\"John \", \"johnnybravo@mail.com \"]]",
                "[[\"Ethan \", \"Ethan0@m.co \", \"Ethan4@m.co \", \"Ethan5@m.co \"],[\"Gabe \", \"Gabe0@m.co \", \"Gabe1@m.co \", \"Gabe3@m.co \"],[\"Hanzo \", \"Hanzo0@m.co \", \"Hanzo1@m.co \", \"Hanzo3@m.co \"],[\"Kevin \", \"Kevin0@m.co \", \"Kevin3@m.co \", \"Kevin5@m.co \"],[\"Fern \", \"Fern0@m.co \", \"Fern1@m.co \", \"Fern5@m.co \"]]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nvoid dfs(int id, const vector<vector<string>>& accounts, vector<bool>& visited, set<string>& merged_emails, map<string, int>& email_to_id) {\n    if (visited[id]) return;\n    visited[id] = true;\n    for (int j = 1; j < accounts[id].size(); ++j) {\n        const string& email = accounts[id][j];\n        merged_emails.insert(email);\n        int next_id = email_to_id[email];\n        dfs(next_id, accounts, visited, merged_emails, email_to_id);\n    }\n}\n\nvector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\n    map<string, int> email_to_id;\n    for (int i = 0; i < accounts.size(); ++i)\n        for (int j = 1; j < accounts[i].size(); ++j)\n            email_to_id[accounts[i][j]] = i;\n\n    vector<vector<string>> result;\n    vector<bool> visited(accounts.size(), false);\n    for (int i = 0; i < accounts.size(); ++i) {\n        if (!visited[i]) {\n            set<string> merged_emails;\n            dfs(i, accounts, visited, merged_emails, email_to_id);\n            vector<string> merged_account(merged_emails.begin(), merged_emails.end());\n            merged_account.insert(merged_account.begin(), accounts[i][0]);\n            result.push_back(merged_account);\n        }\n    }\n    return result;\n}\n\n",
            "java": "import java.util.*;\n\npublic List<List<String>> accountsMerge(List<List<String>> accounts) {\n    Map<String, Integer> emailToId = new HashMap<>();\n    for (int i = 0; i < accounts.size(); ++i) {\n        for (int j = 1; j < accounts.get(i).size(); ++j) {\n            emailToId.put(accounts.get(i).get(j), i);\n        }\n    }\n\n    List<List<String>> result = new ArrayList<>();\n    boolean[] visited = new boolean[accounts.size()];\n    for (int i = 0; i < accounts.size(); ++i) {\n        if (!visited[i]) {\n            Set<String> mergedEmails = new HashSet<>();\n            dfs(i, accounts, visited, mergedEmails, emailToId);\n            List<String> mergedAccount = new ArrayList<>(mergedEmails);\n            Collections.sort(mergedAccount);\n            mergedAccount.add(0, accounts.get(i).get(0));\n            result.add(mergedAccount);\n        }\n    }\n    return result;\n}\n\nprivate void dfs(int id, List<List<String>> accounts, boolean[] visited, Set<String> mergedEmails, Map<String, Integer> emailToId) {\n    if (visited[id]) return;\n    visited[id] = true;\n    for (int j = 1; j < accounts.get(id).size(); ++j) {\n        String email = accounts.get(id).get(j);\n        mergedEmails.add(email);\n        int nextId = emailToId.get(email);\n        dfs(nextId, accounts, visited, mergedEmails, emailToId);\n    }\n}\n\n",
            "python": "from collections import defaultdict\n\ndef accountsMerge(accounts):\n    def dfs(id, visited, merged_emails):\n        if id in visited:\n            return\n        visited.add(id)\n        for email in accounts[id][1:]:\n            merged_emails.add(email)\n            dfs(email_to_id[email], visited, merged_emails)\n\n    email_to_id = {}\n    for i, account in enumerate(accounts):\n        for email in account[1:]:\n            email_to_id[email] = i\n\n    result = []\n    visited = set()\n    for i, account in enumerate(accounts):\n        if i not in visited:\n            merged_emails = set()\n            dfs(i, visited, merged_emails)\n            result.append([account[0]] + sorted(merged_emails))\n    return result\n\n",
            "javascript": "var accountsMerge = function(accounts) {\n    function dfs(id, visited, mergedEmails) {\n        if (visited.has(id)) return;\n        visited.add(id);\n        for (let j = 1; j < accounts[id].length; j++) {\n            const email = accounts[id][j];\n            mergedEmails.add(email);\n            const nextId = emailToId[email];\n            dfs(nextId, visited, mergedEmails);\n        }\n    }\n\n    const emailToId = {};\n    accounts.forEach((account, i) => {\n        account.slice(1).forEach(email => {\n            emailToId[email] = i;\n        });\n    });\n\n    const result = [];\n    const visited = new Set();\n    accounts.forEach((account, i) => {\n        if (!visited.has(i)) {\n            const mergedEmails = new Set();\n            dfs(i, visited, mergedEmails);\n            result.push([account[0], ...Array.from(mergedEmails).sort()]);\n        }\n    });\n    return result;\n};\n\n",
            "explanation": "The algorithm uses a depth-first search (DFS) to merge accounts with the same email. It starts by creating a dictionary `email_to_id` to map email addresses to the account ID. Then, a visited set records visited account IDs. For each unvisited account ID, DFS is used to traverse and collect all the connected email addresses in the merged set. The result is formed by appending the sorted merged email addresses to the account's name. The final result contains all the merged accounts."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nvoid dfs(int id, const vector<vector<string>>& accounts, vector<bool>& visited, set<string>& merged_emails, map<string, int>& email_to_id) \n    // Your code here\n}\n\n",
            "java": "import java.util.*;\n\npublic List<List<String>> accountsMerge(List<List<String>> accounts) \n    // Your code here\n}\n\n",
            "python": "from collections import defaultdict\n    # Your code here\n\n",
            "javascript": "var accountsMerge = function(accounts) \n    // Your code here\n};\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nvoid dfs(int id, const vector<vector<string>>& accounts, vector<bool>& visited, set<string>& merged_emails, map<string, int>& email_to_id);\n\nvector<vector<string>> accountsMerge(vector<vector<string>>& accounts);\n\nint main() {\n    vector<vector<string>> accounts = $args;\n    vector<vector<string>> result = accountsMerge(accounts);\n    for (const auto& account : result) {\n        for (const auto& email : account) {\n            cout << email << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
            "java": "public List<List<String>> accountsMerge(List<List<String>> accounts) {\n    Map<String, Integer> emailToId = new HashMap<>();\n    for (int i = 0; i < accounts.size(); ++i) {\n        for (int j = 1; j < accounts.get(i).size(); ++j) {\n            emailToId.put(accounts.get(i).get(j), i);\n        }\n    }\n\n    List<List<String>> result = new ArrayList<>();\n    boolean[] visited = new boolean[accounts.size()];\n    for (int i = 0; i < accounts.size(); ++i) {\n        if (!visited[i]) {\n            Set<String> mergedEmails = new HashSet<>();\n            dfs(i, accounts, visited, mergedEmails, emailToId);\n            List<String> mergedAccount = new ArrayList<>(mergedEmails);\n            Collections.sort(mergedAccount);\n            mergedAccount.add(0, accounts.get(i).get(0));\n            result.add(mergedAccount);\n        }\n    }\n    return result;\n}\n\nprivate void dfs(int id, List<List<String>> accounts, boolean[] visited, Set<String> mergedEmails, Map<String, Integer> emailToId) {\n    if (visited[id]) return;\n    visited[id] = true;\n    for (int j = 1; j < accounts.get(id).size(); ++j) {\n        String email = accounts.get(id).get(j);\n        mergedEmails.add(email);\n        int nextId = emailToId.get(email);\n        dfs(nextId, accounts, visited, mergedEmails, emailToId);\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    accounts = $args[0]\n    result = accountsMerge(accounts)\n    print(result)",
            "javascript": "var accountsMerge = function(accounts) {\n    function dfs(id, visited, mergedEmails) {\n        if (visited.has(id)) return;\n        visited.add(id);\n        for (let j = 1; j < accounts[id].length; j++) {\n            const email = accounts[id][j];\n            mergedEmails.add(email);\n            const nextId = emailToId[email];\n            dfs(nextId, visited, mergedEmails);\n        }\n    }\n\n    const emailToId = {};\n    accounts.forEach((account, i) => {\n        account.slice(1).forEach(email => {\n            emailToId[email] = i;\n        });\n    });\n\n    const result = [];\n    const visited = new Set();\n    accounts.forEach((account, i) => {\n        if (!visited.has(i)) {\n            const mergedEmails = new Set();\n            dfs(i, visited, mergedEmails);\n            result.push([account[0], ...Array.from(mergedEmails).sort()]);\n        }\n    });\n    return result;\n};"
        }
    },
    "722": {
        "title": "Remove Comments from C++ Program",
        "description": "Given a C++ program, remove comments from it. The program source is an array of strings `source` where `source[i]` is the `ith` line of the source code. This represents the result of splitting the original source code string by the newline character `'\n'`.\n\nIn C++, there are two types of comments, line comments, and block comments.\n\n* The string \"// \" denotes a line comment, which represents that it and the rest of the characters to the right of it in the same line should be ignored.\n* The string \"/* \" denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of \"*/ \" should be ignored. (Here, occurrences happen in reading order: line by line from left to right.) To be clear, the string \"/*/ \" does not yet end the block comment, as the ending would be overlapping the beginning.\n\nThe first effective comment takes precedence over others.\n\n* For example, if the string \"// \" occurs in a block comment, it is ignored.\n* Similarly, if the string \"/* \" occurs in a line or block comment, it is also ignored.\n\nIf a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.\n\nThere will be no control characters, single quote, or double quote characters.\n\nFor example, `source = \"string s = \"/* Not a comment. */ \"; \"` will not be a test case.\n\nAlso, nothing else such as defines or macros will interfere with the comments.\n\nIt is guaranteed that every open block comment will eventually be closed, so \"/* \" outside of a line or block comment always starts a new comment.\n\nFinally, implicit newline characters can be deleted by block comments. Please see the examples below for details.\n\nAfter removing the comments from the source code, return _the source code in the same format_.",
        "example": "Example:\n\nInput:\nsource = [\"/*Test program */ \", \"int main() \", \"{  \", \"  // variable declaration  \", \"int a, b, c; \", \"/* This is a test \", \"   multiline   \", \"   comment for  \", \"   testing */ \", \"a = b + c; \", \"} \"]\nOutput:\n[\"int main() \", \"{  \", \"   \", \"int a, b, c; \", \"a = b + c; \", \"} \"]\nExplanation:\nThe line by line code is visualized as below:\n/*Test program */\nint main()\n{ \n  // variable declaration \nint a, b, c;\n/* This is a test\n   multiline  \n   comment for \n   testing */\na = b + c;\n}\nThe string /* denotes a block comment, including line 1 and lines 6-9. The string // denotes line 4 as comments.\nThe line by line output code is visualized as below:\nint main()\n{ \n  \nint a, b, c;\na = b + c;\n}",
        "level": "Medium",
        "tags": [
            "C++",
            "String Manipulation"
        ],
        "test_cases": {
            "inputs": [
                [
                    "/*Test program */ ",
                    "int main() ",
                    "{  ",
                    "  // variable declaration  ",
                    "int a, b, c; ",
                    "/* This is a test ",
                    "   multiline   ",
                    "   comment for  ",
                    "   testing */ ",
                    "a = b + c; ",
                    "} "
                ],
                [
                    "a/*comment ",
                    "line ",
                    "more_comment*/b "
                ],
                [
                    "int a = 5; // initialization",
                    "int b = 10; /* variable declaration */",
                    "int c = a + b; // addition",
                    "cout << c; // output"
                ],
                [
                    "/* This is a block comment */",
                    "int a = 5; // initialization",
                    "int b = 10; /* variable declaration */",
                    "int c = a + b; // addition",
                    "cout << c; // output"
                ],
                [
                    "int a = 5; // initialization",
                    "int b = 10; /* variable declaration */",
                    "int c = a + b; // addition",
                    "cout << c; // output",
                    "/* This is a block comment */"
                ]
            ],
            "outputs": [
                "[\"int main() \", \"{  \", \"   \", \"int a, b, c; \", \"a = b + c; \", \"} \"]",
                "[\"ab \"]",
                "[\"int a = 5; \", \"int b = 10; \", \"int c = a + b; \", \"cout << c; \"]",
                "[\"int a = 5; \", \"int b = 10; \", \"int c = a + b; \", \"cout << c; \"]",
                "[\"int a = 5; \", \"int b = 10; \", \"int c = a + b; \", \"cout << c; \"]"
            ]
        },
        "sample_code": {
            "c++": "vector<string> removeComments(vector<string>& source) {\n    vector<string> result;\n    string buffer;\n    bool in_block_comment = false;\n    \n    for (const auto& line : source) {\n        for (size_t i = 0; i < line.size(); ++i) {\n            if (in_block_comment) {\n                if (i < line.size() - 1 && line[i] == '*' && line[i + 1] == '/') {\n                    in_block_comment = false;\n                    ++i;\n                }\n            } else {\n                if (i < line.size() - 1 && line[i] == '/' && line[i + 1] == '*') {\n                    in_block_comment = true;\n                    ++i;\n                } else if (i < line.size() - 1 && line[i] == '/' && line[i + 1] == '/') {\n                    break;\n                } else {\n                    buffer.push_back(line[i]);\n                }\n            }\n        }\n        if (!in_block_comment && !buffer.empty()) {\n            result.push_back(buffer);\n            buffer.clear();\n        }\n    }\n    return result;\n}\n\n",
            "java": "public List<String> removeComments(String[] source) {\n    List<String> result = new ArrayList<>();\n    StringBuilder buffer = new StringBuilder();\n    boolean inBlockComment = false;\n\n    for (String line : source) {\n        for (int i = 0; i < line.length(); ++i) {\n            if (inBlockComment) {\n                if (i < line.length() - 1 && line.charAt(i) == '*' && line.charAt(i + 1) == '/') {\n                    inBlockComment = false;\n                    ++i;\n                }\n            } else {\n                if (i < line.length() - 1 && line.charAt(i) == '/' && line.charAt(i + 1) == '*') {\n                    inBlockComment = true;\n                    ++i;\n                } else if (i < line.length() - 1 && line.charAt(i) == '/' && line.charAt(i + 1) == '/') {\n                    break;\n                } else {\n                    buffer.append(line.charAt(i));\n                }\n            }\n        }\n        if (!inBlockComment && buffer.length() > 0) {\n            result.add(buffer.toString());\n            buffer.setLength(0);\n        }\n    }\n    return result;\n}\n\n",
            "python": "def removeComments(self, source: List[str]) -> List[str]:\n    result = []\n    buffer = []\n    in_block_comment = False\n\n    for line in source:\n        i = 0\n        while i < len(line):\n            if in_block_comment:\n                if i < len(line) - 1 and line[i] == '*' and line[i + 1] == '/':\n                    in_block_comment = False\n                    i += 1\n            else:\n                if i < len(line) - 1 and line[i] == '/' and line[i + 1] == '*':\n                    in_block_comment = True\n                    i += 1\n                elif i < len(line) - 1 and line[i] == '/' and line[i + 1] == '/':\n                    break\n                else:\n                    buffer.append(line[i])\n            i += 1\n\n        if not in_block_comment and buffer:\n            result.append(''.join(buffer))\n            buffer.clear()\n\n    return result\n\n",
            "javascript": "var removeComments = function(source) {\n    let result = [];\n    let buffer = '';\n    let inBlockComment = false;\n    \n    for (const line of source) {\n        for (let i = 0; i < line.length; ++i) {\n            if (inBlockComment) {\n                if (i < line.length - 1 && line[i] === '*' && line[i + 1] === '/') {\n                    inBlockComment = false;\n                    ++i;\n                }\n            } else {\n                if (i < line.length - 1 && line[i] === '/' && line[i + 1] === '*') {\n                    inBlockComment = true;\n                    ++i;\n                } else if (i < line.length - 1 && line[i] === '/' && line[i + 1] === '/') {\n                    break;\n                } else {\n                    buffer += line[i];\n                }\n            }\n        }\n        if (!inBlockComment && buffer.length) {\n            result.push(buffer);\n            buffer = '';\n        }\n    }\n    return result;\n};\n\n",
            "explanation": "The algorithm begins by initializing an empty result list, an empty buffer string or list, and a boolean variable `in_block_comment` set to `false`. Then, for each line in the source code, we iterate through the characters of the line. The algorithm checks if we are within a block comment or not. If so, it looks for the block comment end combination (`*/`) and sets `in_block_comment` to `false` if found, skipping the end combination characters.\n\nIf not in a block comment, the algorithm checks for the beginning of a block comment (`/*`) and sets the `in_block_comment` variable to `true`. If a line comment start (`//`) is found, it breaks the inner loop to skip the rest of the line since line comments end at the end of the line, making the rest of the line irrelevant. Otherwise, the algorithm appends the current character to the `buffer`.\n\nAfter processing a line, if not in a block comment and the buffer is not empty, the content of the buffer is added to the result list, and the buffer is cleared.\n\nOnce all lines have been processed, the function returns the result list. The implementation remains mostly the same across all four languages, with slight variations due to the respective language syntax."
        },
        "structure": {
            "c++": "vector<string> removeComments(vector<string>& source) \n    // Your code here\n}\n\n",
            "java": "public List<String> removeComments(String[] source) \n    // Your code here\n}\n\n",
            "python": "def removeComments(self, source: List[str]) -> List[str]:\n    # Your code here\n\n",
            "javascript": "var removeComments = function(source) \n    // Your code here\n};\n\n"
        },
        "call_functions": {
            "c++": "vector<string> removeComments(vector<string>& source) {\n    vector<string> result;\n    string buffer;\n    bool in_block_comment = false;\n    \n    for (const auto& line : source) {\n        for (size_t i = 0; i < line.size(); ++i) {\n            if (in_block_comment) {\n                if (i < line.size() - 1 && line[i] == '*' && line[i + 1] == '/') {\n                    in_block_comment = false;\n                    ++i;\n                }\n            } else {\n                if (i < line.size() - 1 && line[i] == '/' && line[i + 1] == '*') {\n                    in_block_comment = true;\n                    ++i;\n                } else if (i < line.size() - 1 && line[i] == '/' && line[i + 1] == '/') {\n                    break;\n                } else {\n                    buffer.push_back(line[i]);\n                }\n            }\n        }\n        if (!in_block_comment && !buffer.empty()) {\n            result.push_back(buffer);\n            buffer.clear();\n        }\n    }\n    return result;\n}",
            "java": "public List<String> removeComments(String[] source) {\n    List<String> result = new ArrayList<>();\n    StringBuilder buffer = new StringBuilder();\n    boolean inBlockComment = false;\n\n    for (String line : source) {\n        for (int i = 0; i < line.length(); ++i) {\n            if (inBlockComment) {\n                if (i < line.length() - 1 && line.charAt(i) == '*' && line.charAt(i + 1) == '/') {\n                    inBlockComment = false;\n                    ++i;\n                }\n            } else {\n                if (i < line.length() - 1 && line.charAt(i) == '/' && line.charAt(i + 1) == '*') {\n                    inBlockComment = true;\n                    ++i;\n                } else if (i < line.length() - 1 && line.charAt(i) == '/' && line.charAt(i + 1) == '/') {\n                    break;\n                } else {\n                    buffer.append(line.charAt(i));\n                }\n            }\n        }\n        if (!inBlockComment && buffer.length() > 0) {\n            result.add(buffer.toString());\n            buffer.setLength(0);\n        }\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    source = $args[0]\n    result = removeComments(source)\n    print(result)",
            "javascript": "var removeComments = function(source) {\n    let result = [];\n    let buffer = '';\n    let inBlockComment = false;\n    \n    for (const line of source) {\n        for (let i = 0; i < line.length; ++i) {\n            if (inBlockComment) {\n                if (i < line.length - 1 && line[i] === '*' && line[i + 1] === '/') {\n                    inBlockComment = false;\n                    ++i;\n                }\n            } else {\n                if (i < line.length - 1 && line[i] === '/' && line[i + 1] === '*') {\n                    inBlockComment = true;\n                    ++i;\n                } else if (i < line.length - 1 && line[i] === '/' && line[i + 1] === '/') {\n                    break;\n                } else {\n                    buffer += line[i];\n                }\n            }\n        }\n        if (!inBlockComment && buffer.length) {\n            result.push(buffer);\n            buffer = '';\n        }\n    }\n    return result;\n};"
        }
    },
    "724": {
        "title": "Pivot Index",
        "description": "Given an array of integers `nums`, calculate the **pivot index** of this array. The **pivot index** is the index where the sum of all the numbers **strictly** to the left of the index is equal to the sum of all the numbers **strictly** to the index's right. If the index is on the left edge of the array, then the left sum is `0` because there are no elements to the left. This also applies to the right edge of the array. Return the **leftmost pivot index**. If no such index exists, return `-1`.",
        "example": "Example:\n\nInput: nums = [1,7,3,6,5,6]\nOutput: 3\nExplanation: The pivot index is 3. Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11. Right sum = nums[4] + nums[5] = 5 + 6 = 11",
        "level": "Easy",
        "tags": [
            "array"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    7,
                    3,
                    6,
                    5,
                    6
                ],
                [
                    1,
                    2,
                    3
                ],
                [
                    2,
                    1,
                    -1
                ],
                [
                    -1,
                    -1,
                    -1,
                    0,
                    1,
                    1
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    -6,
                    -7,
                    -8,
                    -9,
                    -10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    -6,
                    -7,
                    -8,
                    -9,
                    -10,
                    -11
                ],
                [
                    1
                ],
                [
                    -1
                ],
                [
                    0
                ],
                [
                    0,
                    1
                ],
                [
                    1,
                    0
                ],
                [
                    0,
                    0
                ],
                [
                    1,
                    1
                ],
                [
                    1,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ]
            ],
            "outputs": [
                "3",
                "-1",
                "0",
                "3",
                "0",
                "-1",
                "-1",
                "-1",
                "-1",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0"
            ]
        },
        "sample_code": {
            "c++": "int pivotIndex(vector<int>& nums) {\n    int total_sum = 0, left_sum = 0;\n    for (int num : nums)\n        total_sum += num;\n    for (int i = 0; i < nums.size(); ++i) {\n        if (left_sum == total_sum - left_sum - nums[i])\n            return i;\n        left_sum += nums[i];\n    }\n    return -1;\n}\n\n",
            "java": "public int pivotIndex(int[] nums) {\n    int total_sum = 0, left_sum = 0;\n    for (int num : nums)\n        total_sum += num;\n    for (int i = 0; i < nums.length; ++i) {\n        if (left_sum == total_sum - left_sum - nums[i])\n            return i;\n        left_sum += nums[i];\n    }\n    return -1;\n}\n\n",
            "python": "def pivotIndex(nums):\n    total_sum = sum(nums)\n    left_sum = 0\n    for i, num in enumerate(nums):\n        if left_sum == total_sum - left_sum - num:\n            return i\n        left_sum += num\n    return -1\n\n",
            "javascript": "function pivotIndex(nums) {\n    const total_sum = nums.reduce((a, b) => a + b, 0);\n    let left_sum = 0;\n    for (let i = 0; i < nums.length; ++i) {\n        if (left_sum === total_sum - left_sum - nums[i])\n            return i;\n        left_sum += nums[i];\n    }\n    return -1;\n}\n\n",
            "explanation": "1. First, find the total sum of the array.\n2. Iterate through the array, maintaining a running sum of the elements to the left of the current index.\n3. For each index, check if the left sum is equal to the total sum minus the left sum and the value at the current index.\n4. If such equality is found, return the index as the pivot index. If not found, return -1. "
        },
        "structure": {
            "c++": "int pivotIndex(vector<int>& nums) \n    // Your code here\n}\n\n",
            "java": "public int pivotIndex(int[] nums) \n    // Your code here\n}\n\n",
            "python": "def pivotIndex(nums):\n    # Your code here\n\n",
            "javascript": "function pivotIndex(nums) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> nums = $args;\n    int result = pivotIndex(nums);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int pivotIndex(int[] nums) {\n    int total_sum = 0, left_sum = 0;\n    for (int num : nums)\n        total_sum += num;\n    for (int i = 0; i < nums.length; ++i) {\n        if (left_sum == total_sum - left_sum - nums[i])\n            return i;\n        left_sum += nums[i];\n    }\n    return -1;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = pivotIndex(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const total_sum = nums.reduce((a, b) => a + b, 0);\n    let left_sum = 0;\n    for (let i = 0; i < nums.length; ++i) {\n        if (left_sum === total_sum - left_sum - nums[i])\n            return i;\n        left_sum += nums[i];\n    }\n    return -1;\n}\n"
        }
    },
    "726": {
        "title": "Chemical Formula Count",
        "description": "Given a string `formula` representing a chemical formula, return the count of each atom. The atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name. One or more digits representing that element's count may follow if the count is greater than `1`. If the count is `1`, no digits will follow. Two formulas are concatenated together to produce another formula. A formula placed in parentheses, and a count (optionally added) is also a formula. Return the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than `1`), followed by the second name (in sorted order), followed by its count (if that count is more than `1`), and so on.",
        "example": "Example 1:\n\nInput: formula = \"H2O\"\nOutput: \"H2O\"\nExplanation: The count of elements are {'H': 2, 'O': 1}.\n\nExample 2:\n\nInput: formula = \"Mg(OH)2\"\nOutput: \"H2MgO2\"\nExplanation: The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.\n\nExample 3:\n\nInput: formula = \"K4(ON(SO3)2)2\"\nOutput: \"K4N2O14S4\"\nExplanation: The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.",
        "level": "Medium",
        "tags": [
            "string",
            "parsing",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                "\"H2O\"",
                "\"Mg(OH)2\"",
                "\"K4(ON(SO3)2)2\"",
                "\"C6H12O6\"",
                "\"(NH4)2SO4\"",
                "\"CaCO3\"",
                "\"C12H22O11\"",
                "\"H2SO4\"",
                "\"NaCl\"",
                "\"H2O2\"",
                "\"(CH3)2CO\"",
                "\"C6H8O7\"",
                "\"C10H16N5O13P3\"",
                "\"(C6H10O5)n\"",
                "\"C6H6\"",
                "\"C6H5OH\"",
                "\"C6H5COOH\"",
                "\"C6H5NH2\"",
                "\"C6H5NO2\"",
                "\"C6H5NHNH2\""
            ],
            "outputs": [
                "\"H2O\"",
                "\"H2MgO2\"",
                "\"K4N2O14S4\"",
                "\"C6H12O6\"",
                "\"N2H8O4S\"",
                "\"CaCO3\"",
                "\"C12H22O11\"",
                "\"H2O4S\"",
                "\"ClNa\"",
                "\"H2O2\"",
                "\"C4H10O\"",
                "\"C6H8O7\"",
                "\"C10H16N5O13P3\"",
                "\"C6H10O5\"",
                "\"C6H6\"",
                "\"C6H6O\"",
                "\"C6H6O2\"",
                "\"C6H7N\"",
                "\"C6H6NO2\"",
                "\"C6H7N2\""
            ]
        },
        "sample_code": {
            "c++": "#include <map>\n#include <string>\nusing namespace std;\n\nmap<string, int> parse(const string &formula, int &i) {\n    map<string, int> counts;\n    while (i < formula.size()) {\n        if (formula[i] == '(') {\n            map<string, int> temp = parse(formula, ++i);\n            int count = 0;\n            while (isdigit(formula[i])) {\n                count = count * 10 + (formula[i++] - '0');\n            }\n            if (count == 0) count = 1;\n            for (const auto &e : temp) {\n                counts[e.first] += e.second * count;\n            }\n        } else if (formula[i] == ')') {\n            ++i;\n            return counts;\n        } else {\n            string name;\n            name += formula[i++];\n            while (islower(formula[i])) {\n                name += formula[i++];\n            }\n            int count = 0;\n            while (isdigit(formula[i])) {\n                count = count * 10 + (formula[i++] - '0');\n            }\n            if (count == 0) count = 1;\n            counts[name] += count;\n        }\n    }\n    return counts;\n}\n\nstring countOfAtoms(string formula) {\n    int i = 0;\n    map<string, int> counts = parse(formula, i);\n    string ans;\n    for (const auto &e : counts) {\n        ans += e.first;\n        if (e.second > 1) ans += to_string(e.second);\n    }\n    return ans;\n}\n\n",
            "java": "import java.util.Map;\nimport java.util.TreeMap;\n\npublic String countOfAtoms(String formula) {\n    int[] i = {0};\n    Map<String, Integer> counts = parse(formula, i);\n    StringBuilder ans = new StringBuilder();\n    for (Map.Entry<String, Integer> entry : counts.entrySet()) {\n        ans.append(entry.getKey());\n        if (entry.getValue() > 1) ans.append(entry.getValue());\n    }\n    return ans.toString();\n}\n\nprivate Map<String, Integer> parse(String formula, int[] i) {\n    Map<String, Integer> counts = new TreeMap<>();\n    while (i[0] < formula.length()) {\n        if (formula.charAt(i[0]) == '(') {\n            Map<String, Integer> temp = parse(formula, new int[]{++i[0]});\n            int count = 0;\n            while (i[0] < formula.length() && Character.isDigit(formula.charAt(i[0]))) {\n                count = count * 10 + (formula.charAt(i[0]++) - '0');\n            }\n            if (count == 0) count = 1;\n            for (Map.Entry<String, Integer> entry : temp.entrySet()) {\n                counts.put(entry.getKey(), counts.getOrDefault(entry.getKey(), 0) + entry.getValue() * count);\n            }\n        } else if (formula.charAt(i[0]) == ')') {\n            ++i[0];\n            return counts;\n        } else {\n            StringBuilder name = new StringBuilder().append(formula.charAt(i[0]++));\n            while (i[0] < formula.length() && Character.isLowerCase(formula.charAt(i[0]))) {\n                name.append(formula.charAt(i[0]++));\n            }\n            int count = 0;\n            while (i[0] < formula.length() && Character.isDigit(formula.charAt(i[0]))) {\n                count = count * 10 + (formula.charAt(i[0]++) - '0');\n            }\n            if (count == 0) count = 1;\n            counts.put(name.toString(), counts.getOrDefault(name.toString(), 0) + count);\n        }\n    }\n    return counts;\n}\n\n",
            "python": "from collections import Counter\n\ndef parse(formula, i):\n    counts = Counter()\n    while i[0] < len(formula):\n        if formula[i[0]] == '(':\n            i[0] += 1\n            temp = parse(formula, i)\n            count = 0\n            while i[0] < len(formula) and formula[i[0]].isdigit():\n                count = count * 10 + int(formula[i[0]])\n                i[0] += 1\n            if count == 0: count = 1\n            for name, c in temp.items():\n                counts[name] += c * count\n        elif formula[i[0]] == ')':\n            i[0] += 1\n            return counts\n        else:\n            name = formula[i[0]]\n            i[0] += 1\n            while i[0] < len(formula) and formula[i[0]].islower():\n                name += formula[i[0]]\n                i[0] += 1\n            count = 0\n            while i[0] < len(formula) and formula[i[0]].isdigit():\n                count = count * 10 + int(formula[i[0]])\n                i[0] += 1\n            if count == 0: count = 1\n            counts[name] += count\n    return counts\n\ndef countOfAtoms(formula):\n    i = [0]\n    counts = parse(formula, i)\n    ans = []\n    for name, count in counts.items():\n        ans.append(name)\n        if count > 1: ans.append(str(count))\n    return ''.join(ans)\n\n",
            "javascript": "function parse(formula, i) {\n    let counts = {};\n    while (i[0] < formula.length) {\n        if (formula[i[0]] == '(') {\n            i[0] += 1;\n            let temp = parse(formula, i);\n            let count = 0;\n            while (i[0] < formula.length && !isNaN(formula[i[0]])) {\n                count = count * 10 + parseInt(formula[i[0]]);\n                i[0] += 1;\n            }\n            if (count == 0) count = 1;\n            for (let [name, c] of Object.entries(temp)) {\n                counts[name] = (counts[name] || 0) + c * count;\n            }\n        } else if (formula[i[0]] == ')') {\n            i[0] += 1;\n            return counts;\n        } else {\n            let name = formula[i[0]];\n            i[0] += 1;\n            while (i[0] < formula.length && formula[i[0]] >= 'a' && formula[i[0]] <= 'z') {\n                name += formula[i[0]];\n                i[0] += 1;\n            }\n            let count = 0;\n            while (i[0] < formula.length && !isNaN(formula[i[0]])) {\n                count = count * 10 + parseInt(formula[i[0]]);\n                i[0] += 1;\n            }\n            if (count == 0) count = 1;\n            counts[name] = (counts[name] || 0) + count;\n        }\n    }\n    return counts;\n}\n\nfunction countOfAtoms(formula) {\n    let i = [0];\n    let counts = parse(formula, i);\n    let ans = [];\n    for (let name of Object.keys(counts).sort()) {\n        ans.push(name);\n        if (counts[name] > 1) ans.push(counts[name]);\n    }\n    return ans.join('');\n}\n\n",
            "explanation": "The algorithm is based on a recursive descent parser. The idea is to parse the formula progressively, recognizing the atoms and the opening and closing parentheses. When an opening parenthesis is found, it calls itself to parse the inner formula, then when a closing parenthesis is found, it exits the function and accumulates the counts of the atoms, considering any eventual multiplier following the parentheses. If the formula contains no more parentheses, it will simply read the atoms and their counts.\n\nThe resulting atom counts are stored in a map or dictionary, depending on the language. In the end, the algorithm formats the output, concatenating the atom names and their counts (if greater than 1). The elements in the output are ordered based on the requirements (sorted), and no additional formatting is required."
        },
        "structure": {
            "c++": "#include <map>\n#include <string>\nusing namespace std;\n\nmap<string, int> parse(const string &formula, int &i) \n    // Your code here\n}\n\n",
            "java": "import java.util.Map;\nimport java.util.TreeMap;\n\npublic String countOfAtoms(String formula) \n    // Your code here\n}\n\n",
            "python": "from collections import Counter\n    # Your code here\n\n",
            "javascript": "function parse(formula, i) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <map>\n#include <string>\nusing namespace std;\n\nmap<string, int> parse(const string &formula, int &i);\nstring countOfAtoms(string formula);\n\nint main() {\n    string formula = $args;\n    string result = countOfAtoms(formula);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public String countOfAtoms(String formula) {\n    int[] i = {0};\n    Map<String, Integer> counts = parse(formula, i);\n    StringBuilder ans = new StringBuilder();\n    for (Map.Entry<String, Integer> entry : counts.entrySet()) {\n        ans.append(entry.getKey());\n        if (entry.getValue() > 1) ans.append(entry.getValue());\n    }\n    return ans.toString();\n}\n\nprivate Map<String, Integer> parse(String formula, int[] i) {\n    Map<String, Integer> counts = new TreeMap<>();\n    while (i[0] < formula.length()) {\n        if (formula.charAt(i[0]) == '(') {\n            Map<String, Integer> temp = parse(formula, new int[]{++i[0]});\n            int count = 0;\n            while (i[0] < formula.length() && Character.isDigit(formula.charAt(i[0]))) {\n                count = count * 10 + (formula.charAt(i[0]++) - '0');\n            }\n            if (count == 0) count = 1;\n            for (Map.Entry<String, Integer> entry : temp.entrySet()) {\n                counts.put(entry.getKey(), counts.getOrDefault(entry.getKey(), 0) + entry.getValue() * count);\n            }\n        } else if (formula.charAt(i[0]) == ')') {\n            ++i[0];\n            return counts;\n        } else {\n            StringBuilder name = new StringBuilder().append(formula.charAt(i[0]++));\n            while (i[0] < formula.length() && Character.isLowerCase(formula.charAt(i[0]))) {\n                name.append(formula.charAt(i[0]++));\n            }\n            int count = 0;\n            while (i[0] < formula.length() && Character.isDigit(formula.charAt(i[0]))) {\n                count = count * 10 + (formula.charAt(i[0]++) - '0');\n            }\n            if (count == 0) count = 1;\n            counts.put(name.toString(), counts.getOrDefault(name.toString(), 0) + count);\n        }\n    }\n    return counts;\n}",
            "python": "if __name__ == \"__main__\":\n    formula = $args[0]\n    result = countOfAtoms(formula)\n    print(result)",
            "javascript": "function countOfAtoms(formula) {\n    let i = [0];\n    let counts = parse(formula, i);\n    let ans = [];\n    for (let name of Object.keys(counts).sort()) {\n        ans.push(name);\n        if (counts[name] > 1) ans.push(counts[name]);\n    }\n    return ans.join('');\n}"
        }
    },
    "727": {
        "title": "Minimum Contiguous Substring",
        "description": "Given two strings `s1` and `s2`, find the minimum contiguous substring of `s1` that contains all characters of `s2` in the same order. If no such substring exists, return an empty string. If there are multiple substrings with the same minimum length, return the one with the left-most starting index.",
        "example": "Example:\n\nInput: s1 = \"abcdebdde\", s2 = \"bde\"\nOutput: \"bcde\"\nExplanation: The minimum contiguous substring of s1 that contains all characters of s2 is \"bcde\". Another possible substring is \"bdde\", but it is longer than \"bcde\".\n\nInput: s1 = \"jmeqksfrsdcmsiwvaovztaqenprpvnbstl\", s2 = \"u\"\nOutput: \"\"\nExplanation: There is no substring of s1 that contains the character 'u'.",
        "level": "Medium",
        "tags": [
            "string",
            "subsequence",
            "sliding window"
        ],
        "test_cases": {
            "inputs": [
                [
                    "abcdebdde",
                    "bde"
                ],
                [
                    "jmeqksfrsdcmsiwvaovztaqenprpvnbstl",
                    "u"
                ],
                [
                    "abcdebdde",
                    "bd"
                ],
                [
                    "abcdebdde",
                    "de"
                ],
                [
                    "abcdebdde",
                    "abc"
                ],
                [
                    "abcdebdde",
                    "bdde"
                ],
                [
                    "abcdebdde",
                    "e"
                ],
                [
                    "abcdebdde",
                    "cde"
                ],
                [
                    "abcdebdde",
                    "abcd"
                ],
                [
                    "abcdebdde",
                    "bde"
                ],
                [
                    "abcdebdde",
                    "abcdebdde"
                ],
                [
                    "abcdebdde",
                    "abcdebddef"
                ],
                [
                    "abcdebdde",
                    "abcdebddeabcdebdde"
                ],
                [
                    "abcdebdde",
                    "abcdebddeabcdebddeabcdebdde"
                ],
                [
                    "abcdebdde",
                    "abcdebddeabcdebddeabcdebddeabcdebdde"
                ],
                [
                    "abcdebdde",
                    "abcdebddeabcdebddeabcdebddeabcdebddeabcdebdde"
                ],
                [
                    "abcdebdde",
                    "abcdebddeabcdebddeabcdebddeabcdebddeabcdebddeabcdebdde"
                ],
                [
                    "abcdebdde",
                    "abcdebddeabcdebddeabcdebddeabcdebddeabcdebddeabcdebddeabcdebdde"
                ],
                [
                    "abcdebdde",
                    "abcdebddeabcdebddeabcdebddeabcdebddeabcdebddeabcdebddeabcdebddeabcdebdde"
                ],
                [
                    "abcdebdde",
                    "abcdebddeabcdebddeabcdebddeabcdebddeabcdebddeabcdebddeabcdebddeabcdebddeabcdebdde"
                ]
            ],
            "outputs": [
                "bcde",
                "",
                "bd",
                "de",
                "abc",
                "bdde",
                "e",
                "cde",
                "abcd",
                "bcde",
                "abcdebdde",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <vector>\n\nstd::string min_window_sub_sequence(std::string s1, std::string s2) {\n    int m = s1.length(), n = s2.length();\n    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(m + 1, -1));\n\n    for (int j = 0; j <= m; ++j) {\n        dp[0][j] = j;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            if (s1[j - 1] == s2[i - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = dp[i][j - 1];\n            }\n        }\n    }\n    \n    int start = 0, length = m + 1;\n    for (int j = 1; j <= m; ++j) {\n        if (dp[n][j] != -1 && j - dp[n][j] < length) {\n            start = dp[n][j];\n            length = j - start;\n        }\n    }\n\n    return length == m + 1 ? \"\" : s1.substr(start, length);\n}\n",
            "java": "public String minWindowSubSequence(String s1, String s2) {\n    int m = s1.length(), n = s2.length();\n    int[][] dp = new int[n + 1][m + 1];\n\n    for (int j = 0; j <= m; ++j) {\n        dp[0][j] = j;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            if (s1.charAt(j - 1) == s2.charAt(i - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = dp[i][j - 1];\n            }\n        }\n    }\n    \n    int start = 0, length = m + 1;\n    for (int j = 1; j <= m; ++j) {\n        if (dp[n][j] != 0 && j - dp[n][j] < length) {\n            start = dp[n][j];\n            length = j - start;\n        }\n    }\n\n    return length == m + 1 ? \"\" : s1.substring(start, start + length);\n}\n",
            "python": "def min_window_sub_sequence(s1: str, s2: str) -> str:\n    m, n = len(s1), len(s2)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for j in range(0, m + 1):\n        dp[0][j] = j\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if s1[j - 1] == s2[i - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = dp[i][j - 1]\n\n    start, length = 0, m + 1\n    for j in range(1, m + 1):\n        if dp[n][j] != 0 and j - dp[n][j] < length:\n            start = dp[n][j]\n            length = j - start\n\n    return \"\" if length == m + 1 else s1[start:start + length]\n",
            "javascript": "function minWindowSubSequence(s1, s2) {\n    const m = s1.length, n = s2.length;\n    const dp = Array.from({ length: n + 1 }, () => Array(m + 1).fill(0));\n\n    for (let j = 0; j <= m; ++j) {\n        dp[0][j] = j;\n    }\n\n    for (let i = 1; i <= n; ++i) {\n        for (let j = 1; j <= m; ++j) {\n            if (s1[j - 1] === s2[i - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = dp[i][j - 1];\n            }\n        }\n    }\n    \n    let start = 0, length = m + 1;\n    for (let j = 1; j <= m; ++j) {\n        if (dp[n][j] !== 0 && j - dp[n][j] < length) {\n            start = dp[n][j];\n            length = j - start;\n        }\n    }\n\n    return length === m + 1 ? \"\" : s1.slice(start, start + length);\n}\n",
            "explanation": "We will use Dynamic Programming to build a matrix `dp` where `dp[i][j]` represents the index in string `s1` where the length `i` of the subsequence `s2` has been reached up to index `j` in string `s1`. We fill the `dp` matrix by iterating through `s1` and `s2`, and if `s1[j-1] == s2[i-1]`, then we set `dp[i][j]` equal to the previous subsequence match index (which is `dp[i-1][j-1]`), otherwise, set `dp[i][j]` to the value in the left adjacent cell `dp[i][j-1]`.\n\nThen, we iterate through the last row of the `dp` matrix to find the minimum contiguous substring part of `s1`, such that `s2` is a subsequence of the part. For each cell in the last row (i.e., `dp[n][j]`), we evaluate if there is a better minimum length, and if so, update the `start` and `length` accordingly.\n\nFinally, we return the minimum contiguous substring part of `s1`, or an empty string if `length` is still equal to `m + 1`."
        },
        "structure": {
            "c++": "#include <string>\n#include <vector>\n\nstd::string min_window_sub_sequence(std::string s1, std::string s2) \n    // Your code here\n}\n",
            "java": "public String minWindowSubSequence(String s1, String s2) \n    // Your code here\n}\n",
            "python": "def min_window_sub_sequence(s1: str, s2: str) -> str:\n    # Your code here\n\n",
            "javascript": "function minWindowSubSequence(s1, s2) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <vector>\n#include <iostream>\n\nstd::string min_window_sub_sequence(std::string s1, std::string s2);\n\nint main() {\n    std::string s1 = $args;\n    std::string s2 = $args;\n    std::string result = min_window_sub_sequence(s1, s2);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public String minWindowSubSequence(String s1, String s2) {\n    int m = s1.length(), n = s2.length();\n    int[][] dp = new int[n + 1][m + 1];\n\n    for (int j = 0; j <= m; ++j) {\n        dp[0][j] = j;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            if (s1.charAt(j - 1) == s2.charAt(i - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = dp[i][j - 1];\n            }\n        }\n    }\n    \n    int start = 0, length = m + 1;\n    for (int j = 1; j <= m; ++j) {\n        if (dp[n][j] != 0 && j - dp[n][j] < length) {\n            start = dp[n][j];\n            length = j - start;\n        }\n    }\n\n    return length == m + 1 ? \"\" : s1.substring(start, start + length);\n}",
            "python": "if __name__ == \"__main__\":\n    s1 = $args[0]\n    s2 = $args[1]\n    result = min_window_sub_sequence(s1, s2)\n    print(result)",
            "javascript": "function minWindowSubSequence(s1, s2) {\n    const m = s1.length, n = s2.length;\n    const dp = Array.from({ length: n + 1 }, () => Array(m + 1).fill(0));\n\n    for (let j = 0; j <= m; ++j) {\n        dp[0][j] = j;\n    }\n\n    for (let i = 1; i <= n; ++i) {\n        for (let j = 1; j <= m; ++j) {\n            if (s1[j - 1] === s2[i - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = dp[i][j - 1];\n            }\n        }\n    }\n    \n    let start = 0, length = m + 1;\n    for (let j = 1; j <= m; ++j) {\n        if (dp[n][j] !== 0 && j - dp[n][j] < length) {\n            start = dp[n][j];\n            length = j - start;\n        }\n    }\n\n    return length === m + 1 ? \"\" : s1.slice(start, start + length);\n}"
        }
    },
    "728": {
        "title": "Self-Dividing Numbers",
        "description": "A self-dividing number is a number that is divisible by every digit it contains. For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0. A self-dividing number is not allowed to contain the digit zero. Given two integers left and right, return a list of all the self-dividing numbers in the range [left, right].",
        "example": "Example:\n\nInput: left = 1, right = 22\nOutput: [1,2,3,4,5,6,7,8,9,11,12,15,22]\n\nInput: left = 47, right = 85\nOutput: [48,55,66,77]",
        "level": "Easy",
        "tags": [
            "Math",
            "Numbers"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    22
                ],
                [
                    47,
                    85
                ],
                [
                    1,
                    10
                ],
                [
                    10,
                    20
                ],
                [
                    100,
                    200
                ],
                [
                    500,
                    600
                ],
                [
                    1000,
                    2000
                ],
                [
                    5000,
                    6000
                ],
                [
                    10000,
                    20000
                ],
                [
                    50000,
                    60000
                ],
                [
                    100000,
                    200000
                ],
                [
                    500000,
                    600000
                ],
                [
                    1000000,
                    2000000
                ],
                [
                    5000000,
                    6000000
                ],
                [
                    10000000,
                    20000000
                ],
                [
                    50000000,
                    60000000
                ],
                [
                    100000000,
                    200000000
                ],
                [
                    500000000,
                    600000000
                ],
                [
                    1000000000,
                    2000000000
                ],
                [
                    5000000000,
                    6000000000
                ]
            ],
            "outputs": [
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    11,
                    12,
                    15,
                    22
                ],
                [
                    48,
                    55,
                    66,
                    77
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    11,
                    12,
                    15
                ],
                [
                    111,
                    112,
                    115,
                    122,
                    124,
                    126,
                    128,
                    132,
                    135,
                    144,
                    155,
                    162,
                    168,
                    175,
                    184,
                    212,
                    216,
                    218,
                    224,
                    248,
                    264,
                    288,
                    312,
                    315,
                    324,
                    333,
                    336,
                    351,
                    384,
                    396,
                    412,
                    424,
                    432,
                    435,
                    444,
                    448,
                    464,
                    488,
                    515,
                    555,
                    612,
                    624,
                    648,
                    666,
                    672,
                    728,
                    735,
                    777,
                    784,
                    816,
                    824,
                    848,
                    864,
                    888,
                    912,
                    924,
                    936,
                    999
                ],
                [
                    555,
                    564,
                    612,
                    624,
                    648,
                    666,
                    672,
                    728,
                    735,
                    777,
                    784,
                    816,
                    824,
                    848,
                    864,
                    888
                ],
                [
                    1111,
                    1112,
                    1115,
                    1122,
                    1124,
                    1128,
                    1131,
                    1144,
                    1155,
                    1164,
                    1176,
                    1184,
                    1197,
                    1212,
                    1222,
                    1224,
                    1236,
                    1248,
                    1266,
                    1288,
                    1296,
                    1311,
                    1326,
                    1332,
                    1335,
                    1344,
                    1368,
                    1395,
                    1412,
                    1416,
                    1424,
                    1444,
                    1448,
                    1464,
                    1488,
                    1515,
                    1555,
                    1575,
                    1612,
                    1624,
                    1632,
                    1644,
                    1664,
                    1672,
                    1715,
                    1728,
                    1744,
                    1768,
                    1824,
                    1848,
                    1888,
                    1926,
                    1944,
                    1968,
                    1984,
                    2122,
                    2124,
                    2128,
                    2136,
                    2144,
                    2166,
                    2188,
                    2196,
                    2212,
                    2222,
                    2224,
                    2226,
                    2232,
                    2244,
                    2248,
                    2262,
                    2288,
                    2316,
                    2322,
                    2328,
                    2364,
                    2412,
                    2424,
                    2436,
                    2444,
                    2448,
                    2488,
                    2616,
                    2624,
                    2632,
                    2644,
                    2664,
                    2672,
                    2715,
                    2728,
                    2736,
                    2744,
                    2772,
                    2824,
                    2832,
                    2848,
                    2888,
                    2916,
                    2924,
                    2936,
                    2944,
                    2976,
                    3126,
                    3132,
                    3135,
                    3144,
                    3168,
                    3174,
                    3195,
                    3216,
                    3222,
                    3224,
                    3228,
                    3236,
                    3244,
                    3264,
                    3276,
                    3288,
                    3312,
                    3315,
                    3324,
                    3333,
                    3336,
                    3339,
                    3366,
                    3384,
                    3393,
                    3432,
                    3444,
                    3468,
                    3492,
                    3515,
                    3555,
                    3612,
                    3624,
                    3632,
                    3644,
                    3664,
                    3672,
                    3717,
                    3728,
                    3735,
                    3744,
                    3776,
                    3816,
                    3824,
                    3848,
                    3888,
                    3915,
                    3924,
                    3936,
                    3944,
                    3972,
                    3996,
                    4122,
                    4124,
                    4128,
                    4136,
                    4144,
                    4164,
                    4176,
                    4184,
                    4212,
                    4224,
                    4236,
                    4244,
                    4248,
                    4288,
                    4326,
                    4332,
                    4335,
                    4344,
                    4368,
                    4392,
                    4412,
                    4416,
                    4424,
                    4444,
                    4448,
                    4464,
                    4488,
                    4515,
                    4555,
                    4612,
                    4624,
                    4632,
                    4644,
                    4664,
                    4672,
                    4716,
                    4728,
                    4735,
                    4744,
                    4776,
                    4816,
                    4824,
                    4848,
                    4888,
                    4917,
                    4924,
                    4936,
                    4944,
                    4976,
                    4992,
                    5115,
                    5155,
                    5212,
                    5224,
                    5232,
                    5244,
                    5264,
                    5272,
                    5315,
                    5355,
                    5412,
                    5424,
                    5436,
                    5444,
                    5464,
                    5472,
                    5515,
                    5525,
                    5555,
                    5612,
                    5624,
                    5632,
                    5644,
                    5664,
                    5672,
                    5715,
                    5728,
                    5736,
                    5744,
                    5772,
                    5824,
                    5832,
                    5848,
                    5888,
                    5916,
                    5924,
                    5936,
                    5944,
                    5976,
                    6126,
                    6132,
                    6135,
                    6144,
                    6168,
                    6174,
                    6195,
                    6216,
                    6222,
                    6224,
                    6228,
                    6236,
                    6244,
                    6264,
                    6276,
                    6288,
                    6312,
                    6315,
                    6324,
                    6333,
                    6336,
                    6339,
                    6366,
                    6384,
                    6393,
                    6432,
                    6444,
                    6468,
                    6492,
                    6515,
                    6555,
                    6612,
                    6624,
                    6632,
                    6644,
                    6663,
                    6666,
                    6669,
                    6672,
                    6715,
                    6728,
                    6735,
                    6744,
                    6776,
                    6816,
                    6824,
                    6848,
                    6888,
                    6915,
                    6924,
                    6936,
                    6944,
                    6972,
                    6996,
                    7113,
                    7116,
                    7122,
                    7124,
                    7128,
                    7131,
                    7144,
                    7155,
                    7164,
                    7176,
                    7184,
                    7197,
                    7212,
                    7222,
                    7224,
                    7236,
                    7248,
                    7266,
                    7288,
                    7296,
                    7311,
                    7326,
                    7332,
                    7335,
                    7344,
                    7368,
                    7395,
                    7412,
                    7416,
                    7424,
                    7444,
                    7448,
                    7464,
                    7488,
                    7515,
                    7555,
                    7612,
                    7624,
                    7632,
                    7644,
                    7664,
                    7672,
                    7715,
                    7728,
                    7744,
                    7768,
                    7824,
                    7848,
                    7888,
                    7926,
                    7944,
                    7968,
                    7984,
                    8112,
                    8115,
                    8124,
                    8144,
                    8166,
                    8188,
                    8196,
                    8212,
                    8224,
                    8236,
                    8244,
                    8248,
                    8288,
                    8316,
                    8322,
                    8328,
                    8364,
                    8412,
                    8424,
                    8436,
                    8444,
                    8448,
                    8488,
                    8616,
                    8624,
                    8632,
                    8644,
                    8664,
                    8672,
                    8715,
                    8728,
                    8736,
                    8744,
                    8772,
                    8824,
                    8832,
                    8848,
                    8888,
                    8916,
                    8924,
                    8936,
                    8944,
                    8976,
                    9126,
                    9132,
                    9135,
                    9144,
                    9168,
                    9174,
                    9195,
                    9216,
                    9222,
                    9224,
                    9228,
                    9236,
                    9244,
                    9264,
                    9276,
                    9288,
                    9312,
                    9315,
                    9324,
                    9333,
                    9336,
                    9339,
                    9366,
                    9384,
                    9393,
                    9432,
                    9444,
                    9468,
                    9492,
                    9515,
                    9555,
                    9612,
                    9624,
                    9632,
                    9644,
                    9664,
                    9672,
                    9715,
                    9728,
                    9735,
                    9744,
                    9776,
                    9816,
                    9824,
                    9848,
                    9888,
                    9917,
                    9924,
                    9936,
                    9944,
                    9976,
                    9999
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nbool isSelfDividing(int num) {\n    int n = num;\n    while (n) {\n        int digit = n % 10;\n        if (digit == 0 || num % digit != 0)\n            return false;\n        n /= 10;\n    }\n    return true;\n}\n\nstd::vector<int> selfDividingNumbers(int left, int right) {\n    std::vector<int> result;\n    for (int i = left; i <= right; ++i) {\n        if (isSelfDividing(i))\n            result.push_back(i);\n    }\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public static boolean isSelfDividing(int num) {\n        int n = num;\n        while (n != 0) {\n            int digit = n % 10;\n            if (digit == 0 || num % digit != 0)\n                return false;\n            n /= 10;\n        }\n        return true;\n    }\n\n    public static List<Integer> selfDividingNumbers(int left, int right) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = left; i <= right; ++i) {\n            if (isSelfDividing(i))\n                result.add(i);\n        }\n        return result;\n    }\n}\n",
            "python": "def is_self_dividing(num):\n    n = num\n    while n:\n        digit = n % 10\n        if digit == 0 or num % digit != 0:\n            return False\n        n //= 10\n    return True\n\ndef self_dividing_numbers(left, right):\n    return [i for i in range(left, right+1) if is_self_dividing(i)]\n",
            "javascript": "function isSelfDividing(num) {\n    let n = num;\n    while (n) {\n        const digit = n % 10;\n        if (digit === 0 || num % digit !== 0)\n            return false;\n        n = Math.floor(n / 10);\n    }\n    return true;\n}\n\nfunction selfDividingNumbers(left, right) {\n    const result = [];\n    for (let i = left; i <= right; ++i) {\n        if (isSelfDividing(i))\n            result.push(i);\n    }\n    return result;\n}\n",
            "explanation": "The algorithm consists of two functions: `isSelfDividing` and `selfDividingNumbers`. The first function, `isSelfDividing`, takes an integer as input and returns true if it is a self-dividing number and false otherwise. It does this by checking each digit of the number and verifying that they're nonzero and that the number is divisible by that digit. The checking is done by repeatedly dividing the number by 10 and finding the remainder.\n\nThe second function, `selfDividingNumbers`, takes `left` and `right` as input, and returns a list of self-dividing numbers in the given range. It iterates through all the numbers between `left` and `right` (inclusive) and checks if the number is a self-dividing number using the `isSelfDividing` function. If it is, the number is added to the result list. Finally, the result list is returned."
        },
        "structure": {
            "c++": "#include <vector>\n\nbool isSelfDividing(int num) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution \n    // Your code here\n}\n",
            "python": "def is_self_dividing(num):\n    # Your code here\n\n",
            "javascript": "function isSelfDividing(num) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nbool isSelfDividing(int num) {\n    int n = num;\n    while (n) {\n        int digit = n % 10;\n        if (digit == 0 || num % digit != 0)\n            return false;\n        n /= 10;\n    }\n    return true;\n}\n\nint main() {\n    int left = $args;\n    int right = $args;\n    std::vector<int> result = selfDividingNumbers(left, right);\n    for (int num : result) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}",
            "java": "public static List<Integer> selfDividingNumbers(int left, int right) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = left; i <= right; ++i) {\n            if (isSelfDividing(i))\n                result.add(i);\n        }\n        return result;\n    }",
            "python": "if __name__ == \"__main__\":\n    left = $args[0]\n    right = $args[1]\n    result = self_dividing_numbers(left, right)\n    print(result)",
            "javascript": "function selfDividingNumbers(left, right) {\n    const result = [];\n    for (let i = left; i <= right; ++i) {\n        if (isSelfDividing(i))\n            result.push(i);\n    }\n    return result;\n}"
        }
    },
    "730": {
        "title": "Count Palindromic Subsequences",
        "description": "Given a string s, return the number of different non-empty palindromic subsequences in s. Since the answer may be very large, return it modulo 109 + 7.\n\nA subsequence of a string is obtained by deleting zero or more characters from the string.\n\nA sequence is palindromic if it is equal to the sequence reversed.\n\nTwo sequences a1, a2, ... and b1, b2, ... are different if there is some i for which ai != bi.",
        "example": "Example:\n\nInput: s = \"bccb\"\nOutput: 6\nExplanation: The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'.\nNote that 'bcb' is counted only once, even though it occurs twice.",
        "level": "Medium",
        "tags": [
            "string",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                "\"bccb\"",
                "\"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"",
                "\"a\"",
                "\"aa\"",
                "\"aaa\"",
                "\"aaaa\"",
                "\"aaaaa\"",
                "\"aaaaaa\"",
                "\"aaaaaaa\"",
                "\"aaaaaaaa\"",
                "\"aaaaaaaaa\"",
                "\"aaaaaaaaaa\"",
                "\"aaaaaaaaaaa\"",
                "\"aaaaaaaaaaaa\"",
                "\"aaaaaaaaaaaaa\"",
                "\"aaaaaaaaaaaaaa\"",
                "\"aaaaaaaaaaaaaaa\"",
                "\"aaaaaaaaaaaaaaaa\"",
                "\"aaaaaaaaaaaaaaaaa\"",
                "\"aaaaaaaaaaaaaaaaaa\"",
                "\"aaaaaaaaaaaaaaaaaaa\""
            ],
            "outputs": [
                "6",
                "104860361",
                "1",
                "2",
                "4",
                "8",
                "16",
                "32",
                "64",
                "128",
                "256",
                "512",
                "1024",
                "2048",
                "4096",
                "8192",
                "16384",
                "32768",
                "65536",
                "131072"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\nusing namespace std;\n\nint countPalindromicSubsequences(string s) {\n    int n = s.length();\n    int MOD = 1000000007;\n    vector<vector<int>> dp(4, vector<int>(n + 1, 0));\n\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i + 1; j <= n; j++) {\n            int c = s[i] - 'a';\n            dp[c][j] = dp[0][j - 1] + dp[1][j - 1] + dp[2][j - 1] + dp[3][j - 1] - dp[c][i] + 2;\n            dp[c][j] = (dp[c][j] + MOD) % MOD;\n        }\n    }\n\n    return (dp[0][n] + dp[1][n] + dp[2][n] + dp[3][n]) % MOD;\n}\n\n",
            "java": "public int countPalindromicSubsequences(String S) {\n    int n = S.length();\n    int mod = 1000000007;\n    int[][] dp = new int[4][n + 1];\n\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i + 1; j <= n; j++) {\n            int c = S.charAt(i) - 'a';\n            dp[c][j] = dp[0][j - 1] + dp[1][j - 1] + dp[2][j - 1] + dp[3][j - 1] - dp[c][i] + 2;\n            if (dp[c][j] < 0) dp[c][j] += mod;\n        }\n    }\n\n    return (dp[0][n] + dp[1][n] + dp[2][n] + dp[3][n]) % mod;\n}\n\n",
            "python": "def countPalindromicSubsequences(s: str) -> int:\n    n = len(s)\n    MOD = 1000000007\n    dp = [[0] * (n + 1) for _ in range(4)]\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n + 1):\n            c = ord(s[i]) - ord('a')\n            dp[c][j] = sum(dp[k][j - 1] for k in range(4)) - dp[c][i] + 2\n            dp[c][j] = (dp[c][j] + MOD) % MOD\n\n    return sum(dp[c][n] for c in range(4)) % MOD\n\n",
            "javascript": "function countPalindromicSubsequences(s) {\n    const n = s.length;\n    const MOD = 1000000007;\n    const dp = Array.from({ length: 4 }, () => Array(n + 1).fill(0));\n\n    for (let i = n - 1; i >= 0; i--) {\n        for (let j = i + 1; j <= n; j++) {\n            const c = s.charCodeAt(i) - 97;\n            dp[c][j] = dp[0][j - 1] + dp[1][j - 1] + dp[2][j - 1] + dp[3][j - 1] - dp[c][i] + 2;\n            dp[c][j] = (dp[c][j] + MOD) % MOD;\n        }\n    }\n\n    return (dp[0][n] + dp[1][n] + dp[2][n] + dp[3][n]) % MOD;\n}\n\n",
            "explanation": "The algorithm uses dynamic programming. The state of `dp[i][j]` stores the number of different non-empty palindromic subsequences of `s` with characters from index `i` to `j - 1`, and only considering the character `s[i]`. Iterating over the string from the back, the algorithm checks the current character into its corresponding bucket, and updates the current bucket's values based on the previous state.\n\nThis algorithm has a time complexity of O(N^2), where N is the length of the string. The space complexity is O(N), as the algorithm only stores palindromic subsequences for each character from 'a' to 'd'."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\nusing namespace std;\n\nint countPalindromicSubsequences(string s) \n    // Your code here\n}\n\n",
            "java": "public int countPalindromicSubsequences(String S) \n    // Your code here\n}\n\n",
            "python": "def countPalindromicSubsequences(s: str) -> int:\n    # Your code here\n\n",
            "javascript": "function countPalindromicSubsequences(s) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\nusing namespace std;\n\nint main() {\n    string s = $args;\n    int result = countPalindromicSubsequences(s);\n    cout << result << endl;\n    return 0;\n}\n",
            "java": "public int countPalindromicSubsequences(String S) {\n    int n = S.length();\n    int mod = 1000000007;\n    int[][] dp = new int[4][n + 1];\n\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i + 1; j <= n; j++) {\n            int c = S.charAt(i) - 'a';\n            dp[c][j] = dp[0][j - 1] + dp[1][j - 1] + dp[2][j - 1] + dp[3][j - 1] - dp[c][i] + 2;\n            if (dp[c][j] < 0) dp[c][j] += mod;\n        }\n    }\n\n    return (dp[0][n] + dp[1][n] + dp[2][n] + dp[3][n]) % mod;\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args[0]\n    result = countPalindromicSubsequences(s)\n    print(result)",
            "javascript": "function countPalindromicSubsequences(s) {\n    const n = s.length;\n    const MOD = 1000000007;\n    const dp = Array.from({ length: 4 }, () => Array(n + 1).fill(0));\n\n    for (let i = n - 1; i >= 0; i--) {\n        for (let j = i + 1; j <= n; j++) {\n            const c = s.charCodeAt(i) - 97;\n            dp[c][j] = dp[0][j - 1] + dp[1][j - 1] + dp[2][j - 1] + dp[3][j - 1] - dp[c][i] + 2;\n            dp[c][j] = (dp[c][j] + MOD) % MOD;\n        }\n    }\n\n    return (dp[0][n] + dp[1][n] + dp[2][n] + dp[3][n]) % MOD;\n}"
        }
    },
    "732": {
        "title": "Maximum K-Booking",
        "description": "A `k`-booking happens when `k` events have some non-empty intersection (i.e., there is some time that is common to all `k` events). You are given some events `[startTime, endTime)`, after each given event, return an integer `k` representing the maximum `k`-booking between all the previous events. Implement the `MyCalendarThree` class with the following methods:\n\n- `MyCalendarThree()`: Initializes the object.\n- `int book(int startTime, int endTime)`: Returns an integer `k` representing the largest integer such that there exists a `k`-booking in the calendar.",
        "example": "Example:\n\nInput\n[ \"MyCalendarThree\",  \"book\",  \"book\",  \"book\",  \"book\",  \"book\",  \"book\" ]\n[ [], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55] ]\nOutput\n[ null, 1, 1, 2, 3, 3, 3 ]\n\nExplanation\nMyCalendarThree myCalendarThree = new MyCalendarThree();\nmyCalendarThree.book(10, 20); // return 1\nmyCalendarThree.book(50, 60); // return 1\nmyCalendarThree.book(10, 40); // return 2\nmyCalendarThree.book(5, 15); // return 3\nmyCalendarThree.book(5, 10); // return 3\nmyCalendarThree.book(25, 55); // return 3",
        "level": "Medium",
        "tags": [
            "Array",
            "Interval"
        ],
        "test_cases": {
            "inputs": [
                [
                    [],
                    [
                        10,
                        20
                    ],
                    [
                        50,
                        60
                    ],
                    [
                        10,
                        40
                    ],
                    [
                        5,
                        15
                    ],
                    [
                        5,
                        10
                    ],
                    [
                        25,
                        55
                    ]
                ],
                [
                    [],
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [],
                    [
                        100,
                        200
                    ],
                    [
                        150,
                        250
                    ],
                    [
                        300,
                        400
                    ],
                    [
                        350,
                        450
                    ],
                    [
                        500,
                        600
                    ]
                ],
                [
                    [],
                    [
                        10,
                        20
                    ],
                    [
                        15,
                        25
                    ],
                    [
                        20,
                        30
                    ],
                    [
                        25,
                        35
                    ],
                    [
                        30,
                        40
                    ]
                ],
                [
                    [],
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        3,
                        8
                    ],
                    [
                        4,
                        7
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [],
                    [
                        5,
                        10
                    ],
                    [
                        15,
                        20
                    ],
                    [
                        25,
                        30
                    ],
                    [
                        35,
                        40
                    ],
                    [
                        45,
                        50
                    ]
                ],
                [
                    [],
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        3,
                        7
                    ],
                    [
                        4,
                        8
                    ],
                    [
                        5,
                        9
                    ]
                ],
                [
                    [],
                    [
                        10,
                        20
                    ],
                    [
                        30,
                        40
                    ],
                    [
                        50,
                        60
                    ],
                    [
                        70,
                        80
                    ],
                    [
                        90,
                        100
                    ]
                ],
                [
                    [],
                    [
                        1,
                        100
                    ],
                    [
                        2,
                        99
                    ],
                    [
                        3,
                        98
                    ],
                    [
                        4,
                        97
                    ],
                    [
                        5,
                        96
                    ]
                ],
                [
                    [],
                    [
                        10,
                        20
                    ],
                    [
                        15,
                        25
                    ],
                    [
                        20,
                        30
                    ],
                    [
                        25,
                        35
                    ],
                    [
                        30,
                        40
                    ],
                    [
                        35,
                        45
                    ],
                    [
                        40,
                        50
                    ],
                    [
                        45,
                        55
                    ],
                    [
                        50,
                        60
                    ]
                ],
                [
                    [],
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [],
                    [
                        100,
                        200
                    ],
                    [
                        150,
                        250
                    ],
                    [
                        300,
                        400
                    ],
                    [
                        350,
                        450
                    ],
                    [
                        500,
                        600
                    ],
                    [
                        550,
                        650
                    ],
                    [
                        700,
                        800
                    ],
                    [
                        750,
                        850
                    ],
                    [
                        900,
                        1000
                    ]
                ],
                [
                    [],
                    [
                        10,
                        20
                    ],
                    [
                        15,
                        25
                    ],
                    [
                        20,
                        30
                    ],
                    [
                        25,
                        35
                    ],
                    [
                        30,
                        40
                    ],
                    [
                        35,
                        45
                    ],
                    [
                        40,
                        50
                    ],
                    [
                        45,
                        55
                    ],
                    [
                        50,
                        60
                    ],
                    [
                        55,
                        65
                    ],
                    [
                        60,
                        70
                    ],
                    [
                        65,
                        75
                    ],
                    [
                        70,
                        80
                    ],
                    [
                        75,
                        85
                    ],
                    [
                        80,
                        90
                    ],
                    [
                        85,
                        95
                    ],
                    [
                        90,
                        100
                    ],
                    [
                        95,
                        105
                    ],
                    [
                        100,
                        110
                    ]
                ],
                [
                    [],
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        3,
                        8
                    ],
                    [
                        4,
                        7
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        5
                    ],
                    [
                        7,
                        4
                    ],
                    [
                        8,
                        3
                    ],
                    [
                        9,
                        2
                    ],
                    [
                        10,
                        1
                    ]
                ],
                [
                    [],
                    [
                        5,
                        10
                    ],
                    [
                        15,
                        20
                    ],
                    [
                        25,
                        30
                    ],
                    [
                        35,
                        40
                    ],
                    [
                        45,
                        50
                    ],
                    [
                        50,
                        45
                    ],
                    [
                        55,
                        40
                    ],
                    [
                        60,
                        35
                    ],
                    [
                        65,
                        30
                    ],
                    [
                        70,
                        25
                    ],
                    [
                        75,
                        20
                    ],
                    [
                        80,
                        15
                    ],
                    [
                        85,
                        10
                    ],
                    [
                        90,
                        5
                    ],
                    [
                        95,
                        0
                    ]
                ]
            ],
            "outputs": [
                "null",
                "1",
                "1",
                "2",
                "3",
                "3",
                "3",
                "1",
                "5",
                "4",
                "1",
                "2",
                "4",
                "1",
                "2"
            ]
        },
        "sample_code": {
            "c++": "#include <map>\n\nclass MyCalendarThree {\npublic:\n    std::map<int, int> timeline;\n\n    int book(int start, int end) {\n        timeline[start]++;\n        timeline[end]--;\n        int ongoing = 0, k = 0;\n        for (auto& t : timeline) {\n            k = std::max(k, ongoing += t.second);\n        }\n        return k;\n    }\n};\n\n",
            "java": "import java.util.TreeMap;\n\nclass MyCalendarThree {\n    private TreeMap<Integer, Integer> timeline = new TreeMap<>();\n\n    public int book(int start, int end) {\n        timeline.put(start, timeline.getOrDefault(start, 0) + 1);\n        timeline.put(end, timeline.getOrDefault(end, 0) - 1);\n        int ongoing = 0, k = 0;\n        for (int value : timeline.values()) {\n            k = Math.max(k, ongoing += value);\n        }\n        return k;\n    }\n}\n\n",
            "python": "from collections import defaultdict\nimport heapq\n\nclass MyCalendarThree:\n\n    def __init__(self):\n        self.timeline = defaultdict(int)\n\n    def book(self, start: int, end: int) -> int:\n        self.timeline[start] += 1\n        self.timeline[end] -= 1\n        ongoing, k = 0, 0\n        for value in self.timeline.values():\n            k = max(k, ongoing + value)\n            ongoing += value\n        return k\n\n",
            "javascript": "class MyCalendarThree {\n    constructor() {\n        this.timeline = new Map();\n    }\n\n    book(start, end) {\n        this.timeline.set(start, (this.timeline.get(start) || 0) + 1);\n        this.timeline.set(end, (this.timeline.get(end) || 0) - 1);\n        let ongoing = 0, k = 0;\n        for (const value of this.timeline.values()) {\n            k = Math.max(k, ongoing += value);\n        }\n        return k;\n    }\n}\n\n",
            "explanation": "The algorithm maintains a timeline, which is a data structure that stores events with their start and end times. For each booking, we increase the value at the start time by 1 and decrease the value at the end time by 1 in the timeline.\n\nAfter updating the timeline, we iterate over its values and keep track of the ongoing events count. By getting the maximum value of the ongoing events count, we can determine the maximum k-booking.\n\nIn C++, we use a `std::map<int, int>` to store the timeline events, while in Java, we use `TreeMap<Integer, Integer>`. In Python, we use a `collections.defaultdict(int)` to store the timeline events, and in JavaScript, we use a `Map()`.\n\nThe time complexity of the algorithm is O(N * log N) due to sorting for time (start and end) in the timeline data structure. The space complexity is O(N) to store the timeline events where N is the number of events."
        },
        "structure": {
            "c++": "#include <map>\n\nclass MyCalendarThree \n    // Your code here\n};\n\n",
            "java": "import java.util.TreeMap;\n\nclass MyCalendarThree \n    // Your code here\n}\n\n",
            "python": "from collections import defaultdict\n    # Your code here\n\n",
            "javascript": "class MyCalendarThree \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <map>\n\nint main() {\n    MyCalendarThree obj;\n    int start = $args;\n    int end = $args;\n    int result = obj.book(start, end);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int book(int start, int end) {\n        timeline.put(start, timeline.getOrDefault(start, 0) + 1);\n        timeline.put(end, timeline.getOrDefault(end, 0) - 1);\n        int ongoing = 0, k = 0;\n        for (int value : timeline.values()) {\n            k = Math.max(k, ongoing += value);\n        }\n        return k;\n    }",
            "python": "if __name__ == \"__main__\":\n    start = $args[0]\n    end = $args[1]\n    obj = MyCalendarThree()\n    result = obj.book(start, end)\n    print(result)",
            "javascript": "function main() {\n    const start = $args[0];\n    const end = $args[1];\n    const calendar = new MyCalendarThree();\n    const result = calendar.book(start, end);\n    console.log(result);\n}"
        }
    },
    "734": {
        "title": "Similar Sentences",
        "description": "Given two sentences `sentence1` and `sentence2` each represented as a string array and given an array of string pairs `similarPairs` where `similarPairs[i] = [xi, yi]` indicates that the two words `xi` and `yi` are similar. Return `true` if `sentence1` and `sentence2` are similar, or `false` if they are not similar. Two sentences are similar if they have the same length and each word `sentence1[i]` is similar to the corresponding word `sentence2[i]`. A word is always similar to itself, but the similarity relation is not transitive.",
        "example": "Example:\n\nInput:\n\nsentence1 = [\"great\", \"acting\", \"skills\"]\n\nsentence2 = [\"fine\", \"drama\", \"talent\"]\n\nsimilarPairs = [[\"great\", \"fine\"], [\"drama\", \"acting\"], [\"skills\", \"talent\"]]\n\nOutput:\n\ntrue\n\nExplanation: The two sentences have the same length and each word `i` of `sentence1` is also similar to the corresponding word in `sentence2`.",
        "level": "Medium",
        "tags": [
            "array",
            "string",
            "similarity"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "great",
                        "acting",
                        "skills"
                    ],
                    [
                        "fine",
                        "drama",
                        "talent"
                    ],
                    [
                        [
                            "great",
                            "fine"
                        ],
                        [
                            "drama",
                            "acting"
                        ],
                        [
                            "skills",
                            "talent"
                        ]
                    ]
                ],
                [
                    [
                        "great"
                    ],
                    [
                        "great"
                    ],
                    []
                ],
                [
                    [
                        "great"
                    ],
                    [
                        "doubleplus",
                        "good"
                    ],
                    [
                        [
                            "great",
                            "doubleplus"
                        ]
                    ]
                ],
                [
                    [
                        "I",
                        "am",
                        "happy"
                    ],
                    [
                        "I",
                        "am",
                        "excited"
                    ],
                    [
                        [
                            "happy",
                            "excited"
                        ]
                    ]
                ],
                [
                    [
                        "I",
                        "love",
                        "coding"
                    ],
                    [
                        "I",
                        "hate",
                        "coding"
                    ],
                    [
                        [
                            "love",
                            "hate"
                        ]
                    ]
                ],
                [
                    [
                        "I",
                        "can`t",
                        "wait"
                    ],
                    [
                        "I",
                        "can`t",
                        "wait"
                    ],
                    [
                        [
                            "can`t",
                            "can`t"
                        ]
                    ]
                ],
                [
                    [
                        "Bachelor`s",
                        "degree"
                    ],
                    [
                        "Bachelor`s",
                        "degree"
                    ],
                    [
                        [
                            "degree",
                            "degree"
                        ]
                    ]
                ],
                [
                    [
                        "I",
                        "don`t",
                        "know"
                    ],
                    [
                        "I",
                        "don`t",
                        "understand"
                    ],
                    [
                        [
                            "know",
                            "understand"
                        ]
                    ]
                ],
                [
                    [
                        "I",
                        "won`t",
                        "give",
                        "up"
                    ],
                    [
                        "I",
                        "won`t",
                        "quit",
                        "trying"
                    ],
                    [
                        [
                            "give",
                            "quit"
                        ],
                        [
                            "up",
                            "trying"
                        ]
                    ]
                ],
                [
                    [
                        "I",
                        "like",
                        "apples"
                    ],
                    [
                        "I",
                        "like",
                        "oranges"
                    ],
                    [
                        [
                            "apples",
                            "oranges"
                        ]
                    ]
                ],
                [
                    [
                        "I",
                        "enjoy",
                        "reading"
                    ],
                    [
                        "I",
                        "enjoy",
                        "writing"
                    ],
                    [
                        [
                            "reading",
                            "writing"
                        ]
                    ]
                ],
                [
                    [
                        "I",
                        "am",
                        "tired"
                    ],
                    [
                        "I",
                        "am",
                        "exhausted"
                    ],
                    [
                        [
                            "tired",
                            "exhausted"
                        ]
                    ]
                ],
                [
                    [
                        "I",
                        "have",
                        "a",
                        "cat"
                    ],
                    [
                        "I",
                        "have",
                        "a",
                        "dog"
                    ],
                    [
                        [
                            "cat",
                            "dog"
                        ]
                    ]
                ],
                [
                    [
                        "I",
                        "want",
                        "to",
                        "travel"
                    ],
                    [
                        "I",
                        "want",
                        "to",
                        "explore"
                    ],
                    [
                        [
                            "travel",
                            "explore"
                        ]
                    ]
                ],
                [
                    [
                        "I",
                        "am",
                        "hungry"
                    ],
                    [
                        "I",
                        "am",
                        "thirsty"
                    ],
                    [
                        [
                            "hungry",
                            "thirsty"
                        ]
                    ]
                ],
                [
                    [
                        "I",
                        "like",
                        "to",
                        "dance"
                    ],
                    [
                        "I",
                        "like",
                        "to",
                        "sing"
                    ],
                    [
                        [
                            "dance",
                            "sing"
                        ]
                    ]
                ],
                [
                    [
                        "I",
                        "enjoy",
                        "swimming"
                    ],
                    [
                        "I",
                        "enjoy",
                        "running"
                    ],
                    [
                        [
                            "swimming",
                            "running"
                        ]
                    ]
                ],
                [
                    [
                        "I",
                        "am",
                        "happy"
                    ],
                    [
                        "I",
                        "am",
                        "sad"
                    ],
                    [
                        [
                            "happy",
                            "sad"
                        ]
                    ]
                ],
                [
                    [
                        "I",
                        "love",
                        "chocolate"
                    ],
                    [
                        "I",
                        "love",
                        "ice cream"
                    ],
                    [
                        [
                            "chocolate",
                            "ice cream"
                        ]
                    ]
                ],
                [
                    [
                        "I",
                        "like",
                        "to",
                        "read"
                    ],
                    [
                        "I",
                        "like",
                        "to",
                        "write"
                    ],
                    [
                        [
                            "read",
                            "write"
                        ]
                    ]
                ],
                [
                    [
                        "I",
                        "am",
                        "excited"
                    ],
                    [
                        "I",
                        "am",
                        "nervous"
                    ],
                    [
                        [
                            "excited",
                            "nervous"
                        ]
                    ]
                ]
            ],
            "outputs": [
                true,
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nbool areSentencesSimilar(vector<string>& sentence1, vector<string>& sentence2, vector<vector<string>>& similarPairs) {\n    if (sentence1.size() != sentence2.size()) return false;\n    unordered_map<string, unordered_set<string>> similarityMap;\n    for (const auto& pair : similarPairs) {\n        similarityMap[pair[0]].insert(pair[1]);\n        similarityMap[pair[1]].insert(pair[0]);\n    }\n    for (int i = 0; i < sentence1.size(); ++i) {\n        if (sentence1[i] != sentence2[i] && !similarityMap[sentence1[i]].count(sentence2[i]))\n            return false;\n    }\n    return true;\n}\n\n",
            "java": "import java.util.*;\n\npublic boolean areSentencesSimilar(String[] sentence1, String[] sentence2, List<List<String>> similarPairs) {\n    if (sentence1.length != sentence2.length) return false;\n    Map<String, Set<String>> similarityMap = new HashMap<>();\n    for (List<String> pair : similarPairs) {\n        similarityMap.putIfAbsent(pair.get(0), new HashSet<>());\n        similarityMap.putIfAbsent(pair.get(1), new HashSet<>());\n        similarityMap.get(pair.get(0)).add(pair.get(1));\n        similarityMap.get(pair.get(1)).add(pair.get(0));\n    }\n    for (int i = 0; i < sentence1.length; ++i) {\n        if (!sentence1[i].equals(sentence2[i]) && !similarityMap.getOrDefault(sentence1[i], Collections.emptySet()).contains(sentence2[i]))\n            return false;\n    }\n    return true;\n}\n\n",
            "python": "from collections import defaultdict\n\ndef areSentencesSimilar(sentence1, sentence2, similarPairs):\n    if len(sentence1) != len(sentence2): return False\n    similarityMap = defaultdict(set)\n    for pair in similarPairs:\n        similarityMap[pair[0]].add(pair[1])\n        similarityMap[pair[1]].add(pair[0])\n    for i in range(len(sentence1)):\n        if sentence1[i] != sentence2[i] and sentence2[i] not in similarityMap[sentence1[i]]:\n            return False\n    return True\n\n",
            "javascript": "function areSentencesSimilar(sentence1, sentence2, similarPairs) {\n    if (sentence1.length !== sentence2.length) return false;\n    const similarityMap = new Map();\n    for (const pair of similarPairs) {\n        if (!similarityMap.has(pair[0])) similarityMap.set(pair[0], new Set());\n        if (!similarityMap.has(pair[1])) similarityMap.set(pair[1], new Set());\n        similarityMap.get(pair[0]).add(pair[1]);\n        similarityMap.get(pair[1]).add(pair[0]);\n    }\n    for (let i = 0; i < sentence1.length; ++i) {\n        if (sentence1[i] !== sentence2[i] && !similarityMap.get(sentence1[i])?.has(sentence2[i]))\n            return false;\n    }\n    return true;\n}\n\n",
            "explanation": "1. If the lengths of the given sentences are unequal, the sentences cannot be similar, hence return false.\n2. Create a mapping from each word in similarPairs to its set of similar words.\n3. Iterate over each word in both sentences and check whether they are similar. If not, return false.\n4. If all words in sentence1 are similar to words at same indices in sentence2, return true."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nbool areSentencesSimilar(vector<string>& sentence1, vector<string>& sentence2, vector<vector<string>>& similarPairs) \n    // Your code here\n}\n\n",
            "java": "import java.util.*;\n\npublic boolean areSentencesSimilar(String[] sentence1, String[] sentence2, List<List<String>> similarPairs) \n    // Your code here\n}\n\n",
            "python": "from collections import defaultdict\n    # Your code here\n\n",
            "javascript": "function areSentencesSimilar(sentence1, sentence2, similarPairs) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n    vector<string> sentence1 = $args;\n    vector<string> sentence2 = $args;\n    vector<vector<string>> similarPairs = $args;\n    bool result = areSentencesSimilar(sentence1, sentence2, similarPairs);\n    cout << boolalpha << result << endl;\n    return 0;\n}\n",
            "java": "public boolean areSentencesSimilar(String[] sentence1, String[] sentence2, List<List<String>> similarPairs) {\n    if (sentence1.length != sentence2.length) return false;\n    Map<String, Set<String>> similarityMap = new HashMap<>();\n    for (List<String> pair : similarPairs) {\n        similarityMap.putIfAbsent(pair.get(0), new HashSet<>());\n        similarityMap.putIfAbsent(pair.get(1), new HashSet<>());\n        similarityMap.get(pair.get(0)).add(pair.get(1));\n        similarityMap.get(pair.get(1)).add(pair.get(0));\n    }\n    for (int i = 0; i < sentence1.length; ++i) {\n        if (!sentence1[i].equals(sentence2[i]) && !similarityMap.getOrDefault(sentence1[i], Collections.emptySet()).contains(sentence2[i]))\n            return false;\n    }\n    return true;\n}",
            "python": "if __name__ == \"__main__\":\n    sentence1 = $args[0]\n    sentence2 = $args[1]\n    similarPairs = $args[2]\n    result = areSentencesSimilar(sentence1, sentence2, similarPairs)\n    print(result)",
            "javascript": "function main() {\n    const sentence1 = $args[0];\n    const sentence2 = $args[1];\n    const similarPairs = $args[2];\n    const result = areSentencesSimilar(sentence1, sentence2, similarPairs);\n    console.log(result);\n}"
        }
    },
    "735": {
        "title": "Asteroid Collision",
        "description": "We are given an array `asteroids` of integers representing asteroids in a row. For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed. Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.",
        "example": "Example:\n\nInput: asteroids = [5,10,-5]\nOutput: [5,10]\nExplanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.",
        "level": "Medium",
        "tags": [
            "array",
            "collision"
        ],
        "test_cases": {
            "inputs": [
                [
                    5,
                    10,
                    -5
                ],
                [
                    8,
                    -8
                ],
                [
                    10,
                    2,
                    -5
                ],
                [
                    1,
                    -1,
                    2,
                    -2
                ],
                [
                    3,
                    4,
                    5,
                    -5,
                    -4,
                    -3
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    -2,
                    -3,
                    -4,
                    -5
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    -1,
                    -1,
                    -1,
                    -1,
                    -1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    -6,
                    -7,
                    -8,
                    -9,
                    -10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    -6,
                    -7,
                    -8,
                    -9,
                    -10,
                    11,
                    12,
                    13,
                    14,
                    15
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    -6,
                    -7,
                    -8,
                    -9,
                    -10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    -11,
                    -12,
                    -13,
                    -14,
                    -15
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    -6,
                    -7,
                    -8,
                    -9,
                    -10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    -11,
                    -12,
                    -13,
                    -14,
                    -15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    -6,
                    -7,
                    -8,
                    -9,
                    -10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    -11,
                    -12,
                    -13,
                    -14,
                    -15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    -16,
                    -17,
                    -18,
                    -19,
                    -20
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    -6,
                    -7,
                    -8,
                    -9,
                    -10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    -11,
                    -12,
                    -13,
                    -14,
                    -15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    -16,
                    -17,
                    -18,
                    -19,
                    -20,
                    21,
                    22,
                    23,
                    24,
                    25
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    -6,
                    -7,
                    -8,
                    -9,
                    -10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    -11,
                    -12,
                    -13,
                    -14,
                    -15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    -16,
                    -17,
                    -18,
                    -19,
                    -20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    -21,
                    -22,
                    -23,
                    -24,
                    -25
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    -6,
                    -7,
                    -8,
                    -9,
                    -10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    -11,
                    -12,
                    -13,
                    -14,
                    -15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    -16,
                    -17,
                    -18,
                    -19,
                    -20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    -21,
                    -22,
                    -23,
                    -24,
                    -25,
                    26,
                    27,
                    28,
                    29,
                    30
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    -6,
                    -7,
                    -8,
                    -9,
                    -10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    -11,
                    -12,
                    -13,
                    -14,
                    -15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    -16,
                    -17,
                    -18,
                    -19,
                    -20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    -21,
                    -22,
                    -23,
                    -24,
                    -25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    -26,
                    -27,
                    -28,
                    -29,
                    -30
                ]
            ],
            "outputs": [
                "[5,10]",
                "[]",
                "[10]",
                "[]",
                "[3,4,5]",
                "[1,2,3,4,5]",
                "[]",
                "[1,2,3,4,5]",
                "[1,1,1,1,1]",
                "[]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]",
                "[]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]",
                "[]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]",
                "[]",
                "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]",
                "[]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> asteroidCollision(vector<int>& asteroids) {\n    vector<int> s;\n    for (int i = 0; i < asteroids.size(); i++) {\n        if (asteroids[i] > 0 || s.empty() || s.back() < 0) {\n            s.push_back(asteroids[i]);\n        } else if (s.back() <= -asteroids[i]) {\n            if (s.back() < -asteroids[i]) i--;\n            s.pop_back();\n        }\n    }\n    return s;\n}\n\n",
            "java": "import java.util.*;\nclass Solution {\n    public int[] asteroidCollision(int[] asteroids) {\n        Stack<Integer> s = new Stack<>();\n        for (int i = 0; i < asteroids.length; i++) {\n            if (asteroids[i] > 0 || s.isEmpty() || s.peek() < 0) {\n                s.push(asteroids[i]);\n            } else if (s.peek() <= -asteroids[i]) {\n                if (s.peek() < -asteroids[i]) i--;\n                s.pop();\n            }\n        }\n        int[] ans = new int[s.size()];\n        for (int i = ans.length - 1; i >= 0; i--) {\n            ans[i] = s.pop();\n        }\n        return ans;\n    }\n}\n\n",
            "python": "def asteroidCollision(asteroids):\n    s = []\n    for num in asteroids:\n        if num > 0 or not s or s[-1] < 0:\n            s.append(num)\n        elif s[-1] <= -num:\n            if s[-1] < -num:\n                s.pop()\n                s.append(num)\n            else:\n                s.pop()\n    return s\n\n",
            "javascript": "function asteroidCollision(asteroids) {\n    const s = [];\n    for (let i = 0; i < asteroids.length; i++) {\n        if (asteroids[i] > 0 || !s.length || s[s.length - 1] < 0) {\n            s.push(asteroids[i]);\n        } else if (s[s.length - 1] <= -asteroids[i]) {\n            if (s[s.length - 1] < -asteroids[i]) i--;\n            s.pop();\n        }\n    }\n    return s;\n}\n\n",
            "explanation": "The algorithm uses a stack data structure to track the asteroids. For each asteroid, if it is moving to the right, or if the stack is empty, or if the top of the stack has an asteroid with a negative value (moving left), then we can simply push the current asteroid onto the stack.\n\nIf the top of the stack has an asteroid with a positive value and the current asteroid has a negative value (meaning they will collide), compare their absolute values. If the top of the stack has a smaller value, decrement the iterator and pop the stack, so that the current asteroid will be considered again. If both have the same value, simply pop the stack without decrementing the iterator. Otherwise, if the top of the stack has a larger value, ignore the current asteroid, and proceed to the next asteroid.\n\nThe final stack will have the remaining asteroids after all the collisions. In the case of Java, the stack is converted to an array before returning the result."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> asteroidCollision(vector<int>& asteroids) \n    // Your code here\n}\n\n",
            "java": "import java.util.*;\nclass Solution \n    // Your code here\n}\n\n",
            "python": "def asteroidCollision(asteroids):\n    # Your code here\n\n",
            "javascript": "function asteroidCollision(asteroids) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nint main() {\n    vector<int> asteroids = $args;\n    vector<int> result = asteroidCollision(asteroids);\n    for (int i = 0; i < result.size(); i++) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n",
            "java": "public int[] asteroidCollision(int[] asteroids) {\n        Stack<Integer> s = new Stack<>();\n        for (int i = 0; i < asteroids.length; i++) {\n            if (asteroids[i] > 0 || s.isEmpty() || s.peek() < 0) {\n                s.push(asteroids[i]);\n            } else if (s.peek() <= -asteroids[i]) {\n                if (s.peek() < -asteroids[i]) i--;\n                s.pop();\n            }\n        }\n        int[] ans = new int[s.size()];\n        for (int i = ans.length - 1; i >= 0; i--) {\n            ans[i] = s.pop();\n        }\n        return ans;\n    }",
            "python": "if __name__ == \"__main__\":\n    asteroids = $args[0]\n    result = asteroidCollision(asteroids)\n    print(result)",
            "javascript": "function main() {\n    const asteroids = $args;\n    const result = asteroidCollision(asteroids);\n    console.log(result);\n}\n"
        }
    },
    "736": {
        "title": "Evaluate Lisp-like Expression",
        "description": "You are given a string expression representing a Lisp-like expression. Your task is to evaluate the expression and return the integer value of it. The expression can be an integer, let expression, add expression, mult expression, or an assigned variable. Expressions always evaluate to a single integer. The let expression assigns values to variables and evaluates an expression. The add expression performs addition of two expressions. The mult expression performs multiplication of two expressions. The evaluation of variable values follows the concept of scope, where the innermost scope is checked first for the value of a variable. It is guaranteed that every expression is legal.",
        "example": "Example:\n\nInput: \"(let x 2 (mult x (let x 3 y 4 (add x y))))\"\nOutput: 14\nExplanation: In the expression (add x y), when checking for the value of the variable x, we check from the innermost scope to the outermost. Since x = 3 is found first, the value of x is 3.",
        "level": "Medium",
        "tags": [
            "expression",
            "evaluation",
            "scope"
        ],
        "test_cases": {
            "inputs": [
                "\"(let x 2 (mult x (let x 3 y 4 (add x y))))\"",
                "\"(let x 3 x 2 x)\"",
                "\"(let x 1 y 2 x (add x y) (add x y))\"",
                "\"(let x 5 y 10 (mult x y))\"",
                "\"(let x 5 y 10 (add (mult x y) (let z 2 (mult x z))))\"",
                "\"(let x 5 y 10 (mult x (add y (let z 2 (mult x z))))))\"",
                "\"(let x 5 y 10 (mult x (add y (let z 2 (mult x z))))))\"",
                "\"(let x 5 y 10 (mult x (add y (let z 2 (mult x z))))))\"",
                "\"(let x 5 y 10 (mult x (add y (let z 2 (mult x z))))))\"",
                "\"(let x 5 y 10 (mult x (add y (let z 2 (mult x z))))))\"",
                "\"(let x 5 y 10 (mult x (add y (let z 2 (mult x z))))))\"",
                "\"(let x 5 y 10 (mult x (add y (let z 2 (mult x z))))))\"",
                "\"(let x 5 y 10 (mult x (add y (let z 2 (mult x z))))))\"",
                "\"(let x 5 y 10 (mult x (add y (let z 2 (mult x z))))))\"",
                "\"(let x 5 y 10 (mult x (add y (let z 2 (mult x z))))))\"",
                "\"(let x 5 y 10 (mult x (add y (let z 2 (mult x z))))))\"",
                "\"(let x 5 y 10 (mult x (add y (let z 2 (mult x z))))))\"",
                "\"(let x 5 y 10 (mult x (add y (let z 2 (mult x z))))))\"",
                "\"(let x 5 y 10 (mult x (add y (let z 2 (mult x z))))))\"",
                "\"(let x 5 y 10 (mult x (add y (let z 2 (mult x z))))))\""
            ],
            "outputs": [
                "14",
                "2",
                "5",
                "50",
                "105",
                "315",
                "315",
                "315",
                "315",
                "315",
                "315",
                "315",
                "315",
                "315",
                "315",
                "315",
                "315",
                "315",
                "315",
                "315"
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint calculate(string &expression, const int &start, int &end, unordered_map<string, int> &variables) {\n    if (expression[start] == '(') {\n        if (expression.substr(start + 1, 3) == \"add\") {\n            int first = start + 5;\n            int second = first;\n            calculate(expression, first, second, variables);\n            int value1 = variables[\" \"];\n            calculate(expression, second + 1, end, variables);\n            int value2 = variables[\" \"];\n            end++;\n            return value1 + value2;\n        } else if (expression.substr(start + 1, 4) == \"mult\") {\n            int first = start + 6;\n            int second = first;\n            calculate(expression, first, second, variables);\n            int value1 = variables[\" \"];\n            calculate(expression, second + 1, end, variables);\n            int value2 = variables[\" \"];\n            end++;\n            return value1 * value2;\n        } else {\n            unordered_map<string, int> inner = unordered_map<string, int>(variables);\n            int idx = start + 5;\n            while (idx < end - 1 && expression[idx] != '(') {\n                int temp = idx;\n                idx = expression.find(' ', idx + 1);\n                string var = expression.substr(temp, idx - temp);\n                temp = idx + 1;\n                if (expression[temp] == '(') {\n                    idx++;\n                } else {\n                    idx = expression.find(' ', idx + 1);\n                }\n                int result = calculate(expression, temp, idx, variables);\n                inner[var] = result;\n                variables = inner;\n            }\n            return calculate(expression, idx, end, variables);\n        }\n    } else {\n        if (isdigit(expression[start]) || expression[start] == '-') {\n            end = expression.find(' ', start);\n            return stoi(expression.substr(start, end - start));\n        } else {\n            int idx = expression.find(' ', start);\n            end = (idx == -1) ? end : idx;\n            return variables[expression.substr(start, end - start)];\n        }\n    }\n}\n\nint evaluate(string expression) {\n    int end = expression.size();\n    unordered_map<string, int> variables;\n    int result = calculate(expression, 0, end, variables);\n    return result;\n}\n",
            "java": "import java.util.HashMap;\n\npublic class Solution {\n    public int evaluate(String expression) {\n        return calculate(expression, 0, expression.length(), new HashMap<>());\n    }\n\n    private int calculate(String expression, int start, int end, HashMap<String, Integer> variables) {\n        if (expression.charAt(start) == '(') {\n            if (expression.startsWith(\"add\", start + 1)) {\n                int first = start + 5;\n                int[] second = new int[]{first};\n                int value1 = calculate(expression, first, end, variables, second);\n                int value2 = calculate(expression, second[0] + 1, end, variables, null);\n                return value1 + value2;\n            } else if (expression.startsWith(\"mult\", start + 1)) {\n                int first = start + 6;\n                int[] second = new int[]{first};\n                int value1 = calculate(expression, first, end, variables, second);\n                int value2 = calculate(expression, second[0] + 1, end, variables, null);\n                return value1 * value2;\n            } else {\n                HashMap<String, Integer> inner = variables;\n                for (int idx = start + 5; idx < end - 1 && expression.charAt(idx) != '('; ) {\n                    int temp = idx;\n                    idx = expression.indexOf(' ', idx + 1);\n                    String var = expression.substring(temp, idx);\n                    temp = idx + 1;\n                    if (expression.charAt(temp) == '(') {\n                        idx++;\n                    } else {\n                        idx = expression.indexOf(' ', idx + 1);\n                    }\n                    int result = calculate(expression, temp, idx, variables, null);\n                    inner = new HashMap<>(variables);\n                    inner.put(var, result);\n                }\n                return calculate(expression, end - 1, end, inner, null);\n            }\n        } else {\n            if (Character.isDigit(expression.charAt(start)) || expression.charAt(start) == '-') {\n                end = expression.indexOf(' ', start);\n                if (end == -1) {\n                    end = expression.length();\n                }\n                return Integer.parseInt(expression.substring(start, end));\n            } else {\n                end = expression.indexOf(' ', start);\n                if (end == -1) {\n                    end = expression.length();\n                }\n                return variables.get(expression.substring(start, end));\n            }\n        }\n    }\n\n    private int calculate(String expression, int start, int end, HashMap<String, Integer> variables, int[] nextStart) {\n        int temp = end;\n        int result = calculate(expression, start, end, variables);\n        if (nextStart != null) {\n            nextStart[0] = temp;\n        }\n        return result;\n    }\n}\n",
            "python": "def evaluate(expression: str) -> int:\n    def calculate(s, start, end, variables):\n        if s[start] == '(':\n            if s[start + 1:start + 4] == \"add\":\n                first = start + 5\n                second = first\n                value1 = calculate(s, first, end, variables)\n                second = s.index(' ', second) + 1\n                value2 = calculate(s, second, end, variables)\n                return value1 + value2\n            elif s[start + 1:start + 5] == \"mult\":\n                first = start + 6\n                second = first\n                value1 = calculate(s, first, end, variables)\n                second = s.index(' ', second) + 1\n                value2 = calculate(s, second, end, variables)\n                return value1 * value2\n            else:\n                inner = variables.copy()\n                idx = start + 5\n                while idx < end - 1 and s[idx] != '(':\n                    temp = idx\n                    idx = s.index(' ', idx + 1)\n                    var = s[temp:idx]\n                    temp = idx + 1\n                    if s[temp] == '(':\n                        idx += 1\n                    else:\n                        idx = s.index(' ', idx + 1)\n                    result = calculate(s, temp, idx, variables)\n                    inner[var] = result\n                    variables = inner\n                return calculate(s, end - 1, end, variables)\n        else:\n            if s[start].isdigit() or s[start] == '-':\n                end = s.find(' ', start) if ' ' in s[start:end] else end\n                return int(s[start:end])\n            else:\n                end = s.find(' ', start) if ' ' in s[start:end] else end\n                return variables[s[start:end]]\n\n    return calculate(expression, 0, len(expression), {})\n",
            "javascript": "function evaluate(expression) {\n    function calculate(s, start, end, variables) {\n        if (s[start] === '(') {\n            if (s.substr(start + 1, 3) === \"add\") {\n                let first = start + 5;\n                let second = first;\n                let value1 = calculate(s, first, end, variables);\n                second = s.indexOf(' ', second) + 1;\n                let value2 = calculate(s, second, end, variables);\n                return value1 + value2;\n            } else if (s.substr(start + 1, 4) === \"mult\") {\n                let first = start + 6;\n                let second = first;\n                let value1 = calculate(s, first, end, variables);\n                second = s.indexOf(' ', second) + 1;\n                let value2 = calculate(s, second, end, variables);\n                return value1 * value2;\n            } else {\n                let inner = new Map(variables);\n                let idx = start + 5;\n                while (idx < end - 1 && s[idx] !== '(') {\n                    let temp = idx;\n                    idx = s.indexOf(' ', idx + 1);\n                    let varName = s.substring(temp, idx);\n                    temp = idx + 1;\n                    if (s[temp] === '(') {\n                        idx++;\n                    } else {\n                        idx = s.indexOf(' ', idx + 1);\n                    }\n                    let result = calculate(s, temp, idx, variables);\n                    inner.set(varName, result);\n                    variables = inner;\n                }\n                return calculate(s, end - 1, end, variables);\n            }\n        } else {\n            if (s[start] === '-' || !isNaN(s[start])) {\n                let idx = s.indexOf(' ', start);\n                end = idx === -1 ? end : idx;\n                return parseInt(s.substring(start, end));\n            } else {\n                let idx = s.indexOf(' ', start);\n                end = idx === -1 ? end : idx;\n                return variables.get(s.substring(start, end));\n            }\n        }\n    }\n\n    return calculate(expression, 0, expression.length, new Map());\n}\n",
            "explanation": "First, we have the helper function `calculate`. It starts by checking if the expression starts with an opening parenthesis `(`. If so, it checks if it is an \"add\" or \"mult\" expression. If it's an \"add\" expression, it calculates the values of the two expressions inside it and returns their sum. If it's a \"mult\" expression, it calculates the values of the two expressions inside it and returns their multiplication.\n\nIf the expression starts with a \"let\" command, it creates a new `variables` Map (or dict/hashmap depending on the language) for the inner scope, which is a copy of the outer scope. It iterates through the string processing variable assignments sequentially, adding the variable and its value to the inner scope's `variables` Map. Once it reaches the final expression, it calls the `calculate` function again with this expression.\n\nIf the expression doesn't start with a parenthesis, it checks if it is a number or a variable. If it's a number, it returns the number parsed as an integer. If it's a variable, it returns the value of the variable from the `variables` Map.\n\nThe `evaluate` function is the entry point, which calls the `calculate` function with the entire expression string and an empty `variables` Map initially."
        },
        "structure": {
            "c++": "#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint calculate(string &expression, const int &start, int &end, unordered_map<string, int> &variables) \n    // Your code here\n}\n",
            "java": "import java.util.HashMap;\n\npublic class Solution \n    // Your code here\n}\n",
            "python": "def evaluate(expression: str) -> int:\n    # Your code here\n\n",
            "javascript": "function evaluate(expression) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int evaluate(string expression) {\n    int end = expression.size();\n    unordered_map<string, int> variables;\n    int result = calculate(expression, 0, end, variables);\n    return result;\n}",
            "java": "public int evaluate(String expression) {\n        return calculate(expression, 0, expression.length(), new HashMap<>());\n    }\n\n    private int calculate(String expression, int start, int end, HashMap<String, Integer> variables) {\n        // code logic\n    }\n\n    private int calculate(String expression, int start, int end, HashMap<String, Integer> variables, int[] nextStart) {\n        // code logic\n    }",
            "python": "if __name__ == \"__main__\":\n    expression = $args[0]\n    result = evaluate(expression)\n    print(result)",
            "javascript": "function evaluate(expression) {\n    function calculate(s, start, end, variables) {\n        if (s[start] === '(') {\n            if (s.substr(start + 1, 3) === \"add\") {\n                let first = start + 5;\n                let second = first;\n                let value1 = calculate(s, first, end, variables);\n                second = s.indexOf(' ', second) + 1;\n                let value2 = calculate(s, second, end, variables);\n                return value1 + value2;\n            } else if (s.substr(start + 1, 4) === \"mult\") {\n                let first = start + 6;\n                let second = first;\n                let value1 = calculate(s, first, end, variables);\n                second = s.indexOf(' ', second) + 1;\n                let value2 = calculate(s, second, end, variables);\n                return value1 * value2;\n            } else {\n                let inner = new Map(variables);\n                let idx = start + 5;\n                while (idx < end - 1 && s[idx] !== '(') {\n                    let temp = idx;\n                    idx = s.indexOf(' ', idx + 1);\n                    let varName = s.substring(temp, idx);\n                    temp = idx + 1;\n                    if (s[temp] === '(') {\n                        idx++;\n                    } else {\n                        idx = s.indexOf(' ', idx + 1);\n                    }\n                    let result = calculate(s, temp, idx, variables);\n                    inner.set(varName, result);\n                    variables = inner;\n                }\n                return calculate(s, end - 1, end, variables);\n            }\n        } else {\n            if (s[start] === '-' || !isNaN(s[start])) {\n                let idx = s.indexOf(' ', start);\n                end = idx === -1 ? end : idx;\n                return parseInt(s.substring(start, end));\n            } else {\n                let idx = s.indexOf(' ', start);\n                end = idx === -1 ? end : idx;\n                return variables.get(s.substring(start, end));\n            }\n        }\n    }\n\n    return calculate(expression, 0, expression.length, new Map());\n}"
        }
    },
    "737": {
        "title": "Similar Sentences",
        "description": "Given two sentences `sentence1` and `sentence2` represented as string arrays, and an array of string pairs `similarPairs`, determine if `sentence1` and `sentence2` are similar. Two sentences are considered similar if they have the same length and each word at index `i` in `sentence1` is similar to the corresponding word at index `i` in `sentence2`. The similarity relation is transitive, meaning if `a` is similar to `b` and `b` is similar to `c`, then `a` is similar to `c`. A word is always similar to itself.",
        "example": "For example, given:\n\nsentence1 = [\"great\", \"acting\", \"skills\"]\nsentence2 = [\"fine\", \"drama\", \"talent\"]\nsimilarPairs = [[\"great\", \"good\"], [\"fine\", \"good\"], [\"drama\", \"acting\"], [\"skills\", \"talent\"]]\n\nThe output would be `true` since the two sentences have the same length and each word in `sentence1` is similar to the corresponding word in `sentence2`.\n\nTo illustrate further, given:\n\nsentence1 = [\"I\", \"love\", \"leetcode\"]\nsentence2 = [\"I\", \"love\", \"onepiece\"]\nsimilarPairs = [[\"manga\", \"onepiece\"], [\"platform\", \"anime\"], [\"leetcode\", \"platform\"], [\"anime\", \"manga\"]]\n\nThe output would be `true` since `leetcode` is similar to `onepiece` and the first two words are the same.",
        "level": "Easy",
        "tags": [
            "array",
            "string"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "great",
                        "acting",
                        "skills"
                    ],
                    [
                        "fine",
                        "drama",
                        "talent"
                    ],
                    [
                        [
                            "great",
                            "good"
                        ],
                        [
                            "fine",
                            "good"
                        ],
                        [
                            "drama",
                            "acting"
                        ],
                        [
                            "skills",
                            "talent"
                        ]
                    ]
                ],
                [
                    [
                        "I",
                        "love",
                        "leetcode"
                    ],
                    [
                        "I",
                        "love",
                        "onepiece"
                    ],
                    [
                        [
                            "manga",
                            "onepiece"
                        ],
                        [
                            "platform",
                            "anime"
                        ],
                        [
                            "leetcode",
                            "platform"
                        ],
                        [
                            "anime",
                            "manga"
                        ]
                    ]
                ],
                [
                    [
                        "I",
                        "love",
                        "leetcode"
                    ],
                    [
                        "I",
                        "love",
                        "onepiece"
                    ],
                    [
                        [
                            "manga",
                            "hunterXhunter"
                        ],
                        [
                            "platform",
                            "anime"
                        ],
                        [
                            "leetcode",
                            "platform"
                        ],
                        [
                            "anime",
                            "manga"
                        ]
                    ]
                ]
            ],
            "outputs": [
                true,
                true,
                false
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <unordered_map>\n#include <string>\n\nbool areSentencesSimilar(std::vector<std::string>& sentence1, std::vector<std::string>& sentence2, std::vector<std::vector<std::string>>& pairs) {\n    if (sentence1.size() != sentence2.size()) return false;\n\n    std::unordered_map<std::string, std::unordered_set<std::string>> graph;\n    for (const auto& p : pairs) {\n        graph[p[0]].insert(p[1]);\n        graph[p[1]].insert(p[0]);\n    }\n    \n    for (int i = 0; i < sentence1.size(); ++i) {\n        if (sentence1[i] == sentence2[i]) continue;\n        if (graph[sentence1[i]].find(sentence2[i]) == graph[sentence1[i]].end()) return false;\n    }\n    return true;\n}\n",
            "java": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic boolean areSentencesSimilar(String[] sentence1, String[] sentence2, List<List<String>> pairs) {\n    if (sentence1.length != sentence2.length) return false;\n    \n    Map<String, Set<String>> graph = new HashMap<>();\n    for (List<String> p : pairs) {\n        graph.putIfAbsent(p.get(0), new HashSet<>());\n        graph.putIfAbsent(p.get(1), new HashSet<>());\n        graph.get(p.get(0)).add(p.get(1));\n        graph.get(p.get(1)).add(p.get(0));\n    }\n    \n    for (int i = 0; i < sentence1.length; ++i) {\n        if (sentence1[i].equals(sentence2[i])) continue;\n        if (!graph.getOrDefault(sentence1[i], new HashSet<>()).contains(sentence2[i])) return false;\n    }\n    return true;\n}\n",
            "python": "from collections import defaultdict\n\ndef areSentencesSimilar(sentence1, sentence2, pairs):\n    if len(sentence1) != len(sentence2):\n        return False\n    \n    graph = defaultdict(set)\n    for a, b in pairs:\n        graph[a].add(b)\n        graph[b].add(a)\n\n    for a, b in zip(sentence1, sentence2):\n        if a == b:\n            continue\n        if b not in graph[a]:\n            return False\n\n    return True\n",
            "javascript": "function areSentencesSimilar(sentence1, sentence2, pairs) {\n    if (sentence1.length !== sentence2.length) return false;\n    \n    const graph = new Map();\n    for (const [a, b] of pairs) {\n        if (!graph.has(a)) graph.set(a, new Set());\n        if (!graph.has(b)) graph.set(b, new Set());\n        \n        graph.get(a).add(b);\n        graph.get(b).add(a);\n    }\n    \n    for (let i = 0; i < sentence1.length; ++i) {\n        if (sentence1[i] === sentence2[i]) continue;\n\n        const neighbors = graph.get(sentence1[i]);\n        if (!neighbors || !neighbors.has(sentence2[i])) return false;\n    }\n    \n    return true;\n}\n",
            "explanation": "We start by checking if sentence1 and sentence2 have the same length, otherwise, they cannot be similar. Then, create a graph using an adjacency list to represent the similarity pairs. Iterate through sentence1 and sentence2 in parallel, compare each pair of words exactly in the same position in both sentences. If a pair of words is equal, they are already similar, so we continue with the next pair. If not, we look for the word from sentence2 in the adjacency list for the word from sentence1. If we find it, they are similar; if not, the sentences are not similar. If all pairs are marked as similar, we return `True`, otherwise `False`."
        },
        "structure": {
            "c++": "#include <vector>\n#include <unordered_map>\n#include <string>\n\nbool areSentencesSimilar(std::vector<std::string>& sentence1, std::vector<std::string>& sentence2, std::vector<std::vector<std::string>>& pairs) \n    // Your code here\n}\n",
            "java": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic boolean areSentencesSimilar(String[] sentence1, String[] sentence2, List<List<String>> pairs) \n    // Your code here\n}\n",
            "python": "from collections import defaultdict\n    # Your code here\n\n",
            "javascript": "function areSentencesSimilar(sentence1, sentence2, pairs) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <unordered_map>\n#include <string>\n#include <iostream>\n\nint main() {\n    std::vector<std::string> sentence1 = $args;\n    std::vector<std::string> sentence2 = $args;\n    std::vector<std::vector<std::string>> pairs = $args;\n    bool result = areSentencesSimilar(sentence1, sentence2, pairs);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}\n",
            "java": "public boolean areSentencesSimilar(String[] sentence1, String[] sentence2, List<List<String>> pairs) {\n    if (sentence1.length != sentence2.length) return false;\n    \n    Map<String, Set<String>> graph = new HashMap<>();\n    for (List<String> p : pairs) {\n        graph.putIfAbsent(p.get(0), new HashSet<>());\n        graph.putIfAbsent(p.get(1), new HashSet<>());\n        graph.get(p.get(0)).add(p.get(1));\n        graph.get(p.get(1)).add(p.get(0));\n    }\n    \n    for (int i = 0; i < sentence1.length; ++i) {\n        if (sentence1[i].equals(sentence2[i])) continue;\n        if (!graph.getOrDefault(sentence1[i], new HashSet<>()).contains(sentence2[i])) return false;\n    }\n    return true;\n}",
            "python": "if __name__ == \"__main__\":\n    sentence1 = $args[0]\n    sentence2 = $args[1]\n    pairs = $args[2]\n    result = areSentencesSimilar(sentence1, sentence2, pairs)\n    print(result)",
            "javascript": "function areSentencesSimilar(sentence1, sentence2, pairs) {\n    if (sentence1.length !== sentence2.length) return false;\n    \n    const graph = new Map();\n    for (const [a, b] of pairs) {\n        if (!graph.has(a)) graph.set(a, new Set());\n        if (!graph.has(b)) graph.set(b, new Set());\n        \n        graph.get(a).add(b);\n        graph.get(b).add(a);\n    }\n    \n    for (let i = 0; i < sentence1.length; ++i) {\n        if (sentence1[i] === sentence2[i]) continue;\n\n        const neighbors = graph.get(sentence1[i]);\n        if (!neighbors || !neighbors.has(sentence2[i])) return false;\n    }\n    \n    return true;\n}"
        }
    },
    "738": {
        "title": "Monotone Increasing Digits",
        "description": "Given an integer `n`, find the largest number that is less than or equal to `n` with monotone increasing digits. An integer has monotone increasing digits if and only if each pair of adjacent digits `x` and `y` satisfy `x <= y`.",
        "example": "Example:\n\nInput: n = 332\nOutput: 299\n\nExplanation: The largest number less than or equal to 332 with monotone increasing digits is 299.",
        "level": "Easy",
        "tags": [
            "Math",
            "Greedy"
        ],
        "test_cases": {
            "inputs": [
                10,
                1234,
                332,
                0,
                9876543210,
                111111,
                54321,
                100,
                999,
                123456789
            ],
            "outputs": [
                9,
                1234,
                299,
                0,
                9876543210,
                111111,
                54321,
                99,
                999,
                123456789
            ]
        },
        "sample_code": {
            "c++": "int monotoneIncreasingDigits(int n) {\n    string n_str = to_string(n);\n    int n_len = n_str.size();\n\n    int i = n_len - 1;\n    while (i > 0) {\n        if (n_str[i] < n_str[i - 1]) {\n            n_str[i - 1] -= 1;\n            for (int j = i; j < n_len; ++j) {\n                n_str[j] = '9';\n            }\n        }\n        --i;\n    }\n\n    return stoi(n_str);\n}\n",
            "java": "public int monotoneIncreasingDigits(int n) {\n    char[] n_str = String.valueOf(n).toCharArray();\n    int n_len = n_str.length;\n\n    int i = n_len - 1;\n    while (i > 0) {\n        if (n_str[i] < n_str[i - 1]) {\n            n_str[i - 1] -= 1;\n            for (int j = i; j < n_len; ++j) {\n                n_str[j] = '9';\n            }\n        }\n        --i;\n    }\n\n    return Integer.parseInt(new String(n_str));\n}\n",
            "python": "def monotoneIncreasingDigits(n: int) -> int:\n    n_str = [c for c in str(n)]\n\n    i = len(n_str) - 1\n    while i > 0:\n        if n_str[i] < n_str[i - 1]:\n            n_str[i - 1] = chr(ord(n_str[i - 1]) - 1)\n            for j in range(i, len(n_str)):\n                n_str[j] = '9'\n        i -= 1\n\n    return int(''.join(n_str))\n",
            "javascript": "function monotoneIncreasingDigits(n) {\n    let n_str = n.toString();\n    let n_len = n_str.length;\n\n    let i = n_len - 1;\n    while (i > 0) {\n        if (n_str.charAt(i) < n_str.charAt(i - 1)) {\n            n_str = n_str.slice(0, i-1) + String.fromCharCode(n_str.charCodeAt(i-1) - 1) + '9'.repeat(n_len - i);\n        }\n        --i;\n    }\n\n    return parseInt(n_str);\n}\n\n",
            "explanation": "1. Convert the input integer to a string for easier manipulation of individual digits, and get its length.\n2. Initialize counter `i` starting at the right-most digit and going left.\n3. If the current digit is less than the previous one, we decrement the previous digit by 1 as it must be less than or equal, then set all digits to the right of the modified digit to 9 (so that the number remains the largest possible).\n4. Continue with step 3 until every previous digit has been checked, adjusting digits as needed.\n5. Convert the string of digits back to an integer and return it."
        },
        "structure": {
            "c++": "int monotoneIncreasingDigits(int n) \n    // Your code here\n}\n",
            "java": "public int monotoneIncreasingDigits(int n) \n    // Your code here\n}\n",
            "python": "def monotoneIncreasingDigits(n: int) -> int:\n    # Your code here\n\n",
            "javascript": "function monotoneIncreasingDigits(n) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = monotoneIncreasingDigits(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int monotoneIncreasingDigits(int n) {\n    char[] n_str = String.valueOf(n).toCharArray();\n    int n_len = n_str.length;\n\n    int i = n_len - 1;\n    while (i > 0) {\n        if (n_str[i] < n_str[i - 1]) {\n            n_str[i - 1] -= 1;\n            for (int j = i; j < n_len; ++j) {\n                n_str[j] = '9';\n            }\n        }\n        --i;\n    }\n\n    return Integer.parseInt(new String(n_str));\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    result = monotoneIncreasingDigits(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = monotoneIncreasingDigits(n);\n    console.log(result);\n}"
        }
    },
    "739": {
        "title": "Waiting for Warmer Temperatures",
        "description": "Given an array of integers `temperatures` representing the daily temperatures, write a function `wait_for_warmer_temperatures(temperatures: List[int]) -> List[int]` that returns an array `answer` such that `answer[i]` is the number of days you have to wait after the `ith` day to get a warmer temperature. If there is no future day for which this is possible, keep `answer[i] == 0` instead.",
        "example": "Example:\n\nInput: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]\n\nExplanation: For the first day, the next day has a higher temperature, so the answer is 1. For the second day, the next day also has a higher temperature, so the answer is 1. For the third day, the next day with a higher temperature is 4 days away. For the fourth day, the next day with a higher temperature is 2 days away. For the fifth day, the next day with a higher temperature is 1 day away. For the sixth day, the next day with a higher temperature is 1 day away. For the seventh and eighth days, there is no future day with a higher temperature, so the answer is 0 for both.",
        "level": "Medium",
        "tags": [
            "array",
            "stack"
        ],
        "test_cases": {
            "inputs": [
                [
                    73,
                    74,
                    75,
                    71,
                    69,
                    72,
                    76,
                    73
                ],
                [
                    30,
                    40,
                    50,
                    60
                ],
                [
                    30,
                    60,
                    90
                ],
                [
                    100,
                    90,
                    80,
                    70,
                    60,
                    50,
                    40,
                    30
                ],
                [
                    30,
                    30,
                    30,
                    30,
                    30,
                    30,
                    30,
                    30
                ],
                [
                    80,
                    70,
                    60,
                    50,
                    40,
                    30,
                    20,
                    10
                ],
                [
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100
                ],
                [
                    30,
                    30,
                    30,
                    30,
                    30,
                    30,
                    30,
                    100
                ]
            ],
            "outputs": [
                "[1,1,4,2,1,1,0,0]",
                "[1,1,1,0]",
                "[1,1,0]",
                "[0,0,0,0,0,0,0,0]",
                "[0,0,0,0,0,0,0,0]",
                "[1,1,1,1,1,1,1,0]",
                "[1,1,1,1,1,1,1,0]",
                "[0,0,0,0,0,0,0,0]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <stack>\n\nstd::vector<int> dailyTemperatures(std::vector<int>& temperatures) {\n    std::vector<int> result(temperatures.size(), 0);\n    std::stack<int> stack;\n\n    for (size_t i = 0; i < temperatures.size(); ++i) {\n        while (!stack.empty() && temperatures[i] > temperatures[stack.top()]) {\n            int idx = stack.top();\n            stack.pop();\n            result[idx] = i - idx;\n        }\n        stack.push(i);\n    }\n\n    return result;\n}\n",
            "java": "import java.util.Stack;\n\npublic int[] dailyTemperatures(int[] temperatures) {\n    int[] result = new int[temperatures.length];\n    Stack<Integer> stack = new Stack<>();\n\n    for (int i = 0; i < temperatures.length; i++) {\n        while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {\n            int idx = stack.pop();\n            result[idx] = i - idx;\n        }\n        stack.push(i);\n    }\n\n    return result;\n}\n",
            "python": "def daily_temperatures(temperatures):\n    result = [0] * len(temperatures)\n    stack = []\n\n    for i, temp in enumerate(temperatures):\n        while stack and temp > temperatures[stack[-1]]:\n            idx = stack.pop()\n            result[idx] = i - idx\n        stack.append(i)\n\n    return result\n",
            "javascript": "function dailyTemperatures(temperatures) {\n    const result = new Array(temperatures.length).fill(0);\n    const stack = [];\n\n    for (let i = 0; i < temperatures.length; i++) {\n        while (stack.length > 0 && temperatures[i] > temperatures[stack[stack.length - 1]]) {\n            const idx = stack.pop();\n            result[idx] = i - idx;\n        }\n        stack.push(i);\n    }\n\n    return result;\n}\n",
            "explanation": "The algorithm uses a stack that stores indices of the temperatures array. We iterate through the temperatures checking if the current temperature is greater than the temperature at the top of the stack. If it is, we pop the stack, and update the result array with the difference of the current index and the popped index, which represents the number of days to wait.\n\nIf the current temperature is not greater than the top of the stack, or the stack is empty, we push the current index onto the stack.\n\nAt the end, any remaining indices in the stack represent days without a warmer day, and their values in the result array will remain as 0 (initialized earlier).\n\nThe time complexity of the algorithm is O(N), since each index will be pushed and popped only once throughout the entire loop."
        },
        "structure": {
            "c++": "#include <vector>\n#include <stack>\n\nstd::vector<int> dailyTemperatures(std::vector<int>& temperatures) \n    // Your code here\n}\n",
            "java": "import java.util.Stack;\n\npublic int[] dailyTemperatures(int[] temperatures) \n    // Your code here\n}\n",
            "python": "def daily_temperatures(temperatures):\n    # Your code here\n\n",
            "javascript": "function dailyTemperatures(temperatures) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <stack>\n\nstd::vector<int> dailyTemperatures(std::vector<int>& temperatures) {\n    std::vector<int> result(temperatures.size(), 0);\n    std::stack<int> stack;\n\n    for (size_t i = 0; i < temperatures.size(); ++i) {\n        while (!stack.empty() && temperatures[i] > temperatures[stack.top()]) {\n            int idx = stack.top();\n            stack.pop();\n            result[idx] = i - idx;\n        }\n        stack.push(i);\n    }\n\n    return result;\n}\n\nint main() {\n    std::vector<int> temperatures = $args;\n    std::vector<int> result = dailyTemperatures(temperatures);\n    for (int i : result) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}",
            "java": "public int[] dailyTemperatures(int[] temperatures) {\n    int[] result = new int[temperatures.length];\n    Stack<Integer> stack = new Stack<>();\n\n    for (int i = 0; i < temperatures.length; i++) {\n        while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {\n            int idx = stack.pop();\n            result[idx] = i - idx;\n        }\n        stack.push(i);\n    }\n\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    temperatures = $args[0]\n    result = daily_temperatures(temperatures)\n    print(result)",
            "javascript": "function main() {\n    const temperatures = $args;\n    const result = dailyTemperatures(temperatures);\n    console.log(result);\n}"
        }
    },
    "742": {
        "title": "Nearest Leaf Node in Binary Tree",
        "description": "Given the `root` of a binary tree where every node has a unique value and a target integer `k`, return the value of the nearest leaf node to the target `k` in the tree. Nearest to a leaf means the least number of edges traveled on the binary tree to reach any leaf of the tree. Also, a node is called a leaf if it has no children.",
        "example": "Example:\n\nInput: root = [1,3,2], k = 1\nOutput: 2\nExplanation: Either 2 or 3 is the nearest leaf node to the target of 1.",
        "level": "Medium",
        "tags": [
            "binary tree",
            "nearest leaf node"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        3,
                        2
                    ],
                    1
                ],
                [
                    [
                        1
                    ],
                    1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        null,
                        null,
                        null,
                        5,
                        null,
                        6
                    ],
                    2
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    8
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    11
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    0
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    -1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    100
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    999
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    1000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    1001
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    500
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    7
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    6
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    9
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    4
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    1
                ]
            ],
            "outputs": [
                2,
                1,
                3,
                5,
                8,
                10,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1
            ]
        },
        "sample_code": {
            "c++": "#include <algorithm>\n#include <cctype>\n\nstd::string toLowerCase(std::string s) {\n    std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n    return s;\n}\n",
            "java": "public String toLowerCase(String s) {\n    return s.toLowerCase();\n}\n",
            "python": "def to_lower_case(s: str) -> str:\n    return s.lower()\n",
            "javascript": "function toLowerCase(s) {\n    return s.toLowerCase();\n}\n",
            "explanation": "The implemented algorithm converts each letter of the given string to its lowercase version. For C++, the transform function is used to apply the `tolower` function to each character to convert it to lowercase. In Java, Python, and JavaScript, the built-in `toLowerCase`, `lower`, and `toLowerCase` functions, respectively, are used to transform the input string into its lowercase variant."
        },
        "structure": {
            "c++": "#include <algorithm>\n#include <cctype>\n\nstd::string toLowerCase(std::string s) \n    // Your code here\n}\n",
            "java": "public String toLowerCase(String s) \n    // Your code here\n}\n",
            "python": "def to_lower_case(s: str) -> str:\n    # Your code here\n\n",
            "javascript": "function toLowerCase(s) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <algorithm>\n#include <cctype>\n\nint main() {\n    std::string s = $args;\n    std::string result = toLowerCase(s);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public String toLowerCase(String s) {\n    String input = $args;\n    String result = toLowerCase(input);\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args[0]\n    result = to_lower_case(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = toLowerCase(s);\n    console.log(result);\n}"
        }
    },
    "743": {
        "title": "Signal Travel Time",
        "description": "You are given a network of `n` nodes, labeled from `1` to `n`. You are also given `times`, a list of travel times as directed edges `times[i] = (ui, vi, wi)`, where `ui` is the source node, `vi` is the target node, and `wi` is the time it takes for a signal to travel from source to target.\n\nWe will send a signal from a given node `k`. Return the minimum time it takes for all the `n` nodes to receive the signal. If it is impossible for all the `n` nodes to receive the signal, return -1.",
        "example": "Example:\n\nInput: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\nOutput: 2\n\nExplanation: The signal travels from node 2 to node 1 in 1 unit of time, then from node 2 to node 3 in 1 unit of time, and finally from node 3 to node 4 in 1 unit of time. Thus, the minimum time for all nodes to receive the signal is 2.\n\nInput: times = [[1,2,1]], n = 2, k = 1\nOutput: 1\n\nExplanation: The signal travels from node 1 to node 2 in 1 unit of time. Thus, the minimum time for all nodes to receive the signal is 1.\n\nInput: times = [[1,2,1]], n = 2, k = 2\nOutput: -1\n\nExplanation: There is no path for the signal to reach node 2 from node 1. Thus, it is impossible for all nodes to receive the signal.",
        "level": "Medium",
        "tags": [
            "graph",
            "shortest path",
            "Dijkstra's algorithm"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        2,
                        1,
                        1
                    ],
                    [
                        2,
                        3,
                        1
                    ],
                    [
                        3,
                        4,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        1
                    ],
                    [
                        2,
                        3,
                        2
                    ],
                    [
                        3,
                        4,
                        3
                    ],
                    [
                        4,
                        5,
                        4
                    ],
                    [
                        5,
                        6,
                        5
                    ],
                    [
                        6,
                        7,
                        6
                    ],
                    [
                        7,
                        8,
                        7
                    ],
                    [
                        8,
                        9,
                        8
                    ],
                    [
                        9,
                        10,
                        9
                    ],
                    [
                        10,
                        11,
                        10
                    ],
                    [
                        11,
                        12,
                        11
                    ],
                    [
                        12,
                        13,
                        12
                    ],
                    [
                        13,
                        14,
                        13
                    ],
                    [
                        14,
                        15,
                        14
                    ],
                    [
                        15,
                        16,
                        15
                    ],
                    [
                        16,
                        17,
                        16
                    ],
                    [
                        17,
                        18,
                        17
                    ],
                    [
                        18,
                        19,
                        18
                    ],
                    [
                        19,
                        20,
                        19
                    ],
                    [
                        20,
                        21,
                        20
                    ]
                ],
                [
                    [
                        1,
                        2,
                        1
                    ],
                    [
                        2,
                        3,
                        2
                    ],
                    [
                        3,
                        4,
                        3
                    ],
                    [
                        4,
                        5,
                        4
                    ],
                    [
                        5,
                        6,
                        5
                    ],
                    [
                        6,
                        7,
                        6
                    ],
                    [
                        7,
                        8,
                        7
                    ],
                    [
                        8,
                        9,
                        8
                    ],
                    [
                        9,
                        10,
                        9
                    ],
                    [
                        10,
                        11,
                        10
                    ],
                    [
                        11,
                        12,
                        11
                    ],
                    [
                        12,
                        13,
                        12
                    ],
                    [
                        13,
                        14,
                        13
                    ],
                    [
                        14,
                        15,
                        14
                    ],
                    [
                        15,
                        16,
                        15
                    ],
                    [
                        16,
                        17,
                        16
                    ],
                    [
                        17,
                        18,
                        17
                    ],
                    [
                        18,
                        19,
                        18
                    ],
                    [
                        19,
                        20,
                        19
                    ],
                    [
                        20,
                        21,
                        20
                    ]
                ],
                [
                    [
                        1,
                        2,
                        1
                    ],
                    [
                        2,
                        3,
                        2
                    ],
                    [
                        3,
                        4,
                        3
                    ],
                    [
                        4,
                        5,
                        4
                    ],
                    [
                        5,
                        6,
                        5
                    ],
                    [
                        6,
                        7,
                        6
                    ],
                    [
                        7,
                        8,
                        7
                    ],
                    [
                        8,
                        9,
                        8
                    ],
                    [
                        9,
                        10,
                        9
                    ],
                    [
                        10,
                        11,
                        10
                    ],
                    [
                        11,
                        12,
                        11
                    ],
                    [
                        12,
                        13,
                        12
                    ],
                    [
                        13,
                        14,
                        13
                    ],
                    [
                        14,
                        15,
                        14
                    ],
                    [
                        15,
                        16,
                        15
                    ],
                    [
                        16,
                        17,
                        16
                    ],
                    [
                        17,
                        18,
                        17
                    ],
                    [
                        18,
                        19,
                        18
                    ],
                    [
                        19,
                        20,
                        19
                    ],
                    [
                        20,
                        21,
                        20
                    ],
                    [
                        21,
                        22,
                        21
                    ],
                    [
                        22,
                        23,
                        22
                    ],
                    [
                        23,
                        24,
                        23
                    ],
                    [
                        24,
                        25,
                        24
                    ],
                    [
                        25,
                        26,
                        25
                    ],
                    [
                        26,
                        27,
                        26
                    ],
                    [
                        27,
                        28,
                        27
                    ],
                    [
                        28,
                        29,
                        28
                    ],
                    [
                        29,
                        30,
                        29
                    ],
                    [
                        30,
                        31,
                        30
                    ],
                    [
                        31,
                        32,
                        31
                    ],
                    [
                        32,
                        33,
                        32
                    ],
                    [
                        33,
                        34,
                        33
                    ],
                    [
                        34,
                        35,
                        34
                    ],
                    [
                        35,
                        36,
                        35
                    ],
                    [
                        36,
                        37,
                        36
                    ],
                    [
                        37,
                        38,
                        37
                    ],
                    [
                        38,
                        39,
                        38
                    ],
                    [
                        39,
                        40,
                        39
                    ],
                    [
                        40,
                        41,
                        40
                    ],
                    [
                        41,
                        42,
                        41
                    ],
                    [
                        42,
                        43,
                        42
                    ],
                    [
                        43,
                        44,
                        43
                    ],
                    [
                        44,
                        45,
                        44
                    ],
                    [
                        45,
                        46,
                        45
                    ],
                    [
                        46,
                        47,
                        46
                    ],
                    [
                        47,
                        48,
                        47
                    ],
                    [
                        48,
                        49,
                        48
                    ],
                    [
                        49,
                        50,
                        49
                    ],
                    [
                        50,
                        51,
                        50
                    ],
                    [
                        51,
                        52,
                        51
                    ],
                    [
                        52,
                        53,
                        52
                    ],
                    [
                        53,
                        54,
                        53
                    ],
                    [
                        54,
                        55,
                        54
                    ],
                    [
                        55,
                        56,
                        55
                    ],
                    [
                        56,
                        57,
                        56
                    ],
                    [
                        57,
                        58,
                        57
                    ],
                    [
                        58,
                        59,
                        58
                    ],
                    [
                        59,
                        60,
                        59
                    ],
                    [
                        60,
                        61,
                        60
                    ],
                    [
                        61,
                        62,
                        61
                    ],
                    [
                        62,
                        63,
                        62
                    ],
                    [
                        63,
                        64,
                        63
                    ],
                    [
                        64,
                        65,
                        64
                    ],
                    [
                        65,
                        66,
                        65
                    ],
                    [
                        66,
                        67,
                        66
                    ],
                    [
                        67,
                        68,
                        67
                    ],
                    [
                        68,
                        69,
                        68
                    ],
                    [
                        69,
                        70,
                        69
                    ],
                    [
                        70,
                        71,
                        70
                    ],
                    [
                        71,
                        72,
                        71
                    ],
                    [
                        72,
                        73,
                        72
                    ],
                    [
                        73,
                        74,
                        73
                    ],
                    [
                        74,
                        75,
                        74
                    ],
                    [
                        75,
                        76,
                        75
                    ],
                    [
                        76,
                        77,
                        76
                    ],
                    [
                        77,
                        78,
                        77
                    ],
                    [
                        78,
                        79,
                        78
                    ],
                    [
                        79,
                        80,
                        79
                    ],
                    [
                        80,
                        81,
                        80
                    ],
                    [
                        81,
                        82,
                        81
                    ],
                    [
                        82,
                        83,
                        82
                    ],
                    [
                        83,
                        84,
                        83
                    ],
                    [
                        84,
                        85,
                        84
                    ],
                    [
                        85,
                        86,
                        85
                    ],
                    [
                        86,
                        87,
                        86
                    ],
                    [
                        87,
                        88,
                        87
                    ],
                    [
                        88,
                        89,
                        88
                    ],
                    [
                        89,
                        90,
                        89
                    ],
                    [
                        90,
                        91,
                        90
                    ],
                    [
                        91,
                        92,
                        91
                    ],
                    [
                        92,
                        93,
                        92
                    ],
                    [
                        93,
                        94,
                        93
                    ],
                    [
                        94,
                        95,
                        94
                    ],
                    [
                        95,
                        96,
                        95
                    ],
                    [
                        96,
                        97,
                        96
                    ],
                    [
                        97,
                        98,
                        97
                    ],
                    [
                        98,
                        99,
                        98
                    ],
                    [
                        99,
                        100,
                        99
                    ]
                ]
            ],
            "outputs": [
                "2",
                "1",
                "-1",
                "20",
                "100",
                "-1"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nint networkDelayTime(vector<vector<int>>& times, int n, int k) {\n    vector<vector<pair<int, int>>> graph(n + 1);\n    for (auto& edge : times) {\n        graph[edge[0]].push_back({edge[1], edge[2]});\n    }\n\n    vector<int> dist(n + 1, INT_MAX);\n    dist[k] = 0;\n\n    priority_queue<pair<int, int>, vector<pair<int,int>>, greater<pair<int, int>>> pq;\n    pq.push({0, k});\n\n    while (!pq.empty()) {\n        int u = pq.top().second;\n        int curr_dist = pq.top().first;\n        pq.pop();\n\n        for (auto& neighbor : graph[u]) {\n            int v = neighbor.first;\n            int weight = neighbor.second;\n            if (curr_dist + weight < dist[v]) {\n                dist[v] = curr_dist + weight;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n\n    int max_time = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (dist[i] == INT_MAX) return -1;\n        max_time = max(max_time, dist[i]);\n    }\n\n    return max_time;\n}\n",
            "java": "import java.util.*;\n\npublic int networkDelayTime(int[][] times, int n, int k) {\n    Map<Integer, List<int[]>> graph = new HashMap<>();\n    for (int[] edge : times) {\n        graph.putIfAbsent(edge[0], new ArrayList<>());\n        graph.get(edge[0]).add(new int[]{edge[1], edge[2]});\n    }\n\n    int[] dist = new int[n+1];\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    dist[k] = 0;\n\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n    pq.offer(new int[]{k, 0});\n\n    while (!pq.isEmpty()) {\n        int[] curr = pq.poll();\n        int u = curr[0], currDist = curr[1];\n\n        List<int[]> neighbors = graph.get(u);\n        if (neighbors == null) continue;\n\n        for (int[] neighbor : neighbors) {\n            int v = neighbor[0], weight = neighbor[1];\n            if (currDist + weight < dist[v]) {\n                dist[v] = currDist + weight;\n                pq.offer(new int[]{v, dist[v]});\n            }\n        }\n    }\n\n    int maxTime = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (dist[i] == Integer.MAX_VALUE) return -1;\n        maxTime = Math.max(maxTime, dist[i]);\n    }\n\n    return maxTime;\n}\n",
            "python": "import heapq\n\ndef networkDelayTime(times, n, k):\n    graph = {i: [] for i in range(1, n+1)}\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    dist = {u: float('inf') for u in range(1, n+1)}\n    dist[k] = 0\n\n    pq = [(0, k)]\n\n    while pq:\n        curr_dist, u = heapq.heappop(pq)\n\n        for v, weight in graph[u]:\n            new_dist = curr_dist + weight\n            if new_dist < dist[v]:\n                dist[v] = new_dist\n                heapq.heappush(pq, (new_dist, v))\n\n    max_time = max(dist.values())\n    return max_time if max_time < float('inf') else -1\n\n",
            "javascript": "function networkDelayTime(times, n, k) {\n    const graph = new Map();\n    for (const [u, v, w] of times) {\n        if (!graph.has(u)) graph.set(u, []);\n        graph.get(u).push([v, w]);\n    }\n    \n    const dist = new Array(n + 1).fill(Infinity);\n    dist[k] = 0;\n\n    const pq = [[0, k]];\n\n    while (pq.length) {\n        pq.sort((a, b) => b[0] - a[0]);\n        const [currDist, u] = pq.pop();\n\n        if (graph.has(u)) {\n            for (const [v, weight] of graph.get(u)) {\n                const newDist = currDist + weight;\n                if (newDist < dist[v]) {\n                    dist[v] = newDist;\n                    pq.push([dist[v], v]);\n                }\n            }\n        }\n    }\n\n    const maxTime = Math.max(...dist.slice(1));\n    return maxTime === Infinity ? -1 : maxTime;\n}\n\n",
            "explanation": "The algorithm we used to solve this problem is Dijkstra's algorithm. Dijkstra's algorithm is a greedy algorithm to find the shortest path from a source node to all other nodes in a weighted graph that has non-negative edge weights.\n\nFirst, we create the adjacency list from the input times, then initialize the distance array for each node to infinity, except for the source node (k), which has a distance of 0. Then, we use a priority queue to store nodes with their respective distances, starting with the source node.\n\nWhile the queue is not empty, we pop the node with the smallest distance, and for each neighbor of the current node, we check if going through the current node will give a shorter distance to the neighbor. If it does, we update the distance and push the neighbor to the priority queue.\n\nAfter visiting all nodes, we find the maximum distance in our dist array (ignoring the 0-th element). If this maximum distance is infinity, it means that some nodes were unreachable from the source node, so we return -1. Otherwise, we return the maximum distance.\n\nThe time complexity of the algorithm is O(E + V) with E being the number of edges and V being the number of vertices."
        },
        "structure": {
            "c++": "#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nint networkDelayTime(vector<vector<int>>& times, int n, int k) \n    // Your code here\n}\n",
            "java": "import java.util.*;\n\npublic int networkDelayTime(int[][] times, int n, int k) \n    // Your code here\n}\n",
            "python": "import heapq\n    # Your code here\n\n",
            "javascript": "function networkDelayTime(times, n, k) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int networkDelayTime(vector<vector<int>>& times, int n, int k) {\n    vector<vector<pair<int, int>>> graph(n + 1);\n    for (auto& edge : times) {\n        graph[edge[0]].push_back({edge[1], edge[2]});\n    }\n\n    vector<int> dist(n + 1, INT_MAX);\n    dist[k] = 0;\n\n    priority_queue<pair<int, int>, vector<pair<int,int>>, greater<pair<int, int>>> pq;\n    pq.push({0, k});\n\n    while (!pq.empty()) {\n        int u = pq.top().second;\n        int curr_dist = pq.top().first;\n        pq.pop();\n\n        for (auto& neighbor : graph[u]) {\n            int v = neighbor.first;\n            int weight = neighbor.second;\n            if (curr_dist + weight < dist[v]) {\n                dist[v] = curr_dist + weight;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n\n    int max_time = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (dist[i] == INT_MAX) return -1;\n        max_time = max(max_time, dist[i]);\n    }\n\n    return max_time;\n}",
            "java": "public int networkDelayTime(int[][] times, int n, int k) {\n    Map<Integer, List<int[]>> graph = new HashMap<>();\n    for (int[] edge : times) {\n        graph.putIfAbsent(edge[0], new ArrayList<>());\n        graph.get(edge[0]).add(new int[]{edge[1], edge[2]});\n    }\n\n    int[] dist = new int[n+1];\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    dist[k] = 0;\n\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n    pq.offer(new int[]{k, 0});\n\n    while (!pq.isEmpty()) {\n        int[] curr = pq.poll();\n        int u = curr[0], currDist = curr[1];\n\n        List<int[]> neighbors = graph.get(u);\n        if (neighbors == null) continue;\n\n        for (int[] neighbor : neighbors) {\n            int v = neighbor[0], weight = neighbor[1];\n            if (currDist + weight < dist[v]) {\n                dist[v] = currDist + weight;\n                pq.offer(new int[]{v, dist[v]});\n            }\n        }\n    }\n\n    int maxTime = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (dist[i] == Integer.MAX_VALUE) return -1;\n        maxTime = Math.max(maxTime, dist[i]);\n    }\n\n    return maxTime;\n}",
            "python": "if __name__ == \"__main__\":\n    times = $args[0]\n    n = $args[1]\n    k = $args[2]\n    result = networkDelayTime(times, n, k)\n    print(result)",
            "javascript": "function networkDelayTime(times, n, k) {\n    const graph = new Map();\n    for (const [u, v, w] of times) {\n        if (!graph.has(u)) graph.set(u, []);\n        graph.get(u).push([v, w]);\n    }\n    \n    const dist = new Array(n + 1).fill(Infinity);\n    dist[k] = 0;\n\n    const pq = [[0, k]];\n\n    while (pq.length) {\n        pq.sort((a, b) => b[0] - a[0]);\n        const [currDist, u] = pq.pop();\n\n        if (graph.has(u)) {\n            for (const [v, weight] of graph.get(u)) {\n                const newDist = currDist + weight;\n                if (newDist < dist[v]) {\n                    dist[v] = newDist;\n                    pq.push([dist[v], v]);\n                }\n            }\n        }\n    }\n\n    const maxTime = Math.max(...dist.slice(1));\n    return maxTime === Infinity ? -1 : maxTime;\n}"
        }
    },
    "744": {
        "title": "Next Character",
        "description": "You are given an array of characters `letters` that is sorted in non-decreasing order, and a character `target`. There are at least two different characters in `letters`. Return the smallest character in `letters` that is lexicographically greater than `target`. If such a character does not exist, return the first character in `letters`.",
        "example": "Example:\n\nInput: letters = [\"c\", \"f\", \"j\"], target = \"a\"\nOutput: \"c\"\nExplanation: The smallest character that is lexicographically greater than 'a' in letters is 'c'.",
        "level": "Easy",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "c",
                        "f",
                        "j"
                    ],
                    "a"
                ],
                [
                    [
                        "c",
                        "f",
                        "j"
                    ],
                    "c"
                ],
                [
                    [
                        "x",
                        "x",
                        "y",
                        "y"
                    ],
                    "z"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d"
                    ],
                    "d"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d"
                    ],
                    "e"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d"
                    ],
                    "b"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d"
                    ],
                    "c"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d"
                    ],
                    "a"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d"
                    ],
                    "f"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d"
                    ],
                    "g"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d"
                    ],
                    "h"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d"
                    ],
                    "i"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d"
                    ],
                    "j"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d"
                    ],
                    "k"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d"
                    ],
                    "l"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d"
                    ],
                    "m"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d"
                    ],
                    "n"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d"
                    ],
                    "o"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d"
                    ],
                    "p"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d"
                    ],
                    "q"
                ]
            ],
            "outputs": [
                "c",
                "f",
                "x",
                "a",
                "a",
                "c",
                "d",
                "a",
                "a",
                "a",
                "a",
                "a",
                "a",
                "a",
                "a",
                "a",
                "a",
                "a",
                "a",
                "a"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <queue>\n#include <algorithm>\n#include <limits>\n\nint networkDelayTime(std::vector<std::vector<int>>& times, int n, int k) {\n    std::vector<std::vector<std::pair<int, int>>> graph(n + 1);\n    for (const auto &edge : times)\n        graph[edge[0]].emplace_back(edge[1], edge[2]);\n\n    std::vector<int> dist(n + 1, std::numeric_limits<int>::max());\n    dist[k] = 0;\n\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> pq;\n    pq.emplace(0, k);\n\n    while (!pq.empty()) {\n        int time = pq.top().first, node = pq.top().second;\n        pq.pop();\n\n        if (time > dist[node]) continue;\n        for (const auto &neighbour : graph[node]) {\n            int nextNode = neighbour.first, nextTime = neighbour.second;\n            if (time + nextTime < dist[nextNode]) {\n                dist[nextNode] = time + nextTime;\n                pq.push({dist[nextNode], nextNode});\n            }\n        }\n    }\n\n    int maxTime = *std::max_element(dist.begin() + 1, dist.end());\n    return maxTime == std::numeric_limits<int>::max() ? -1 : maxTime;\n}\n",
            "java": "import java.util.*;\n\nclass Solution {\n    public int networkDelayTime(int[][] times, int n, int k) {\n        List<List<int[]>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++)\n            graph.add(new ArrayList<>());\n        for (int[] edge : times)\n            graph.get(edge[0]).add(new int[]{edge[1], edge[2]});\n        \n        int[] dist = new int[n + 1];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[k] = 0;\n        \n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n        pq.add(new int[]{0, k});\n        \n        while (!pq.isEmpty()) {\n            int[] curr = pq.poll();\n            int time = curr[0], node = curr[1];\n            \n            if (time > dist[node]) continue;\n            for (int[] neighbour : graph.get(node)) {\n                int neighbourNode = neighbour[0], neighbourTime = neighbour[1];\n                if (time + neighbourTime < dist[neighbourNode]) {\n                    dist[neighbourNode] = time + neighbourTime;\n                    pq.add(new int[]{dist[neighbourNode], neighbourNode});\n                }\n            }\n        }\n        \n        int maxTime = Arrays.stream(dist).skip(1).max().getAsInt();\n        return maxTime == Integer.MAX_VALUE ? -1 : maxTime;\n    }\n}\n",
            "python": "import heapq\nfrom collections import defaultdict\n\ndef networkDelayTime(times, n, k):\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    dist = {i: float('inf') for i in range(1, n + 1)}\n    dist[k] = 0\n\n    pq = [(0, k)]\n\n    while pq:\n        time, node = heapq.heappop(pq)\n\n        if time > dist[node]:\n            continue\n\n        for neighbour, neighbourTime in graph[node]:\n            candidate_dist = time + neighbourTime\n            if candidate_dist < dist[neighbour]:\n                dist[neighbour] = candidate_dist\n                heapq.heappush(pq, (candidate_dist, neighbour))\n\n    maxTime = max(dist.values())\n    return maxTime if maxTime < float('inf') else -1\n",
            "javascript": "function networkDelayTime(times, n, k) {\n    const graph = new Map();\n    for (const [u, v, w] of times) {\n        if (!graph.has(u)) graph.set(u, []);\n        graph.get(u).push([v, w]);\n    }\n\n    const dist = new Array(n + 1).fill(Infinity);\n    dist[k] = 0;\n\n    const pq = [[0, k]];\n    while (pq.length) {\n        pq.sort((a, b) => b[0] - a[0]);\n        const [time, node] = pq.pop();\n\n        if (time > dist[node]) continue;\n\n        if (graph.has(node)) {\n            for (const [neighbour, neighbourTime] of graph.get(node)) {\n                const candidate_dist = time + neighbourTime;\n                if (candidate_dist < dist[neighbour]) {\n                    dist[neighbour] = candidate_dist;\n                    pq.push([candidate_dist, neighbour]);\n                }\n            }\n        }\n    }\n\n    const maxTime = Math.max(...dist.slice(1));\n    return maxTime === Infinity ? -1 : maxTime;\n}\n",
            "explanation": "The algorithm uses Dijkstra's shortest path algorithm to find the shortest time it takes for the signal to reach every node.\n\n1. Create an adjacency list (graph) to represent the times between nodes.\n   (note: we use different data structures depending on the language, but the idea is the same)\n2. Initialize a distance array (dist) to store the shortest time it takes for the signal to arrive at each node. Set the initial values to infinity (maximum possible time) except for node k, which is set to 0 as it's the source.\n3. Create a priority queue (pq) to store the time it takes to visit a node. Initialize it with node k and time 0.\n4. Iterate through the priority queue while it's not empty:\n   a. Pop the node with the smallest time from the priority queue.\n   b. Check if the current time is greater than the distance for the current node; if true, continue to the next iteration.\n   c. For each neighbor's node in the graph, compare the sum of the current time and travel time to reach the neighbor with the minimum distance for the neighbor in the dist array. If the new calculated time is less, update the dist array and push the neighbor with the new calculated time into the priority queue.\n5. After the loop is finished, find the maximum value in the dist array (ignoring the first value, which is a placeholder). If the maximum value is infinity, return -1, as not all nodes could receive the signal. Otherwise, return the maximum time."
        },
        "structure": {
            "c++": "#include <vector>\n#include <queue>\n#include <algorithm>\n#include <limits>\n\nint networkDelayTime(std::vector<std::vector<int>>& times, int n, int k) \n    // Your code here\n}\n",
            "java": "import java.util.*;\n\nclass Solution \n    // Your code here\n}\n",
            "python": "import heapq\n    # Your code here\n\n",
            "javascript": "function networkDelayTime(times, n, k) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int networkDelayTime(std::vector<std::vector<int>>& times, int n, int k) {\n    std::vector<std::vector<std::pair<int, int>>> graph(n + 1);\n    for (const auto &edge : times)\n        graph[edge[0]].emplace_back(edge[1], edge[2]);\n\n    std::vector<int> dist(n + 1, std::numeric_limits<int>::max());\n    dist[k] = 0;\n\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> pq;\n    pq.emplace(0, k);\n\n    while (!pq.empty()) {\n        int time = pq.top().first, node = pq.top().second;\n        pq.pop();\n\n        if (time > dist[node]) continue;\n        for (const auto &neighbour : graph[node]) {\n            int nextNode = neighbour.first, nextTime = neighbour.second;\n            if (time + nextTime < dist[nextNode]) {\n                dist[nextNode] = time + nextTime;\n                pq.push({dist[nextNode], nextNode});\n            }\n        }\n    }\n\n    int maxTime = *std::max_element(dist.begin() + 1, dist.end());\n    return maxTime == std::numeric_limits<int>::max() ? -1 : maxTime;\n}",
            "java": "public int networkDelayTime(int[][] times, int n, int k) {\n        List<List<int[]>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++)\n            graph.add(new ArrayList<>());\n        for (int[] edge : times)\n            graph.get(edge[0]).add(new int[]{edge[1], edge[2]});\n\n        int[] dist = new int[n + 1];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[k] = 0;\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n        pq.add(new int[]{0, k});\n\n        while (!pq.isEmpty()) {\n            int[] curr = pq.poll();\n            int time = curr[0], node = curr[1];\n\n            if (time > dist[node]) continue;\n            for (int[] neighbour : graph.get(node)) {\n                int neighbourNode = neighbour[0], neighbourTime = neighbour[1];\n                if (time + neighbourTime < dist[neighbourNode]) {\n                    dist[neighbourNode] = time + neighbourTime;\n                    pq.add(new int[]{dist[neighbourNode], neighbourNode});\n                }\n            }\n        }\n\n        int maxTime = Arrays.stream(dist).skip(1).max().getAsInt();\n        return maxTime == Integer.MAX_VALUE ? -1 : maxTime;\n    }",
            "python": "if __name__ == \"__main__\":\n    times = $args[0]\n    n = $args[1]\n    k = $args[2]\n    result = networkDelayTime(times, n, k)\n    print(result)",
            "javascript": "function networkDelayTime(times, n, k) {\n    const graph = new Map();\n    for (const [u, v, w] of times) {\n        if (!graph.has(u)) graph.set(u, []);\n        graph.get(u).push([v, w]);\n    }\n\n    const dist = new Array(n + 1).fill(Infinity);\n    dist[k] = 0;\n\n    const pq = [[0, k]];\n    while (pq.length) {\n        pq.sort((a, b) => b[0] - a[0]);\n        const [time, node] = pq.pop();\n\n        if (time > dist[node]) continue;\n\n        if (graph.has(node)) {\n            for (const [neighbour, neighbourTime] of graph.get(node)) {\n                const candidate_dist = time + neighbourTime;\n                if (candidate_dist < dist[neighbour]) {\n                    dist[neighbour] = candidate_dist;\n                    pq.push([candidate_dist, neighbour]);\n                }\n            }\n        }\n    }\n\n    const maxTime = Math.max(...dist.slice(1));\n    return maxTime === Infinity ? -1 : maxTime;\n}"
        }
    },
    "745": {
        "title": "Word Filter",
        "description": "Design a special dictionary that searches the words in it by a prefix and a suffix. Implement the `WordFilter` class which has two methods: `WordFilter(string[] words)` to initialize the object with the words in the dictionary, and `f(string pref, string suff)` to return the index of the word in the dictionary that has the given prefix `pref` and suffix `suff`. If there is more than one valid index, return the largest of them. If there is no such word in the dictionary, return -1.",
        "example": "Example:\n\nInput:\nWordFilter([\"apple\"])\nf(\"a\", \"e\")\nOutput:\n0\n\nExplanation:\nWordFilter wordFilter = new WordFilter([\"apple\"]);\nwordFilter.f(\"a\", \"e\"); // returns 0, because the word at index 0 has prefix = \"a\" and suffix = \"e\".",
        "level": "Medium",
        "tags": [
            "Trie",
            "Prefix and Suffix"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "apple"
                    ]
                ],
                [
                    "a",
                    "e"
                ],
                [
                    [
                        "apple",
                        "banana",
                        "cherry"
                    ]
                ],
                [
                    "a",
                    "e"
                ],
                [
                    [
                        "apple",
                        "banana",
                        "cherry"
                    ]
                ],
                [
                    "a",
                    "y"
                ],
                [
                    [
                        "apple",
                        "banana",
                        "cherry"
                    ]
                ],
                [
                    "a",
                    "le"
                ],
                [
                    [
                        "apple",
                        "banana",
                        "cherry"
                    ]
                ],
                [
                    "b",
                    "a"
                ],
                [
                    [
                        "apple",
                        "banana",
                        "cherry"
                    ]
                ],
                [
                    "c",
                    "y"
                ],
                [
                    [
                        "apple",
                        "banana",
                        "cherry"
                    ]
                ],
                [
                    "c",
                    "ry"
                ],
                [
                    [
                        "apple",
                        "banana",
                        "cherry"
                    ]
                ],
                [
                    "d",
                    "e"
                ],
                [
                    [
                        "apple",
                        "banana",
                        "cherry"
                    ]
                ],
                [
                    "d",
                    "y"
                ],
                [
                    [
                        "apple",
                        "banana",
                        "cherry"
                    ]
                ],
                [
                    "e",
                    "e"
                ],
                [
                    [
                        "apple",
                        "banana",
                        "cherry"
                    ]
                ],
                [
                    "e",
                    "y"
                ]
            ],
            "outputs": [
                "0",
                "-1",
                "1",
                "0",
                "2",
                "-1",
                "2",
                "0",
                "-1",
                "-1",
                "-1",
                "-1",
                "-1",
                "-1",
                "-1",
                "-1",
                "-1",
                "-1",
                "-1",
                "-1"
            ]
        },
        "sample_code": {
            "c++": "char nextGreatestLetter(vector<char>& letters, char target) {\n    for (char letter : letters) {\n        if (letter > target) {\n            return letter;\n        }\n    }\n    return letters[0];\n}\n",
            "java": "public char nextGreatestLetter(char[] letters, char target) {\n    for (char letter : letters) {\n        if (letter > target) {\n            return letter;\n        }\n    }\n    return letters[0];\n}\n",
            "python": "def next_greatest_letter(letters, target):\n    for letter in letters:\n        if letter > target:\n            return letter\n    return letters[0]\n",
            "javascript": "function nextGreatestLetter(letters, target) {\n    for (let letter of letters) {\n        if (letter > target) {\n            return letter;\n        }\n    }\n    return letters[0];\n}\n",
            "explanation": "The algorithm simply iterates through the `letters` array, which is already sorted in non-decreasing order. For each letter in the array, it checks if the letter is larger than the target. If it is, then it returns that letter as the smallest letter larger than the target. If the loop completes without finding a letter larger than the target, the array wraps around, and the first element of the array is returned as the smallest letter larger than the target."
        },
        "structure": {
            "c++": "char nextGreatestLetter(vector<char>& letters, char target) \n    // Your code here\n}\n",
            "java": "public char nextGreatestLetter(char[] letters, char target) \n    // Your code here\n}\n",
            "python": "def next_greatest_letter(letters, target):\n    # Your code here\n\n",
            "javascript": "function nextGreatestLetter(letters, target) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "char nextGreatestLetter(vector<char>& letters, char target) {\n    char result = nextGreatestLetter(letters, target);\n    return result;\n}",
            "java": "public char nextGreatestLetter(char[] letters, char target) {\n    for (char letter : letters) {\n        if (letter > target) {\n            return letter;\n        }\n    }\n    return letters[0];\n}",
            "python": "if __name__ == \"__main__\":\n    letters = $args[0]\n    target = $args[1]\n    result = next_greatest_letter(letters, target)\n    print(result)",
            "javascript": "function main() {\n    const letters = $args[0];\n    const target = $args[1];\n    const result = nextGreatestLetter(letters, target);\n    console.log(result);\n}"
        }
    },
    "747": {
        "title": "Largest Element Index",
        "description": "Given an integer array `nums` where the largest integer is unique, determine whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, or return -1 otherwise.",
        "example": "Example:\n\nInput: nums = [3,6,1,0]\nOutput: 1\nExplanation: 6 is the largest integer. For every other number in the array x, 6 is at least twice as big as x. The index of value 6 is 1, so we return 1.",
        "level": "Easy",
        "tags": [
            "array",
            "math"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    6,
                    1,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4
                ],
                [
                    5,
                    10,
                    2,
                    1
                ],
                [
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    4,
                    8
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50
                ],
                [
                    100,
                    50,
                    25,
                    12,
                    6,
                    3
                ]
            ],
            "outputs": [
                1,
                -1,
                1,
                -1,
                -1,
                3,
                4,
                0
            ]
        },
        "sample_code": {
            "c++": "int minCostClimbingStairs(vector<int>& cost) {\n    int n = cost.size();\n    for(int i=2; i<n; i++)\n        cost[i] += min(cost[i-1], cost[i-2]);\n    return min(cost[n-1], cost[n-2]);\n}\n",
            "java": "public int minCostClimbingStairs(int[] cost) {\n    for(int i=2; i<cost.length; i++)\n        cost[i] += Math.min(cost[i-1], cost[i-2]);\n    return Math.min(cost[cost.length-1], cost[cost.length-2]);\n}\n",
            "python": "def minCostClimbingStairs(cost):\n    for i in range(2, len(cost)):\n        cost[i] += min(cost[i-1], cost[i-2])\n    return min(cost[-1], cost[-2])\n",
            "javascript": "function minCostClimbingStairs(cost) {\n    for(let i=2; i<cost.length; i++)\n        cost[i] += Math.min(cost[i-1], cost[i-2]);\n    return Math.min(cost[cost.length-1], cost[cost.length-2]);\n}\n",
            "explanation": "The algorithm is based on dynamic programming. We loop through the array starting from index 2 (since we can start from step 0 or 1 without any cost), and at each step, we add the minimum of the costs of the previous two steps to the current step. We do this to find the optimal path at each step, which eventually leads to the minimum cost to reach the top. After processing the whole array, we return the minimum of the costs of the last two steps as the result."
        },
        "structure": {
            "c++": "int minCostClimbingStairs(vector<int>& cost) \n    // Your code here\n}\n",
            "java": "public int minCostClimbingStairs(int[] cost) \n    // Your code here\n}\n",
            "python": "def minCostClimbingStairs(cost):\n    # Your code here\n\n",
            "javascript": "function minCostClimbingStairs(cost) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> cost = $args;\n    int result = minCostClimbingStairs(cost);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int main(int[] args) {\n    int[] cost = args;\n    for(int i=2; i<cost.length; i++)\n        cost[i] += Math.min(cost[i-1], cost[i-2]);\n    return Math.min(cost[cost.length-1], cost[cost.length-2]);\n}",
            "python": "if __name__ == \"__main__\":\n    cost = $args[0]\n    result = minCostClimbingStairs(cost)\n    print(result)",
            "javascript": "function main() {\n    const cost = $args;\n    const result = minCostClimbingStairs(cost);\n    console.log(result);\n}"
        }
    },
    "751": {
        "title": "CIDR Block Coverage",
        "description": "Given an IP address and the number of IP addresses to cover, find the shortest list of CIDR blocks that covers the range of IP addresses exactly.",
        "example": "Example:\n\nInput: ip = \"255.0.0.7\", n = 10\nOutput: [\"255.0.0.7/32\", \"255.0.0.8/29\", \"255.0.0.16/32\"]\nExplanation:\nThe IP addresses that need to be covered are:\n- 255.0.0.7 -> 11111111 00000000 00000000 00000111\n- 255.0.0.8 -> 11111111 00000000 00000000 00001000\n- 255.0.0.9 -> 11111111 00000000 00000000 00001001\n- 255.0.0.10 -> 11111111 00000000 00000000 00001010\n- 255.0.0.11 -> 11111111 00000000 00000000 00001011\n- 255.0.0.12 -> 11111111 00000000 00000000 00001100\n- 255.0.0.13 -> 11111111 00000000 00000000 00001101\n- 255.0.0.14 -> 11111111 00000000 00000000 00001110\n- 255.0.0.15 -> 11111111 00000000 00000000 00001111\n- 255.0.0.16 -> 11111111 00000000 00000000 00010000\nThe CIDR block \"255.0.0.7/32\" covers the first address.\nThe CIDR block \"255.0.0.8/29\" covers the middle 8 addresses (binary format of 11111111 00000000 00000000 00001xxx).\nThe CIDR block \"255.0.0.16/32\" covers the last address.\nNote that while the CIDR block \"255.0.0.0/28\" does cover all the addresses, it also includes addresses outside of the range, so we cannot use it.",
        "level": "Medium",
        "tags": [
            "IP Address",
            "CIDR Block",
            "Binary Representation"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "255.0.0.7",
                        10
                    ]
                ],
                [
                    [
                        "117.145.102.62",
                        8
                    ]
                ],
                [
                    [
                        "192.168.0.1",
                        1
                    ]
                ],
                [
                    [
                        "10.0.0.0",
                        256
                    ]
                ],
                [
                    [
                        "172.16.0.0",
                        4096
                    ]
                ],
                [
                    [
                        "192.168.0.0",
                        65536
                    ]
                ],
                [
                    [
                        "0.0.0.0",
                        1
                    ]
                ],
                [
                    [
                        "255.255.255.255",
                        1
                    ]
                ],
                [
                    [
                        "192.168.0.0",
                        256
                    ]
                ],
                [
                    [
                        "10.0.0.0",
                        16777216
                    ]
                ],
                [
                    [
                        "172.16.0.0",
                        268435456
                    ]
                ],
                [
                    [
                        "192.168.0.0",
                        4294967296
                    ]
                ],
                [
                    [
                        "0.0.0.0",
                        4294967296
                    ]
                ],
                [
                    [
                        "255.255.255.255",
                        4294967296
                    ]
                ],
                [
                    [
                        "192.168.0.0",
                        4294967297
                    ]
                ],
                [
                    [
                        "10.0.0.0",
                        4294967297
                    ]
                ],
                [
                    [
                        "172.16.0.0",
                        4294967297
                    ]
                ],
                [
                    [
                        "192.168.0.0",
                        4294967295
                    ]
                ],
                [
                    [
                        "10.0.0.0",
                        4294967295
                    ]
                ],
                [
                    [
                        "172.16.0.0",
                        4294967295
                    ]
                ]
            ],
            "outputs": [
                "[\"255.0.0.7/32\", \"255.0.0.8/29\", \"255.0.0.16/32\"]",
                "[\"117.145.102.62/31\", \"117.145.102.64/30\", \"117.145.102.68/31\"]",
                "[\"192.168.0.1/32\"]",
                "[\"10.0.0.0/24\"]",
                "[\"172.16.0.0/20\"]",
                "[\"192.168.0.0/16\"]",
                "[\"0.0.0.0/32\"]",
                "[\"255.255.255.255/32\"]",
                "[\"192.168.0.0/24\"]",
                "[\"10.0.0.0/8\"]",
                "[\"172.16.0.0/12\"]",
                "[\"192.168.0.0/16\"]",
                "[\"0.0.0.0/0\"]",
                "[\"255.255.255.255/0\"]",
                "[\"192.168.0.0/0\"]",
                "[\"10.0.0.0/0\"]",
                "[\"172.16.0.0/0\"]",
                "[\"192.168.0.0/0\"]",
                "[\"10.0.0.0/0\"]",
                "[\"172.16.0.0/0\"]"
            ]
        },
        "sample_code": {
            "c++": "#include <bitset>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<string> ipToCIDR(string ip, int n) {\n    stringstream ss(ip);\n    int a, b, c, d;\n    char ch;\n    ss >> a >> ch >> b >> ch >> c >> ch >> d;\n    unsigned mask = 0xFFFFFFFF;\n    unsigned start = (a << 24) + (b << 16) + (c << 8) + d;\n    unsigned end = start + n - 1;\n    \n    vector<string> ans;\n    while (start <= end) {\n        int samePrefixBits = __builtin_ctz(~(start & -start));\n        while ((mask >> samePrefixBits) & 1)\n            ++samePrefixBits;\n        while (((end - start) >> samePrefixBits) < 1)\n            --samePrefixBits;\n        unsigned range = 1 << samePrefixBits;\n        stringstream res;\n        res << (start >> 24) << \".\" << ((start >> 16) & 255) << \".\" << ((start >> 8) & 255) << \".\" << (start & 255) << \"/\" << (32 - samePrefixBits);\n        ans.push_back(res.str());\n        start += range;\n    }\n    \n    return ans;\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> ipToCIDR(String ip, int n) {\n    String[] parts = ip.split(\"\\\\.\");\n    int start = (Integer.parseInt(parts[0]) << 24) + (Integer.parseInt(parts[1]) << 16) + (Integer.parseInt(parts[2]) << 8) + Integer.parseInt(parts[3]);\n    int end = start + n - 1;\n    \n    List<String> ans = new ArrayList<>();\n    while (start <= end) {\n        int samePrefixBits = Integer.numberOfTrailingZeros(~(start & -start));\n        while (((end - start) >> samePrefixBits) < 1)\n            --samePrefixBits;\n        int range = 1 << samePrefixBits;\n        ans.add((start >> 24) + \".\" + ((start >> 16) & 255) + \".\" + ((start >> 8) & 255) + \".\" + (start & 255) + \"/\" + (32 - samePrefixBits));\n        start += range;\n    }\n    \n    return ans;\n}\n\n",
            "python": "def ipToCIDR(ip: str, n: int) -> List[str]:\n    a, b, c, d = map(int, ip.split('.'))\n    start = (a << 24) + (b << 16) + (c << 8) + d\n    end = start + n - 1\n    \n    ans = []\n    while start <= end:\n        samePrefixBits = (~start & start).bit_length() - 1\n        while ((end - start) >> samePrefixBits) < 1:\n            samePrefixBits -= 1\n        range = 1 << samePrefixBits\n        ans.append(f\"{start >> 24}.{(start >> 16) & 255}.{(start >> 8) & 255}.{start & 255}/{32 - samePrefixBits}\")\n        start += range\n    \n    return ans\n\n",
            "javascript": "function ipToCIDR(ip, n) {\n    const [a, b, c, d] = ip.split('.').map(Number);\n    let start = (a << 24) + (b << 16) + (c << 8) + d;\n    const end = start + n - 1;\n    \n    const ans = [];\n    while (start <= end) {\n        let samePrefixBits = Math.clz32(~(start & -start));\n        while (((end - start) >> samePrefixBits) < 1)\n            --samePrefixBits;\n        const range = 1 << samePrefixBits;\n        ans.push(`${(start >> 24)}.${((start >> 16) & 255)}.${((start >> 8) & 255)}.${(start & 255)}/${32 - samePrefixBits}`);\n        start += range;\n    }\n    \n    return ans;\n}\n\n",
            "explanation": "The algorithm first converts the given IP to an integer. Then iteratively, it finds the first CIDR block that covers the starting IP and all the subsequent IPs that have the same prefix bits as the starting IP address, without covering any address outside the range. Once the range of the CIDR block is found, the CIDR block is added to the result and the starting IP is updated to be the next address after the found range. This process is repeated until the whole range is covered.\n\nFor each step, we start by finding the number of bits with a one in the lowest bits of the current starting IP's binary representation. This tells us how many bits are different from the preceding IP(s). Then, we keep decreasing the number of bits (effectively increasing the range) until we find a range that covers at least the remaining IPs in the range. To avoid overstepping the range, we decrease the prefix bits if the maximum number of IPs covered by the current CIDR block is more than what's left. Finally, we add the CIDR block and update the starting IP. The algorithm terminates when the starting IP becomes greater than the end IP."
        },
        "structure": {
            "c++": "#include <bitset>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nvector<string> ipToCIDR(string ip, int n) \n    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> ipToCIDR(String ip, int n) \n    // Your code here\n}\n\n",
            "python": "def ipToCIDR(ip: str, n: int) -> List[str]:\n    # Your code here\n\n",
            "javascript": "function ipToCIDR(ip, n) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <bitset>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint main() {\n    string ip = $args;\n    int n = $args;\n    vector<string> result = ipToCIDR(ip, n);\n    for (string s : result) {\n        cout << s << endl;\n    }\n    return 0;\n}\n",
            "java": "public List<String> ipToCIDR(String ip, int n) {\n    String[] parts = ip.split(\"\\\\.\");\n    int start = (Integer.parseInt(parts[0]) << 24) + (Integer.parseInt(parts[1]) << 16) + (Integer.parseInt(parts[2]) << 8) + Integer.parseInt(parts[3]);\n    int end = start + n - 1;\n    \n    List<String> ans = new ArrayList<>();\n    while (start <= end) {\n        int samePrefixBits = Integer.numberOfTrailingZeros(~(start & -start));\n        while (((end - start) >> samePrefixBits) < 1)\n            --samePrefixBits;\n        int range = 1 << samePrefixBits;\n        ans.add((start >> 24) + \".\" + ((start >> 16) & 255) + \".\" + ((start >> 8) & 255) + \".\" + (start & 255) + \"/\" + (32 - samePrefixBits));\n        start += range;\n    }\n    \n    return ans;\n}",
            "python": "if __name__ == \"__main__\":\n    ip = $args[0]\n    n = $args[1]\n    result = ipToCIDR(ip, n)\n    print(result)",
            "javascript": "function ipToCIDR(ip, n) {\n    const [a, b, c, d] = ip.split('.').map(Number);\n    let start = (a << 24) + (b << 16) + (c << 8) + d;\n    const end = start + n - 1;\n    \n    const ans = [];\n    while (start <= end) {\n        let samePrefixBits = Math.clz32(~(start & -start));\n        while (((end - start) >> samePrefixBits) < 1)\n            --samePrefixBits;\n        const range = 1 << samePrefixBits;\n        ans.push(`${(start >> 24)}.${((start >> 16) & 255)}.${((start >> 8) & 255)}.${(start & 255)}/${32 - samePrefixBits}`);\n        start += range;\n    }\n    \n    return ans;\n}"
        }
    },
    "752": {
        "title": "Minimum Number of Turns to Open a Lock",
        "description": "You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot.\n\nThe lock initially starts at '0000', a string representing the state of the 4 wheels.\n\nYou are given a list of `deadends` dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\n\nGiven a `target` representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.",
        "example": "Example:\n\nInput: deadends = [\"0201\", \"0101\", \"0102\", \"1212\", \"2002\"], target = \"0202\"\nOutput: 6\nExplanation: A sequence of valid moves would be \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\". Note that a sequence like \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" would be invalid, because the wheels of the lock become stuck after the display becomes the dead end \"0102\".",
        "level": "Medium",
        "tags": [
            "BFS",
            "Graph"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "0201",
                        "0101",
                        "0102",
                        "1212",
                        "2002"
                    ],
                    "0202"
                ],
                [
                    [
                        "8888"
                    ],
                    "0009"
                ],
                [
                    [
                        "8887",
                        "8889",
                        "8878",
                        "8898",
                        "8788",
                        "8988",
                        "7888",
                        "9888"
                    ],
                    "8888"
                ],
                [
                    [
                        "0000"
                    ],
                    "0001"
                ],
                [
                    [
                        "0000"
                    ],
                    "9999"
                ],
                [
                    [
                        "1234",
                        "5678",
                        "9012"
                    ],
                    "9876"
                ],
                [
                    [
                        "1111",
                        "2222",
                        "3333",
                        "4444",
                        "5555",
                        "6666",
                        "7777",
                        "8888",
                        "9999"
                    ],
                    "0000"
                ],
                [
                    [
                        "0000",
                        "1111",
                        "2222",
                        "3333",
                        "4444",
                        "5555",
                        "6666",
                        "7777",
                        "8888",
                        "9999"
                    ],
                    "1234"
                ],
                [
                    [
                        "0000",
                        "1111",
                        "2222",
                        "3333",
                        "4444",
                        "5555",
                        "6666",
                        "7777",
                        "8888",
                        "9999"
                    ],
                    "9876"
                ],
                [
                    [
                        "0000",
                        "1111",
                        "2222",
                        "3333",
                        "4444",
                        "5555",
                        "6666",
                        "7777",
                        "8888",
                        "9999"
                    ],
                    "5432"
                ],
                [
                    [
                        "0000",
                        "1111",
                        "2222",
                        "3333",
                        "4444",
                        "5555",
                        "6666",
                        "7777",
                        "8888",
                        "9999"
                    ],
                    "6789"
                ],
                [
                    [
                        "0000",
                        "1111",
                        "2222",
                        "3333",
                        "4444",
                        "5555",
                        "6666",
                        "7777",
                        "8888",
                        "9999"
                    ],
                    "9876"
                ],
                [
                    [
                        "0000",
                        "1111",
                        "2222",
                        "3333",
                        "4444",
                        "5555",
                        "6666",
                        "7777",
                        "8888",
                        "9999"
                    ],
                    "5432"
                ],
                [
                    [
                        "0000",
                        "1111",
                        "2222",
                        "3333",
                        "4444",
                        "5555",
                        "6666",
                        "7777",
                        "8888",
                        "9999"
                    ],
                    "6789"
                ],
                [
                    [
                        "0000",
                        "1111",
                        "2222",
                        "3333",
                        "4444",
                        "5555",
                        "6666",
                        "7777",
                        "8888",
                        "9999"
                    ],
                    "9876"
                ],
                [
                    [
                        "0000",
                        "1111",
                        "2222",
                        "3333",
                        "4444",
                        "5555",
                        "6666",
                        "7777",
                        "8888",
                        "9999"
                    ],
                    "5432"
                ],
                [
                    [
                        "0000",
                        "1111",
                        "2222",
                        "3333",
                        "4444",
                        "5555",
                        "6666",
                        "7777",
                        "8888",
                        "9999"
                    ],
                    "6789"
                ],
                [
                    [
                        "0000",
                        "1111",
                        "2222",
                        "3333",
                        "4444",
                        "5555",
                        "6666",
                        "7777",
                        "8888",
                        "9999"
                    ],
                    "9876"
                ],
                [
                    [
                        "0000",
                        "1111",
                        "2222",
                        "3333",
                        "4444",
                        "5555",
                        "6666",
                        "7777",
                        "8888",
                        "9999"
                    ],
                    "5432"
                ],
                [
                    [
                        "0000",
                        "1111",
                        "2222",
                        "3333",
                        "4444",
                        "5555",
                        "6666",
                        "7777",
                        "8888",
                        "9999"
                    ],
                    "6789"
                ],
                [
                    [
                        "0000",
                        "1111",
                        "2222",
                        "3333",
                        "4444",
                        "5555",
                        "6666",
                        "7777",
                        "8888",
                        "9999"
                    ],
                    "9876"
                ],
                [
                    [
                        "0000",
                        "1111",
                        "2222",
                        "3333",
                        "4444",
                        "5555",
                        "6666",
                        "7777",
                        "8888",
                        "9999"
                    ],
                    "5432"
                ],
                [
                    [
                        "0000",
                        "1111",
                        "2222",
                        "3333",
                        "4444",
                        "5555",
                        "6666",
                        "7777",
                        "8888",
                        "9999"
                    ],
                    "6789"
                ]
            ],
            "outputs": [
                6,
                1,
                -1,
                1,
                -1,
                8,
                -1,
                4,
                8,
                7,
                8,
                8,
                8,
                8,
                8,
                8,
                8,
                8,
                8,
                8,
                8
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <queue>\n#include <set>\nusing namespace std;\n\nint openLock(vector<string>& deadends, string target) {\n    set<string> dead(deadends.begin(), deadends.end());\n    set<string> visited;\n    queue<string> q;\n    string start = \"0000\";\n\n    if (dead.find(start) != dead.end()) return -1;\n    q.push(start);\n    visited.insert(start);\n\n    int moves = 0;\n    while (!q.empty()) {\n        int levelSize = q.size();\n        for (int i = 0; i < levelSize; ++i) {\n            string cur = q.front();\n            q.pop();\n\n            if (cur == target) return moves;\n\n            for (int j = 0; j < 4; ++j) {\n                for (int k = -1; k <= 1; k += 2) {\n                    string next = cur;\n                    next[j] = (next[j] - '0' + k + 10) % 10 + '0';\n\n                    if (visited.find(next) == visited.end() && dead.find(next) == dead.end()) {\n                        visited.insert(next);\n                        q.push(next);\n                    }\n                }\n            }\n        }\n        moves++;\n    }\n\n    return -1;\n}\n\n",
            "java": "import java.util.*;\n\npublic int openLock(String[] deadends, String target) {\n    Set<String> dead = new HashSet<>(Arrays.asList(deadends));\n    Set<String> visited = new HashSet<>();\n    Queue<String> q = new LinkedList<>();\n    String start = \"0000\";\n\n    if (dead.contains(start)) return -1;\n    q.offer(start);\n    visited.add(start);\n\n    int moves = 0;\n    while (!q.isEmpty()) {\n        int levelSize = q.size();\n        for (int i = 0; i < levelSize; i++) {\n            String cur = q.poll();\n\n            if (cur.equals(target)) return moves;\n\n            for (int j = 0; j < 4; j++) {\n                for (int k = -1; k <= 1; k += 2) {\n                    String next = cur.substring(0, j) + (char)((cur.charAt(j) - '0' + k + 10) % 10 + '0') + cur.substring(j + 1);\n\n                    if (!visited.contains(next) && !dead.contains(next)) {\n                        visited.add(next);\n                        q.offer(next);\n                    }\n                }\n            }\n        }\n        moves++;\n    }\n\n    return -1;\n}\n\n",
            "python": "from collections import deque\n\ndef openLock(deadends, target):\n    dead = set(deadends)\n    visited = set()\n    q = deque([\"0000\"])\n\n    if \"0000\" in dead:\n        return -1\n\n    visited.add(\"0000\")\n    moves = 0\n\n    while q:\n        level_size = len(q)\n        for i in range(level_size):\n            cur = q.popleft()\n\n            if cur == target:\n                return moves\n\n            for j in range(4):\n                for k in [-1, 1]:\n                    next_val = cur[:j] + str((int(cur[j]) + k + 10) % 10) + cur[j + 1:]\n\n                    if next_val not in visited and next_val not in dead:\n                        visited.add(next_val)\n                        q.append(next_val)\n\n        moves += 1\n\n    return -1\n\n",
            "javascript": "var openLock = function(deadends, target) {\n    const dead = new Set(deadends);\n    const visited = new Set();\n    const queue = [\"0000\"];\n\n    if (dead.has(\"0000\")) return -1;\n\n    visited.add(\"0000\");\n    let moves = 0;\n\n    while (queue.length) {\n        let levelSize = queue.length;\n        for (let i = 0; i < levelSize; i++) {\n            let cur = queue.shift();\n\n            if (cur === target) return moves;\n\n            for (let j = 0; j < 4; j++) {\n                for (let k = -1; k <= 1; k += 2) {\n                    let next = cur.slice(0, j) + ((Number(cur[j]) + k + 10) % 10).toString() + cur.slice(j + 1);\n\n                    if (!visited.has(next) && !dead.has(next)) {\n                        visited.add(next);\n                        queue.push(next);\n                    }\n                }\n            }\n        }\n        moves++;\n    }\n\n    return -1;\n};\n\n",
            "explanation": "The algorithm uses a Breadth-First Search (BFS) approach to explore all possible combinations of the lock. We start with the initial state \"0000\". At each level, we change each wheel with one slot forward and one slot backward, and check the resulting combinations. If the combination isn't in the deadends and hasn't been visited before, it is added to the queue for further exploration. We continue exploring until the target is found or the queue is empty. The BFS ensures that the minimum number of turns are returned because it explores states level by level, where each level represents a certain number of turns. If the target is not found after the search, we return -1 indicating a failure to unlock the lock."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <queue>\n#include <set>\nusing namespace std;\n\nint openLock(vector<string>& deadends, string target) \n    // Your code here\n}\n\n",
            "java": "import java.util.*;\n\npublic int openLock(String[] deadends, String target) \n    // Your code here\n}\n\n",
            "python": "from collections import deque\n    # Your code here\n\n",
            "javascript": "var openLock = function(deadends, target) \n    // Your code here\n};\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <queue>\n#include <set>\nusing namespace std;\n\nint main() {\n    vector<string> deadends = $args;\n    string target = \"target_value\";\n    int result = openLock(deadends, target);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int openLock(String[] deadends, String target) {\n    Set<String> dead = new HashSet<>(Arrays.asList(deadends));\n    Set<String> visited = new HashSet<>();\n    Queue<String> q = new LinkedList<>();\n    String start = \"0000\";\n\n    if (dead.contains(start)) return -1;\n    q.offer(start);\n    visited.add(start);\n\n    int moves = 0;\n    while (!q.isEmpty()) {\n        int levelSize = q.size();\n        for (int i = 0; i < levelSize; i++) {\n            String cur = q.poll();\n\n            if (cur.equals(target)) return moves;\n\n            for (int j = 0; j < 4; j++) {\n                for (int k = -1; k <= 1; k += 2) {\n                    String next = cur.substring(0, j) + (char)((cur.charAt(j) - '0' + k + 10) % 10 + '0') + cur.substring(j + 1);\n\n                    if (!visited.contains(next) && !dead.contains(next)) {\n                        visited.add(next);\n                        q.offer(next);\n                    }\n                }\n            }\n        }\n        moves++;\n    }\n\n    return -1;\n}",
            "python": "if __name__ == \"__main__\":\n    deadends = $args[0]\n    target = $args[1]\n    result = openLock(deadends, target)\n    print(result)",
            "javascript": "var openLock = function(deadends, target) {\n    const dead = new Set(deadends);\n    const visited = new Set();\n    const queue = [\"0000\"];\n\n    if (dead.has(\"0000\")) return -1;\n\n    visited.add(\"0000\");\n    let moves = 0;\n\n    while (queue.length) {\n        let levelSize = queue.length;\n        for (let i = 0; i < levelSize; i++) {\n            let cur = queue.shift();\n\n            if (cur === target) return moves;\n\n            for (let j = 0; j < 4; j++) {\n                for (let k = -1; k <= 1; k += 2) {\n                    let next = cur.slice(0, j) + ((Number(cur[j]) + k + 10) % 10).toString() + cur.slice(j + 1);\n\n                    if (!visited.has(next) && !dead.has(next)) {\n                        visited.add(next);\n                        queue.push(next);\n                    }\n                }\n            }\n        }\n        moves++;\n    }\n\n    return -1;\n};\n\nconst deadends = $args[0];\nconst target = $args[1];\n\nconst result = openLock(deadends, target);\nconsole.log(result);"
        }
    },
    "753": {
        "title": "Safe Password Combination",
        "description": "You are given a safe protected by a password. The password is a sequence of `n` digits where each digit can be in the range `[0, k - 1]`. The safe checks the most recent `n` digits entered each time a digit is typed. Return any string of minimum length that will unlock the safe at some point of entering it.",
        "example": "For example, if the password is '345' and you enter '012345', the safe will unlock after typing '345'.\n\nInput: n = 1, k = 2\nOutput: '10'\nExplanation: The password is a single digit, so enter each digit. '01' would also unlock the safe.",
        "level": "Medium",
        "tags": [
            "String",
            "Backtracking"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2
                ],
                [
                    2,
                    2
                ],
                [
                    3,
                    3
                ],
                [
                    4,
                    4
                ],
                [
                    2,
                    3
                ],
                [
                    3,
                    2
                ],
                [
                    4,
                    10
                ],
                [
                    1,
                    1
                ],
                [
                    4,
                    1
                ],
                [
                    3,
                    4
                ],
                [
                    2,
                    5
                ],
                [
                    4,
                    3
                ],
                [
                    1,
                    10
                ],
                [
                    3,
                    1
                ],
                [
                    2,
                    4
                ],
                [
                    4,
                    2
                ],
                [
                    1,
                    3
                ],
                [
                    2,
                    1
                ],
                [
                    3,
                    10
                ],
                [
                    4,
                    5
                ]
            ],
            "outputs": [
                "10",
                "01100",
                "0120120",
                "0123012301230123",
                "0120120120120120",
                "0120120120120120",
                "0123456789012345678901234567890123456789",
                "0",
                "0123012301230123",
                "0120120120120120",
                "01234",
                "0123012301230123",
                "0123456789",
                "0",
                "0120120120120120",
                "01234",
                "0123012301230123",
                "0",
                "0123456789",
                "01234"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <queue>\n#include <unordered_set>\n\nint openLock(std::vector<std::string> &deadends, std::string target) {\n    std::unordered_set<std::string> dead(deadends.begin(), deadends.end());\n    std::unordered_set<std::string> visited;\n    std::queue<std::pair<std::string, int>> wheel_states;\n\n    if (dead.find(\"0000\") != dead.end()) return -1;\n    wheel_states.push({\"0000\", 0});\n    visited.insert(\"0000\");\n\n    while (!wheel_states.empty()) {\n        auto [current_state, turns] = wheel_states.front(); wheel_states.pop();\n\n        if (current_state == target) return turns;\n\n        for (int i = 0; i < 4; ++i) {\n            std::string up_state = current_state;\n            std::string down_state = current_state;\n            up_state[i] = (up_state[i] - '0' + 1) % 10 + '0';\n            down_state[i] = (down_state[i] - '0' + 9) % 10 + '0';\n\n            if (!visited.count(up_state) && !dead.count(up_state)) {\n                wheel_states.push({up_state, turns + 1});\n                visited.insert(up_state);\n            }\n\n            if (!visited.count(down_state) && !dead.count(down_state)) {\n                wheel_states.push({down_state, turns + 1});\n                visited.insert(down_state);\n            }\n        }\n    }\n    return -1;\n}\n",
            "java": "import java.util.*;\n\npublic int openLock(String[] deadends, String target) {\n    Set<String> dead = new HashSet<>(Arrays.asList(deadends));\n    Set<String> visited = new HashSet<>();\n    Queue<String[]> wheelStates = new LinkedList<>();\n\n    if (dead.contains(\"0000\")) return -1;\n    wheelStates.add(new String[]{\"0000\", \"0\"});\n    visited.add(\"0000\");\n\n    while (!wheelStates.isEmpty()) {\n        String[] currentStateTurn = wheelStates.poll();\n        String currentState = currentStateTurn[0];\n        int turns = Integer.parseInt(currentStateTurn[1]);\n\n        if (currentState.equals(target)) return turns;\n\n        for (int i = 0; i < 4; ++i) {\n            char[] upStateArr = currentState.toCharArray();\n            char[] downStateArr = currentState.toCharArray();\n            upStateArr[i] = (char)(((upStateArr[i] - '0' + 1) % 10) + '0');\n            downStateArr[i] = (char)(((downStateArr[i] - '0' + 9) % 10) + '0');\n            String upState = new String(upStateArr);\n            String downState = new String(downStateArr);\n\n            if (!visited.contains(upState) && !dead.contains(upState)) {\n                wheelStates.add(new String[]{upState, String.valueOf(turns + 1)});\n                visited.add(upState);\n            }\n\n            if (!visited.contains(downState) && !dead.contains(downState)) {\n                wheelStates.add(new String[]{downState, String.valueOf(turns + 1)});\n                visited.add(downState);\n            }\n        }\n    }\n    return -1;\n}\n",
            "python": "from collections import deque\n\ndef openLock(deadends, target):\n    dead = set(deadends)\n    visited = set()\n    wheel_states = deque([(\"0000\", 0)])\n\n    if \"0000\" in dead:\n        return -1\n\n    while wheel_states:\n        current_state, turns = wheel_states.popleft()\n\n        if current_state == target:\n            return turns\n\n        for i in range(4):\n            up_state = current_state[:i] + str((int(current_state[i]) + 1) % 10) + current_state[i + 1:]\n            down_state = current_state[:i] + str((int(current_state[i]) - 1) % 10) + current_state[i + 1:]\n\n            if up_state not in visited and up_state not in dead:\n                wheel_states.append((up_state, turns + 1))\n                visited.add(up_state)\n\n            if down_state not in visited and down_state not in dead:\n                wheel_states.append((down_state, turns + 1))\n                visited.add(down_state)\n\n    return -1\n",
            "javascript": "function openLock(deadends, target) {\n    const dead = new Set(deadends);\n    const visited = new Set();\n    const wheelStates = [[\"0000\", 0]];\n\n    if (dead.has(\"0000\")) return -1;\n\n    while (wheelStates.length > 0) {\n        const [currentState, turns] = wheelStates.shift();\n\n        if (currentState === target) return turns;\n\n        for (let i = 0; i < 4; ++i) {\n            const upState = currentState.slice(0, i) + ((parseInt(currentState[i]) + 1) % 10).toString() + currentState.slice(i + 1);\n            const downState = currentState.slice(0, i) + ((parseInt(currentState[i]) - 1 + 10) % 10).toString() + currentState.slice(i + 1);\n\n            if (!visited.has(upState) && !dead.has(upState)) {\n                wheelStates.push([upState, turns + 1]);\n                visited.add(upState);\n            }\n\n            if (!visited.has(downState) && !dead.has(downState)) {\n                wheelStates.push([downState, turns + 1]);\n                visited.add(downState);\n            }\n        }\n    }\n    return -1;\n}\n",
            "explanation": "The algorithm is based on a breadth-first search. We create sets for deadends and visited states, and a queue of wheel states with the number of turns for each state. If the starting state \"0000\" is in deadends, we return -1, as there is no solution. \n\nWe iterate while wheelStates is not empty. On each iteration, we check if the current state is equal to the target state, and return the number of turns if they are equal. Then, for each wheel of the state, we calculate the up state and down state by adding 1 or subtracting 1 from its position respectively (modulo 10). After that, if up_state or down_state are not visited and not in deadends, we add them to wheelStates with turns + 1. Finally, we add up_state and down_state in visited states.\n\nIf there is no solution, return -1 when the wheelStates queue becomes empty."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <queue>\n#include <unordered_set>\n\nint openLock(std::vector<std::string> &deadends, std::string target) \n    // Your code here\n}\n",
            "java": "import java.util.*;\n\npublic int openLock(String[] deadends, String target) \n    // Your code here\n}\n",
            "python": "from collections import deque\n    # Your code here\n\n",
            "javascript": "function openLock(deadends, target) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int openLock(std::vector<std::string> &deadends, std::string target) {\n    std::unordered_set<std::string> dead(deadends.begin(), deadends.end());\n    std::unordered_set<std::string> visited;\n    std::queue<std::pair<std::string, int>> wheel_states;\n\n    if (dead.find(\"0000\") != dead.end()) return -1;\n    wheel_states.push({\"0000\", 0});\n    visited.insert(\"0000\");\n\n    while (!wheel_states.empty()) {\n        auto [current_state, turns] = wheel_states.front(); wheel_states.pop();\n\n        if (current_state == target) return turns;\n\n        for (int i = 0; i < 4; ++i) {\n            std::string up_state = current_state;\n            std::string down_state = current_state;\n            up_state[i] = (up_state[i] - '0' + 1) % 10 + '0';\n            down_state[i] = (down_state[i] - '0' + 9) % 10 + '0';\n\n            if (!visited.count(up_state) && !dead.count(up_state)) {\n                wheel_states.push({up_state, turns + 1});\n                visited.insert(up_state);\n            }\n\n            if (!visited.count(down_state) && !dead.count(down_state)) {\n                wheel_states.push({down_state, turns + 1});\n                visited.insert(down_state);\n            }\n        }\n    }\n    return -1;\n}",
            "java": "public int openLock(String[] deadends, String target) {\n    Set<String> dead = new HashSet<>(Arrays.asList(deadends));\n    Set<String> visited = new HashSet<>();\n    Queue<String[]> wheelStates = new LinkedList<>();\n\n    if (dead.contains(\"0000\")) return -1;\n    wheelStates.add(new String[]{\"0000\", \"0\"});\n    visited.add(\"0000\");\n\n    while (!wheelStates.isEmpty()) {\n        String[] currentStateTurn = wheelStates.poll();\n        String currentState = currentStateTurn[0];\n        int turns = Integer.parseInt(currentStateTurn[1]);\n\n        if (currentState.equals(target)) return turns;\n\n        for (int i = 0; i < 4; ++i) {\n            char[] upStateArr = currentState.toCharArray();\n            char[] downStateArr = currentState.toCharArray();\n            upStateArr[i] = (char)(((upStateArr[i] - '0' + 1) % 10) + '0');\n            downStateArr[i] = (char)(((downStateArr[i] - '0' + 9) % 10) + '0');\n            String upState = new String(upStateArr);\n            String downState = new String(downStateArr);\n\n            if (!visited.contains(upState) && !dead.contains(upState)) {\n                wheelStates.add(new String[]{upState, String.valueOf(turns + 1)});\n                visited.add(upState);\n            }\n\n            if (!visited.contains(downState) && !dead.contains(downState)) {\n                wheelStates.add(new String[]{downState, String.valueOf(turns + 1)});\n                visited.add(downState);\n            }\n        }\n    }\n    return -1;\n}",
            "python": "if __name__ == \"__main__\":\n    deadends = $args[0]\n    target = $args[1]\n    result = openLock(deadends, target)\n    print(result)",
            "javascript": "function openLock(deadends, target) {\n    const dead = new Set(deadends);\n    const visited = new Set();\n    const wheelStates = [[\"0000\", 0]];\n\n    if (dead.has(\"0000\")) return -1;\n\n    while (wheelStates.length > 0) {\n        const [currentState, turns] = wheelStates.shift();\n\n        if (currentState === target) return turns;\n\n        for (let i = 0; i < 4; ++i) {\n            const upState = currentState.slice(0, i) + ((parseInt(currentState[i]) + 1) % 10).toString() + currentState.slice(i + 1);\n            const downState = currentState.slice(0, i) + ((parseInt(currentState[i]) - 1 + 10) % 10).toString() + currentState.slice(i + 1);\n\n            if (!visited.has(upState) && !dead.has(upState)) {\n                wheelStates.push([upState, turns + 1]);\n                visited.add(upState);\n            }\n\n            if (!visited.has(downState) && !dead.has(downState)) {\n                wheelStates.push([downState, turns + 1]);\n                visited.add(downState);\n            }\n        }\n    }\n    return -1;\n}"
        }
    },
    "754": {
        "title": "Minimum Moves to Reach Destination",
        "description": "You are standing at position `0` on an infinite number line. There is a destination at position `target`. You can make some number of moves `numMoves` so that on each move, you can either go left or right. During the `ith` move (starting from `i == 1` to `i == numMoves`), you take `i` steps in the chosen direction. Given the integer `target`, return the minimum number of moves required (i.e., the minimum `numMoves`) to reach the destination.",
        "example": "Example:\n\nInput: target = 2\nOutput: 3\nExplanation: On the 1st move, we step from 0 to 1 (1 step). On the 2nd move, we step from 1 to -1 (2 steps). On the 3rd move, we step from -1 to 2 (3 steps).",
        "level": "Medium",
        "tags": [
            "math",
            "greedy"
        ],
        "test_cases": {
            "inputs": [
                2,
                3,
                0,
                5,
                -2,
                10,
                -5,
                100,
                -100,
                999999,
                -999999,
                123456789,
                -987654321,
                1,
                -1,
                1000000000,
                -1000000000,
                123,
                -456,
                789
            ],
            "outputs": [
                3,
                2,
                0,
                3,
                3,
                4,
                3,
                14,
                14,
                1414,
                1414,
                15745,
                14142,
                1,
                1,
                44721,
                44721,
                15,
                15,
                39
            ]
        },
        "sample_code": {
            "c++": "int reachNumber(int target) {\n    target = abs(target);\n    int step = 0, sum = 0;\n    while (sum < target) {\n        step++;\n        sum += step;\n    }\n    while ((sum - target) % 2 != 0) {\n        step++;\n        sum += step;\n    }\n    return step;\n}\n\n",
            "java": "public int reachNumber(int target) {\n    target = Math.abs(target);\n    int step = 0, sum = 0;\n    while (sum < target) {\n        step++;\n        sum += step;\n    }\n    while ((sum - target) % 2 != 0) {\n        step++;\n        sum += step;\n    }\n    return step;\n}\n\n",
            "python": "def reachNumber(target: int) -> int:\n    target = abs(target)\n    step = 0\n    sum = 0\n    while sum < target:\n        step += 1\n        sum += step\n    while (sum - target) % 2 != 0:\n        step += 1\n        sum += step\n    return step\n\n",
            "javascript": "function reachNumber(target) {\n    target = Math.abs(target);\n    let step = 0, sum = 0;\n    while (sum < target) {\n        step++;\n        sum += step;\n    }\n    while ((sum - target) % 2 != 0) {\n        step++;\n        sum += step;\n    }\n    return step;\n}\n\n",
            "explanation": "1. Calculate the absolute value of `target` since reaching a negative target can be achieved similarly to reaching a positive target.\n2. Initialize the steps count `step` and a variable `sum` to store the sum of steps.\n3. Keep adding steps to `sum` until the `sum` is greater than or equal to the target.\n4. If the difference between the `sum` and the `target` is not divisible by 2, it means we haven't reached an even-numbered position or an odd-numbered position according to the parity of the `target`. If that's the case, increment `step` and add the new `step` to the `sum`.\n5. Repeat step 4 until the difference between the `sum` and the `target` is divisible by 2.\n6. Return the value of `step`."
        },
        "structure": {
            "c++": "int reachNumber(int target) \n    // Your code here\n}\n\n",
            "java": "public int reachNumber(int target) \n    // Your code here\n}\n\n",
            "python": "def reachNumber(target: int) -> int:\n    # Your code here\n\n",
            "javascript": "function reachNumber(target) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int target = $args;\n    int result = reachNumber(target);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int reachNumber(int target) {\n    target = Math.abs(target);\n    int step = 0, sum = 0;\n    while (sum < target) {\n        step++;\n        sum += step;\n    }\n    while ((sum - target) % 2 != 0) {\n        step++;\n        sum += step;\n    }\n    return step;\n}",
            "python": "if __name__ == \"__main__\":\n    target = $args[0]\n    result = reachNumber(target)\n    print(result)",
            "javascript": "function main() {\n    const target = $args;\n    const result = reachNumber(target);\n    console.log(result);\n}\n"
        }
    },
    "755": {
        "title": "Water Flow in Elevation Map",
        "description": "You are given an elevation map represented as an integer array `heights`, where `heights[i]` represents the height of the terrain at index `i`. The width at each index is `1`. You are also given two integers `volume` and `k`. `volume` units of water will fall at index `k`.\n\nWater first drops at the index `k` and rests on top of the highest terrain or water at that index. Then, it flows according to the following rules:\n\n- If the droplet would eventually fall by moving left, then move left.\n- Otherwise, if the droplet would eventually fall by moving right, then move right.\n- Otherwise, rise to its current position.\n\nHere, **'eventually fall'** means that the droplet will eventually be at a lower level if it moves in that direction. Also, level means the height of the terrain plus any water in that column.\n\nWe can assume there is infinitely high terrain on the two sides out of bounds of the array. Also, there could not be partial water being spread out evenly on more than one grid block, and each unit of water has to be in exactly one block.",
        "example": "Example:\n\nInput: heights = [2,1,1,2,1,2,2], volume = 4, k = 3\nOutput: [2,2,2,3,2,2,2]\nExplanation:\nThe first drop of water lands at index k = 3. When moving left or right, the water can only move to the same level or a lower level. Since moving left will eventually make it fall, it moves left. Since moving left will not make it fall, it stays in place.\n\nThe next droplet falls at index k = 3. Since the new droplet moving left will eventually make it fall, it moves left. Notice that the droplet still preferred to move left, even though it could move right (and moving right makes it fall quicker).\n\nThe third droplet falls at index k = 3. Since moving left would not eventually make it fall, it tries to move right. Since moving right would eventually make it fall, it moves right.\n\nFinally, the fourth droplet falls at index k = 3. Since moving left would not eventually make it fall, it tries to move right. Since moving right would not eventually make it fall, it stays in place.",
        "level": "Medium",
        "tags": [
            "array",
            "simulation"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        2,
                        1,
                        1,
                        2,
                        1,
                        2,
                        2
                    ],
                    4,
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    2,
                    2
                ],
                [
                    [
                        3,
                        1,
                        3
                    ],
                    5,
                    1
                ],
                [
                    [
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    10,
                    2
                ],
                [
                    [
                        5,
                        4,
                        3,
                        2,
                        1
                    ],
                    3,
                    0
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    5,
                    2
                ],
                [
                    [
                        2,
                        2,
                        2,
                        2,
                        2
                    ],
                    0,
                    4
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1,
                    3
                ],
                [
                    [
                        5,
                        4,
                        3,
                        2,
                        1
                    ],
                    10,
                    4
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    0,
                    0
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    0,
                    2
                ],
                [
                    [
                        2,
                        2,
                        2,
                        2,
                        2
                    ],
                    5,
                    4
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    3,
                    3
                ],
                [
                    [
                        5,
                        4,
                        3,
                        2,
                        1
                    ],
                    1,
                    4
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    10,
                    0
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    5,
                    2
                ],
                [
                    [
                        2,
                        2,
                        2,
                        2,
                        2
                    ],
                    0,
                    4
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1,
                    3
                ],
                [
                    [
                        5,
                        4,
                        3,
                        2,
                        1
                    ],
                    10,
                    4
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    0,
                    0
                ]
            ],
            "outputs": [
                [
                    2,
                    2,
                    2,
                    3,
                    2,
                    2,
                    2
                ],
                [
                    2,
                    3,
                    3,
                    4
                ],
                [
                    4,
                    4,
                    4
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ]
            ]
        },
        "sample_code": {
            "c++": "int min_moves(int target) {\n    target = abs(target);\n    int step = 0;\n    int sum = 0;\n    while (sum < target || (sum - target) % 2 == 1) {\n        step++;\n        sum += step;\n    }\n    return step;\n}\n\n",
            "java": "public int minMoves(int target) {\n    target = Math.abs(target);\n    int step = 0;\n    int sum = 0;\n    while (sum < target || (sum - target) % 2 != 0) {\n        step++;\n        sum += step;\n    }\n    return step;\n}\n\n",
            "python": "def min_moves(target: int) -> int:\n    target = abs(target)\n    step = 0\n    total = 0\n    while total < target or (total - target) % 2 != 0:\n        step += 1\n        total += step\n    return step\n\n",
            "javascript": "function minMoves(target) {\n    target = Math.abs(target);\n    let step = 0;\n    let sum = 0;\n    while (sum < target || (sum - target) % 2 !== 0) {\n        step++;\n        sum += step;\n    }\n    return step;\n}\n\n",
            "explanation": "The algorithm works as follows:\n1. Make sure the target is a positive integer by taking its absolute value.\n2. Initialize the `step` and `sum` variables to 0.\n3. Keep incrementing the `step` value by 1 and add it to the `sum` until the following condition is satisfied: `(sum >= target) && ((sum - target) % 2 == 0)`\n4. Return the minimum number of steps required to reach the destination, which will be the value of `step` at the end of the loop."
        },
        "structure": {
            "c++": "int min_moves(int target) \n    // Your code here\n}\n\n",
            "java": "public int minMoves(int target) \n    // Your code here\n}\n\n",
            "python": "def min_moves(target: int) -> int:\n    # Your code here\n\n",
            "javascript": "function minMoves(target) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int target = $args;\n    int result = min_moves(target);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int minMoves(int target) {\n    target = Math.abs(target);\n    int step = 0;\n    int sum = 0;\n    while (sum < target || (sum - target) % 2 != 0) {\n        step++;\n        sum += step;\n    }\n    return step;\n}",
            "python": "if __name__ == \"__main__\":\n    target = $args[0]\n    result = min_moves(target)\n    print(result)",
            "javascript": "function main() {\n    const target = $args;\n    const result = minMoves(target);\n    console.log(result);\n}\n"
        }
    },
    "756": {
        "title": "Pyramid Block Stacking",
        "description": "You are stacking blocks to form a pyramid. Each block has a color, which is represented by a single letter. Each row of blocks contains one less block than the row beneath it and is centered on top. To make the pyramid aesthetically pleasing, there are only specific triangular patterns that are allowed. A triangular pattern consists of a single block stacked on top of two blocks. The patterns are given as a list of three-letter strings `allowed`, where the first two characters of a pattern represent the left and right bottom blocks respectively, and the third character is the top block. You start with a bottom row of blocks `bottom`, given as a single string, that you must use as the base of the pyramid. Given `bottom` and `allowed`, return true if you can build the pyramid all the way to the top such that every triangular pattern in the pyramid is in `allowed`, or false otherwise.",
        "example": "Example:\n\nInput: bottom = \"BCD \", allowed = [ \"BCC \", \"CDE \", \"CEA \", \"FFF \"]\nOutput: true\nExplanation: The allowed triangular patterns are shown on the right. Starting from the bottom (level 3), we can build  \"CE \" on level 2 and then build  \"A \" on level 1. There are three triangular patterns in the pyramid, which are  \"BCC \",  \"CDE \", and  \"CEA \". All are allowed.",
        "level": "Medium",
        "tags": [
            "stack",
            "recursion",
            "backtracking"
        ],
        "test_cases": {
            "inputs": [
                "\"BCD \"",
                "\"AAAA \"",
                "\"AB \"",
                "\"CDE \"",
                "\"FFF \""
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                false
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <vector>\n#include <unordered_map>\n\nbool pyramidTransitionHelper(std::string& bottom, std::string& top, int idx, std::unordered_map<std::string, std::vector<char>>& mapping) {\n    if (bottom.length() == 1) return true;\n    if (idx == bottom.length() - 1) return pyramidTransitionHelper(top, \"\", 0, mapping);\n    std::string key = bottom.substr(idx, 2);\n    if (mapping.find(key) == mapping.end()) return false;\n    for (char c : mapping[key]) {\n        top.push_back(c);\n        if (pyramidTransitionHelper(bottom, top, idx + 1, mapping)) return true;\n        top.pop_back();\n    }\n    return false;\n}\n\nbool pyramidTransition(std::string bottom, std::vector<std::string>& allowed) {\n    std::unordered_map<std::string, std::vector<char>> mapping;\n    for (const auto& s : allowed) mapping[s.substr(0, 2)].push_back(s[2]);\n    return pyramidTransitionHelper(bottom, \"\", 0, mapping);\n}\n\n",
            "java": "import java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic boolean pyramidTransition(String bottom, List<String> allowed) {\n    Map<String, List<Character>> mapping = new HashMap<>();\n    for (String s : allowed) {\n        mapping.computeIfAbsent(s.substring(0, 2), k -> new ArrayList<>()).add(s.charAt(2));\n    }\n    return pyramidTransitionHelper(bottom, \"\", 0, mapping);\n}\n\nprivate boolean pyramidTransitionHelper(String bottom, String top, int idx, Map<String, List<Character>> mapping) {\n    if (bottom.length() == 1) return true;\n    if (idx == bottom.length() - 1) return pyramidTransitionHelper(top, \"\", 0, mapping);\n    String key = bottom.substring(idx, idx + 2);\n    if (!mapping.containsKey(key)) return false;\n    for (Character c : mapping.get(key)) {\n        if (pyramidTransitionHelper(bottom, top + c, idx + 1, mapping)) return true;\n    }\n    return false;\n}\n\n",
            "python": "def pyramid_transition(bottom, allowed):\n    mapping = {}\n    for s in allowed:\n        key = s[:2]\n        if key not in mapping:\n            mapping[key] = []\n        mapping[key].append(s[2])\n    return pyramid_transition_helper(bottom, \"\", 0, mapping)\n\ndef pyramid_transition_helper(bottom, top, idx, mapping):\n    if len(bottom) == 1:\n        return True\n    if idx == len(bottom) - 1:\n        return pyramid_transition_helper(top, \"\", 0, mapping)\n    key = bottom[idx:idx + 2]\n    if key not in mapping:\n        return False\n    for c in mapping[key]:\n        if pyramid_transition_helper(bottom, top + c, idx + 1, mapping):\n            return True\n    return False\n\n",
            "javascript": "function pyramidTransition(bottom, allowed) {\n    const mapping = {};\n    for (const s of allowed) {\n        const key = s.substr(0, 2);\n        if (!(key in mapping)) mapping[key] = [];\n        mapping[key].push(s[2]);\n    }\n    return pyramidTransitionHelper(bottom, '', 0, mapping);\n}\n\nfunction pyramidTransitionHelper(bottom, top, idx, mapping) {\n    if (bottom.length === 1) return true;\n    if (idx === bottom.length - 1) return pyramidTransitionHelper(top, '', 0, mapping);\n    const key = bottom.substr(idx, 2);\n    if (!(key in mapping)) return false;\n    for (const c of mapping[key]) {\n        if (pyramidTransitionHelper(bottom, top + c, idx + 1, mapping)) return true;\n    }\n    return false;\n}\n\n",
            "explanation": "We first create a mapping from two-character keys to the list of possible top characters for a triangle. Then, we use a recursive helper function to build the pyramid. If the bottom row's length reaches 1, it means the pyramid is complete and we return true. If the index reaches the bottom length minus 1, we have just completed one level of the pyramid and need to continue for the next level. At each step, we try different allowed triangles and continue the recursion. If any allowed character leads to a successful pyramid, we return true. If there is no possible combination left, we return false."
        },
        "structure": {
            "c++": "#include <string>\n#include <vector>\n#include <unordered_map>\n\nbool pyramidTransitionHelper(std::string& bottom, std::string& top, int idx, std::unordered_map<std::string, std::vector<char>>& mapping) \n    // Your code here\n}\n\n",
            "java": "import java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic boolean pyramidTransition(String bottom, List<String> allowed) \n    // Your code here\n}\n\n",
            "python": "def pyramid_transition(bottom, allowed):\n    # Your code here\n\n",
            "javascript": "function pyramidTransition(bottom, allowed) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "bool pyramidTransition(std::string bottom, std::vector<std::string>& allowed) {\n    std::unordered_map<std::string, std::vector<char>> mapping;\n    for (const auto& s : allowed) mapping[s.substr(0, 2)].push_back(s[2]);\n    return pyramidTransitionHelper(bottom, \"\", 0, mapping);\n}",
            "java": "public boolean pyramidTransition(String bottom, List<String> allowed) {\n    Map<String, List<Character>> mapping = new HashMap<>();\n    for (String s : allowed) {\n        mapping.computeIfAbsent(s.substring(0, 2), k -> new ArrayList<>()).add(s.charAt(2));\n    }\n    return pyramidTransitionHelper(bottom, \"\", 0, mapping);\n}\n\nprivate boolean pyramidTransitionHelper(String bottom, String top, int idx, Map<String, List<Character>> mapping) {\n    if (bottom.length() == 1) return true;\n    if (idx == bottom.length() - 1) return pyramidTransitionHelper(top, \"\", 0, mapping);\n    String key = bottom.substring(idx, idx + 2);\n    if (!mapping.containsKey(key)) return false;\n    for (Character c : mapping.get(key)) {\n        if (pyramidTransitionHelper(bottom, top + c, idx + 1, mapping)) return true;\n    }\n    return false;\n}",
            "python": "if __name__ == \"__main__\":\n    bottom = $args[0]\n    allowed = $args[1]\n    result = pyramid_transition(bottom, allowed)\n    print(result)",
            "javascript": "function main() {\n    const bottom = $args[0];\n    const allowed = $args[1];\n    const result = pyramidTransition(bottom, allowed);\n    console.log(result);\n}"
        }
    },
    "757": {
        "title": "Minimum Size of Containing Set",
        "description": "You are given a 2D integer array `intervals` where `intervals[i] = [starti, endi]` represents all the integers from `starti` to `endi` inclusively. A **containing set** is an array `nums` where each interval from `intervals` has **at least two** integers in `nums`. Return the minimum possible size of a containing set.",
        "example": "Example:\n\nInput: intervals = [[1,3],[3,7],[8,9]]\nOutput: 5\nExplanation: Let nums = [2, 3, 4, 8, 9]. It can be shown that there cannot be any containing array of size 4.",
        "level": "Medium",
        "tags": [
            "array",
            "interval"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        3
                    ],
                    [
                        3,
                        7
                    ],
                    [
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        3
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        5
                    ],
                    [
                        3,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        6,
                        8
                    ],
                    [
                        7,
                        9
                    ]
                ],
                [
                    [
                        10,
                        15
                    ],
                    [
                        12,
                        14
                    ],
                    [
                        16,
                        18
                    ],
                    [
                        17,
                        19
                    ]
                ],
                [
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        100
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        100
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        10,
                        20
                    ]
                ],
                [
                    [
                        1,
                        100
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        10,
                        20
                    ],
                    [
                        21,
                        30
                    ]
                ],
                [
                    [
                        1,
                        100
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        10,
                        20
                    ],
                    [
                        21,
                        30
                    ],
                    [
                        31,
                        40
                    ]
                ],
                [
                    [
                        1,
                        100
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        10,
                        20
                    ],
                    [
                        21,
                        30
                    ],
                    [
                        31,
                        40
                    ],
                    [
                        41,
                        50
                    ]
                ],
                [
                    [
                        1,
                        100
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        10,
                        20
                    ],
                    [
                        21,
                        30
                    ],
                    [
                        31,
                        40
                    ],
                    [
                        41,
                        50
                    ],
                    [
                        51,
                        60
                    ]
                ],
                [
                    [
                        1,
                        100
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        10,
                        20
                    ],
                    [
                        21,
                        30
                    ],
                    [
                        31,
                        40
                    ],
                    [
                        41,
                        50
                    ],
                    [
                        51,
                        60
                    ],
                    [
                        61,
                        70
                    ]
                ],
                [
                    [
                        1,
                        100
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        10,
                        20
                    ],
                    [
                        21,
                        30
                    ],
                    [
                        31,
                        40
                    ],
                    [
                        41,
                        50
                    ],
                    [
                        51,
                        60
                    ],
                    [
                        61,
                        70
                    ],
                    [
                        71,
                        80
                    ]
                ],
                [
                    [
                        1,
                        100
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        10,
                        20
                    ],
                    [
                        21,
                        30
                    ],
                    [
                        31,
                        40
                    ],
                    [
                        41,
                        50
                    ],
                    [
                        51,
                        60
                    ],
                    [
                        61,
                        70
                    ],
                    [
                        71,
                        80
                    ],
                    [
                        81,
                        90
                    ]
                ],
                [
                    [
                        1,
                        100
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        10,
                        20
                    ],
                    [
                        21,
                        30
                    ],
                    [
                        31,
                        40
                    ],
                    [
                        41,
                        50
                    ],
                    [
                        51,
                        60
                    ],
                    [
                        61,
                        70
                    ],
                    [
                        71,
                        80
                    ],
                    [
                        81,
                        90
                    ],
                    [
                        91,
                        100
                    ]
                ],
                [
                    [
                        1,
                        100
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        10,
                        20
                    ],
                    [
                        21,
                        30
                    ],
                    [
                        31,
                        40
                    ],
                    [
                        41,
                        50
                    ],
                    [
                        51,
                        60
                    ],
                    [
                        61,
                        70
                    ],
                    [
                        71,
                        80
                    ],
                    [
                        81,
                        90
                    ],
                    [
                        91,
                        100
                    ],
                    [
                        101,
                        200
                    ]
                ],
                [
                    [
                        1,
                        100
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        10,
                        20
                    ],
                    [
                        21,
                        30
                    ],
                    [
                        31,
                        40
                    ],
                    [
                        41,
                        50
                    ],
                    [
                        51,
                        60
                    ],
                    [
                        61,
                        70
                    ],
                    [
                        71,
                        80
                    ],
                    [
                        81,
                        90
                    ],
                    [
                        91,
                        100
                    ],
                    [
                        101,
                        200
                    ],
                    [
                        201,
                        300
                    ]
                ],
                [
                    [
                        1,
                        100
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        10,
                        20
                    ],
                    [
                        21,
                        30
                    ],
                    [
                        31,
                        40
                    ],
                    [
                        41,
                        50
                    ],
                    [
                        51,
                        60
                    ],
                    [
                        61,
                        70
                    ],
                    [
                        71,
                        80
                    ],
                    [
                        81,
                        90
                    ],
                    [
                        91,
                        100
                    ],
                    [
                        101,
                        200
                    ],
                    [
                        201,
                        300
                    ],
                    [
                        301,
                        400
                    ]
                ],
                [
                    [
                        1,
                        100
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        10,
                        20
                    ],
                    [
                        21,
                        30
                    ],
                    [
                        31,
                        40
                    ],
                    [
                        41,
                        50
                    ],
                    [
                        51,
                        60
                    ],
                    [
                        61,
                        70
                    ],
                    [
                        71,
                        80
                    ],
                    [
                        81,
                        90
                    ],
                    [
                        91,
                        100
                    ],
                    [
                        101,
                        200
                    ],
                    [
                        201,
                        300
                    ],
                    [
                        301,
                        400
                    ],
                    [
                        401,
                        500
                    ]
                ]
            ],
            "outputs": [
                5,
                3,
                5,
                7,
                7,
                10,
                10,
                100,
                100,
                100,
                100,
                100,
                100,
                100,
                100,
                100,
                100,
                100,
                100,
                100
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <unordered_map>\n#include <vector>\n\nbool dfs(std::string curr, std::string bottom, std::unordered_map<std::string, std::vector<char>>& mapping) {\n    if (bottom.size() == 1) return true;\n\n    for (int i = 0; i < bottom.size() - 1; ++i) {\n        std::string s = bottom.substr(i, 2);\n        if (mapping.count(s) == 0) return false;\n    }\n\n    curr = \"\";\n    for (int i = 0; i < bottom.size() - 1; ++i) {\n        curr += mapping[bottom.substr(i, 2)][0];\n    }\n\n    return dfs(curr, curr, mapping);\n}\n\nbool pyramidTransition(std::string bottom, std::vector<std::string>& allowed) {\n    std::unordered_map<std::string, std::vector<char>> mapping;\n    for (std::string& s : allowed) {\n        mapping[s.substr(0, 2)].emplace_back(s[2]);\n    }\n    return dfs(\"\", bottom, mapping);\n}\n\n",
            "java": "import java.util.*;\n\npublic boolean pyramidTransition(String bottom, List<String> allowed) {\n    Map<String, List<Character>> mapping = new HashMap<>();\n    for (String s : allowed) {\n        String key = s.substring(0, 2);\n        if (!mapping.containsKey(key)) {\n            mapping.put(key, new ArrayList<>());\n        }\n        mapping.get(key).add(s.charAt(2));\n    }\n    return dfs(\"\", bottom, mapping);\n}\n\npublic boolean dfs(String curr, String bottom, Map<String, List<Character>> mapping) {\n    if (bottom.length() == 1) return true;\n    for (int i = 0; i < bottom.length() - 1; ++i) {\n        if (!mapping.containsKey(bottom.substring(i, i + 2))) return false;\n    }\n    curr = \"\";\n    for (int i = 0; i < bottom.length() - 1; ++i) {\n        curr += mapping.get(bottom.substring(i, i + 2)).get(0);\n    }\n    return dfs(curr, curr, mapping);\n}\n\n",
            "python": "from collections import defaultdict\n\ndef pyramidTransition(bottom, allowed):\n    mapping = defaultdict(list)\n    for s in allowed:\n        mapping[s[:2]].append(s[2])\n    return dfs(\"\", bottom, mapping)\n\ndef dfs(curr, bottom, mapping):\n    if len(bottom) == 1:\n        return True\n    for i in range(len(bottom) - 1):\n        if bottom[i:i+2] not in mapping:\n            return False\n    curr = \"\".join(mapping[bottom[i:i + 2]][0] for i in range(len(bottom) - 1))\n    return dfs(curr, curr, mapping)\n\n",
            "javascript": "function pyramidTransition(bottom, allowed) {\n    const mapping = {};\n    for (const s of allowed) {\n        const key = s.slice(0, 2);\n        if (!(key in mapping)) {\n            mapping[key] = [];\n        }\n        mapping[key].push(s[2]);\n    }\n    return dfs(\"\", bottom, mapping);\n}\n\nfunction dfs(curr, bottom, mapping) {\n    if (bottom.length === 1) {\n        return true;\n    }\n    for (let i = 0; i < bottom.length - 1; ++i) {\n        if (!(bottom.slice(i, i + 2) in mapping)) {\n            return false;\n        }\n    }\n    curr = \"\";\n    for (let i = 0; i < bottom.length - 1; ++i) {\n        curr += mapping[bottom.slice(i, i + 2)][0];\n    }\n    return dfs(curr, curr, mapping);\n}\n\n",
            "explanation": "1. Create a mapping, with the allowed patterns, which maps bottom two characters of allowed string to their respective top character.\n2. Define a function dfs, which loops through the current bottom to find the mapping for the subsequent row.\n3. If it can create a subsequent row fully from the mappings without any error, it calls the dfs again recursively with the new row as the bottom row.\n4. If, finally, a single character row(bottom.length==1) is formed at the top, it returns true; otherwise, it returns false.\n5. Call dfs with the original bottom row and return the result."
        },
        "structure": {
            "c++": "#include <string>\n#include <unordered_map>\n#include <vector>\n\nbool dfs(std::string curr, std::string bottom, std::unordered_map<std::string, std::vector<char>>& mapping) \n    // Your code here\n}\n\n",
            "java": "import java.util.*;\n\npublic boolean pyramidTransition(String bottom, List<String> allowed) \n    // Your code here\n}\n\n",
            "python": "from collections import defaultdict\n    # Your code here\n\n",
            "javascript": "function pyramidTransition(bottom, allowed) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <unordered_map>\n#include <vector>\n#include <iostream>\n\nbool dfs(std::string curr, std::string bottom, std::unordered_map<std::string, std::vector<char>>& mapping) {\n    if (bottom.size() == 1) return true;\n\n    for (int i = 0; i < bottom.size() - 1; ++i) {\n        std::string s = bottom.substr(i, 2);\n        if (mapping.count(s) == 0) return false;\n    }\n\n    curr = \"\";\n    for (int i = 0; i < bottom.size() - 1; ++i) {\n        curr += mapping[bottom.substr(i, 2)][0];\n    }\n\n    return dfs(curr, curr, mapping);\n}\n\nbool pyramidTransition(std::string bottom, std::vector<std::string>& allowed) {\n    std::unordered_map<std::string, std::vector<char>> mapping;\n    for (std::string& s : allowed) {\n        mapping[s.substr(0, 2)].emplace_back(s[2]);\n    }\n    return dfs(\"\", bottom, mapping);\n}\n\nint main() {\n    std::string bottom = $args;\n    std::vector<std::string> allowed = {};\n    bool result = pyramidTransition(bottom, allowed);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}\n",
            "java": "public boolean pyramidTransition(String bottom, List<String> allowed) {\n    Map<String, List<Character>> mapping = new HashMap<>();\n    for (String s : allowed) {\n        String key = s.substring(0, 2);\n        if (!mapping.containsKey(key)) {\n            mapping.put(key, new ArrayList<>());\n        }\n        mapping.get(key).add(s.charAt(2));\n    }\n    return dfs(\"\", bottom, mapping);\n}\n\npublic boolean dfs(String curr, String bottom, Map<String, List<Character>> mapping) {\n    if (bottom.length() == 1) return true;\n    for (int i = 0; i < bottom.length() - 1; ++i) {\n        if (!mapping.containsKey(bottom.substring(i, i + 2))) return false;\n    }\n    curr = \"\";\n    for (int i = 0; i < bottom.length() - 1; ++i) {\n        curr += mapping.get(bottom.substring(i, i + 2)).get(0);\n    }\n    return dfs(curr, curr, mapping);\n}",
            "python": "if __name__ == \"__main__\":\n    bottom = $args[0]\n    allowed = $args[1]\n    result = pyramidTransition(bottom, allowed)\n    print(result)",
            "javascript": "function main() {\n    const bottom = $args[0];\n    const allowed = $args[1];\n    const result = pyramidTransition(bottom, allowed);\n    console.log(result);\n}"
        }
    },
    "759": {
        "title": "Common Free Time",
        "description": "Given a list of employees' schedules, each represented by a list of non-overlapping intervals in sorted order, find the common, positive-length free time for all employees. Return the list of finite intervals representing the common free time, sorted in ascending order. Exclude intervals with zero length.",
        "example": "Example:\n\nInput: schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]\nOutput: [[3,4]]\nExplanation: There are three employees, and the common free time intervals are [-inf, 1], [3, 4], [10, inf]. Intervals containing inf are discarded as they are not finite.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        [
                            1,
                            2
                        ],
                        [
                            5,
                            6
                        ]
                    ],
                    [
                        [
                            1,
                            3
                        ]
                    ],
                    [
                        [
                            4,
                            10
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            3
                        ],
                        [
                            6,
                            7
                        ]
                    ],
                    [
                        [
                            2,
                            4
                        ]
                    ],
                    [
                        [
                            2,
                            5
                        ],
                        [
                            9,
                            12
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    [
                        [
                            5,
                            6
                        ],
                        [
                            7,
                            8
                        ]
                    ],
                    [
                        [
                            9,
                            10
                        ],
                        [
                            11,
                            12
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            5
                        ]
                    ],
                    [
                        [
                            2,
                            3
                        ]
                    ],
                    [
                        [
                            4,
                            6
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    [
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            5
                        ]
                    ],
                    [
                        [
                            3,
                            4
                        ],
                        [
                            5,
                            6
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    [
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            5
                        ]
                    ],
                    [
                        [
                            3,
                            4
                        ],
                        [
                            5,
                            6
                        ]
                    ],
                    [
                        [
                            6,
                            7
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    [
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            5
                        ]
                    ],
                    [
                        [
                            3,
                            4
                        ],
                        [
                            5,
                            6
                        ]
                    ],
                    [
                        [
                            6,
                            7
                        ]
                    ],
                    [
                        [
                            8,
                            9
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    [
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            5
                        ]
                    ],
                    [
                        [
                            3,
                            4
                        ],
                        [
                            5,
                            6
                        ]
                    ],
                    [
                        [
                            6,
                            7
                        ]
                    ],
                    [
                        [
                            8,
                            9
                        ]
                    ],
                    [
                        [
                            10,
                            11
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    [
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            5
                        ]
                    ],
                    [
                        [
                            3,
                            4
                        ],
                        [
                            5,
                            6
                        ]
                    ],
                    [
                        [
                            6,
                            7
                        ]
                    ],
                    [
                        [
                            8,
                            9
                        ]
                    ],
                    [
                        [
                            10,
                            11
                        ]
                    ],
                    [
                        [
                            12,
                            13
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    [
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            5
                        ]
                    ],
                    [
                        [
                            3,
                            4
                        ],
                        [
                            5,
                            6
                        ]
                    ],
                    [
                        [
                            6,
                            7
                        ]
                    ],
                    [
                        [
                            8,
                            9
                        ]
                    ],
                    [
                        [
                            10,
                            11
                        ]
                    ],
                    [
                        [
                            12,
                            13
                        ]
                    ],
                    [
                        [
                            14,
                            15
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    [
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            5
                        ]
                    ],
                    [
                        [
                            3,
                            4
                        ],
                        [
                            5,
                            6
                        ]
                    ],
                    [
                        [
                            6,
                            7
                        ]
                    ],
                    [
                        [
                            8,
                            9
                        ]
                    ],
                    [
                        [
                            10,
                            11
                        ]
                    ],
                    [
                        [
                            12,
                            13
                        ]
                    ],
                    [
                        [
                            14,
                            15
                        ]
                    ],
                    [
                        [
                            16,
                            17
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    [
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            5
                        ]
                    ],
                    [
                        [
                            3,
                            4
                        ],
                        [
                            5,
                            6
                        ]
                    ],
                    [
                        [
                            6,
                            7
                        ]
                    ],
                    [
                        [
                            8,
                            9
                        ]
                    ],
                    [
                        [
                            10,
                            11
                        ]
                    ],
                    [
                        [
                            12,
                            13
                        ]
                    ],
                    [
                        [
                            14,
                            15
                        ]
                    ],
                    [
                        [
                            16,
                            17
                        ]
                    ],
                    [
                        [
                            18,
                            19
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    [
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            5
                        ]
                    ],
                    [
                        [
                            3,
                            4
                        ],
                        [
                            5,
                            6
                        ]
                    ],
                    [
                        [
                            6,
                            7
                        ]
                    ],
                    [
                        [
                            8,
                            9
                        ]
                    ],
                    [
                        [
                            10,
                            11
                        ]
                    ],
                    [
                        [
                            12,
                            13
                        ]
                    ],
                    [
                        [
                            14,
                            15
                        ]
                    ],
                    [
                        [
                            16,
                            17
                        ]
                    ],
                    [
                        [
                            18,
                            19
                        ]
                    ],
                    [
                        [
                            20,
                            21
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    [
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            5
                        ]
                    ],
                    [
                        [
                            3,
                            4
                        ],
                        [
                            5,
                            6
                        ]
                    ],
                    [
                        [
                            6,
                            7
                        ]
                    ],
                    [
                        [
                            8,
                            9
                        ]
                    ],
                    [
                        [
                            10,
                            11
                        ]
                    ],
                    [
                        [
                            12,
                            13
                        ]
                    ],
                    [
                        [
                            14,
                            15
                        ]
                    ],
                    [
                        [
                            16,
                            17
                        ]
                    ],
                    [
                        [
                            18,
                            19
                        ]
                    ],
                    [
                        [
                            20,
                            21
                        ]
                    ],
                    [
                        [
                            22,
                            23
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    [
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            5
                        ]
                    ],
                    [
                        [
                            3,
                            4
                        ],
                        [
                            5,
                            6
                        ]
                    ],
                    [
                        [
                            6,
                            7
                        ]
                    ],
                    [
                        [
                            8,
                            9
                        ]
                    ],
                    [
                        [
                            10,
                            11
                        ]
                    ],
                    [
                        [
                            12,
                            13
                        ]
                    ],
                    [
                        [
                            14,
                            15
                        ]
                    ],
                    [
                        [
                            16,
                            17
                        ]
                    ],
                    [
                        [
                            18,
                            19
                        ]
                    ],
                    [
                        [
                            20,
                            21
                        ]
                    ],
                    [
                        [
                            22,
                            23
                        ]
                    ],
                    [
                        [
                            24,
                            25
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    [
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            5
                        ]
                    ],
                    [
                        [
                            3,
                            4
                        ],
                        [
                            5,
                            6
                        ]
                    ],
                    [
                        [
                            6,
                            7
                        ]
                    ],
                    [
                        [
                            8,
                            9
                        ]
                    ],
                    [
                        [
                            10,
                            11
                        ]
                    ],
                    [
                        [
                            12,
                            13
                        ]
                    ],
                    [
                        [
                            14,
                            15
                        ]
                    ],
                    [
                        [
                            16,
                            17
                        ]
                    ],
                    [
                        [
                            18,
                            19
                        ]
                    ],
                    [
                        [
                            20,
                            21
                        ]
                    ],
                    [
                        [
                            22,
                            23
                        ]
                    ],
                    [
                        [
                            24,
                            25
                        ]
                    ],
                    [
                        [
                            26,
                            27
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    [
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            5
                        ]
                    ],
                    [
                        [
                            3,
                            4
                        ],
                        [
                            5,
                            6
                        ]
                    ],
                    [
                        [
                            6,
                            7
                        ]
                    ],
                    [
                        [
                            8,
                            9
                        ]
                    ],
                    [
                        [
                            10,
                            11
                        ]
                    ],
                    [
                        [
                            12,
                            13
                        ]
                    ],
                    [
                        [
                            14,
                            15
                        ]
                    ],
                    [
                        [
                            16,
                            17
                        ]
                    ],
                    [
                        [
                            18,
                            19
                        ]
                    ],
                    [
                        [
                            20,
                            21
                        ]
                    ],
                    [
                        [
                            22,
                            23
                        ]
                    ],
                    [
                        [
                            24,
                            25
                        ]
                    ],
                    [
                        [
                            26,
                            27
                        ]
                    ],
                    [
                        [
                            28,
                            29
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    [
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            5
                        ]
                    ],
                    [
                        [
                            3,
                            4
                        ],
                        [
                            5,
                            6
                        ]
                    ],
                    [
                        [
                            6,
                            7
                        ]
                    ],
                    [
                        [
                            8,
                            9
                        ]
                    ],
                    [
                        [
                            10,
                            11
                        ]
                    ],
                    [
                        [
                            12,
                            13
                        ]
                    ],
                    [
                        [
                            14,
                            15
                        ]
                    ],
                    [
                        [
                            16,
                            17
                        ]
                    ],
                    [
                        [
                            18,
                            19
                        ]
                    ],
                    [
                        [
                            20,
                            21
                        ]
                    ],
                    [
                        [
                            22,
                            23
                        ]
                    ],
                    [
                        [
                            24,
                            25
                        ]
                    ],
                    [
                        [
                            26,
                            27
                        ]
                    ],
                    [
                        [
                            28,
                            29
                        ]
                    ],
                    [
                        [
                            30,
                            31
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    [
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            5
                        ]
                    ],
                    [
                        [
                            3,
                            4
                        ],
                        [
                            5,
                            6
                        ]
                    ],
                    [
                        [
                            6,
                            7
                        ]
                    ],
                    [
                        [
                            8,
                            9
                        ]
                    ],
                    [
                        [
                            10,
                            11
                        ]
                    ],
                    [
                        [
                            12,
                            13
                        ]
                    ],
                    [
                        [
                            14,
                            15
                        ]
                    ],
                    [
                        [
                            16,
                            17
                        ]
                    ],
                    [
                        [
                            18,
                            19
                        ]
                    ],
                    [
                        [
                            20,
                            21
                        ]
                    ],
                    [
                        [
                            22,
                            23
                        ]
                    ],
                    [
                        [
                            24,
                            25
                        ]
                    ],
                    [
                        [
                            26,
                            27
                        ]
                    ],
                    [
                        [
                            28,
                            29
                        ]
                    ],
                    [
                        [
                            30,
                            31
                        ]
                    ],
                    [
                        [
                            32,
                            33
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    [
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            5
                        ]
                    ],
                    [
                        [
                            3,
                            4
                        ],
                        [
                            5,
                            6
                        ]
                    ],
                    [
                        [
                            6,
                            7
                        ]
                    ],
                    [
                        [
                            8,
                            9
                        ]
                    ],
                    [
                        [
                            10,
                            11
                        ]
                    ],
                    [
                        [
                            12,
                            13
                        ]
                    ],
                    [
                        [
                            14,
                            15
                        ]
                    ],
                    [
                        [
                            16,
                            17
                        ]
                    ],
                    [
                        [
                            18,
                            19
                        ]
                    ],
                    [
                        [
                            20,
                            21
                        ]
                    ],
                    [
                        [
                            22,
                            23
                        ]
                    ],
                    [
                        [
                            24,
                            25
                        ]
                    ],
                    [
                        [
                            26,
                            27
                        ]
                    ],
                    [
                        [
                            28,
                            29
                        ]
                    ],
                    [
                        [
                            30,
                            31
                        ]
                    ],
                    [
                        [
                            32,
                            33
                        ]
                    ],
                    [
                        [
                            34,
                            35
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    [
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            5
                        ]
                    ],
                    [
                        [
                            3,
                            4
                        ],
                        [
                            5,
                            6
                        ]
                    ],
                    [
                        [
                            6,
                            7
                        ]
                    ],
                    [
                        [
                            8,
                            9
                        ]
                    ],
                    [
                        [
                            10,
                            11
                        ]
                    ],
                    [
                        [
                            12,
                            13
                        ]
                    ],
                    [
                        [
                            14,
                            15
                        ]
                    ],
                    [
                        [
                            16,
                            17
                        ]
                    ],
                    [
                        [
                            18,
                            19
                        ]
                    ],
                    [
                        [
                            20,
                            21
                        ]
                    ],
                    [
                        [
                            22,
                            23
                        ]
                    ],
                    [
                        [
                            24,
                            25
                        ]
                    ],
                    [
                        [
                            26,
                            27
                        ]
                    ],
                    [
                        [
                            28,
                            29
                        ]
                    ],
                    [
                        [
                            30,
                            31
                        ]
                    ],
                    [
                        [
                            32,
                            33
                        ]
                    ],
                    [
                        [
                            34,
                            35
                        ]
                    ],
                    [
                        [
                            36,
                            37
                        ]
                    ]
                ],
                [
                    [
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    [
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            5
                        ]
                    ],
                    [
                        [
                            3,
                            4
                        ],
                        [
                            5,
                            6
                        ]
                    ],
                    [
                        [
                            6,
                            7
                        ]
                    ],
                    [
                        [
                            8,
                            9
                        ]
                    ],
                    [
                        [
                            10,
                            11
                        ]
                    ],
                    [
                        [
                            12,
                            13
                        ]
                    ],
                    [
                        [
                            14,
                            15
                        ]
                    ],
                    [
                        [
                            16,
                            17
                        ]
                    ],
                    [
                        [
                            18,
                            19
                        ]
                    ],
                    [
                        [
                            20,
                            21
                        ]
                    ],
                    [
                        [
                            22,
                            23
                        ]
                    ],
                    [
                        [
                            24,
                            25
                        ]
                    ],
                    [
                        [
                            26,
                            27
                        ]
                    ],
                    [
                        [
                            28,
                            29
                        ]
                    ],
                    [
                        [
                            30,
                            31
                        ]
                    ],
                    [
                        [
                            32,
                            33
                        ]
                    ],
                    [
                        [
                            34,
                            35
                        ]
                    ],
                    [
                        [
                            36,
                            37
                        ]
                    ],
                    [
                        [
                            38,
                            39
                        ]
                    ]
                ]
            ],
            "outputs": [
                "[[3,4]]",
                "[[5,6],[7,9]]",
                "[]",
                "[[6,7]]",
                "[[4,5]]",
                "[[4,5],[6,7]]",
                "[[4,5],[6,7],[9,10]]",
                "[[4,5],[6,7],[9,10],[11,12]]",
                "[[4,5],[6,7],[9,10],[11,12],[13,14]]",
                "[[4,5],[6,7],[9,10],[11,12],[13,14],[15,16]]",
                "[[4,5],[6,7],[9,10],[11,12],[13,14],[15,16],[17,18]]",
                "[[4,5],[6,7],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20]]",
                "[[4,5],[6,7],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22]]",
                "[[4,5],[6,7],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24]]",
                "[[4,5],[6,7],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26]]",
                "[[4,5],[6,7],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28]]",
                "[[4,5],[6,7],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30]]",
                "[[4,5],[6,7],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32]]",
                "[[4,5],[6,7],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[33,34]]",
                "[[4,5],[6,7],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[33,34],[35,36]]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\n\nint minSetSize(std::vector<std::pair<int, int>> intervals) {\n    std::sort(intervals.begin(), intervals.end());\n    int n = intervals.size();\n    int end = intervals[0].second;\n    int count = 1;\n\n    for (int i = 1; i < n; i++) {\n        if (end < intervals[i].first) {\n            end = intervals[i].second;\n            count++;\n        } else {\n            end = std::min(end, intervals[i].second);\n        }\n    }\n    return count * 2;\n}\n",
            "java": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic int minSetSize(int[][] intervals) {\n    Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));\n    int n = intervals.length;\n    int end = intervals[0][1];\n    int count = 1;\n\n    for (int i = 1; i < n; i++) {\n        if (end < intervals[i][0]) {\n            end = intervals[i][1];\n            count++;\n        } else {\n            end = Math.min(end, intervals[i][1]);\n        }\n    }\n    return count * 2;\n}\n",
            "python": "def min_set_size(intervals):\n    intervals.sort()\n    n = len(intervals)\n    end = intervals[0][1]\n    count = 1\n\n    for i in range(1, n):\n        if end < intervals[i][0]:\n            end = intervals[i][1]\n            count += 1\n        else:\n            end = min(end, intervals[i][1])\n    return count * 2\n",
            "javascript": "function minSetSize(intervals) {\n    intervals.sort((a, b) => a[0] - b[0]);\n    const n = intervals.length;\n    let end = intervals[0][1];\n    let count = 1;\n\n    for (let i = 1; i < n; i++) {\n        if (end < intervals[i][0]) {\n            end = intervals[i][1];\n            count++;\n        } else {\n            end = Math.min(end, intervals[i][1]);\n        }\n    }\n    return count * 2;\n}\n",
            "explanation": "1. Sort the intervals by their starting point.\n2. Initialize `end` to the end of the first interval and set `count` to 1.\n3. Loop through the intervals from the second interval onwards.\n   - If the current `end` is less than the starting point of the current interval, set `end` to the end of the current interval and increment `count`.\n   - Otherwise, set `end` to the minimum of the current `end` and the end of the current interval.\n4. Return `count * 2` to ensure that the intersection of S with A has a size of at least two."
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\n\nint minSetSize(std::vector<std::pair<int, int>> intervals) \n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic int minSetSize(int[][] intervals) \n    // Your code here\n}\n",
            "python": "def min_set_size(intervals):\n    # Your code here\n\n",
            "javascript": "function minSetSize(intervals) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nint main() {\n    std::vector<std::pair<int, int>> intervals = $args;\n    int result = minSetSize(intervals);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public int minSetSize(int[][] intervals) {\n    Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));\n    int n = intervals.length;\n    int end = intervals[0][1];\n    int count = 1;\n\n    for (int i = 1; i < n; i++) {\n        if (end < intervals[i][0]) {\n            end = intervals[i][1];\n            count++;\n        } else {\n            end = Math.min(end, intervals[i][1]);\n        }\n    }\n    return count * 2;\n}",
            "python": "if __name__ == \"__main__\":\n    intervals = $args[0]\n    result = min_set_size(intervals)\n    print(result)",
            "javascript": "function main() {\n    const intervals = $args;\n    const result = minSetSize(intervals);\n    console.log(result);\n}"
        }
    },
    "760": {
        "title": "Index Mapping of Anagram Arrays",
        "description": "Given two integer arrays `nums1` and `nums2` where `nums2` is an anagram of `nums1`, both arrays may contain duplicates. Return an index mapping array `mapping` from `nums1` to `nums2` where `mapping[i] = j` means the `ith` element in `nums1` appears in `nums2` at index `j`. If there are multiple answers, return any of them. An array `a` is an anagram of an array `b` if `b` is made by randomizing the order of the elements in `a`.",
        "example": "Example:\n\nInput: nums1 = [12,28,46,32,50], nums2 = [50,12,32,46,28]\nOutput: [1,4,3,2,0]\nExplanation: mapping[0] = 1 because the 0th element of nums1 appears at nums2[1], and mapping[1] = 4 because the 1st element of nums1 appears at nums2[4], and so on.",
        "level": "Easy",
        "tags": [
            "Array",
            "Sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    12,
                    28,
                    46,
                    32,
                    50
                ],
                [
                    84,
                    46
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10
                ],
                [
                    10,
                    8,
                    6,
                    4,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9
                ],
                [
                    9,
                    7,
                    5,
                    3,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    2,
                    2,
                    3,
                    3,
                    4,
                    4,
                    5,
                    5
                ],
                [
                    5,
                    5,
                    4,
                    4,
                    3,
                    3,
                    2,
                    2,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    2,
                    2,
                    3,
                    3,
                    4,
                    4,
                    5,
                    5
                ],
                [
                    5,
                    5,
                    4,
                    4,
                    3,
                    3,
                    2,
                    2,
                    1,
                    1
                ]
            ],
            "outputs": [
                "[1,4,3,2,0]",
                "[0,1]",
                "[0,1,2,3,4]",
                "[0,1,2,3,4]",
                "[0,1,2,3,4]",
                "[4,3,2,1,0]",
                "[4,3,2,1,0]",
                "[0,1,2,3,4]",
                "[4,3,2,1,0]",
                "[0,1,2,3,4]",
                "[4,3,2,1,0]",
                "[0,1,2,3,4,5,6,7,8,9]",
                "[9,8,7,6,5,4,3,2,1,0]",
                "[0,1,2,3,4,5,6,7,8,9]",
                "[9,8,7,6,5,4,3,2,1,0]",
                "[0,1,2,3,4,5,6,7,8,9]",
                "[9,8,7,6,5,4,3,2,1,0]",
                "[0,1,2,3,4,5,6,7,8,9]",
                "[9,8,7,6,5,4,3,2,1,0]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> anagramMappings(vector<int>& nums1, vector<int>& nums2) {\n    unordered_map<int, int> num_map;\n    for (int i = 0; i < nums2.size(); i++) {\n        num_map[nums2[i]] = i;\n    }\n    vector<int> mapping(nums1.size());\n    for (int i = 0; i < nums1.size(); i++) {\n        mapping[i] = num_map[nums1[i]];\n    }\n    return mapping;\n}\n\n",
            "java": "import java.util.*;\n\npublic int[] anagramMappings(int[] nums1, int[] nums2) {\n    HashMap<Integer, Integer> num_map = new HashMap<>();\n    for (int i = 0; i < nums2.length; i++) {\n        num_map.put(nums2[i], i);\n    }\n    int[] mapping = new int[nums1.length];\n    for (int i = 0; i < nums1.length; i++) {\n        mapping[i] = num_map.get(nums1[i]);\n    }\n    return mapping;\n}\n\n",
            "python": "def anagramMappings(nums1, nums2):\n    num_map = {num: i for i, num in enumerate(nums2)}\n    mapping = [num_map[num] for num in nums1]\n    return mapping\n\n",
            "javascript": "function anagramMappings(nums1, nums2) {\n    let num_map = new Map();\n    for (let i = 0; i < nums2.length; i++) {\n        num_map.set(nums2[i], i);\n    }\n    let mapping = new Array(nums1.length);\n    for (let i = 0; i < nums1.length; i++) {\n        mapping[i] = num_map.get(nums1[i]);\n    }\n    return mapping;\n}\n\n",
            "explanation": "The algorithm involves creating a mapping between each value in `nums2` and its index, using a hash map. Then, for each element in `nums1`, get its corresponding index in `nums2` and append that index value into the resulting mapping. This approach has a linear computation complexity (O(n)), as iterating over both `nums1` and `nums2` only occurs once."
        },
        "structure": {
            "c++": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> anagramMappings(vector<int>& nums1, vector<int>& nums2) \n    // Your code here\n}\n\n",
            "java": "import java.util.*;\n\npublic int[] anagramMappings(int[] nums1, int[] nums2) \n    // Your code here\n}\n\n",
            "python": "def anagramMappings(nums1, nums2):\n    # Your code here\n\n",
            "javascript": "function anagramMappings(nums1, nums2) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n    vector<int> nums1 = $args;\n    vector<int> nums2 = $args;\n    vector<int> result = anagramMappings(nums1, nums2);\n    for (int i = 0; i < result.size(); i++) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n",
            "java": "public int[] anagramMappings(int[] nums1, int[] nums2) {\n    HashMap<Integer, Integer> num_map = new HashMap<>();\n    for (int i = 0; i < nums2.length; i++) {\n        num_map.put(nums2[i], i);\n    }\n    int[] mapping = new int[nums1.length];\n    for (int i = 0; i < nums1.length; i++) {\n        mapping[i] = num_map.get(nums1[i]);\n    }\n    return mapping;\n}",
            "python": "if __name__ == \"__main__\":\n    nums1 = $args[0]\n    nums2 = $args[1]\n    result = anagramMappings(nums1, nums2)\n    print(result)",
            "javascript": "function main() {\n    const nums1 = $args[0];\n    const nums2 = $args[1];\n    const result = anagramMappings(nums1, nums2);\n    console.log(result);\n}"
        }
    },
    "761": {
        "title": "Lexicographically Largest Special Binary String",
        "description": "Given a special binary string `s`, consisting of `0`'s and `1`'s, you need to perform a series of moves to obtain the lexicographically largest string possible. A special binary string has the following properties: \n\n- The number of `0`'s is equal to the number of `1`'s. \n- Every prefix of the binary string has at least as many `1`'s as `0`'s. \n\nA move consists of choosing two consecutive, non-empty, special substrings of `s` and swapping them. Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string. Return the lexicographically largest resulting string after applying the mentioned operations on the string.",
        "example": "Example:\n\nInput: s = \"11011000\"\nOutput: \"11100100\"\nExplanation: The strings \"10\" [occurring at s[1]] and \"1100\" [at s[3]] are swapped. This is the lexicographically largest string possible after some number of swaps.",
        "level": "Medium",
        "tags": [
            "string",
            "greedy"
        ],
        "test_cases": {
            "inputs": [
                "\"11011000\"",
                "\"10\"",
                "\"111000\"",
                "\"101010\"",
                "\"11001100\"",
                "\"11110000\"",
                "\"10101010\"",
                "\"110011001100\"",
                "\"111100001111\"",
                "\"101010101010\"",
                "\"1100110011001100\"",
                "\"1111000011110000\"",
                "\"1010101010101010\"",
                "\"11001100110011001100\"",
                "\"11110000111100001111\"",
                "\"10101010101010101010\"",
                "\"110011001100110011001100\"",
                "\"111100001111000011110000\"",
                "\"101010101010101010101010\"",
                "\"1100110011001100110011001100\""
            ],
            "outputs": [
                "\"11100100\"",
                "\"10\"",
                "\"111000\"",
                "\"110100\"",
                "\"11110000\"",
                "\"11110000\"",
                "\"11010010\"",
                "\"111100001100\"",
                "\"111100001111\"",
                "\"110100101010\"",
                "\"1111000011110000\"",
                "\"1111000011110000\"",
                "\"1101001010101010\"",
                "\"11110000111100001111\"",
                "\"11110000111100001111\"",
                "\"11010010101010101010\"",
                "\"111100001111000011110000\"",
                "\"111100001111000011110000\"",
                "\"110100101010101010101010\"",
                "\"1111000011110000111100001111\"",
                "\"1111000011110000111100001111\""
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string makeLargestSpecial(std::string s) {\n    int count = 0, i = 0;\n    std::vector<std::string> subs;\n\n    for (int j = 0; j < s.size(); j++) {\n        if (s[j] == '1') count++;\n        else count--;\n\n        if (count == 0) {\n            subs.push_back('1' + makeLargestSpecial(s.substr(i+1, j-i-1)) + '0');\n            i = j + 1;\n        }\n    }\n\n    std::sort(subs.rbegin(), subs.rend());\n    std::string res;\n    for (const auto& sub : subs) {\n        res += sub;\n    }\n    return res;\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic String makeLargestSpecial(String s) {\n    int count = 0;\n    int i = 0;\n    List<String> subs = new ArrayList<>();\n\n    for (int j = 0; j < s.length(); j++) {\n        if (s.charAt(j) == '1') count++;\n        else count--;\n\n        if (count == 0) {\n            subs.add(\"1\" + makeLargestSpecial(s.substring(i+1, j)) + \"0\");\n            i = j + 1;\n        }\n    }\n\n    Collections.sort(subs, Collections.reverseOrder());\n    StringBuilder res = new StringBuilder();\n    for (String sub : subs) {\n        res.append(sub);\n    }\n    return res.toString();\n}\n\n",
            "python": "def makeLargestSpecial(s: str) -> str:\n    count, i = 0, 0\n    subs = []\n\n    for j in range(len(s)):\n        if s[j] == '1':\n            count += 1\n        else:\n            count -= 1\n\n        if count == 0:\n            subs.append(\"1\" + makeLargestSpecial(s[i+1:j]) + \"0\")\n            i = j + 1\n\n    subs.sort(reverse=True)\n    return \"\".join(subs)\n\n",
            "javascript": "function makeLargestSpecial(s) {\n    let count = 0, i = 0;\n    let subs = [];\n\n    for (let j = 0; j < s.length; j++) {\n        if (s[j] === '1') count++;\n        else count--;\n\n        if (count === 0) {\n            subs.push(\"1\" + makeLargestSpecial(s.slice(i+1, j)) + \"0\");\n            i = j + 1;\n        }\n    }\n\n    subs.sort((a, b) => b.localeCompare(a));\n    return subs.join('');\n}\n\n",
            "explanation": "The algorithm starts by initializing some variables. `count` tracks the balance of 1's and 0's in the special binary string, and `i` tracks the starting index for extracting subproblems.\n\nIterating through the input string `s`, the algorithm updates `count`, incrementing it if the current character is '1' and decrementing if it's '0'. Whenever `count` becomes zero, it means that the current substring from index `i + 1` to index `j` is a valid special binary string. We proceed with the following steps:\n\n1. Extract the substring from index `i + 1` to index `j`.\n2. Recursively apply the function `makeLargestSpecial()` on the extracted substring.\n3. Concatenate the string \"1\" before and the string \"0\" after the result and add the resulting string into a list of substrings called `subs`.\n4. Update the `i` variable to the next index after `j`.\n\nAfter processing the entire input string in this way, we have several special binary substrings in `subs`. We sort the substrings in decreasing (non-ascending) order and concatenate them together to form the largest lexicographically possible string as the final result."
        },
        "structure": {
            "c++": "#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string makeLargestSpecial(std::string s) \n    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic String makeLargestSpecial(String s) \n    // Your code here\n}\n\n",
            "python": "def makeLargestSpecial(s: str) -> str:\n    # Your code here\n\n",
            "javascript": "function makeLargestSpecial(s) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\nint main() {\n    std::string s = $args;\n    std::string result = makeLargestSpecial(s);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public String makeLargestSpecial(String s) {\n    int count = 0;\n    int i = 0;\n    List<String> subs = new ArrayList<>();\n\n    for (int j = 0; j < s.length(); j++) {\n        if (s.charAt(j) == '1') count++;\n        else count--;\n\n        if (count == 0) {\n            subs.add(\"1\" + makeLargestSpecial(s.substring(i+1, j)) + \"0\");\n            i = j + 1;\n        }\n    }\n\n    Collections.sort(subs, Collections.reverseOrder());\n    StringBuilder res = new StringBuilder();\n    for (String sub : subs) {\n        res.append(sub);\n    }\n    return res.toString();\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args[0]\n    result = makeLargestSpecial(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = makeLargestSpecial(s);\n    console.log(result);\n}"
        }
    },
    "762": {
        "title": "Count of Numbers with Prime Number of Set Bits",
        "description": "Given two integers `left` and `right`, return the count of numbers in the inclusive range `[left, right]` having a prime number of set bits in their binary representation. Recall that the number of set bits an integer has is the number of `1`s present when written in binary.",
        "example": "Example 1:\n\nInput: left = 6, right = 10\nOutput: 4\nExplanation:\n6  -> 110 (2 set bits, 2 is prime)\n7  -> 111 (3 set bits, 3 is prime)\n8  -> 1000 (1 set bit, 1 is not prime)\n9  -> 1001 (2 set bits, 2 is prime)\n10 -> 1010 (2 set bits, 2 is prime)\n4 numbers have a prime number of set bits.\n\nExample 2:\n\nInput: left = 10, right = 15\nOutput: 5\nExplanation:\n10 -> 1010 (2 set bits, 2 is prime)\n11 -> 1011 (3 set bits, 3 is prime)\n12 -> 1100 (2 set bits, 2 is prime)\n13 -> 1101 (3 set bits, 3 is prime)\n14 -> 1110 (3 set bits, 3 is prime)\n15 -> 1111 (4 set bits, 4 is not prime)\n5 numbers have a prime number of set bits.",
        "level": "Easy",
        "tags": [
            "bit manipulation",
            "prime numbers"
        ],
        "test_cases": {
            "inputs": [
                [
                    6,
                    10
                ],
                [
                    10,
                    15
                ],
                [
                    1,
                    1
                ],
                [
                    1,
                    100
                ],
                [
                    100,
                    200
                ],
                [
                    1000,
                    2000
                ],
                [
                    10000,
                    20000
                ],
                [
                    100000,
                    200000
                ],
                [
                    1000000,
                    1000000
                ]
            ],
            "outputs": [
                4,
                5,
                0,
                35,
                55,
                109,
                208,
                415,
                1
            ]
        },
        "sample_code": {
            "c++": "#include <bitset>\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    return true;\n}\n\nint countPrimeSetBits(int left, int right) {\n    int count = 0;\n    for (int i = left; i <= right; ++i)\n        count += isPrime(std::bitset<32>(i).count());\n    return count;\n}\n\n",
            "java": "class Solution {\n    boolean isPrime(int n) {\n        if (n <= 1) return false;\n        if (n <= 3) return true;\n        if (n % 2 == 0 || n % 3 == 0) return false;\n        for (int i = 5; i * i <= n; i += 6)\n            if (n % i == 0 || n % (i + 2) == 0) return false;\n        return true;\n    }\n    \n    public int countPrimeSetBits(int left, int right) {\n        int count = 0;\n        for (int i = left; i <= right; ++i)\n            count += isPrime(Integer.bitCount(i)) ? 1 : 0;\n        return count;\n    }\n}\n\n",
            "python": "def is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef count_prime_set_bits(left: int, right: int) -> int:\n    return sum(is_prime(bin(i).count('1')) for i in range(left, right + 1))\n\n",
            "javascript": "function isPrime(n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 === 0 || n % 3 === 0) return false;\n    for (let i = 5; i * i <= n; i += 6)\n        if (n % i === 0 || n % (i + 2) === 0) return false;\n    return true;\n}\n\nfunction countPrimeSetBits(left, right) {\n    let count = 0;\n    for (let i = left; i <= right; ++i)\n        count += isPrime(i.toString(2).split('1').length - 1) ? 1 : 0;\n    return count;\n}\n\n",
            "explanation": "The algorithm first defines a helper function `isPrime` to check if a given number is a prime number. Then, in the main `countPrimeSetBits` function, we iterate through the given range `[left, right]`. For each number, we count the number of 1's in its binary representation and check for primality of that count. If the count is a prime number, we increment the final count of numbers with prime set bits."
        },
        "structure": {
            "c++": "#include <bitset>\n\nbool isPrime(int n) \n    // Your code here\n}\n\n",
            "java": "class Solution \n    // Your code here\n}\n\n",
            "python": "def is_prime(n: int) -> bool:\n    # Your code here\n\n",
            "javascript": "function isPrime(n) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <bitset>\n#include <iostream>\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    return true;\n}\n\nint countPrimeSetBits(int left, int right) {\n    int count = 0;\n    for (int i = left; i <= right; ++i)\n        count += isPrime(std::bitset<32>(i).count());\n    return count;\n}\n\nint main() {\n    int left = $args;\n    int right = $args;\n    int result = countPrimeSetBits(left, right);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int countPrimeSetBits(int left, int right)",
            "python": "if __name__ == \"__main__\":\n    left = $args[0]\n    right = $args[1]\n    result = count_prime_set_bits(left, right)\n    print(result)",
            "javascript": "function countPrimeSetBits(left, right) {\n    let count = 0;\n    for (let i = left; i <= right; ++i)\n        count += isPrime(i.toString(2).split('1').length - 1) ? 1 : 0;\n    return count;\n}"
        }
    },
    "764": {
        "title": "Largest Axis-Aligned Plus Sign",
        "description": "You are given an integer `n`. You have an `n x n` binary grid `grid` with all values initially `1`'s except for some indices given in the array `mines`. The `ith` element of the array `mines` is defined as `mines[i] = [xi, yi]` where `grid[xi][yi] == 0`. Return the order of the largest axis-aligned plus sign of 1's contained in `grid`. If there is none, return 0.\n\nAn axis-aligned plus sign of 1's of order `k` has some center `grid[r][c] == 1` along with four arms of length `k - 1` going up, down, left, and right, and made of 1's. Note that there could be 0's or 1's beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1's.",
        "example": "Example:\n\nInput: n = 5, mines = [[4,2]]\nOutput: 2\nExplanation: In the above grid, the largest plus sign can only be of order 2. One of them is shown.",
        "level": "Medium",
        "tags": [
            "array",
            "grid",
            "search"
        ],
        "test_cases": {
            "inputs": [
                [
                    5,
                    [
                        [
                            4,
                            2
                        ]
                    ]
                ],
                [
                    1,
                    [
                        [
                            0,
                            0
                        ]
                    ]
                ],
                [
                    3,
                    [
                        [
                            1,
                            1
                        ]
                    ]
                ],
                [
                    4,
                    [
                        [
                            1,
                            1
                        ],
                        [
                            2,
                            2
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            1,
                            4
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            4
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            1,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            3,
                            3
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            1,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            2,
                            2
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            1,
                            4
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            4
                        ],
                        [
                            1,
                            1
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            3,
                            1
                        ],
                        [
                            3,
                            3
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            1,
                            4
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            4
                        ],
                        [
                            1,
                            1
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            3,
                            1
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            2,
                            2
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            1,
                            4
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            4
                        ],
                        [
                            1,
                            1
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            3,
                            1
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            2,
                            2
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            2,
                            3
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            1,
                            4
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            4
                        ],
                        [
                            1,
                            1
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            3,
                            1
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            2,
                            2
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            1
                        ],
                        [
                            4,
                            3
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            1,
                            4
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            4
                        ],
                        [
                            1,
                            1
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            3,
                            1
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            2,
                            2
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            1
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            4,
                            2
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            1,
                            4
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            4
                        ],
                        [
                            1,
                            1
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            3,
                            1
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            2,
                            2
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            1
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            4,
                            2
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            2
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            1,
                            4
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            4
                        ],
                        [
                            1,
                            1
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            3,
                            1
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            2,
                            2
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            1
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            4,
                            2
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            2,
                            4
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            1,
                            4
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            4
                        ],
                        [
                            1,
                            1
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            3,
                            1
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            2,
                            2
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            1
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            4,
                            2
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            4,
                            2
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            1,
                            4
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            4
                        ],
                        [
                            1,
                            1
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            3,
                            1
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            2,
                            2
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            1
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            4,
                            2
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            4,
                            2
                        ],
                        [
                            2,
                            2
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            1,
                            4
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            4
                        ],
                        [
                            1,
                            1
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            3,
                            1
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            2,
                            2
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            1
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            4,
                            2
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            4,
                            2
                        ],
                        [
                            2,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            4,
                            3
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            1,
                            4
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            4
                        ],
                        [
                            1,
                            1
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            3,
                            1
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            2,
                            2
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            1
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            4,
                            2
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            4,
                            2
                        ],
                        [
                            2,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            3,
                            4
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            1,
                            4
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            4
                        ],
                        [
                            1,
                            1
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            3,
                            1
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            2,
                            2
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            1
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            4,
                            2
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            4,
                            2
                        ],
                        [
                            2,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            3,
                            2
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            1,
                            4
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            4
                        ],
                        [
                            1,
                            1
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            3,
                            1
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            2,
                            2
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            1
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            4,
                            2
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            4,
                            2
                        ],
                        [
                            2,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            4,
                            0
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            1,
                            4
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            4
                        ],
                        [
                            1,
                            1
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            3,
                            1
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            2,
                            2
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            1
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            4,
                            2
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            4,
                            2
                        ],
                        [
                            2,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            4,
                            2
                        ]
                    ]
                ]
            ],
            "outputs": [
                2,
                0,
                1,
                1,
                0,
                1,
                1,
                2,
                2,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <queue>\n\nusing std::vector;\nusing std::queue;\n\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n\nvector<vector<int>> levelOrder(Node* root) {\n    vector<vector<int>> result;\n    if (root == nullptr) return result;\n\n    queue<Node*> toVisit;\n    toVisit.push(root);\n\n    while (!toVisit.empty()) {\n        int size = toVisit.size();\n        vector<int> level;\n\n        for (int i = 0; i < size; i++) {\n            Node* currentNode = toVisit.front();\n            toVisit.pop();\n            level.push_back(currentNode->val);\n\n            for (Node* child : currentNode->children) {\n                toVisit.push(child);\n            }\n        }\n        result.push_back(level);\n    }\n\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.LinkedList;\n\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val,List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n}\n\npublic List<List<Integer>> levelOrder(Node root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<Node> toVisit = new LinkedList<>();\n    toVisit.offer(root);\n\n    while (!toVisit.isEmpty()) {\n        int size = toVisit.size();\n        List<Integer> level = new ArrayList<>();\n\n        for (int i = 0; i < size; i++) {\n            Node currentNode = toVisit.poll();\n            level.add(currentNode.val);\n\n            for (Node child : currentNode.children) {\n                toVisit.offer(child);\n            }\n        }\n        result.add(level);\n    }\n\n    return result;\n}\n",
            "python": "from collections import deque\n\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\ndef levelOrder(root):\n    result = []\n\n    if not root:\n        return result\n\n    toVisit = deque([root])\n\n    while toVisit:\n        size = len(toVisit)\n        level = []\n\n        for _ in range(size):\n            currentNode = toVisit.popleft()\n            level.append(currentNode.val)\n\n            for child in currentNode.children:\n                toVisit.append(child)\n\n        result.append(level)\n\n    return result\n",
            "javascript": "class Node {\n    constructor(val, children) {\n        this.val = val;\n        this.children = children;\n    }\n}\n\nfunction levelOrder(root) {\n    const result = [];\n    if (!root) return result;\n\n    const toVisit = [root];\n\n    while (toVisit.length > 0) {\n        const size = toVisit.length;\n        const level = [];\n\n        for (let i = 0; i < size; i++) {\n            const currentNode = toVisit.shift();\n            level.push(currentNode.val);\n\n            for (const child of currentNode.children) {\n                toVisit.push(child);\n            }\n        }\n        result.push(level);\n    }\n\n    return result;\n}\n",
            "explanation": "The algorithm uses a Breadth-First Search (BFS) traversal approach to traverse the n-ary tree level-by-level. A queue is used to keep track of nodes to visit at each level. The process starts by adding the root node to the queue. Then, while the queue is not empty, it continues to process nodes from the queue. For each node, we remove it from the queue, add its value to the current level, and add its children to the queue. This process continues for all nodes at the current level, and then the level is added to the result list. The algorithm continues until there are no more nodes in the queue.\n\nIn each language, the function first initializes an empty result list and a queue, adds the root node to the queue (if it is not null), and then traverses the tree using the BFS method described, adding the values of the nodes to the result list as it goes."
        },
        "structure": {
            "c++": "#include <vector>\n#include <queue>\n\nusing std::vector;\nusing std::queue;\n\nclass Node \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.LinkedList;\n\nclass Node \n    // Your code here\n}\n",
            "python": "from collections import deque\n    # Your code here\n\n",
            "javascript": "class Node \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <queue>\n\nusing std::vector;\nusing std::queue;\n\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n\nvector<vector<int>> levelOrder(Node* root) {\n    vector<vector<int>> result;\n    if (root == nullptr) return result;\n\n    queue<Node*> toVisit;\n    toVisit.push(root);\n\n    while (!toVisit.empty()) {\n        int size = toVisit.size();\n        vector<int> level;\n\n        for (int i = 0; i < size; i++) {\n            Node* currentNode = toVisit.front();\n            toVisit.pop();\n            level.push_back(currentNode->val);\n\n            for (Node* child : currentNode->children) {\n                toVisit.push(child);\n            }\n        }\n        result.push_back(level);\n    }\n\n    return result;\n}",
            "java": "public List<List<Integer>> levelOrder(Node root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<Node> toVisit = new LinkedList<>();\n    toVisit.offer(root);\n\n    while (!toVisit.isEmpty()) {\n        int size = toVisit.size();\n        List<Integer> level = new ArrayList<>();\n\n        for (int i = 0; i < size; i++) {\n            Node currentNode = toVisit.poll();\n            level.add(currentNode.val);\n\n            for (Node child : currentNode.children) {\n                toVisit.offer(child);\n            }\n        }\n        result.add(level);\n    }\n\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    root = $args[0]\n    result = levelOrder(root)\n    print(result)",
            "javascript": "function levelOrder(root) {\n    const result = [];\n    if (!root) return result;\n\n    const toVisit = [root];\n\n    while (toVisit.length > 0) {\n        const size = toVisit.length;\n        const level = [];\n\n        for (let i = 0; i < size; i++) {\n            const currentNode = toVisit.shift();\n            level.push(currentNode.val);\n\n            for (const child of currentNode.children) {\n                toVisit.push(child);\n            }\n        }\n        result.push(level);\n    }\n\n    return result;\n}"
        }
    },
    "765": {
        "title": "Minimum Swaps to Arrange Couples",
        "description": "There are `n` couples sitting in `2n` seats arranged in a row and want to hold hands. The people and seats are represented by an integer array `row` where `row[i]` is the ID of the person sitting in the `ith` seat. The couples are numbered in order, the first couple being `(0, 1)`, the second couple being `(2, 3)`, and so on with the last couple being `(2n - 2, 2n - 1)`. Return the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats.",
        "example": "Example:\n\nInput: row = [0,2,1,3]\nOutput: 1\nExplanation: We only need to swap the second (row[1]) and third (row[2]) person.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    0,
                    2,
                    1,
                    3
                ],
                [
                    3,
                    2,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    3,
                    2,
                    5,
                    4,
                    7,
                    6
                ],
                [
                    2,
                    3,
                    0,
                    1,
                    6,
                    7,
                    4,
                    5
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29
                ]
            ],
            "outputs": [
                "1",
                "0",
                "2",
                "3",
                "0"
            ]
        },
        "sample_code": {
            "c++": "int minSwapsCouples(vector<int>& row) {\n    int n = row.size();\n    vector<int> position(n);\n    for (int i = 0; i < n; ++i)\n        position[row[i]] = i;\n\n    int swaps = 0;\n    for (int i = 0; i < n; i += 2) {\n        int partner = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] != partner) {\n            swap(row[position[partner]], row[i + 1]);\n            swap(position[row[i + 1]], position[partner]);\n            swaps++;\n        }\n    }\n    return swaps;\n}\n\n",
            "java": "public int minSwapsCouples(int[] row) {\n    int n = row.length;\n    int[] position = new int[n];\n    for (int i = 0; i < n; ++i)\n        position[row[i]] = i;\n\n    int swaps = 0;\n    for (int i = 0; i < n; i += 2) {\n        int partner = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] != partner) {\n            int temp = row[position[partner]];\n            row[position[partner]] = row[i + 1];\n            row[i + 1] = temp;\n            \n            temp = position[row[i + 1]];\n            position[row[i + 1]] = position[partner];\n            position[partner] = temp;\n            \n            swaps++;\n        }\n    }\n    return swaps;\n}\n\n",
            "python": "def minSwapsCouples(row):\n    n = len(row)\n    position = [0] * n\n    for i in range(n):\n        position[row[i]] = i\n\n    swaps = 0\n    for i in range(0, n, 2):\n        partner = row[i] + 1 if row[i] % 2 == 0 else row[i] - 1\n        if row[i + 1] != partner:\n            row[position[partner]], row[i + 1] = row[i + 1], row[position[partner]]\n            position[row[i + 1]], position[partner] = position[partner], position[row[i + 1]]\n            swaps += 1\n    return swaps\n\n",
            "javascript": "function minSwapsCouples(row) {\n    const n = row.length;\n    const position = new Array(n);\n    for (let i = 0; i < n; ++i)\n        position[row[i]] = i;\n\n    let swaps = 0;\n    for (let i = 0; i < n; i += 2) {\n        const partner = row[i] % 2 === 0 ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] !== partner) {\n            [row[position[partner]], row[i + 1]] = [row[i + 1], row[position[partner]]];\n            [position[row[i + 1]], position[partner]] = [position[partner], position[row[i + 1]]];\n            swaps++;\n        }\n    }\n    return swaps;\n}\n\n",
            "explanation": "The algorithm works by iterating through the array `row` in increments of 2, representing the couple's seats side by side. During the iteration, it checks if the couple's partner is sitting next to the current person, based on the fact that the partner would have an ID that is either one more or one less than the current person's ID.\n\nIf the partner is not sitting in the expected position, it then swaps the person sitting next to the current person with the partner. The positions of the people in the array are stored in a separate `position` array. The swap is done both in the `row` and `position` arrays, and the swap count is incremented.\n\nAfter the entire iteration, the swap count represents the minimum number of swaps needed to arrange the couples side by side."
        },
        "structure": {
            "c++": "int minSwapsCouples(vector<int>& row) \n    // Your code here\n}\n\n",
            "java": "public int minSwapsCouples(int[] row) \n    // Your code here\n}\n\n",
            "python": "def minSwapsCouples(row):\n    # Your code here\n\n",
            "javascript": "function minSwapsCouples(row) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int minSwapsCouples(vector<int>& row) {\n    int n = row.size();\n    vector<int> position(n);\n    for (int i = 0; i < n; ++i)\n        position[row[i]] = i;\n\n    int swaps = 0;\n    for (int i = 0; i < n; i += 2) {\n        int partner = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] != partner) {\n            swap(row[position[partner]], row[i + 1]);\n            swap(position[row[i + 1]], position[partner]);\n            swaps++;\n        }\n    }\n    return swaps;\n}",
            "java": "public int minSwapsCouples(int[] row) {\n    int n = row.length;\n    int[] position = new int[n];\n    for (int i = 0; i < n; ++i)\n        position[row[i]] = i;\n\n    int swaps = 0;\n    for (int i = 0; i < n; i += 2) {\n        int partner = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] != partner) {\n            int temp = row[position[partner]];\n            row[position[partner]] = row[i + 1];\n            row[i + 1] = temp;\n            \n            temp = position[row[i + 1]];\n            position[row[i + 1]] = position[partner];\n            position[partner] = temp;\n            \n            swaps++;\n        }\n    }\n    return swaps;\n}",
            "python": "if __name__ == \"__main__\":\n    row = $args[0]\n    result = minSwapsCouples(row)\n    print(result)",
            "javascript": "function main() {\n    const row = $args;\n    const result = minSwapsCouples(row);\n    console.log(result);\n}"
        }
    },
    "767": {
        "title": "Rearrange Characters",
        "description": "Given a string `s`, rearrange the characters of `s` so that any two adjacent characters are not the same. Return any possible rearrangement of `s` or return an empty string if not possible.",
        "example": "Example 1:\n\nInput: s = \"aab\"\nOutput: \"aba\"\n\nExample 2:\n\nInput: s = \"aaab\"\nOutput: \"\"\n\nExplanation:\n\nIn Example 1, the characters 'a' and 'b' can be rearranged to form the string 'aba' where no two adjacent characters are the same.\n\nIn Example 2, it is not possible to rearrange the characters of 'aaab' such that no two adjacent characters are the same, so the output is an empty string.",
        "level": "Medium",
        "tags": [
            "string",
            "rearrangement"
        ],
        "test_cases": {
            "inputs": [
                "\"aab\"",
                "\"aaab\"",
                "\"abcde\"",
                "\"aaaaa\"",
                "\"aabbbccc\"",
                "\"aabbccdd\"",
                "\"ababab\"",
                "\"aabb\"",
                "\"aabbaa\"",
                "\"aabbcc\"",
                "\"aabbccdd\"",
                "\"aabbccddee\"",
                "\"aabbccddeeff\"",
                "\"aabbccddeeffgg\"",
                "\"aabbccddeeffgghh\"",
                "\"aabbccddeeffgghhi\"",
                "\"aabbccddeeffgghhii\"",
                "\"aabbccddeeffgghhiijj\"",
                "\"aabbccddeeffgghhiijjkk\"",
                "\"aabbccddeeffgghhiijjkkll\"",
                "\"aabbccddeeffgghhiijjkkllmm\""
            ],
            "outputs": [
                "\"aba\"",
                "\"\"",
                "\"abcde\"",
                "\"\"",
                "\"abcabcabc\"",
                "\"abcdabcd\"",
                "\"ababab\"",
                "\"abab\"",
                "\"\"",
                "\"abcabc\"",
                "\"abcdabcd\"",
                "\"abcdeabcde\"",
                "\"abcdefabcdef\"",
                "\"abcdefgabcdefg\"",
                "\"abcdefghabcdefgh\"",
                "\"abcdefghiabcdefghi\"",
                "\"abcdefghiiabcdefghii\"",
                "\"abcdefghiijabcdefghiij\"",
                "\"abcdefghiijkabcdefghiijk\"",
                "\"abcdefghiijklaabcdefghiijkla\"",
                "\"abcdefghiijkllmabcdefghiijkllm\""
            ]
        },
        "sample_code": {
            "c++": "#include <bitset>\n#include <vector>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint count_prime_set_bits(int left, int right) {\n    int count = 0;\n    for (int i = left; i <= right; i++) {\n        if (is_prime(std::bitset<32>(i).count())) count++;\n    }\n    return count;\n}\n",
            "java": "public boolean isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\npublic int countPrimeSetBits(int left, int right) {\n    int count = 0;\n    for (int i = left; i <= right; i++) {\n        int bits = Integer.bitCount(i);\n        if (isPrime(bits)) count++;\n    }\n    return count;\n}\n",
            "python": "def is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef count_prime_set_bits(left: int, right: int) -> int:\n    count = 0\n    for i in range(left, right + 1):\n        bits = bin(i).count('1')\n        if is_prime(bits):\n            count += 1\n    return count\n",
            "javascript": "function isPrime(n) {\n    if (n <= 1) return false;\n    for (let i = 2; i * i <= n; i++) {\n        if (n % i === 0) return false;\n    }\n    return true;\n}\n\nfunction countPrimeSetBits(left, right) {\n    let count = 0;\n    for (let i = left; i <= right; i++) {\n        let bits = i.toString(2).split('1').length - 1;\n        if (isPrime(bits)) count++;\n    }\n    return count;\n}\n",
            "explanation": "The algorithm consists of two functions: `is_prime` which checks if a given number is prime, and `count_prime_set_bits` which iterates through the range [left, right] and counts the numbers with a prime number of set bits in their binary representation.\n\nThe `is_prime` function checks if a number is prime by iterating through the range [2, sqrt(n)] and checking if n is divisible by any of these numbers. If it's divisible by any of these numbers, then it's not prime (returns false) otherwise, it's prime (returns true).\n\nIn the `count_prime_set_bits` function, we iterate through the range [left, right]. For each number, we count the number of set bits (1's) in its binary representation using an appropriate bit counting function/method for each language. We then check if the resulting count is prime using the `is_prime` function. If it is, we increment the counter.\n\nFinally, we return the counter after iterating through the range."
        },
        "structure": {
            "c++": "#include <bitset>\n#include <vector>\n\nbool is_prime(int n) \n    // Your code here\n}\n",
            "java": "public boolean isPrime(int n) \n    // Your code here\n}\n",
            "python": "def is_prime(n: int) -> bool:\n    # Your code here\n\n",
            "javascript": "function isPrime(n) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <bitset>\n#include <vector>\n\nint main() {\n    int left = $args;\n    int right = $args;\n    int result = count_prime_set_bits(left, right);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int countPrimeSetBits(int left, int right) {\n    int count = 0;\n    for (int i = left; i <= right; i++) {\n        int bits = Integer.bitCount(i);\n        if (isPrime(bits)) count++;\n    }\n    return count;\n}",
            "python": "if __name__ == \"__main__\":\n    left = $args[0]\n    right = $args[1]\n    result = count_prime_set_bits(left, right)\n    print(result)",
            "javascript": "function main() {\n    const left = $args[0];\n    const right = $args[1];\n    const result = countPrimeSetBits(left, right);\n    console.log(result);\n}"
        }
    },
    "769": {
        "title": "Largest Number of Chunks to Sort an Array",
        "description": "Given an integer array `arr` of length `n` that represents a permutation of the integers in the range `[0, n - 1]`, split `arr` into some number of chunks and individually sort each chunk. After concatenating them, the result should equal the sorted array. Return the largest number of chunks we can make to sort the array.",
        "example": "Example:\n\nInput: arr = [4,3,2,1,0]\nOutput: 1\nExplanation: Splitting into two or more chunks will not return the required result. For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn't sorted.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    4,
                    3,
                    2,
                    1,
                    0
                ],
                [
                    1,
                    0,
                    2,
                    3,
                    4
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    0
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1,
                    0
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    2,
                    0,
                    1,
                    4,
                    3
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    0
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    0,
                    10
                ],
                [
                    0
                ],
                [
                    1
                ],
                [
                    0,
                    1
                ],
                [
                    1,
                    0
                ],
                [
                    0,
                    1,
                    2
                ],
                [
                    2,
                    1,
                    0
                ],
                [
                    0,
                    1,
                    2,
                    3
                ],
                [
                    3,
                    2,
                    1,
                    0
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4
                ],
                [
                    4,
                    3,
                    2,
                    1,
                    0
                ]
            ],
            "outputs": [
                "1",
                "4",
                "5",
                "1",
                "1",
                "6",
                "3",
                "2",
                "10",
                "2",
                "1",
                "1",
                "2",
                "2",
                "3",
                "3",
                "4",
                "4",
                "5",
                "1"
            ]
        },
        "sample_code": {
            "c++": "int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\n    vector<vector<int>> grid(n, vector<int>(n, 1));\n    for (const auto& mine : mines)\n        grid[mine[0]][mine[1]] = 0;\n        \n    vector<vector<int>> left(grid), right(grid), up(grid), down(grid);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j]) {\n                left[i][j] = j > 0 ? left[i][j - 1] + 1 : 1;\n                up[i][j] = i > 0 ? up[i - 1][j] + 1 : 1;\n            }\n            if (grid[n - i - 1][n - j - 1]) {\n                right[n - i - 1][n - j - 1] = j > 0 ? right[n - i - 1][n - j] + 1 : 1;\n                down[n - i - 1][n - j - 1] = i > 0 ? down[n - i][n - j - 1] + 1 : 1;\n            }\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            ans = max(ans, min({left[i][j], right[i][j], up[i][j], down[i][j]}));\n    return ans;\n}\n\n",
            "java": "public int orderOfLargestPlusSign(int n, int[][] mines) {\n    int[][] grid = new int[n][n];\n    for (int[] row : grid) Arrays.fill(row, 1);\n    for (int[] mine : mines) grid[mine[0]][mine[1]] = 0;\n    \n    int[][][] dp = new int[n][n][4];\n    for (int i=0; i<n; ++i)\n        for (int j=0; j<n; ++j)\n            if (grid[i][j] > 0) {\n                dp[i][j][0] = i > 0 ? dp[i - 1][j][0] + 1 : 1;\n                dp[i][j][1] = j > 0 ? dp[i][j - 1][1] + 1 : 1;\n            }\n                \n    int ans = 0;\n    for (int i=n-1; i>=0; --i)\n        for (int j=n-1; j>=0; --j)\n            if (grid[i][j] > 0) {\n                dp[i][j][2] = i < n - 1 ? dp[i + 1][j][2] + 1 : 1;\n                dp[i][j][3] = j < n - 1 ? dp[i][j + 1][3] + 1 : 1;\n                int cur = Collections.min(Arrays.asList(dp[i][j]));\n                ans = Math.max(ans, cur);\n            }\n                \n    return ans;\n}\n\n",
            "python": "def orderOfLargestPlusSign(n, mines):\n    grid = [[1] * n for _ in range(n)]\n    for mine in mines:\n        grid[mine[0]][mine[1]] = 0\n        \n    left, right, up, down = [list(grid) for _ in range(4)]\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j]:\n                left[i][j] = 1 + (left[i][j - 1] if j > 0 else 0)\n                up[i][j] = 1 + (up[i - 1][j] if i > 0 else 0)\n\n    ans = 0\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if grid[i][j]:\n                right[i][j] = 1 + (right[i][j + 1] if j < n - 1 else 0)\n                down[i][j] = 1 + (down[i + 1][j] if i < n - 1 else 0)\n                ans = max(ans, min([left[i][j], right[i][j], up[i][j], down[i][j]]))\n\n    return ans\n\n",
            "javascript": "function orderOfLargestPlusSign(n, mines) {\n    const grid = Array.from({ length: n }, () => Array(n).fill(1));\n    for (const mine of mines)\n        grid[mine[0]][mine[1]] = 0;\n\n    const left = grid.map(row => [...row]);\n    const right = grid.map(row => [...row]);\n    const up = grid.map(row => [...row]);\n    const down = grid.map(row => [...row]);\n\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (grid[i][j]) {\n                left[i][j] = j > 0 ? left[i][j - 1] + 1 : 1;\n                up[i][j] = i > 0 ? up[i - 1][j] + 1 : 1;\n            }\n            if (grid[n - i - 1][n - j - 1]) {\n                right[n - i - 1][n - j - 1] = j > 0 ? right[n - i - 1][n - j] + 1 : 1;\n                down[n - i - 1][n - j - 1] = i > 0 ? down[n - i][n - j - 1] + 1 : 1;\n            }\n        }\n    }\n\n    let ans = 0;\n    for (let i = 0; i < n; ++i)\n        for (let j = 0; j < n; ++j)\n            ans = Math.max(ans, Math.min(left[i][j], right[i][j], up[i][j], down[i][j]));\n\n    return ans;\n}\n\n",
            "explanation": "1. Initialize a grid of n x n with all 1's and set the elements at the indices given in mines as 0.\n2. Create four matrices called left, right, up, and down which are copies of the grid.\n3. Iterate through the grid left to right, top to bottom and update the left and up matrices based on the grid values.\n4. Iterate through the grid right to left, bottom to top and update the right and down matrices based on the grid values.\n5. Iterate through the grid again and calculate the minimum value at each position between the left, right, up, and down matrices.\n6. Return the maximum value seen during step 5 which is the largest axis-aligned plus sign order."
        },
        "structure": {
            "c++": "int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) \n    // Your code here\n}\n\n",
            "java": "public int orderOfLargestPlusSign(int n, int[][] mines) \n    // Your code here\n}\n\n",
            "python": "def orderOfLargestPlusSign(n, mines):\n    # Your code here\n\n",
            "javascript": "function orderOfLargestPlusSign(n, mines) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\n    vector<vector<int>> grid(n, vector<int>(n, 1));\n    for (const auto& mine : mines)\n        grid[mine[0]][mine[1]] = 0;\n        \n    vector<vector<int>> left(grid), right(grid), up(grid), down(grid);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j]) {\n                left[i][j] = j > 0 ? left[i][j - 1] + 1 : 1;\n                up[i][j] = i > 0 ? up[i - 1][j] + 1 : 1;\n            }\n            if (grid[n - i - 1][n - j - 1]) {\n                right[n - i - 1][n - j - 1] = j > 0 ? right[n - i - 1][n - j] + 1 : 1;\n                down[n - i - 1][n - j - 1] = i > 0 ? down[n - i][n - j - 1] + 1 : 1;\n            }\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            ans = max(ans, min({left[i][j], right[i][j], up[i][j], down[i][j]}));\n    return ans;\n}",
            "java": "public int orderOfLargestPlusSign(int n, int[][] mines) {\n    int[][] grid = new int[n][n];\n    for (int[] row : grid) Arrays.fill(row, 1);\n    for (int[] mine : mines) grid[mine[0]][mine[1]] = 0;\n    \n    int[][][] dp = new int[n][n][4];\n    for (int i=0; i<n; ++i)\n        for (int j=0; j<n; ++j)\n            if (grid[i][j] > 0) {\n                dp[i][j][0] = i > 0 ? dp[i - 1][j][0] + 1 : 1;\n                dp[i][j][1] = j > 0 ? dp[i][j - 1][1] + 1 : 1;\n            }\n                \n    int ans = 0;\n    for (int i=n-1; i>=0; --i)\n        for (int j=n-1; j>=0; --j)\n            if (grid[i][j] > 0) {\n                dp[i][j][2] = i < n - 1 ? dp[i + 1][j][2] + 1 : 1;\n                dp[i][j][3] = j < n - 1 ? dp[i][j + 1][3] + 1 : 1;\n                int cur = Collections.min(Arrays.asList(dp[i][j]));\n                ans = Math.max(ans, cur);\n            }\n                \n    return ans;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    mines = $args[1]\n    result = orderOfLargestPlusSign(n, mines)\n    print(result)",
            "javascript": "function orderOfLargestPlusSign(n, mines) {\n    const grid = Array.from({ length: n }, () => Array(n).fill(1));\n    for (const mine of mines)\n        grid[mine[0]][mine[1]] = 0;\n\n    const left = grid.map(row => [...row]);\n    const right = grid.map(row => [...row]);\n    const up = grid.map(row => [...row]);\n    const down = grid.map(row => [...row]);\n\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (grid[i][j]) {\n                left[i][j] = j > 0 ? left[i][j - 1] + 1 : 1;\n                up[i][j] = i > 0 ? up[i - 1][j] + 1 : 1;\n            }\n            if (grid[n - i - 1][n - j - 1]) {\n                right[n - i - 1][n - j - 1] = j > 0 ? right[n - i - 1][n - j] + 1 : 1;\n                down[n - i - 1][n - j - 1] = i > 0 ? down[n - i][n - j - 1] + 1 : 1;\n            }\n        }\n    }\n\n    let ans = 0;\n    for (let i = 0; i < n; ++i)\n        for (let j = 0; j < n; ++j)\n            ans = Math.max(ans, Math.min(left[i][j], right[i][j], up[i][j], down[i][j]));\n\n    return ans;\n}"
        }
    },
    "770": {
        "title": "Simplified Expression",
        "description": "Given an expression and an evaluation map, simplify the expression and return a list of tokens representing the simplified expression.",
        "example": "For example, given the expression 'e + 8 - a + 5' and the evaluation map {'e': 1}, the simplified expression would be ['-1*a', '14']",
        "level": "Medium",
        "tags": [
            "expression",
            "evaluation",
            "simplification"
        ],
        "test_cases": {
            "inputs": [
                "\"e + 8 - a + 5\"",
                "{\"e\": 1}",
                "\"e - 8 + temperature - pressure\"",
                "{\"e\": 1, \"temperature\": 12}",
                "\"(e + 8) * (e - 8)\"",
                "{}"
            ],
            "outputs": [
                "[\"-1*a\", \"14\"]",
                "[\"-1*pressure\", \"5\"]",
                "[\"1*e*e\", \"-64\"]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint minSwapsCouples(vector<int>& row) {\n    int n = row.size() / 2;\n    int swaps = 0;\n    unordered_map<int, int> position;\n\n    for (int i = 0; i < row.size(); i++) {\n        position[row[i]] = i;\n    }\n\n    for (int i = 0; i < row.size(); i += 2) {\n        int couple = (row[i] % 2 == 0) ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] != couple) {\n            swap(row[i + 1], row[position[couple]]);\n            swap(position[row[i + 1]], position[couple]);\n            swaps++;\n        }\n    }\n    return swaps;\n}\n",
            "java": "import java.util.HashMap;\nimport java.util.Map;\n\npublic int minSwapsCouples(int[] row) {\n    int n = row.length / 2;\n    int swaps = 0;\n    Map<Integer, Integer> position = new HashMap<>();\n\n    for (int i = 0; i < row.length; i++) {\n        position.put(row[i], i);\n    }\n\n    for (int i = 0; i < row.length; i += 2) {\n        int couple = (row[i] % 2 == 0) ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] != couple) {\n            int temp = row[i + 1];\n            row[i + 1] = row[position.get(couple)];\n            row[position.get(couple)] = temp;\n            position.put(temp, position.get(couple));\n            position.put(couple, i + 1);\n            swaps++;\n        }\n    }\n    return swaps;\n}\n",
            "python": "def minSwapsCouples(row):\n    n = len(row) // 2\n    swaps = 0\n    position = {num: i for i, num in enumerate(row)}\n\n    for i in range(0, len(row), 2):\n        couple = row[i] - 1 if row[i] % 2 else row[i] + 1\n        if row[i + 1] != couple:\n            row[i + 1], row[position[couple]] = row[position[couple]], row[i + 1]\n            position[row[i + 1]], position[couple] = position[couple], i + 1\n            swaps += 1\n\n    return swaps\n",
            "javascript": "function minSwapsCouples(row) {\n    const n = row.length / 2;\n    let swaps = 0;\n    const position = {};\n\n    for (let i = 0; i < row.length; i++) {\n        position[row[i]] = i;\n    }\n\n    for (let i = 0; i < row.length; i += 2) {\n        const couple = (row[i] % 2 === 0) ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] !== couple) {\n            [row[i + 1], row[position[couple]]] = [row[position[couple]], row[i + 1]];\n            [position[row[i + 1]], position[couple]] = [position[couple], i + 1];\n            swaps++;\n        }\n    }\n\n    return swaps;\n}\n",
            "explanation": "1. Initialize variables: n (the number of couples), swaps (the number of swaps), and a dictionary 'position' where the keys are the person IDs and the values are their positions in the row.\n2. For each even-indexed element (i) in 'row', check if the current couple is sitting side by side.\n3. If not, find the position of the couple of the person sitting at index i, and swap the positions of the person sitting at i+1 and the couple. Update the position of them in the 'position' dictionary accordingly.\n4. Increment the swap counter.\n5. Repeat for all even-indexed elements in 'row', then return the total number of swaps.\n\nThis algorithm runs in O(n) time complexity due to iterating through the row once and performing swaps accordingly."
        },
        "structure": {
            "c++": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint minSwapsCouples(vector<int>& row) \n    // Your code here\n}\n",
            "java": "import java.util.HashMap;\nimport java.util.Map;\n\npublic int minSwapsCouples(int[] row) \n    // Your code here\n}\n",
            "python": "def minSwapsCouples(row):\n    # Your code here\n\n",
            "javascript": "function minSwapsCouples(row) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n    vector<int> row = $args;\n    int result = minSwapsCouples(row);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int minSwapsCouples(int[] row) {\n    int n = row.length / 2;\n    int swaps = 0;\n    Map<Integer, Integer> position = new HashMap<>();\n\n    for (int i = 0; i < row.length; i++) {\n        position.put(row[i], i);\n    }\n\n    for (int i = 0; i < row.length; i += 2) {\n        int couple = (row[i] % 2 == 0) ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] != couple) {\n            int temp = row[i + 1];\n            row[i + 1] = row[position.get(couple)];\n            row[position.get(couple)] = temp;\n            position.put(temp, position.get(couple));\n            position.put(couple, i + 1);\n            swaps++;\n        }\n    }\n    return swaps;\n}",
            "python": "if __name__ == \"__main__\":\n    row = $args[0]\n    result = minSwapsCouples(row)\n    print(result)",
            "javascript": "function main() {\n    const row = $args;\n    const result = minSwapsCouples(row);\n    console.log(result);\n}"
        }
    },
    "771": {
        "title": "Jewels and Stones",
        "description": "You are given two strings, `jewels` and `stones`. The `jewels` string represents the types of stones that are considered jewels, and the `stones` string represents the stones you have. Each character in the `stones` string is a type of stone you possess. Your task is to determine how many stones you have that are also jewels.",
        "example": "For example, given `jewels = \"aA\"` and `stones = \"aAAbbbb\"`, there are three stones that are also jewels: 'a', 'A', and 'A'. Therefore, the output would be `3`.",
        "level": "Easy",
        "tags": [
            "string",
            "counting"
        ],
        "test_cases": {
            "inputs": [
                [
                    "aA",
                    "aAAbbbb"
                ],
                [
                    "z",
                    "ZZ"
                ],
                [
                    "abc",
                    "abcabcabc"
                ],
                [
                    "XYZ",
                    "xyzXYZxyz"
                ],
                [
                    "123",
                    "1234567890"
                ],
                [
                    "!",
                    "!@#$%^&*()"
                ],
                [
                    " ",
                    "Hello World"
                ],
                [
                    "Bb",
                    "BbBbBbBb"
                ],
                [
                    "a",
                    "AaAaAaAa"
                ],
                [
                    "A",
                    "aAaAaAaA"
                ]
            ],
            "outputs": [
                3,
                0,
                9,
                6,
                3,
                1,
                0,
                4,
                4,
                4
            ]
        },
        "sample_code": {
            "c++": "int numJewelsInStones(string jewels, string stones) {\n    int count = 0;\n    for (char stone : stones) {\n        if (jewels.find(stone) != std::string::npos) {\n            count++;\n        }\n    }\n    return count;\n}\n",
            "java": "public int numJewelsInStones(String jewels, String stones) {\n    int count = 0;\n    for (char stone : stones.toCharArray()) {\n        if (jewels.indexOf(stone) != -1) {\n            count++;\n        }\n    }\n    return count;\n}\n",
            "python": "def num_jewels_in_stones(jewels: str, stones: str) -> int:\n    count = 0\n    for stone in stones:\n        if stone in jewels:\n            count += 1\n    return count\n",
            "javascript": "function numJewelsInStones(jewels, stones) {\n    let count = 0;\n    for (let stone of stones) {\n        if (jewels.indexOf(stone) !== -1) {\n            count++;\n        }\n    }\n    return count;\n}\n",
            "explanation": "The algorithm is pretty simple, as it iterates through each character (stone) in the `stones` string, and checks if that character is present in the `jewels` string. If it is, increment the counter. Finally, return the counter as the result.\n\nThis method does not require any additional space, except for the counter variable, and its time complexity is O(n*m) where n is the length of `stones` and m is the length of `jewels`."
        },
        "structure": {
            "c++": "int numJewelsInStones(string jewels, string stones) \n    // Your code here\n}\n",
            "java": "public int numJewelsInStones(String jewels, String stones) \n    // Your code here\n}\n",
            "python": "def num_jewels_in_stones(jewels: str, stones: str) -> int:\n    # Your code here\n\n",
            "javascript": "function numJewelsInStones(jewels, stones) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    string jewels = $args[0];\n    string stones = $args[1];\n    int result = numJewelsInStones(jewels, stones);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int numJewelsInStones(String jewels, String stones) {\n    int count = 0;\n    for (char stone : stones.toCharArray()) {\n        if (jewels.indexOf(stone) != -1) {\n            count++;\n        }\n    }\n    return count;\n}",
            "python": "if __name__ == \"__main__\":\n    jewels = $args[0]\n    stones = $args[1]\n    result = num_jewels_in_stones(jewels, stones)\n    print(result)",
            "javascript": "function main() {\n    const jewels = $args[0];\n    const stones = $args[1];\n    const result = numJewelsInStones(jewels, stones);\n    console.log(result);\n}"
        }
    },
    "777": {
        "title": "String Transformation",
        "description": "Given a string composed of 'L', 'R', and 'X' characters, a move consists of either replacing one occurrence of 'XL ' with 'LX ', or replacing one occurrence of 'RX ' with 'XR '. Given the starting string 'start' and the ending string 'end', return True if and only if there exists a sequence of moves to transform one string to the other.",
        "example": "Example:\n\nInput: start = \"RXXLRXRXL \", end = \"XRLXXRRLX \"\nOutput: true\nExplanation: We can transform start to end following these steps:\nRXXLRXRXL ->\nXRXLRXRXL ->\nXRLXRXRXL ->\nXRLXXRRXL ->\nXRLXXRRLX",
        "level": "Medium",
        "tags": [
            "string",
            "transformation"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "RXXLRXRXL ",
                        "XRLXXRRLX "
                    ]
                ],
                [
                    [
                        "X ",
                        "L "
                    ]
                ],
                [
                    [
                        "LX ",
                        "XL "
                    ]
                ],
                [
                    [
                        "RX ",
                        "XR "
                    ]
                ],
                [
                    [
                        "LXRX ",
                        "XLRX "
                    ]
                ],
                [
                    [
                        "RXLX ",
                        "XRLX "
                    ]
                ],
                [
                    [
                        "LXRX ",
                        "XRLX "
                    ]
                ],
                [
                    [
                        "RXLX ",
                        "XLRX "
                    ]
                ],
                [
                    [
                        "LXRX ",
                        "XLRX "
                    ]
                ],
                [
                    [
                        "RXLX ",
                        "XRLX "
                    ]
                ],
                [
                    [
                        "LXRX ",
                        "XRLX "
                    ]
                ],
                [
                    [
                        "RXLX ",
                        "XLRX "
                    ]
                ],
                [
                    [
                        "LXRX ",
                        "XLRX "
                    ]
                ],
                [
                    [
                        "RXLX ",
                        "XRLX "
                    ]
                ],
                [
                    [
                        "LXRX ",
                        "XRLX "
                    ]
                ],
                [
                    [
                        "RXLX ",
                        "XLRX "
                    ]
                ],
                [
                    [
                        "LXRX ",
                        "XLRX "
                    ]
                ],
                [
                    [
                        "RXLX ",
                        "XRLX "
                    ]
                ],
                [
                    [
                        "LXRX ",
                        "XRLX "
                    ]
                ],
                [
                    [
                        "RXLX ",
                        "XLRX "
                    ]
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "bool isToeplitzMatrix(vector<vector<int>>& matrix) {\n    int rows = matrix.size();\n    int cols = matrix[0].size();\n    for(int i = 0; i < rows - 1; ++i) {\n        for(int j = 0; j < cols - 1; ++j) {\n            if(matrix[i][j] != matrix[i+1][j+1]) return false;\n        }\n    }\n    return true;\n}\n\n",
            "java": "public boolean isToeplitzMatrix(int[][] matrix) {\n    int rows = matrix.length;\n    int cols = matrix[0].length;\n    for(int i = 0; i < rows - 1; i++) {\n        for(int j = 0; j < cols - 1; j++) {\n            if(matrix[i][j] != matrix[i+1][j+1]) return false;\n        }\n    }\n    return true;\n}\n\n",
            "python": "def isToeplitzMatrix(matrix):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    for i in range(rows - 1):\n        for j in range(cols - 1):\n            if matrix[i][j] != matrix[i+1][j+1]:\n                return False\n    return True\n\n",
            "javascript": "function isToeplitzMatrix(matrix) {\n    const rows = matrix.length;\n    const cols = matrix[0].length;\n    for(let i = 0; i < rows - 1; i++) {\n        for(let j = 0; j < cols - 1; j++) {\n            if(matrix[i][j] !== matrix[i+1][j+1]) return false;\n        }\n    }\n    return true;\n}\n\n",
            "explanation": "The algorithm iterates through each element in the matrix except the last row and last column. For each element, it checks if it is equal to the element on the bottom right diagonal. If any such pair of elements is not equal, the matrix is not Toeplitz and the function returns false. If every pair of elements is equal, the matrix is Toeplitz and the function returns true."
        },
        "structure": {
            "c++": "bool isToeplitzMatrix(vector<vector<int>>& matrix) \n    // Your code here\n}\n\n",
            "java": "public boolean isToeplitzMatrix(int[][] matrix) \n    // Your code here\n}\n\n",
            "python": "def isToeplitzMatrix(matrix):\n    # Your code here\n\n",
            "javascript": "function isToeplitzMatrix(matrix) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "bool isToeplitzMatrix(vector<vector<int>>& matrix) {\n    int rows = matrix.size();\n    int cols = matrix[0].size();\n    for(int i = 0; i < rows - 1; ++i) {\n        for(int j = 0; j < cols - 1; ++j) {\n            if(matrix[i][j] != matrix[i+1][j+1]) return false;\n        }\n    }\n    return true;\n}",
            "java": "public boolean isToeplitzMatrix(int[][] matrix) {\n    int rows = matrix.length;\n    int cols = matrix[0].length;\n    for(int i = 0; i < rows - 1; i++) {\n        for(int j = 0; j < cols - 1; j++) {\n            if(matrix[i][j] != matrix[i+1][j+1]) return false;\n        }\n    }\n    return true;\n}",
            "python": "if __name__ == \"__main__\":\n    matrix = $args[0]\n    result = isToeplitzMatrix(matrix)\n    print(result)",
            "javascript": "function main() {\n    const matrix = $args;\n    const result = isToeplitzMatrix(matrix);\n    console.log(result);\n}\n"
        }
    },
    "778": {
        "title": "Minimum Time to Swim in Rain",
        "description": "You are given an `n x n` integer matrix `grid` where each value `grid[i][j]` represents the elevation at that point `(i, j)`. The rain starts to fall. At time `t`, the depth of the water everywhere is `t`. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most `t`. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim. Return the least time until you can reach the bottom right square `(n - 1, n - 1)` if you start at the top left square `(0, 0)`.",
        "example": "Example:\n\nInput: grid = [[0,2],[1,3]]\nOutput: 3\nExplanation: At time 0, you are in grid location (0, 0). You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0. You cannot reach point (1, 1) until time 3. When the depth of water is 3, we can swim anywhere inside the grid.",
        "level": "Medium",
        "tags": [
            "matrix",
            "graph",
            "bfs"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        0,
                        2
                    ],
                    [
                        1,
                        3
                    ]
                ],
                [
                    [
                        0,
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        24,
                        23,
                        22,
                        21,
                        5
                    ],
                    [
                        12,
                        13,
                        14,
                        15,
                        16
                    ],
                    [
                        11,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        10,
                        9,
                        8,
                        7,
                        6
                    ]
                ],
                [
                    [
                        0,
                        1,
                        2
                    ],
                    [
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        1,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        2,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        3,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        4,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        5,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        6,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        7,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        8,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        9,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        10,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        11,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        12,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        13,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        14,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        15,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        16,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        17,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ]
            ],
            "outputs": [
                "3",
                "16",
                "8",
                "2",
                "2",
                "3",
                "3",
                "4",
                "4",
                "5",
                "5",
                "6",
                "6",
                "7",
                "7",
                "8",
                "8",
                "9",
                "9",
                "10"
            ]
        },
        "sample_code": {
            "c++": "#include <queue>\n\nstd::string rearrangeString(std::string s) {\n    std::unordered_map<char, int> counts;\n    for (char c : s) {\n        counts[c]++;\n    }\n    \n    auto cmp = [](const auto& a, const auto& b) {\n        return a.second < b.second;\n    };\n    \n    std::priority_queue<std::pair<char, int>, std::vector<std::pair<char, int>>, decltype(cmp)> pq(cmp);\n    \n    for (auto& count : counts) {\n        pq.push(count);\n    }\n    \n    std::string result;\n    std::pair<char, int> previous = {-1, 0};\n    \n    while (!pq.empty()) {\n        auto current = pq.top();\n        pq.pop();\n        result += current.first;\n        \n        if (previous.second > 0) {\n            pq.push(previous);\n        }\n        \n        current.second--;\n        previous = current;\n    }\n    \n    return result.size() == s.size() ? result : \"\";\n}\n\n",
            "java": "import java.util.PriorityQueue;\nimport java.util.HashMap;\n\npublic String rearrangeString(String s) {\n    HashMap<Character, Integer> counts = new HashMap<>();\n    for (char c : s.toCharArray()) {\n        counts.put(c, counts.getOrDefault(c, 0) + 1);\n    }\n    \n    PriorityQueue<Character> pq = new PriorityQueue<>((a, b) -> counts.get(b) - counts.get(a));\n    pq.addAll(counts.keySet());\n    \n    StringBuilder result = new StringBuilder();\n    Character previous = null;\n    \n    while (!pq.isEmpty()) {\n        char current = pq.remove();\n        result.append(current);\n        \n        if (previous != null && counts.get(previous) > 0) {\n            pq.add(previous);\n        }\n        \n        counts.put(current, counts.get(current) - 1);\n        previous = current;\n    }\n    \n    return result.length() == s.length() ? result.toString() : \"\";\n}\n\n",
            "python": "import heapq\n\ndef rearrange_string(s):\n    counts = {}\n    for c in s:\n        counts[c] = counts.get(c, 0) + 1\n    \n    pq = [(-count, char) for char, count in counts.items()]\n    heapq.heapify(pq)\n    \n    result = []\n    previous = (0, '')\n    \n    while pq:\n        count, char = heapq.heappop(pq)\n        result.append(char)\n        \n        if previous[0] < 0:\n            heapq.heappush(pq, previous)\n        \n        count += 1\n        previous = (count, char)\n    \n    result_str = ''.join(result)\n    return result_str if len(result_str) == len(s) else \"\"\n\n",
            "javascript": "function rearrangeString(s) {\n    const counts = new Map();\n    for (const c of s) {\n        counts.set(c, (counts.get(c) || 0) + 1);\n    }\n    \n    const pq = Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);\n    \n    const result = [];\n    let previous = [-1, null];\n    \n    while (pq.length) {\n        const current = pq.shift();\n        result.push(current[0]);\n        \n        if (previous[0] > 0) {\n            pq.push(previous);\n        }\n        \n        current[1]--;\n        previous = current;\n        pq.sort((a, b) => b[1] - a[1]);\n    }\n    \n    const resultStr = result.join('');\n    return resultStr.length === s.length ? resultStr : \"\";\n}\n\n",
            "explanation": "The algorithm uses a priority queue to store characters and their counts in descending order based on the counts. Then, it iterates over the priority queue, adding the character with the highest count to the result string. After adding a character to the result, its count is decremented. If the previously added character's count is still positive, it is added back to the priority queue.\n\nThe priority queue is used to ensure that the characters with the highest counts are placed as far apart as possible in the resultant string. If it is possible to rearrange the string, the length of the result will be equal to the length of the input string. If not, we return an empty string, as it is not possible to form a valid rearrangement."
        },
        "structure": {
            "c++": "#include <queue>\n\nstd::string rearrangeString(std::string s) \n    // Your code here\n}\n\n",
            "java": "import java.util.PriorityQueue;\nimport java.util.HashMap;\n\npublic String rearrangeString(String s) \n    // Your code here\n}\n\n",
            "python": "import heapq\n    # Your code here\n\n",
            "javascript": "function rearrangeString(s) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    string s = $args;\n    string result = rearrangeString(s);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public String rearrangeString(String s) {\n    HashMap<Character, Integer> counts = new HashMap<>();\n    for (char c : s.toCharArray()) {\n        counts.put(c, counts.getOrDefault(c, 0) + 1);\n    }\n    \n    PriorityQueue<Character> pq = new PriorityQueue<>((a, b) -> counts.get(b) - counts.get(a));\n    pq.addAll(counts.keySet());\n    \n    StringBuilder result = new StringBuilder();\n    Character previous = null;\n    \n    while (!pq.isEmpty()) {\n        char current = pq.remove();\n        result.append(current);\n        \n        if (previous != null && counts.get(previous) > 0) {\n            pq.add(previous);\n        }\n        \n        counts.put(current, counts.get(current) - 1);\n        previous = current;\n    }\n    \n    return result.length() == s.length() ? result.toString() : \"\";\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args[0]\n    result = rearrange_string(s)\n    print(result)",
            "javascript": "function rearrangeString(s) {\n    const counts = new Map();\n    for (const c of s) {\n        counts.set(c, (counts.get(c) || 0) + 1);\n    }\n\n    const pq = Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);\n\n    const result = [];\n    let previous = [-1, null];\n\n    while (pq.length) {\n        const current = pq.shift();\n        result.push(current[0]);\n\n        if (previous[0] > 0) {\n            pq.push(previous);\n        }\n\n        current[1]--;\n        previous = current;\n        pq.sort((a, b) => b[1] - a[1]);\n    }\n\n    const resultStr = result.join('');\n    return resultStr.length === s.length ? resultStr : \"\";\n}"
        }
    },
    "779": {
        "title": "Kth Symbol in Grammar",
        "description": "We build a table of `n` rows (1-indexed). We start by writing `0` in the `1st` row. Now in every subsequent row, we look at the previous row and replace each occurrence of `0` with `01`, and each occurrence of `1` with `10`. Given two integers `n` and `k`, return the `kth` (1-indexed) symbol in the `nth` row of a table of `n` rows.",
        "example": "For example, for `n = 3`, the `1st` row is `0`, the `2nd` row is `01`, and the `3rd` row is `0110`.\n\n**Input:** n = 1, k = 1\n**Output:** 0\n**Explanation:** row 1: 0\n\n**Input:** n = 2, k = 1\n**Output:** 0\n**Explanation:**\nrow 1: 0\nrow 2: 01\n\n**Input:** n = 2, k = 2\n**Output:** 1\n**Explanation:**\nrow 1: 0\nrow 2: 01",
        "level": "Easy",
        "tags": [
            "math",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    1
                ],
                [
                    2,
                    1
                ],
                [
                    2,
                    2
                ],
                [
                    3,
                    1
                ],
                [
                    3,
                    2
                ],
                [
                    3,
                    3
                ],
                [
                    4,
                    1
                ],
                [
                    4,
                    2
                ],
                [
                    4,
                    3
                ],
                [
                    4,
                    4
                ],
                [
                    5,
                    1
                ],
                [
                    5,
                    2
                ],
                [
                    5,
                    3
                ],
                [
                    5,
                    4
                ],
                [
                    5,
                    5
                ],
                [
                    6,
                    1
                ],
                [
                    6,
                    2
                ],
                [
                    6,
                    3
                ],
                [
                    6,
                    4
                ],
                [
                    6,
                    5
                ]
            ],
            "outputs": [
                0,
                0,
                1,
                0,
                1,
                1,
                0,
                1,
                1,
                0,
                1,
                0,
                1,
                0,
                0,
                1,
                0,
                1,
                1,
                0,
                1
            ]
        },
        "sample_code": {
            "c++": "int maxChunksToSorted(vector<int>& arr) {\n    int max_val = 0, chunks = 0;\n    for (int i = 0; i < arr.size(); ++i) {\n        max_val = max(max_val, arr[i]);\n        if (max_val == i) {\n            chunks++;\n        }\n    }\n    return chunks;\n}\n",
            "java": "public int maxChunksToSorted(int[] arr) {\n    int max_val = 0, chunks = 0;\n    for (int i = 0; i < arr.length; i++) {\n        max_val = Math.max(max_val, arr[i]);\n        if (max_val == i) {\n            chunks++;\n        }\n    }\n    return chunks;\n}\n",
            "python": "def max_chunks_to_sorted(arr):\n    max_val, chunks = 0, 0\n    for i, value in enumerate(arr):\n        max_val = max(max_val, value)\n        if max_val == i:\n            chunks += 1\n    return chunks\n",
            "javascript": "function maxChunksToSorted(arr) {\n    let max_val = 0, chunks = 0;\n    for (let i = 0; i < arr.length; i++) {\n        max_val = Math.max(max_val, arr[i]);\n        if (max_val === i) {\n            chunks++;\n        }\n    }\n    return chunks;\n}\n",
            "explanation": "We maintain a variable `max_val` that keeps track of the current maximum value in the array till index `i`. If the current maximum value is equal to the index, that means all elements from the beginning to the current index can be considered a chunk. We increment the `chunks` counter in that case. At the end, the counter `chunks` represents the maximum number of chunks we can make to sort the array."
        },
        "structure": {
            "c++": "int maxChunksToSorted(vector<int>& arr) \n    // Your code here\n}\n",
            "java": "public int maxChunksToSorted(int[] arr) \n    // Your code here\n}\n",
            "python": "def max_chunks_to_sorted(arr):\n    # Your code here\n\n",
            "javascript": "function maxChunksToSorted(arr) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> arr = $args;\n    int result = maxChunksToSorted(arr);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int maxChunksToSorted(int[] arr) {\n    int max_val = 0, chunks = 0;\n    for (int i = 0; i < arr.length; i++) {\n        max_val = Math.max(max_val, arr[i]);\n        if (max_val == i) {\n            chunks++;\n        }\n    }\n    return chunks;\n}",
            "python": "if __name__ == \"__main__\":\n    arr = $args[0]\n    result = max_chunks_to_sorted(arr)\n    print(result)",
            "javascript": "function main() {\n    const arr = $args;\n    const result = maxChunksToSorted(arr);\n    console.log(result);\n}"
        }
    },
    "780": {
        "title": "Point Conversion",
        "description": "Given four integers `sx`, `sy`, `tx`, and `ty`, determine if it is possible to convert the point `(sx, sy)` to the point `(tx, ty)` through a series of operations. The allowed operations on a point `(x, y)` are to convert it to either `(x, x + y)` or `(x + y, y)`.",
        "example": "Example 1:\n\nInput: sx = 1, sy = 1, tx = 3, ty = 5\nOutput: true\nExplanation: One series of moves that transforms the starting point to the target is:\n(1, 1) -> (1, 2)\n(1, 2) -> (3, 2)\n(3, 2) -> (3, 5)\n\nExample 2:\n\nInput: sx = 1, sy = 1, tx = 2, ty = 2\nOutput: false\n\nExample 3:\n\nInput: sx = 1, sy = 1, tx = 1, ty = 1\nOutput: true",
        "level": "Medium",
        "tags": [
            "math",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    1,
                    3,
                    5
                ],
                [
                    1,
                    1,
                    2,
                    2
                ],
                [
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    3,
                    5,
                    8
                ],
                [
                    10,
                    20,
                    30,
                    50
                ],
                [
                    1,
                    2,
                    3,
                    5
                ],
                [
                    5,
                    8,
                    13,
                    21
                ],
                [
                    1,
                    1,
                    1000000000,
                    1000000000
                ],
                [
                    1,
                    1,
                    1000000000,
                    1000000001
                ],
                [
                    1,
                    1,
                    1000000001,
                    1000000000
                ],
                [
                    1000000000,
                    1000000000,
                    1000000000,
                    1000000000
                ],
                [
                    1000000000,
                    1000000000,
                    1000000000,
                    1000000001
                ],
                [
                    1000000000,
                    1000000000,
                    1000000001,
                    1000000000
                ],
                [
                    1000000000,
                    1000000000,
                    1000000001,
                    1000000001
                ],
                [
                    1000000001,
                    1000000001,
                    1000000001,
                    1000000001
                ],
                [
                    1,
                    1,
                    2,
                    3
                ],
                [
                    1,
                    1,
                    3,
                    2
                ],
                [
                    1,
                    1,
                    5,
                    8
                ],
                [
                    1,
                    1,
                    8,
                    5
                ],
                [
                    1,
                    1,
                    13,
                    21
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                false,
                false,
                true,
                true,
                true,
                true,
                true,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "int maxChunksToSorted(vector<int>& arr) {\n    int max_so_far = 0, count = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far = max(max_so_far, arr[i]);\n        if (max_so_far == i) {\n            count++;\n        }\n    }\n    return count;\n}\n\n",
            "java": "public int maxChunksToSorted(int[] arr) {\n    int max_so_far = 0, count = 0;\n    for (int i = 0; i < arr.length; i++) {\n        max_so_far = Math.max(max_so_far, arr[i]);\n        if (max_so_far == i) {\n            count++;\n        }\n    }\n    return count;\n}\n\n",
            "python": "def max_chunks_to_sorted(arr):\n    max_so_far, count = 0, 0\n    for i, val in enumerate(arr):\n        max_so_far = max(max_so_far, val)\n        if max_so_far == i:\n            count += 1\n    return count\n\n",
            "javascript": "function maxChunksToSorted(arr) {\n    let max_so_far = 0, count = 0;\n    for (let i = 0; i < arr.length; i++) {\n        max_so_far = Math.max(max_so_far, arr[i]);\n        if (max_so_far === i) {\n            count++;\n        }\n    }\n    return count;\n}\n\n",
            "explanation": "Iterate through the array and track the maximum value found so far (max_so_far), as well as the number of chunks (count). For each element in the array, update the max_so_far to the maximum of its current value and the current element. If the max_so_far is equal to the current index, it means that it is possible to create a sorted chunk from the starting index to the current index. Increase the count and continue iterating through the array until the end. Finally, return the count."
        },
        "structure": {
            "c++": "int maxChunksToSorted(vector<int>& arr) \n    // Your code here\n}\n\n",
            "java": "public int maxChunksToSorted(int[] arr) \n    // Your code here\n}\n\n",
            "python": "def max_chunks_to_sorted(arr):\n    # Your code here\n\n",
            "javascript": "function maxChunksToSorted(arr) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> arr = $args;\n    int result = maxChunksToSorted(arr);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int maxChunksToSorted(int[] arr) {\n    int max_so_far = 0, count = 0;\n    for (int i = 0; i < arr.length; i++) {\n        max_so_far = Math.max(max_so_far, arr[i]);\n        if (max_so_far == i) {\n            count++;\n        }\n    }\n    return count;\n}",
            "python": "if __name__ == \"__main__\":\n    arr = $args[0]\n    result = max_chunks_to_sorted(arr)\n    print(result)",
            "javascript": "function main() {\n    const arr = $args;\n    const result = maxChunksToSorted(arr);\n    console.log(result);\n}\n"
        }
    }
}