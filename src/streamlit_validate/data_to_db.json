{
    "1": {
        "title": "Two Sum",
        "description": "Given an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
        "example": "Given an array nums = [2,7,11,15] and target = 9, the output should be [0,1] because nums[0] + nums[1] = 2 + 7 = 9.",
        "level": "Easy",
        "tags": [
            "Array",
            "Two Pointers"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        2,
                        7,
                        11,
                        15
                    ],
                    9
                ],
                [
                    [
                        3,
                        2,
                        4
                    ],
                    6
                ],
                [
                    [
                        3,
                        3
                    ],
                    6
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    9
                ],
                [
                    [
                        10,
                        20,
                        30,
                        40,
                        50
                    ],
                    70
                ],
                [
                    [
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    0
                ],
                [
                    [
                        -1,
                        -2,
                        -3,
                        -4,
                        -5
                    ],
                    -8
                ],
                [
                    [
                        100,
                        200,
                        300,
                        400,
                        500
                    ],
                    600
                ],
                [
                    [
                        1,
                        3,
                        5,
                        7,
                        9
                    ],
                    12
                ],
                [
                    [
                        2,
                        4,
                        6,
                        8,
                        10
                    ],
                    14
                ],
                [
                    [
                        9,
                        8,
                        7,
                        6,
                        5
                    ],
                    14
                ],
                [
                    [
                        5,
                        10,
                        15,
                        20,
                        25
                    ],
                    30
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    2
                ],
                [
                    [
                        2,
                        2,
                        2,
                        2,
                        2
                    ],
                    4
                ],
                [
                    [
                        3,
                        6,
                        9,
                        12,
                        15
                    ],
                    18
                ],
                [
                    [
                        4,
                        8,
                        12,
                        16,
                        20
                    ],
                    24
                ],
                [
                    [
                        5,
                        5,
                        5,
                        5,
                        5
                    ],
                    10
                ],
                [
                    [
                        6,
                        12,
                        18,
                        24,
                        30
                    ],
                    36
                ],
                [
                    [
                        7,
                        14,
                        21,
                        28,
                        35
                    ],
                    42
                ],
                [
                    [
                        8,
                        16,
                        24,
                        32,
                        40
                    ],
                    48
                ]
            ],
            "outputs": [
                [
                    0,
                    1
                ],
                [
                    1,
                    2
                ],
                [
                    0,
                    1
                ],
                [
                    2,
                    4
                ],
                [
                    1,
                    3
                ],
                [
                    0,
                    1
                ],
                [
                    1,
                    4
                ],
                [
                    1,
                    3
                ],
                [
                    1,
                    3
                ],
                [
                    0,
                    2
                ],
                [
                    1,
                    2
                ],
                [
                    0,
                    3
                ],
                [
                    0,
                    1
                ],
                [
                    0,
                    1
                ],
                [
                    2,
                    4
                ],
                [
                    1,
                    3
                ],
                [
                    0,
                    4
                ],
                [
                    1,
                    3
                ],
                [
                    0,
                    2
                ],
                [
                    1,
                    3
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <unordered_map>\n\nstd::vector<int> twoSum(std::vector<int>& nums, int target) {\n    std::unordered_map<int, int> map;\n    for (int i = 0; i < nums.size(); i++) {\n        int complement = target - nums[i];\n        if (map.find(complement) != map.end()) {\n            return {map[complement], i};\n        }\n        map[nums[i]] = i;\n    }\n    return {};\n}\n",
            "java": "public int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[]{map.get(complement), i};\n        }\n        map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}\n",
            "python": "def twoSum(nums, target):\n    map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in map:\n            return [map[complement], i]\n        map[num] = i\n    return []\n",
            "javascript": "function twoSum(nums, target) {\n    const map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (map.has(complement)) {\n            return [map.get(complement), i];\n        }\n        map.set(nums[i], i);\n    }\n    return [];\n}\n",
            "explanation": "The algorithm leverages a hash map (unordered_map in C++, HashMap in Java, dictionary in Python, and Map in JavaScript). It iterates through the given 'nums' array and calculates the complementary value (target - current value). If the complementary value is already in the hash map, it means that we found a solution, and we return those indices. If the complement is not in the hash map, we store the current element in the hash map with its index. If the algorithm doesn't find the solution, it returns an empty array or throws an exception (in Java).\n\nThis approach has a time complexity of O(n) and a space complexity of O(n) as well."
        },
        "structure": {
            "c++": "#include <vector>\n#include <unordered_map>\n\nstd::vector<int> twoSum(std::vector<int>& nums, int target) {\n    // Your code here\n}\n",
            "java": "import java.util.HashMap;\nimport java.util.Map;\n\npublic int[] twoSum(int[] nums, int target) {\n    // Your code here\n}\n",
            "python": "def twoSum(nums, target):\n    # Your code here\n\n",
            "javascript": "function twoSum(nums, target) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nint main() {\n    std::vector<int> nums =$args;\n    int target = $args;\n    std::vector<int> result = twoSum(nums, target);\n    for (int i = 0; i < result.size(); i++) {\n        std::cout << result[i] << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs =  $args\n    nums = inputs[0]\n    target = inputs[1]\n    result = twoSum(nums, target)\n    print(result)",
            "javascript": "function main() {\n    let inputs = $args\n    const nums = inputs[0];\n    const target = inputs[1];\n    const result = twoSum(nums, target);\n    console.log(result);\n}",
            "java": "public static void main(String[] args) {\n    int[] nums = $args;\n    int target = $args;\n    int[] result = twoSum(nums, target);\n    System.out.println(Arrays.toString(result));\n}"
        }
    },
    "3": {
        "title": "Longest Substring Without Repeating Characters",
        "description": "Given a string `s`, find the length of the longest substring without repeating characters.",
        "example": "Example 1:\n\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.",
        "level": "Medium",
        "tags": [
            "string",
            "sliding window",
            "hash table"
        ],
        "test_cases": {
            "inputs": [
                "\"abcabcbb\"",
                "\"bbbbb\"",
                "\"pwwkew\"",
                "\"\"",
                "\"a\"",
                "\"abcdefg\"",
                "\"aab\"",
                "\"abb\"",
                "\"abcabcabc\"",
                "\"abcdeffghijklmnopqrstuvwxyz\""
            ],
            "outputs": [
                "3",
                "1",
                "3",
                "0",
                "1",
                "7",
                "2",
                "2",
                "3",
                "26"
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <unordered_set>\n\nint lengthOfLongestSubstring(std::string s) {\n    int left = 0, right = 0, maxLength = 0;\n    std::unordered_set<char> characters;\n\n    while (right < s.size()) {\n        if (characters.find(s[right]) == characters.end()) {\n            characters.insert(s[right]);\n            maxLength = std::max(maxLength, right - left + 1);\n            right++;\n        } else {\n            characters.erase(s[left]);\n            left++;\n        }\n    }\n\n    return maxLength;\n}\n",
            "java": "import java.util.HashSet;\nimport java.util.Set;\n\npublic int lengthOfLongestSubstring(String s) {\n    int left = 0, right = 0, maxLength = 0;\n    Set<Character> characters = new HashSet<>();\n\n    while (right < s.length()) {\n        if (!characters.contains(s.charAt(right))) {\n            characters.add(s.charAt(right));\n            maxLength = Math.max(maxLength, right - left + 1);\n            right++;\n        } else {\n            characters.remove(s.charAt(left));\n            left++;\n        }\n    }\n\n    return maxLength;\n}\n",
            "python": "def length_of_longest_substring(s: str) -> int:\n    left = 0\n    right = 0\n    max_length = 0\n    characters = set()\n\n    while right < len(s):\n        if s[right] not in characters:\n            characters.add(s[right])\n            max_length = max(max_length, right - left + 1)\n            right += 1\n        else:\n            characters.remove(s[left])\n            left += 1\n\n    return max_length\n",
            "javascript": "function lengthOfLongestSubstring(s) {\n    let left = 0, right = 0, maxLength = 0;\n    const characters = new Set();\n\n    while (right < s.length) {\n        if (!characters.has(s.charAt(right))) {\n            characters.add(s.charAt(right));\n            maxLength = Math.max(maxLength, right - left + 1);\n            right++;\n        } else {\n            characters.delete(s.charAt(left));\n            left++;\n        }\n    }\n\n    return maxLength;\n}\n",
            "explanation": "The algorithm uses a sliding window with two pointers, left and right, to iterate through the string. It also uses a set to store the unique characters in the current window.\n\n1. Initialize left and right pointers to the start of the string, and maxLength to 0.\n2. Check if the character at the right index is in the set.\n   - If it's not in the set, add the character to the set, update maxLength, and move the right pointer forward.\n   - If it's in the set, remove the character at the left index from the set, and move the left pointer forward.\n3. Repeat step 2 until the right pointer reaches the end of the string.\n4. Return maxLength. \n\nThe algorithm runs in O(n) time, where n is the length of the input string."
        },
        "structure": {
            "c++": "#include <string>\n#include <unordered_set>\n\nint lengthOfLongestSubstring(std::string s) \n    // Your code here\n}\n",
            "java": "import java.util.HashSet;\nimport java.util.Set;\n\npublic int lengthOfLongestSubstring(String s) \n    // Your code here\n}\n",
            "python": "def length_of_longest_substring(s: str) -> int:\n    # Your code here\n\n",
            "javascript": "function lengthOfLongestSubstring(s) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <string>\n#include <unordered_set>\n\nint lengthOfLongestSubstring(std::string s) {\n    int left = 0, right = 0, maxLength = 0;\n    std::unordered_set<char> characters;\n\n    while (right < s.size()) {\n        if (characters.find(s[right]) == characters.end()) {\n            characters.insert(s[right]);\n            maxLength = std::max(maxLength, right - left + 1);\n            right++;\n        } else {\n            characters.erase(s[left]);\n            left++;\n        }\n    }\n\n    return maxLength;\n}\n\nint main() {\n    std::string s = $args;\n    int result = lengthOfLongestSubstring(s);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = length_of_longest_substring(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = lengthOfLongestSubstring(s);\n    console.log(result);\n}",
            "java": "public int lengthOfLongestSubstring(String s) {\n    int left = 0, right = 0, maxLength = 0;\n    Set<Character> characters = new HashSet<>();\n\n    while (right < s.length()) {\n        if (!characters.contains(s.charAt(right))) {\n            characters.add(s.charAt(right));\n            maxLength = Math.max(maxLength, right - left + 1);\n            right++;\n        } else {\n            characters.remove(s.charAt(left));\n            left++;\n        }\n    }\n\n    return maxLength;\n}"
        }
    },
    "4": {
        "title": "Median of Two Sorted Arrays",
        "description": "Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).",
        "example": "Given nums1 = [1,3] and nums2 = [2], the merged array is [1,2,3] and the median is 2.0.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        3
                    ],
                    [
                        2
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ]
                ],
                [
                    [
                        1,
                        2,
                        5,
                        9
                    ],
                    [
                        3,
                        4,
                        6,
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        8,
                        9,
                        10,
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        8,
                        9,
                        10,
                        11,
                        12,
                        13
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12,
                        13
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12,
                        13,
                        14
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        10,
                        11,
                        12,
                        13,
                        14
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        12,
                        13,
                        14,
                        15,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        12,
                        13,
                        14,
                        15,
                        16,
                        17
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16,
                        17
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16,
                        17,
                        18
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13
                    ],
                    [
                        14,
                        15,
                        16,
                        17,
                        18
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13
                    ],
                    [
                        14,
                        15,
                        16,
                        17,
                        18,
                        19
                    ]
                ]
            ],
            "outputs": [
                2.0,
                2.5,
                5.5,
                5.5,
                6.0,
                6.0,
                6.5,
                6.5,
                7.0,
                7.0,
                7.5,
                7.5,
                8.0,
                8.0,
                8.5,
                8.5,
                9.0,
                9.0,
                9.5,
                9.5
            ]
        },
        "sample_code": {
            "c++": "double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n    if (nums1.size() > nums2.size()) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    int x = nums1.size();\n    int y = nums2.size();\n    int low = 0;\n    int high = x;\n    \n    while (low <= high) {\n        int partitionX = (low + high) / 2;\n        int partitionY = (x + y + 1) / 2 - partitionX;\n        \n        int maxLeftX = (partitionX == 0) ? INT_MIN : nums1[partitionX - 1];\n        int minRightX = (partitionX == x) ? INT_MAX : nums1[partitionX];\n        \n        int maxLeftY = (partitionY == 0) ? INT_MIN : nums2[partitionY - 1];\n        int minRightY = (partitionY == y) ? INT_MAX : nums2[partitionY];\n        \n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 == 0) {\n                return (double(max(maxLeftX, maxLeftY) + min(minRightX, minRightY))) / 2;\n            } else {\n                return double(max(maxLeftX, maxLeftY));\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }    \n    return 0;\n}\n",
            "java": "public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n    if (nums1.length > nums2.length) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    int x = nums1.length;\n    int y = nums2.length;\n    int low = 0;\n    int high = x;\n    \n    while (low <= high) {\n        int partitionX = (low + high) / 2;\n        int partitionY = (x + y + 1) / 2 - partitionX;\n        \n        int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];\n        int minRightX = (partitionX == x) ? Integer.MAX_VALUE : nums1[partitionX];\n        \n        int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : nums2[partitionY - 1];\n        int minRightY = (partitionY == y) ? Integer.MAX_VALUE : nums2[partitionY];\n        \n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 == 0) {\n                return (double)(Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\n            } else {\n                return (double)Math.max(maxLeftX, maxLeftY);\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }    \n    return 0;\n}\n",
            "python": "def findMedianSortedArrays(nums1, nums2):\n    if len(nums1) > len(nums2):\n        return findMedianSortedArrays(nums2, nums1)\n    \n    x, y = len(nums1), len(nums2)\n    low, high = 0, x\n\n    while low <= high:\n        partition_x = (low + high) // 2\n        partition_y = (x + y + 1) // 2 - partition_x\n\n        max_left_x = float('-inf') if partition_x == 0 else nums1[partition_x - 1]\n        min_right_x = float('inf') if partition_x == x else nums1[partition_x]\n\n        max_left_y = float('-inf') if partition_y == 0 else nums2[partition_y - 1]\n        min_right_y = float('inf') if partition_y == y else nums2[partition_y]\n\n        if max_left_x <= min_right_y and max_left_y <= min_right_x:\n            if (x + y) % 2 == 0:\n                return (max(max_left_x, max_left_y) + min(min_right_x, min_right_y)) / 2\n            else:\n                return max(max_left_x, max_left_y)\n        elif max_left_x > min_right_y:\n            high = partition_x - 1\n        else:\n            low = partition_x + 1\n    \n    return 0\n",
            "javascript": "function findMedianSortedArrays(nums1, nums2) {\n    if (nums1.length > nums2.length) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    const x = nums1.length;\n    const y = nums2.length;\n    let low = 0;\n    let high = x;\n    \n    while (low <= high) {\n        const partitionX = Math.floor((low + high) / 2);\n        const partitionY = Math.floor((x + y + 1) / 2) - partitionX;\n        \n        const maxLeftX = (partitionX === 0) ? Number.NEGATIVE_INFINITY : nums1[partitionX - 1];\n        const minRightX = (partitionX === x) ? Number.POSITIVE_INFINITY : nums1[partitionX];\n        \n        const maxLeftY = (partitionY === 0) ? Number.NEGATIVE_INFINITY : nums2[partitionY - 1];\n        const minRightY = (partitionY === y) ? Number.POSITIVE_INFINITY : nums2[partitionY];\n        \n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 === 0) {\n                return (Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\n            } else {\n                return Math.max(maxLeftX, maxLeftY);\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }    \n    return 0;\n}\n\n",
            "explanation": "1. Choose the smaller array as nums1 so that the problem is simpler with less log(n) complexity.\n2. Use Binary Search (BS) to partition the smallest array.\n3. Now we calculate the position of partition in the larger array (nums2) having fetched the smaller one.\n4. Find the four important numbers - maxSize - left and right of partition in the two arrays.\n5. If maxSizeLeft <= minSizeRight and maxSizeLeft2 <= minSizeRight2, then the partition of both arrays is correct, if not, adjust the partition of nums1. If maxLeftX > minRightY, move the BS partition to the left; if maxLeftY > minRightX, move the BS partition to the right.\n6. When the correct partition is found, calculate the median based on the length of the merged array, even or odd."
        },
        "structure": {
            "c++": "double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) \n    // Your code here\n}\n",
            "java": "public double findMedianSortedArrays(int[] nums1, int[] nums2) \n    // Your code here\n}\n",
            "python": "def findMedianSortedArrays(nums1, nums2):\n    # Your code here\n\n",
            "javascript": "function findMedianSortedArrays(nums1, nums2) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function Declaration\n\ndouble findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2);\n\nint main() {\n    // Argument Assignment\n    vector<int> nums1 = $args;\n    vector<int> nums2 = $args;\n    \n    // Function Invocation\n    double result = findMedianSortedArrays(nums1, nums2);\n    \n    // Output\n    cout << result << endl;\n    \n    return 0;\n}\n\n// Function Definition\n\ndouble findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n    if (nums1.size() > nums2.size()) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    int x = nums1.size();\n    int y = nums2.size();\n    int low = 0;\n    int high = x;\n    \n    while (low <= high) {\n        int partitionX = (low + high) / 2;\n        int partitionY = (x + y + 1) / 2 - partitionX;\n        \n        int maxLeftX = (partitionX == 0) ? INT_MIN : nums1[partitionX - 1];\n        int minRightX = (partitionX == x) ? INT_MAX : nums1[partitionX];\n        \n        int maxLeftY = (partitionY == 0) ? INT_MIN : nums2[partitionY - 1];\n        int minRightY = (partitionY == y) ? INT_MAX : nums2[partitionY];\n        \n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 == 0) {\n                return (double(max(maxLeftX, maxLeftY) + min(minRightX, minRightY))) / 2;\n            } else {\n                return double(max(maxLeftX, maxLeftY));\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }    \n    return 0;\n}",
            "java": "public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n    if (nums1.length > nums2.length) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    int x = nums1.length;\n    int y = nums2.length;\n    int low = 0;\n    int high = x;\n    \n    while (low <= high) {\n        int partitionX = (low + high) / 2;\n        int partitionY = (x + y + 1) / 2 - partitionX;\n        \n        int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];\n        int minRightX = (partitionX == x) ? Integer.MAX_VALUE : nums1[partitionX];\n        \n        int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : nums2[partitionY - 1];\n        int minRightY = (partitionY == y) ? Integer.MAX_VALUE : nums2[partitionY];\n        \n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 == 0) {\n                return (double)(Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\n            } else {\n                return (double)Math.max(maxLeftX, maxLeftY);\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }    \n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs = $args\n    nums1 = inputs[0]\n    nums2 = inputs[1]\n    result = findMedianSortedArrays(nums1, nums2)\n    print(result)",
            "javascript": "function findMedianSortedArrays(nums1, nums2) {\n    if (nums1.length > nums2.length) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    const x = nums1.length;\n    const y = nums2.length;\n    let low = 0;\n    let high = x;\n    \n    while (low <= high) {\n        const partitionX = Math.floor((low + high) / 2);\n        const partitionY = Math.floor((x + y + 1) / 2) - partitionX;\n        \n        const maxLeftX = (partitionX === 0) ? Number.NEGATIVE_INFINITY : nums1[partitionX - 1];\n        const minRightX = (partitionX === x) ? Number.POSITIVE_INFINITY : nums1[partitionX];\n        \n        const maxLeftY = (partitionY === 0) ? Number.NEGATIVE_INFINITY : nums2[partitionY - 1];\n        const minRightY = (partitionY === y) ? Number.POSITIVE_INFINITY : nums2[partitionY];\n        \n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 === 0) {\n                return (Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\n            } else {\n                return Math.max(maxLeftX, maxLeftY);\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }    \n    return 0;\n}"
        }
    },
    "5": {
        "title": "Longest Palindromic Substring",
        "description": "Given a string `s`, find and return the longest palindromic substring in `s`. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward. If there are multiple longest palindromic substrings, return any one of them.",
        "example": "Example 1:\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\nExample 2:\n\nInput: s = \"cbbd\"\nOutput: \"bb\"",
        "level": "Medium",
        "tags": [
            "String",
            "Dynamic Programming"
        ],
        "test_cases": {
            "inputs": [
                "\"babad\"",
                "\"cbbd\"",
                "\"a\"",
                "\"ac\"",
                "\"bb\"",
                "\"racecar\"",
                "\"abcdeedcba\"",
                "\"abcdefedcba\"",
                "\"abcdeedcbafg\"",
                "\"abcdefedcbagf\"",
                "\"abacdfgdcaba\"",
                "\"abacdfgdcabba\"",
                "\"abacdfgdcabbaa\"",
                "\"abacdfgdcabbaaa\"",
                "\"abacdfgdcabbaaaa\"",
                "\"abacdfgdcabbaaaaa\"",
                "\"abacdfgdcabbaaaaaa\"",
                "\"abacdfgdcabbaaaaaaa\"",
                "\"abacdfgdcabbaaaaaaaa\"",
                "\"abacdfgdcabbaaaaaaaaa\"",
                "\"abacdfgdcabbaaaaaaaaaa\""
            ],
            "outputs": [
                "\"bab\"",
                "\"bb\"",
                "\"a\"",
                "\"a\"",
                "\"bb\"",
                "\"racecar\"",
                "\"abcdeedcba\"",
                "\"abcdefedcba\"",
                "\"abcdeedcba\"",
                "\"abcdefedcba\"",
                "\"aba\"",
                "\"abba\"",
                "\"abba\"",
                "\"abba\"",
                "\"abba\"",
                "\"abba\"",
                "\"abba\"",
                "\"abba\"",
                "\"abba\"",
                "\"abba\"",
                "\"abba\""
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n\nstd::string longestPalindromicSubstring(std::string s) {\n  int n = s.size();\n  if (n == 0) return \"\";\n  int start = 0, maxLength = 1;\n\n  for (int i = 0; i < n; ++i) {\n    int l = i, r = i;\n\n    while (r < n - 1 && s[r] == s[r + 1])\n      r++;\n    i = r;\n\n    while (l > 0 && r < n - 1 && s[l - 1] == s[r + 1]) {\n      l--;\n      r++;\n    }\n\n    int length = r - l + 1;\n    if (length > maxLength) {\n      start = l;\n      maxLength = length;\n    }\n  }\n\n  return s.substr(start, maxLength);\n}\n",
            "java": "public String longestPalindromicSubstring(String s) {\n    int n = s.length();\n    if (n == 0) return \"\";\n\n    int start = 0, maxLength = 1;\n\n    for (int i = 0; i < n; ++i) {\n        int l = i, r = i;\n\n        while (r < n - 1 && s.charAt(r) == s.charAt(r + 1))\n            r++;\n        i = r;\n\n        while (l > 0 && r < n - 1 && s.charAt(l - 1) == s.charAt(r + 1)) {\n            l--;\n            r++;\n        }\n\n        int length = r - l + 1;\n        if (length > maxLength) {\n            start = l;\n            maxLength = length;\n        }\n    }\n\n    return s.substring(start, start + maxLength);\n}\n",
            "python": "def longest_palindromic_substring(s: str) -> str:\n    n = len(s)\n    if n == 0: return \"\"\n\n    start, max_length = 0, 1\n\n    for i in range(n):\n        l, r = i, i\n\n        while r < n - 1 and s[r] == s[r + 1]:\n            r += 1\n        i = r\n\n        while l > 0 and r < n - 1 and s[l - 1] == s[r + 1]:\n            l -= 1\n            r += 1\n\n        length = r - l + 1\n        if length > max_length:\n            start, max_length = l, length\n\n    return s[start:start + max_length]\n",
            "javascript": "function longestPalindromicSubstring(s) {\n  let n = s.length;\n  if (n === 0) return \"\";\n\n  let start = 0, maxLength = 1;\n\n  for (let i = 0; i < n; ++i) {\n    let l = i, r = i;\n\n    while (r < n - 1 && s[r] === s[r + 1])\n      r++;\n    i = r;\n\n    while (l > 0 && r < n - 1 && s[l - 1] === s[r + 1]) {\n      l--;\n      r++;\n    }\n\n    let length = r - l + 1;\n    if (length > maxLength) {\n      start = l;\n      maxLength = length;\n    }\n  }\n\n  return s.substring(start, start + maxLength);\n}\n",
            "explanation": "1. Initialize `start` and `maxLength` for result substring.\n2. Iterate through the given string `s` using the index `i`.\n3. For each index `i`, create two pointers `l` and `r` starting at `i`.\n4. Check if there's a consecutive sequence of identical characters, increment the right pointer `r` until the end of the sequence is reached.\n5. Update the index `i` to the current value of `r`.\n6. Expand the pointers `l` and `r` outwards to find the longest palindromic substring, checking that characters on both sides are equal.\n7. If the current length of the substring is greater than `maxLength`, update `start` and `maxLength`.\n8. Return the longest palindromic substring using the `start` and `maxLength`."
        },
        "structure": {
            "c++": "#include <string>\n\nstd::string longestPalindromicSubstring(std::string s) \n    // Your code here\n}\n",
            "java": "public String longestPalindromicSubstring(String s) \n    // Your code here\n}\n",
            "python": "def longest_palindromic_substring(s: str) -> str:\n    # Your code here\n\n",
            "javascript": "function longestPalindromicSubstring(s) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <string>\n\nstd::string longestPalindromicSubstring(std::string s);\n\nint main() {\n    std::string input = $args;\n    std::string result = longestPalindromicSubstring(input);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public String longestPalindromicSubstring(String s) {\n    int n = s.length();\n    if (n == 0) return \"\";\n\n    int start = 0, maxLength = 1;\n\n    for (int i = 0; i < n; ++i) {\n        int l = i, r = i;\n\n        while (r < n - 1 && s.charAt(r) == s.charAt(r + 1))\n            r++;\n        i = r;\n\n        while (l > 0 && r < n - 1 && s.charAt(l - 1) == s.charAt(r + 1)) {\n            l--;\n            r++;\n        }\n\n        int length = r - l + 1;\n        if (length > maxLength) {\n            start = l;\n            maxLength = length;\n        }\n    }\n\n    return s.substring(start, start + maxLength);\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = longest_palindromic_substring(s)\n    print(result)",
            "javascript": "function main() {\n  const s = $args;\n  const result = longestPalindromicSubstring(s);\n  console.log(result);\n}"
        }
    },
    "7": {
        "title": "Reverse Integer",
        "description": "Given a signed 32-bit integer `x`, return `x` with its digits reversed. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-231, 231 - 1]`, then return `0`.\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).",
        "example": "Example 1:\n\nInput: x = 123\nOutput: 321\n\nExample 2:\n\nInput: x = -123\nOutput: -321\n\nExample 3:\n\nInput: x = 120\nOutput: 21",
        "level": "Easy",
        "tags": [
            "Math"
        ],
        "test_cases": {
            "inputs": [
                123,
                -123,
                120,
                0,
                1,
                -1,
                10,
                -10,
                100,
                -100,
                123456789,
                -123456789,
                2147483647,
                -2147483648,
                2147483646,
                -2147483647,
                1534236469,
                -2147483412,
                0,
                987654321
            ],
            "outputs": [
                321,
                -321,
                21,
                0,
                1,
                -1,
                1,
                -1,
                1,
                -1,
                987654321,
                -987654321,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                123456789
            ]
        },
        "sample_code": {
            "c++": "int reverse(int x) {\n    long long res = 0;\n    while (x != 0) {\n        res = res * 10 + x % 10;\n        x /= 10;\n    }\n    return (res < INT_MIN || res > INT_MAX) ? 0 : res;\n}\n",
            "java": "public int reverse(int x) {\n    long res = 0;\n    while (x != 0) {\n        res = res * 10 + x % 10;\n        x /= 10;\n    }\n    return (res < Integer.MIN_VALUE || res > Integer.MAX_VALUE) ? 0 : (int)res;\n}\n",
            "python": "def reverse(x: int) -> int:\n    sign = -1 if x < 0 else 1\n    x = abs(x)\n    res = 0\n    while x:\n        res = res * 10 + x % 10\n        x //= 10\n    res *= sign\n    return res if -2**31 <= res <= 2**31 - 1 else 0\n",
            "javascript": "function reverse(x) {\n    let sign = x < 0 ? -1 : 1;\n    x = Math.abs(x);\n    let res = 0;\n    while (x !== 0) {\n        res = res * 10 + x % 10;\n        x = Math.floor(x / 10);\n    }\n    res *= sign;\n    return (res < -(2 ** 31) || res > 2 ** 31 - 1) ? 0 : res;\n}\n",
            "explanation": "The algorithm initializes `res` as 0. Then, we determine the sign of the input integer and take its absolute value. We use a while loop to iterate through each digit of `x` from right to left. In each iteration, we multiply the current `res` by 10 and add the last digit of `x` to it. The last digit of `x` is obtained by `x % 10`. After adding the last digit, we remove it from `x` by doing either `x /= 10` or `x //= 10`.\n\nAfter processing all the digits, we adjust `res` with the sign we computed earlier. Finally, we check if the reversed integer is within the 32-bit integer range. If it is, we return the result; otherwise, we return 0."
        },
        "structure": {
            "c++": "int reverse(int x) \n    // Your code here\n}\n",
            "java": "public int reverse(int x) \n    // Your code here\n}\n",
            "python": "def reverse(x: int) -> int:\n    # Your code here\n\n",
            "javascript": "function reverse(x) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int x = $args;\n    long long res = 0;\n    while (x != 0) {\n        res = res * 10 + x % 10;\n        x /= 10;\n    }\n    int result = (res < INT_MIN || res > INT_MAX) ? 0 : res;\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    int x = $args;\n    int result = reverse(x);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    x = $args\n    result = reverse(x)\n    print(result)",
            "javascript": "function main() {\n    const x = $args;\n    let sign = x < 0 ? -1 : 1;\n    x = Math.abs(x);\n    let res = 0;\n    while (x !== 0) {\n        res = res * 10 + x % 10;\n        x = Math.floor(x / 10);\n    }\n    res *= sign;\n    const result = (res < -(2 ** 31) || res > 2 ** 31 - 1) ? 0 : res;\n    console.log(result);\n}"
        }
    },
    "9": {
        "title": "Palindrome Integer",
        "description": "Given an integer `x`, determine if it is a palindrome. Return `true` if `x` is a palindrome, and `false` otherwise.",
        "example": "Example 1:\n\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.",
        "level": "Easy",
        "tags": [
            "math"
        ],
        "test_cases": {
            "inputs": [
                121,
                -121,
                10,
                12321,
                1234321,
                123454321,
                12345654321,
                123456654321
            ],
            "outputs": [
                true,
                false,
                false,
                true,
                true,
                true,
                true,
                true
                
            ]
        },
        "sample_code": {
            "c++": "bool isPalindrome(int x) {\n    if (x < 0) return false;\n    int original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x /= 10;\n    }\n    return original == reversed;\n}\n\n",
            "java": "public boolean isPalindrome(int x) {\n    if (x < 0) return false;\n    int original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x /= 10;\n    }\n    return original == reversed;\n}\n\n",
            "python": "def is_palindrome(x: int) -> bool:\n    if x < 0:\n        return False\n    original, reversed = x, 0\n    while x > 0:\n        reversed = reversed * 10 + x % 10\n        x //= 10\n    return original == reversed\n\n",
            "javascript": "function isPalindrome(x) {\n    if (x < 0) return false;\n    let original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x = Math.floor(x / 10);\n    }\n    return original === reversed;\n}\n\n",
            "explanation": "Here is the algorithm:\n\n1. If the integer is negative, immediately return false, as negative numbers cannot be palindromes.\n2. Create a variable named `original` to store the original integer value and `reversed` initialized with 0 to store the reversed integer value.\n3. Iterate through the integer while it's greater than zero and, in each iteration, perform the following operations:\n   a. Multiply the `reversed` value by 10 and add the modulus of the integer (x) by 10.\n   b. Divide the integer (x) by 10, discarding the remainder.\n4. Compare `original` and `reversed` integers; if they are equal, return true; otherwise, return false.\n\nThis approach requires O(log10(n)) time complexity as we are dividing the input by 10 in each iteration."
        },
        "structure": {
            "c++": "bool isPalindrome(int x) \n    // Your code here\n}\n\n",
            "java": "public boolean isPalindrome(int x) \n    // Your code here\n}\n\n",
            "python": "def is_palindrome(x: int) -> bool:\n    # Your code here\n\n",
            "javascript": "function isPalindrome(x) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nbool isPalindrome(int x) {\n    if (x < 0) return false;\n    int original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x /= 10;\n    }\n    return original == reversed;\n}\n\nint main() {\n    int n = $args;\n    bool result = isPalindrome(n);\n    cout << boolalpha << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    int x = $args;\n    boolean result = isPalindrome(x);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    x = $args\n    result = is_palindrome(x)\n    print(result)\n",
            "javascript": "function main() {\n    const x = $args;\n    const result = isPalindrome(x);\n    console.log(result);\n}\n"
        }
    },
    "10": {
        "title": "Regular Expression Matching",
        "description": "Given an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:\n\n*   `'.'` Matches any single character.\n*   `'*'` Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).",
        "example": "Example:\n\nInput:\n\ns = \"aa \", p = \"a \"\nOutput:\nfalse\nExplanation:\n\"a \" does not match the entire string \"aa \".",
        "level": "Medium",
        "tags": [
            "string",
            "regular expression",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    "aa ",
                    "a "
                ],
                [
                    "aa ",
                    "a* "
                ],
                [
                    "ab ",
                    ".* "
                ],
                [
                    "abc ",
                    "a.c "
                ],
                [
                    "aab ",
                    "c*a*b "
                ],
                [
                    "mississippi ",
                    "mis*is*p*. "
                ],
                [
                    "aaa ",
                    "a*a "
                ],
                [
                    "aaa ",
                    "ab*a*c*a "
                ],
                [
                    "a ",
                    ".*..a* "
                ],
                [
                    "a ",
                    "a*a "
                ],
                [
                    "a ",
                    "a* "
                ],
                [
                    "a ",
                    "a. "
                ],
                [
                    "a ",
                    "a.* "
                ],
                [
                    "a ",
                    "a.. "
                ],
                [
                    "a ",
                    "a... "
                ],
                [
                    "a ",
                    "a.... "
                ],
                [
                    "a ",
                    "a..... "
                ],
                [
                    "a ",
                    "a...... "
                ],
                [
                    "a ",
                    "a....... "
                ],
                [
                    "a ",
                    "a........ "
                ]
            ],
            "outputs": [
                false,
                true,
                true,
                true,
                true,
                false,
                true,
                true,
                false,
                true,
                true,
                false,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "bool isMatch(std::string s, std::string p) {\n    int m = s.length(), n = p.length();\n    std::vector<std::vector<bool>> dp(m + 1, std::vector<bool>(n + 1, false));\n    dp[0][0] = true;\n\n    for (int j = 1; j <= n; j++) {\n        if (p[j - 1] == '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (p[j - 1] == s[i - 1] || p[j - 1] == '.') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p[j - 1] == '*') {\n                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n",
            "java": "public boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n\n    for (int j = 1; j <= n; j++) {\n        if (p.charAt(j - 1) == '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (p.charAt(j - 1) == s.charAt(i - 1) || p.charAt(j - 1) == '.') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p.charAt(j - 1) == '*') {\n                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'));\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n",
            "python": "def is_match(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        if p[j - 1] == '*' and dp[0][j - 2]:\n            dp[0][j] = True\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                dp[i][j] = dp[i - 1][j - 1]\n            elif p[j - 1] == '*':\n                dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))\n\n    return dp[m][n]\n",
            "javascript": "function isMatch(s, p) {\n    const m = s.length, n = p.length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(false));\n    dp[0][0] = true;\n\n    for (let j = 1; j <= n; j++) {\n        if (p[j - 1] === '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n          if (p[j - 1] === s[i - 1] || p[j - 1] === '.') {\n              dp[i][j] = dp[i - 1][j - 1];\n          } else if (p[j - 1] === '*') {\n              dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] === p[j - 2] || p[j - 2] === '.'));\n          }\n      }\n    }\n\n    return dp[m][n];\n}\n",
            "explanation": "We use Dynamic Programming to solve this problem. We store intermediate results in a 2D boolean array `dp`, where `dp[i][j]` indicates whether the first `i` characters of `s` match the first `j` characters of `p`. We then loop through the characters of both strings and update the `dp` table.\n\nIf the current characters in `s` and `p` are equal or `p` has a '.', we update the `dp[i][j]` to the value `dp[i - 1][j - 1]`, because the match continues.\n\nIf the current character in `p` is '*', we have two options:\n\n1. Consider the matching of the previous character in `p` as 0 occurrences. We update the `dp[i][j]` value to `dp[i][j - 2]`.\n2. Consider the matching of the previous character in `p` as at least 1 occurrence. We update `dp[i][j]` to the value of `dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')`.\n\nFinally, `dp[m][n]` stores the result, where `m` and `n` are the lengths of strings `s` and `p` respectively."
        },
        "structure": {
            "c++": "bool isMatch(std::string s, std::string p) \n    // Your code here\n}\n",
            "java": "public boolean isMatch(String s, String p) \n    // Your code here\n}\n",
            "python": "def is_match(s: str, p: str) -> bool:\n    # Your code here\n\n",
            "javascript": "function isMatch(s, p) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\n\nbool isMatch(std::string s, std::string p) {\n    int m = s.length(), n = p.length();\n    std::vector<std::vector<bool>> dp(m + 1, std::vector<bool>(n + 1, false));\n    dp[0][0] = true;\n\n    for (int j = 1; j <= n; j++) {\n        if (p[j - 1] == '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (p[j - 1] == s[i - 1] || p[j - 1] == '.') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p[j - 1] == '*') {\n                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n\nint main() {\n    std::string s = $args;\n    std::string p = $args;\n    bool result = isMatch(s, p);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "java": "public boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n\n    for (int j = 1; j <= n; j++) {\n        if (p.charAt(j - 1) == '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (p.charAt(j - 1) == s.charAt(i - 1) || p.charAt(j - 1) == '.') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p.charAt(j - 1) == '*') {\n                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'));\n            }\n        }\n    }\n\n    return dp[m][n];\n}",
            "python": "if __name__ == \"__main__\":\n    inputs = $args\n    s = inputs[0]\n    p = inputs[1]\n    result = is_match(s, p)\n    print(result)",
            "javascript": "function main() {\n    const s = $args[0];\n    const p = $args[1];\n    const result = isMatch(s, p);\n    console.log(result);\n}"
        }
    },
    "11": {
        "title": "Container With Most Water",
        "description": "Given an integer array `height` of length `n`, where each element represents the height of a vertical line, find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water the container can store.",
        "example": "Example:\n\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.",
        "level": "Medium",
        "tags": [
            "Array",
            "Two Pointers",
            "Greedy"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    8,
                    6,
                    2,
                    5,
                    4,
                    8,
                    3,
                    7
                ],
                [
                    1,
                    1
                ],
                [
                    4,
                    3,
                    2,
                    1,
                    4
                ],
                [
                    1,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    20,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ]
            ],
            "outputs": [
                49,
                1,
                16,
                2,
                6,
                4,
                4,
                25,
                25,
                100,
                100
            ]
        },
        "sample_code": {
            "c++": "int maxArea(vector<int>& height) {\n    int max_area = 0, left = 0, right = height.size() - 1;\n    while (left < right) {\n        max_area = max(max_area, min(height[left], height[right]) * (right - left));\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return max_area;\n}\n",
            "java": "public int maxArea(int[] height) {\n    int max_area = 0, left = 0, right = height.length - 1;\n    while (left < right) {\n        max_area = Math.max(max_area, Math.min(height[left], height[right]) * (right - left));\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return max_area;\n}\n",
            "python": "def max_area(height):\n    max_area, left, right = 0, 0, len(height) - 1\n    while left < right:\n        max_area = max(max_area, min(height[left], height[right]) * (right - left))\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_area\n",
            "javascript": "function maxArea(height) {\n    let max_area = 0, left = 0, right = height.length - 1;\n    while (left < right) {\n        max_area = Math.max(max_area, Math.min(height[left], height[right]) * (right - left));\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return max_area;\n}\n",
            "explanation": "The algorithm uses a two-pointer approach, with one pointer starting from the left end and the other from the right end. It calculates the area between these two lines and updates the maximum area if the current area is larger than the previously calculated maximum area. If the height at the left pointer is less than the height at the right pointer, it moves the left pointer to the right. Otherwise, it moves the right pointer to the left. The algorithm continues until the pointers meet.\n\nThis algorithm ensures that the maximum area is found without having to check all possible pairs of lines because it always chooses the pair of lines with the maximum possible distance and minimum height difference at each step."
        },
        "structure": {
            "c++": "int maxArea(vector<int>& height) \n    // Your code here\n}\n",
            "java": "public int maxArea(int[] height) \n    // Your code here\n}\n",
            "python": "def max_area(height):\n    # Your code here\n\n",
            "javascript": "function maxArea(height) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint maxArea(vector<int>& height) {\n    int max_area = 0, left = 0, right = height.size() - 1;\n    while (left < right) {\n        max_area = max(max_area, min(height[left], height[right]) * (right - left));\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return max_area;\n}\n\nint main() {\n    vector<int> height = $args;\n    int result = maxArea(height);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    int[] height = $args;\n    int result = maxArea(height);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    height = $args\n    result = max_area(height)\n    print(result)",
            "javascript": "function main() {\n    const height = $args;\n    const result = maxArea(height);\n    console.log(result);\n}"
        }
    },
    "6": {
        "title": "Zigzag Conversion",
        "description": "The string `PAYPALISHIRING` is written in a zigzag pattern on a given number of rows. Write a function `convert` that takes a string and the number of rows and returns the string in the zigzag pattern.",
        "example": "Example 1:\n\nInput: s = `PAYPALISHIRING`, numRows = 3\nOutput: `PAHNAPLSIIGYIR`\n\nExample 2:\n\nInput: s = `PAYPALISHIRING`, numRows = 4\nOutput: `PINALSIGYAHRPI`\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n\nExample 3:\n\nInput: s = `A`, numRows = 1\nOutput: `A`",
        "level": "Medium",
        "tags": [
            "string",
            "pattern"
        ],
        "test_cases": {
            "inputs": [
                [
                    "PAYPALISHIRING",
                    3
                ],
                [
                    "PAYPALISHIRING",
                    4
                ],
                [
                    "A",
                    1
                ],
                [
                    "HELLO",
                    2
                ],
                [
                    "WORLD",
                    2
                ],
                [
                    "ZIGZAG",
                    4
                ],
                [
                    "CONVERSION",
                    5
                ],
                [
                    "CODING",
                    3
                ],
                [
                    "QUESTION",
                    4
                ],
                [
                    "EXAMPLE",
                    3
                ],
                [
                    "TEST",
                    2
                ],
                [
                    "CASES",
                    3
                ],
                [
                    "ZIGZAGCONVERSION",
                    5
                ],
                [
                    "STRING",
                    4
                ],
                [
                    "PATTERN",
                    3
                ],
                [
                    "ALGORITHM",
                    6
                ],
                [
                    "PROGRAMMING",
                    5
                ],
                [
                    "CHALLENGE",
                    4
                ],
                [
                    "SOLUTION",
                    3
                ],
                [
                    "LEETCODE",
                    2
                ]
            ],
            "outputs": [
                "\"PAHNAPLSIIGYIR\"",
                "\"PINALSIGYAHRPI\"",
                "\"A\"",
                "\"HLOEL\"",
                "\"WDLRO\"",
                "\"ZGZAI\"",
                "\"CNOIOTVN\"",
                "\"CIGDNO\"",
                "\"QETNUSO\"",
                "\"EPEXMLA\"",
                "\"TSET\"",
                "\"SECA\"",
                "\"ZGZAIOTNNOVC\"",
                "\"SRTNI\"",
                "\"PTNREA\"",
                "\"AOLGMRITHM\"",
                "\"PORMGAMRIN\"",
                "\"CEGELLNAH\"",
                "\"NIOITULOS\"",
                "\"ETACODEEL\""
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <vector>\n\nstd::string convert(std::string s, int numRows) {\n    if (numRows == 1 || numRows >= s.size()) return s;\n\n    std::vector<std::string> rows(std::min(numRows, int(s.size())));\n    int curRow = 0;\n    bool goingDown = false;\n\n    for (char c : s) {\n        rows[curRow] += c;\n        if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;\n        curRow += goingDown ? 1 : -1;\n    }\n\n    std::string result;\n    for (std::string row : rows) result += row;\n    return result;\n}\n",
            "java": "public class ZigzagConversion {\n    public String convert(String s, int numRows) {\n        if (numRows == 1 || numRows >= s.length()) return s;\n\n        StringBuilder[] rows = new StringBuilder[numRows];\n        for (int i = 0; i < numRows; i++) rows[i] = new StringBuilder();\n        \n        int curRow = 0;\n        boolean goingDown = false;\n\n        for (char c : s.toCharArray()) {\n            rows[curRow].append(c);\n            if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;\n            curRow += goingDown ? 1 : -1;\n        }\n\n        StringBuilder result = new StringBuilder();\n        for (StringBuilder row : rows) result.append(row);\n        return result.toString();\n    }\n}\n",
            "python": "def convert(s: str, numRows: int) -> str:\n    if numRows == 1 or numRows >= len(s):\n        return s\n\n    rows = [\"\"] * numRows\n    curRow = 0\n    goingDown = False\n\n    for c in s:\n        rows[curRow] += c\n        if curRow == 0 or curRow == numRows - 1:\n            goingDown = not goingDown\n        curRow += 1 if goingDown else -1\n\n    return \"\".join(rows)\n",
            "javascript": "function convert(s, numRows) {\n    if (numRows === 1 || numRows >= s.length) return s;\n\n    let rows = new Array(numRows).fill(\"\");\n    let curRow = 0;\n    let goingDown = false;\n\n    for (let c of s) {\n        rows[curRow] += c;\n        if (curRow === 0 || curRow === numRows - 1) goingDown = !goingDown;\n        curRow += goingDown ? 1 : -1;\n    }\n\n    return rows.join(\"\");\n}\n",
            "explanation": "1. If the number of rows is 1 or is greater than or equal to the length of the string, the string is just returned as is.\n2. Create an array called \"rows\" to contain the characters that would reside in each row of the zigzag pattern.\n3. Iterate through the string one character at a time.\n4. For each character in the string, place it into the appropriate row of the \"rows\" array.\n5. Determine whether the next character should be placed in the row above or below the current row by checking if the current row is 0 (at the top) or equal to the number of rows minus 1 (at the bottom). If at the top or the bottom, the direction will change.\n6. Update the current row index according to the direction (going up or down).\n7. After iterating through the entire string, join the rows array into a single string and return it."
        },
        "structure": {
            "c++": "#include <string>\n#include <vector>\n\nstd::string convert(std::string s, int numRows) \n    // Your code here\n}\n",
            "java": "public class ZigzagConversion \n    // Your code here\n}\n",
            "python": "def convert(s: str, numRows: int) -> str:\n    # Your code here\n\n",
            "javascript": "function convert(s, numRows) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <string>\n#include <vector>\n\nstd::string convert(std::string s, int numRows) {\n    if (numRows == 1 || numRows >= s.size()) return s;\n\n    std::vector<std::string> rows(std::min(numRows, int(s.size())));\n    int curRow = 0;\n    bool goingDown = false;\n\n    for (char c : s) {\n        rows[curRow] += c;\n        if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;\n        curRow += goingDown ? 1 : -1;\n    }\n\n    std::string result;\n    for (std::string row : rows) result += row;\n    return result;\n}\n\nint main() {\n    std::string s = $args;\n    int numRows = 3;\n    std::string result = convert(s, numRows);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs = $args\n    s = inputs[0]\n    numRows = inputs[1]\n    result = convert(s, numRows)\n    print(result)",
            "javascript": "function main() {\n    const s = $args[0];\n    const numRows = $args[1];\n    const result = convert(s, numRows);\n    console.log(result);\n}",
            "java": "public String convert(String s, int numRows) {\n        if (numRows == 1 || numRows >= s.length()) return s;\n\n        StringBuilder[] rows = new StringBuilder[numRows];\n        for (int i = 0; i < numRows; i++) rows[i] = new StringBuilder();\n        \n        int curRow = 0;\n        boolean goingDown = false;\n\n        for (char c : s.toCharArray()) {\n            rows[curRow].append(c);\n            if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;\n            curRow += goingDown ? 1 : -1;\n        }\n\n        StringBuilder result = new StringBuilder();\n        for (StringBuilder row : rows) result.append(row);\n        return result.toString();\n    }"
        }
    },
    "8": {
        "title": "String to Integer (atoi)",
        "description": "Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).\n\nThe algorithm for `myAtoi(string s)` is as follows:\n\n1. Read in and ignore any leading whitespace.\n2. Check if the next character (if not already at the end of the string) is \"-\" or \"+\". Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n3. Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n4. Convert these digits into an integer (i.e. \"123 \" -> 123, \"0032 \" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\n5. If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\n6. Return the integer as the final result.\n\n**Note:**\n\n- Only the space character \" \" is considered a whitespace character.\n- **Do not ignore** any characters other than the leading whitespace or the rest of the string after the digits.",
        "example": "Example 1:\n\nInput: s = \"42 \"\nOutput: 42\nExplanation: The underlined characters are what is read in, the caret is the current reader position.\nStep 1: \"42 \" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42 \" (no characters read because there is neither a \"-\" nor \"+\")\n         ^\nStep 3: \"42 \" (\"42\" is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range [-231, 231 - 1], the final result is 42.\n\nExample 2:\n\nInput: s = \"   -42 \"\nOutput: -42\nExplanation: Step 1: \"   -42 \" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   -42 \" (\"-\" is read, so the result should be negative)\n             ^\nStep 3: \"   -42 \" (\"42\" is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range [-231, 231 - 1], the final result is -42.\n\nExample 3:\n\nInput: s = \"4193 with words \"\nOutput: 4193\nExplanation: Step 1: \"4193 with words \" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"4193 with words \" (no characters read because there is neither a \"-\" nor \"+\")\n         ^\nStep 3: \"4193 with words \" (\"4193\" is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\nSince 4193 is in the range [-231, 231 - 1], the final result is 4193.",
        "level": "Medium",
        "tags": [
            "string",
            "parsing",
            "integer"
        ],
        "test_cases": {
            "inputs": [
                "\"42 \"",
                "\"   -42 \"",
                "\"4193 with words \"",
                "\"words and 987\"",
                "\"-91283472332\"",
                "\"3.14159\"",
                "\"-3.14159\"",
                "\"-1234567890123456789012345678901234567890\"",
                "\"1234567890123456789012345678901234567890\"",
                "\"\"",
                "\"0\"",
                "\"-\"",
                "\"+\"",
                "\"-0\"",
                "\"+0\"",
                "\"-123\"",
                "\"+123\"",
                "\"-000123\"",
                "\"+000123\"",
                "\"-000\"",
                "\"+000\""
            ],
            "outputs": [
                "42",
                "-42",
                "4193",
                "0",
                "-2147483648",
                "3",
                "-3",
                "-2147483648",
                "2147483647",
                "0",
                "0",
                "0",
                "0",
                "0",
                "-123",
                "123",
                "-123",
                "123",
                "0",
                "0"
            ]
        },
        "sample_code": {
            "c++": "int myAtoi(string s) {\n    long result = 0;\n    int i = 0, sign = 1;\n    while (s[i] == ' ') i++;\n    if (s[i] == '-' || s[i] == '+') sign = (s[i++] == '+') ? 1 : -1;\n    while (isdigit(s[i])) {\n        result = result * 10 + (s[i++] - '0');\n        if (result * sign > INT_MAX) return INT_MAX;\n        if (result * sign < INT_MIN) return INT_MIN;\n    }\n    return result * sign;\n}\n",
            "java": "public int myAtoi(String s) {\n    long result = 0;\n    int i = 0, sign = 1;\n    while (i < s.length() && s.charAt(i) == ' ') i++;\n    if (i < s.length() && (s.charAt(i) == '-' || s.charAt(i) == '+')) {\n        sign = (s.charAt(i++) == '+') ? 1 : -1;\n    }\n    while (i < s.length() && Character.isDigit(s.charAt(i))) {\n        result = result * 10 + (s.charAt(i++) - '0');\n        if (result * sign > Integer.MAX_VALUE) return Integer.MAX_VALUE;\n        if (result * sign < Integer.MIN_VALUE) return Integer.MIN_VALUE;\n    }\n    return (int) (result * sign);\n}\n",
            "python": "def myAtoi(s):\n    result, i, sign = 0, 0, 1\n    while i < len(s) and s[i] == ' ': i += 1\n    if i < len(s) and (s[i] == '-' or s[i] == '+'):\n        sign = -1 if s[i] == '-' else 1\n        i += 1\n    while i < len(s) and s[i].isdigit():\n        result = result * 10 + int(s[i])\n        i += 1\n        if result * sign > 2**31 - 1: return 2**31 - 1\n        if result * sign < -2**31: return -2**31\n    return result * sign\n",
            "javascript": "function myAtoi(s) {\n    let result = 0, i = 0, sign = 1;\n    while (s[i] === ' ') i++;\n    if (s[i] === '-' || s[i] === '+') sign = (s[i++] === '+') ? 1 : -1;\n    while (!isNaN(s[i]) && s[i] !== ' ') {\n        result = result * 10 + parseInt(s[i++], 10);\n        if (result * sign > 2147483647) return 2147483647;\n        if (result * sign < -2147483648) return -2147483648;\n    }\n    return result * sign;\n}\n",
            "explanation": "1. Initialize `result` as 0, index `i` as 0, and `sign` as 1 (positive).\n2. Loop through the string until a non-space character is found or the end of the string is reached.\n3. If the current character is '+' or '-', update the `sign` according to the character and increment the index `i`.\n4. If a digit is found, multiply the previous `result` by 10 and add the digit to it. Increment the index `i`.\n5. Check if the result multiplied by the sign is out of the 32-bit signed integer range. If so, return the appropriate boundary value.\n6. When no more digits are found, return the final result multiplied by the sign."
        },
        "structure": {
            "c++": "int myAtoi(string s) \n    // Your code here\n}\n",
            "java": "public int myAtoi(String s) \n    // Your code here\n}\n",
            "python": "def myAtoi(s):\n    # Your code here\n\n",
            "javascript": "function myAtoi(s) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint myAtoi(string s) {\n    long result = 0;\n    int i = 0, sign = 1;\n    while (s[i] == ' ') i++;\n    if (s[i] == '-' || s[i] == '+') sign = (s[i++] == '+') ? 1 : -1;\n    while (isdigit(s[i])) {\n        result = result * 10 + (s[i++] - '0');\n        if (result * sign > INT_MAX) return INT_MAX;\n        if (result * sign < INT_MIN) return INT_MIN;\n    }\n    return result * sign;\n}\n\nint main() {\n    string s = $args;\n    int result = myAtoi(s);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int myAtoi(String s) {\n    long result = 0;\n    int i = 0, sign = 1;\n    while (i < s.length() && s.charAt(i) == ' ') i++;\n    if (i < s.length() && (s.charAt(i) == '-' || s.charAt(i) == '+')) {\n        sign = (s.charAt(i++) == '+') ? 1 : -1;\n    }\n    while (i < s.length() && Character.isDigit(s.charAt(i))) {\n        result = result * 10 + (s.charAt(i++) - '0');\n        if (result * sign > Integer.MAX_VALUE) return Integer.MAX_VALUE;\n        if (result * sign < Integer.MIN_VALUE) return Integer.MIN_VALUE;\n    }\n    return (int) (result * sign);\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = myAtoi(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = myAtoi(s);\n    console.log(result);\n}"
        }
    },
    "12": {
        "title": "Convert Integer to Roman Numeral",
        "description": "Given an integer, convert it to a Roman numeral. Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D`, and `M`. The symbols and their corresponding values are as follows:\n\n`I` - 1\n`V` - 5\n`X` - 10\n`L` - 50\n`C` - 100\n`D` - 500\n`M` - 1000\n\nRoman numerals are usually written largest to smallest from left to right. However, there are six instances where subtraction is used. For example, `IV` represents 4, `IX` represents 9, `XL` represents 40, `XC` represents 90, `CD` represents 400, and `CM` represents 900.\n\nWrite a function `convertToRoman` that takes an integer `num` as input and returns its Roman numeral representation as a string.",
        "example": "Example:\n\nInput:\nnum = 3\n\nOutput:\n\"III\"\n\nExplanation:\n3 is represented as 3 ones.\n\nInput:\nnum = 58\n\nOutput:\n\"LVIII\"\n\nExplanation:\nL = 50, V = 5, III = 3.\n\nInput:\nnum = 1994\n\nOutput:\n\"MCMXCIV\"\n\nExplanation:\nM = 1000, CM = 900, XC = 90, and IV = 4.",
        "level": "Medium",
        "tags": [
            "Math",
            "String"
        ],
        "test_cases": {
            "inputs": [
                3,
                58,
                1994,
                4,
                9,
                40,
                90,
                400,
                900,
                3999,
                1,
                10,
                100,
                1000,
                399,
                444,
                555,
                666,
                777,
                888
            ],
            "outputs": [
                "III",
                "LVIII",
                "MCMXCIV",
                "IV",
                "IX",
                "XL",
                "XC",
                "CD",
                "CM",
                "MMMCMXCIX",
                "I",
                "X",
                "C",
                "M",
                "CCCXCIX",
                "CDXLIV",
                "DLV",
                "DCLXVI",
                "DCCLXXVII",
                "DCCCLXXXVIII"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n\nstd::string intToRoman(int num) {\n    std::vector<std::pair<int, std::string>> romans = {\n        {1000, \"M\"},\n        {900, \"CM\"},\n        {500, \"D\"},\n        {400, \"CD\"},\n        {100, \"C\"},\n        {90, \"XC\"},\n        {50, \"L\"},\n        {40, \"XL\"},\n        {10, \"X\"},\n        {9, \"IX\"},\n        {5, \"V\"},\n        {4, \"IV\"},\n        {1, \"I\"}\n    };\n    std::string roman = \"\";\n    for (const auto& p : romans) {\n        while (num >= p.first) {\n            roman += p.second;\n            num -= p.first;\n        }\n    }\n    return roman;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class RomanNumerals {\n    public static String intToRoman(int num) {\n        List<Pair> romans = Arrays.asList(\n            new Pair(1000, \"M\"), new Pair(900, \"CM\"), new Pair(500, \"D\"), \n            new Pair(400, \"CD\"), new Pair(100, \"C\"), new Pair(90, \"XC\"),\n            new Pair(50, \"L\"), new Pair(40, \"XL\"), new Pair(10, \"X\"), \n            new Pair(9, \"IX\"), new Pair(5, \"V\"), new Pair(4, \"IV\"),\n            new Pair(1, \"I\")\n        );\n        StringBuilder roman = new StringBuilder();\n        for (Pair p : romans) {\n            while (num >= p.num) {\n                roman.append(p.symbol);\n                num -= p.num;\n            }\n        }\n        return roman.toString();\n    }\n    \n    private static class Pair {\n        final int num;\n        final String symbol;\n        \n        Pair(int num, String symbol) {\n            this.num = num;\n            this.symbol = symbol;\n        }\n    }\n}\n",
            "python": "def int_to_roman(num):\n    romans = [\n        (1000, \"M\"), (900, \"CM\"), (500, \"D\"),\n        (400, \"CD\"), (100, \"C\"), (90, \"XC\"),\n        (50, \"L\"), (40, \"XL\"), (10, \"X\"), \n        (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")\n    ]\n    roman = \"\"\n    for value, symbol in romans:\n        while num >= value:\n            roman += symbol\n            num -= value\n    return roman\n",
            "javascript": "function intToRoman(num) {\n    const romans = [\n        [1000, \"M\"], [900, \"CM\"], [500, \"D\"],\n        [400, \"CD\"], [100, \"C\"], [90, \"XC\"],\n        [50, \"L\"], [40, \"XL\"], [10, \"X\"], \n        [9, \"IX\"], [5, \"V\"], [4, \"IV\"], [1, \"I\"]\n    ];\n    let roman = \"\";\n    for (const [value, symbol] of romans) {\n        while (num >= value) {\n            roman += symbol;\n            num -= value;\n        }\n    }\n    return roman;\n}\n",
            "explanation": "The algorithm starts with a list of pairs, where each pair contains a decimal value and its corresponding roman numeral. Then, it iteratively go through the list of pairs and checks if the num is greater than or equal to the decimal value. If it is, it appends the roman numeral to the result, and subtracts the decimal value from the num. This is done until the num becomes 0."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n\nstd::string intToRoman(int num) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class RomanNumerals \n    // Your code here\n}\n",
            "python": "def int_to_roman(num):\n    # Your code here\n\n",
            "javascript": "function intToRoman(num) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::string intToRoman(int num);\n\nint main() {\n    int n = $args;\n    std::string result = intToRoman(n);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public static void main(String[] args) {\n    int num = $args;\n    String result = intToRoman(num);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    num = $args\n    result = int_to_roman(num)\n    print(result)",
            "javascript": "function main() {\n    const num = $args;\n    const result = intToRoman(num);\n    console.log(result);\n}"
        }
    },
    "13": {
        "title": "Roman Numeral to Integer Conversion",
        "description": "Given a Roman numeral, convert it to an integer. Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D`, and `M`. The symbols and their corresponding values are as follows: \n\n`I` - 1\n`V` - 5\n`X` - 10\n`L` - 50\n`C` - 100\n`D` - 500\n`M` - 1000\n\nRoman numerals are usually written largest to smallest from left to right. However, there are six instances where subtraction is used. For example, `IV` represents 4 (5 - 1) and `IX` represents 9 (10 - 1). The goal is to convert the given Roman numeral into its corresponding integer value.",
        "example": "Example:\n\nInput: \"III\"\nOutput: 3\nExplanation: The Roman numeral \"III\" represents the number 3.\n\nInput: \"LVIII\"\nOutput: 58\nExplanation: The Roman numeral \"LVIII\" represents the number 58. It can be broken down as follows: L (50) + V (5) + III (3).\n\nInput: \"MCMXCIV\"\nOutput: 1994\nExplanation: The Roman numeral \"MCMXCIV\" represents the number 1994. It can be broken down as follows: M (1000) + CM (900) + XC (90) + IV (4).",
        "level": "Easy",
        "tags": [
            "String",
            "Math"
        ],
        "test_cases": {
            "inputs": [
                "\"III\"",
                "\"LVIII\"",
                "\"MCMXCIV\"",
                "\"IV\"",
                "\"IX\"",
                "\"XL\"",
                "\"XC\"",
                "\"CD\"",
                "\"CM\"",
                "\"XIV\"",
                "\"XXIX\"",
                "\"XLV\"",
                "\"XCIX\"",
                "\"CDXLIV\"",
                "\"CMXCIX\"",
                "\"MMMCMXCIX\"",
                "\"I\"",
                "\"V\"",
                "\"X\"",
                "\"L\"",
                "\"C\"",
                "\"D\"",
                "\"M\""
            ],
            "outputs": [
                "3",
                "58",
                "1994",
                "4",
                "9",
                "40",
                "90",
                "400",
                "900",
                "14",
                "29",
                "45",
                "99",
                "444",
                "999",
                "3999",
                "1",
                "5",
                "10",
                "50",
                "100",
                "500",
                "1000"
            ]
        },
        "sample_code": {
            "c++": "int romanToInt(string s) {\n    unordered_map<char, int> roman_values = { {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000} };\n    int total = 0;\n    int prev_value = 0;\n\n    for (char c : s) {\n        int current_value = roman_values[c];\n        if (current_value > prev_value)\n            total += current_value - (2 * prev_value);\n        else\n            total += current_value;\n        prev_value = current_value;\n    }\n\n    return total;\n}\n\n",
            "java": "public int romanToInt(String s) {\n    Map<Character, Integer> romanValues = new HashMap<>();\n    romanValues.put('I', 1);\n    romanValues.put('V', 5);\n    romanValues.put('X', 10);\n    romanValues.put('L', 50);\n    romanValues.put('C', 100);\n    romanValues.put('D', 500);\n    romanValues.put('M', 1000);\n\n    int total = 0;\n    int prevValue = 0;\n\n    for (char c : s.toCharArray()) {\n        int currValue = romanValues.get(c);\n        total += currValue > prevValue ? currValue - 2 * prevValue : currValue;\n        prevValue = currValue;\n    }\n\n    return total;\n}\n\n",
            "python": "def roman_to_int(s):\n    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    total = 0\n    prev_value = 0\n    \n    for c in s:\n        current_value = roman_values[c]\n        if current_value > prev_value:\n            total += current_value - 2 * prev_value\n        else:\n            total += current_value\n        prev_value = current_value\n\n    return total\n\n",
            "javascript": "function romanToInt(s) {\n    const romanValues = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000};\n    let total = 0;\n    let prevValue = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        let currValue = romanValues[s[i]];\n        if (currValue > prevValue)\n            total += currValue - (2 * prevValue);\n        else\n            total += currValue;\n        prevValue = currValue;\n    }\n\n    return total;\n}\n\n",
            "explanation": "The algorithm iterates through the input string, which represents the Roman numeral. At each iteration, the character is converted to its corresponding integer value using a hash map. Then, the value is added to the total. However, if the current value is greater than the previous value, it means that we need to subtract the previous value from the current value (while considering that the previous value has already been added once). To do this, we add to the total the current value minus 2 times the previous value. Finally, the previous value is updated, and the loop continues. After the loop finishes, the total gives us the integer value equivalent to the Roman numeral."
        },
        "structure": {
            "c++": "int romanToInt(string s) \n    // Your code here\n}\n\n",
            "java": "public int romanToInt(String s) \n    // Your code here\n}\n\n",
            "python": "def roman_to_int(s):\n    # Your code here\n\n",
            "javascript": "function romanToInt(s) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint romanToInt(string s) {\n    unordered_map<char, int> roman_values = { {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000} };\n    int total = 0;\n    int prev_value = 0;\n\n    for (char c : s) {\n        int current_value = roman_values[c];\n        if (current_value > prev_value)\n            total += current_value - (2 * prev_value);\n        else\n            total += current_value;\n        prev_value = current_value;\n    }\n\n    return total;\n}\n\nint main() {\n    string s = $args;\n    int result = romanToInt(s);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int romanToInt(String s) {\n    Map<Character, Integer> romanValues = new HashMap<>();\n    romanValues.put('I', 1);\n    romanValues.put('V', 5);\n    romanValues.put('X', 10);\n    romanValues.put('L', 50);\n    romanValues.put('C', 100);\n    romanValues.put('D', 500);\n    romanValues.put('M', 1000);\n\n    int total = 0;\n    int prevValue = 0;\n\n    for (char c : s.toCharArray()) {\n        int currValue = romanValues.get(c);\n        total += currValue > prevValue ? currValue - 2 * prevValue : currValue;\n        prevValue = currValue;\n    }\n\n    return total;\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = roman_to_int(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = romanToInt(s);\n    console.log(result);\n}"
        }
    },
    "14": {
        "title": "Longest Common Prefix",
        "description": "Write a function that takes an array of strings and returns the longest common prefix string among them. If there is no common prefix, return an empty string.",
        "example": "For example, given the input strs = [\"flower\", \"flow\", \"flight\"], the output should be \"fl\". \n\nExplanation: The longest common prefix among the strings is \"fl\".\n\nGiven the input strs = [\"dog\", \"racecar\", \"car\"], the output should be an empty string. \n\nExplanation: There is no common prefix among the strings.",
        "level": "Easy",
        "tags": [
            "Array",
            "String"
        ],
        "test_cases": {
            "inputs": [
                [
                    "flower",
                    "flow",
                    "flight"
                ],
                [
                    "dog",
                    "racecar",
                    "car"
                ],
                [
                    "apple",
                    "app",
                    "application"
                ],
                [
                    "coding",
                    "code",
                    "coder"
                ],
                [
                    "hello",
                    "hell",
                    "help"
                ],
                [
                    "prefix",
                    "pre",
                    "preparation"
                ],
                [
                    "",
                    "abc",
                    "def"
                ],
                [
                    "",
                    "",
                    ""
                ],
                [
                    "abc",
                    "abc",
                    "abc"
                ],
                [
                    "abc",
                    "abcd",
                    "abcde"
                ],
                [
                    "abc",
                    "def",
                    "ghi"
                ],
                [
                    "abc",
                    "ab",
                    "a"
                ],
                [
                    "abc",
                    "ab",
                    "abc"
                ],
                [
                    "abc",
                    "ab",
                    "abcd"
                ],
                [
                    "abc",
                    "ab",
                    "abcde"
                ],
                [
                    "abc",
                    "ab",
                    "abcdefgh"
                ],
                [
                    "abc",
                    "ab",
                    "abcdefghi"
                ],
                [
                    "abc",
                    "ab",
                    "abcdefghij"
                ],
                [
                    "abc",
                    "ab",
                    "abcdefghijk"
                ],
                [
                    "abc",
                    "ab",
                    "abcdefghijkl"
                ]
            ],
            "outputs": [
                "fl",
                "",
                "app",
                "cod",
                "hel",
                "pre",
                "",
                "",
                "abc",
                "abc",
                "",
                "a",
                "ab",
                "abc",
                "abc",
                "abc",
                "abc",
                "abc",
                "abc",
                "abc"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring longestCommonPrefix(vector<string>& strs) {\n    if (strs.empty()) return \"\";\n\n    for (int i = 0; i < strs[0].size(); ++i) {\n        char c = strs[0][i];\n        for (int j = 1; j < strs.size(); ++j) {\n            if (i == strs[j].size() || strs[j][i] != c) {\n                return strs[0].substr(0, i);\n            }\n        }\n    }\n    return strs[0];\n}\n",
            "java": "public String longestCommonPrefix(String[] strs) {\n    if (strs.length == 0) return \"\";\n\n    for (int i = 0; i < strs[0].length(); ++i) {\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; ++j) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c) {\n                return strs[0].substring(0, i);\n            }\n        }\n    }\n    return strs[0];\n}\n",
            "python": "def longest_common_prefix(strs):\n    if not strs:\n        return \"\"\n\n    for i, c in enumerate(strs[0]):\n        for j in range(1, len(strs)):\n            if i == len(strs[j]) or strs[j][i] != c:\n                return strs[0][:i]\n    return strs[0]\n",
            "javascript": "function longestCommonPrefix(strs) {\n    if (strs.length === 0) return \"\";\n\n    for (let i = 0; i < strs[0].length; ++i) {\n        const c = strs[0][i];\n        for (let j = 1; j < strs.length; ++j) {\n            if (i === strs[j].length || strs[j][i] !== c) {\n                return strs[0].substr(0, i);\n            }\n        }\n    }\n    return strs[0];\n}\n",
            "explanation": "The algorithm iterates through the characters in the first string and compares the equivalent characters in the subsequent strings. If there is a mismatch detected, return the common prefix up to the mismatch point. If the algorithm finishes iterating over the first string, return the entire first string as the common prefix.\n\n1. Check if the input array is empty, if it is, return an empty string as there is no common prefix.\n2. Iterate through the characters of the first string.\n3. For each character, iterate through the rest of the strings in the array.\n4. Compare the current character with the corresponding character in the other strings.\n5. If there is a mismatch or if we reach the end of a string, return the common prefix substring up to the current index.\n6. If the loop reaches the end of the first string, then the whole first string is the common prefix. Return the entire first string."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring longestCommonPrefix(vector<string>& strs) \n    // Your code here\n}\n",
            "java": "public String longestCommonPrefix(String[] strs) \n    // Your code here\n}\n",
            "python": "def longest_common_prefix(strs):\n    # Your code here\n\n",
            "javascript": "function longestCommonPrefix(strs) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longestCommonPrefix(vector<string>& strs) {\n    if (strs.empty()) return \"\";\n\n    for (int i = 0; i < strs[0].size(); ++i) {\n        char c = strs[0][i];\n        for (int j = 1; j < strs.size(); ++j) {\n            if (i == strs[j].size() || strs[j][i] != c) {\n                return strs[0].substr(0, i);\n            }\n        }\n    }\n    return strs[0];\n}\n\nint main() {\n    vector<string> strs = $args;\n    string result = longestCommonPrefix(strs);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    String[] strs = $args;\n    String result = longestCommonPrefix(strs);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    strs = $args\n    result = longest_common_prefix(strs)\n    print(result)",
            "javascript": "function main() {\n    const strs = $args;\n    const result = longestCommonPrefix(strs);\n    console.log(result);\n}"
        }
    },
    "15": {
        "title": "Triplets with Zero Sum",
        "description": "Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`. Notice that the solution set must not contain duplicate triplets.",
        "example": "Example 1:\n\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0. nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0. The distinct triplets are [-1,0,1] and [-1,-1,2]. Notice that the order of the output and the order of the triplets does not matter.\n\nExample 2:\n\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\n\nExample 3:\n\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.",
        "level": "Medium",
        "tags": [
            "Array",
            "Two Pointers"
        ],
        "test_cases": {
            "inputs": [
                [
                    -1,
                    0,
                    1,
                    2,
                    -1,
                    -4
                ],
                [
                    0,
                    1,
                    1
                ],
                [
                    0,
                    0,
                    0
                ],
                [
                    -2,
                    0,
                    1,
                    1,
                    2
                ],
                [
                    1,
                    2,
                    -2,
                    -1
                ],
                [
                    3,
                    0,
                    -2,
                    -1,
                    1,
                    2
                ],
                [
                    -1,
                    -1,
                    -1,
                    0,
                    0,
                    0,
                    1,
                    1,
                    1
                ],
                [
                    -1,
                    0,
                    1,
                    2,
                    -1,
                    -4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ]
            ],
            "outputs": [
                "[[-1,-1,2],[-1,0,1]]",
                "[]",
                "[[0,0,0]]",
                "[[-2,0,2],[-2,1,1]]",
                "[[-2,-1,3],[-2,0,2],[-1,0,1]]",
                "[[-2,-1,3],[-2,0,2],[-1,0,1]]",
                "[[-1,-1,2],[-1,0,1],[0,0,0]]",
                "[[-1,-1,2],[-1,0,1],[0,0,0]]",
                "[]",
                "[]",
                "[[0,0,0]]",
                "[]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> threeSum(std::vector<int>& nums) {\n    std::vector<std::vector<int>> result;\n    std::sort(nums.begin(), nums.end());\n\n    for (int i = 0; i < (int)nums.size() - 2; ++i) {\n        if (i == 0 || nums[i] != nums[i - 1]) {\n            int j = i + 1, k = nums.size() - 1;\n            while (j < k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                if (sum == 0) {\n                    result.push_back({nums[i], nums[j], nums[k]});\n                    while (j < k && nums[j] == nums[j + 1]) ++j;\n                    while (j < k && nums[k] == nums[k - 1]) --k;\n                    ++j;\n                    --k;\n                } else if (sum < 0) {\n                    ++j;\n                } else {\n                    --k;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n",
            "java": "import java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> threeSum(int[] nums) {\n    Arrays.sort(nums);\n    List<List<Integer>> result = new ArrayList<>();\n\n    for (int i = 0; i < nums.length - 2; i++) {\n        if (i == 0 || nums[i] != nums[i - 1]) {\n            int j = i + 1, k = nums.length - 1;\n            while (j < k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                if (sum == 0) {\n                    result.add(Arrays.asList(nums[i], nums[j], nums[k]));\n                    while (j < k && nums[j] == nums[j + 1]) j++;\n                    while (j < k && nums[k] == nums[k - 1]) k--;\n                    j++;\n                    k--;\n                } else if (sum < 0) {\n                    j++;\n                } else {\n                    k--;\n                }                    \n            }\n        }\n    }\n\n    return result;\n}\n",
            "python": "def threeSum(nums):\n    nums.sort()\n    result = []\n\n    for i in range(len(nums) - 2):\n        if i == 0 or nums[i] != nums[i - 1]:\n            j, k = i + 1, len(nums) - 1\n            while j < k:\n                s = nums[i] + nums[j] + nums[k]\n                if s == 0:\n                    result.append([nums[i], nums[j], nums[k]])\n                    while j < k and nums[j] == nums[j + 1]:\n                        j += 1\n                    while j < k and nums[k] == nums[k - 1]:\n                        k -= 1\n                    j += 1\n                    k -= 1\n                elif s < 0:\n                    j += 1\n                else:\n                    k -= 1\n\n    return result\n",
            "javascript": "function threeSum(nums) {\n    nums.sort((a, b) => a - b);\n    const result = [];\n\n    for (let i = 0; i < nums.length - 2; i++) {\n        if (i == 0 || nums[i] != nums[i - 1]) {\n            let j = i + 1, k = nums.length - 1;\n            while (j < k) {\n                const sum = nums[i] + nums[j] + nums[k];\n                if (sum === 0) {\n                    result.push([nums[i], nums[j], nums[k]]);\n                    while (j < k && nums[j] === nums[j + 1]) j++;\n                    while (j < k && nums[k] === nums[k - 1]) k--;\n                    j++;\n                    k--;\n                } else if (sum < 0) {\n                    j++;\n                } else {\n                    k--;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n",
            "explanation": "1. Sort the input array `nums`.\n2. Loop through `nums` from index `0` to `length - 2`. Let the current index be `i`.\n    - If `i` is `0` or `nums[i]` is not equal to the previous element (`nums[i - 1]`), perform the following steps:\n        - Initialize two pointers `j` and `k`, where `j` is the next index after `i`, and `k` is the last index of `nums`.\n        - While `j` is less than `k`, perform the following steps:\n            - Calculate the sum `s` of the elements at indices `i`, `j`, and `k`.\n            - If the sum `s` is equal to `0`, then we've found a valid triplet. Add it to the `result` array and move the pointers, `j` and `k`, skipping duplicates if any.\n            - If the sum `s` is less than `0`, increment `j` to move towards positive values.\n            - If the sum `s` is greater than `0`, decrement `k` to move towards negative values.\n3. Return the `result` array.\n\nThe algorithm removes duplicates by checking if the current numbers being processed are equal to previously processed numbers. The sorting step helps in simplifying the algorithm and reducing the search space."
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> threeSum(std::vector<int>& nums) \n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> threeSum(int[] nums) \n    // Your code here\n}\n",
            "python": "def threeSum(nums):\n    # Your code here\n\n",
            "javascript": "function threeSum(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> threeSum(std::vector<int>& nums) {\n    std::vector<std::vector<int>> result;\n    std::sort(nums.begin(), nums.end());\n\n    for (int i = 0; i < (int)nums.size() - 2; ++i) {\n        if (i == 0 || nums[i] != nums[i - 1]) {\n            int j = i + 1, k = nums.size() - 1;\n            while (j < k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                if (sum == 0) {\n                    result.push_back({nums[i], nums[j], nums[k]});\n                    while (j < k && nums[j] == nums[j + 1]) ++j;\n                    while (j < k && nums[k] == nums[k - 1]) --k;\n                    ++j;\n                    --k;\n                } else if (sum < 0) {\n                    ++j;\n                } else {\n                    --k;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    std::vector<int> nums = $args;\n    std::vector<std::vector<int>> result = threeSum(nums);\n\n    for (const auto& triplet : result) {\n        for (const auto& num : triplet) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = threeSum(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    nums.sort((a, b) => a - b);\n    const result = [];\n\n    for (let i = 0; i < nums.length - 2; i++) {\n        if (i == 0 || nums[i] != nums[i - 1]) {\n            let j = i + 1, k = nums.length - 1;\n            while (j < k) {\n                const sum = nums[i] + nums[j] + nums[k];\n                if (sum === 0) {\n                    result.push([nums[i], nums[j], nums[k]]);\n                    while (j < k && nums[j] === nums[j + 1]) j++;\n                    while (j < k && nums[k] === nums[k - 1]) k--;\n                    j++;\n                    k--;\n                } else if (sum < 0) {\n                    j++;\n                } else {\n                    k--;\n                }\n            }\n        }\n    }\n\n    console.log(result);\n}"
        }
    },
    "16": {
        "title": "Closest Three Sum",
        "description": "Given an integer array `nums` of length `n` and an integer `target`, find three integers in `nums` such that the sum is closest to `target`. Return the sum of the three integers. You may assume that each input would have exactly one solution.",
        "example": "Example:\n\nInput: nums = [-1,2,1,-4], target = 1\nOutput: 2\nExplanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).",
        "level": "Medium",
        "tags": [
            "Array",
            "Two Pointers"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        -1,
                        2,
                        1,
                        -4
                    ],
                    1
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    10
                ],
                [
                    [
                        -10,
                        -5,
                        0,
                        5,
                        10
                    ],
                    0
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    3
                ],
                [
                    [
                        -1,
                        -2,
                        -3,
                        -4,
                        -5
                    ],
                    -10
                ],
                [
                    [
                        10,
                        20,
                        30,
                        40,
                        50
                    ],
                    100
                ],
                [
                    [
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    5
                ],
                [
                    [
                        -1,
                        -1,
                        -1,
                        -1,
                        -1
                    ],
                    -3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    -10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    15
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    6
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    7
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    8
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    9
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    11
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    12
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    13
                ]
            ],
            "outputs": [
                2,
                0,
                9,
                0,
                3,
                -9,
                60,
                0,
                -3,
                3,
                15,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                6
            ]
        },
        "sample_code": {
            "c++": "#include <algorithm>\n#include <vector>\n\nint threeSumClosest(std::vector<int>& nums, int target) {\n    std::sort(nums.begin(), nums.end());\n    int closest = nums[0] + nums[1] + nums[2];\n    for (int i = 0; i < nums.size() - 2; ++i) {\n        int left = i + 1;\n        int right = nums.size() - 1;\n        while (left < right) {\n            int sum = nums[i] + nums[left] + nums[right];\n            if (sum == target) {\n                return sum;\n            }\n            if (abs(target - sum) < abs(target - closest)) {\n                closest = sum;\n            }\n            if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return closest;\n}\n",
            "java": "import java.util.Arrays;\n\npublic int threeSumClosest(int[] nums, int target) {\n    Arrays.sort(nums);\n    int closest = nums[0] + nums[1] + nums[2];\n    for (int i = 0; i < nums.length - 2; ++i) {\n        int left = i + 1;\n        int right = nums.length - 1;\n        while (left < right) {\n            int sum = nums[i] + nums[left] + nums[right];\n            if (sum == target) {\n                return sum;\n            }\n            if (Math.abs(target - sum) < Math.abs(target - closest)) {\n                closest = sum;\n            }\n            if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return closest;\n}\n",
            "python": "def threeSumClosest(nums, target):\n    nums.sort()\n    closest = sum(nums[:3])\n    for i in range(len(nums) - 2):\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            cur_sum = nums[i] + nums[left] + nums[right]\n            if cur_sum == target:\n                return cur_sum\n            if abs(target - cur_sum) < abs(target - closest):\n                closest = cur_sum\n            if cur_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return closest\n",
            "javascript": "function threeSumClosest(nums, target) {\n    nums.sort((a, b) => a - b);\n    let closest = nums[0] + nums[1] + nums[2];\n    for (let i = 0; i < nums.length - 2; ++i) {\n        let left = i + 1;\n        let right = nums.length - 1;\n        while (left < right) {\n            let sum = nums[i] + nums[left] + nums[right];\n            if (sum === target) {\n                return sum;\n            }\n            if (Math.abs(target - sum) < Math.abs(target - closest)) {\n                closest = sum;\n            }\n            if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return closest;\n}\n",
            "explanation": "1. Sort the input array `nums`.\n2. Initialize the `closest` variable to be the sum of the first three elements.\n3. Iterate through the sorted array with a pointer `i` running from the first element to the third-to-last element.\n4. Initialize two-pointers `left` (set to `i + 1`) and `right` (set to the last element).\n5. While `left` is less than `right`:\n    a. Calculate the current sum `cur_sum` using the elements at positions `i`, `left`, and `right`.\n    b. If `cur_sum` is equal to `target`, return it as the closest sum.\n    c. Update the `closest` sum if the difference between `target` and `cur_sum` is less than the difference between `target` and `closest`.\n    d. Move the `left` pointer forward if `cur_sum` is less than `target`, otherwise move the `right` pointer backward.\n6. Return the `closest` sum found."
        },
        "structure": {
            "c++": "#include <algorithm>\n#include <vector>\n\nint threeSumClosest(std::vector<int>& nums, int target) \n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\n\npublic int threeSumClosest(int[] nums, int target) \n    // Your code here\n}\n",
            "python": "def threeSumClosest(nums, target):\n    # Your code here\n\n",
            "javascript": "function threeSumClosest(nums, target) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\n\nint threeSumClosest(std::vector<int>& nums, int target);\n\nint main() {\n    std::vector<int> nums = $args;\n    int target = 0;\n    int result = threeSumClosest(nums, target);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "python": "if __name__ == \"__main__\":\n    inputs = [[1, 1, 1, 1, 1], 3]\n    nums = inputs[0]\n    target = inputs[1]\n    result = threeSumClosest(nums, target)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args[0];\n    const target = $args[1];\n    const result = threeSumClosest(nums, target);\n    console.log(result);\n}"
        }
    },
    "17": {
        "title": "Letter Combinations of a Phone Number",
        "description": "Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.\n\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.",
        "example": "Example:\n\n**Input:** digits = \"23\"\n**Output:** [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]\n\n**Input:** digits = \"\"\n**Output:** []\n\n**Input:** digits = \"2\"\n**Output:** [\"a\", \"b\", \"c\"]",
        "level": "Medium",
        "tags": [
            "String",
            "Recursion",
            "Backtracking"
        ],
        "test_cases": {
            "inputs": [
                "\"23\"",
                "\"\"",
                "\"2\"",
                "\"234\"",
                "\"567\"",
                "\"89\"",
                "\"999\"",
                "\"7777\"",
                "\"2222\"",
                "\"3333\"",
                "\"4444\"",
                "\"5555\"",
                "\"6666\"",
                "\"8888\"",
                "\"9999\"",
                "\"222\"",
                "\"333\"",
                "\"444\"",
                "\"555\"",
                "\"666\"",
                "\"777\"",
                "\"888\"",
                "\"999\"",
                "\"2222\"",
                "\"3333\"",
                "\"4444\"",
                "\"5555\"",
                "\"6666\"",
                "\"7777\"",
                "\"8888\"",
                "\"9999\""
            ],
            "outputs": [
                "[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]",
                "[]",
                "[\"a\", \"b\", \"c\"]",
                "[\"adg\", \"adh\", \"adi\", \"aeg\", \"aeh\", \"aei\", \"afg\", \"afh\", \"afi\", \"bdg\", \"bdh\", \"bdi\", \"beg\", \"beh\", \"bei\", \"bfg\", \"bfh\", \"bfi\", \"cdg\", \"cdh\", \"cdi\", \"ceg\", \"ceh\", \"cei\", \"cfg\", \"cfh\", \"cfi\"]",
                "[\"jm\", \"jn\", \"jo\", \"km\", \"kn\", \"ko\", \"lm\", \"ln\", \"lo\"]",
                "[\"tw\", \"tx\", \"ty\", \"uw\", \"ux\", \"uy\", \"vw\", \"vx\", \"vy\"]",
                "[\"w\", \"x\", \"y\", \"z\"]",
                "[\"aa\", \"ab\", \"ac\", \"ba\", \"bb\", \"bc\", \"ca\", \"cb\", \"cc\"]",
                "[\"aa\", \"ad\", \"ae\", \"af\", \"ba\", \"bd\", \"be\", \"bf\", \"ca\", \"cd\", \"ce\", \"cf\"]",
                "[\"dd\", \"de\", \"df\", \"ed\", \"ee\", \"ef\", \"fd\", \"fe\", \"ff\"]",
                "[\"gg\", \"gh\", \"gi\", \"hg\", \"hh\", \"hi\", \"ig\", \"ih\", \"ii\"]",
                "[\"jj\", \"jk\", \"jl\", \"kj\", \"kk\", \"kl\", \"lj\", \"lk\", \"ll\"]",
                "[\"pp\", \"pq\", \"pr\", \"ps\", \"qp\", \"qq\", \"qr\", \"qs\", \"rp\", \"rq\", \"rr\", \"rs\", \"sp\", \"sq\", \"sr\", \"ss\"]",
                "[\"tt\", \"tu\", \"tv\", \"ut\", \"uu\", \"uv\", \"vt\", \"vu\", \"vv\"]",
                "[\"ww\", \"wx\", \"wy\", \"wz\", \"xw\", \"xx\", \"xy\", \"xz\", \"yw\", \"yx\", \"yy\", \"yz\", \"zw\", \"zx\", \"zy\", \"zz\"]",
                "[\"aa\", \"ad\", \"ae\", \"af\", \"ba\", \"bd\", \"be\", \"bf\", \"ca\", \"cd\", \"ce\", \"cf\"]",
                "[\"dd\", \"de\", \"df\", \"ed\", \"ee\", \"ef\", \"fd\", \"fe\", \"ff\"]",
                "[\"gg\", \"gh\", \"gi\", \"hg\", \"hh\", \"hi\", \"ig\", \"ih\", \"ii\"]",
                "[\"jj\", \"jk\", \"jl\", \"kj\", \"kk\", \"kl\", \"lj\", \"lk\", \"ll\"]",
                "[\"pp\", \"pq\", \"pr\", \"ps\", \"qp\", \"qq\", \"qr\", \"qs\", \"rp\", \"rq\", \"rr\", \"rs\", \"sp\", \"sq\", \"sr\", \"ss\"]",
                "[\"tt\", \"tu\", \"tv\", \"ut\", \"uu\", \"uv\", \"vt\", \"vu\", \"vv\"]",
                "[\"ww\", \"wx\", \"wy\", \"wz\", \"xw\", \"xx\", \"xy\", \"xz\", \"yw\", \"yx\", \"yy\", \"yz\", \"zw\", \"zx\", \"zy\", \"zz\"]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> letterCombinations(string digits) {\n    if(digits.empty()) return {};\n    vector<string> phone = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    vector<string> result = {\"\"};\n\n    for (char d : digits) {\n        vector<string> temp;\n        for (const string &s : result) {\n            for (char c : phone[d - '2']) {\n                temp.push_back(s + c);\n            }\n        }\n        result.swap(temp);\n    }\n    return result;\n}\n",
            "java": "public List<String> letterCombinations(String digits) {\n    LinkedList<String> output = new LinkedList<>();\n    if(digits.isEmpty()) return output;\n    \n    String[] phone = new String[] {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    output.add(\"\");\n    \n    for(char d : digits.toCharArray()){\n        while(output.peek().length() == digits.indexOf(d)){\n            String perm = output.remove();\n            for(char c : phone[d - '2'].toCharArray()){\n                output.add(perm + c);\n            }\n        }\n    }\n    \n    return output;\n}\n",
            "python": "def letter_combinations(digits: str):\n    if not digits: return []\n    phone = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\n    result = [\"\"]\n\n    for digit in digits:\n        temp = []\n        for s in result:\n            for c in phone[int(digit) - 2]:\n                temp.append(s + c)\n        result = temp\n\n    return result\n",
            "javascript": "function letterCombinations(digits) {\n    if (digits.length === 0) return [];\n    \n    let phone = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];\n    let result = [\"\"];\n\n    for (let i = 0; i < digits.length; i++) {\n        let digit = digits[i];\n        let temp = [];\n\n        for (let s of result) {\n            for (let c of phone[digit - 2]) {\n                temp.push(s + c);\n            }\n        }\n\n        result = temp;\n    }\n\n    return result;\n}\n",
            "explanation": "The algorithm visits each digit from the given `digits` string one by one. For each digit, it appends all possible characters corresponding to that digit, in a breadth-first search manner. The current stage's results are saved in the `result` list (or `output` list in Java). A temporary list `temp` is used to store the combinations formed at each stage before replacing the `result` list. The phone buttons mapping is stored in the `phone` list/array."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> letterCombinations(string digits) \n    // Your code here\n}\n",
            "java": "public List<String> letterCombinations(String digits) \n    // Your code here\n}\n",
            "python": "def letter_combinations(digits: str):\n    # Your code here\n\n",
            "javascript": "function letterCombinations(digits) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> letterCombinations(string digits) {\n    if(digits.empty()) return {};\n    vector<string> phone = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    vector<string> result = {\"\"};\n\n    for (char d : digits) {\n        vector<string> temp;\n        for (const string &s : result) {\n            for (char c : phone[d - '2']) {\n                temp.push_back(s + c);\n            }\n        }\n        result.swap(temp);\n    }\n    return result;\n}\n\nint main() {\n    string digits = $args;\n    vector<string> result = letterCombinations(digits);\n    for (const string &s : result) {\n        cout << s << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "java": "public List<String> letterCombinations(String digits) {\n    LinkedList<String> output = new LinkedList<>();\n    if(digits.isEmpty()) return output;\n    \n    String[] phone = new String[] {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    output.add(\"\");\n    \n    for(char d : digits.toCharArray()){\n        while(output.peek().length() == digits.indexOf(d)){\n            String perm = output.remove();\n            for(char c : phone[d - '2'].toCharArray()){\n                output.add(perm + c);\n            }\n        }\n    }\n    \n    return output;\n}",
            "python": "if __name__ == \"__main__\":\n    digits = $args\n    result = letter_combinations(digits)\n    print(result)",
            "javascript": "function letterCombinations(digits) {\n    if (digits.length === 0) return [];\n    \n    let phone = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];\n    let result = [\"\"];\n\n    for (let i = 0; i < digits.length; i++) {\n        let digit = digits[i];\n        let temp = [];\n\n        for (let s of result) {\n            for (let c of phone[digit - 2]) {\n                temp.push(s + c);\n            }\n        }\n\n        result = temp;\n    }\n\n    return result;\n}"
        }
    },
    "27": {
        "title": "Remove Elements and Count",
        "description": "Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` in-place. The order of the elements may be changed. Then return the number of elements in `nums` which are not equal to `val`.\n\nConsider the number of elements in `nums` which are not equal to `val` be `k`, to get accepted, you need to do the following things:\n\n- Change the array `nums` such that the first `k` elements of `nums` contain the elements which are not equal to `val`. The remaining elements of `nums` are not important as well as the size of `nums`.\n- Return `k`.",
        "example": "Example:\n\nInput: nums = [3,2,2,3], val = 3\nOutput: 2\nExplanation: Your function should return k = 2, with the first two elements of nums being 2. It does not matter what you leave beyond the returned k (hence they are underscores).",
        "level": "Easy",
        "tags": [
            "array",
            "in-place"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        3,
                        2,
                        2,
                        3
                    ],
                    3
                ],
                [
                    [
                        0,
                        1,
                        2,
                        2,
                        3,
                        0,
                        4,
                        2
                    ],
                    2
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    6
                ],
                [
                    [
                        5,
                        5,
                        5,
                        5,
                        5,
                        5,
                        5,
                        5
                    ],
                    5
                ],
                [
                    [
                        2,
                        4,
                        6,
                        8,
                        10
                    ],
                    5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    0
                ],
                [
                    [],
                    0
                ]
            ],
            "outputs": [
                "2",
                "5",
                "0",
                "0",
                "5",
                "10",
                "0"
            ]
        },
        "sample_code": {
            "c++": "int removeElement(vector<int>& nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.size(); j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n",
            "java": "public int removeElement(int[] nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.length; j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n",
            "python": "def removeElement(nums, val):\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != val:\n            nums[i] = nums[j]\n            i += 1\n    return i\n",
            "javascript": "function removeElement(nums, val) {\n    let i = 0;\n    for (let j = 0; j < nums.length; j++) {\n        if (nums[j] !== val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n",
            "explanation": "The algorithm uses two pointers approach. The pointer `i` maintains the position where the next non-val element should be placed, and pointer `j` iterates through the array. If the element at `j` is not equal to `val`, we place it at the position `i` and increment the `i` pointer. The loop continues until we have checked all the elements in the array. The `i` pointer will give us the count of elements that are not equal to `val`, which is the result. Thus, we return the value of `i` as the final result.\n\nThe time complexity of this algorithm is O(n), where n is the number of elements in the array, as we only iterate through the array once. The space complexity is O(1) since we do not use any extra memory. We modify the input array in-place."
        },
        "structure": {
            "c++": "int removeElement(vector<int>& nums, int val) \n    // Your code here\n}\n",
            "java": "public int removeElement(int[] nums, int val) \n    // Your code here\n}\n",
            "python": "def removeElement(nums, val):\n    # Your code here\n\n",
            "javascript": "function removeElement(nums, val) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "python": "if __name__ == \"__main__\":\n    inputs = $args\n    nums = inputs[0]\n    val = inputs[1]\n    result =removeElement(nums, val)\n    print(result)",
            "c++": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint removeElement(vector<int>& nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.size(); j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n\nint main() {\n    vector<int> nums = $args;\n    int val = 5;\n    int result = removeElement(nums, val);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    int[] nums = {1, 2, 3, 4, 5};\n    int val = 3;\n    int result = removeElement(nums, val);\n    System.out.println(result);\n}",
            "javascript": "function main() {\n    const nums = $args[0];\n    const val = $args[1];\n    const result = removeElement(nums, val);\n    console.log(result);\n}"
        }
    },
    "29": {
        "title": "Integer Division without Using Multiplication, Division, and Mod Operator",
        "description": "Given two integers `dividend` and `divisor`, divide two integers without using multiplication, division, and mod operator. The integer division should truncate toward zero, which means losing its fractional part. Return the quotient after dividing `dividend` by `divisor`. If the quotient is greater than 231 - 1, return 231 - 1. If the quotient is less than -231, return -231.",
        "example": "Example:\n\nInput: dividend = 10, divisor = 3\nOutput: 3\nExplanation: 10/3 = 3.33333.. which is truncated to 3.",
        "level": "Medium",
        "tags": [
            "Math",
            "Bit Manipulation"
        ],
        "test_cases": {
            "inputs": [
                [
                    10,
                    3
                ],
                [
                    7,
                    -3
                ],
                [
                    0,
                    1
                ],
                [
                    1,
                    1
                ],
                [
                    100,
                    10
                ],
                [
                    100,
                    -10
                ],
                [
                    123456789,
                    987654321
                ],
                [
                    -123456789,
                    987654321
                ],
                [
                    2147483647,
                    1
                ],
                [
                    2147483647,
                    -1
                ],
                [
                    -2147483648,
                    1
                ],
                [
                    -2147483648,
                    -1
                ],
                [
                    2147483647,
                    2
                ],
                [
                    2147483647,
                    -2
                ],
                [
                    -2147483648,
                    2
                ],
                [
                    -2147483648,
                    -2
                ],
                [
                    2147483647,
                    2147483647
                ],
                [
                    2147483647,
                    -2147483647
                ],
                [
                    -2147483648,
                    2147483647
                ],
                [
                    -2147483648,
                    -2147483647
                ]
            ],
            "outputs": [
                3,
                -2,
                0,
                1,
                10,
                -10,
                0,
                0,
                2147483647,
                -2147483648,
                -2147483648,
                2147483647,
                1073741823,
                -1073741824,
                -1073741824,
                1073741823,
                1,
                -1,
                -1,
                1
            ]
        },
        "sample_code": {
            "c++": "int divide(int dividend, int divisor) {\n    if (dividend == INT_MIN && divisor == -1) {\n        return INT_MAX;\n    }\n\n    int sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n\n    long long dvd = labs(dividend);\n    long long dvs = labs(divisor);\n    int ans = 0;\n\n    while (dvd >= dvs) {\n        long long temp = dvs, multiple = 1;\n        while (dvd >= (temp << 1)) {\n            temp <<= 1;\n            multiple <<= 1;\n        }\n        dvd -= temp;\n        ans += multiple;\n    }\n\n    return ans * sign;\n}\n",
            "java": "public int divide(int dividend, int divisor) {\n    if (dividend == Integer.MIN_VALUE && divisor == -1) {\n        return Integer.MAX_VALUE;\n    }\n\n    int sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n\n    long dvd = Math.abs((long) dividend);\n    long dvs = Math.abs((long) divisor);\n    int ans = 0;\n\n    while (dvd >= dvs) {\n        long temp = dvs, multiple = 1;\n        while (dvd >= (temp << 1)) {\n            temp <<= 1;\n            multiple <<= 1;\n        }\n        dvd -= temp;\n        ans += multiple;\n    }\n\n    return ans * sign;\n}\n",
            "python": "def divide(dividend: int, divisor: int) -> int:\n    if dividend == -(2**31) and divisor == -1:\n        return 2**31 - 1\n\n    sign = -1 if (dividend > 0) ^ (divisor > 0) else 1\n\n    dvd = abs(dividend)\n    dvs = abs(divisor)\n    ans = 0\n\n    while dvd >= dvs:\n        temp = dvs\n        multiple = 1\n        while dvd >= (temp << 1):\n            temp <<= 1\n            multiple <<= 1\n        dvd -= temp\n        ans += multiple\n\n    return ans * sign\n",
            "javascript": "function divide(dividend, divisor) {\n    if (dividend === -Math.pow(2, 31) && divisor === -1) {\n        return Math.pow(2, 31) - 1;\n    }\n\n    const sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n\n    let dvd = Math.abs(dividend);\n    let dvs = Math.abs(divisor);\n    let ans = 0;\n\n    while (dvd >= dvs) {\n        let temp = dvs;\n        let multiple = 1;\n        while (dvd >= (temp << 1)) {\n            temp <<= 1;\n            multiple <<= 1;\n        }\n        dvd -= temp;\n        ans += multiple;\n    }\n\n    return ans * sign;\n}\n",
            "explanation": "1. First, we handle the edge case where dividend = -2^31 and divisor = -1. The result must be 2^31, but since it's out of the signed integer range, we should return 2^31 - 1.\n2. Calculate the sign of the result based on the signs of dividend and divisor.\n3. We use the bitwise shift operator to handle divisions by powers of 2. In each iteration, we initialize the temp variable as the absolute value of the divisor to calculate how many times it fits into the remaining dividend. We then use another loop to repeatedly double the temp variable (by bitwise left shift) and check if the dividend is still greater or equal. If so, we also double the 'multiple' value associated with temp, as that's the actual quotient in the current iteration.\n4. When the shifting loop exits, we subtract the current temp from dividend and accumulate the current multiple to our answer.\n5. Once the dividend is less than the divisor, we break the loop and return the signed quotient by multiplying the sign variable to our answer."
        },
        "structure": {
            "c++": "int divide(int dividend, int divisor) \n    // Your code here\n}\n",
            "java": "public int divide(int dividend, int divisor) \n    // Your code here\n}\n",
            "python": "def divide(dividend: int, divisor: int) -> int:\n    # Your code here\n\n",
            "javascript": "function divide(dividend, divisor) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <climits>\nusing namespace std;\n\nint divide(int dividend, int divisor) {\n    if (dividend == INT_MIN && divisor == -1) {\n        return INT_MAX;\n    }\n\n    int sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n\n    long long dvd = labs(dividend);\n    long long dvs = labs(divisor);\n    int ans = 0;\n\n    while (dvd >= dvs) {\n        long long temp = dvs, multiple = 1;\n        while (dvd >= (temp << 1)) {\n            temp <<= 1;\n            multiple <<= 1;\n        }\n        dvd -= temp;\n        ans += multiple;\n    }\n\n    return ans * sign;\n}\n\nint main() {\n    int dividend = $args;\n    int divisor = $args;\n    int result = divide(dividend, divisor);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static int divide(int dividend, int divisor) {\n    if (dividend == Integer.MIN_VALUE && divisor == -1) {\n        return Integer.MAX_VALUE;\n    }\n\n    int sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n\n    long dvd = Math.abs((long) dividend);\n    long dvs = Math.abs((long) divisor);\n    int ans = 0;\n\n    while (dvd >= dvs) {\n        long temp = dvs, multiple = 1;\n        while (dvd >= (temp << 1)) {\n            temp <<= 1;\n            multiple <<= 1;\n        }\n        dvd -= temp;\n        ans += multiple;\n    }\n\n    return ans * sign;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs = $args\n    dividend = inputs[0]\n    divisor = inputs[1]\n    result = divide(dividend, divisor)\n    print(result)",
            "javascript": "function main() {\n    const dividend = $args[0];\n    const divisor = $args[1];\n    const result = divide(dividend, divisor);\n    console.log(result);\n}"
        }
    },
    "30": {
        "title": "Concatenated Substring",
        "description": "You are given a string `s` and an array of strings `words`. All the strings of `words` are of the same length. A concatenated substring in `s` is a substring that contains all the strings of any permutation of `words` concatenated. Return the starting indices of all the concatenated substrings in `s`. You can return the answer in any order.",
        "example": "Example 1:\n\nInput: s = \"barfoothefoobarman\", words = [\"foo\", \"bar\"]\nOutput: [0, 9]\nExplanation: The substring starting at index 0 is \"barfoo\" which is the concatenation of [\"bar\", \"foo\"]. The substring starting at index 9 is \"foobar\" which is the concatenation of [\"foo\", \"bar\"].\n\nExample 2:\n\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\", \"good\", \"best\", \"word\"]\nOutput: []\nExplanation: There is no substring in s that is the concatenation of any permutation of words.\n\nExample 3:\n\nInput: s = \"barfoofoobarthefoobarman\", words = [\"bar\", \"foo\", \"the\"]\nOutput: [6, 9, 12]\nExplanation: The substring starting at index 6 is \"foobarthe\" which is the concatenation of [\"foo\", \"bar\", \"the\"]. The substring starting at index 9 is \"barthefoo\" which is the concatenation of [\"bar\", \"the\", \"foo\"]. The substring starting at index 12 is \"thefoobar\" which is the concatenation of [\"the\", \"foo\", \"bar\"].",
        "level": "Medium",
        "tags": [
            "String",
            "Array",
            "Permutation"
        ],
        "test_cases": {
            "inputs": [
                [
                    
                        "barfoothefoobarman",
                        [
                            "foo",
                            "bar"
                        ]
                    
                ],
                [
                    
                        "wordgoodgoodgoodbestword",
                        [
                            "word",
                            "good",
                            "best",
                            "word"
                        ]
                    
                ],
                [
                    
                        "barfoofoobarthefoobarman",
                        [
                            "bar",
                            "foo",
                            "the"
                        ]
                    
                ],
                [
                    
                        "abcdefg",
                        [
                            "abc",
                            "def",
                            "g"
                        ]
                    
                ],
                [
                    
                        "hellohellohello",
                        [
                            "hello",
                            "hello"
                        ]
                    
                ],
                [
                    
                        "abcdabcdabcd",
                        [
                            "abcd",
                            "abcd",
                            "abcd"
                        ]
                    
                ],
                [
                    
                        "foobarfoobar",
                        [
                            "foo",
                            "bar"
                        ]
                    
                ],
                [
                    
                        "abcabcabc",
                        [
                            "abc",
                            "abc"
                        ]
                    
                ],
                [
                    
                        "xyzxyzxyz",
                        [
                            "xyz",
                            "xyz"
                        ]
                    
                ],
                [
                    
                        "aaaabbbbcccc",
                        [
                            "aaa",
                            "bbb",
                            "ccc"
                        ]
                    
                ],
                [
                    
                        "abcdefghijabcdefghijabcdefghij",
                        [
                            "abc",
                            "def",
                            "ghi",
                            "j"
                        ]
                    
                ],
                [
                    
                        "abcdefghijabcdefghijabcdefghij",
                        [
                            "abc",
                            "def",
                            "ghi",
                            "jkl"
                        ]
                    
                ],
                [
                    
                        "abcdefghijabcdefghijabcdefghij",
                        [
                            "abc",
                            "def",
                            "ghi",
                            "jklm"
                        ]
                    
                ],
                [
                    
                        "abcdefghijabcdefghijabcdefghij",
                        [
                            "abc",
                            "def",
                            "ghi",
                            "jklmn"
                        ]
                    
                ],
                [
                    
                        "abcdefghijabcdefghijabcdefghij",
                        [
                            "abc",
                            "def",
                            "ghi",
                            "jklmno"
                        ]
                    
                ],
                [
                    
                        "abcdefghijabcdefghijabcdefghij",
                        [
                            "abc",
                            "def",
                            "ghi",
                            "jklmnop"
                        ]
                    
                ],
                [
                    
                        "abcdefghijabcdefghijabcdefghij",
                        [
                            "abc",
                            "def",
                            "ghi",
                            "jklmnopq"
                        ]
                    
                ],
                [
                    
                        "abcdefghijabcdefghijabcdefghij",
                        [
                            "abc",
                            "def",
                            "ghi",
                            "jklmnopqr"
                        ]
                    
                ],
                [
                    
                        "abcdefghijabcdefghijabcdefghij",
                        [
                            "abc",
                            "def",
                            "ghi",
                            "jklmnopqrs"
                        ]
                    
                ],
                [
                    
                        "abcdefghijabcdefghijabcdefghij",
                        [
                            "abc",
                            "def",
                            "ghi",
                            "jklmnopqrst"
                        ]
                    
                ]
            ],
            "outputs": [
                [0, 9],
                [],
                [6, 9, 12],
                [0],
                [0, 5],
                [0, 4, 8],
                [0, 3],
                [0, 3, 6],
                [0, 3, 6],
                [0, 4, 8],
                [0, 10, 20],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                []
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<int> findSubstring(std::string s, std::vector<std::string>& words) {\n    if (s.empty() || words.empty()) return {};\n    \n    std::unordered_map<std::string, int> word_count;\n    for (const auto& word : words) {\n        ++word_count[word];\n    }\n    \n    int word_length = words[0].size();\n    int total_words = words.size();\n    int total_length = word_length * total_words;\n    std::vector<int> result;\n    \n    for (int i = 0; i <= (int)s.size() - total_length; ++i) {\n        std::unordered_map<std::string, int> temp_word_count;\n        for (int j = 0; j < total_words; ++j) {\n            std::string current_word = s.substr(i + j * word_length, word_length);\n            if (word_count.find(current_word) == word_count.end()) break;\n            ++temp_word_count[current_word];\n            if (temp_word_count[current_word] > word_count[current_word]) break;\n            if (j + 1 == total_words) result.push_back(i);\n        }\n    }\n    \n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<Integer> findSubstring(String s, String[] words) {\n    if (s == null || s.length() == 0 || words == null || words.length == 0) return new ArrayList<>();\n    \n    Map<String, Integer> word_count = new HashMap<>();\n    for (String word : words) {\n        word_count.put(word, word_count.getOrDefault(word, 0) + 1);\n    }\n    \n    int word_length = words[0].length();\n    int total_words = words.length;\n    int total_length = word_length * total_words;\n    List<Integer> result = new ArrayList<>();\n    \n    for (int i = 0; i <= s.length() - total_length; i++) {\n        Map<String, Integer> temp_word_count = new HashMap<>();\n        for (int j = 0; j < total_words; j++) {\n            String current_word = s.substring(i + j * word_length, i + (j + 1) * word_length);\n            if (!word_count.containsKey(current_word)) break;\n            temp_word_count.put(current_word, temp_word_count.getOrDefault(current_word, 0) + 1);\n            if (temp_word_count.get(current_word) > word_count.get(current_word)) break;\n            if (j + 1 == total_words) result.add(i);\n        }\n    }\n    \n    return result;\n}\n",
            "python": "from collections import Counter\n\ndef findSubstring(s, words):\n    if not s or not words:\n        return []\n\n    word_count = Counter(words)\n    word_length = len(words[0])\n    total_words = len(words)\n    total_length = word_length * total_words\n    result = []\n\n    for i in range(len(s) - total_length + 1):\n        temp_word_count = Counter()\n        for j in range(total_words):\n            current_word = s[i + j * word_length:i + (j + 1) * word_length]\n            if current_word not in word_count:\n                break\n            temp_word_count[current_word] += 1\n            if temp_word_count[current_word] > word_count[current_word]:\n                break\n            if j + 1 == total_words:\n                result.append(i)\n\n    return result\n",
            "javascript": "function findSubstring(s, words) {\n    if (!s || !words || words.length === 0) return [];\n\n    const word_count = new Map();\n    for (const word of words) {\n        word_count.set(word, (word_count.get(word) || 0) + 1);\n    }\n\n    const word_length = words[0].length;\n    const total_words = words.length;\n    const total_length = word_length * total_words;\n    const result = [];\n\n    for (let i = 0; i <= s.length - total_length; i++) {\n        const temp_word_count = new Map();\n        for (let j = 0; j < total_words; j++) {\n            const current_word = s.substr(i + j * word_length, word_length);\n            if (!word_count.has(current_word)) break;\n            temp_word_count.set(current_word, (temp_word_count.get(current_word) || 0) + 1);\n            if (temp_word_count.get(current_word) > word_count.get(current_word)) break;\n            if (j + 1 === total_words) result.push(i);\n        }\n    }\n\n    return result;\n}\n",
            "explanation": "1. If the input string `s` or `words` array is empty, return an empty list.\n2. Create a hashmap `word_count` to store the count of each word present in the `words` array.\n3. Get the length of a single word, the total number of words, and the total length of the concatenated string.\n4. Iterate through the string `s` with an index `i`, starting from 0 and up to `s.size() - total_length`.\n5. For each index `i`, create a temporary hashmap `temp_word_count`, and iterate through the words starting from index `j` to `total_words - 1`.\n6. Extract the current word from the substring with the starting position `(i + j * word_length)`, and length `word_length`.\n7. Look for the current word in the hashmap `word_count`. If it's not present, break the loop and check the next index.\n8. Add the current word to the temporary hashmap `temp_word_count`. If the word's count in `temp_word_count` exceeds the count in `word_count`, break the loop.\n9. If all words are present in the substring and satisfy the required counts, add the current index `i` to the result list.\n10. Return the result list after processing all indices."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<int> findSubstring(std::string s, std::vector<std::string>& words) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<Integer> findSubstring(String s, String[] words) \n    // Your code here\n}\n",
            "python": "from collections import Counter\n    # Your code here\n\n",
            "javascript": "function findSubstring(s, words) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<int> findSubstring(std::string s, std::vector<std::string>& words);\n\nint main() {\n    std::string s = $args;\n    std::vector<std::string> words = {\"word1\", \"word2\", \"word3\"}; // Replace with actual words\n    std::vector<int> result = findSubstring(s, words);\n    \n    for (int i : result) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}",
            "java": "public List<Integer> findSubstring(String s, String[] words) {\n    if (s == null || s.length() == 0 || words == null || words.length == 0) return new ArrayList<>();\n    \n    Map<String, Integer> word_count = new HashMap<>();\n    for (String word : words) {\n        word_count.put(word, word_count.getOrDefault(word, 0) + 1);\n    }\n    \n    int word_length = words[0].length();\n    int total_words = words.length;\n    int total_length = word_length * total_words;\n    List<Integer> result = new ArrayList<>();\n    \n    for (int i = 0; i <= s.length() - total_length; i++) {\n        Map<String, Integer> temp_word_count = new HashMap<>();\n        for (int j = 0; j < total_words; j++) {\n            String current_word = s.substring(i + j * word_length, i + (j + 1) * word_length);\n            if (!word_count.containsKey(current_word)) break;\n            temp_word_count.put(current_word, temp_word_count.getOrDefault(current_word, 0) + 1);\n            if (temp_word_count.get(current_word) > word_count.get(current_word)) break;\n            if (j + 1 == total_words) result.add(i);\n        }\n    }\n    \n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs = $args\n    s = inputs[0]\n    words =inputs[1]\n    print(findSubstring(s, words))",
            "javascript": "function findSubstring(s, words) {\n    if (!s || !words || words.length === 0) return [];\n\n    const word_count = new Map();\n    for (const word of words) {\n        word_count.set(word, (word_count.get(word) || 0) + 1);\n    }\n\n    const word_length = words[0].length;\n    const total_words = words.length;\n    const total_length = word_length * total_words;\n    const result = [];\n\n    for (let i = 0; i <= s.length - total_length; i++) {\n        const temp_word_count = new Map();\n        for (let j = 0; j < total_words; j++) {\n            const current_word = s.substr(i + j * word_length, word_length);\n            if (!word_count.has(current_word)) break;\n            temp_word_count.set(current_word, (temp_word_count.get(current_word) || 0) + 1);\n            if (temp_word_count.get(current_word) > word_count.get(current_word)) break;\n            if (j + 1 === total_words) result.push(i);\n        }\n    }\n\n    return result;\n}"
        }
    },
    "7": {
        "title": "Reverse Integer",
        "description": "Given a signed 32-bit integer `x`, return `x` with its digits reversed. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-231, 231 - 1]`, then return `0`.\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).",
        "example": "Example 1:\n\nInput: x = 123\nOutput: 321\n\nExample 2:\n\nInput: x = -123\nOutput: -321\n\nExample 3:\n\nInput: x = 120\nOutput: 21",
        "level": "Easy",
        "tags": [
            "Math"
        ],
        "test_cases": {
            "inputs": [
                123,
                -123,
                120,
                0,
                1,
                -1,
                10,
                -10,
                100,
                -100,
                123456789,
                -123456789,
                2147483647,
                -2147483648,
                2147483646,
                -2147483647,
                1534236469,
                -2147483412,
                0,
                987654321
            ],
            "outputs": [
                321,
                -321,
                21,
                0,
                1,
                -1,
                1,
                -1,
                1,
                -1,
                987654321,
                -987654321,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                123456789
            ]
        },
        "sample_code": {
            "c++": "int reverse(int x) {\n    long long res = 0;\n    while (x != 0) {\n        res = res * 10 + x % 10;\n        x /= 10;\n    }\n    return (res < INT_MIN || res > INT_MAX) ? 0 : res;\n}\n",
            "java": "public int reverse(int x) {\n    long res = 0;\n    while (x != 0) {\n        res = res * 10 + x % 10;\n        x /= 10;\n    }\n    return (res < Integer.MIN_VALUE || res > Integer.MAX_VALUE) ? 0 : (int)res;\n}\n",
            "python": "def reverse(x: int) -> int:\n    sign = -1 if x < 0 else 1\n    x = abs(x)\n    res = 0\n    while x:\n        res = res * 10 + x % 10\n        x //= 10\n    res *= sign\n    return res if -2**31 <= res <= 2**31 - 1 else 0\n",
            "javascript": "function reverse(x) {\n    let sign = x < 0 ? -1 : 1;\n    x = Math.abs(x);\n    let res = 0;\n    while (x !== 0) {\n        res = res * 10 + x % 10;\n        x = Math.floor(x / 10);\n    }\n    res *= sign;\n    return (res < -(2 ** 31) || res > 2 ** 31 - 1) ? 0 : res;\n}\n",
            "explanation": "The algorithm initializes `res` as 0. Then, we determine the sign of the input integer and take its absolute value. We use a while loop to iterate through each digit of `x` from right to left. In each iteration, we multiply the current `res` by 10 and add the last digit of `x` to it. The last digit of `x` is obtained by `x % 10`. After adding the last digit, we remove it from `x` by doing either `x /= 10` or `x //= 10`.\n\nAfter processing all the digits, we adjust `res` with the sign we computed earlier. Finally, we check if the reversed integer is within the 32-bit integer range. If it is, we return the result; otherwise, we return 0."
        },
        "structure": {
            "c++": "int reverse(int x) \n    // Your code here\n}\n",
            "java": "public int reverse(int x) \n    // Your code here\n}\n",
            "python": "def reverse(x: int) -> int:\n    # Your code here\n\n",
            "javascript": "function reverse(x) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int x = $args;\n    long long res = 0;\n    while (x != 0) {\n        res = res * 10 + x % 10;\n        x /= 10;\n    }\n    int result = (res < INT_MIN || res > INT_MAX) ? 0 : res;\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    int x = $args;\n    int result = reverse(x);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    x = $args\n    result = reverse(x)\n    print(result)",
            "javascript": "function main() {\n    const x = $args;\n    let sign = x < 0 ? -1 : 1;\n    x = Math.abs(x);\n    let res = 0;\n    while (x !== 0) {\n        res = res * 10 + x % 10;\n        x = Math.floor(x / 10);\n    }\n    res *= sign;\n    const result = (res < -(2 ** 31) || res > 2 ** 31 - 1) ? 0 : res;\n    console.log(result);\n}"
        }
    },
    "31": {
        "title": "Next Permutation",
        "description": "Given an array of integers, find the next lexicographically greater permutation of the array. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). Implement the function `nextPermutation(nums: List[int]) -> None` to find the next permutation in place using constant extra memory.",
        "example": "Example:\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n\nExplanation: The next permutation of [1,2,3] is [1,3,2].\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n\nExplanation: The next permutation of [3,2,1] is [1,2,3].\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n\nExplanation: The next permutation of [1,1,5] is [1,5,1].",
        "level": "Medium",
        "tags": [
            "Array",
            "Sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3
                ],
                [
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4
                ],
                [
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    5,
                    4
                ],
                [
                    1,
                    2,
                    4,
                    3,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1,
                    0
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    5,
                    4,
                    0
                ],
                [
                    1,
                    2,
                    4,
                    3,
                    5,
                    0
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1,
                    0,
                    9
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    0,
                    9
                ],
                [
                    1,
                    2,
                    3,
                    5,
                    4,
                    0,
                    9
                ],
                [
                    1,
                    2,
                    4,
                    3,
                    5,
                    0,
                    9
                ]
            ],
            "outputs": [
                "[1,3,2]",
                "[1,2,3]",
                "[1,5,1]",
                "[1,2,4,3]",
                "[1,2,3,4]",
                "[1,1,1,1]",
                "[1,2,3,5,4]",
                "[1,2,3,5,4]",
                "[1,2,4,0,3,5]",
                "[1,2,4,5,3,0]",
                "[0,1,2,3,4,5]",
                "[0,1,2,3,4,5]",
                "[0,1,2,3,5,4]",
                "[0,1,2,3,5,4]",
                "[0,1,2,3,5,4]",
                "[0,1,2,3,5,4,9]",
                "[0,1,2,3,4,5,6,7,8,9]",
                "[0,1,2,3,5,4,9]",
                "[0,1,2,3,5,4,9]",
                "[0,1,2,3,5,4,9]"
            ]
        },
        "sample_code": {
            "c++": "#include <algorithm>\nvoid nextPermutation(vector<int>& nums) {\n    int n = nums.size(), k, l;\n    for (k = n - 2; k >= 0; k--) {\n        if (nums[k] < nums[k + 1]) break;\n    }\n    if (k < 0) {\n        reverse(nums.begin(), nums.end());\n    } else {\n        for (l = n - 1; l > k; l--) {\n            if (nums[l] > nums[k]) break;\n        }\n        swap(nums[k], nums[l]);\n        reverse(nums.begin() + k + 1, nums.end());\n    }\n}\n",
            "java": "public void nextPermutation(int[] nums) {\n    int n = nums.length, k = n - 2, l;\n    while(k >= 0 && nums[k] >= nums[k + 1]) k--;\n\n    if(k < 0) {\n        Arrays.sort(nums);\n    } else {\n        for (l = n - 1; l > k; l--) {\n            if (nums[l] > nums[k]) break;\n        }\n        int temp = nums[k];\n        nums[k] = nums[l];\n        nums[l] = temp;\n        Arrays.sort(nums, k + 1, n);\n    }\n}\n",
            "python": "def nextPermutation(nums):\n    n, k = len(nums), -1\n    for i in range(n - 1, 0, -1):\n        if nums[i - 1] < nums[i]:\n            k = i - 1\n            break\n    if k == -1:\n        nums.reverse()\n    else:\n        l = 0\n        for i in range(n - 1, k, -1):\n            if nums[i] > nums[k]:\n                l = i\n                break\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k + 1:] = reversed(nums[k + 1:])\n    return nums\n",
            "javascript": "function nextPermutation(nums) {\n    let n = nums.length, k = n - 2, l;\n    while(k >= 0 && nums[k] >= nums[k + 1]) k--;\n\n    if(k < 0) {\n        nums.sort((a, b) => a - b);\n    } else {\n        for (l = n - 1; l > k; l--) {\n            if (nums[l] > nums[k]) break;\n        }\n        [nums[k], nums[l]] = [nums[l], nums[k]];\n        let tempArr = nums.slice(k + 1).sort((a, b) => a - b);\n        nums.splice(k + 1, n - k - 1, ...tempArr);\n    }\n}\n",
            "explanation": "We can solve this problem by following the steps below:\n\n1. Identify the largest index `k` such that `nums[k] < nums[k + 1]`. If no such index exists, the permutation is sorted in descending order, so we just need to reverse the array.\n2. Identify the largest index `l` greater than `k` such that `nums[k] < nums[l]`.\n3. Swap the value of `nums[k]` with that of `nums[l]`.\n4. Reverse the sub-array `nums[k + 1:]` which is guaranteed to be in non-increasing order.\n\nBy making these changes in place and only using constant extra memory, we obtain the next permutation of the array nums."
        },
        "structure": {
            "c++": "#include <algorithm>\nvoid nextPermutation(vector<int>& nums) \n    // Your code here\n}\n",
            "java": "public void nextPermutation(int[] nums) \n    // Your code here\n}\n",
            "python": "def nextPermutation(nums):\n    # Your code here\n\n",
            "javascript": "function nextPermutation(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid nextPermutation(vector<int>& nums) {\n    int n = nums.size(), k, l;\n    for (k = n - 2; k >= 0; k--) {\n        if (nums[k] < nums[k + 1]) break;\n    }\n    if (k < 0) {\n        reverse(nums.begin(), nums.end());\n    } else {\n        for (l = n - 1; l > k; l--) {\n            if (nums[l] > nums[k]) break;\n        }\n        swap(nums[k], nums[l]);\n        reverse(nums.begin() + k + 1, nums.end());\n    }\n}\n\nint main() {\n    vector<int> nums = $args;\n    nextPermutation(nums);\n    for (int i = 0; i < nums.size(); i++) {\n        cout << nums[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "java": "public void callNextPermutation(int[] nums) {\n    int n = nums.length, k = n - 2, l;\n    while(k >= 0 && nums[k] >= nums[k + 1]) k--;\n\n    if(k < 0) {\n        Arrays.sort(nums);\n    } else {\n        for (l = n - 1; l > k; l--) {\n            if (nums[l] > nums[k]) break;\n        }\n        int temp = nums[k];\n        nums[k] = nums[l];\n        nums[l] = temp;\n        Arrays.sort(nums, k + 1, n);\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    nums =$args\n    print(nextPermutation(nums))",
            "javascript": "function nextPermutation(nums) {\n    let n = nums.length, k = n - 2, l;\n    while(k >= 0 && nums[k] >= nums[k + 1]) k--;\n\n    if(k < 0) {\n        nums.sort((a, b) => a - b);\n    } else {\n        for (l = n - 1; l > k; l--) {\n            if (nums[l] > nums[k]) break;\n        }\n        [nums[k], nums[l]] = [nums[l], nums[k]];\n        let tempArr = nums.slice(k + 1).sort((a, b) => a - b);\n        nums.splice(k + 1, n - k - 1, ...tempArr);\n    }\n}"
        }
    },
    "33": {
        "title": "Search in Rotated Sorted Array",
        "description": "You are given an integer array `nums` sorted in ascending order (with **distinct** values). Prior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`. Given the array `nums` **after** the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or -1 if it is not in `nums`. You must write an algorithm with O(log n) runtime complexity.",
        "example": "Example:\n\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\n\nExplanation: The target element 0 is present at index 4 in the rotated sorted array.\n\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\n\nExplanation: The target element 3 is not present in the rotated sorted array.\n\nInput: nums = [1], target = 0\nOutput: -1\n\nExplanation: The target element 0 is not present in the rotated sorted array.",
        "level": "Medium",
        "tags": [
            "Array",
            "Binary Search"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        4,
                        5,
                        6,
                        7,
                        0,
                        1,
                        2
                    ],
                    0
                ],
                [
                    [
                        4,
                        5,
                        6,
                        7,
                        0,
                        1,
                        2
                    ],
                    3
                ],
                [
                    [
                        1
                    ],
                    0
                ],
                [
                    [
                        1,
                        3,
                        5
                    ],
                    1
                ],
                [
                    [
                        3,
                        5,
                        1
                    ],
                    1
                ],
                [
                    [
                        5,
                        1,
                        3
                    ],
                    1
                ],
                [
                    [
                        1,
                        3
                    ],
                    1
                ],
                [
                    [
                        3,
                        1
                    ],
                    1
                ],
                [
                    [
                        1
                    ],
                    1
                ]
            ],
            "outputs": [
                "4",
                "-1",
                "-1",
                "0",
                "2",
                "1",
                "0",
                "1",
                "-1"
            ]
        },
        "sample_code": {
            "c++": "int search(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        }\n        if (nums[mid] >= nums[left]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n",
            "java": "public int search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        }\n        if (nums[mid] >= nums[left]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n",
            "python": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] >= nums[left]:\n            if target >= nums[left] and target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if target > nums[mid] and target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return -1\n",
            "javascript": "function search(nums, target) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] === target) {\n            return mid;\n        }\n        if (nums[mid] >= nums[left]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n",
            "explanation": "The algorithm is a variation of binary search. The main idea is to decide whether the target is in the left or the right half of the current subarray. If nums[mid] >= nums[left], the left half is sorted. If target is in the range [nums[left], nums[mid]), set right = mid - 1. Otherwise, set left = mid + 1. If nums[mid] < nums[left], the right half must be sorted. If target is in the range (nums[mid], nums[right]], set left = mid + 1. Otherwise, set right = mid - 1. Continue the process until the target is found or the subarray is empty, in which case return -1. This algorithm has a runtime complexity of O(log n) because it eliminates half of the remaining elements at each step, similar to a binary search."
        },
        "structure": {
            "c++": "int search(vector<int>& nums, int target) \n    // Your code here\n}\n",
            "java": "public int search(int[] nums, int target) \n    // Your code here\n}\n",
            "python": "def search(nums, target):\n    # Your code here\n\n",
            "javascript": "function search(nums, target) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint search(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        }\n        if (nums[mid] >= nums[left]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    vector<int> nums = $args;\n    int target = $args;\n    int result = search(nums, target);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        }\n        if (nums[mid] >= nums[left]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs  = $args\n    nums = inputs[0]\n    target = inputs[1]\n    result = search(nums, target)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args[0];\n    const target = $args[1];\n    const result = search(nums, target);\n    console.log(result);\n}"
        }
    },
    "34": {
        "title": "Find Target Range",
        "description": "Given an array of integers `nums` sorted in non-decreasing order, find the starting and ending position of a given `target` value. If `target` is not found in the array, return `[-1, -1]`. You must write an algorithm with `O(log n)` runtime complexity.",
        "example": "Example:\n\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\n\nExplanation: The target value 8 is found at index 3 and 4 in the array.\n\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\n\nExplanation: The target value 6 is not found in the array.\n\nInput: nums = [], target = 0\nOutput: [-1,-1]\n\nExplanation: The array is empty, so the target value 0 is not found.",
        "level": "Medium",
        "tags": [
            "array",
            "binary search"
        ],
        "test_cases": {
            "inputs": [
                [
                    5,
                    7,
                    7,
                    8,
                    8,
                    10
                ],
                [
                    5,
                    7,
                    7,
                    8,
                    8,
                    10
                ],
                [],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ]
            ],
            "outputs": [
                [
                    3,
                    4
                ],
                [
                    -1,
                    -1
                ],
                [
                    -1,
                    -1
                ],
                [
                    -1,
                    -1
                ],
                [
                    -1,
                    -1
                ],
                [
                    0,
                    0
                ],
                [
                    1,
                    1
                ],
                [
                    2,
                    2
                ],
                [
                    3,
                    3
                ],
                [
                    4,
                    4
                ],
                [
                    -1,
                    -1
                ],
                [
                    -1,
                    -1
                ],
                [
                    -1,
                    -1
                ],
                [
                    -1,
                    -1
                ],
                [
                    -1,
                    -1
                ],
                [
                    -1,
                    -1
                ],
                [
                    -1,
                    -1
                ],
                [
                    -1,
                    -1
                ],
                [
                    -1,
                    -1
                ],
                [
                    -1,
                    -1
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nstd::vector<int> searchRange(std::vector<int>& nums, int target) {\n    int start = -1, end = -1;\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n            if (nums[mid] == target) {\n                start = mid;\n            }\n        }\n    }\n    \n    left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > target) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n            if (nums[mid] == target) {\n                end = mid;\n            }\n        }\n    }\n    \n    return {start, end};\n}\n",
            "java": "public int[] searchRange(int[] nums, int target) {\n    int start = -1, end = -1;\n    int left = 0, right = nums.length - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n            if (nums[mid] == target) {\n                start = mid;\n            }\n        }\n    }\n    \n    left = 0;\n    right = nums.length - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > target) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n            if (nums[mid] == target) {\n                end = mid;\n            }\n        }\n    }\n    \n    return new int[] {start, end};\n}\n",
            "python": "def searchRange(nums, target):\n    start, end = -1, -1\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n            if nums[mid] == target:\n                start = mid\n\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] > target:right = mid - 1\n        else:\n            left = mid + 1\n            if nums[mid] == target:\n                end = mid\n    \n    return [start, end]\n",
            "javascript": "function searchRange(nums, target) {\n    let start = -1, end = -1;\n    let left = 0, right = nums.length - 1;\n\n    while (left <= right) {\n        const mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n            if (nums[mid] === target) {\n                start = mid;\n            }\n        }\n    }\n\n    left = 0;\n    right = nums.length - 1;\n\n    while (left <= right) {\n        const mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] > target) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n            if (nums[mid] === target) {\n                end = mid;\n            }\n        }\n    }\n\n    return [start, end];\n}\n",
            "explanation": "1. Initialize `start` and `end` variables to -1 as default return values.\n2. Setup `left` and `right` pointers at the beginning and end of the `nums` array.\n3. Loop until `left` is greater than `right`:\n   a. Calculate the `mid` index.\n   b. If the value at the `mid` index is smaller than `target`, move the `left` pointer to `mid + 1`.\n   c. If the value at the `mid` index is greater than or equal to `target`, move the `right` pointer to `mid - 1`. If the value at the `mid` index is equal to `target`, update `start` with `mid`.\n4. Reset `left` and `right` pointers to the beginning and end of the `nums` array.\n5. Loop again until `left` is greater than `right`:\n   a. Calculate the `mid` index.\n   b. If the value at the `mid` index is greater than `target`, move the `right` pointer to `mid - 1`.\n   c. If the value at the `mid` index is smaller than or equal to `target`, move the `left` pointer to `mid + 1`. If the value at the `mid` index is equal to `target`, update `end` with `mid`.\n6. Return the resulting `start` and `end` values as an array/list."
        },
        "structure": {
            "c++": "#include <vector>\n\nstd::vector<int> searchRange(std::vector<int>& nums, int target) \n    // Your code here\n}\n",
            "java": "public int[] searchRange(int[] nums, int target) \n    // Your code here\n}\n",
            "python": "def searchRange(nums, target):\n    # Your code here\n\n",
            "javascript": "function searchRange(nums, target) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\n\nstd::vector<int> searchRange(std::vector<int>& nums, int target);\n\nint main() {\n    std::vector<int> nums = $args;\n    int target = 5;\n    std::vector<int> result = searchRange(nums, target);\n    std::cout << \"[\" << result[0] << \", \" << result[1] << \"]\" << std::endl;\n    return 0;\n}\n",
            "java": "public int[] searchRange(int[] nums, int target) {\n    int start = -1, end = -1;\n    int left = 0, right = nums.length - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n            if (nums[mid] == target) {\n                start = mid;\n            }\n        }\n    }\n    \n    left = 0;\n    right = nums.length - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > target) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n            if (nums[mid] == target) {\n                end = mid;\n            }\n        }\n    }\n    \n    return new int[] {start, end};\n}",
            "python": "if __name__ == \"__main__\":\n    input  = $args\n    result = search(nums, target)\n    print(result)",
            "javascript": "function searchRange(nums, target) {\n    let start = -1, end = -1;\n    let left = 0, right = nums.length - 1;\n\n    while (left <= right) {\n        const mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n            if (nums[mid] === target) {\n                start = mid;\n            }\n        }\n    }\n\n    left = 0;\n    right = nums.length - 1;\n\n    while (left <= right) {\n        const mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] > target) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n            if (nums[mid] === target) {\n                end = mid;\n            }\n        }\n    }\n\n    return [start, end];\n}"
        }
    },
    "35": {
        "title": "Search Insert Position",
        "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou must write an algorithm with O(log n) runtime complexity.",
        "example": "Example:\n\nInput: nums = [1,3,5,6], target = 5\nOutput: 2\n\nExplanation: The target value 5 is found at index 2 in the given array.\n\nInput: nums = [1,3,5,6], target = 2\nOutput: 1\n\nExplanation: The target value 2 is not found in the given array. If it were to be inserted, it would be at index 1.\n\nInput: nums = [1,3,5,6], target = 7\nOutput: 4\n\nExplanation: The target value 7 is not found in the given array. If it were to be inserted, it would be at index 4.",
        "level": "Easy",
        "tags": [
            "Array",
            "Binary Search"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    5
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    2
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    7
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    0
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    4
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    6
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    3
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    1
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    8
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    -1
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    10
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    -5
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6,
                        8,
                        10
                    ],
                    5
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6,
                        8,
                        10
                    ],
                    2
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6,
                        8,
                        10
                    ],
                    7
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6,
                        8,
                        10
                    ],
                    0
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6,
                        8,
                        10
                    ],
                    4
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6,
                        8,
                        10
                    ],
                    6
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6,
                        8,
                        10
                    ],
                    3
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6,
                        8,
                        10
                    ],
                    1
                ]
            ],
            "outputs": [
                "2",
                "1",
                "4",
                "0",
                "2",
                "3",
                "1",
                "0",
                "6",
                "0",
                "6",
                "0",
                "2",
                "1",
                "4",
                "0",
                "2",
                "3",
                "1",
                "0"
            ]
        },
        "sample_code": {
            "c++": "int searchInsert(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n}\n",
            "java": "public int searchInsert(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n}\n",
            "python": "def searchInsert(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left\n",
            "javascript": "function searchInsert(nums, target) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] === target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n}\n",
            "explanation": "The given problem requires a binary search algorithm. We define two pointers, `left` and `right`, initially set to the first and last index of the array. We then enter a loop that continues as long as left is less than or equal to right. Inside the loop, we calculate the middle index, `mid`, as the average of left and right. If the value at this middle index is equal to the target value, we return the middle index. If the middle value is less than the target value, we set left to `mid + 1`, meaning we search the right half of the remaining array. If the middle value is greater than the target value, we set the right to `mid - 1`, meaning we search the left half of the remaining array. After the loop, if the target value is not found, we return the value of the left pointer, which represents the index where the target value should be inserted."
        },
        "structure": {
            "c++": "int searchInsert(vector<int>& nums, int target) \n    // Your code here\n}\n",
            "java": "public int searchInsert(int[] nums, int target) \n    // Your code here\n}\n",
            "python": "def searchInsert(nums, target):\n    # Your code here\n\n",
            "javascript": "function searchInsert(nums, target) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint searchInsert(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n}\n\nint main() {\n    vector<int> nums = $args;\n    int target = $args;\n    int result = searchInsert(nums, target);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    int[] nums = {1, 3, 5, 6};\n    int target = 5;\n    int result = searchInsert(nums, target);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    target = $args[1]\n    result = searchInsert(nums, target)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args[0];\n    const target = $args[1];\n    const result = searchInsert(nums, target);\n    console.log(result);\n}"
        }
    },
    "37": {
        "title": "Sudoku Solver",
        "description": "Write a program to solve a Sudoku puzzle by filling the empty cells. A Sudoku solution must satisfy all of the following rules:\n\n1. Each of the digits `1-9` must occur exactly once in each row.\n2. Each of the digits `1-9` must occur exactly once in each column.\n3. Each of the digits `1-9` must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.\n\nThe '.' character indicates empty cells.",
        "example": "**Example:**\n\n**Input:**\nboard = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n]\n**Output:**\n[\n    [\"5\", \"3\", \"4\", \"6\", \"7\", \"8\", \"9\", \"1\", \"2\"],\n    [\"6\", \"7\", \"2\", \"1\", \"9\", \"5\", \"3\", \"4\", \"8\"],\n    [\"1\", \"9\", \"8\", \"3\", \"4\", \"2\", \"5\", \"6\", \"7\"],\n    [\"8\", \"5\", \"9\", \"7\", \"6\", \"1\", \"4\", \"2\", \"3\"],\n    [\"4\", \"2\", \"6\", \"8\", \"5\", \"3\", \"7\", \"9\", \"1\"],\n    [\"7\", \"1\", \"3\", \"9\", \"2\", \"4\", \"8\", \"5\", \"6\"],\n    [\"9\", \"6\", \"1\", \"5\", \"3\", \"7\", \"2\", \"8\", \"4\"],\n    [\"2\", \"8\", \"7\", \"4\", \"1\", \"9\", \"6\", \"3\", \"5\"],\n    [\"3\", \"4\", \"5\", \"2\", \"8\", \"6\", \"1\", \"7\", \"9\"]\n]\n**Explanation:** The input board is shown above and the only valid solution is shown below:",
        "level": "Medium",
        "tags": [
            "array",
            "backtracking"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "5",
                        "3",
                        ".",
                        ".",
                        "7",
                        ".",
                        ".",
                        ".",
                        "."
                    ],
                    [
                        "6",
                        ".",
                        ".",
                        "1",
                        "9",
                        "5",
                        ".",
                        ".",
                        "."
                    ],
                    [
                        ".",
                        "9",
                        "8",
                        ".",
                        ".",
                        ".",
                        ".",
                        "6",
                        "."
                    ],
                    [
                        "8",
                        ".",
                        ".",
                        ".",
                        "6",
                        ".",
                        ".",
                        ".",
                        "3"
                    ],
                    [
                        "4",
                        ".",
                        ".",
                        "8",
                        ".",
                        "3",
                        ".",
                        ".",
                        "1"
                    ],
                    [
                        "7",
                        ".",
                        ".",
                        ".",
                        "2",
                        ".",
                        ".",
                        ".",
                        "6"
                    ],
                    [
                        ".",
                        "6",
                        ".",
                        ".",
                        ".",
                        ".",
                        "2",
                        "8",
                        "."
                    ],
                    [
                        ".",
                        ".",
                        ".",
                        "4",
                        "1",
                        "9",
                        ".",
                        ".",
                        "5"
                    ],
                    [
                        ".",
                        ".",
                        ".",
                        ".",
                        "8",
                        ".",
                        ".",
                        "7",
                        "9"
                    ]
                ]
            ],
            "outputs": [
                "[[\"5\", \"3\", \"4\", \"6\", \"7\", \"8\", \"9\", \"1\", \"2\"],[\"6\", \"7\", \"2\", \"1\", \"9\", \"5\", \"3\", \"4\", \"8\"],[\"1\", \"9\", \"8\", \"3\", \"4\", \"2\", \"5\", \"6\", \"7\"],[\"8\", \"5\", \"9\", \"7\", \"6\", \"1\", \"4\", \"2\", \"3\"],[\"4\", \"2\", \"6\", \"8\", \"5\", \"3\", \"7\", \"9\", \"1\"],[\"7\", \"1\", \"3\", \"9\", \"2\", \"4\", \"8\", \"5\", \"6\"],[\"9\", \"6\", \"1\", \"5\", \"3\", \"7\", \"2\", \"8\", \"4\"],[\"2\", \"8\", \"7\", \"4\", \"1\", \"9\", \"6\", \"3\", \"5\"],[\"3\", \"4\", \"5\", \"2\", \"8\", \"6\", \"1\", \"7\", \"9\"]]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nbool isValid(vector<vector<char>>& board, int row, int col, char c) {\n    for (int i = 0; i < 9; i++) {\n        if (board[i][col] == c) return false; \n        if (board[row][i] == c) return false; \n        if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false; \n    }\n    return true;\n}\n\nbool solveSudokuHelper(vector<vector<char>>& board) {\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            if (board[i][j] == '.') {\n                for (char c = '1'; c <= '9'; c++) {\n                    if (isValid(board, i, j, c)) {\n                        board[i][j] = c;\n\n                        if (solveSudokuHelper(board))\n                            return true;\n\n                        board[i][j] = '.';\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid solveSudoku(vector<vector<char>>& board) {\n    solveSudokuHelper(board);\n}\n",
            "java": "import java.util.*;\n\nclass Solution {\n    public boolean isValid(char[][] board, int row, int col, char c) {\n        for (int i = 0; i < 9; i++) {\n            if (board[i][col] == c) return false;\n            if (board[row][i] == c) return false;\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false;\n        }\n        return true;\n    }\n\n    public boolean solveSudokuHelper(char[][] board) {\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if (board[i][j] == '.') {\n                    for (char c = '1'; c <= '9'; c++) {\n                        if (isValid(board, i, j, c)) {\n                            board[i][j] = c;\n\n                            if (solveSudokuHelper(board)) {\n                                return true;\n                            }\n\n                            board[i][j] = '.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void solveSudoku(char[][] board) {\n        solveSudokuHelper(board);\n    }\n}\n",
            "python": "def isValid(board, row, col, c):\n    for i in range(9):\n        if board[i][col] == c:\n            return False\n        if board[row][i] == c:\n            return False\n        if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == c:\n            return False\n    return True\n\ndef solveSudokuHelper(board):\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == '.':\n                for c in '123456789':\n                    if isValid(board, i, j, c):\n                        board[i][j] = c\n\n                        if solveSudokuHelper(board):\n                            return True\n\n                        board[i][j] = '.'\n                return False\n\n    return True\n\ndef solveSudoku(board):\n    solveSudokuHelper(board)\n",
            "javascript": "function isValid(board, row, col, c) {\n    for (let i = 0; i < 9; i++) {\n        if (board[i][col] === c) return false;\n        if (board[row][i] === c) return false;\n        if (board[3 * Math.floor(row / 3) + Math.floor(i / 3)][3 * Math.floor(col / 3) + i % 3] === c) return false;\n    }\n    return true;\n}\n\nfunction solveSudokuHelper(board) {\n    for (let i = 0; i < 9; i++) {\n        for (let j = 0; j < 9; j++) {\n            if (board[i][j] === '.') {\n                for (let c = 1; c <= 9; c++) {\n                    if (isValid(board, i, j, c.toString())) {\n                        board[i][j] = c.toString();\n\n                        if (solveSudokuHelper(board)) {\n                            return true;\n                        }\n\n                        board[i][j] = '.';\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nfunction solveSudoku(board) {\n    solveSudokuHelper(board);\n}\n",
            "explanation": "1. The algorithm starts by searching for an empty cell (denoted by '.').\n2. Once an empty cell is found, it tries to insert a number from 1 to 9.\n3. For each inserted number, it checks if its placement is valid based on Sudoku rules:\n   - The number must not be present in the same row or column.\n   - The number must not be present in its corresponding 3x3 grid.\n4. It calls itself (backtracks) recursively whenever a valid number is inserted into the cell.\n5. If inserting a number fails to lead to a valid solution, the algorithm reverts that cell to '.' and tries the next number.\n6. The process is repeated until a valid board is created or all possibilities have failed.\n7. Once an empty cell is not found, it considers the board solved and exits the process."
        },
        "structure": {
            "c++": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nbool isValid(vector<vector<char>>& board, int row, int col, char c) \n    // Your code here\n}\n",
            "java": "import java.util.*;\n\nclass Solution \n    // Your code here\n}\n",
            "python": "def isValid(board, row, col, c):\n    # Your code here\n\n",
            "javascript": "function isValid(board, row, col, c) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nbool isValid(vector<vector<char>>& board, int row, int col, char c) {\n    for (int i = 0; i < 9; i++) {\n        if (board[i][col] == c) return false; \n        if (board[row][i] == c) return false; \n        if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false; \n    }\n    return true;\n}\n\nbool solveSudokuHelper(vector<vector<char>>& board) {\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            if (board[i][j] == '.') {\n                for (char c = '1'; c <= '9'; c++) {\n                    if (isValid(board, i, j, c)) {\n                        board[i][j] = c;\n\n                        if (solveSudokuHelper(board))\n                            return true;\n\n                        board[i][j] = '.';\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid solveSudoku(vector<vector<char>>& board) {\n    solveSudokuHelper(board);\n}\n\nint main() {\n    vector<vector<char>> board = $args;\n    solveSudoku(board);\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            cout << board[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n        int n = $args;\n        boolean result = isPowerOfFour(n);\n        System.out.println(result);\n    }\n",
            "python": "if __name__ == \"__main__\":\n    board = $args[0]\n    solveSudoku(board)\n    print(board)",
            "javascript": "function solveSudoku(board) {\n    solveSudokuHelper(board);\n}"
        }
    },
    "38": {
        "title": "Count and Say Sequence",
        "description": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula. Given a positive integer n, return the nth term of the count-and-say sequence.",
        "example": "Example:\n\nInput: n = 4\nOutput: \"1211\"\nExplanation:\ncountAndSay(1) = \"1\"\ncountAndSay(2) = say \"1\" = one 1 = \"11\"\ncountAndSay(3) = say \"11\" = two 1's = \"21\"\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"",
        "level": "Easy",
        "tags": [
            "recursion",
            "string"
        ],
        "test_cases": {
            "inputs": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                15,
                20,
                25,
                30
            ],
            "outputs": [
                "1",
                "11",
                "21",
                "1211",
                "111221",
                "312211",
                "13112221",
                "1113213211",
                "31131211131221",
                "13211311123113112211",
                "311311222113111231131112132112311321322112111312211312111322212311322113212221",
                "11131221131211131231121113112221121321132132211331222113112211",
                "311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111312211311123113322112111312211312111322212311322113212221",
                "111312211312111312311211131122211213211321322113312221131122111213122112311311222112111312211311123113322112111312211312111322212311322113212221"
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n\nstd::string countAndSay(int n) {\n    if (n == 1) return \"1\";\n    std::string previous = countAndSay(n-1);\n    std::string result = \"\";\n    int count = 1;\n    for (int i = 1; i < previous.length(); i++) {\n        if (previous[i] == previous[i-1]) {\n            count++;\n        } else {\n            result += std::to_string(count) + previous[i-1];\n            count = 1;\n        }\n    }\n    result += std::to_string(count) + previous.back();\n    return result;\n}\n",
            "java": "public String countAndSay(int n) {\n    if (n == 1) return \"1\";\n    String previous = countAndSay(n-1);\n    StringBuilder result = new StringBuilder();\n    int count = 1;\n    for (int i = 1; i < previous.length(); i++) {\n        if (previous.charAt(i) == previous.charAt(i-1)) {\n            count++;\n        } else {\n            result.append(count).append(previous.charAt(i-1));\n            count = 1;\n        }\n    }\n    result.append(count).append(previous.charAt(previous.length()-1));\n    return result.toString();\n}\n",
            "python": "def count_and_say(n):\n    if n == 1:\n        return \"1\"\n    previous = count_and_say(n - 1)\n    result = []\n    count = 1\n    for i in range(1, len(previous)):\n        if previous[i] == previous[i - 1]:\n            count += 1\n        else:\n            result.append(str(count))\n            result.append(previous[i - 1])\n            count = 1\n    result.append(str(count))\n    result.append(previous[-1])\n    return \"\".join(result)\n",
            "javascript": "function countAndSay(n) {\n    if (n === 1) return \"1\";\n    let previous = countAndSay(n - 1);\n    let result = \"\";\n    let count = 1;\n    for (let i = 1; i < previous.length; i++) {\n        if (previous[i] === previous[i - 1]) {\n            count++;\n        } else {\n            result += count.toString() + previous[i - 1];\n            count = 1;\n        }\n    }\n    result += count.toString() + previous[previous.length - 1];\n    return result;\n}\n",
            "explanation": "The algorithm is a recursive solution. It starts with the base case, when `n` is 1, it returns the first term of the sequence \"1\". In other cases, it makes a recursive call to the function with `n-1` to get the previous term in the sequence. Then it iterates through the previous term, comparing each character with the previous one to count the number of consecutive equal digits. When it encounters a different character, it appends the count and the character to the result string and resets the count to 1. Finally, it appends the last count and character to the result string and returns it."
        },
        "structure": {
            "c++": "#include <string>\n\nstd::string countAndSay(int n) \n    // Your code here\n}\n",
            "java": "public String countAndSay(int n) \n    // Your code here\n}\n",
            "python": "def count_and_say(n):\n    # Your code here\n\n",
            "javascript": "function countAndSay(n) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <string>\n\nstd::string countAndSay(int n) {\n    if (n == 1) return \"1\";\n    std::string previous = countAndSay(n-1);\n    std::string result = \"\";\n    int count = 1;\n    for (int i = 1; i < previous.length(); i++) {\n        if (previous[i] == previous[i-1]) {\n            count++;\n        } else {\n            result += std::to_string(count) + previous[i-1];\n            count = 1;\n        }\n    }\n    result += std::to_string(count) + previous.back();\n    return result;\n}\n\nint main() {\n    int n = $args;\n    std::string result = countAndSay(n);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "python": "def call_count_and_say(n):\n    result = count_and_say(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    n = $args\n    call_count_and_say(n)",
            "javascript": "function main() {\n    const n = $args;\n    const result = countAndSay(n);\n    console.log(result);\n}",
            "java": "public String countAndSay(int n) {\n    if (n == 1) return \"1\";\n    String previous = countAndSay(n-1);\n    StringBuilder result = new StringBuilder();\n    int count = 1;\n    for (int i = 1; i < previous.length(); i++) {\n        if (previous.charAt(i) == previous.charAt(i-1)) {\n            count++;\n        } else {\n            result.append(count).append(previous.charAt(i-1));\n            count = 1;\n        }\n    }\n    result.append(count).append(previous.charAt(previous.length()-1));\n    return result.toString();\n}"
        }
    },
    "41": {
        "title": "Smallest Missing Positive Integer",
        "description": "Given an unsorted integer array `nums`, find the smallest missing positive integer. Implement an algorithm that runs in `O(n)` time and uses constant extra space.",
        "example": "Example 1:\n\nInput: nums = [1,2,0]\nOutput: 3\nExplanation: The numbers in the range [1,2] are all in the array.\n\nExample 2:\n\nInput: nums = [3,4,-1,1]\nOutput: 2\nExplanation: 1 is in the array but 2 is missing.\n\nExample 3:\n\nInput: nums = [7,8,9,11,12]\nOutput: 1\nExplanation: The smallest positive integer 1 is missing.",
        "level": "Medium",
        "tags": [
            "Array",
            "Sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    0
                ],
                [
                    3,
                    4,
                    -1,
                    1
                ],
                [
                    7,
                    8,
                    9,
                    11,
                    12
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    2,
                    3,
                    4,
                    5
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    -1,
                    -2,
                    -3
                ],
                [
                    0
                ],
                [
                    -1
                ],
                [
                    1
                ],
                [
                    2
                ],
                [
                    3
                ],
                [
                    4
                ],
                [
                    5
                ],
                [
                    6
                ],
                [
                    7
                ],
                [
                    8
                ],
                [
                    9
                ],
                [
                    10
                ]
            ],
            "outputs": [
                3,
                2,
                1,
                6,
                6,
                1,
                1,
                1,
                1,
                1,
                2,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1
            ]
        },
        "sample_code": {
            "c++": "int firstMissingPositive(vector<int>& nums) {\n    int n = nums.size();\n    for(int i = 0; i < n; ++i)\n        while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])\n            swap(nums[i], nums[nums[i] - 1]);\n\n    for(int i = 0; i < n; ++i)\n        if(nums[i] != i + 1)\n            return i + 1;\n    return n + 1;\n}\n",
            "java": "public int firstMissingPositive(int[] nums) {\n    int n = nums.length;\n    for(int i = 0; i < n; i++) {\n        while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {\n            int temp = nums[i];\n            nums[i] = nums[temp - 1];\n            nums[temp - 1] = temp;\n        }\n    }\n\n    for(int i = 0; i < n; i++) {\n        if(nums[i] != i + 1) {\n            return i + 1;\n        }\n    }\n    return n + 1;\n}\n",
            "python": "def firstMissingPositive(nums):\n    n = len(nums)\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    return n + 1\n",
            "javascript": "function firstMissingPositive(nums) {\n    let n = nums.length;\n    for(let i = 0; i < n; i++) {\n        while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] !== nums[i]) {\n            let temp = nums[i];\n            nums[i] = nums[temp - 1];\n            nums[temp - 1] = temp;\n        }\n    }\n\n    for(let i = 0; i < n; i++) {\n        if(nums[i] !== i + 1) {\n            return i + 1;\n        }\n    }\n    return n + 1;\n}\n",
            "explanation": "In this algorithm, the elements are swapped with the values at their correct index if they are positive, in range, and not equal to the value already at that index. After the first loop, the array will have correct values at correct indices where possible (1-based), so we just need to find the index `i` where `nums[i] != i+1`. If not found, return the next positive integer `n + 1`. The loop has O(n) complexity, because each time at least one element gets placed at its correct position, so we need a max of n iterations on average."
        },
        "structure": {
            "c++": "int firstMissingPositive(vector<int>& nums) \n    // Your code here\n}\n",
            "java": "public int firstMissingPositive(int[] nums) \n    // Your code here\n}\n",
            "python": "def firstMissingPositive(nums):\n    # Your code here\n\n",
            "javascript": "function firstMissingPositive(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint firstMissingPositive(vector<int>& nums) {\n    int n = nums.size();\n    for(int i = 0; i < n; ++i)\n        while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])\n            swap(nums[i], nums[nums[i] - 1]);\n\n    for(int i = 0; i < n; ++i)\n        if(nums[i] != i + 1)\n            return i + 1;\n    return n + 1;\n}\n\nint main() {\n    vector<int> nums = $args;\n    int result = firstMissingPositive(nums);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int firstMissingPositive(int[] nums) {\n    int n = nums.length;\n    for(int i = 0; i < n; i++) {\n        while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {\n            int temp = nums[i];\n            nums[i] = nums[temp - 1];\n            nums[temp - 1] = temp;\n        }\n    }\n\n    for(int i = 0; i < n; i++) {\n        if(nums[i] != i + 1) {\n            return i + 1;\n        }\n    }\n    return n + 1;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = firstMissingPositive(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = firstMissingPositive(nums);\n    console.log(result);\n}"
        }
    },
    "42": {
        "title": "Trapping Rain Water",
        "description": "Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.",
        "example": "Example:\n\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.",
        "level": "Medium",
        "tags": [
            "array",
            "two pointers",
            "stack"
        ],
        "test_cases": {
            "inputs": [
                [
                    0,
                    1,
                    0,
                    2,
                    1,
                    0,
                    1,
                    3,
                    2,
                    1,
                    2,
                    1
                ],
                [
                    4,
                    2,
                    0,
                    3,
                    2,
                    5
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    3,
                    1,
                    2,
                    1,
                    3
                ],
                [
                    2,
                    1,
                    2,
                    1,
                    2
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    0,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    1,
                    2,
                    1
                ],
                [
                    2,
                    1,
                    2,
                    1,
                    2
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    3,
                    3,
                    3,
                    3,
                    3
                ],
                [
                    4,
                    4,
                    4,
                    4,
                    4
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1,
                    2,
                    3,
                    4,
                    5
                ]
            ],
            "outputs": [
                6,
                9,
                0,
                0,
                0,
                4,
                1,
                0,
                1,
                0,
                1,
                1,
                1,
                1,
                0,
                0,
                0,
                0,
                16,
                16
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nint trap(vector<int>& height) {\n    int n = height.size();\n    int left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\n\n    while (left < right) {\n        if (height[left] <= height[right]) {\n            maxLeft = max(maxLeft, height[left]);\n            water += maxLeft - height[left];\n            left++;\n        } else {\n            maxRight = max(maxRight, height[right]);\n            water += maxRight - height[right];\n            right--;\n        }\n    }\n\n    return water;\n}\n",
            "java": "public int trap(int[] height) {\n    int n = height.length, left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\n\n    while (left < right) {\n        if (height[left] <= height[right]) {\n            maxLeft = Math.max(maxLeft, height[left]);\n            water += maxLeft - height[left];\n            left++;\n        } else {\n            maxRight = Math.max(maxRight, height[right]);\n            water += maxRight - height[right];\n            right--;\n        }\n    }\n\n    return water;\n}\n",
            "python": "def trap(height):\n    n = len(height)\n    left, right, max_left, max_right, water = 0, n - 1, 0, 0, 0\n\n    while left < right:\n        if height[left] <= height[right]:\n            max_left = max(max_left, height[left])\n            water += max_left - height[left]\n            left += 1\n        else:\n            max_right = max(max_right, height[right])\n            water += max_right - height[right]\n            right -= 1\n\n    return water\n",
            "javascript": "function trap(height) {\n    const n = height.length;\n    let left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\n\n    while (left < right) {\n        if (height[left] <= height[right]) {\n            maxLeft = Math.max(maxLeft, height[left]);\n            water += maxLeft - height[left];\n            left++;\n        } else {\n            maxRight = Math.max(maxRight, height[right]);\n            water += maxRight - height[right];\n            right--;\n        }\n    }\n\n    return water;\n}\n",
            "explanation": "The algorithm uses a two-pointer approach, initializing left and right pointers to the beginning and end of the elevation map, respectively. It also initializes two variables `maxLeft` and `maxRight` to keep track of the maximum heights on the left and right of the pointers, as well as a variable `water` to store the trapped water.\n\nThe algorithm iterates through the elevation map until the left pointer is less than the right pointer. In each iteration, it compares the values at both pointers to determine which side is shorter. If the value at the left pointer is less than or equal to the value at the right pointer, it means water can be trapped on the left side up to the height of the shorter bar. The algorithm updates `maxLeft` with the maximum height on the left side and then adds the trapped water (which is the difference between the maximum height and the current height) to the `water` variable. The left pointer is then incremented. If the value at the right pointer is smaller, the same logic is applied to the right side and the right pointer is decremented.\n\nThis process is repeated until the left pointer is no longer less than the right pointer, at which point the total trapped water has been calculated and the `water` variable is returned. This algorithm has a time complexity of O(n) and a space complexity of O(1) as it only uses constant extra space."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nint trap(vector<int>& height) \n    // Your code here\n}\n",
            "java": "public int trap(int[] height) \n    // Your code here\n}\n",
            "python": "def trap(height):\n    # Your code here\n\n",
            "javascript": "function trap(height) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nint main() {\n    vector<int> height = $args;\n    int result = trap(height);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int trap(int[] height) {\n    int n = height.length, left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\n\n    while (left < right) {\n        if (height[left] <= height[right]) {\n            maxLeft = Math.max(maxLeft, height[left]);\n            water += maxLeft - height[left];\n            left++;\n        } else {\n            maxRight = Math.max(maxRight, height[right]);\n            water += maxRight - height[right];\n            right--;\n        }\n    }\n\n    return water;\n}",
            "python": "if __name__ == \"__main__\":\n    height = $args\n    result = trap(height)\n    print(result)",
            "javascript": "function main() {\n    const height = $args;\n    const result = trap(height);\n    console.log(result);\n}"
        }
    },
    "44": {
        "title": "Wildcard Pattern Matching",
        "description": "Given an input string (`s`) and a pattern (`p`), implement wildcard pattern matching with support for `'?'` and `'*'` where:\n\n*   `'?'` Matches any single character.\n*   `'*'` Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the **entire** input string (not partial).",
        "example": "Example:\n\n**Input:** s =  \"aa \", p =  \"a \"\n**Output:** false\n**Explanation:**  \"a \" does not match the entire string  \"aa \".",
        "level": "Medium",
        "tags": [
            "string",
            "pattern matching",
            "wildcard"
        ],
        "test_cases": {
            "inputs": [
                [
                    "aa ",
                    "a "
                ],
                [
                    "aa ",
                    "* "
                ],
                [
                    "cb ",
                    "?a "
                ],
                [
                    "abc ",
                    "a*c "
                ],
                [
                    "abc ",
                    "a?c "
                ],
                [
                    "abc ",
                    "a?*c "
                ],
                [
                    "abc ",
                    "a?*d "
                ],
                [
                    "abc ",
                    "a?* "
                ],
                [
                    "abc ",
                    "a?*? "
                ],
                [
                    "abc ",
                    "a?*?* "
                ],
                [
                    "abc ",
                    "a?*?*? "
                ],
                [
                    "abc ",
                    "a?*?*?* "
                ],
                [
                    "abc ",
                    "a?*?*?*? "
                ],
                [
                    "abc ",
                    "a?*?*?*?* "
                ],
                [
                    "abc ",
                    "a?*?*?*?*? "
                ],
                [
                    "abc ",
                    "a?*?*?*?*?* "
                ],
                [
                    "abc ",
                    "a?*?*?*?*?*? "
                ],
                [
                    "abc ",
                    "a?*?*?*?*?*?* "
                ],
                [
                    "abc ",
                    "a?*?*?*?*?*?*? "
                ],
                [
                    "abc ",
                    "a?*?*?*?*?*?*?* "
                ],
                [
                    "abc ",
                    "a?*?*?*?*?*?*?*? "
                ],
                [
                    "abc ",
                    "a?*?*?*?*?*?*?*?* "
                ],
                [
                    "abc ",
                    "a?*?*?*?*?*?*?*?*? "
                ]
            ],
            "outputs": [
                false,
                true,
                false,
                true,
                true,
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "bool isMatch(const std::string& s, const std::string& p) {\n    int m = s.size(), n = p.size();\n    int i = 0, j = 0, asterisk = -1, match;\n    while (i < m) {\n        if (j < n && (s[i] == p[j] || p[j] == '?')) {\n            i++; j++;\n        } else if (j < n && p[j] == '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk >= 0) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p[j] == '*') j++;\n    return j == n;\n}\n",
            "java": "public boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    int i = 0, j = 0, asterisk = -1, match = 0;\n    while (i < m) {\n        if (j < n && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')) {\n            i++; j++;\n        } else if (j < n && p.charAt(j) == '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk != -1) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p.charAt(j) == '*') j++;\n    return j == n;\n}\n",
            "python": "def is_match(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    i = j = 0\n    match = asterisk = -1\n    while i < m:\n        if j < n and (s[i] == p[j] or p[j] == '?'):\n            i, j = i + 1, j + 1\n        elif j < n and p[j] == '*':\n            match, asterisk = i, j\n            j += 1\n        elif asterisk >= 0:\n            i, j = match + 1, asterisk + 1\n            match += 1\n        else:\n            return False\n    while j < n and p[j] == '*':\n        j += 1\n    return j == n\n",
            "javascript": "function isMatch(s, p) {\n    let m = s.length,\n        n = p.length;\n    let i = 0,\n        j = 0,\n        asterisk = -1,\n        match = 0;\n    while (i < m) {\n        if (j < n && (s[i] === p[j] || p[j] === '?')) {\n            i++;\n            j++;\n        } else if (j < n && p[j] === '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk >= 0) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p[j] === '*') j++;\n    return j === n;\n}\n",
            "explanation": "- Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.\n- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.\n  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.\n  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.\n  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.\n  - If none of the above conditions are met, return `false` as the input string and pattern don't match.\n- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.\n- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`."
        },
        "structure": {
            "c++": "bool isMatch(const std::string& s, const std::string& p) \n    // Your code here\n}\n",
            "java": "public boolean isMatch(String s, String p) \n    // Your code here\n}\n",
            "python": "def is_match(s: str, p: str) -> bool:\n    # Your code here\n\n",
            "javascript": "function isMatch(s, p) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <string>\n\nbool isMatch(const std::string& s, const std::string& p) {\n    int m = s.size(), n = p.size();\n    int i = 0, j = 0, asterisk = -1, match;\n    while (i < m) {\n        if (j < n && (s[i] == p[j] || p[j] == '?')) {\n            i++; j++;\n        } else if (j < n && p[j] == '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk >= 0) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p[j] == '*') j++;\n    return j == n;\n}\n\nint main() {\n    std::string s = $args;\n    std::string p = $args;\n    bool result = isMatch(s, p);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "java": "public boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    int i = 0, j = 0, asterisk = -1, match = 0;\n    while (i < m) {\n        if (j < n && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')) {\n            i++; j++;\n        } else if (j < n && p.charAt(j) == '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk != -1) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p.charAt(j) == '*') j++;\n    return j == n;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    s = inputs[0]\n    p = inputs[1]\n    result = is_match(s, p)\n    print(result)",
            "javascript": "function main() {\n    const s = $args[0];\n    const p = $args[1];\n    const result = isMatch(s, p);\n    console.log(result);\n}"
        }
    },
    "46": {
        "title": "Permutations of Distinct Integers",
        "description": "Given an array `nums` of distinct integers, return all the possible permutations. You can return the answer in any order.",
        "example": "Example 1:\n\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\nExample 2:\n\nInput: nums = [0,1]\nOutput: [[0,1],[1,0]]\n\nExample 3:\n\nInput: nums = [1]\nOutput: [[1]]",
        "level": "Medium",
        "tags": [
            "Array",
            "Permutations"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3
                ],
                [
                    0,
                    1
                ],
                [
                    1
                ],
                [
                    4,
                    5,
                    6,
                    7
                ],
                [
                    -1,
                    0,
                    1
                ],
                [
                    10,
                    20,
                    30
                ],
                [
                    2,
                    4,
                    6,
                    8
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5
                ],
                [
                    3,
                    2,
                    1
                ],
                [
                    100,
                    200,
                    300
                ]
            ],
            "outputs": [
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        1,
                        3,
                        2
                    ],
                    [
                        2,
                        1,
                        3
                    ],
                    [
                        2,
                        3,
                        1
                    ],
                    [
                        3,
                        1,
                        2
                    ],
                    [
                        3,
                        2,
                        1
                    ]
                ],
                [
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        0
                    ]
                ],
                [
                    [
                        1
                    ]
                ],
                [
                    [
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        4,
                        5,
                        7,
                        6
                    ],
                    [
                        4,
                        6,
                        5,
                        7
                    ],
                    [
                        4,
                        6,
                        7,
                        5
                    ],
                    [
                        4,
                        7,
                        5,
                        6
                    ],
                    [
                        4,
                        7,
                        6,
                        5
                    ],
                    [
                        5,
                        4,
                        6,
                        7
                    ],
                    [
                        5,
                        4,
                        7,
                        6
                    ],
                    [
                        5,
                        6,
                        4,
                        7
                    ],
                    [
                        5,
                        6,
                        7,
                        4
                    ],
                    [
                        5,
                        7,
                        4,
                        6
                    ],
                    [
                        5,
                        7,
                        6,
                        4
                    ],
                    [
                        6,
                        4,
                        5,
                        7
                    ],
                    [
                        6,
                        4,
                        7,
                        5
                    ],
                    [
                        6,
                        5,
                        4,
                        7
                    ],
                    [
                        6,
                        5,
                        7,
                        4
                    ],
                    [
                        6,
                        7,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        5,
                        4
                    ],
                    [
                        7,
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        4,
                        6,
                        5
                    ],
                    [
                        7,
                        5,
                        4,
                        6
                    ],
                    [
                        7,
                        5,
                        6,
                        4
                    ],
                    [
                        7,
                        6,
                        4,
                        5
                    ],
                    [
                        7,
                        6,
                        5,
                        4
                    ]
                ],
                [
                    [
                        -1,
                        0,
                        1
                    ],
                    [
                        -1,
                        1,
                        0
                    ],
                    [
                        0,
                        -1,
                        1
                    ],
                    [
                        0,
                        1,
                        -1
                    ],
                    [
                        1,
                        -1,
                        0
                    ],
                    [
                        1,
                        0,
                        -1
                    ]
                ],
                [
                    [
                        10,
                        20,
                        30
                    ],
                    [
                        10,
                        30,
                        20
                    ],
                    [
                        20,
                        10,
                        30
                    ],
                    [
                        20,
                        30,
                        10
                    ],
                    [
                        30,
                        10,
                        20
                    ],
                    [
                        30,
                        20,
                        10
                    ]
                ],
                [
                    [
                        2,
                        4,
                        6,
                        8
                    ],
                    [
                        2,
                        4,
                        8,
                        6
                    ],
                    [
                        2,
                        6,
                        4,
                        8
                    ],
                    [
                        2,
                        6,
                        8,
                        4
                    ],
                    [
                        2,
                        8,
                        4,
                        6
                    ],
                    [
                        2,
                        8,
                        6,
                        4
                    ],
                    [
                        4,
                        2,
                        6,
                        8
                    ],
                    [
                        4,
                        2,
                        8,
                        6
                    ],
                    [
                        4,
                        6,
                        2,
                        8
                    ],
                    [
                        4,
                        6,
                        8,
                        2
                    ],
                    [
                        4,
                        8,
                        2,
                        6
                    ],
                    [
                        4,
                        8,
                        6,
                        2
                    ],
                    [
                        6,
                        2,
                        4,
                        8
                    ],
                    [
                        6,
                        2,
                        8,
                        4
                    ],
                    [
                        6,
                        4,
                        2,
                        8
                    ],
                    [
                        6,
                        4,
                        8,
                        2
                    ],
                    [
                        6,
                        8,
                        2,
                        4
                    ],
                    [
                        6,
                        8,
                        4,
                        2
                    ],
                    [
                        8,
                        2,
                        4,
                        6
                    ],
                    [
                        8,
                        2,
                        6,
                        4
                    ],
                    [
                        8,
                        4,
                        2,
                        6
                    ],
                    [
                        8,
                        4,
                        6,
                        2
                    ],
                    [
                        8,
                        6,
                        2,
                        4
                    ],
                    [
                        8,
                        6,
                        4,
                        2
                    ]
                ],
                [
                    [
                        9,
                        8,
                        7,
                        6,
                        5
                    ],
                    [
                        9,
                        8,
                        7,
                        5,
                        6
                    ],
                    [
                        9,
                        8,
                        6,
                        7,
                        5
                    ],
                    [
                        9,
                        8,
                        6,
                        5,
                        7
                    ],
                    [
                        9,
                        8,
                        5,
                        7,
                        6
                    ],
                    [
                        9,
                        8,
                        5,
                        6,
                        7
                    ],
                    [
                        9,
                        7,
                        8,
                        6,
                        5
                    ],
                    [
                        9,
                        7,
                        8,
                        5,
                        6
                    ],
                    [
                        9,
                        7,
                        6,
                        8,
                        5
                    ],
                    [
                        9,
                        7,
                        6,
                        5,
                        8
                    ],
                    [
                        9,
                        7,
                        5,
                        8,
                        6
                    ],
                    [
                        9,
                        7,
                        5,
                        6,
                        8
                    ],
                    [
                        9,
                        6,
                        8,
                        7,
                        5
                    ],
                    [
                        9,
                        6,
                        8,
                        5,
                        7
                    ],
                    [
                        9,
                        6,
                        7,
                        8,
                        5
                    ],
                    [
                        9,
                        6,
                        7,
                        5,
                        8
                    ],
                    [
                        9,
                        6,
                        5,
                        8,
                        7
                    ],
                    [
                        9,
                        6,
                        5,
                        7,
                        8
                    ],
                    [
                        9,
                        5,
                        8,
                        7,
                        6
                    ],
                    [
                        9,
                        5,
                        8,
                        6,
                        7
                    ],
                    [
                        9,
                        5,
                        7,
                        8,
                        6
                    ],
                    [
                        9,
                        5,
                        7,
                        6,
                        8
                    ],
                    [
                        9,
                        5,
                        6,
                        8,
                        7
                    ],
                    [
                        9,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        8,
                        9,
                        7,
                        6,
                        5
                    ],
                    [
                        8,
                        9,
                        7,
                        5,
                        6
                    ],
                    [
                        8,
                        9,
                        6,
                        7,
                        5
                    ],
                    [
                        8,
                        9,
                        6,
                        5,
                        7
                    ],
                    [
                        8,
                        9,
                        5,
                        7,
                        6
                    ],
                    [
                        8,
                        9,
                        5,
                        6,
                        7
                    ],
                    [
                        8,
                        7,
                        9,
                        6,
                        5
                    ],
                    [
                        8,
                        7,
                        9,
                        5,
                        6
                    ],
                    [
                        8,
                        7,
                        6,
                        9,
                        5
                    ],
                    [
                        8,
                        7,
                        6,
                        5,
                        9
                    ],
                    [
                        8,
                        7,
                        5,
                        9,
                        6
                    ],
                    [
                        8,
                        7,
                        5,
                        6,
                        9
                    ],
                    [
                        8,
                        6,
                        9,
                        7,
                        5
                    ],
                    [
                        8,
                        6,
                        9,
                        5,
                        7
                    ],
                    [
                        8,
                        6,
                        7,
                        9,
                        5
                    ],
                    [
                        8,
                        6,
                        7,
                        5,
                        9
                    ],
                    [
                        8,
                        6,
                        5,
                        9,
                        7
                    ],
                    [
                        8,
                        6,
                        5,
                        7,
                        9
                    ],
                    [
                        8,
                        5,
                        9,
                        7,
                        6
                    ],
                    [
                        8,
                        5,
                        9,
                        6,
                        7
                    ],
                    [
                        8,
                        5,
                        7,
                        9,
                        6
                    ],
                    [
                        8,
                        5,
                        7,
                        6,
                        9
                    ],
                    [
                        8,
                        5,
                        6,
                        9,
                        7
                    ],
                    [
                        8,
                        5,
                        6,
                        7,
                        9
                    ],
                    [
                        7,
                        9,
                        8,
                        6,
                        5
                    ],
                    [
                        7,
                        9,
                        8,
                        5,
                        6
                    ],
                    [
                        7,
                        9,
                        6,
                        8,
                        5
                    ],
                    [
                        7,
                        9,
                        6,
                        5,
                        8
                    ],
                    [
                        7,
                        9,
                        5,
                        8,
                        6
                    ],
                    [
                        7,
                        9,
                        5,
                        6,
                        8
                    ],
                    [
                        7,
                        8,
                        9,
                        6,
                        5
                    ],
                    [
                        7,
                        8,
                        9,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        6,
                        9,
                        5
                    ],
                    [
                        7,
                        8,
                        6,
                        5,
                        9
                    ],
                    [
                        7,
                        8,
                        5,
                        9,
                        6
                    ],
                    [
                        7,
                        8,
                        5,
                        6,
                        9
                    ],
                    [
                        7,
                        6,
                        9,
                        8,
                        5
                    ],
                    [
                        7,
                        6,
                        9,
                        5,
                        8
                    ],
                    [
                        7,
                        6,
                        8,
                        9,
                        5
                    ],
                    [
                        7,
                        6,
                        8,
                        5,
                        9
                    ],
                    [
                        7,
                        6,
                        5,
                        9,
                        8
                    ],
                    [
                        7,
                        6,
                        5,
                        8,
                        9
                    ],
                    [
                        7,
                        5,
                        9,
                        8,
                        6
                    ],
                    [
                        7,
                        5,
                        9,
                        6,
                        8
                    ],
                    [
                        7,
                        5,
                        8,
                        9,
                        6
                    ],
                    [
                        7,
                        5,
                        8,
                        6,
                        9
                    ],
                    [
                        7,
                        5,
                        6,
                        9,
                        8
                    ],
                    [
                        7,
                        5,
                        6,
                        8,
                        9
                    ],
                    [
                        6,
                        9,
                        8,
                        7,
                        5
                    ],
                    [
                        6,
                        9,
                        8,
                        5,
                        7
                    ],
                    [
                        6,
                        9,
                        7,
                        8,
                        5
                    ],
                    [
                        6,
                        9,
                        7,
                        5,
                        8
                    ],
                    [
                        6,
                        9,
                        5,
                        8,
                        7
                    ],
                    [
                        6,
                        9,
                        5,
                        7,
                        8
                    ],
                    [
                        6,
                        8,
                        9,
                        7,
                        5
                    ],
                    [
                        6,
                        8,
                        9,
                        5,
                        7
                    ],
                    [
                        6,
                        8,
                        7,
                        9,
                        5
                    ],
                    [
                        6,
                        8,
                        7,
                        5,
                        9
                    ],
                    [
                        6,
                        8,
                        5,
                        9,
                        7
                    ],
                    [
                        6,
                        8,
                        5,
                        7,
                        9
                    ],
                    [
                        6,
                        7,
                        9,
                        8,
                        5
                    ],
                    [
                        6,
                        7,
                        9,
                        5,
                        8
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        5,
                        9
                    ],
                    [
                        6,
                        7,
                        5,
                        9,
                        8
                    ],
                    [
                        6,
                        7,
                        5,
                        8,
                        9
                    ],
                    [
                        6,
                        5,
                        9,
                        8,
                        7
                    ],
                    [
                        6,
                        5,
                        9,
                        7,
                        8
                    ],
                    [
                        6,
                        5,
                        8,
                        9,
                        7
                    ],
                    [
                        6,
                        5,
                        8,
                        7,
                        9
                    ],
                    [
                        6,
                        5,
                        7,
                        9,
                        8
                    ],
                    [
                        6,
                        5,
                        7,
                        8,
                        9
                    ],
                    [
                        5,
                        9,
                        8,
                        7,
                        6
                    ],
                    [
                        5,
                        9,
                        8,
                        6,
                        7
                    ],
                    [
                        5,
                        9,
                        7,
                        8,
                        6
                    ],
                    [
                        5,
                        9,
                        7,
                        6,
                        8
                    ],
                    [
                        5,
                        9,
                        6,
                        8,
                        7
                    ],
                    [
                        5,
                        9,
                        6,
                        7,
                        8
                    ],
                    [
                        5,
                        8,
                        9,
                        7,
                        6
                    ],
                    [
                        5,
                        8,
                        9,
                        6,
                        7
                    ],
                    [
                        5,
                        8,
                        7,
                        9,
                        6
                    ],
                    [
                        5,
                        8,
                        7,
                        6,
                        9
                    ],
                    [
                        5,
                        8,
                        6,
                        9,
                        7
                    ],
                    [
                        5,
                        8,
                        6,
                        7,
                        9
                    ],
                    [
                        5,
                        7,
                        9,
                        8,
                        6
                    ],
                    [
                        5,
                        7,
                        9,
                        6,
                        8
                    ],
                    [
                        5,
                        7,
                        8,
                        9,
                        6
                    ],
                    [
                        5,
                        7,
                        8,
                        6,
                        9
                    ],
                    [
                        5,
                        7,
                        6,
                        9,
                        8
                    ],
                    [
                        5,
                        7,
                        6,
                        8,
                        9
                    ],
                    [
                        5,
                        6,
                        9,
                        8,
                        7
                    ],
                    [
                        5,
                        6,
                        9,
                        7,
                        8
                    ],
                    [
                        5,
                        6,
                        8,
                        9,
                        7
                    ],
                    [
                        5,
                        6,
                        8,
                        7,
                        9
                    ],
                    [
                        5,
                        6,
                        7,
                        9,
                        8
                    ],
                    [
                        5,
                        6,
                        7,
                        8,
                        9
                    ]
                ],
                [
                    [
                        3,
                        2,
                        1
                    ],
                    [
                        3,
                        1,
                        2
                    ],
                    [
                        2,
                        3,
                        1
                    ],
                    [
                        2,
                        1,
                        3
                    ],
                    [
                        1,
                        3,
                        2
                    ],
                    [
                        1,
                        2,
                        3
                    ]
                ],
                [
                    [
                        100,
                        200,
                        300
                    ],
                    [
                        100,
                        300,
                        200
                    ],
                    [
                        200,
                        100,
                        300
                    ],
                    [
                        200,
                        300,
                        100
                    ],
                    [
                        300,
                        100,
                        200
                    ],
                    [
                        300,
                        200,
                        100
                    ]
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nvoid helper(std::vector<int>& nums, int index, std::vector<std::vector<int>>& results) {\n    if (index == nums.size() - 1) {\n        results.push_back(nums);\n        return;\n    }\n\n    for (int i = index; i < nums.size(); i++) {\n        std::swap(nums[index], nums[i]);\n        helper(nums, index + 1, results);\n        std::swap(nums[index], nums[i]);\n    }\n}\n\nstd::vector<std::vector<int>> permute(std::vector<int>& nums) {\n    std::vector<std::vector<int>> results;\n    helper(nums, 0, results);\n    return results;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> permute(int[] nums) {\n    List<List<Integer>> results = new ArrayList<>();\n    helper(nums, 0, results);\n    return results;\n}\n\nprivate void helper(int[] nums, int index, List<List<Integer>> results) {\n    if (index == nums.length - 1) {\n        List<Integer> tempList = new ArrayList<>();\n        for (int n : nums) {\n            tempList.add(n);\n        }\n        results.add(tempList);\n        return;\n    }\n\n    for (int i = index; i < nums.length; i++) {\n        swap(nums, index, i);\n        helper(nums, index + 1, results);\n        swap(nums, index, i);\n    }\n}\n\nprivate void swap(int[] nums, int i, int j) {\n    int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n}\n",
            "python": "from typing import List\n\ndef permute(nums: List[int]) -> List[List[int]]:\n    def helper(index):\n        if index == len(nums) - 1:\n            results.append(nums[:])\n            return\n\n        for i in range(index, len(nums)):\n            nums[index], nums[i] = nums[i], nums[index]\n            helper(index + 1)\n            nums[index], nums[i] = nums[i], nums[index]\n\n    results = []\n    helper(0)\n    return results\n",
            "javascript": "function permute(nums) {\n  const results = [];\n  helper(nums, 0, results);\n  return results;\n}\n\nfunction helper(nums, index, results) {\n  if (index === nums.length - 1) {\n    results.push(nums.slice());\n    return;\n  }\n\n  for (let i = index; i < nums.length; i++) {\n    [nums[index], nums[i]] = [nums[i], nums[index]];\n    helper(nums, index + 1, results);\n    [nums[index], nums[i]] = [nums[i], nums[index]];\n  }\n}\n",
            "explanation": "The algorithm uses backtracking to generate all possible permutations. It works by swapping the elements in the input array in a recursive manner.\n\n1. The base case is when the index reaches the last element of the array; at this point, we append the current configuration to the \"results\" list.\n2. For each index, we iterate from `index` to the end of the array, performing the following steps:\n    a. Swap `index` and `i` elements.\n    b. Recursively call the helper function with `index + 1`.\n    c. Swap the elements back to their original positions.\n\nThis will generate all possible permutations, as it swaps elements in different positions while maintaining the original order in the input array. The termination condition for the recursion is the base case when we reach the end of the array. The complexity of this algorithm is O(N!), as there are N! permutations of an array of N elements."
        },
        "structure": {
            "c++": "#include <vector>\n\nvoid helper(std::vector<int>& nums, int index, std::vector<std::vector<int>>& results) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> permute(int[] nums) \n    // Your code here\n}\n",
            "python": "from typing import List\n    # Your code here\n\n",
            "javascript": "function permute(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nvoid helper(std::vector<int>& nums, int index, std::vector<std::vector<int>>& results) {\n    if (index == nums.size() - 1) {\n        results.push_back(nums);\n        return;\n    }\n\n    for (int i = index; i < nums.size(); i++) {\n        std::swap(nums[index], nums[i]);\n        helper(nums, index + 1, results);\n        std::swap(nums[index], nums[i]);\n    }\n}\n\nstd::vector<std::vector<int>> permute(std::vector<int>& nums) {\n    std::vector<std::vector<int>> results;\n    helper(nums, 0, results);\n    return results;\n}\n\nint main() {\n    std::vector<int> nums = $args;\n    std::vector<std::vector<int>> result = permute(nums);\n    for (const auto& res : result) {\n        for (const auto& num : res) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}",
            "java": "public List<List<Integer>> permute(int[] nums) {\n    List<List<Integer>> results = new ArrayList<>();\n    helper(nums, 0, results);\n    return results;\n}\n\nprivate void helper(int[] nums, int index, List<List<Integer>> results) {\n    if (index == nums.length - 1) {\n        List<Integer> tempList = new ArrayList<>();\n        for (int n : nums) {\n            tempList.add(n);\n        }\n        results.add(tempList);\n        return;\n    }\n\n    for (int i = index; i < nums.length; i++) {\n        swap(nums, index, i);\n        helper(nums, index + 1, results);\n        swap(nums, index, i);\n    }\n}\n\nprivate void swap(int[] nums, int i, int j) {\n    int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = permute(nums)\n    print(result)",
            "javascript": "function main() {\n  const nums = $args;\n  const results = permute(nums);\n  console.log(results);\n}"
        }
    },
    "47": {
        "title": "Unique Permutations with Duplicates",
        "description": "Given a collection of numbers, `nums`, that might contain duplicates, return all possible unique permutations in any order.",
        "example": "Example 1:\n\nInput: nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n\nExample 2:\n\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "level": "Medium",
        "tags": [
            "Array",
            "Backtracking"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    1,
                    2
                ],
                [
                    1,
                    2,
                    3
                ],
                [
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2
                ],
                [
                    1,
                    2,
                    2
                ],
                [
                    1,
                    1,
                    2,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4
                ],
                [
                    1,
                    1,
                    2,
                    2,
                    3,
                    3
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8
                ],
                [
                    1,
                    1,
                    2,
                    2,
                    3,
                    3,
                    4,
                    4,
                    5,
                    5
                ]
            ],
            "outputs": [
                [
                    [
                        1,
                        1,
                        2
                    ],
                    [
                        1,
                        2,
                        1
                    ],
                    [
                        2,
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        1,
                        3,
                        2
                    ],
                    [
                        2,
                        1,
                        3
                    ],
                    [
                        2,
                        3,
                        1
                    ],
                    [
                        3,
                        1,
                        2
                    ],
                    [
                        3,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1,
                        1
                    ]
                ],
                [
                    [
                        2,
                        2,
                        2
                    ]
                ],
                [
                    [
                        1,
                        2,
                        2
                    ],
                    [
                        2,
                        1,
                        2
                    ],
                    [
                        2,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1,
                        2,
                        2
                    ],
                    [
                        1,
                        2,
                        1,
                        2
                    ],
                    [
                        1,
                        2,
                        2,
                        1
                    ],
                    [
                        2,
                        1,
                        1,
                        2
                    ],
                    [
                        2,
                        1,
                        2,
                        1
                    ],
                    [
                        2,
                        2,
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        1,
                        2,
                        4,
                        3
                    ],
                    [
                        1,
                        3,
                        2,
                        4
                    ],
                    [
                        1,
                        3,
                        4,
                        2
                    ],
                    [
                        1,
                        4,
                        2,
                        3
                    ],
                    [
                        1,
                        4,
                        3,
                        2
                    ],
                    [
                        2,
                        1,
                        3,
                        4
                    ],
                    [
                        2,
                        1,
                        4,
                        3
                    ],
                    [
                        2,
                        3,
                        1,
                        4
                    ],
                    [
                        2,
                        3,
                        4,
                        1
                    ],
                    [
                        2,
                        4,
                        1,
                        3
                    ],
                    [
                        2,
                        4,
                        3,
                        1
                    ],
                    [
                        3,
                        1,
                        2,
                        4
                    ],
                    [
                        3,
                        1,
                        4,
                        2
                    ],
                    [
                        3,
                        2,
                        1,
                        4
                    ],
                    [
                        3,
                        2,
                        4,
                        1
                    ],
                    [
                        3,
                        4,
                        1,
                        2
                    ],
                    [
                        3,
                        4,
                        2,
                        1
                    ],
                    [
                        4,
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        1,
                        3,
                        2
                    ],
                    [
                        4,
                        2,
                        1,
                        3
                    ],
                    [
                        4,
                        2,
                        3,
                        1
                    ],
                    [
                        4,
                        3,
                        1,
                        2
                    ],
                    [
                        4,
                        3,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        8,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        7,
                        6,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        7,
                        8,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        8,
                        6,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        8,
                        7,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6,
                        5,
                        7,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6,
                        5,
                        8,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6,
                        7,
                        5,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6,
                        7,
                        8,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6,
                        8,
                        5,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6,
                        8,
                        7,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        7,
                        5,
                        6,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        7,
                        5,
                        8,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        7,
                        6,
                        5,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        7,
                        6,
                        8,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        7,
                        8,
                        5,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        7,
                        8,
                        6,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        8,
                        5,
                        6,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        8,
                        5,
                        7,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        8,
                        6,
                        5,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        8,
                        6,
                        7,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        8,
                        7,
                        5,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        8,
                        7,
                        6,
                        5
                    ]
                ],
                [
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ]
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\n\nvoid backtrack(std::vector<std::vector<int>>& result, std::vector<int>& nums, int start) {\n    if (start == nums.size()) {\n        result.push_back(nums);\n        return;\n    }\n    for (int i = start; i < nums.size(); i++) {\n        if (i > start && nums[i] == nums[start]) continue;\n        std::swap(nums[start], nums[i]);\n        backtrack(result, nums, start + 1);\n        std::swap(nums[start], nums[i]);\n    }\n}\n\nstd::vector<std::vector<int>> permuteUnique(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    std::vector<std::vector<int>> result;\n    backtrack(result, nums, 0);\n    return result;\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<List<Integer>> permuteUnique(int[] nums) {\n    Arrays.sort(nums);\n    List<List<Integer>> result = new ArrayList<>();\n    boolean[] visited = new boolean[nums.length];\n    backtrack(result, new ArrayList<>(), nums, visited);\n    return result;\n}\n\nprivate void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums, boolean[] visited) {\n    if (tempList.size() == nums.length) {\n        result.add(new ArrayList<>(tempList));\n    } else {\n        for (int i = 0; i < nums.length; i++) {\n            if (visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])) continue;\n            visited[i] = true;\n            tempList.add(nums[i]);\n            backtrack(result, tempList, nums, visited);\n            tempList.remove(tempList.size() - 1);\n            visited[i] = false;\n        }\n    }\n}\n\n",
            "python": "from typing import List\n\ndef permuteUnique(nums: List[int]) -> List[List[int]]:\n    def backtrack(start):\n        if start == len(nums):\n            result.append(nums[:])\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[start]:\n                continue\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start]\n\n    nums.sort()\n    result = []\n    backtrack(0)\n    return result\n\n",
            "javascript": "function permuteUnique(nums) {\n    nums.sort((a, b) => a - b);\n    const result = [];\n    const visited = new Array(nums.length).fill(false);\n\n    function backtrack(tempList) {\n        if (tempList.length === nums.length) {\n            result.push([...tempList]);\n            return;\n        }\n        for (let i = 0; i < nums.length; i++) {\n            if (visited[i] || (i > 0 && nums[i] === nums[i - 1] && !visited[i - 1])) continue;\n            visited[i] = true;\n            tempList.push(nums[i]);\n            backtrack(tempList);\n            tempList.pop();\n            visited[i] = false;\n        }\n    }\n\n    backtrack([]);\n    return result;\n}\n\n",
            "explanation": "We use backtracking to generate permutations. Firstly, we sort the `nums` array to make sure that duplicate numbers are located together. Then, for each recursive backtracking call, we swap the elements in the range `[start, len(nums) - 1]` with `nums[start]`, ignoring already-visited elements by using a `visited` array.\n\nWe also skip any element that is equal to the current `start` element to avoid duplicates. After generating a valid permutation by iterating through all indices, we append the current permutation to the result array. When backtracking, we maintain the original order of elements before moving to the next level.\n\nThe time complexity of this approach is O(n! * n) since there are n! available permutations and each permutation requires O(n) time to build the solution. The space complexity is O(n) to store the `visited` array and temporary lists."
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\n\nvoid backtrack(std::vector<std::vector<int>>& result, std::vector<int>& nums, int start) \n    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<List<Integer>> permuteUnique(int[] nums) \n    // Your code here\n}\n\n",
            "python": "from typing import List\n    # Your code here\n\n",
            "javascript": "function permuteUnique(nums) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nvoid backtrack(std::vector<std::vector<int>>& result, std::vector<int>& nums, int start) {\n    if (start == nums.size()) {\n        result.push_back(nums);\n        return;\n    }\n    for (int i = start; i < nums.size(); i++) {\n        if (i > start && nums[i] == nums[start]) continue;\n        std::swap(nums[start], nums[i]);\n        backtrack(result, nums, start + 1);\n        std::swap(nums[start], nums[i]);\n    }\n}\n\nstd::vector<std::vector<int>> permuteUnique(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    std::vector<std::vector<int>> result;\n    backtrack(result, nums, 0);\n    return result;\n}\n\nint main() {\n    std::vector<int> nums = $args;\n    std::vector<std::vector<int>> result = permuteUnique(nums);\n    for (const auto& res : result) {\n        for (const auto& num : res) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}",
            "java": "public List<List<Integer>> permuteUnique(int[] nums) {\n    Arrays.sort(nums);\n    List<List<Integer>> result = new ArrayList<>();\n    boolean[] visited = new boolean[nums.length];\n    backtrack(result, new ArrayList<>(), nums, visited);\n    return result;\n}\n\nprivate void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums, boolean[] visited) {\n    if (tempList.size() == nums.length) {\n        result.add(new ArrayList<>(tempList));\n    } else {\n        for (int i = 0; i < nums.length; i++) {\n            if (visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])) continue;\n            visited[i] = true;\n            tempList.add(nums[i]);\n            backtrack(result, tempList, nums, visited);\n            tempList.remove(tempList.size() - 1);\n            visited[i] = false;\n        }\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = permuteUnique(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    nums.sort((a, b) => a - b);\n    const result = [];\n    const visited = new Array(nums.length).fill(false);\n\n    function backtrack(tempList) {\n        if (tempList.length === nums.length) {\n            result.push([...tempList]);\n            return;\n        }\n        for (let i = 0; i < nums.length; i++) {\n            if (visited[i] || (i > 0 && nums[i] === nums[i - 1] && !visited[i - 1])) continue;\n            visited[i] = true;\n            tempList.push(nums[i]);\n            backtrack(tempList);\n            tempList.pop();\n            visited[i] = false;\n        }\n    }\n\n    backtrack([]);\n    console.log(result);\n}\n"
        }
    },
    "48": {
        "title": "Rotate Image",
        "description": "You are given an `n x n` 2D `matrix` representing an image. Rotate the image by **90** degrees (clockwise) in-place.",
        "example": "Example:\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\n\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
        "level": "Medium",
        "tags": [
            "array",
            "matrix",
            "in-place"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9
                    ]
                ],
                [
                    [
                        5,
                        1,
                        9,
                        11
                    ],
                    [
                        2,
                        4,
                        8,
                        10
                    ],
                    [
                        13,
                        3,
                        6,
                        7
                    ],
                    [
                        15,
                        14,
                        12,
                        16
                    ]
                ],
                [
                    [
                        1
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16,
                        17,
                        18
                    ],
                    [
                        19,
                        20,
                        21,
                        22,
                        23,
                        24
                    ],
                    [
                        25,
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35,
                        36
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14
                    ],
                    [
                        15,
                        16,
                        17,
                        18,
                        19,
                        20,
                        21
                    ],
                    [
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28
                    ],
                    [
                        29,
                        30,
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40,
                        41,
                        42
                    ],
                    [
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15,
                        16
                    ],
                    [
                        17,
                        18,
                        19,
                        20,
                        21,
                        22,
                        23,
                        24
                    ],
                    [
                        25,
                        26,
                        27,
                        28,
                        29,
                        30,
                        31,
                        32
                    ],
                    [
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48
                    ],
                    [
                        49,
                        50,
                        51,
                        52,
                        53,
                        54,
                        55,
                        56
                    ],
                    [
                        57,
                        58,
                        59,
                        60,
                        61,
                        62,
                        63,
                        64
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        10,
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18
                    ],
                    [
                        19,
                        20,
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27
                    ],
                    [
                        28,
                        29,
                        30,
                        31,
                        32,
                        33,
                        34,
                        35,
                        36
                    ],
                    [
                        37,
                        38,
                        39,
                        40,
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50,
                        51,
                        52,
                        53,
                        54
                    ],
                    [
                        55,
                        56,
                        57,
                        58,
                        59,
                        60,
                        61,
                        62,
                        63
                    ],
                    [
                        64,
                        65,
                        66,
                        67,
                        68,
                        69,
                        70,
                        71,
                        72
                    ],
                    [
                        73,
                        74,
                        75,
                        76,
                        77,
                        78,
                        79,
                        80,
                        81
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65,
                        66,
                        67,
                        68,
                        69,
                        70
                    ],
                    [
                        71,
                        72,
                        73,
                        74,
                        75,
                        76,
                        77,
                        78,
                        79,
                        80
                    ],
                    [
                        81,
                        82,
                        83,
                        84,
                        85,
                        86,
                        87,
                        88,
                        89,
                        90
                    ],
                    [
                        91,
                        92,
                        93,
                        94,
                        95,
                        96,
                        97,
                        98,
                        99,
                        100
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20,
                        21,
                        22
                    ],
                    [
                        23,
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        30,
                        31,
                        32,
                        33
                    ],
                    [
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40,
                        41,
                        42,
                        43,
                        44
                    ],
                    [
                        45,
                        46,
                        47,
                        48,
                        49,
                        50,
                        51,
                        52,
                        53,
                        54,
                        55
                    ],
                    [
                        56,
                        57,
                        58,
                        59,
                        60,
                        61,
                        62,
                        63,
                        64,
                        65,
                        66
                    ],
                    [
                        67,
                        68,
                        69,
                        70,
                        71,
                        72,
                        73,
                        74,
                        75,
                        76,
                        77
                    ],
                    [
                        78,
                        79,
                        80,
                        81,
                        82,
                        83,
                        84,
                        85,
                        86,
                        87,
                        88
                    ],
                    [
                        89,
                        90,
                        91,
                        92,
                        93,
                        94,
                        95,
                        96,
                        97,
                        98,
                        99
                    ],
                    [
                        100,
                        101,
                        102,
                        103,
                        104,
                        105,
                        106,
                        107,
                        108,
                        109,
                        110
                    ],
                    [
                        111,
                        112,
                        113,
                        114,
                        115,
                        116,
                        117,
                        118,
                        119,
                        120,
                        121
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20,
                        21,
                        22,
                        23,
                        24
                    ],
                    [
                        25,
                        26,
                        27,
                        28,
                        29,
                        30,
                        31,
                        32,
                        33,
                        34,
                        35,
                        36
                    ],
                    [
                        37,
                        38,
                        39,
                        40,
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48
                    ],
                    [
                        49,
                        50,
                        51,
                        52,
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65,
                        66,
                        67,
                        68,
                        69,
                        70,
                        71,
                        72
                    ],
                    [
                        73,
                        74,
                        75,
                        76,
                        77,
                        78,
                        79,
                        80,
                        81,
                        82,
                        83,
                        84
                    ],
                    [
                        85,
                        86,
                        87,
                        88,
                        89,
                        90,
                        91,
                        92,
                        93,
                        94,
                        95,
                        96
                    ],
                    [
                        97,
                        98,
                        99,
                        100,
                        101,
                        102,
                        103,
                        104,
                        105,
                        106,
                        107,
                        108
                    ],
                    [
                        109,
                        110,
                        111,
                        112,
                        113,
                        114,
                        115,
                        116,
                        117,
                        118,
                        119,
                        120
                    ],
                    [
                        121,
                        122,
                        123,
                        124,
                        125,
                        126,
                        127,
                        128,
                        129,
                        130,
                        131,
                        132
                    ],
                    [
                        133,
                        134,
                        135,
                        136,
                        137,
                        138,
                        139,
                        140,
                        141,
                        142,
                        143,
                        144
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13
                    ],
                    [
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20,
                        21,
                        22,
                        23,
                        24,
                        25,
                        26
                    ],
                    [
                        27,
                        28,
                        29,
                        30,
                        31,
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39
                    ],
                    [
                        40,
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50,
                        51,
                        52
                    ],
                    [
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60,
                        61,
                        62,
                        63,
                        64,
                        65
                    ],
                    [
                        66,
                        67,
                        68,
                        69,
                        70,
                        71,
                        72,
                        73,
                        74,
                        75,
                        76,
                        77,
                        78
                    ],
                    [
                        79,
                        80,
                        81,
                        82,
                        83,
                        84,
                        85,
                        86,
                        87,
                        88,
                        89,
                        90,
                        91
                    ],
                    [
                        92,
                        93,
                        94,
                        95,
                        96,
                        97,
                        98,
                        99,
                        100,
                        101,
                        102,
                        103,
                        104
                    ],
                    [
                        105,
                        106,
                        107,
                        108,
                        109,
                        110,
                        111,
                        112,
                        113,
                        114,
                        115,
                        116,
                        117
                    ],
                    [
                        118,
                        119,
                        120,
                        121,
                        122,
                        123,
                        124,
                        125,
                        126,
                        127,
                        128,
                        129,
                        130
                    ],
                    [
                        131,
                        132,
                        133,
                        134,
                        135,
                        136,
                        137,
                        138,
                        139,
                        140,
                        141,
                        142,
                        143
                    ],
                    [
                        144,
                        145,
                        146,
                        147,
                        148,
                        149,
                        150,
                        151,
                        152,
                        153,
                        154,
                        155,
                        156
                    ],
                    [
                        157,
                        158,
                        159,
                        160,
                        161,
                        162,
                        163,
                        164,
                        165,
                        166,
                        167,
                        168,
                        169
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14
                    ],
                    [
                        15,
                        16,
                        17,
                        18,
                        19,
                        20,
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28
                    ],
                    [
                        29,
                        30,
                        31,
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40,
                        41,
                        42
                    ],
                    [
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50,
                        51,
                        52,
                        53,
                        54,
                        55,
                        56
                    ],
                    [
                        57,
                        58,
                        59,
                        60,
                        61,
                        62,
                        63,
                        64,
                        65,
                        66,
                        67,
                        68,
                        69,
                        70
                    ],
                    [
                        71,
                        72,
                        73,
                        74,
                        75,
                        76,
                        77,
                        78,
                        79,
                        80,
                        81,
                        82,
                        83,
                        84
                    ],
                    [
                        85,
                        86,
                        87,
                        88,
                        89,
                        90,
                        91,
                        92,
                        93,
                        94,
                        95,
                        96,
                        97,
                        98
                    ],
                    [
                        99,
                        100,
                        101,
                        102,
                        103,
                        104,
                        105,
                        106,
                        107,
                        108,
                        109,
                        110,
                        111,
                        112
                    ],
                    [
                        113,
                        114,
                        115,
                        116,
                        117,
                        118,
                        119,
                        120,
                        121,
                        122,
                        123,
                        124,
                        125,
                        126
                    ],
                    [
                        127,
                        128,
                        129,
                        130,
                        131,
                        132,
                        133,
                        134,
                        135,
                        136,
                        137,
                        138,
                        139,
                        140
                    ],
                    [
                        141,
                        142,
                        143,
                        144,
                        145,
                        146,
                        147,
                        148,
                        149,
                        150,
                        151,
                        152,
                        153,
                        154
                    ],
                    [
                        155,
                        156,
                        157,
                        158,
                        159,
                        160,
                        161,
                        162,
                        163,
                        164,
                        165,
                        166,
                        167,
                        168,
                        169
                    ],
                    [
                        170,
                        171,
                        172,
                        173,
                        174,
                        175,
                        176,
                        177,
                        178,
                        179,
                        180,
                        181,
                        182,
                        183
                    ],
                    [
                        184,
                        185,
                        186,
                        187,
                        188,
                        189,
                        190,
                        191,
                        192,
                        193,
                        194,
                        195,
                        196,
                        197
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20,
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40,
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50,
                        51,
                        52,
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65,
                        66,
                        67,
                        68,
                        69,
                        70,
                        71,
                        72,
                        73,
                        74,
                        75
                    ],
                    [
                        76,
                        77,
                        78,
                        79,
                        80,
                        81,
                        82,
                        83,
                        84,
                        85,
                        86,
                        87,
                        88,
                        89,
                        90
                    ],
                    [
                        91,
                        92,
                        93,
                        94,
                        95,
                        96,
                        97,
                        98,
                        99,
                        100,
                        101,
                        102,
                        103,
                        104,
                        105
                    ],
                    [
                        106,
                        107,
                        108,
                        109,
                        110,
                        111,
                        112,
                        113,
                        114,
                        115,
                        116,
                        117,
                        118,
                        119,
                        120
                    ],
                    [
                        121,
                        122,
                        123,
                        124,
                        125,
                        126,
                        127,
                        128,
                        129,
                        130,
                        131,
                        132,
                        133,
                        134,
                        135
                    ],
                    [
                        136,
                        137,
                        138,
                        139,
                        140,
                        141,
                        142,
                        143,
                        144,
                        145,
                        146,
                        147,
                        148,
                        149,
                        150
                    ],
                    [
                        151,
                        152,
                        153,
                        154,
                        155,
                        156,
                        157,
                        158,
                        159,
                        160,
                        161,
                        162,
                        163,
                        164,
                        165
                    ],
                    [
                        166,
                        167,
                        168,
                        169,
                        170,
                        171,
                        172,
                        173,
                        174,
                        175,
                        176,
                        177,
                        178,
                        179,
                        180
                    ],
                    [
                        181,
                        182,
                        183,
                        184,
                        185,
                        186,
                        187,
                        188,
                        189,
                        190,
                        191,
                        192,
                        193,
                        194,
                        195
                    ],
                    [
                        196,
                        197,
                        198,
                        199,
                        200,
                        201,
                        202,
                        203,
                        204,
                        205,
                        206,
                        207,
                        208,
                        209,
                        210
                    ],
                    [
                        211,
                        212,
                        213,
                        214,
                        215,
                        216,
                        217,
                        218,
                        219,
                        220,
                        221,
                        222,
                        223,
                        224,
                        225
                    ]
                ]
            ],
            "outputs": [
                "[[7,4,1],[8,5,2],[9,6,3]]",
                "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
                "[[1]]",
                "[[3,1],[4,2]]",
                "[[13,9,5,1],[14,10,6,2],[15,11,7,3],[16,12,8,4]]",
                "[[21,16,11,6,1],[22,17,12,7,2],[23,18,13,8,3],[24,19,14,9,4],[25,20,15,10,5]]",
                "[[31,25,19,13,7,1],[32,26,20,14,8,2],[33,27,21,15,9,3],[34,28,22,16,10,4],[35,29,23,17,11,5],[36,30,24,18,12,6]]",
                "[[49,42,35,28,21,14,7],[50,43,36,29,22,15,8],[51,44,37,30,23,16,9],[52,45,38,31,24,17,10],[53,46,39,32,25,18,11],[54,47,40,33,26,19,12],[55,48,41,34,27,20,13]]",
                "[[64,57,50,43,36,29,22,15],[65,58,51,44,37,30,23,16],[66,59,52,45,38,31,24,17],[67,60,53,46,39,32,25,18],[68,61,54,47,40,33,26,19],[69,62,55,48,41,34,27,20],[70,63,56,49,42,35,28,21],[71,64,57,50,43,36,29,22]]",
                "[[81,73,65,57,49,41,33,25,17,9],[82,74,66,58,50,42,34,26,18,10],[83,75,67,59,51,43,35,27,19,11],[84,76,68,60,52,44,36,28,20,12],[85,77,69,61,53,45,37,29,21,13],[86,78,70,62,54,46,38,30,22,14],[87,79,71,63,55,47,39,31,23,15],[88,80,72,64,56,48,40,32,24,16]]",
                "[[100,91,82,73,64,55,46,37,28,19,10],[101,92,83,74,65,56,47,38,29,20,11],[102,93,84,75,66,57,48,39,30,21,12],[103,94,85,76,67,58,49,40,31,22,13],[104,95,86,77,68,59,50,41,32,23,14],[105,96,87,78,69,60,51,42,33,24,15],[106,97,88,79,70,61,52,43,34,25,16],[107,98,89,80,71,62,53,44,35,26,17],[108,99,90,81,72,63,54,45,36,27,18],[109,100,91,82,73,64,55,46,37,28,19]]",
                "[[121,111,101,91,81,71,61,51,41,31,21,11],[122,112,102,92,82,72,62,52,42,32,22,12],[123,113,103,93,83,73,63,53,43,33,23,13],[124,114,104,94,84,74,64,54,44,34,24,14],[125,115,105,95,85,75,65,55,45,35,25,15],[126,116,106,96,86,76,66,56,46,36,26,16],[127,117,107,97,87,77,67,57,47,37,27,17],[128,118,108,98,88,78,68,58,48,38,28,18],[129,119,109,99,89,79,69,59,49,39,29,19],[130,120,110,100,90,80,70,60,50,40,30,20],[131,121,111,101,91,81,71,61,51,41,31,21]]",
                "[[144,133,122,111,100,89,78,67,56,45,34,23,12],[145,134,123,112,101,90,79,68,57,46,35,24,13],[146,135,124,113,102,91,80,69,58,47,36,25,14],[147,136,125,114,103,92,81,70,59,48,37,26,15],[148,137,126,115,104,93,82,71,60,49,38,27,16],[149,138,127,116,105,94,83,72,61,50,39,28,17],[150,139,128,117,106,95,84,73,62,51,40,29,18],[151,140,129,118,107,96,85,74,63,52,41,30,19],[152,141,130,119,108,97,86,75,64,53,42,31,20],[153,142,131,120,109,98,87,76,65,54,43,32,21],[154,143,132,121,110,99,88,77,66,55,44,33,22],[155,144,133,122,111,100,89,78,67,56,45,34,23]]",
                "[[169,157,145,133,121,109,97,85,73,61,49,37,25,13],[170,158,146,134,122,110,98,86,74,62,50,38,26,14],[171,159,147,135,123,111,99,87,75,63,51,39,27,15],[172,160,148,136,124,112,100,88,76,64,52,40,28,16],[173,161,149,137,125,113,101,89,77,65,53,41,29,17],[174,162,150,138,126,114,102,90,78,66,54,42,30,18],[175,163,151,139,127,115,103,91,79,67,55,43,31,19],[176,164,152,140,128,116,104,92,80,68,56,44,32,20],[177,165,153,141,129,117,105,93,81,69,57,45,33,21],[178,166,154,142,130,118,106,94,82,70,58,46,34,22],[179,167,155,143,131,119,107,95,83,71,59,47,35,23],[180,168,156,144,132,120,108,96,84,72,60,48,36,24],[181,169,157,145,133,121,109,97,85,73,61,49,37,25]]",
                "[[196,183,170,157,144,131,118,105,92,79,66,53,40,27,14],[197,184,171,158,145,132,119,106,93,80,67,54,41,28,15],[198,185,172,159,146,133,120,107,94,81,68,55,42,29,16],[199,186,173,160,147,134,121,108,95,82,69,56,43,30,17],[200,187,174,161,148,135,122,109,96,83,70,57,44,31,18],[201,188,175,162,149,136,123,110,97,84,71,58,45,32,19],[202,189,176,163,150,137,124,111,98,85,72,59,46,33,20],[203,190,177,164,151,138,125,112,99,86,73,60,47,34,21],[204,191,178,165,152,139,126,113,100,87,74,61,48,35,22],[205,192,179,166,153,140,127,114,101,88,75,62,49,36,23],[206,193,180,167,154,141,128,115,102,89,76,63,50,37,24],[207,194,181,168,155,142,129,116,103,90,77,64,51,38,25],[208,195,182,169,156,143,130,117,104,91,78,65,52,39,26]]",
                "[[225,210,195,180,165,150,135,120,105,90,75,60,45,30,15],[226,211,196,181,166,151,136,121,106,91,76,61,46,31,16],[227,212,197,182,167,152,137,122,107,92,77,62,47,32,17],[228,213,198,183,168,153,138,123,108,93,78,63,48,33,18],[229,214,199,184,169,154,139,124,109,94,79,64,49,34,19],[230,215,200,185,170,155,140,125,110,95,80,65,50,35,20],[231,216,201,186,171,156,141,126,111,96,81,66,51,36,21],[232,217,202,187,172,157,142,127,112,97,82,67,52,37,22],[233,218,203,188,173,158,143,128,113,98,83,68,53,38,23],[234,219,204,189,174,159,144,129,114,99,84,69,54,39,24],[235,220,205,190,175,160,145,130,115,100,85,70,55,40,25],[236,221,206,191,176,161,146,131,116,101,86,71,56,41,26],[237,222,207,192,177,162,147,132,117,102,87,72,57,42,27],[238,223,208,193,178,163,148,133,118,103,88,73,58,43,28],[239,224,209,194,179,164,149,134,119,104,89,74,59,44,29]]"
            ]
        },
        "sample_code": {
            "c++": "void rotate(vector<vector<int>>& matrix) {\n    int n = matrix.size();\n    for (int i = 0; i < n / 2; i++) {\n        for (int j = i; j < n - i - 1; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[n - j - 1][i];\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n            matrix[j][n - i - 1] = temp;\n        }\n    }\n}\n",
            "java": "public void rotate(int[][] matrix) {\n    int n = matrix.length;\n    for (int i = 0; i < n / 2; i++) {\n        for (int j = i; j < n - i - 1; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[n - j - 1][i];\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n            matrix[j][n - i - 1] = temp;\n        }\n    }\n}\n",
            "python": "def rotate(matrix):\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n",
            "javascript": "function rotate(matrix) {\n    let n = matrix.length;\n    for (let i = 0; i < Math.floor(n / 2); i++) {\n        for (let j = i; j < n - i - 1; j++) {\n            let temp = matrix[i][j];\n            matrix[i][j] = matrix[n - j - 1][i];\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n            matrix[j][n - i - 1] = temp;\n        }\n    }\n}\n",
            "explanation": "The algorithm iterates over each layer of the matrix gradually working inwards. For each element in the current layer, it performs a 4-way swap (moving elements from left -> top, bottom -> left, right -> bottom, and top -> right). This moves each element in the layer to its new position after rotation without using any additional memory. The algorithm proceeds with this strategy until it reaches the center of the matrix, ensuring that all elements are correctly rotated."
        },
        "structure": {
            "c++": "void rotate(vector<vector<int>>& matrix) \n    // Your code here\n}\n",
            "java": "public void rotate(int[][] matrix) \n    // Your code here\n}\n",
            "python": "def rotate(matrix):\n    # Your code here\n\n",
            "javascript": "function rotate(matrix) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid rotate(vector<vector<int>>& matrix) {\n    int n = matrix.size();\n    for (int i = 0; i < n / 2; i++) {\n        for (int j = i; j < n - i - 1; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[n - j - 1][i];\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n            matrix[j][n - i - 1] = temp;\n        }\n    }\n}\n\nint main() {\n    vector<vector<int>> matrix = $args;\n    rotate(matrix);\n    for (int i = 0; i < matrix.size(); i++) {\n        for (int j = 0; j < matrix[i].size(); j++) {\n            cout << matrix[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
            "java": "public void rotate(int[][] matrix) {\n    int n = matrix.length;\n    for (int i = 0; i < n / 2; i++) {\n        for (int j = i; j < n - i - 1; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[n - j - 1][i];\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n            matrix[j][n - i - 1] = temp;\n        }\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    matrix = $args\n    rotate(matrix)\n    print(matrix)",
            "javascript": "function rotate(matrix) {\n    let n = matrix.length;\n    for (let i = 0; i < Math.floor(n / 2); i++) {\n        for (let j = i; j < n - i - 1; j++) {\n            let temp = matrix[i][j];\n            matrix[i][j] = matrix[n - j - 1][i];\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n            matrix[j][n - i - 1] = temp;\n        }\n    }\n}\n\nconst matrix = $args;\nrotate(matrix);\nconsole.log(matrix);"
        }
    },
    "49": {
        "title": "Group Anagrams",
        "description": "Given an array of strings `strs`, group the anagrams together. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Return the groups of anagrams in any order.",
        "example": "Example:\n\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\nInput: strs = [\"\"]\nOutput: [[\"\"]]\n\nInput: strs = [\"a\"]\nOutput: [[\"a\"]]",
        "level": "Easy",
        "tags": [
            "Array",
            "String",
            "Sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    "eat",
                    "tea",
                    "tan",
                    "ate",
                    "nat",
                    "bat"
                ],
                [
                    ""
                ],
                [
                    "a"
                ],
                [
                    "abc",
                    "cba",
                    "bca",
                    "def",
                    "fed",
                    "edf"
                ],
                [
                    "cat",
                    "dog",
                    "tac",
                    "god",
                    "act"
                ],
                [
                    "abcd",
                    "dcba",
                    "efgh",
                    "hgfe",
                    "ijkl",
                    "lkji"
                ],
                [
                    "abcd",
                    "dcba",
                    "efgh",
                    "hgfe",
                    "ijkl",
                    "lkji",
                    "mnop",
                    "opnm"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz",
                    "cba",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz",
                    "cba",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx",
                    "bac",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz",
                    "cba",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx",
                    "bac",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx",
                    "cab",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz",
                    "cba",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx",
                    "bac",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx",
                    "cab",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz",
                    "bca",
                    "edf",
                    "hgi",
                    "klj",
                    "mon",
                    "prq",
                    "sut",
                    "xwv",
                    "yzz"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz",
                    "cba",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx",
                    "bac",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx",
                    "cab",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz",
                    "bca",
                    "edf",
                    "hgi",
                    "klj",
                    "mon",
                    "prq",
                    "sut",
                    "xwv",
                    "yzz",
                    "acb",
                    "dfe",
                    "gih",
                    "jlk",
                    "omn",
                    "qpr",
                    "tsu",
                    "vxw",
                    "zyx"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz",
                    "cba",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx",
                    "bac",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx",
                    "cab",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz",
                    "bca",
                    "edf",
                    "hgi",
                    "klj",
                    "mon",
                    "prq",
                    "sut",
                    "xwv",
                    "yzz",
                    "acb",
                    "dfe",
                    "gih",
                    "jlk",
                    "omn",
                    "qpr",
                    "tsu",
                    "vxw",
                    "zyx",
                    "bca",
                    "edf",
                    "hgi",
                    "klj",
                    "mon",
                    "prq",
                    "sut",
                    "xwv",
                    "yzz"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz",
                    "cba",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx",
                    "bac",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx",
                    "cab",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz",
                    "bca",
                    "edf",
                    "hgi",
                    "klj",
                    "mon",
                    "prq",
                    "sut",
                    "xwv",
                    "yzz",
                    "acb",
                    "dfe",
                    "gih",
                    "jlk",
                    "omn",
                    "qpr",
                    "tsu",
                    "vxw",
                    "zyx",
                    "bca",
                    "edf",
                    "hgi",
                    "klj",
                    "mon",
                    "prq",
                    "sut",
                    "xwv",
                    "yzz",
                    "cba",
                    "fed",
                    "ihg",
                    "klj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx"
                ]
            ],
            "outputs": [
                "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
                "[[\"\"]]",
                "[[\"a\"]]",
                "[[\"abc\",\"cba\",\"bca\"],[\"def\",\"fed\",\"edf\"]]",
                "[[\"cat\",\"tac\",\"act\"],[\"dog\",\"god\"]]",
                "[[\"abcd\",\"dcba\"],[\"efgh\",\"hgfe\"],[\"ijkl\",\"lkji\"]]",
                "[[\"abcd\",\"dcba\"],[\"efgh\",\"hgfe\"],[\"ijkl\",\"lkji\"],[\"mnop\",\"opnm\"]]",
                "[[\"abc\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"]]",
                "[[\"abc\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"],[\"cba\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"]]",
                "[[\"abc\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"],[\"cba\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"],[\"bac\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"]]",
                "[[\"abc\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"],[\"cba\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"],[\"bac\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"],[\"cab\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"]]",
                "[[\"abc\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"],[\"cba\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"],[\"bac\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"],[\"cab\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"],[\"bca\"],[\"edf\"],[\"hgi\"],[\"klj\"],[\"mon\"],[\"prq\"],[\"sut\"],[\"xwv\"],[\"yzz\"]]",
                "[[\"abc\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"],[\"cba\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"],[\"bac\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"],[\"cab\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"],[\"bca\"],[\"edf\"],[\"hgi\"],[\"klj\"],[\"mon\"],[\"prq\"],[\"sut\"],[\"xwv\"],[\"yzz\"],[\"acb\"],[\"dfe\"],[\"gih\"],[\"jlk\"],[\"omn\"],[\"qpr\"],[\"tsu\"],[\"vxw\"],[\"zyx\"]]",
                "[[\"abc\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"],[\"cba\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"],[\"bac\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"],[\"cab\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"],[\"bca\"],[\"edf\"],[\"hgi\"],[\"klj\"],[\"mon\"],[\"prq\"],[\"sut\"],[\"xwv\"],[\"yzz\"],[\"acb\"],[\"dfe\"],[\"gih\"],[\"jlk\"],[\"omn\"],[\"qpr\"],[\"tsu\"],[\"vxw\"],[\"zyx\"],[\"bca\"],[\"edf\"],[\"hgi\"],[\"klj\"],[\"mon\"],[\"prq\"],[\"sut\"],[\"xwv\"],[\"yzz\"]]",
                "[[\"abc\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"],[\"cba\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"],[\"bac\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"],[\"cab\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"],[\"bca\"],[\"edf\"],[\"hgi\"],[\"klj\"],[\"mon\"],[\"prq\"],[\"sut\"],[\"xwv\"],[\"yzz\"],[\"acb\"],[\"dfe\"],[\"gih\"],[\"jlk\"],[\"omn\"],[\"qpr\"],[\"tsu\"],[\"vxw\"],[\"zyx\"],[\"bca\"],[\"edf\"],[\"hgi\"],[\"klj\"],[\"mon\"],[\"prq\"],[\"sut\"],[\"xwv\"],[\"yzz\"],[\"cba\"],[\"fed\"],[\"ihg\"],[\"klj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"]]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nstd::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) {\n    std::map<std::string, std::vector<std::string>> anagramMap;\n\n    for (std::string str : strs) {\n        std::string key = str;\n        std::sort(key.begin(), key.end());\n        anagramMap[key].push_back(str);\n    }\n\n    std::vector<std::vector<std::string>> result;\n    for (auto &entry : anagramMap) {\n        result.push_back(entry.second);\n    }\n\n    return result;\n}\n",
            "java": "import java.util.*;\n\npublic List<List<String>> groupAnagrams(String[] strs) {\n    Map<String, List<String>> anagramMap = new HashMap<>();\n\n    for (String str : strs) {\n        char[] keyChars = str.toCharArray();\n        Arrays.sort(keyChars);\n        String key = new String(keyChars);\n\n        anagramMap.putIfAbsent(key, new ArrayList<>());\n        anagramMap.get(key).add(str);\n    }\n\n    return new ArrayList<>(anagramMap.values());\n}\n",
            "python": "from collections import defaultdict\n\ndef group_anagrams(strs):\n    anagram_map = defaultdict(list)\n\n    for s in strs:\n        key = ''.join(sorted(s))\n        anagram_map[key].append(s)\n\n    return list(anagram_map.values())\n",
            "javascript": "function groupAnagrams(strs) {\n    const anagramMap = new Map();\n\n    for (const str of strs) {\n        const key = str.split('').sort().join('');\n\n        if (!anagramMap.has(key)) {\n            anagramMap.set(key, []);\n        }\n        anagramMap.get(key).push(str);\n    }\n\n    return Array.from(anagramMap.values());\n}\n",
            "explanation": "The algorithm iterates through the input array of strings. For each string, create a sorted version of the string as key, and store the original strings as values. Use a data structure like a map or dictionary to store the grouped anagrams in these key-value pairs. The keys will represent the different anagrams, while the values will be lists of the original strings that fit the anagram. Finally, extract the values (lists of anagrams) from the map or dictionary and return them. This works because anagrams will produce the same sorted strings as keys."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nstd::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) \n    // Your code here\n}\n",
            "java": "import java.util.*;\n\npublic List<List<String>> groupAnagrams(String[] strs) \n    // Your code here\n}\n",
            "python": "from collections import defaultdict\n    # Your code here\n\n",
            "javascript": "function groupAnagrams(strs) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nstd::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) {\n    std::map<std::string, std::vector<std::string>> anagramMap;\n\n    for (std::string str : strs) {\n        std::string key = str;\n        std::sort(key.begin(), key.end());\n        anagramMap[key].push_back(str);\n    }\n\n    std::vector<std::vector<std::string>> result;\n    for (auto &entry : anagramMap) {\n        result.push_back(entry.second);\n    }\n\n    return result;\n}\n\nint main() {\n    std::vector<std::string> strs = $args;\n    std::vector<std::vector<std::string>> result = groupAnagrams(strs);\n\n    for (const auto& group : result) {\n        for (const auto& str : group) {\n            std::cout << str << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}",
            "java": "public List<List<String>> groupAnagrams(String[] strs) {\n    Map<String, List<String>> anagramMap = new HashMap<>();\n\n    for (String str : strs) {\n        char[] keyChars = str.toCharArray();\n        Arrays.sort(keyChars);\n        String key = new String(keyChars);\n\n        anagramMap.putIfAbsent(key, new ArrayList<>());\n        anagramMap.get(key).add(str);\n    }\n\n    return new ArrayList<>(anagramMap.values());\n}",
            "python": "if __name__ == \"__main__\":\n    strs = $args\n    result = group_anagrams(strs)\n    print(result)",
            "javascript": "function main() {\n    const strs = $args;\n    const result = groupAnagrams(strs);\n    console.log(result);\n}"
        }
    },
    "50": {
        "title": "Power Function",
        "description": "Write a function `power(x, n)` that calculates `x` raised to the power `n` (i.e., `x^n`). Implement the function using the given description.",
        "example": "Example:\n\nInput: x = 2.00000, n = 10\nOutput: 1024.00000\n\nInput: x = 2.10000, n = 3\nOutput: 9.26100\n\nInput: x = 2.00000, n = -2\nOutput: 0.25000\nExplanation: 2^-2 = 1/2^2 = 1/4 = 0.25",
        "level": "Medium",
        "tags": [
            "math",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                [
                    2.0,
                    10
                ],
                [
                    2.1,
                    3
                ],
                [
                    2.0,
                    -2
                ],
                [
                    0.5,
                    0
                ],
                [
                    10.0,
                    5
                ],
                [
                    3.0,
                    4
                ],
                [
                    1.5,
                    7
                ],
                [
                    4.0,
                    -3
                ],
                [
                    0.0,
                    10
                ],
                [
                    1.0,
                    100
                ],
                [
                    -2.0,
                    5
                ],
                [
                    -3.0,
                    3
                ],
                [
                    -1.5,
                    6
                ],
                [
                    -4.0,
                    -2
                ],
                [
                    0.5,
                    -3
                ],
                [
                    1.0,
                    0
                ],
                [
                    2.0,
                    1
                ],
                [
                    3.0,
                    0
                ],
                [
                    4.0,
                    1
                ],
                [
                    5.0,
                    2
                ]
            ],
            "outputs": [
                1024.0,
                9.261,
                0.25,
                1.0,
                100000.0,
                81.0,
                133.875,
                -0.015625,
                0.0,
                1.0,
                -32.0,
                -27.0,
                64.5,
                0.0625,
                8.0,
                1.0,
                2.0,
                1.0,
                4.0,
                25.0
            ]
        },
        "sample_code": {
            "c++": "double myPow(double x, int n) {\n    if (n == 0) return 1;\n    if (n < 0) {\n        x = 1 / x;\n        n = -n;\n    }\n    double result = 1;\n    double currentProduct = x;\n    for (long long i = n; i; i /= 2) {\n        if ((i % 2) == 1) {\n            result = result * currentProduct;\n        }\n        currentProduct = currentProduct * currentProduct;\n    }\n    return result;\n}\n",
            "java": "double myPow(double x, int n) {\n    if (n == 0) return 1;\n    if (n < 0) {\n        x = 1 / x;\n        n = -n;\n    }\n    double result = 1;\n    double currentProduct = x;\n    for (long i = n; i > 0; i /= 2) {\n        if ((i % 2) == 1) {\n            result *= currentProduct;\n        }\n        currentProduct *= currentProduct;\n    }\n    return result;\n}\n",
            "python": "def myPow(x: float, n: int) -> float:\n    if n == 0:\n        return 1\n    if n < 0:\n        x = 1 / x\n        n = -n\n    result = 1\n    currentProduct = x\n    i = n\n    while i:\n        if i % 2 == 1:\n            result *= currentProduct\n        currentProduct *= currentProduct\n        i //= 2\n    return result\n",
            "javascript": "function myPow(x, n) {\n    if (n === 0) return 1;\n    if (n < 0) {\n        x = 1 / x;\n        n = -n;\n    }\n    let result = 1;\n    let currentProduct = x;\n    for (let i = n; i > 0; i = Math.floor(i / 2)) {\n        if (i % 2 === 1) {\n            result *= currentProduct;\n        }\n        currentProduct *= currentProduct;\n    }\n    return result;\n}\n",
            "explanation": "The algorithm uses the binary exponentiation technique, which is a faster method of calculating x^n compared to the naive approach. It relies on the process of repeatedly multiplying the current product by itself and updating it after each iteration. The loop iterates through the bits of the exponent n, from the least significant to the most significant. If the current bit of n is 1, the result is multiplied by the current product. At the end of the loop, the current product is updated by squaring it. This process continues until all bits of the exponent have been processed.\n\nThe time complexity of the algorithm is O(log(n)) because the loop iterates through the bits of n, and the number of bits in n is proportional to the logarithm of n. The space complexity is O(1), as the space used by the temporary variables does not depend on the size of n."
        },
        "structure": {
            "c++": "double myPow(double x, int n) \n    // Your code here\n}\n",
            "java": "double myPow(double x, int n) \n    // Your code here\n}\n",
            "python": "def myPow(x: float, n: int) -> float:\n    # Your code here\n\n",
            "javascript": "function myPow(x, n) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\ndouble myPow(double x, int n) {\n    if (n == 0) return 1;\n    if (n < 0) {\n        x = 1 / x;\n        n = -n;\n    }\n    double result = 1;\n    double currentProduct = x;\n    for (long long i = n; i; i /= 2) {\n        if ((i % 2) == 1) {\n            result = result * currentProduct;\n        }\n        currentProduct = currentProduct * currentProduct;\n    }\n    return result;\n}\n\nint main() {\n    double x = $args;\n    int n = $args;\n    double result = myPow(x, n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    double x = $args[0];\n    int n = $args[1];\n    double result = myPow(x, n);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    x = inputs[0]\n    n = inputs[1]\n    result = myPow(x, n)\n    print(result)",
            "javascript": "function main() {\n    const x = $args[0];\n    const n = $args[1];\n    const result = myPow(x, n);\n    console.log(result);\n}"
        }
    },
    "51": {
        "title": "N-Queens Puzzle",
        "description": "The N-Queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the N-Queens puzzle. Each solution contains a distinct board configuration of the N-Queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.",
        "example": "Example:\n\nInput: n = 4\nOutput: [['.Q..', '...Q', 'Q...', '..Q.'], ['..Q.', 'Q...', '...Q', '.Q..']]\nExplanation: There exist two distinct solutions to the 4-Queens puzzle as shown above.",
        "level": "Medium",
        "tags": [
            "backtracking",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                4,
                1,
                2,
                3,
                5
            ],
            "outputs": [
                [
                    [
                        ".Q..",
                        "...Q",
                        "Q...",
                        "..Q."
                    ],
                    [
                        "..Q.",
                        "Q...",
                        "...Q",
                        ".Q.."
                    ]
                ],
                [
                    [
                        "Q"
                    ]
                ],
                [],
                [],
                []
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n\nbool isSafe(const std::vector<std::string>& board, int row, int col, int n) {\n    for (int i = 0; i < col; ++i) {\n        if (board[row][i] == 'Q') return false;\n    }\n    for (int i = row, j = col; i >= 0 && j >= 0; --i, --j) {\n        if (board[i][j] == 'Q') return false;\n    }\n    for (int i = row, j = col; i < n && j >= 0; ++i, --j) {\n        if (board[i][j] == 'Q') return false;\n    }\n    return true;\n}\n\nvoid solve(std::vector<std::vector<std::string>>& result, std::vector<std::string>& board, int n, int col) {\n    if (col == n) {\n        result.push_back(board);\n        return;\n    }\n    for (int row = 0; row < n; ++row) {\n        if (isSafe(board, row, col, n)) {\n            board[row][col] = 'Q';\n            solve(result, board, n, col + 1);\n            board[row][col] = '.';\n        }\n    }\n}\n\nstd::vector<std::vector<std::string>> solveNQueens(int n) {\n    std::vector<std::vector<std::string>> result;\n    std::vector<std::string> board(n, std::string(n, '.'));\n    solve(result, board, n, 0);\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<String>> solveNQueens(int n) {\n    List<List<String>> result = new ArrayList<>();\n    solve(result, new ArrayList<>(), n, 0);\n    return result;\n}\n\nprivate void solve(List<List<String>> result, List<Integer> current, int n, int col) {\n    if (col == n) {\n        result.add(generateBoard(current, n));\n        return;\n    }\n    for (int row = 0; row < n; row++) {\n        if(isSafe(current, row, col)) {\n            current.add(row);\n            solve(result, current, n, col + 1);\n            current.remove(col);\n        }\n    }\n}\n\nprivate boolean isSafe(List<Integer> current, int row, int col) {\n    for (int i = 0; i < col; i++) {\n        int prevRow = current.get(i);\n        if (prevRow == row || (Math.abs(col - i) == Math.abs(row - prevRow))) {\n            return false;\n        }\n    }\n    return true;\n}\n\nprivate List<String> generateBoard(List<Integer> current, int n) {\n    List<String> board = new ArrayList<>();\n    for (int row : current) {\n        StringBuilder sb = new StringBuilder();\n        for (int col = 0; col < n; col++)\n            sb.append((col == row) ? \"Q\" : \".\");\n        board.add(sb.toString());\n    }\n    return board;\n}\n",
            "python": "def solveNQueens(n):\n    def isSafe(board, row, col):\n        for i in range(col):\n            if board[row][i] == 'Q': return False\n        i, j = row, col\n        while i >= 0 and j >= 0:\n            if board[i][j] == 'Q': return False\n            i, j = i - 1, j - 1\n        i, j = row, col\n        while i < n and j >= 0:\n            if board[i][j] == 'Q': return False\n            i, j = i + 1, j - 1\n        return True\n\n    def solve(result, board, n, col):\n        if col == n:\n            result.append(board.copy())\n            return\n        for row in range(n):\n            if isSafe(board, row, col):\n                board[row] = board[row][:col] + 'Q' + board[row][col + 1:]\n                solve(result, board, n, col + 1)\n                board[row] = board[row][:col] + '.' + board[row][col + 1:]\n\n    result, board = [], ['.' * n for _ in range(n)]\n    solve(result, board, n, 0)\n    return result\n",
            "javascript": "function solveNQueens(n) {\n  function isSafe(board, row, col) {\n    for (let i = 0; i < col; i++)\n      if (board[row][i] == 'Q') return false;\n    for (let i = row, j = col; i >= 0 && j >= 0; i--, j--)\n      if (board[i][j] == 'Q') return false;\n    for (let i = row, j = col; i < n && j >= 0; i++, j--)\n      if (board[i][j] == 'Q') return false;\n    return true;\n  }\n\n  function solve(result, board, n, col) {\n    if (col == n) {\n      result.push(board.map(row => row.join('')));\n      return;\n    }\n    for (let row = 0; row < n; row++) {\n      if (isSafe(board, row, col)) {\n        board[row][col] = 'Q';\n        solve(result, board, n, col + 1);\n        board[row][col] = '.';\n      }\n    }\n  }\n\n  const result = [];\n  const board = Array.from({ length: n }, () => Array(n).fill('.'));\n  solve(result, board, n, 0);\n  return result;\n}\n",
            "explanation": "The algorithm uses the backtracking approach to solve the N-Queens puzzle. The idea is to place queens one by one in different columns, starting from the leftmost column. When placing a queen, check if that position is safe from all previously placed queens in terms of the horizontal, diagonal, and anti-diagonal directions. If the selected position is safe, move on to the next column and try to place another queen there. If no safe positions are found in the current column, then go back to the previous column and move the queen to another safe position. Repeat this process until all queens are placed in a valid configuration or all possible arrangements have been tried. During the process, whenever we successfully place `n` queens on the board, add that configuration to our result list. Finally, return the list of all unique solutions found."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n\nbool isSafe(const std::vector<std::string>& board, int row, int col, int n) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<String>> solveNQueens(int n) \n    // Your code here\n}\n",
            "python": "def solveNQueens(n):\n    # Your code here\n\n",
            "javascript": "function solveNQueens(n) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "std::vector<std::vector<std::string>> solveNQueens(int n) {\n    std::vector<std::vector<std::string>> result;\n    std::vector<std::string> board(n, std::string(n, '.'));\n    solve(result, board, n, 0);\n    return result;\n}",
            "java": "public List<List<String>> solveNQueens(int n) {\n    List<List<String>> result = new ArrayList<>();\n    solve(result, new ArrayList<>(), n, 0);\n    return result;\n}\n\nprivate void solve(List<List<String>> result, List<Integer> current, int n, int col) {\n    if (col == n) {\n        result.add(generateBoard(current, n));\n        return;\n    }\n    for (int row = 0; row < n; row++) {\n        if(isSafe(current, row, col)) {\n            current.add(row);\n            solve(result, current, n, col + 1);\n            current.remove(col);\n        }\n    }\n}\n\nprivate boolean isSafe(List<Integer> current, int row, int col) {\n    for (int i = 0; i < col; i++) {\n        int prevRow = current.get(i);\n        if (prevRow == row || (Math.abs(col - i) == Math.abs(row - prevRow))) {\n            return false;\n        }\n    }\n    return true;\n}\n\nprivate List<String> generateBoard(List<Integer> current, int n) {\n    List<String> board = new ArrayList<>();\n    for (int row : current) {\n        StringBuilder sb = new StringBuilder();\n        for (int col = 0; col < n; col++)\n            sb.append((col == row) ? \"Q\" : \".\");\n        board.add(sb.toString());\n    }\n    return board;\n}",
            "javascript": "function solveNQueens(n) {\n  function isSafe(board, row, col) {\n    for (let i = 0; i < col; i++)\n      if (board[row][i] == 'Q') return false;\n    for (let i = row, j = col; i >= 0 && j >= 0; i--, j--)\n      if (board[i][j] == 'Q') return false;\n    for (let i = row, j = col; i < n && j >= 0; i++, j--)\n      if (board[i][j] == 'Q') return false;\n    return true;\n  }\n\n  function solve(result, board, n, col) {\n    if (col == n) {\n      result.push(board.map(row => row.join('')));\n      return;\n    }\n    for (let row = 0; row < n; row++) {\n      if (isSafe(board, row, col)) {\n        board[row][col] = 'Q';\n        solve(result, board, n, col + 1);\n        board[row][col] = '.';\n      }\n    }\n  }\n\n  const result = [];\n  const board = Array.from({ length: n }, () => Array(n).fill('.'));\n  solve(result, board, n, 0);\n  return result;\n}",
            "python": "if __name__ == \"__main__\":\n    input=$args\n    result = solveNQueens(input)\n    print(result)"
        }
    },
    "52": {
        "title": "N-Queens Puzzle Solutions",
        "description": "The N-Queens puzzle is a classic problem of placing N queens on an N x N chessboard such that no two queens can attack each other. Given an integer N, your task is to calculate the number of distinct solutions to the N-Queens puzzle.",
        "example": "Example:\n\nInput: N = 4\nOutput: 2\nExplanation: There are two distinct solutions to the 4-Queens puzzle as shown below:\n\nSolution 1:\n\n. Q . .\n. . . Q\nQ . . .\n. . Q .\n\nSolution 2:\n\n. . Q .\nQ . . .\n. . . Q\n. Q . .",
        "level": "Medium",
        "tags": [
            "backtracking",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                4,
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                9
            ],
            "outputs": [
                2,
                1,
                0,
                0,
                10,
                4,
                40,
                92,
                352
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nbool isSafe(vector<int> &cols, int row) {\n    int col = cols.size();\n    for (int i = 0; i < cols.size(); i++) {\n        if (cols[i] == row || abs(i - col) == abs(cols[i] - row)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid backtrack(int n, vector<int> &cols, int &count) {\n    if (cols.size() == n) {\n        count++;\n        return;\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (isSafe(cols, i)) {\n            cols.push_back(i);\n            backtrack(n, cols, count);\n            cols.pop_back();\n        }\n    }\n}\n\nint totalNQueens(int n) {\n    vector<int> cols;\n    int count = 0;\n    backtrack(n, cols, count);\n    return count;\n}\n\n",
            "java": "import java.util.ArrayList;\n\npublic int totalNQueens(int n) {\n    ArrayList<Integer> cols = new ArrayList<>();\n    return backtrack(n, cols);\n}\n\npublic int backtrack(int n, ArrayList<Integer> cols) {\n    if (cols.size() == n) {\n        return 1;\n    }\n\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (isSafe(cols, i)) {\n            cols.add(i);\n            count += backtrack(n, cols);\n            cols.remove(cols.size() - 1);\n        }\n    }\n    return count;\n}\n\npublic boolean isSafe(ArrayList<Integer> cols, int row) {\n    int col = cols.size();\n    for (int i = 0; i < cols.size(); i++) {\n        if (cols.get(i) == row || Math.abs(i - col) == Math.abs(cols.get(i) - row)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n",
            "python": "def is_safe(cols, row):\n    col = len(cols)\n    for i, r in enumerate(cols):\n        if r == row or abs(i - col) == abs(r - row):\n            return False\n    return True\n\n\ndef backtrack(n, cols):\n    if len(cols) == n:\n        return 1\n\n    count = 0\n    for i in range(n):\n        if is_safe(cols, i):\n            cols.append(i)\n            count += backtrack(n, cols)\n            cols.pop()\n\n    return count\n\n\ndef total_n_queens(n):\n    cols = []\n    return backtrack(n, cols)\n",
            "javascript": "function isSafe(cols, row) {\n    let col = cols.length;\n    for (let i = 0; i < cols.length; i++) {\n        if (cols[i] === row || Math.abs(i - col) === Math.abs(cols[i] - row)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction backtrack(n, cols) {\n    if (cols.length === n) {\n        return 1;\n    }\n\n    let count = 0;\n    for (let i = 0; i < n; i++) {\n        if (isSafe(cols, i)) {\n            cols.push(i);\n            count += backtrack(n, cols);\n            cols.pop();\n        }\n    }\n    return count;\n}\n\nfunction totalNQueens(n) {\n    let cols = [];\n    return backtrack(n, cols);\n}\n",
            "explanation": "The algorithm recursively places queens on columns and checks if the placement is safe, i.e., no queens are attacking each other. \n1. Maintain an array `cols` storing the row indices of placed queens. The index in this array represents the column the queen is placed in. This ensures that no two queens are placed in the same column.\n2. Recursively place queens (column-wise).\n3. Check for a safe position for each queen in the current column:\n   a. Check for same row (`cols[i] == row`).\n   b. Check for diagonal attack (`abs(i - col) == abs(cols[i] - row)`).\n4. If the current position is safe, place the queen in the current column at the current row position, and continue to place the next queen.\n5. If all queens are placed, increment the solution count.\n6. If the recursive call finishes, backtrack by removing the queen from the current column and move on to the next row in the same column.\n7. The base case is when the `cols` size equals `n`, meaning all queens have been placed safely; increment the count.\n\nThis approach considers all possible configurations for placing the n queens while avoiding visiting invalid configurations. It uses backtracking to explore the state space efficiently. The algorithm finds the number of distinct solutions to the n-queens puzzle."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nbool isSafe(vector<int> &cols, int row) \n    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\n\npublic int totalNQueens(int n) \n    // Your code here\n}\n\n",
            "python": "def is_safe(cols, row):\n    # Your code here\n\n",
            "javascript": "function isSafe(cols, row) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nint main() {\n    int n = $args;\n    int result = totalNQueens(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int totalNQueens(int n) {\n    ArrayList<Integer> cols = new ArrayList<>();\n    return backtrack(n, cols);\n}\n\npublic int backtrack(int n, ArrayList<Integer> cols) {\n    if (cols.size() == n) {\n        return 1;\n    }\n\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (isSafe(cols, i)) {\n            cols.add(i);\n            count += backtrack(n, cols);\n            cols.remove(cols.size() - 1);\n        }\n    }\n    return count;\n}\n\npublic boolean isSafe(ArrayList<Integer> cols, int row) {\n    int col = cols.size();\n    for (int i = 0; i < cols.size(); i++) {\n        if (cols.get(i) == row || Math.abs(i - col) == Math.abs(cols.get(i) - row)) {\n            return false;\n        }\n    }\n    return true;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = total_n_queens(n)\n    print(result)",
            "javascript": "function totalNQueens(n) {\n    let cols = [];\n    return backtrack(n, cols);\n}"
        }
    },
    "54": {
        "title": "Spiral Matrix",
        "description": "Given an `m x n` matrix, return all elements of the matrix in spiral order.",
        "example": "Example 1:\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]\n\nExample 2:\n\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]",
        "level": "Medium",
        "tags": [
            "array",
            "matrix",
            "spiral"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9
                    ],
                    [
                        10,
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        3
                    ],
                    [
                        4
                    ],
                    [
                        5
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        30
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65,
                        66,
                        67,
                        68,
                        69,
                        70
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65,
                        66,
                        67,
                        68,
                        69,
                        70
                    ],
                    [
                        71,
                        72,
                        73,
                        74,
                        75,
                        76,
                        77,
                        78,
                        79,
                        80
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65,
                        66,
                        67,
                        68,
                        69,
                        70
                    ],
                    [
                        71,
                        72,
                        73,
                        74,
                        75,
                        76,
                        77,
                        78,
                        79,
                        80
                    ],
                    [
                        81,
                        82,
                        83,
                        84,
                        85,
                        86,
                        87,
                        88,
                        89,
                        90
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65,
                        66,
                        67,
                        68,
                        69,
                        70
                    ],
                    [
                        71,
                        72,
                        73,
                        74,
                        75,
                        76,
                        77,
                        78,
                        79,
                        80
                    ],
                    [
                        81,
                        82,
                        83,
                        84,
                        85,
                        86,
                        87,
                        88,
                        89,
                        90
                    ],
                    [
                        91,
                        92,
                        93,
                        94,
                        95,
                        96,
                        97,
                        98,
                        99,
                        100
                    ]
                ]
            ],
            "outputs": [
                [
                    1,
                    2,
                    3,
                    6,
                    9,
                    8,
                    7,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    8,
                    12,
                    11,
                    10,
                    9,
                    5,
                    6,
                    7
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    10,
                    15,
                    20,
                    19,
                    18,
                    17,
                    16,
                    11,
                    6,
                    7,
                    8,
                    9,
                    14,
                    13,
                    12
                ],
                [
                    1,
                    2,
                    3,
                    6,
                    9,
                    12,
                    11,
                    10,
                    7,
                    4,
                    5,
                    8
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    4,
                    6,
                    8,
                    10,
                    9,
                    7,
                    5,
                    3
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    10,
                    15,
                    14,
                    13,
                    12,
                    11,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    30,
                    29,
                    28,
                    27,
                    26,
                    25,
                    24,
                    23,
                    22,
                    21
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    30,
                    40,
                    39,
                    38,
                    37,
                    36,
                    35,
                    34,
                    33,
                    32,
                    31,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    30,
                    40,
                    50,
                    49,
                    48,
                    47,
                    46,
                    45,
                    44,
                    43,
                    42,
                    41,
                    31,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    39,
                    38,
                    37,
                    36,
                    35,
                    34,
                    33,
                    32
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    30,
                    40,
                    50,
                    60,
                    59,
                    58,
                    57,
                    56,
                    55,
                    54,
                    53,
                    52,
                    51,
                    41,
                    31,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    39,
                    49,
                    48,
                    47,
                    46,
                    45,
                    44,
                    43,
                    42,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    69,
                    68,
                    67,
                    66,
                    65,
                    64,
                    63,
                    62,
                    61,
                    51,
                    41,
                    31,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    39,
                    49,
                    59,
                    58,
                    57,
                    56,
                    55,
                    54,
                    53,
                    52,
                    42,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    48,
                    47,
                    46,
                    45,
                    44,
                    43
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    79,
                    78,
                    77,
                    76,
                    75,
                    74,
                    73,
                    72,
                    71,
                    61,
                    51,
                    41,
                    31,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    39,
                    49,
                    59,
                    69,
                    68,
                    67,
                    66,
                    65,
                    64,
                    63,
                    62,
                    52,
                    42,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    48,
                    58,
                    57,
                    56,
                    55,
                    54,
                    53,
                    43,
                    44,
                    45,
                    46,
                    47
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    89,
                    88,
                    87,
                    86,
                    85,
                    84,
                    83,
                    82,
                    81,
                    71,
                    61,
                    51,
                    41,
                    31,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    39,
                    49,
                    59,
                    69,
                    79,
                    78,
                    77,
                    76,
                    75,
                    74,
                    73,
                    72,
                    62,
                    52,
                    42,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    48,
                    58,
                    68,
                    67,
                    66,
                    65,
                    64,
                    63,
                    53,
                    43,
                    44,
                    45,
                    46,
                    47,
                    57,
                    56,
                    55,
                    54
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100,
                    99,
                    98,
                    97,
                    96,
                    95,
                    94,
                    93,
                    92,
                    91,
                    81,
                    71,
                    61,
                    51,
                    41,
                    31,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    39,
                    49,
                    59,
                    69,
                    79,
                    89,
                    88,
                    87,
                    86,
                    85,
                    84,
                    83,
                    82,
                    72,
                    62,
                    52,
                    42,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    48,
                    58,
                    68,
                    78,
                    77,
                    76,
                    75,
                    74,
                    73,
                    63,
                    53,
                    43,
                    44,
                    45,
                    46,
                    47,
                    57,
                    67,
                    66,
                    65,
                    64,
                    54,
                    55,
                    56
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\n    vector<int> result;\n    if (matrix.empty()) return result;\n    int m = matrix.size(), n = matrix[0].size();\n    int rowStart = 0, colStart = 0, rowEnd = m - 1, colEnd = n - 1;\n\n    while (rowStart <= rowEnd && colStart <= colEnd) {\n        for (int i = colStart; i <= colEnd; ++i) {\n            result.push_back(matrix[rowStart][i]);\n        }\n        rowStart++;\n        for (int i = rowStart; i <= rowEnd; ++i) {\n            result.push_back(matrix[i][colEnd]);\n        }\n        colEnd--;\n        if (rowStart <= rowEnd) {\n            for (int i = colEnd; i >= colStart; --i) {\n                result.push_back(matrix[rowEnd][i]);\n            }\n        }\n        rowEnd--;\n        if (colStart <= colEnd) {\n            for (int i = rowEnd; i >= rowStart; --i) {\n                result.push_back(matrix[i][colStart]);\n            }\n        }\n        colStart++;\n    }\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> spiralOrder(int[][] matrix) {\n    List<Integer> result = new ArrayList<>();\n    if (matrix == null || matrix.length == 0) return result;\n    int m = matrix.length, n = matrix[0].length;\n    int rowStart = 0, colStart = 0, rowEnd = m - 1, colEnd = n - 1;\n\n    while (rowStart <= rowEnd && colStart <= colEnd) {\n        for (int i = colStart; i <= colEnd; i++) {\n            result.add(matrix[rowStart][i]);\n        }\n        rowStart++;\n        for (int i = rowStart; i <= rowEnd; i++) {\n            result.add(matrix[i][colEnd]);\n        }\n        colEnd--;\n        if (rowStart <= rowEnd) {\n            for (int i = colEnd; i >= colStart; i--) {\n                result.add(matrix[rowEnd][i]);\n            }\n        }\n        rowEnd--;\n        if (colStart <= colEnd) {\n            for (int i = rowEnd; i >= rowStart; i--) {\n                result.add(matrix[i][colStart]);\n            }\n        }\n        colStart++;\n    }\n    return result;\n}\n",
            "python": "def spiralOrder(matrix):\n    result = []\n    if not matrix: return result\n    m, n = len(matrix), len(matrix[0])\n    rowStart, colStart, rowEnd, colEnd = 0, 0, m - 1, n - 1\n\n    while rowStart <= rowEnd and colStart <= colEnd:\n        for i in range(colStart, colEnd + 1): \n            result.append(matrix[rowStart][i])\n        rowStart += 1\n        \n        for i in range(rowStart, rowEnd + 1): \n            result.append(matrix[i][colEnd]) \n        colEnd -= 1\n        \n        if rowStart <= rowEnd:\n            for i in range(colEnd, colStart - 1, -1): \n                result.append(matrix[rowEnd][i]) \n        rowEnd -= 1\n        \n        if colStart <= colEnd:\n            for i in range(rowEnd, rowStart - 1, -1): \n                result.append(matrix[i][colStart]) \n        colStart += 1\n        \n    return result\n",
            "javascript": "function spiralOrder(matrix) {\n    const result = [];\n    if (!matrix.length) return result;\n    let m = matrix.length, n = matrix[0].length;\n    let rowStart = 0, colStart = 0, rowEnd = m - 1, colEnd = n - 1;\n\n    while (rowStart <= rowEnd && colStart <= colEnd) {\n        for (let i = colStart; i <= colEnd; i++) {\n            result.push(matrix[rowStart][i]);\n        }\n        rowStart++;\n        for (let i = rowStart; i <= rowEnd; i++) {\n            result.push(matrix[i][colEnd]);\n        }\n        colEnd--;\n        if (rowStart <= rowEnd) {\n            for (let i = colEnd; i >= colStart; i--) {\n                result.push(matrix[rowEnd][i]);\n            }\n        }\n        rowEnd--;\n        if (colStart <= colEnd) {\n            for (let i = rowEnd; i >= rowStart; i--) {\n                result.push(matrix[i][colStart]);\n            }\n        }\n        colStart++;\n    }\n    return result;\n}\n",
            "explanation": "The algorithm iterates over the matrix in a spiral order. Initialize the indices to keep track of the matrix boundaries. The algorithm goes from left to right, from top to bottom, from right to left, and then from bottom to top. With each iteration, update the matrix boundaries. The process continues until the row and column boundaries cross each other."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> spiralOrder(vector<vector<int>>& matrix) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> spiralOrder(int[][] matrix) \n    // Your code here\n}\n",
            "python": "def spiralOrder(matrix):\n    # Your code here\n\n",
            "javascript": "function spiralOrder(matrix) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nint main() {\n    vector<vector<int>> matrix = $args;\n    vector<int> result = spiralOrder(matrix);\n    for (int i = 0; i < result.size(); ++i) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "java": "public List<Integer> spiralOrder(int[][] matrix) {\n    List<Integer> result = new ArrayList<>();\n    if (matrix == null || matrix.length == 0) return result;\n    int m = matrix.length, n = matrix[0].length;\n    int rowStart = 0, colStart = 0, rowEnd = m - 1, colEnd = n - 1;\n\n    while (rowStart <= rowEnd && colStart <= colEnd) {\n        for (int i = colStart; i <= colEnd; i++) {\n            result.add(matrix[rowStart][i]);\n        }\n        rowStart++;\n        for (int i = rowStart; i <= rowEnd; i++) {\n            result.add(matrix[i][colEnd]);\n        }\n        colEnd--;\n        if (rowStart <= rowEnd) {\n            for (int i = colEnd; i >= colStart; i--) {\n                result.add(matrix[rowEnd][i]);\n            }\n        }\n        rowEnd--;\n        if (colStart <= colEnd) {\n            for (int i = rowEnd; i >= rowStart; i--) {\n                result.add(matrix[i][colStart]);\n            }\n        }\n        colStart++;\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    matrix = $args\n    result = spiralOrder(matrix)\n    print(result)"
        }
    },
    "56": {
        "title": "Merge Overlapping Intervals",
        "description": "Given an array of intervals where each interval is represented as [start, end], merge all overlapping intervals and return an array of non-overlapping intervals that cover all the intervals in the input.",
        "example": "Example 1:\n\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\nExample 2:\n\nInput: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.",
        "level": "Medium",
        "tags": [
            "Array",
            "Sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        8,
                        10
                    ],
                    [
                        15,
                        18
                    ]
                ],
                [
                    [
                        1,
                        4
                    ],
                    [
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        3,
                        8
                    ],
                    [
                        4,
                        7
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        6
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        3
                    ],
                    [
                        4,
                        6
                    ],
                    [
                        7,
                        9
                    ],
                    [
                        10,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        6
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        5,
                        7
                    ],
                    [
                        6,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ]
                ]
            ],
            "outputs": [
                "[[1,6],[8,10],[15,18]]",
                "[[1,5]]",
                "[[1,2],[3,4],[5,6],[7,8]]",
                "[[1,10]]",
                "[[1,6],[7,8]]",
                "[[1,3],[4,6],[7,9],[10,12]]",
                "[[1,5]]",
                "[[1,2],[3,4],[5,6],[7,8],[9,10]]",
                "[[1,6],[7,8],[9,10]]",
                "[[1,4],[5,8]]",
                "[[1,6]]",
                "[[1,7]]",
                "[[1,8]]",
                "[[1,9]]",
                "[[1,10]]",
                "[[1,11]]",
                "[[1,12]]",
                "[[1,13]]",
                "[[1,14]]",
                "[[1,15]]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> merge(std::vector<std::vector<int>>& intervals) {\n    if (intervals.empty()) return {};\n\n    std::sort(intervals.begin(), intervals.end());\n    std::vector<std::vector<int>> result;\n    result.push_back(intervals[0]);\n\n    for (int i = 1; i < intervals.size(); i++) {\n        if (result.back()[1] >= intervals[i][0]) {\n            result.back()[1] = std::max(result.back()[1], intervals[i][1]);\n        } else {\n            result.push_back(intervals[i]);\n        }\n    }\n\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<int[]> merge(int[][] intervals) {\n    if (intervals.length == 0) return new ArrayList<>();\n\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n    List<int[]> result = new ArrayList<>();\n    result.add(intervals[0]);\n\n    for (int i = 1; i < intervals.length; i++) {\n        if (result.get(result.size() - 1)[1] >= intervals[i][0]) {\n            result.get(result.size() - 1)[1] = Math.max(result.get(result.size() - 1)[1], intervals[i][1]);\n        } else {\n            result.add(intervals[i]);\n        }\n    }\n\n    return result;\n}\n",
            "python": "def merge(intervals):\n    if not intervals:\n        return []\n\n    intervals.sort()\n    result = [intervals[0]]\n\n    for i in range(1, len(intervals)):\n        if result[-1][1] >= intervals[i][0]:\n            result[-1][1] = max(result[-1][1], intervals[i][1])\n        else:\n            result.append(intervals[i])\n\n    return result\n",
            "javascript": "function merge(intervals) {\n    if (intervals.length === 0) return [];\n\n    intervals.sort((a, b) => a[0] - b[0]);\n    const result = [intervals[0]];\n\n    for (let i = 1; i < intervals.length; i++) {\n        if (result[result.length - 1][1] >= intervals[i][0]) {\n            result[result.length - 1][1] = Math.max(result[result.length - 1][1], intervals[i][1]);\n        } else {\n            result.push(intervals[i]);\n        }\n    }\n\n    return result;\n}\n",
            "explanation": "The algorithm first sorts the intervals based on their start time. Then, it initializes an empty list `result` to store the merged intervals, and adds the first interval to `result`. Next, it iterates through the remaining intervals, comparing the end time of the last interval in `result` to the start time of the current interval. If they overlap (i.e., the end time of the last interval in `result` is greater than or equal to the start time of the current interval), then the end time of the last interval in `result` is updated to the maximum of its own end time and the end time of the current interval. Otherwise, the current interval is added to `result`. The process continues until all intervals have been processed, and `result` contains the merged, non-overlapping intervals covering the input intervals."
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> merge(std::vector<std::vector<int>>& intervals) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<int[]> merge(int[][] intervals) \n    // Your code here\n}\n",
            "python": "def merge(intervals):\n    # Your code here\n\n",
            "javascript": "function merge(intervals) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nint main() {\n    std::vector<std::vector<int>> intervals = $args;\n    std::vector<std::vector<int>> result = merge(intervals);\n\n    for (const auto& interval : result) {\n        std::cout << '[' << interval[0] << ',' << interval[1] << ']';\n    }\n\n    return 0;\n}",
            "java": "public List<int[]> merge(int[][] intervals) {\n    if (intervals.length == 0) return new ArrayList<>();\n\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n    List<int[]> result = new ArrayList<>();\n    result.add(intervals[0]);\n\n    for (int i = 1; i < intervals.length; i++) {\n        if (result.get(result.size() - 1)[1] >= intervals[i][0]) {\n            result.get(result.size() - 1)[1] = Math.max(result.get(result.size() - 1)[1], intervals[i][1]);\n        } else {\n            result.add(intervals[i]);\n        }\n    }\n\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    intervals = $args\n    result = merge(intervals)\n    print(result)",
            "javascript": "function merge(intervals) {\n    if (intervals.length === 0) return [];\n\n    intervals.sort((a, b) => a[0] - b[0]);\n    const result = [intervals[0]];\n\n    for (let i = 1; i < intervals.length; i++) {\n        if (result[result.length - 1][1] >= intervals[i][0]) {\n            result[result.length - 1][1] = Math.max(result[result.length - 1][1], intervals[i][1]);\n        } else {\n            result.push(intervals[i]);\n        }\n    }\n\n    return result;\n}"
        }
    },
    "57": {
        "title": "Insert Interval",
        "description": "You are given an array of non-overlapping intervals `intervals` where `intervals[i] = [starti, endi]` represent the start and the end of the `ith` interval and `intervals` is sorted in ascending order by `starti`. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval.\n\nInsert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by `starti` and `intervals` still does not have any overlapping intervals (merge overlapping intervals if necessary).\n\nReturn `intervals` after the insertion.",
        "example": "Example:\n\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\n\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        3
                    ],
                    [
                        6,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        10
                    ],
                    [
                        12,
                        16
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        6,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        10
                    ],
                    [
                        12,
                        16
                    ]
                ],
                [
                    [
                        1,
                        3
                    ],
                    [
                        6,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        10
                    ],
                    [
                        12,
                        16
                    ]
                ],
                [
                    [
                        1,
                        3
                    ],
                    [
                        6,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        10
                    ],
                    [
                        12,
                        16
                    ]
                ],
                [
                    [
                        1,
                        3
                    ],
                    [
                        6,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        10
                    ],
                    [
                        12,
                        16
                    ]
                ],
                [
                    [
                        1,
                        3
                    ],
                    [
                        6,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        10
                    ],
                    [
                        12,
                        16
                    ]
                ],
                [
                    [
                        1,
                        3
                    ],
                    [
                        6,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        10
                    ],
                    [
                        12,
                        16
                    ]
                ],
                [
                    [
                        1,
                        3
                    ],
                    [
                        6,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        10
                    ],
                    [
                        12,
                        16
                    ]
                ],
                [
                    [
                        1,
                        3
                    ],
                    [
                        6,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        10
                    ],
                    [
                        12,
                        16
                    ]
                ],
                [
                    [
                        1,
                        3
                    ],
                    [
                        6,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        10
                    ],
                    [
                        12,
                        16
                    ]
                ]
            ],
            "outputs": [
                [
                    [
                        1,
                        5
                    ],
                    [
                        6,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        10
                    ],
                    [
                        12,
                        16
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        6,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        10
                    ],
                    [
                        12,
                        16
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        6,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        10
                    ],
                    [
                        12,
                        16
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        6,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        10
                    ],
                    [
                        12,
                        16
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        6,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        10
                    ],
                    [
                        12,
                        16
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        6,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        10
                    ],
                    [
                        12,
                        16
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        6,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        10
                    ],
                    [
                        12,
                        16
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        6,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        10
                    ],
                    [
                        12,
                        16
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        6,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        10
                    ],
                    [
                        12,
                        16
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        6,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        10
                    ],
                    [
                        12,
                        16
                    ]
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n    vector<vector<int>> result;\n    int start_pos = 0;\n\n    while (start_pos < intervals.size() && intervals[start_pos][1] < newInterval[0]) {\n        result.push_back(intervals[start_pos]);\n        start_pos++;\n    }\n\n    while (start_pos < intervals.size() && intervals[start_pos][0] <= newInterval[1]) {\n        newInterval[0] = min(newInterval[0], intervals[start_pos][0]);\n        newInterval[1] = max(newInterval[1], intervals[start_pos][1]);\n        start_pos++;\n    }\n\n    result.push_back(newInterval);\n\n    while (start_pos < intervals.size()) {\n        result.push_back(intervals[start_pos]);\n        start_pos++;\n    }\n\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<int[]> insert(int[][] intervals, int[] newInterval) {\n    List<int[]> result = new ArrayList<>();\n    int start_pos = 0;\n\n    while (start_pos < intervals.length && intervals[start_pos][1] < newInterval[0]) {\n        result.add(intervals[start_pos]);\n        start_pos++;\n    }\n\n    while (start_pos < intervals.length && intervals[start_pos][0] <= newInterval[1]) {\n        newInterval[0] = Math.min(newInterval[0], intervals[start_pos][0]);\n        newInterval[1] = Math.max(newInterval[1], intervals[start_pos][1]);\n        start_pos++;\n    }\n\n    result.add(newInterval);\n\n    while (start_pos < intervals.length) {\n        result.add(intervals[start_pos]);\n        start_pos++;\n    }\n\n    return result;\n}\n",
            "python": "from typing import List\n\ndef insert(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n    result = []\n    start_pos = 0\n\n    while start_pos < len(intervals) and intervals[start_pos][1] < newInterval[0]:\n        result.append(intervals[start_pos])\n        start_pos += 1\n\n    while start_pos < len(intervals) and intervals[start_pos][0] <= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[start_pos][0])\n        newInterval[1] = max(newInterval[1], intervals[start_pos][1])\n        start_pos += 1\n\n    result.append(newInterval)\n\n    while start_pos < len(intervals):\n        result.append(intervals[start_pos])\n        start_pos += 1\n\n    return result\n",
            "javascript": "function insert(intervals, newInterval) {\n    const result = [];\n    let start_pos = 0;\n\n    while (start_pos < intervals.length && intervals[start_pos][1] < newInterval[0]) {\n        result.push(intervals[start_pos]);\n        start_pos++;\n    }\n\n    while (start_pos < intervals.length && intervals[start_pos][0] <= newInterval[1]) {\n        newInterval[0] = Math.min(newInterval[0], intervals[start_pos][0]);\n        newInterval[1] = Math.max(newInterval[1], intervals[start_pos][1]);\n        start_pos++;\n    }\n\n    result.push(newInterval);\n\n    while (start_pos < intervals.length) {\n        result.push(intervals[start_pos]);\n        start_pos++;\n    }\n\n    return result;\n}\n",
            "explanation": "The algorithm to merge the new interval starts by exploring the non-overlapping intervals before the new one as we are given a sorted list of intervals. We add the explored intervals that came before to the result. After that, we continue exploring intervals that overlap with the new interval and continuously merging them. We update the new interval's starting and ending points according to the merging process until no overlapping intervals remain. We add the merged interval to the result list, and finally, we add the rest of the original intervals present after the new interval. The result will be a merged list of intervals. "
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<int[]> insert(int[][] intervals, int[] newInterval) \n    // Your code here\n}\n",
            "python": "from typing import List\n    # Your code here\n\n",
            "javascript": "function insert(intervals, newInterval) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nint main() {\n    vector<vector<int>> intervals = $args;\n    vector<int> newInterval = $args;\n    vector<vector<int>> result = insert(intervals, newInterval);\n\n    for (int i = 0; i < result.size(); i++) {\n        for (int j = 0; j < result[i].size(); j++) {\n            cout << result[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    intervals = $args\n    newInterval = $args\n    result = insert(intervals, newInterval)\n    print(result)"
        }
    },
    "58": {
        "title": "Length of Last Word",
        "description": "Given a string `s` consisting of words and spaces, return the length of the last word in the string. A word is a maximal substring consisting of non-space characters only.",
        "example": "Example 1:\n\nInput: s = \"Hello World \"\nOutput: 5\nExplanation: The last word is \"World \" with length 5.",
        "level": "Easy",
        "tags": [
            "string",
            "parsing"
        ],
        "test_cases": {
            "inputs": [
                "\"Hello World \"",
                "\"   fly me   to   the moon   \"",
                "\"luffy is still joyboy \"",
                "\"This is a test\"",
                "\"Coding is fun\"",
                "\"  Hello  \"",
                "\"  Hello World\"",
                "\"Hello World\"",
                "\"Hello\"",
                "\"\"",
                "\"   \"",
                "\"a\"",
                "\"a b\"",
                "\"a b c\"",
                "\"a b c d\"",
                "\"a b c d e\"",
                "\"a b c d e f\"",
                "\"a b c d e f g\"",
                "\"a b c d e f g h\"",
                "\"a b c d e f g h i\""
            ],
            "outputs": [
                5,
                4,
                6,
                4,
                3,
                5,
                5,
                5,
                5,
                0,
                0,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1
            ]
        },
        "sample_code": {
            "c++": "int lengthOfLastWord(string s) {\n    int length = 0;\n    int tail = s.length() - 1;\n    while (tail >= 0 && s[tail] == ' ') tail--;\n    while (tail >= 0 && s[tail] != ' ') {\n        length++;\n        tail--;\n    }\n    return length;\n}\n",
            "java": "public int lengthOfLastWord(String s) {\n    int length = 0;\n    int tail = s.length() - 1;\n    while (tail >= 0 && s.charAt(tail) == ' ') tail--;\n    while (tail >= 0 && s.charAt(tail) != ' ') {\n        length++;\n        tail--;\n    }\n    return length;\n}\n",
            "python": "def length_of_last_word(s: str) -> int:\n    length = 0\n    tail = len(s) - 1\n    while tail >= 0 and s[tail] == ' ':\n        tail -= 1\n    while tail >= 0 and s[tail] != ' ':\n        length += 1\n        tail -= 1\n    return length\n",
            "javascript": "function lengthOfLastWord(s) {\n    let length = 0;\n    let tail = s.length - 1;\n    while (tail >= 0 && s[tail] === ' ') tail--;\n    while (tail >= 0 && s[tail] !== ' ') {\n        length++;\n        tail--;\n    }\n    return length;\n}\n",
            "explanation": "The algorithm for finding the length of the last word in a string containing multiple words separated by spaces is as follows:\n\n1. Initialize variables for the length of the last word and the tail (i.e., the end) of the input string.\n2. Traverse the string in reverse order to find the start of the last word by checking if a character is a space. Skip all spaces found.\n3. Continue traversing the string in reverse order and record the length of the last word until a space is encountered or the start of the string is reached.\n4. Return the length of the last word.\n\nThis algorithm is implemented in each of the given programming languages (C++, Java, Python, and JavaScript) with the appropriate syntax and variable initialization. The functions are named `lengthOfLastWord` for C++, Java, and JavaScript, and `length_of_last_word` for Python."
        },
        "structure": {
            "c++": "int lengthOfLastWord(string s) \n    // Your code here\n}\n",
            "java": "public int lengthOfLastWord(String s) \n    // Your code here\n}\n",
            "python": "def length_of_last_word(s: str) -> int:\n    # Your code here\n\n",
            "javascript": "function lengthOfLastWord(s) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    string s = $args;\n    int result = lengthOfLastWord(s);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = length_of_last_word(s)\n    print(result)",
            "java": "public int lengthOfLastWord(String s) {\n    int length = 0;\n    int tail = s.length() - 1;\n    while (tail >= 0 && s.charAt(tail) == ' ') tail--;\n    while (tail >= 0 && s.charAt(tail) != ' ') {\n        length++;\n        tail--;\n    }\n    return length;\n}"
        }
    },
    "59": {
        "title": "Spiral Matrix",
        "description": "Given a positive integer `n`, generate an `n x n` matrix filled with elements from `1` to `n2` in spiral order.",
        "example": "Example 1:\n\nInput: n = 3\nOutput: [[1,2,3],[8,9,4],[7,6,5]]\n\nExample 2:\n\nInput: n = 1\nOutput: [[1]]",
        "level": "Medium",
        "tags": [
            "array",
            "matrix"
        ],
        "test_cases": {
            "inputs": [
                3,
                4,
                5,
                1,
                2,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "outputs": [
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        8,
                        9,
                        4
                    ],
                    [
                        7,
                        6,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        12,
                        13,
                        14,
                        5
                    ],
                    [
                        11,
                        16,
                        15,
                        6
                    ],
                    [
                        10,
                        9,
                        8,
                        7
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        6
                    ],
                    [
                        15,
                        24,
                        25,
                        20,
                        7
                    ],
                    [
                        14,
                        23,
                        22,
                        21,
                        8
                    ],
                    [
                        13,
                        12,
                        11,
                        10,
                        9
                    ]
                ],
                [
                    [
                        1
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        4,
                        3
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        8,
                        9,
                        4
                    ],
                    [
                        7,
                        6,
                        5
                    ],
                    [
                        12,
                        11,
                        10
                    ],
                    [
                        13,
                        14,
                        15
                    ],
                    [
                        18,
                        17,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        8
                    ],
                    [
                        23,
                        40,
                        41,
                        42,
                        43,
                        30,
                        9
                    ],
                    [
                        22,
                        39,
                        48,
                        49,
                        44,
                        31,
                        10
                    ],
                    [
                        21,
                        38,
                        47,
                        46,
                        45,
                        32,
                        11
                    ],
                    [
                        20,
                        37,
                        36,
                        35,
                        34,
                        33,
                        12
                    ],
                    [
                        19,
                        18,
                        17,
                        16,
                        15,
                        14,
                        13
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        10
                    ],
                    [
                        31,
                        56,
                        57,
                        58,
                        59,
                        60,
                        61,
                        40,
                        11
                    ],
                    [
                        30,
                        55,
                        72,
                        73,
                        74,
                        75,
                        62,
                        41,
                        12
                    ],
                    [
                        29,
                        54,
                        71,
                        80,
                        81,
                        76,
                        63,
                        42,
                        13
                    ],
                    [
                        28,
                        53,
                        70,
                        79,
                        78,
                        77,
                        64,
                        43,
                        14
                    ],
                    [
                        27,
                        52,
                        69,
                        68,
                        67,
                        66,
                        65,
                        44,
                        15
                    ],
                    [
                        26,
                        51,
                        50,
                        49,
                        48,
                        47,
                        46,
                        45,
                        16
                    ],
                    [
                        25,
                        24,
                        23,
                        22,
                        21,
                        20,
                        19,
                        18,
                        17
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40,
                        41,
                        42,
                        43,
                        44,
                        11
                    ],
                    [
                        35,
                        64,
                        65,
                        66,
                        67,
                        68,
                        69,
                        70,
                        45,
                        12
                    ],
                    [
                        34,
                        63,
                        84,
                        85,
                        86,
                        87,
                        88,
                        71,
                        46,
                        13
                    ],
                    [
                        33,
                        62,
                        83,
                        96,
                        97,
                        98,
                        89,
                        72,
                        47,
                        14
                    ],
                    [
                        32,
                        61,
                        82,
                        95,
                        100,
                        99,
                        90,
                        73,
                        48,
                        15
                    ],
                    [
                        31,
                        60,
                        81,
                        94,
                        93,
                        92,
                        91,
                        74,
                        49,
                        16
                    ],
                    [
                        30,
                        59,
                        80,
                        79,
                        78,
                        77,
                        76,
                        75,
                        50,
                        17
                    ],
                    [
                        29,
                        58,
                        57,
                        56,
                        55,
                        54,
                        53,
                        52,
                        51,
                        18
                    ],
                    [
                        28,
                        27,
                        26,
                        25,
                        24,
                        23,
                        22,
                        21,
                        20,
                        19
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        40,
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        12
                    ],
                    [
                        39,
                        72,
                        73,
                        74,
                        75,
                        76,
                        77,
                        78,
                        79,
                        50,
                        13
                    ],
                    [
                        38,
                        71,
                        96,
                        97,
                        98,
                        99,
                        100,
                        101,
                        80,
                        51,
                        14
                    ],
                    [
                        37,
                        70,
                        95,
                        120,
                        121,
                        122,
                        123,
                        102,
                        81,
                        52,
                        15
                    ],
                    [
                        36,
                        69,
                        94,
                        119,
                        132,
                        133,
                        124,
                        103,
                        82,
                        53,
                        16
                    ],
                    [
                        35,
                        68,
                        93,
                        118,
                        131,
                        134,
                        125,
                        104,
                        83,
                        54,
                        17
                    ],
                    [
                        34,
                        67,
                        92,
                        117,
                        130,
                        135,
                        126,
                        105,
                        84,
                        55,
                        18
                    ],
                    [
                        33,
                        66,
                        91,
                        116,
                        129,
                        136,
                        127,
                        106,
                        85,
                        56,
                        19
                    ],
                    [
                        32,
                        65,
                        90,
                        115,
                        128,
                        137,
                        128,
                        107,
                        86,
                        57,
                        20
                    ],
                    [
                        31,
                        64,
                        89,
                        114,
                        113,
                        112,
                        111,
                        110,
                        109,
                        108,
                        21
                    ],
                    [
                        30,
                        63,
                        88,
                        87,
                        86,
                        85,
                        84,
                        83,
                        82,
                        81,
                        22
                    ],
                    [
                        29,
                        62,
                        61,
                        60,
                        59,
                        58,
                        57,
                        56,
                        55,
                        54,
                        23
                    ],
                    [
                        28,
                        27,
                        26,
                        25,
                        24,
                        23,
                        22,
                        21,
                        20,
                        19,
                        18
                    ],
                    [
                        17,
                        16,
                        15,
                        14,
                        13,
                        12,
                        11,
                        10,
                        9,
                        8,
                        7
                    ],
                    [
                        36,
                        35,
                        34,
                        33,
                        32,
                        31,
                        30,
                        29,
                        28,
                        27,
                        26
                    ],
                    [
                        37,
                        38,
                        39,
                        40,
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        25
                    ],
                    [
                        38,
                        39,
                        40,
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        24
                    ],
                    [
                        39,
                        40,
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        23
                    ],
                    [
                        40,
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        22
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50,
                        21
                    ],
                    [
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50,
                        51,
                        20
                    ],
                    [
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50,
                        51,
                        52,
                        19
                    ],
                    [
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50,
                        51,
                        52,
                        53,
                        18
                    ],
                    [
                        45,
                        46,
                        47,
                        48,
                        49,
                        50,
                        51,
                        52,
                        53,
                        54,
                        17
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50,
                        51,
                        52,
                        53,
                        54,
                        55,
                        16
                    ],
                    [
                        47,
                        48,
                        49,
                        50,
                        51,
                        52,
                        53,
                        54,
                        55,
                        56,
                        15
                    ],
                    [
                        48,
                        49,
                        50,
                        51,
                        52,
                        53,
                        54,
                        55,
                        56,
                        57,
                        14
                    ],
                    [
                        49,
                        50,
                        51,
                        52,
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        13
                    ],
                    [
                        50,
                        51,
                        52,
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        12
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60,
                        11
                    ],
                    [
                        52,
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60,
                        61,
                        10
                    ],
                    [
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60,
                        61,
                        62,
                        9
                    ],
                    [
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60,
                        61,
                        62,
                        63,
                        8
                    ],
                    [
                        55,
                        56,
                        57,
                        58,
                        59,
                        60,
                        61,
                        62,
                        63,
                        64,
                        7
                    ],
                    [
                        56,
                        57,
                        58,
                        59,
                        60,
                        61,
                        62,
                        63,
                        64,
                        65,
                        6
                    ],
                    [
                        57,
                        58,
                        59,
                        60,
                        61,
                        62,
                        63,
                        64,
                        65,
                        66,
                        5
                    ],
                    [
                        58,
                        59,
                        60,
                        61,
                        62,
                        63,
                        64,
                        65,
                        66,
                        67,
                        4
                    ],
                    [
                        59,
                        60,
                        61,
                        62,
                        63,
                        64,
                        65,
                        66,
                        67,
                        68,
                        3
                    ],
                    [
                        60,
                        61,
                        62,
                        63,
                        64,
                        65,
                        66,
                        67,
                        68,
                        69,
                        2
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65,
                        66,
                        67,
                        68,
                        69,
                        70,
                        1
                    ]
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nstd::vector<std::vector<int>> generateMatrix(int n) {\n    std::vector<std::vector<int>> matrix(n, std::vector<int>(n));\n    int value = 1, top = 0, bottom = n - 1, left = 0, right = n - 1;\n\n    while (value <= n * n) {\n        for (int i = left; i <= right; i++) {\n            matrix[top][i] = value++;\n        }\n\n        for (int i = top + 1; i <= bottom; i++) {\n            matrix[i][right] = value++;\n        }\n\n        if (top < bottom && left < right) {\n            for (int i = right - 1; i >= left; i--) {\n                matrix[bottom][i] = value++;\n            }\n\n            for (int i = bottom - 1; i > top; i--) {\n                matrix[i][left] = value++;\n            }\n        }\n\n        top++, bottom--, left++, right--;\n    }\n\n    return matrix;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.Arrays;\n\npublic int[][] generateMatrix(int n) {\n    int[][] matrix = new int[n][n];\n    int value = 1, top = 0, bottom = n - 1, left = 0, right = n - 1;\n\n    while (value <= n * n) {\n        for (int i = left; i <= right; i++) {\n            matrix[top][i] = value++;\n        }\n\n        for (int i = top + 1; i <= bottom; i++) {\n            matrix[i][right] = value++;\n        }\n\n        if (top < bottom && left < right) {\n            for (int i = right - 1; i >= left; i--) {\n                matrix[bottom][i] = value++;\n            }\n\n            for (int i = bottom - 1; i > top; i--) {\n                matrix[i][left] = value++;\n            }\n        }\n\n        top++; bottom--; left++; right--;\n    }\n\n    return matrix;\n}\n",
            "python": "def generateMatrix(n: int) -> list[list[int]]:\n    matrix = [[0] * n for _ in range(n)]\n    value, top, bottom, left, right = 1, 0, n - 1, 0, n - 1\n\n    while value <= n * n:\n        for i in range(left, right + 1):\n            matrix[top][i] = value\n            value += 1\n\n        for i in range(top + 1, bottom + 1):\n            matrix[i][right] = value\n            value += 1\n\n        if top < bottom and left < right:\n            for i in range(right - 1, left - 1, -1):\n                matrix[bottom][i] = value\n                value += 1\n\n            for i in range(bottom - 1, top, -1):\n                matrix[i][left] = value\n                value += 1\n\n        top, bottom, left, right = top + 1, bottom - 1, left + 1, right - 1\n\n    return matrix\n",
            "javascript": "function generateMatrix(n) {\n    const matrix = Array.from({ length: n }, () => new Array(n).fill(0));\n    let value = 1, top = 0, bottom = n - 1, left = 0, right = n - 1;\n\n    while (value <= n * n) {\n        for (let i = left; i <= right; i++) {\n            matrix[top][i] = value++;\n        }\n\n        for (let i = top + 1; i <= bottom; i++) {\n            matrix[i][right] = value++;\n        }\n\n        if (top < bottom && left < right) {\n            for (let i = right - 1; i >= left; i--) {\n                matrix[bottom][i] = value++;\n            }\n\n            for (let i = bottom - 1; i > top; i--) {\n                matrix[i][left] = value++;\n            }\n        }\n\n        top++, bottom--, left++, right--;\n    }\n\n    return matrix;\n}\n",
            "explanation": "The algorithm initializes an n x n matrix and defines variables to maintain the current top (row), bottom (row), left (column), and right (column) positions. The algorithm then loops through the four sides of the outer square/boundary of the matrix in clockwise order (top row left to right, right column top to bottom, bottom row right to left, left column bottom to top) and fills the elements with the numbers in sequence from 1 to n\u00c2\u00b2. After completing a boundary, update the top, bottom, left, and right variables to point to the next inner square/boundary, and repeat the process until every position in the matrix has been filled."
        },
        "structure": {
            "c++": "#include <vector>\n\nstd::vector<std::vector<int>> generateMatrix(int n) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.Arrays;\n\npublic int[][] generateMatrix(int n) \n    // Your code here\n}\n",
            "python": "def generateMatrix(n: int) -> List[List[int]]:\n    # Your code here\n\n",
            "javascript": "function generateMatrix(n) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nint main() {\n    int n = $args;\n    std::vector<std::vector<int>> result = generateMatrix(n);\n\n    for (const auto& row : result) {\n        for (const auto& num : row) {\n            std::cout << num << ' ';\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = generateMatrix(n)\n    print(result)"
        }
    },
    "60": {
        "title": "Permutation Sequence",
        "description": "Given a set of numbers from 1 to n, the set contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get a sequence. Given n and k, return the kth permutation sequence.",
        "example": "For example, given n = 3 and k = 3, the set of permutations is [\"123\", \"132\", \"213\", \"231\", \"312\", \"321\"]. The 3rd permutation is \"213\", so the output would be \"213\".",
        "level": "Medium",
        "tags": [
            "Math",
            "Backtracking"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    3
                ],
                [
                    4,
                    9
                ],
                [
                    3,
                    1
                ],
                [
                    5,
                    24
                ],
                [
                    6,
                    720
                ],
                [
                    9,
                    362880
                ],
                [
                    9,
                    362879
                ]
            ],
            "outputs": [
                "213",
                "2314",
                "123",
                "54321",
                "654321",
                "987654321",
                "987654312"
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <vector>\n\nstd::string getPermutation(int n, int k) {\n    std::vector<int> factorials(n, 1);\n    std::vector<char> nums(n, '1');\n    std::string result;\n    int index;\n\n    for (int i = 1; i <= n; ++i) {\n        nums[i - 1] += i - 1;\n        factorials[i - 1] *= i;\n    }\n\n    k--;\n\n    for (int i = n; i >= 1; --i) {\n        index = k / factorials[i - 1];\n        k %= factorials[i - 1];\n        result.push_back(nums[index]);\n        nums.erase(nums.begin() + index);\n    }\n\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic String getPermutation(int n, int k) {\n    List<Integer> nums = new ArrayList<>();\n    int[] factorials = new int[n];\n    StringBuilder sb = new StringBuilder();\n    int index;\n\n    factorials[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        nums.add(i);\n        factorials[i - 1] = i * factorials[i - 1];\n    }\n\n    k--;\n\n    for (int i = n; i >= 1; --i) {\n        index = k / factorials[i - 1];\n        k %= factorials[i - 1];\n        sb.append(nums.get(index));\n        nums.remove(index);\n    }\n\n    return sb.toString();\n}\n",
            "python": "def getPermutation(n, k):\n    factorials = [1]\n    nums = list(range(1, n + 1))\n    result = []\n\n    for i in range(1, n):\n        factorials.append(factorials[-1] * i)\n\n    k -= 1\n\n    for i in range(n, 0, -1):\n        index = k // factorials[i - 1]\n        k %= factorials[i - 1]\n        result.append(str(nums.pop(index)))\n\n    return ''.join(result)\n",
            "javascript": "function getPermutation(n, k) {\n    const factorials = [1];\n    const nums = [...Array(n)].map((_, i) => i + 1);\n    let result = '';\n\n    for (let i = 1; i < n; i++) {\n        factorials[i] = factorials[i - 1] * i;\n    }\n\n    k--;\n\n    for (let i = n; i >= 1; i--) {\n        const index = Math.floor(k / factorials[i - 1]);\n        k %= factorials[i - 1];\n        result += nums[index];\n        nums.splice(index, 1);\n    }\n\n    return result;\n}\n",
            "explanation": "The algorithm uses factorials and a list of available numbers to construct the kth permutation. \n\nFirst, we precompute the factorials up to n using a loop.\n\nNext, we initialize an array or list of available numbers, from 1 to n.\n\nThen, we iterate from n down to 1, calculating the index of the current number in the available list to be included in the resulting permutation. We can calculate it as follows: `index = (k - 1) // factorials[i - 1]`. \n\nAfter, we update the value of k to: `k %= factorials[i - 1]`.\n\nAt each step, we append or concatenate the chosen number to the result and remove it from the list of available numbers.\n\nFinally, we return the result as a string."
        },
        "structure": {
            "c++": "#include <string>\n#include <vector>\n\nstd::string getPermutation(int n, int k) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic String getPermutation(int n, int k) \n    // Your code here\n}\n",
            "python": "def getPermutation(n, k):\n    # Your code here\n\n",
            "javascript": "function getPermutation(n, k) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <vector>\n#include <iostream>\n\nint main() {\n    int n = $args;\n    int k = $args;\n    std::string result = getPermutation(n, k);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public String getPermutation(int n, int k) {\n    List<Integer> nums = new ArrayList<>();\n    int[] factorials = new int[n];\n    StringBuilder sb = new StringBuilder();\n    int index;\n\n    factorials[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        nums.add(i);\n        factorials[i - 1] = i * factorials[i - 1];\n    }\n\n    k--;\n\n    for (int i = n; i >= 1; --i) {\n        index = k / factorials[i - 1];\n        k %= factorials[i - 1];\n        sb.append(nums.get(index));\n        nums.remove(index);\n    }\n\n    return sb.toString();\n}",
            "python": "if __name__ == \"__main__\":\n    input=$args\n    n = input[0]\n    k = input[1]\n    result = getPermutation(n, k)\n    print(result)"
        }
    },
    "65": {
        "title": "Valid Number",
        "description": "Given a string `s`, determine if it is a valid number. A valid number can be split into components in a specific order: a decimal number or an integer, followed by an optional 'e' or 'E' followed by an integer. A decimal number can have an optional sign character ('+' or '-'), followed by one of the following formats: one or more digits followed by a dot '.', one or more digits followed by a dot '.' and one or more digits, or a dot '.' followed by one or more digits. An integer can have an optional sign character followed by one or more digits. Return true if the given string is a valid number, otherwise return false.",
        "example": "Example:\n\nInput: \"0 \"\nOutput: true\n\nInput: \"e \"\nOutput: false\n\nInput: \". \"\nOutput: false\n\nExplanation:\n\nIn the first example, the string \"0 \" is a valid number as it is an integer.\n\nIn the second example, the string \"e \" is not a valid number as it does not have any components.\n\nIn the third example, the string \". \" is not a valid number as it does not have any components.",
        "level": "Medium",
        "tags": [
            "string",
            "parsing"
        ],
        "test_cases": {
            "inputs": [
                "\"2\"",
                "\"0089\"",
                "\"-0.1\"",
                "\"+3.14\"",
                "\"4.\"",
                "\"-.9\"",
                "\"2e10\"",
                "\"-90E3\"",
                "\"3e+7\"",
                "\"+6e-1\"",
                "\"53.5e93\"",
                "\"-123.456e789\"",
                "\"abc\"",
                "\"1a\"",
                "\"1e\"",
                "\"e3\"",
                "\"99e2.5\"",
                "\"--6\"",
                "\"-+3\"",
                "\"95a54e53\""
            ],
            "outputs": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "#include <regex>\n#include <string>\n\nbool isNumber(const std::string& s) {\n    std::regex pattern(\"^[-+]?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(e[-+]?[0-9]+)?$\");\n    return std::regex_match(s, pattern);\n}\n\n",
            "java": "import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Solution {\n    public boolean isNumber(String s) {\n        String pattern = \"^[-+]?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(e[-+]?[0-9]+)?$\";\n        return Pattern.matches(pattern, s);\n    }\n}\n\n",
            "python": "import re\n\ndef is_number(s: str) -> bool:\n    pattern = re.compile(r'^[-+]?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(e[-+]?[0-9]+)?$')\n    return bool(pattern.match(s))\n\n",
            "javascript": "function isNumber(s) {\n    const pattern = /^[-+]?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(e[-+]?[0-9]+)?$/;\n    return pattern.test(s);\n}\n\n",
            "explanation": "The algorithm utilizes regular expressions to match the input string against a pattern that defines a valid number. The regular expression in this case has the following meaning:\n\n1. `^`: Start of the string\n2. `[-+]?`: An optional sign, either `+` or `-`\n3. `(`: Start of a group that can be an integer or a decimal\n4. `(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))`: Here, a valid number can either have digits before and after the decimal point or only after the decimal point (or only before the decimal point with an optional decimal delimiter).\n5. `)`: End of the group\n6. `(e[-+]?[0-9]+)?`: An optional scientific notation part, which consists of the letter 'e', followed by an optional sign and at least one digit\n7. `$`: End of the string\n\nThe regex pattern is constructed to cover all cases according to the problem's description. The function then uses each language's regex library to match the input string against this pattern, returning `true` if the input string matches and `false` otherwise."
        },
        "structure": {
            "c++": "#include <regex>\n#include <string>\n\nbool isNumber(const std::string& s) \n    // Your code here\n}\n\n",
            "java": "import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Solution \n    // Your code here\n}\n\n",
            "python": "import re\n    # Your code here\n\n",
            "javascript": "function isNumber(s) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <regex>\n#include <string>\n#include <iostream>\n\nint main() {\n    std::string s = $args;\n    bool result = isNumber(s);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "java": "public boolean isNumber(String s) {\n        String pattern = \"^[-+]?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(e[-+]?[0-9]+)?$\";\n        return Pattern.matches(pattern, s);\n    }",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = is_number(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = isNumber(s);\n    console.log(result);\n}"
        }
    },
    "68": {
        "title": "Text Justification",
        "description": "Given an array of strings `words` and a width `maxWidth`, format the text such that each line has exactly `maxWidth` characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces `' '` when necessary so that each line has exactly `maxWidth` characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left-justified, and no extra space is inserted between words.",
        "example": "Example 1:\n\nInput: words = [\"This \",  \"is \",  \"an \",  \"example \",  \"of \",  \"text \",  \"justification. \"], maxWidth = 16\nOutput:\n[\"This    is    an \", \"example  of text \", \"justification.   \"]\n\nExample 2:\n\nInput: words = [\"What \", \"must \", \"be \", \"acknowledgment \", \"shall \", \"be \"], maxWidth = 16\nOutput:\n[\"What   must   be \", \"acknowledgment   \", \"shall be         \"]\n\nExample 3:\n\nInput: words = [\"Science \", \"is \", \"what \", \"we \", \"understand \", \"well \", \"enough \", \"to \", \"explain \", \"to \", \"a \", \"computer. \", \"Art \", \"is \", \"everything \", \"else \", \"we \", \"do \"], maxWidth = 20\nOutput:\n[\"Science  is  what we \", \"understand      well \", \"enough to explain to \", \"a  computer.  Art is \", \"everything  else  we \", \"do                   \"]",
        "level": "Medium",
        "tags": [
            "string",
            "greedy"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "This ",
                        "is ",
                        "an ",
                        "example ",
                        "of ",
                        "text ",
                        "justification. "
                    ],
                    16
                ],
                [
                    [
                        "What ",
                        "must ",
                        "be ",
                        "acknowledgment ",
                        "shall ",
                        "be "
                    ],
                    16
                ],
                [
                    [
                        "Science ",
                        "is ",
                        "what ",
                        "we ",
                        "understand ",
                        "well ",
                        "enough ",
                        "to ",
                        "explain ",
                        "to ",
                        "a ",
                        "computer. ",
                        "Art ",
                        "is ",
                        "everything ",
                        "else ",
                        "we ",
                        "do "
                    ],
                    20
                ]
            ],
            "outputs": [
                [
                    "This    is    an ",
                    "example  of text ",
                    "justification.   "
                ],
                [
                    "What   must   be ",
                    "acknowledgment   ",
                    "shall be         "
                ],
                [
                    "Science  is  what we ",
                    "understand      well ",
                    "enough to explain to ",
                    "a  computer.  Art is ",
                    "everything  else  we ",
                    "do                   "
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> fullJustify(vector<string>& words, int maxWidth) {\n    vector<string> result;\n    int idx = 0;\n    while (idx < words.size()) {\n        int totalChars = words[idx].size();\n        int last = idx + 1;\n        while (last < words.size()) {\n            if (totalChars + 1 + words[last].length() > maxWidth) break;\n            totalChars += 1 + words[last].length();\n            last++;\n        }\n        int gaps = last - idx - 1;\n        stringstream line;\n        if (last == words.size() || gaps == 0) {\n            for (int i = idx; i < last; i++) {\n                line << words[i];\n                if (i < last - 1) line << \" \";\n            }\n            line << string(maxWidth - line.str().size(), ' ');\n        } else {\n            int evenSpaces = (maxWidth - totalChars) / gaps;\n            int extraSpaces = (maxWidth - totalChars) % gaps;\n            for (int i = idx; i < last; i++) {\n                line << words[i];\n                if (i < last - 1) {\n                    line << string(evenSpaces + (i - idx < extraSpaces ? 1 : 0), ' ');\n                }\n            }\n        }\n        idx = last;\n        result.push_back(line.str());\n    }\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> fullJustify(String[] words, int maxWidth) {\n    List<String> result = new ArrayList<>();\n    int idx = 0;\n    while (idx < words.length) {\n        int totalChars = words[idx].length();\n        int last = idx + 1;\n        while (last < words.length) {\n            if (totalChars + 1 + words[last].length() > maxWidth) break;\n            totalChars += 1 + words[last].length();\n            last++;\n        }\n        int gaps = last - idx - 1;\n        StringBuilder line = new StringBuilder();\n        if (last == words.length || gaps == 0) {\n            for (int i = idx; i < last; i++) {\n                line.append(words[i]);\n                if (i < last - 1) line.append(\" \");\n            }\n            while (line.length() < maxWidth) line.append(\" \");\n        } else {\n            int evenSpaces = (maxWidth - totalChars) / gaps;\n            int extraSpaces = (maxWidth - totalChars) % gaps;\n            for (int i = idx; i < last; i++) {\n                line.append(words[i]);\n                if (i < last - 1) {\n                    line.append(\" \".repeat(evenSpaces + (i - idx < extraSpaces ? 1 : 0)));\n                }\n            }\n        }\n        idx = last;\n        result.add(line.toString());\n    }\n    return result;\n}\n",
            "python": "def fullJustify(words, maxWidth):\n    result = []\n    idx = 0\n    while idx < len(words):\n        total_chars = len(words[idx])\n        last = idx + 1\n        while last < len(words):\n            if total_chars + 1 + len(words[last]) > maxWidth:\n                break\n            total_chars += 1 + len(words[last])\n            last += 1\n        gaps = last - idx - 1\n        line = []\n        if last == len(words) or gaps == 0:\n            for i in range(idx, last):\n                line.append(words[i])\n                if i < last - 1:\n                    line.append(\" \")\n            while sum(len(w) for w in line) < maxWidth:\n                line.append(\" \")\n        else:\n            even_spaces = (maxWidth - total_chars) // gaps\n            extra_spaces = (maxWidth - total_chars) % gaps\n            for i in range(idx, last):\n                line.append(words[i])\n                if i < last - 1:\n                    line.append(\" \" * (even_spaces + (1 if i - idx < extra_spaces else 0)))\n        idx = last\n        result.append(\"\".join(line))\n    return result\n",
            "javascript": "function fullJustify(words, maxWidth) {\n    const result = [];\n    let idx = 0;\n    while (idx < words.length) {\n        let totalChars = words[idx].length;\n        let last = idx + 1;\n        while (last < words.length) {\n            if (totalChars + 1 + words[last].length > maxWidth) break;\n            totalChars += 1 + words[last].length;\n            last++;\n        }\n        const gaps = last - idx - 1;\n        let line = \"\";\n        if (last === words.length || gaps === 0) {\n            for (let i = idx; i < last; i++) {\n                line += words[i];\n                if (i < last - 1) line += \" \";\n            }\n            while (line.length < maxWidth) line += \" \";\n        } else {\n            const evenSpaces = Math.floor((maxWidth - totalChars) / gaps);\n            const extraSpaces = (maxWidth - totalChars) % gaps;\n            for (let i = idx; i < last; i++) {\n                line += words[i];\n                if (i < last - 1) {\n                    line += \" \".repeat(evenSpaces + (i - idx < extraSpaces ? 1 : 0));\n                }\n            }\n        }\n        idx = last;\n        result.push(line);\n    }\n    return result;\n}\n",
            "explanation": "The algorithm works as follows:\n1. Initialize an empty result list.\n2. Use `idx` to keep track of the start of the line. `idx` initially starts at 0, i.e., the first word.\n3. Calculate the total number of characters from `idx` to the last word in a line by testing whether adding the next word, with an extra space before it, would exceed `maxWidth`.\n4. Find the number of gaps in the current line. If it is the last line or there is only one word, left-justify the words and pad the remaining space with spaces.\n5. If it's not the last line, distribute spaces as evenly as possible between words: calculate `evenSpaces` and `extraSpaces`, and add an extra space to the left gaps until there are no more `extraSpaces`.\n6. Append the constructed line to the result list and update the `idx` to the start of the next line.\n7. Repeat steps 3 to 6 until reaching the last word.\n8. Return the result list."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> fullJustify(vector<string>& words, int maxWidth) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> fullJustify(String[] words, int maxWidth) \n    // Your code here\n}\n",
            "python": "def fullJustify(words, maxWidth):\n    # Your code here\n\n",
            "javascript": "function fullJustify(words, maxWidth) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> fullJustify(vector<string>& words, int maxWidth) {\n    vector<string> result;\n    int idx = 0;\n    while (idx < words.size()) {\n        int totalChars = words[idx].size();\n        int last = idx + 1;\n        while (last < words.size()) {\n            if (totalChars + 1 + words[last].length() > maxWidth) break;\n            totalChars += 1 + words[last].length();\n            last++;\n        }\n        int gaps = last - idx - 1;\n        stringstream line;\n        if (last == words.size() || gaps == 0) {\n            for (int i = idx; i < last; i++) {\n                line << words[i];\n                if (i < last - 1) line << \" \";\n            }\n            line << string(maxWidth - line.str().size(), ' ');\n        } else {\n            int evenSpaces = (maxWidth - totalChars) / gaps;\n            int extraSpaces = (maxWidth - totalChars) % gaps;\n            for (int i = idx; i < last; i++) {\n                line << words[i];\n                if (i < last - 1) {\n                    line << string(evenSpaces + (i - idx < extraSpaces ? 1 : 0), ' ');\n                }\n            }\n        }\n        idx = last;\n        result.push_back(line.str());\n    }\n    return result;\n}",
            "java": "public List<String> fullJustify(String[] words, int maxWidth) {\n    List<String> result = new ArrayList<>();\n    int idx = 0;\n    while (idx < words.length) {\n        int totalChars = words[idx].length();\n        int last = idx + 1;\n        while (last < words.length) {\n            if (totalChars + 1 + words[last].length() > maxWidth) break;\n            totalChars += 1 + words[last].length();\n            last++;\n        }\n        int gaps = last - idx - 1;\n        StringBuilder line = new StringBuilder();\n        if (last == words.length || gaps == 0) {\n            for (int i = idx; i < last; i++) {\n                line.append(words[i]);\n                if (i < last - 1) line.append(\" \");\n            }\n            while (line.length() < maxWidth) line.append(\" \");\n        } else {\n            int evenSpaces = (maxWidth - totalChars) / gaps;\n            int extraSpaces = (maxWidth - totalChars) % gaps;\n            for (int i = idx; i < last; i++) {\n                line.append(words[i]);\n                if (i < last - 1) {\n                    line.append(\" \".repeat(evenSpaces + (i - idx < extraSpaces ? 1 : 0)));\n                }\n            }\n        }\n        idx = last;\n        result.add(line.toString());\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    words = $args[0]\n    maxWidth = $args[1]\n    result = fullJustify(words, maxWidth)\n    print(result)",
            "javascript": "function fullJustify(words, maxWidth) {\n    const result = [];\n    let idx = 0;\n    while (idx < words.length) {\n        let totalChars = words[idx].length;\n        let last = idx + 1;\n        while (last < words.length) {\n            if (totalChars + 1 + words[last].length > maxWidth) break;\n            totalChars += 1 + words[last].length;\n            last++;\n        }\n        const gaps = last - idx - 1;\n        let line = \"\";\n        if (last === words.length || gaps === 0) {\n            for (let i = idx; i < last; i++) {\n                line += words[i];\n                if (i < last - 1) line += \" \";\n            }\n            while (line.length < maxWidth) line += \" \";\n        } else {\n            const evenSpaces = Math.floor((maxWidth - totalChars) / gaps);\n            const extraSpaces = (maxWidth - totalChars) % gaps;\n            for (let i = idx; i < last; i++) {\n                line += words[i];\n                if (i < last - 1) {\n                    line += \" \".repeat(evenSpaces + (i - idx < extraSpaces ? 1 : 0));\n                }\n            }\n        }\n        idx = last;\n        result.push(line);\n    }\n    return result;\n}"
        }
    },
    "69": {
        "title": "Square Root Rounded Down",
        "description": "Given a non-negative integer `x`, you need to find the square root of `x` rounded down to the nearest integer. The returned integer should be non-negative. You must not use any built-in exponent function or operator.",
        "example": "Example:\n\nInput: x = 4\nOutput: 2\nExplanation: The square root of 4 is 2, so we return 2.",
        "level": "Easy",
        "tags": [
            "Math",
            "Binary Search"
        ],
        "test_cases": {
            "inputs": [
                0,
                1,
                2,
                3,
                4,
                8,
                9,
                16,
                25,
                36,
                49,
                64,
                81,
                100,
                121,
                144,
                169,
                196,
                225,
                256
            ],
            "outputs": [
                0,
                1,
                1,
                1,
                2,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16
            ]
        },
        "sample_code": {
            "c++": "int mySqrt(int x) {\n    if (x == 0 || x == 1) return x;\n    int start = 1, end = x, ans;\n    while (start <= end) {\n        int mid = (start + end) / 2;\n        if (mid * mid == x) return mid;\n        if (mid * mid < x) {\n            start = mid + 1;\n            ans = mid;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}\n",
            "java": "public int mySqrt(int x) {\n    if (x == 0 || x == 1) return x;\n    int start = 1, end = x, ans = 0;\n    while (start <= end) {\n        int mid = (start + end) / 2;\n        if (mid * mid == x) return mid;\n        if (mid <= x / mid) {\n            start = mid + 1;\n            ans = mid;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}\n",
            "python": "def mySqrt(x):\n    if x == 0 or x == 1:\n        return x\n    start, end, ans = 1, x, 0\n    while start <= end:\n        mid = (start + end) // 2\n        if mid * mid == x:\n            return mid\n        if mid * mid < x:\n            start = mid + 1\n            ans = mid\n        else:\n            end = mid - 1\n    return ans\n",
            "javascript": "function mySqrt(x) {\n    if (x === 0 || x === 1) return x;\n    let start = 1, end = x, ans;\n    while (start <= end) {\n        let mid = Math.floor((start + end) / 2);\n        if (mid * mid === x) return mid;\n        if (mid * mid < x) {\n            start = mid + 1;\n            ans = mid;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}\n\n",
            "explanation": "The algorithm uses a binary search approach to find the integer square root of the given number `x`. It starts with the smallest possible answer (1) and the largest possible answer (x), updating the \"start\" and \"end\" positions based on whether the current midpoint squared is smaller or larger than x. The integer square root of the number is found when `mid * mid == x`, or when the closest integer (under or equal to x) value has been located. The binary search approach keeps the time complexity at O(log(x)), making it an efficient solution."
        },
        "structure": {
            "c++": "int mySqrt(int x) \n    // Your code here\n}\n",
            "java": "public int mySqrt(int x) \n    // Your code here\n}\n",
            "python": "def mySqrt(x):\n    # Your code here\n\n",
            "javascript": "function mySqrt(x) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int x = $args;\n    int result = mySqrt(x);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int mySqrt(int x) {\n    if (x == 0 || x == 1) return x;\n    int start = 1, end = x, ans = 0;\n    while (start <= end) {\n        int mid = (start + end) / 2;\n        if (mid * mid == x) return mid;\n        if (mid <= x / mid) {\n            start = mid + 1;\n            ans = mid;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}",
            "python": "if __name__ == \"__main__\":\n    x = $args\n    result = mySqrt(x)\n    print(result)"
        }
    },
    "71": {
        "title": "Simplified Canonical Path",
        "description": "Given an absolute path to a file or directory in a Unix-style file system, convert it to the simplified canonical path. In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names. The canonical path should have the following format: \n\n- The path starts with a single slash '/'. \n- Any two directories are separated by a single slash '/'. \n- The path does not end with a trailing '/'. \n- The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..').",
        "example": "Example:\n\nInput: path = \"/home/\"\nOutput: \"/home\"\nExplanation: Note that there is no trailing slash after the last directory name.",
        "level": "Medium",
        "tags": [
            "string",
            "parsing"
        ],
        "test_cases": {
            "inputs": [
                "\"/home/\"",
                "\"/../\"",
                "\"/home//foo/\"",
                "\"/a/./b/../../c/\"",
                "\"/a//b////c/d//././/..\"",
                "\"/a/../../b/../c//.//\"",
                "\"/a//b////c/d//././/..\"",
                "\"/a/../../b/../c//.//\"",
                "\"/a/./b/./c/./d/\"",
                "\"/a/../../../../../..\"",
                "\"/a/./b/./c/./d/\"",
                "\"/a/../../../../../..\"",
                "\"/a/./b/./c/./d/\"",
                "\"/a/../../../../../..\"",
                "\"/a/./b/./c/./d/\"",
                "\"/a/../../../../../..\"",
                "\"/a/./b/./c/./d/\"",
                "\"/a/../../../../../..\"",
                "\"/a/./b/./c/./d/\"",
                "\"/a/../../../../../..\""
            ],
            "outputs": [
                "\"/home\"",
                "\"/\"",
                "\"/home/foo\"",
                "\"/c\"",
                "\"/a/b/c\"",
                "\"/c\"",
                "\"/a/b/c\"",
                "\"/c\"",
                "\"/a/b/c/d\"",
                "\"/\"",
                "\"/a/b/c/d\"",
                "\"/\"",
                "\"/a/b/c/d\"",
                "\"/\"",
                "\"/a/b/c/d\"",
                "\"/\"",
                "\"/a/b/c/d\"",
                "\"/\"",
                "\"/a/b/c/d\"",
                "\"/\""
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <vector>\n#include <sstream>\n\nstd::string simplifyPath(std::string path) {\n    std::vector<std::string> stack;\n    std::istringstream ss{path};\n    std::string part;\n\n    while (std::getline(ss, part, '/')) {\n        if (part.empty() || part == \".\") continue;\n        if (part == \"..\") {\n            if (!stack.empty()) stack.pop_back();\n        } else {\n            stack.push_back(part);\n        }\n    }\n\n    std::string canonicalPath;\n    for (const auto &piece : stack) {\n        canonicalPath += '/' + piece;\n    }\n    return stack.empty() ? \"/\" : canonicalPath;\n}\n",
            "java": "import java.util.LinkedList;\n\npublic String simplifyPath(String path) {\n    String[] parts = path.split(\"/\");\n    LinkedList<String> stack = new LinkedList<>();\n\n    for (String part : parts) {\n        if (part.isEmpty() || part.equals(\".\")) continue;\n        if (part.equals(\"..\")) {\n            if (!stack.isEmpty()) stack.removeLast();\n        } else {\n            stack.addLast(part);\n        }\n    }\n\n    StringBuilder canonicalPath = new StringBuilder();\n    for (String piece : stack) {\n        canonicalPath.append('/').append(piece);\n    }\n    return stack.isEmpty() ? \"/\" : canonicalPath.toString();\n}\n",
            "python": "def simplifyPath(path: str) -> str:\n    stack = []\n    parts = path.split(\"/\")\n\n    for part in parts:\n        if not part or part == \".\":\n            continue\n        if part == \"..\":\n            if stack:\n                stack.pop()\n        else:\n            stack.append(part)\n\n    return \"/\" + \"/\".join(stack)\n",
            "javascript": "function simplifyPath(path) {\n    let stack = [];\n    let parts = path.split(\"/\");\n\n    for (let part of parts) {\n        if (!part || part === \".\") continue;\n        if (part === \"..\") {\n            if (stack.length) stack.pop();\n        } else {\n            stack.push(part);\n        }\n    }\n\n    return \"/\" + stack.join(\"/\");\n}\n",
            "explanation": "The algorithm uses a stack to keep track of the directory hierarchy. It starts by splitting the input string by '/', iterating over each part, and processing them according to the following rules:\n1. If the part is empty or \".\", skip it.\n2. If the part is \"..\", pop off the top element of the stack (if it's non-empty).\n3. Otherwise, push the part onto the stack.\n\nAfter processing all parts, concatenate the elements in the stack separated by '/' and return the canonical path.\n\nThe implementations are very similar across the four languages, with differences stemming primarily from the syntax and conventions of each language."
        },
        "structure": {
            "c++": "#include <string>\n#include <vector>\n#include <sstream>\n\nstd::string simplifyPath(std::string path) \n    // Your code here\n}\n",
            "java": "import java.util.LinkedList;\n\npublic String simplifyPath(String path) \n    // Your code here\n}\n",
            "python": "def simplifyPath(path: str) -> str:\n    # Your code here\n\n",
            "javascript": "function simplifyPath(path) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <vector>\n#include <sstream>\n\nint main() {\n    std::string path = $args;\n    std::string result = simplifyPath(path);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    path = $args\n    result = simplifyPath(path)\n    print(result)"
        }
    },
    "72": {
        "title": "Minimum Edit Distance",
        "description": "Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`. You have the following three operations permitted on a word: Insert a character, Delete a character, Replace a character.",
        "example": "Example:\n\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: horse -> rorse (replace 'h' with 'r'), rorse -> rose (remove 'r'), rose -> ros (remove 'e')",
        "level": "Medium",
        "tags": [
            "Dynamic Programming",
            "String"
        ],
        "test_cases": {
            "inputs": [
                [
                    "horse",
                    "ros"
                ],
                [
                    "intention",
                    "execution"
                ],
                [
                    "kitten",
                    "sitting"
                ],
                [
                    "abc",
                    "def"
                ],
                [
                    "abcdef",
                    "abcdef"
                ],
                [
                    "abcdef",
                    "fedcba"
                ],
                [
                    "abcdef",
                    "abc"
                ],
                [
                    "abc",
                    "abcdef"
                ],
                [
                    "",
                    ""
                ],
                [
                    "abc",
                    ""
                ],
                [
                    "",
                    "abc"
                ],
                [
                    "a",
                    "a"
                ],
                [
                    "a",
                    "b"
                ],
                [
                    "a",
                    ""
                ],
                [
                    "",
                    "a"
                ],
                [
                    "abcdefghijklmnopqrstuvwxyz",
                    "abcdefghijklmnopqrstuvwxyz"
                ],
                [
                    "abcdefghijklmnopqrstuvwxyz",
                    "zyxwvutsrqponmlkjihgfedcba"
                ],
                [
                    "abcdefghijklmnopqrstuvwxyz",
                    "abc"
                ],
                [
                    "abc",
                    "abcdefghijklmnopqrstuvwxyz"
                ],
                [
                    "abc",
                    "cba"
                ]
            ],
            "outputs": [
                3,
                5,
                3,
                3,
                0,
                6,
                3,
                3,
                0,
                3,
                3,
                0,
                1,
                1,
                1,
                0,
                0,
                23,
                23,
                23,
                2
            ]
        },
        "sample_code": {
            "c++": "int minDistance(string word1, string word2) {\n    int m = word1.size();\n    int n = word2.size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    \n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0) {\n                dp[i][j] = j;\n            } else if (j == 0) {\n                dp[i][j] = i;\n            } else if (word1[i - 1] == word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n",
            "java": "public int minDistance(String word1, String word2) {\n    int m = word1.length();\n    int n = word2.length();\n    int[][] dp = new int[m + 1][n + 1];\n    \n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0) {\n                dp[i][j] = j;\n            } else if (j == 0) {\n                dp[i][j] = i;\n            } else if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n",
            "python": "def minDistance(word1: str, word2: str) -> int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n    \n    return dp[m][n]\n",
            "javascript": "function minDistance(word1, word2) {\n    const m = word1.length;\n    const n = word2.length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    \n    for (let i = 0; i <= m; i++) {\n        for (let j = 0; j <= n; j++) {\n            if (i === 0) {\n                dp[i][j] = j;\n            } else if (j === 0) {\n                dp[i][j] = i;\n            } else if (word1[i - 1] === word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n",
            "explanation": "The algorithm used is dynamic programming. We create a 2D table dp with dimensions (m+1) x (n+1), where m is the length of word1 and n is the length of word2. Each cell dp[i][j] represents the minimum number of operations required to convert word1[0...i-1] to word2[0...j-1].\n\nFor each cell, we have the following conditions:\n1. If either i or j is 0, it means one of the strings is empty, so the minimum number of operations needed is the length of the non-empty string (i or j).\n2. If the current characters of the two strings are equal (word1[i-1] == word2[j-1]), we don't have to do anything, so dp[i][j] = dp[i-1][j-1].\n3. If the current characters are different, we take the minimum of the following and add 1:\n    a. dp[i-1][j]: Delete operation\n    b. dp[i][j-1]: Insert operation\n    c. dp[i-1][j-1]: Replace operation\n\nAfter filling the table, the minimum number of operations will be at dp[m][n]."
        },
        "structure": {
            "c++": "int minDistance(string word1, string word2) \n    // Your code here\n}\n",
            "java": "public int minDistance(String word1, String word2) \n    // Your code here\n}\n",
            "python": "def minDistance(word1: str, word2: str) -> int:\n    # Your code here\n\n",
            "javascript": "function minDistance(word1, word2) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int minDistance(string word1, string word2) {\n    int m = word1.size();\n    int n = word2.size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    \n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0) {\n                dp[i][j] = j;\n            } else if (j == 0) {\n                dp[i][j] = i;\n            } else if (word1[i - 1] == word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}",
            "java": "public int minDistance(String word1, String word2) {\n    int m = word1.length();\n    int n = word2.length();\n    int[][] dp = new int[m + 1][n + 1];\n    \n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0) {\n                dp[i][j] = j;\n            } else if (j == 0) {\n                dp[i][j] = i;\n            } else if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    word1 = inputs[0]\n    word2 = inputs[1]\n    result = minDistance(word1, word2)\n    print(result)",
            "javascript": "function minDistance(word1, word2) {\n    const m = word1.length;\n    const n = word2.length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    \n    for (let i = 0; i <= m; i++) {\n        for (let j = 0; j <= n; j++) {\n            if (i === 0) {\n                dp[i][j] = j;\n            } else if (j === 0) {\n                dp[i][j] = i;\n            } else if (word1[i - 1] === word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}"
        }
    },
    "75": {
        "title": "Sort Colors",
        "description": "Given an array `nums` with `n` objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively. You must solve this problem without using the library's sort function.",
        "example": "Example:\n\nInput: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]\n\nInput: nums = [2,0,1]\nOutput: [0,1,2]",
        "level": "Medium",
        "tags": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    0,
                    2,
                    1,
                    1,
                    0
                ],
                [
                    2,
                    0,
                    1
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    0,
                    1,
                    2
                ],
                [
                    2,
                    1,
                    0
                ],
                [
                    1,
                    0,
                    2
                ],
                [
                    0,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    0
                ],
                [
                    2,
                    0,
                    1,
                    0,
                    2,
                    1
                ],
                [
                    1,
                    0,
                    2,
                    0,
                    1,
                    2
                ],
                [
                    2,
                    1,
                    0,
                    1,
                    2,
                    0
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                [
                    2,
                    2,
                    1,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    1,
                    0,
                    0,
                    2,
                    2
                ],
                [
                    0,
                    1,
                    2,
                    2,
                    1,
                    0
                ],
                [
                    2,
                    1,
                    0,
                    0,
                    1,
                    2
                ],
                [
                    1,
                    2,
                    0,
                    0,
                    2,
                    1
                ],
                [
                    0,
                    2,
                    1,
                    1,
                    0,
                    2
                ]
            ],
            "outputs": [
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                [
                    0,
                    1,
                    2
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    0,
                    1,
                    2
                ],
                [
                    0,
                    1,
                    2
                ],
                [
                    0,
                    1,
                    2
                ],
                [
                    0,
                    1,
                    2
                ],
                [
                    0,
                    1,
                    2
                ],
                [
                    0,
                    0,
                    0,
                    1,
                    1,
                    2
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2
                ]
            ]
        },
        "sample_code": {
            "c++": "void sortColors(vector<int>& nums) {\n    int red = 0, white = 0, blue = nums.size() - 1;\n    while (white <= blue) {\n        if (nums[white] == 0) {\n            swap(nums[red++], nums[white++]);\n        } else if (nums[white] == 1) {\n            white++;\n        } else {\n            swap(nums[white], nums[blue--]);\n        }\n    }\n}\n",
            "java": "public void sortColors(int[] nums) {\n    int red = 0, white = 0, blue = nums.length - 1;\n    while (white <= blue) {\n        if (nums[white] == 0) {\n            int temp = nums[red];\n            nums[red++] = nums[white];\n            nums[white++] = temp;\n        } else if (nums[white] == 1) {\n            white++;\n        } else {\n            int temp = nums[white];\n            nums[white] = nums[blue];\n            nums[blue--] = temp;\n        }\n    }\n}\n",
            "python": "def sortColors(nums: list[int]) -> None:\n    red, white, blue = 0, 0, len(nums) - 1\n    while white <= blue:\n        if nums[white] == 0:\n            nums[red], nums[white] = nums[white], nums[red]\n            red += 1\n            white += 1\n        elif nums[white] == 1:\n            white += 1\n        else:\n            nums[white], nums[blue] = nums[blue], nums[white]\n            blue -= 1\n",
            "javascript": "function sortColors(nums) {\n    let red = 0, white = 0, blue = nums.length - 1;\n    while (white <= blue) {\n        if (nums[white] === 0) {\n            [nums[red], nums[white]] = [nums[white], nums[red]];\n            red++;\n            white++;\n        } else if (nums[white] === 1) {\n            white++;\n        } else {\n            [nums[white], nums[blue]] = [nums[blue], nums[white]];\n            blue--;\n        }\n    }\n}\n",
            "explanation": "The algorithm can be explained using three pointers: `red`, `white`, and `blue`. `red` is responsible for tracking the position where the next 0 should be moved to, starting from the beginning of the array. Likewise, `blue` is responsible for tracking the position where the next 2 should be swapped to, starting from the end of the array. `white` is responsible for iterating through the array.\n\nWhile `white` is less than or equal to `blue`, check the current `nums[white]` value. If it is 0, swap it with the value at index `red`, and increment both `red` and `white`. If it is 1, simply increment `white`. If it is 2, swap the value at index `white` with the value at index `blue`, and decrement `blue` without incrementing `white` since the newly swapped value at index `white` might be 0 or 2.\n\nThis will sort the colors in the required order with a linear-time complexity, as we only go through the array once with the `white` pointer. Also, it sorts the colors in-place without the need for additional storage."
        },
        "structure": {
            "c++": "void sortColors(vector<int>& nums) \n    // Your code here\n}\n",
            "java": "public void sortColors(int[] nums) \n    // Your code here\n}\n",
            "python": "def sortColors(nums: List[int]) -> None:\n    # Your code here\n\n",
            "javascript": "function sortColors(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "void sortColors(vector<int>& nums) {\n    int red = 0, white = 0, blue = nums.size() - 1;\n    while (white <= blue) {\n        if (nums[white] == 0) {\n            swap(nums[red++], nums[white++]);\n        } else if (nums[white] == 1) {\n            white++;\n        } else {\n            swap(nums[white], nums[blue--]);\n        }\n    }\n}",
            "java": "public void sortColors(int[] nums) {\n    int red = 0, white = 0, blue = nums.length - 1;\n    while (white <= blue) {\n        if (nums[white] == 0) {\n            int temp = nums[red];\n            nums[red++] = nums[white];\n            nums[white++] = temp;\n        } else if (nums[white] == 1) {\n            white++;\n        } else {\n            int temp = nums[white];\n            nums[white] = nums[blue];\n            nums[blue--] = temp;\n        }\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    sortColors(nums)\n    print(nums)"
        }
    },
    "76": {
        "title": "Minimum Window Substring",
        "description": "Given two strings `s` and `t` of lengths `m` and `n` respectively, find the minimum window substring of `s` that contains all the characters from `t`. If there is no such substring, return an empty string.",
        "example": "Example 1:\n\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n\nExample 2:\n\nInput: s = \"a\", t = \"a\"\nOutput: \"a\"\nExplanation: The entire string s is the minimum window.\n\nExample 3:\n\nInput: s = \"a\", t = \"aa\"\nOutput: \"\"\nExplanation: Both 'a's from t must be included in the window. Since the largest window of s only has one 'a', return empty string.",
        "level": "Medium",
        "tags": [
            "string",
            "sliding window",
            "two pointers"
        ],
        "test_cases": {
            "inputs": [
                [
                    "ADOBECODEBANC",
                    "ABC"
                ],
                [
                    "a",
                    "a"
                ],
                [
                    "a",
                    "aa"
                ],
                [
                    "ab",
                    "a"
                ],
                [
                    "ab",
                    "b"
                ],
                [
                    "abc",
                    "ab"
                ],
                [
                    "abc",
                    "ac"
                ],
                [
                    "abc",
                    "abc"
                ],
                [
                    "abc",
                    "abcd"
                ],
                [
                    "aabbcc",
                    "abc"
                ],
                [
                    "aabbcc",
                    "abcc"
                ],
                [
                    "aabbcc",
                    "aabbcc"
                ],
                [
                    "aabbcc",
                    "aabbccd"
                ],
                [
                    "aabbcc",
                    "aabbccdd"
                ],
                [
                    "aabbcc",
                    "aabbccdde"
                ],
                [
                    "aabbcc",
                    "aabbccddeeff"
                ],
                [
                    "aabbcc",
                    "aabbccddeeffg"
                ],
                [
                    "aabbcc",
                    "aabbccddeeffgg"
                ],
                [
                    "aabbcc",
                    "aabbccddeeffggh"
                ],
                [
                    "aabbcc",
                    "aabbccddeeffgghi"
                ]
            ],
            "outputs": [
                "BANC",
                "a",
                "",
                "a",
                "b",
                "ab",
                "abc",
                "abc",
                "",
                "aabbcc",
                "abcc",
                "aabbcc",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <unordered_map>\n\nstd::string min_window(std::string s, std::string t) {\n    std::unordered_map<char, int> need, window;\n    for (char c : t) need[c]++;\n    \n    int left = 0, right = 0;\n    int valid = 0;\n    int start = 0, length = INT_MAX;\n\n    while (right < s.length()) {\n        char c = s[right];\n        right++;\n        if (need.count(c)) {\n            window[c]++;\n            if (window[c] <= need[c]) valid++;\n        }\n\n        while (valid == t.length()) {\n            if (right - left < length) {\n                start = left;\n                length = right - left;\n            }\n\n            char d = s[left];\n            left++;\n            if (need.count(d)) {\n                if (window[d] <= need[d]) valid--;\n                window[d]--;\n            }\n        }\n    }\n    return length == INT_MAX ? \"\" : s.substr(start, length);\n}\n\n",
            "java": "import java.util.HashMap;\n\npublic String minWindow(String s, String t) {\n    HashMap<Character, Integer> need = new HashMap<>();\n    HashMap<Character, Integer> window = new HashMap<>();\n    for (char c : t.toCharArray()) need.put(c, need.getOrDefault(c, 0) + 1);\n    \n    int left = 0, right = 0;\n    int valid = 0;\n    int start = 0, length = Integer.MAX_VALUE;\n\n    while (right < s.length()) {\n        char c = s.charAt(right);\n        right++;\n        if (need.containsKey(c)) {\n            window.put(c, window.getOrDefault(c, 0) + 1);\n            if (window.get(c) <= need.get(c)) valid++;\n        }\n\n        while (valid == t.length()) {\n            if (right - left < length) {\n                start = left;\n                length = right - left;\n            }\n\n            char d = s.charAt(left);\n            left++;\n            if (need.containsKey(d)) {\n                if (window.get(d) <= need.get(d)) valid--;\n                window.put(d, window.get(d) - 1);\n            }\n        }\n    }\n    return length == Integer.MAX_VALUE ? \"\" : s.substring(start, start + length);\n}\n\n",
            "python": "from collections import Counter\n\ndef min_window(s, t):\n    need = Counter(t)\n    window = {}\n    \n    left = 0\n    right = 0\n    valid = 0\n    start = 0\n    length = float('inf')\n\n    while right < len(s):\n        c = s[right]\n        right += 1\n        if c in need:\n            window[c] = window.get(c, 0) + 1\n            if window[c] <= need[c]:\n                valid += 1\n\n        while valid == len(t):\n            if right - left < length:\n                start = left\n                length = right - left\n\n            d = s[left]\n            left += 1\n            if d in need:\n                if window[d] <= need[d]:\n                    valid -= 1\n                window[d] -= 1\n\n    return \"\" if length == float('inf') else s[start : start + length]\n\n",
            "javascript": "function minWindow(s, t) {\n    const need = new Map();\n    const window = new Map();\n\n    for (const c of t) {\n        need.set(c, (need.get(c) || 0) + 1);\n    }\n    \n    let left = 0, right = 0;\n    let valid = 0;\n    let start = 0, length = Infinity;\n\n    while (right < s.length) {\n        const c = s[right];\n        right++;\n        if (need.has(c)) {\n            window.set(c, (window.get(c) || 0) + 1);\n            if (window.get(c) <= need.get(c)) valid++;\n        }\n\n        while (valid === t.length) {\n            if (right - left < length) {\n                start = left;\n                length = right - left;\n            }\n\n            const d = s[left];\n            left++;\n            if (need.has(d)) {\n                if (window.get(d) <= need.get(d)) valid--;\n                window.set(d, window.get(d) - 1);\n            }\n        }\n    }\n    return length === Infinity ? \"\" : s.substring(start, start + length);\n}\n\n",
            "explanation": "The algorithm uses a sliding window approach to find the minimum window substring. We use two pointers, `left` and `right`, to represent the current window. \n\n1. Initialize an unordered_map or dictionary for `need` to store characters and their counts in `t`, and another for `window` to store characters and their counts in the current window.\n2. Initialize `left` and `right` pointers, `valid` counter for keeping track of characters satisfying the criteria, and `start` and `length` for holding the answer substring information.\n3. Iterate through the string `s` using the `right` pointer, and:\n    - If the current character exists in the `need` map, update the count of the character in the `window` map, and increment `valid` if the count in the window is less than or equal to the count in need.\n4. Check the validity by comparing `valid` with the length of `t`.\n    - If valid, update the answer substring's `start` and `length` if the current window's length is less than the current minimum.\n    - Then, increment the `left` pointer to slide the window until the current character count in the window goes below the count in `need`. Update the `valid` counter accordingly.\n5. Return the answer substring, or empty string if no window was found."
        },
        "structure": {
            "c++": "#include <string>\n#include <unordered_map>\n\nstd::string min_window(std::string s, std::string t) \n    // Your code here\n}\n\n",
            "java": "import java.util.HashMap;\n\npublic String minWindow(String s, String t) \n    // Your code here\n}\n\n",
            "python": "from collections import Counter\n    # Your code here\n\n",
            "javascript": "function minWindow(s, t) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <unordered_map>\n\nint main() {\n    std::string s = $args;\n    std::string t = $args;\n    std::string result = min_window(s, t);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public String minWindow(String s, String t) {\n    HashMap<Character, Integer> need = new HashMap<>();\n    HashMap<Character, Integer> window = new HashMap<>();\n    for (char c : t.toCharArray()) need.put(c, need.getOrDefault(c, 0) + 1);\n    \n    int left = 0, right = 0;\n    int valid = 0;\n    int start = 0, length = Integer.MAX_VALUE;\n\n    while (right < s.length()) {\n        char c = s.charAt(right);\n        right++;\n        if (need.containsKey(c)) {\n            window.put(c, window.getOrDefault(c, 0) + 1);\n            if (window.get(c) <= need.get(c)) valid++;\n        }\n\n        while (valid == t.length()) {\n            if (right - left < length) {\n                start = left;\n                length = right - left;\n            }\n\n            char d = s.charAt(left);\n            left++;\n            if (need.containsKey(d)) {\n                if (window.get(d) <= need.get(d)) valid--;\n                window.put(d, window.get(d) - 1);\n            }\n        }\n    }\n    return length == Integer.MAX_VALUE ? \"\" : s.substring(start, start + length);\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    s = inputs[0]\n    t = inputs[1]\n    result = min_window(s, t)\n    print(result)",
            "javascript": "function minWindow(s, t) {\n    const need = new Map();\n    const window = new Map();\n\n    for (const c of t) {\n        need.set(c, (need.get(c) || 0) + 1);\n    }\n    \n    let left = 0, right = 0;\n    let valid = 0;\n    let start = 0, length = Infinity;\n\n    while (right < s.length) {\n        const c = s[right];\n        right++;\n        if (need.has(c)) {\n            window.set(c, (window.get(c) || 0) + 1);\n            if (window.get(c) <= need.get(c)) valid++;\n        }\n\n        while (valid === t.length) {\n            if (right - left < length) {\n                start = left;\n                length = right - left;\n            }\n\n            const d = s[left];\n            left++;\n            if (need.has(d)) {\n                if (window.get(d) <= need.get(d)) valid--;\n                window.set(d, window.get(d) - 1);\n            }\n        }\n    }\n    return length === Infinity ? \"\" : s.substring(start, start + length);\n}"
        }
    },
    "77": {
        "title": "Combinations of K Numbers",
        "description": "Given two integers `n` and `k`, return all possible combinations of `k` numbers chosen from the range `[1, n]`. You may return the answer in any order.",
        "example": "Example:\n\nInput: n = 4, k = 2\nOutput: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nExplanation: There are 4 choose 2 = 6 total combinations. Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.",
        "level": "Medium",
        "tags": [
            "Array",
            "Backtracking"
        ],
        "test_cases": {
            "inputs": [
                [
                    4,
                    2
                ],
                [
                    1,
                    1
                ],
                [
                    5,
                    3
                ],
                [
                    10,
                    4
                ],
                [
                    3,
                    2
                ],
                [
                    8,
                    1
                ],
                [
                    20,
                    5
                ],
                [
                    2,
                    2
                ],
                [
                    6,
                    4
                ],
                [
                    15,
                    3
                ],
                [
                    7,
                    1
                ],
                [
                    12,
                    2
                ],
                [
                    18,
                    6
                ],
                [
                    9,
                    3
                ],
                [
                    11,
                    1
                ],
                [
                    14,
                    4
                ],
                [
                    19,
                    2
                ],
                [
                    13,
                    5
                ],
                [
                    16,
                    3
                ],
                [
                    17,
                    1
                ]
            ],
            "outputs": [
                [
                    [
                        1,
                        2
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        3,
                        4
                    ]
                ],
                [
                    [
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        1,
                        2,
                        4
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        1,
                        3,
                        4
                    ],
                    [
                        1,
                        3,
                        5
                    ],
                    [
                        1,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4
                    ],
                    [
                        2,
                        3,
                        5
                    ],
                    [
                        2,
                        4,
                        5
                    ],
                    [
                        3,
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        1,
                        2,
                        3,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        6
                    ],
                    [
                        1,
                        2,
                        4,
                        5
                    ],
                    [
                        1,
                        2,
                        4,
                        6
                    ],
                    [
                        1,
                        2,
                        5,
                        6
                    ],
                    [
                        1,
                        3,
                        4,
                        5
                    ],
                    [
                        1,
                        3,
                        4,
                        6
                    ],
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    [
                        1,
                        4,
                        5,
                        6
                    ],
                    [
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4,
                        6
                    ],
                    [
                        2,
                        3,
                        5,
                        6
                    ],
                    [
                        2,
                        4,
                        5,
                        6
                    ],
                    [
                        3,
                        4,
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        3
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        3
                    ],
                    [
                        4
                    ],
                    [
                        5
                    ],
                    [
                        6
                    ],
                    [
                        7
                    ],
                    [
                        8
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        6,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        6,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        6,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        7,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        7,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        8,
                        9
                    ],
                    [
                        1,
                        2,
                        4,
                        5,
                        6
                    ],
                    [
                        1,
                        2,
                        4,
                        5,
                        7
                    ],
                    [
                        1,
                        2,
                        4,
                        5,
                        8
                    ],
                    [
                        1,
                        2,
                        4,
                        5,
                        9
                    ],
                    [
                        1,
                        2,
                        4,
                        6,
                        7
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        1,
                        3
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        1,
                        2,
                        3,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        10
                    ],
                    [
                        1,
                        2,
                        4,
                        5
                    ],
                    [
                        1,
                        2,
                        4,
                        6
                    ],
                    [
                        1,
                        2,
                        4,
                        7
                    ],
                    [
                        1,
                        2,
                        4,
                        8
                    ],
                    [
                        1,
                        2,
                        4,
                        9
                    ],
                    [
                        1,
                        2,
                        4,
                        10
                    ],
                    [
                        1,
                        2,
                        5,
                        6
                    ],
                    [
                        1,
                        2,
                        5,
                        7
                    ],
                    [
                        1,
                        2,
                        5,
                        8
                    ],
                    [
                        1,
                        2,
                        5,
                        9
                    ],
                    [
                        1,
                        2,
                        5,
                        10
                    ],
                    [
                        1,
                        2,
                        6,
                        7
                    ],
                    [
                        1,
                        2,
                        6,
                        8
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        3
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        1,
                        5
                    ],
                    [
                        1,
                        6
                    ],
                    [
                        1,
                        7
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        3,
                        5
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        4,
                        6
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        5,
                        7
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        6,
                        8
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        7,
                        9
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        8,
                        10
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        9,
                        11
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        10,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        7,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        7,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        7,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        8,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        8,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        9,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        6,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        6,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        6,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        6,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        7,
                        8
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        2
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        1,
                        2,
                        3,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        11
                    ],
                    [
                        1,
                        2,
                        3,
                        12
                    ],
                    [
                        1,
                        2,
                        3,
                        13
                    ],
                    [
                        1,
                        2,
                        3,
                        14
                    ],
                    [
                        1,
                        2,
                        3,
                        15
                    ],
                    [
                        1,
                        2,
                        3,
                        16
                    ],
                    [
                        1,
                        2,
                        3,
                        17
                    ],
                    [
                        1,
                        2,
                        3,
                        18
                    ],
                    [
                        1,
                        2,
                        3,
                        19
                    ],
                    [
                        1,
                        2,
                        3,
                        20
                    ],
                    [
                        1,
                        2,
                        4,
                        5
                    ],
                    [
                        1,
                        2,
                        4,
                        6
                    ],
                    [
                        1,
                        2,
                        4,
                        7
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        3
                    ],
                    [
                        4
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        11
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        12
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        13
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        14
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        15
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        16
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        17
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        18
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        19
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        20
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        1,
                        5
                    ],
                    [
                        1,
                        6
                    ],
                    [
                        1,
                        7
                    ],
                    [
                        1,
                        8
                    ],
                    [
                        1,
                        9
                    ],
                    [
                        1,
                        10
                    ],
                    [
                        1,
                        11
                    ],
                    [
                        1,
                        12
                    ],
                    [
                        1,
                        13
                    ],
                    [
                        1,
                        14
                    ],
                    [
                        1,
                        15
                    ],
                    [
                        1,
                        16
                    ],
                    [
                        1,
                        17
                    ],
                    [
                        1,
                        18
                    ],
                    [
                        1,
                        19
                    ],
                    [
                        1,
                        20
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        11
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        12
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        13
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        14
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        15
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        16
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        17
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        18
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        19
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        20
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        7,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        7,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        7,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        7,
                        11
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        7,
                        12
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        7,
                        13
                    ]
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nvoid backtrack(int n, int k, int start, std::vector<int>& current, std::vector<std::vector<int>>& result) {\n    if (current.size() == k) {\n        result.push_back(current);\n        return;\n    }\n\n    for (int i = start; i <= n; ++i) {\n        current.push_back(i);\n        backtrack(n, k, i + 1, current, result);\n        current.pop_back();\n    }\n}\n\nstd::vector<std::vector<int>> combine(int n, int k) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> current;\n    backtrack(n, k, 1, current, result);\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> combine(int n, int k) {\n    List<List<Integer>> result = new ArrayList<>();\n    backtrack(n, k, 1, new ArrayList<>(), result);\n    return result;\n}\n\nprivate void backtrack(int n, int k, int start, List<Integer> current, List<List<Integer>> result) {\n    if (current.size() == k) {\n        result.add(new ArrayList<>(current));\n        return;\n    }\n\n    for (int i = start; i <= n; i++) {\n        current.add(i);\n        backtrack(n, k, i + 1, current, result);\n        current.remove(current.size() - 1);\n    }\n}\n",
            "python": "from typing import List\n\ndef combine(n: int, k: int) -> List[List[int]]:\n    def backtrack(start, current_combination):\n        if len(current_combination) == k:\n            result.append(current_combination[:])\n\n        for i in range(start, n + 1):\n            current_combination.append(i)\n            backtrack(i + 1, current_combination)\n            current_combination.pop()\n\n    result = []\n    backtrack(1, [])\n    return result\n",
            "javascript": "function combine(n, k) {\n    const result = [];\n    backtrack(n, k, 1, [], result);\n    return result;\n}\n\nfunction backtrack(n, k, start, current, result) {\n    if (current.length === k) {\n        result.push([...current]);\n        return;\n    }\n\n    for (let i = start; i <= n; i++) {\n        current.push(i);\n        backtrack(n, k, i + 1, current, result);\n        current.pop();\n    }\n}\n",
            "explanation": "The algorithm uses a backtracking approach to generate all possible combinations of k numbers out of the range [1, n]. We create a helper function called `backtrack` that recursively generates combinations. In this helper function, we have a base case where if the size of the current combination is equal to k, we add it to the result. Otherwise, we iterate through the numbers from the start index to n, add the current number to the current combination, and make a recursive call with an incremented start index. After the call, we \"undo\" the decision by removing the number from the current combination (backtracking).\n\nThe main function initializes an empty result list, calls the `backtrack` function with a start index of 1 and an empty current combination list, and then returns the result list."
        },
        "structure": {
            "c++": "#include <vector>\n\nvoid backtrack(int n, int k, int start, std::vector<int>& current, std::vector<std::vector<int>>& result) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> combine(int n, int k) \n    // Your code here\n}\n",
            "python": "from typing import List\n    # Your code here\n\n",
            "javascript": "function combine(n, k) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nvoid backtrack(int n, int k, int start, std::vector<int>& current, std::vector<std::vector<int>>& result) {\n    if (current.size() == k) {\n        result.push_back(current);\n        return;\n    }\n\n    for (int i = start; i <= n; ++i) {\n        current.push_back(i);\n        backtrack(n, k, i + 1, current, result);\n        current.pop_back();\n    }\n}\n\nstd::vector<std::vector<int>> combine(int n, int k) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> current;\n    backtrack(n, k, 1, current, result);\n    return result;\n}\n\nint main() {\n    int n = $args;\n    int k = $args;\n    std::vector<std::vector<int>> result = combine(n, k);\n    for (const auto& combination : result) {\n        for (const auto& num : combination) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}",
            "java": "public List<List<Integer>> combine(int n, int k) {\n    List<List<Integer>> result = new ArrayList<>();\n    backtrack(n, k, 1, new ArrayList<>(), result);\n    return result;\n}\n\nprivate void backtrack(int n, int k, int start, List<Integer> current, List<List<Integer>> result) {\n    if (current.size() == k) {\n        result.add(new ArrayList<>(current));\n        return;\n    }\n\n    for (int i = start; i <= n; i++) {\n        current.add(i);\n        backtrack(n, k, i + 1, current, result);\n        current.remove(current.size() - 1);\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    n = inputs[0]\n    k = inputs[1]\n    result = combine(n, k)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const k = $args;\n    const result = combine(n, k);\n    console.log(result);\n}"
        }
    },
    "78": {
        "title": "Subset Power Set",
        "description": "Given an integer array `nums` of **unique** elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.",
        "example": "Example 1:\n\nInput: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\nExample 2:\n\nInput: nums = [0]\nOutput: [[],[0]]",
        "level": "Medium",
        "tags": [
            "Array",
            "Backtracking"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3
                ],
                [
                    0
                ],
                [
                    4,
                    5,
                    6
                ],
                [
                    -1,
                    0,
                    1
                ],
                [
                    10,
                    20,
                    30,
                    40
                ],
                [
                    7,
                    8,
                    9,
                    10,
                    11
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10,
                    12
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9,
                    11,
                    13
                ],
                [
                    2,
                    3,
                    5,
                    7,
                    11,
                    13,
                    17,
                    19
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    32,
                    64,
                    128,
                    256
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    5,
                    10,
                    15,
                    20,
                    25,
                    30,
                    35,
                    40,
                    45,
                    50
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50
                ]
            ],
            "outputs": [
                [
                    [],
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        3
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        1,
                        2,
                        3
                    ]
                ],
                [
                    [],
                    [
                        0
                    ]
                ],
                [
                    [],
                    [
                        4
                    ],
                    [
                        5
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        6
                    ],
                    [
                        4,
                        6
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        4,
                        5,
                        6
                    ]
                ],
                [
                    [],
                    [
                        -1
                    ],
                    [
                        0
                    ],
                    [
                        -1,
                        0
                    ],
                    [
                        1
                    ],
                    [
                        -1,
                        1
                    ],
                    [
                        0,
                        1
                    ],
                    [
                        -1,
                        0,
                        1
                    ]
                ],
                [
                    [],
                    [
                        10
                    ],
                    [
                        20
                    ],
                    [
                        10,
                        20
                    ],
                    [
                        30
                    ],
                    [
                        10,
                        30
                    ],
                    [
                        20,
                        30
                    ],
                    [
                        10,
                        20,
                        30
                    ],
                    [
                        40
                    ],
                    [
                        10,
                        40
                    ],
                    [
                        20,
                        40
                    ],
                    [
                        10,
                        20,
                        40
                    ],
                    [
                        30,
                        40
                    ],
                    [
                        10,
                        30,
                        40
                    ],
                    [
                        20,
                        30,
                        40
                    ],
                    [
                        10,
                        20,
                        30,
                        40
                    ]
                ],
                [
                    [],
                    [
                        7
                    ],
                    [
                        8
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        9
                    ],
                    [
                        7,
                        9
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        7,
                        8,
                        9
                    ],
                    [
                        10
                    ],
                    [
                        7,
                        10
                    ],
                    [
                        8,
                        10
                    ],
                    [
                        7,
                        8,
                        10
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        7,
                        9,
                        10
                    ],
                    [
                        8,
                        9,
                        10
                    ],
                    [
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11
                    ],
                    [
                        7,
                        11
                    ],
                    [
                        8,
                        11
                    ],
                    [
                        7,
                        8,
                        11
                    ],
                    [
                        9,
                        11
                    ],
                    [
                        7,
                        9,
                        11
                    ],
                    [
                        8,
                        9,
                        11
                    ],
                    [
                        7,
                        8,
                        9,
                        11
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        7,
                        10,
                        11
                    ],
                    [
                        8,
                        10,
                        11
                    ],
                    [
                        7,
                        8,
                        10,
                        11
                    ],
                    [
                        9,
                        10,
                        11
                    ],
                    [
                        7,
                        9,
                        10,
                        11
                    ],
                    [
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11
                    ]
                ],
                [
                    [],
                    [
                        2
                    ],
                    [
                        4
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        6
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        4,
                        6
                    ],
                    [
                        2,
                        4,
                        6
                    ],
                    [
                        8
                    ],
                    [
                        2,
                        8
                    ],
                    [
                        4,
                        8
                    ],
                    [
                        2,
                        4,
                        8
                    ],
                    [
                        6,
                        8
                    ],
                    [
                        2,
                        6,
                        8
                    ],
                    [
                        4,
                        6,
                        8
                    ],
                    [
                        2,
                        4,
                        6,
                        8
                    ],
                    [
                        10
                    ],
                    [
                        2,
                        10
                    ],
                    [
                        4,
                        10
                    ],
                    [
                        2,
                        4,
                        10
                    ],
                    [
                        6,
                        10
                    ],
                    [
                        2,
                        6,
                        10
                    ],
                    [
                        4,
                        6,
                        10
                    ],
                    [
                        2,
                        4,
                        6,
                        10
                    ],
                    [
                        8,
                        10
                    ],
                    [
                        2,
                        8,
                        10
                    ],
                    [
                        4,
                        8,
                        10
                    ],
                    [
                        2,
                        4,
                        8,
                        10
                    ],
                    [
                        6,
                        8,
                        10
                    ],
                    [
                        2,
                        6,
                        8,
                        10
                    ],
                    [
                        4,
                        6,
                        8,
                        10
                    ],
                    [
                        2,
                        4,
                        6,
                        8,
                        10
                    ],
                    [
                        12
                    ],
                    [
                        2,
                        12
                    ],
                    [
                        4,
                        12
                    ],
                    [
                        2,
                        4,
                        12
                    ],
                    [
                        6,
                        12
                    ],
                    [
                        2,
                        6,
                        12
                    ],
                    [
                        4,
                        6,
                        12
                    ],
                    [
                        2,
                        4,
                        6,
                        12
                    ],
                    [
                        8,
                        12
                    ],
                    [
                        2,
                        8,
                        12
                    ],
                    [
                        4,
                        8,
                        12
                    ],
                    [
                        2,
                        4,
                        8,
                        12
                    ],
                    [
                        6,
                        8,
                        12
                    ],
                    [
                        2,
                        6,
                        8,
                        12
                    ],
                    [
                        4,
                        6,
                        8,
                        12
                    ],
                    [
                        2,
                        4,
                        6,
                        8,
                        12
                    ]
                ],
                [
                    [],
                    [
                        1
                    ],
                    [
                        3
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        5
                    ],
                    [
                        1,
                        5
                    ],
                    [
                        3,
                        5
                    ],
                    [
                        1,
                        3,
                        5
                    ],
                    [
                        7
                    ],
                    [
                        1,
                        7
                    ],
                    [
                        3,
                        7
                    ],
                    [
                        1,
                        3,
                        7
                    ],
                    [
                        5,
                        7
                    ],
                    [
                        1,
                        5,
                        7
                    ],
                    [
                        3,
                        5,
                        7
                    ],
                    [
                        1,
                        3,
                        5,
                        7
                    ],
                    [
                        9
                    ],
                    [
                        1,
                        9
                    ],
                    [
                        3,
                        9
                    ],
                    [
                        1,
                        3,
                        9
                    ],
                    [
                        5,
                        9
                    ],
                    [
                        1,
                        5,
                        9
                    ],
                    [
                        3,
                        5,
                        9
                    ],
                    [
                        1,
                        3,
                        5,
                        9
                    ],
                    [
                        11
                    ],
                    [
                        1,
                        11
                    ],
                    [
                        3,
                        11
                    ],
                    [
                        1,
                        3,
                        11
                    ],
                    [
                        5,
                        11
                    ],
                    [
                        1,
                        5,
                        11
                    ],
                    [
                        3,
                        5,
                        11
                    ],
                    [
                        1,
                        3,
                        5,
                        11
                    ],
                    [
                        13
                    ],
                    [
                        1,
                        13
                    ],
                    [
                        3,
                        13
                    ],
                    [
                        1,
                        3,
                        13
                    ],
                    [
                        5,
                        13
                    ],
                    [
                        1,
                        5,
                        13
                    ],
                    [
                        3,
                        5,
                        13
                    ],
                    [
                        1,
                        3,
                        5,
                        13
                    ],
                    [
                        15
                    ],
                    [
                        1,
                        15
                    ],
                    [
                        3,
                        15
                    ],
                    [
                        1,
                        3,
                        15
                    ],
                    [
                        5,
                        15
                    ],
                    [
                        1,
                        5,
                        15
                    ],
                    [
                        3,
                        5,
                        15
                    ],
                    [
                        1,
                        3,
                        5,
                        15
                    ]
                ],
                [
                    [],
                    [
                        2
                    ],
                    [
                        3
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        5
                    ],
                    [
                        2,
                        5
                    ],
                    [
                        3,
                        5
                    ],
                    [
                        2,
                        3,
                        5
                    ],
                    [
                        7
                    ],
                    [
                        2,
                        7
                    ],
                    [
                        3,
                        7
                    ],
                    [
                        2,
                        3,
                        7
                    ],
                    [
                        5,
                        7
                    ],
                    [
                        2,
                        5,
                        7
                    ],
                    [
                        3,
                        5,
                        7
                    ],
                    [
                        2,
                        3,
                        5,
                        7
                    ],
                    [
                        11
                    ],
                    [
                        2,
                        11
                    ],
                    [
                        3,
                        11
                    ],
                    [
                        2,
                        3,
                        11
                    ],
                    [
                        5,
                        11
                    ],
                    [
                        2,
                        5,
                        11
                    ],
                    [
                        3,
                        5,
                        11
                    ],
                    [
                        2,
                        3,
                        5,
                        11
                    ],
                    [
                        13
                    ],
                    [
                        2,
                        13
                    ],
                    [
                        3,
                        13
                    ],
                    [
                        2,
                        3,
                        13
                    ],
                    [
                        5,
                        13
                    ],
                    [
                        2,
                        5,
                        13
                    ],
                    [
                        3,
                        5,
                        13
                    ],
                    [
                        2,
                        3,
                        5,
                        13
                    ],
                    [
                        17
                    ],
                    [
                        2,
                        17
                    ],
                    [
                        3,
                        17
                    ],
                    [
                        2,
                        3,
                        17
                    ],
                    [
                        5,
                        17
                    ],
                    [
                        2,
                        5,
                        17
                    ],
                    [
                        3,
                        5,
                        17
                    ],
                    [
                        2,
                        3,
                        5,
                        17
                    ],
                    [
                        19
                    ],
                    [
                        2,
                        19
                    ],
                    [
                        3,
                        19
                    ],
                    [
                        2,
                        3,
                        19
                    ],
                    [
                        5,
                        19
                    ],
                    [
                        2,
                        5,
                        19
                    ],
                    [
                        3,
                        5,
                        19
                    ],
                    [
                        2,
                        3,
                        5,
                        19
                    ]
                ],
                [
                    [],
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        4
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        1,
                        2,
                        4
                    ],
                    [
                        8
                    ],
                    [
                        1,
                        8
                    ],
                    [
                        2,
                        8
                    ],
                    [
                        1,
                        2,
                        8
                    ],
                    [
                        4,
                        8
                    ],
                    [
                        1,
                        4,
                        8
                    ],
                    [
                        2,
                        4,
                        8
                    ],
                    [
                        1,
                        2,
                        4,
                        8
                    ],
                    [
                        16
                    ],
                    [
                        1,
                        16
                    ],
                    [
                        2,
                        16
                    ],
                    [
                        1,
                        2,
                        16
                    ],
                    [
                        4,
                        16
                    ],
                    [
                        1,
                        4,
                        16
                    ],
                    [
                        2,
                        4,
                        16
                    ],
                    [
                        1,
                        2,
                        4,
                        16
                    ],
                    [
                        32
                    ],
                    [
                        1,
                        32
                    ],
                    [
                        2,
                        32
                    ],
                    [
                        1,
                        2,
                        32
                    ],
                    [
                        4,
                        32
                    ],
                    [
                        1,
                        4,
                        32
                    ],
                    [
                        2,
                        4,
                        32
                    ],
                    [
                        1,
                        2,
                        4,
                        32
                    ],
                    [
                        64
                    ],
                    [
                        1,
                        64
                    ],
                    [
                        2,
                        64
                    ],
                    [
                        1,
                        2,
                        64
                    ],
                    [
                        4,
                        64
                    ],
                    [
                        1,
                        4,
                        64
                    ],
                    [
                        2,
                        4,
                        64
                    ],
                    [
                        1,
                        2,
                        4,
                        64
                    ],
                    [
                        128
                    ],
                    [
                        1,
                        128
                    ],
                    [
                        2,
                        128
                    ],
                    [
                        1,
                        2,
                        128
                    ],
                    [
                        4,
                        128
                    ],
                    [
                        1,
                        4,
                        128
                    ],
                    [
                        2,
                        4,
                        128
                    ],
                    [
                        1,
                        2,
                        4,
                        128
                    ],
                    [
                        256
                    ],
                    [
                        1,
                        256
                    ],
                    [
                        2,
                        256
                    ],
                    [
                        1,
                        2,
                        256
                    ],
                    [
                        4,
                        256
                    ],
                    [
                        1,
                        4,
                        256
                    ],
                    [
                        2,
                        4,
                        256
                    ],
                    [
                        1,
                        2,
                        4,
                        256
                    ]
                ],
                [
                    [],
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        3
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        1,
                        2,
                        4
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        1,
                        3,
                        4
                    ],
                    [
                        2,
                        3,
                        4
                    ],
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5
                    ],
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        3,
                        5
                    ],
                    [
                        1,
                        3,
                        5
                    ],
                    [
                        2,
                        3,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        5
                    ],
                    [
                        6
                    ],
                    [
                        1,
                        6
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        1,
                        2,
                        6
                    ],
                    [
                        3,
                        6
                    ],
                    [
                        1,
                        3,
                        6
                    ],
                    [
                        2,
                        3,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        6
                    ],
                    [
                        7
                    ],
                    [
                        1,
                        7
                    ],
                    [
                        2,
                        7
                    ],
                    [
                        1,
                        2,
                        7
                    ],
                    [
                        3,
                        7
                    ],
                    [
                        1,
                        3,
                        7
                    ],
                    [
                        2,
                        3,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        7
                    ],
                    [
                        8
                    ],
                    [
                        1,
                        8
                    ],
                    [
                        2,
                        8
                    ],
                    [
                        1,
                        2,
                        8
                    ],
                    [
                        3,
                        8
                    ],
                    [
                        1,
                        3,
                        8
                    ],
                    [
                        2,
                        3,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        8
                    ],
                    [
                        9
                    ],
                    [
                        1,
                        9
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        1,
                        2,
                        9
                    ],
                    [
                        3,
                        9
                    ],
                    [
                        1,
                        3,
                        9
                    ],
                    [
                        2,
                        3,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        9
                    ],
                    [
                        10
                    ],
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        10
                    ],
                    [
                        1,
                        2,
                        10
                    ],
                    [
                        3,
                        10
                    ],
                    [
                        1,
                        3,
                        10
                    ],
                    [
                        2,
                        3,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        10
                    ]
                ],
                [
                    [],
                    [
                        5
                    ],
                    [
                        10
                    ],
                    [
                        5,
                        10
                    ],
                    [
                        15
                    ],
                    [
                        5,
                        15
                    ],
                    [
                        10,
                        15
                    ],
                    [
                        5,
                        10,
                        15
                    ],
                    [
                        20
                    ],
                    [
                        5,
                        20
                    ],
                    [
                        10,
                        20
                    ],
                    [
                        5,
                        10,
                        20
                    ],
                    [
                        15,
                        20
                    ],
                    [
                        5,
                        15,
                        20
                    ],
                    [
                        10,
                        15,
                        20
                    ],
                    [
                        5,
                        10,
                        15,
                        20
                    ],
                    [
                        25
                    ],
                    [
                        5,
                        25
                    ],
                    [
                        10,
                        25
                    ],
                    [
                        5,
                        10,
                        25
                    ],
                    [
                        15,
                        25
                    ],
                    [
                        5,
                        15,
                        25
                    ],
                    [
                        10,
                        15,
                        25
                    ],
                    [
                        5,
                        10,
                        15,
                        25
                    ],
                    [
                        30
                    ],
                    [
                        5,
                        30
                    ],
                    [
                        10,
                        30
                    ],
                    [
                        5,
                        10,
                        30
                    ],
                    [
                        15,
                        30
                    ],
                    [
                        5,
                        15,
                        30
                    ],
                    [
                        10,
                        15,
                        30
                    ],
                    [
                        5,
                        10,
                        15,
                        30
                    ],
                    [
                        35
                    ],
                    [
                        5,
                        35
                    ],
                    [
                        10,
                        35
                    ],
                    [
                        5,
                        10,
                        35
                    ],
                    [
                        15,
                        35
                    ],
                    [
                        5,
                        15,
                        35
                    ],
                    [
                        10,
                        15,
                        35
                    ],
                    [
                        5,
                        10,
                        15,
                        35
                    ],
                    [
                        40
                    ],
                    [
                        5,
                        40
                    ],
                    [
                        10,
                        40
                    ],
                    [
                        5,
                        10,
                        40
                    ],
                    [
                        15,
                        40
                    ],
                    [
                        5,
                        15,
                        40
                    ],
                    [
                        10,
                        15,
                        40
                    ],
                    [
                        5,
                        10,
                        15,
                        40
                    ],
                    [
                        45
                    ],
                    [
                        5,
                        45
                    ],
                    [
                        10,
                        45
                    ],
                    [
                        5,
                        10,
                        45
                    ],
                    [
                        15,
                        45
                    ],
                    [
                        5,
                        15,
                        45
                    ],
                    [
                        10,
                        15,
                        45
                    ],
                    [
                        5,
                        10,
                        15,
                        45
                    ],
                    [
                        50
                    ],
                    [
                        5,
                        50
                    ],
                    [
                        10,
                        50
                    ],
                    [
                        5,
                        10,
                        50
                    ],
                    [
                        15,
                        50
                    ],
                    [
                        5,
                        15,
                        50
                    ],
                    [
                        10,
                        15,
                        50
                    ],
                    [
                        5,
                        10,
                        15,
                        50
                    ]
                ],
                [
                    [],
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        3
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        1,
                        2,
                        4
                    ],
                    [
                        5
                    ],
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        6
                    ],
                    [
                        1,
                        6
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        1,
                        2,
                        6
                    ],
                    [
                        7
                    ],
                    [
                        1,
                        7
                    ],
                    [
                        2,
                        7
                    ],
                    [
                        1,
                        2,
                        7
                    ],
                    [
                        8
                    ],
                    [
                        1,
                        8
                    ],
                    [
                        2,
                        8
                    ],
                    [
                        1,
                        2,
                        8
                    ],
                    [
                        9
                    ],
                    [
                        1,
                        9
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        1,
                        2,
                        9
                    ],
                    [
                        10
                    ],
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        10
                    ],
                    [
                        1,
                        2,
                        10
                    ],
                    [
                        11
                    ],
                    [
                        1,
                        11
                    ],
                    [
                        2,
                        11
                    ],
                    [
                        1,
                        2,
                        11
                    ],
                    [
                        12
                    ],
                    [
                        1,
                        12
                    ],
                    [
                        2,
                        12
                    ],
                    [
                        1,
                        2,
                        12
                    ],
                    [
                        13
                    ],
                    [
                        1,
                        13
                    ],
                    [
                        2,
                        13
                    ],
                    [
                        1,
                        2,
                        13
                    ],
                    [
                        14
                    ],
                    [
                        1,
                        14
                    ],
                    [
                        2,
                        14
                    ],
                    [
                        1,
                        2,
                        14
                    ],
                    [
                        15
                    ],
                    [
                        1,
                        15
                    ],
                    [
                        2,
                        15
                    ],
                    [
                        1,
                        2,
                        15
                    ]
                ],
                [
                    [],
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        3
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        1,
                        2,
                        4
                    ],
                    [
                        5
                    ],
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        6
                    ],
                    [
                        1,
                        6
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        1,
                        2,
                        6
                    ],
                    [
                        7
                    ],
                    [
                        1,
                        7
                    ],
                    [
                        2,
                        7
                    ],
                    [
                        1,
                        2,
                        7
                    ],
                    [
                        8
                    ],
                    [
                        1,
                        8
                    ],
                    [
                        2,
                        8
                    ],
                    [
                        1,
                        2,
                        8
                    ],
                    [
                        9
                    ],
                    [
                        1,
                        9
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        1,
                        2,
                        9
                    ],
                    [
                        10
                    ],
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        10
                    ],
                    [
                        1,
                        2,
                        10
                    ],
                    [
                        11
                    ],
                    [
                        1,
                        11
                    ],
                    [
                        2,
                        11
                    ],
                    [
                        1,
                        2,
                        11
                    ],
                    [
                        12
                    ],
                    [
                        1,
                        12
                    ],
                    [
                        2,
                        12
                    ],
                    [
                        1,
                        2,
                        12
                    ],
                    [
                        13
                    ],
                    [
                        1,
                        13
                    ],
                    [
                        2,
                        13
                    ],
                    [
                        1,
                        2,
                        13
                    ],
                    [
                        14
                    ],
                    [
                        1,
                        14
                    ],
                    [
                        2,
                        14
                    ],
                    [
                        1,
                        2,
                        14
                    ],
                    [
                        15
                    ],
                    [
                        1,
                        15
                    ],
                    [
                        2,
                        15
                    ],
                    [
                        1,
                        2,
                        15
                    ],
                    [
                        16
                    ],
                    [
                        1,
                        16
                    ],
                    [
                        2,
                        16
                    ],
                    [
                        1,
                        2,
                        16
                    ],
                    [
                        17
                    ],
                    [
                        1,
                        17
                    ],
                    [
                        2,
                        17
                    ],
                    [
                        1,
                        2,
                        17
                    ],
                    [
                        18
                    ],
                    [
                        1,
                        18
                    ],
                    [
                        2,
                        18
                    ],
                    [
                        1,
                        2,
                        18
                    ],
                    [
                        19
                    ],
                    [
                        1,
                        19
                    ],
                    [
                        2,
                        19
                    ],
                    [
                        1,
                        2,
                        19
                    ],
                    [
                        20
                    ],
                    [
                        1,
                        20
                    ],
                    [
                        2,
                        20
                    ],
                    [
                        1,
                        2,
                        20
                    ]
                ],
                [
                    [],
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        3
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        1,
                        2,
                        4
                    ],
                    [
                        5
                    ],
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        6
                    ],
                    [
                        1,
                        6
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        1,
                        2,
                        6
                    ],
                    [
                        7
                    ],
                    [
                        1,
                        7
                    ],
                    [
                        2,
                        7
                    ],
                    [
                        1,
                        2,
                        7
                    ],
                    [
                        8
                    ],
                    [
                        1,
                        8
                    ],
                    [
                        2,
                        8
                    ],
                    [
                        1,
                        2,
                        8
                    ],
                    [
                        9
                    ],
                    [
                        1,
                        9
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        1,
                        2,
                        9
                    ],
                    [
                        10
                    ],
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        10
                    ],
                    [
                        1,
                        2,
                        10
                    ],
                    [
                        11
                    ],
                    [
                        1,
                        11
                    ],
                    [
                        2,
                        11
                    ],
                    [
                        1,
                        2,
                        11
                    ],
                    [
                        12
                    ],
                    [
                        1,
                        12
                    ],
                    [
                        2,
                        12
                    ],
                    [
                        1,
                        2,
                        12
                    ],
                    [
                        13
                    ],
                    [
                        1,
                        13
                    ],
                    [
                        2,
                        13
                    ],
                    [
                        1,
                        2,
                        13
                    ],
                    [
                        14
                    ],
                    [
                        1,
                        14
                    ],
                    [
                        2,
                        14
                    ],
                    [
                        1,
                        2,
                        14
                    ],
                    [
                        15
                    ],
                    [
                        1,
                        15
                    ],
                    [
                        2,
                        15
                    ],
                    [
                        1,
                        2,
                        15
                    ],
                    [
                        16
                    ],
                    [
                        1,
                        16
                    ],
                    [
                        2,
                        16
                    ],
                    [
                        1,
                        2,
                        16
                    ],
                    [
                        17
                    ],
                    [
                        1,
                        17
                    ],
                    [
                        2,
                        17
                    ],
                    [
                        1,
                        2,
                        17
                    ],
                    [
                        18
                    ],
                    [
                        1,
                        18
                    ],
                    [
                        2,
                        18
                    ],
                    [
                        1,
                        2,
                        18
                    ],
                    [
                        19
                    ],
                    [
                        1,
                        19
                    ],
                    [
                        2,
                        19
                    ],
                    [
                        1,
                        2,
                        19
                    ],
                    [
                        20
                    ],
                    [
                        1,
                        20
                    ],
                    [
                        2,
                        20
                    ],
                    [
                        1,
                        2,
                        20
                    ],
                    [
                        21
                    ],
                    [
                        1,
                        21
                    ],
                    [
                        2,
                        21
                    ],
                    [
                        1,
                        2,
                        21
                    ],
                    [
                        22
                    ],
                    [
                        1,
                        22
                    ],
                    [
                        2,
                        22
                    ],
                    [
                        1,
                        2,
                        22
                    ],
                    [
                        23
                    ],
                    [
                        1,
                        23
                    ],
                    [
                        2,
                        23
                    ],
                    [
                        1,
                        2,
                        23
                    ],
                    [
                        24
                    ],
                    [
                        1,
                        24
                    ],
                    [
                        2,
                        24
                    ],
                    [
                        1,
                        2,
                        24
                    ],
                    [
                        25
                    ],
                    [
                        1,
                        25
                    ],
                    [
                        2,
                        25
                    ],
                    [
                        1,
                        2,
                        25
                    ]
                ],
                [
                    [],
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        3
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        1,
                        2,
                        4
                    ],
                    [
                        5
                    ],
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        6
                    ],
                    [
                        1,
                        6
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        1,
                        2,
                        6
                    ],
                    [
                        7
                    ],
                    [
                        1,
                        7
                    ],
                    [
                        2,
                        7
                    ],
                    [
                        1,
                        2,
                        7
                    ],
                    [
                        8
                    ],
                    [
                        1,
                        8
                    ],
                    [
                        2,
                        8
                    ],
                    [
                        1,
                        2,
                        8
                    ],
                    [
                        9
                    ],
                    [
                        1,
                        9
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        1,
                        2,
                        9
                    ],
                    [
                        10
                    ],
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        10
                    ],
                    [
                        1,
                        2,
                        10
                    ],
                    [
                        11
                    ],
                    [
                        1,
                        11
                    ],
                    [
                        2,
                        11
                    ],
                    [
                        1,
                        2,
                        11
                    ],
                    [
                        12
                    ],
                    [
                        1,
                        12
                    ],
                    [
                        2,
                        12
                    ],
                    [
                        1,
                        2,
                        12
                    ],
                    [
                        13
                    ],
                    [
                        1,
                        13
                    ],
                    [
                        2,
                        13
                    ],
                    [
                        1,
                        2,
                        13
                    ],
                    [
                        14
                    ],
                    [
                        1,
                        14
                    ],
                    [
                        2,
                        14
                    ],
                    [
                        1,
                        2,
                        14
                    ],
                    [
                        15
                    ],
                    [
                        1,
                        15
                    ],
                    [
                        2,
                        15
                    ],
                    [
                        1,
                        2,
                        15
                    ],
                    [
                        16
                    ],
                    [
                        1,
                        16
                    ],
                    [
                        2,
                        16
                    ],
                    [
                        1,
                        2,
                        16
                    ],
                    [
                        17
                    ],
                    [
                        1,
                        17
                    ],
                    [
                        2,
                        17
                    ],
                    [
                        1,
                        2,
                        17
                    ],
                    [
                        18
                    ],
                    [
                        1,
                        18
                    ],
                    [
                        2,
                        18
                    ],
                    [
                        1,
                        2,
                        18
                    ],
                    [
                        19
                    ],
                    [
                        1,
                        19
                    ],
                    [
                        2,
                        19
                    ],
                    [
                        1,
                        2,
                        19
                    ],
                    [
                        20
                    ],
                    [
                        1,
                        20
                    ],
                    [
                        2,
                        20
                    ],
                    [
                        1,
                        2,
                        20
                    ],
                    [
                        21
                    ],
                    [
                        1,
                        21
                    ],
                    [
                        2,
                        21
                    ],
                    [
                        1,
                        2,
                        21
                    ],
                    [
                        22
                    ],
                    [
                        1,
                        22
                    ],
                    [
                        2,
                        22
                    ],
                    [
                        1,
                        2,
                        22
                    ],
                    [
                        23
                    ],
                    [
                        1,
                        23
                    ],
                    [
                        2,
                        23
                    ],
                    [
                        1,
                        2,
                        23
                    ],
                    [
                        24
                    ],
                    [
                        1,
                        24
                    ],
                    [
                        2,
                        24
                    ],
                    [
                        1,
                        2,
                        24
                    ],
                    [
                        25
                    ],
                    [
                        1,
                        25
                    ],
                    [
                        2,
                        25
                    ],
                    [
                        1,
                        2,
                        25
                    ],
                    [
                        26
                    ],
                    [
                        1,
                        26
                    ],
                    [
                        2,
                        26
                    ],
                    [
                        1,
                        2,
                        26
                    ],
                    [
                        27
                    ],
                    [
                        1,
                        27
                    ],
                    [
                        2,
                        27
                    ],
                    [
                        1,
                        2,
                        27
                    ],
                    [
                        28
                    ],
                    [
                        1,
                        28
                    ],
                    [
                        2,
                        28
                    ],
                    [
                        1,
                        2,
                        28
                    ],
                    [
                        29
                    ],
                    [
                        1,
                        29
                    ],
                    [
                        2,
                        29
                    ],
                    [
                        1,
                        2,
                        29
                    ],
                    [
                        30
                    ],
                    [
                        1,
                        30
                    ],
                    [
                        2,
                        30
                    ],
                    [
                        1,
                        2,
                        30
                    ]
                ],
                [
                    [],
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        3
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        1,
                        2,
                        4
                    ],
                    [
                        5
                    ],
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        6
                    ],
                    [
                        1,
                        6
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        1,
                        2,
                        6
                    ],
                    [
                        7
                    ],
                    [
                        1,
                        7
                    ],
                    [
                        2,
                        7
                    ],
                    [
                        1,
                        2,
                        7
                    ],
                    [
                        8
                    ],
                    [
                        1,
                        8
                    ],
                    [
                        2,
                        8
                    ],
                    [
                        1,
                        2,
                        8
                    ],
                    [
                        9
                    ],
                    [
                        1,
                        9
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        1,
                        2,
                        9
                    ],
                    [
                        10
                    ],
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        10
                    ],
                    [
                        1,
                        2,
                        10
                    ],
                    [
                        11
                    ],
                    [
                        1,
                        11
                    ],
                    [
                        2,
                        11
                    ],
                    [
                        1,
                        2,
                        11
                    ],
                    [
                        12
                    ],
                    [
                        1,
                        12
                    ],
                    [
                        2,
                        12
                    ],
                    [
                        1,
                        2,
                        12
                    ],
                    [
                        13
                    ],
                    [
                        1,
                        13
                    ],
                    [
                        2,
                        13
                    ],
                    [
                        1,
                        2,
                        13
                    ],
                    [
                        14
                    ],
                    [
                        1,
                        14
                    ],
                    [
                        2,
                        14
                    ],
                    [
                        1,
                        2,
                        14
                    ],
                    [
                        15
                    ],
                    [
                        1,
                        15
                    ],
                    [
                        2,
                        15
                    ],
                    [
                        1,
                        2,
                        15
                    ],
                    [
                        16
                    ],
                    [
                        1,
                        16
                    ],
                    [
                        2,
                        16
                    ],
                    [
                        1,
                        2,
                        16
                    ],
                    [
                        17
                    ],
                    [
                        1,
                        17
                    ],
                    [
                        2,
                        17
                    ],
                    [
                        1,
                        2,
                        17
                    ],
                    [
                        18
                    ],
                    [
                        1,
                        18
                    ],
                    [
                        2,
                        18
                    ],
                    [
                        1,
                        2,
                        18
                    ],
                    [
                        19
                    ],
                    [
                        1,
                        19
                    ],
                    [
                        2,
                        19
                    ],
                    [
                        1,
                        2,
                        19
                    ],
                    [
                        20
                    ],
                    [
                        1,
                        20
                    ],
                    [
                        2,
                        20
                    ],
                    [
                        1,
                        2,
                        20
                    ],
                    [
                        21
                    ],
                    [
                        1,
                        21
                    ],
                    [
                        2,
                        21
                    ],
                    [
                        1,
                        2,
                        21
                    ],
                    [
                        22
                    ],
                    [
                        1,
                        22
                    ],
                    [
                        2,
                        22
                    ],
                    [
                        1,
                        2,
                        22
                    ],
                    [
                        23
                    ],
                    [
                        1,
                        23
                    ],
                    [
                        2,
                        23
                    ],
                    [
                        1,
                        2,
                        23
                    ],
                    [
                        24
                    ],
                    [
                        1,
                        24
                    ],
                    [
                        2,
                        24
                    ],
                    [
                        1,
                        2,
                        24
                    ],
                    [
                        25
                    ],
                    [
                        1,
                        25
                    ],
                    [
                        2,
                        25
                    ],
                    [
                        1,
                        2,
                        25
                    ],
                    [
                        26
                    ],
                    [
                        1,
                        26
                    ],
                    [
                        2,
                        26
                    ],
                    [
                        1,
                        2,
                        26
                    ],
                    [
                        27
                    ],
                    [
                        1,
                        27
                    ],
                    [
                        2,
                        27
                    ],
                    [
                        1,
                        2,
                        27
                    ],
                    [
                        28
                    ],
                    [
                        1,
                        28
                    ],
                    [
                        2,
                        28
                    ],
                    [
                        1,
                        2,
                        28
                    ],
                    [
                        29
                    ],
                    [
                        1,
                        29
                    ],
                    [
                        2,
                        29
                    ],
                    [
                        1,
                        2,
                        29
                    ],
                    [
                        30
                    ],
                    [
                        1,
                        30
                    ],
                    [
                        2,
                        30
                    ],
                    [
                        1,
                        2,
                        30
                    ],
                    [
                        31
                    ],
                    [
                        1,
                        31
                    ],
                    [
                        2,
                        31
                    ],
                    [
                        1,
                        2,
                        31
                    ],
                    [
                        32
                    ],
                    [
                        1,
                        32
                    ],
                    [
                        2,
                        32
                    ],
                    [
                        1,
                        2,
                        32
                    ],
                    [
                        33
                    ],
                    [
                        1,
                        33
                    ],
                    [
                        2,
                        33
                    ],
                    [
                        1,
                        2,
                        33
                    ],
                    [
                        34
                    ],
                    [
                        1,
                        34
                    ],
                    [
                        2,
                        34
                    ],
                    [
                        1,
                        2,
                        34
                    ],
                    [
                        35
                    ],
                    [
                        1,
                        35
                    ],
                    [
                        2,
                        35
                    ],
                    [
                        1,
                        2,
                        35
                    ],
                    [
                        36
                    ],
                    [
                        1,
                        36
                    ],
                    [
                        2,
                        36
                    ],
                    [
                        1,
                        2,
                        36
                    ],
                    [
                        37
                    ],
                    [
                        1,
                        37
                    ],
                    [
                        2,
                        37
                    ],
                    [
                        1,
                        2,
                        37
                    ],
                    [
                        38
                    ],
                    [
                        1,
                        38
                    ],
                    [
                        2,
                        38
                    ],
                    [
                        1,
                        2,
                        38
                    ],
                    [
                        39
                    ],
                    [
                        1,
                        39
                    ],
                    [
                        2,
                        39
                    ],
                    [
                        1,
                        2,
                        39
                    ],
                    [
                        40
                    ],
                    [
                        1,
                        40
                    ],
                    [
                        2,
                        40
                    ],
                    [
                        1,
                        2,
                        40
                    ]
                ],
                [
                    [],
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        3
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        1,
                        2,
                        4
                    ],
                    [
                        5
                    ],
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        6
                    ],
                    [
                        1,
                        6
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        1,
                        2,
                        6
                    ],
                    [
                        7
                    ],
                    [
                        1,
                        7
                    ],
                    [
                        2,
                        7
                    ],
                    [
                        1,
                        2,
                        7
                    ],
                    [
                        8
                    ],
                    [
                        1,
                        8
                    ],
                    [
                        2,
                        8
                    ],
                    [
                        1,
                        2,
                        8
                    ],
                    [
                        9
                    ],
                    [
                        1,
                        9
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        1,
                        2,
                        9
                    ],
                    [
                        10
                    ],
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        10
                    ],
                    [
                        1,
                        2,
                        10
                    ],
                    [
                        11
                    ],
                    [
                        1,
                        11
                    ],
                    [
                        2,
                        11
                    ],
                    [
                        1,
                        2,
                        11
                    ],
                    [
                        12
                    ],
                    [
                        1,
                        12
                    ],
                    [
                        2,
                        12
                    ],
                    [
                        1,
                        2,
                        12
                    ],
                    [
                        13
                    ],
                    [
                        1,
                        13
                    ],
                    [
                        2,
                        13
                    ],
                    [
                        1,
                        2,
                        13
                    ],
                    [
                        14
                    ],
                    [
                        1,
                        14
                    ],
                    [
                        2,
                        14
                    ],
                    [
                        1,
                        2,
                        14
                    ],
                    [
                        15
                    ],
                    [
                        1,
                        15
                    ],
                    [
                        2,
                        15
                    ],
                    [
                        1,
                        2,
                        15
                    ],
                    [
                        16
                    ],
                    [
                        1,
                        16
                    ],
                    [
                        2,
                        16
                    ],
                    [
                        1,
                        2,
                        16
                    ],
                    [
                        17
                    ],
                    [
                        1,
                        17
                    ],
                    [
                        2,
                        17
                    ],
                    [
                        1,
                        2,
                        17
                    ],
                    [
                        18
                    ],
                    [
                        1,
                        18
                    ],
                    [
                        2,
                        18
                    ],
                    [
                        1,
                        2,
                        18
                    ],
                    [
                        19
                    ],
                    [
                        1,
                        19
                    ],
                    [
                        2,
                        19
                    ],
                    [
                        1,
                        2,
                        19
                    ],
                    [
                        20
                    ],
                    [
                        1,
                        20
                    ],
                    [
                        2,
                        20
                    ],
                    [
                        1,
                        2,
                        20
                    ],
                    [
                        21
                    ],
                    [
                        1,
                        21
                    ],
                    [
                        2,
                        21
                    ],
                    [
                        1,
                        2,
                        21
                    ],
                    [
                        22
                    ],
                    [
                        1,
                        22
                    ],
                    [
                        2,
                        22
                    ],
                    [
                        1,
                        2,
                        22
                    ],
                    [
                        23
                    ],
                    [
                        1,
                        23
                    ],
                    [
                        2,
                        23
                    ],
                    [
                        1,
                        2,
                        23
                    ],
                    [
                        24
                    ],
                    [
                        1,
                        24
                    ],
                    [
                        2,
                        24
                    ],
                    [
                        1,
                        2,
                        24
                    ],
                    [
                        25
                    ],
                    [
                        1,
                        25
                    ],
                    [
                        2,
                        25
                    ],
                    [
                        1,
                        2,
                        25
                    ],
                    [
                        26
                    ],
                    [
                        1,
                        26
                    ],
                    [
                        2,
                        26
                    ],
                    [
                        1,
                        2,
                        26
                    ],
                    [
                        27
                    ],
                    [
                        1,
                        27
                    ],
                    [
                        2,
                        27
                    ],
                    [
                        1,
                        2,
                        27
                    ],
                    [
                        28
                    ],
                    [
                        1,
                        28
                    ],
                    [
                        2,
                        28
                    ],
                    [
                        1,
                        2,
                        28
                    ],
                    [
                        29
                    ],
                    [
                        1,
                        29
                    ],
                    [
                        2,
                        29
                    ],
                    [
                        1,
                        2,
                        29
                    ],
                    [
                        30
                    ],
                    [
                        1,
                        30
                    ],
                    [
                        2,
                        30
                    ],
                    [
                        1,
                        2,
                        30
                    ],
                    [
                        31
                    ],
                    [
                        1,
                        31
                    ],
                    [
                        2,
                        31
                    ],
                    [
                        1,
                        2,
                        31
                    ],
                    [
                        32
                    ],
                    [
                        1,
                        32
                    ],
                    [
                        2,
                        32
                    ],
                    [
                        1,
                        2,
                        32
                    ],
                    [
                        33
                    ],
                    [
                        1,
                        33
                    ],
                    [
                        2,
                        33
                    ],
                    [
                        1,
                        2,
                        33
                    ],
                    [
                        34
                    ],
                    [
                        1,
                        34
                    ],
                    [
                        2,
                        34
                    ],
                    [
                        1,
                        2,
                        34
                    ],
                    [
                        35
                    ],
                    [
                        1,
                        35
                    ],
                    [
                        2,
                        35
                    ],
                    [
                        1,
                        2,
                        35
                    ],
                    [
                        36
                    ],
                    [
                        1,
                        36
                    ],
                    [
                        2,
                        36
                    ],
                    [
                        1,
                        2,
                        36
                    ],
                    [
                        37
                    ],
                    [
                        1,
                        37
                    ],
                    [
                        2,
                        37
                    ],
                    [
                        1,
                        2,
                        37
                    ],
                    [
                        38
                    ],
                    [
                        1,
                        38
                    ],
                    [
                        2,
                        38
                    ],
                    [
                        1,
                        2,
                        38
                    ],
                    [
                        39
                    ],
                    [
                        1,
                        39
                    ],
                    [
                        2,
                        39
                    ],
                    [
                        1,
                        2,
                        39
                    ],
                    [
                        40
                    ],
                    [
                        1,
                        40
                    ],
                    [
                        2,
                        40
                    ],
                    [
                        1,
                        2,
                        40
                    ],
                    [
                        41
                    ],
                    [
                        1,
                        41
                    ],
                    [
                        2,
                        41
                    ],
                    [
                        1,
                        2,
                        41
                    ],
                    [
                        42
                    ],
                    [
                        1,
                        42
                    ],
                    [
                        2,
                        42
                    ],
                    [
                        1,
                        2,
                        42
                    ],
                    [
                        43
                    ],
                    [
                        1,
                        43
                    ],
                    [
                        2,
                        43
                    ],
                    [
                        1,
                        2,
                        43
                    ],
                    [
                        44
                    ],
                    [
                        1,
                        44
                    ],
                    [
                        2,
                        44
                    ],
                    [
                        1,
                        2,
                        44
                    ],
                    [
                        45
                    ],
                    [
                        1,
                        45
                    ],
                    [
                        2,
                        45
                    ],
                    [
                        1,
                        2,
                        45
                    ],
                    [
                        46
                    ],
                    [
                        1,
                        46
                    ],
                    [
                        2,
                        46
                    ],
                    [
                        1,
                        2,
                        46
                    ],
                    [
                        47
                    ],
                    [
                        1,
                        47
                    ],
                    [
                        2,
                        47
                    ],
                    [
                        1,
                        2,
                        47
                    ],
                    [
                        48
                    ],
                    [
                        1,
                        48
                    ],
                    [
                        2,
                        48
                    ],
                    [
                        1,
                        2,
                        48
                    ],
                    [
                        49
                    ],
                    [
                        1,
                        49
                    ],
                    [
                        2,
                        49
                    ],
                    [
                        1,
                        2,
                        49
                    ],
                    [
                        50
                    ],
                    [
                        1,
                        50
                    ],
                    [
                        2,
                        50
                    ],
                    [
                        1,
                        2,
                        50
                    ]
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nstd::vector<std::vector<int>> subsets(std::vector<int>& nums) {\n    std::vector<std::vector<int>> result;\n    int n = nums.size();\n    int num_subsets = 1 << n;\n\n    for (int i = 0; i < num_subsets; ++i) {\n        std::vector<int> subset;\n        for (int j = 0; j < n; ++j) {\n            if (i & (1 << j)) {\n                subset.push_back(nums[j]);\n            }\n        }\n        result.push_back(subset);\n    }\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    int n = nums.length;\n    int num_subsets = 1 << n;\n\n    for (int i = 0; i < num_subsets; ++i) {\n        List<Integer> subset = new ArrayList<>();\n        for (int j = 0; j < n; ++j) {\n            if ((i & (1 << j)) != 0) {\n                subset.add(nums[j]);\n            }\n        }\n        result.add(subset);\n    }\n    return result;\n}\n",
            "python": "def subsets(nums):\n    n = len(nums)\n    num_subsets = 1 << n\n    result = []\n\n    for i in range(num_subsets):\n        subset = []\n        for j in range(n):\n            if i & (1 << j):\n                subset.append(nums[j])\n        result.append(subset)\n    return result\n",
            "javascript": "function subsets(nums) {\n    let result = [];\n    let n = nums.length;\n    let num_subsets = 1 << n;\n\n    for (let i = 0; i < num_subsets; ++i) {\n        let subset = [];\n        for (let j = 0; j < n; ++j) {\n            if (i & (1 << j)) {\n                subset.push(nums[j]);\n            }\n        }\n        result.push(subset);\n    }\n    return result;\n}\n",
            "explanation": "1. Calculate the number of subsets in the power set (2^n) using bit manipulation.\n2. Loop through all numbers from 0 to 2^n - 1.\n3. For each number, loop through its bits, and if the bit is set (1), include the corresponding element from the input array in the current subset.\n4. Add the current subset to the result list.\n5. After the loops finish, return the result list containing all subsets."
        },
        "structure": {
            "c++": "#include <vector>\n\nstd::vector<std::vector<int>> subsets(std::vector<int>& nums) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> subsets(int[] nums) \n    // Your code here\n}\n",
            "python": "def subsets(nums):\n    # Your code here\n\n",
            "javascript": "function subsets(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nstd::vector<std::vector<int>> subsets(std::vector<int>& nums);\n\nint main() {\n    std::vector<int> nums = $args;\n    std::vector<std::vector<int>> result = subsets(nums);\n\n    for (const auto& subset : result) {\n        std::cout << '[';\n        for (int i = 0; i < subset.size(); ++i) {\n            std::cout << subset[i];\n            if (i != subset.size() - 1) {\n                std::cout << ',';\n            }\n        }\n        std::cout << ']';\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n",
            "java": "public List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    int n = nums.length;\n    int num_subsets = 1 << n;\n\n    for (int i = 0; i < num_subsets; ++i) {\n        List<Integer> subset = new ArrayList<>();\n        for (int j = 0; j < n; ++j) {\n            if ((i & (1 << j)) != 0) {\n                subset.add(nums[j]);\n            }\n        }\n        result.add(subset);\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = subsets(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = subsets(nums);\n    console.log(result);\n}"
        }
    },
    "79": {
        "title": "Word Search",
        "description": "Given an `m x n` grid of characters `board` and a string `word`, determine if `word` exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
        "example": "Given a board = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], and a word = 'ABCCED', the function should return true, as the word 'ABCCED' can be formed by starting at cell (0,0) and moving right, down, down, left, and up.\n\nGiven a board = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], and a word = 'SEE', the function should return true, as the word 'SEE' can be formed by starting at cell (0,1) and moving right, down, and down.\n\nGiven a board = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], and a word = 'ABCB', the function should return false, as it is not possible to form the word 'ABCB' in the grid.",
        "level": "Medium",
        "tags": [
            "Array",
            "Backtracking"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCCED"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "SEE"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCB"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCD"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ASAD"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABFCE"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDAS"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASF"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFS"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSF"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSFS"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSFSC"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSFSCS"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSFSCSA"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSFSCSAS"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSFSCSASF"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSFSCSASFS"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSFSCSASFSF"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSFSCSASFSFS"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSFSCSASFSFSC"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSFSCSASFSFSCS"
                ]
            ],
            "outputs": [
                true,
                true,
                false,
                false,
                false,
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "bool exist(vector<vector<char>>& board, string word) {\n    int m = board.size();\n    int n = board[0].size();\n    \n    function<bool(int, int, int)> dfs = [&](int i, int j, int k) {\n        if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] != word[k])\n            return false;\n        if (k == word.length() - 1)\n            return true;\n        \n        char temp = board[i][j];\n        board[i][j] = '/';\n        bool res = dfs(i + 1, j, k + 1) || dfs(i - 1, j, k + 1) || dfs(i, j + 1, k + 1) || dfs(i, j - 1, k + 1);\n        board[i][j] = temp;\n        return res;\n    };\n    \n    for (int i = 0; i < m; i++)\n        for (int j = 0; j < n; j++)\n            if (dfs(i, j, 0))\n                return true;\n    return false;\n}\n\n",
            "java": "public boolean exist(char[][] board, String word) {\n    int m = board.length;\n    int n = board[0].length;\n\n    boolean[][] visited = new boolean[m][n];\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dfs(board, i, j, 0, word, visited)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean dfs(char[][] board, int i, int j, int k, String word, boolean[][] visited) {\n    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != word.charAt(k) || visited[i][j]) {\n        return false;\n    }\n\n    if (k == word.length() - 1) {\n        return true;\n    }\n\n    visited[i][j] = true;\n    boolean result = dfs(board, i + 1, j, k + 1, word, visited)\n            || dfs(board, i - 1, j, k + 1, word, visited)\n            || dfs(board, i, j + 1, k + 1, word, visited)\n            || dfs(board, i, j - 1, k + 1, word, visited);\n    visited[i][j] = false;\n\n    return result;\n}\n\n",
            "python": "def exist(board, word):\n    m, n = len(board), len(board[0])\n\n    def dfs(i, j, k):\n        if not 0 <= i < m or not 0 <= j < n or board[i][j] != word[k]:\n            return False\n        if k == len(word) - 1:\n            return True\n\n        tmp, board[i][j] = board[i][j], '/'\n        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n        board[i][j] = tmp\n        return res\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n    return False\n\n",
            "javascript": "function exist(board, word) {\n    const m = board.length;\n    const n = board[0].length;\n\n    function dfs(i, j, k) {\n        if (i < 0 || i === m || j < 0 || j === n || board[i][j] !== word[k])\n            return false;\n        if (k === word.length - 1)\n            return true;\n        \n        const temp = board[i][j];\n        board[i][j] = '/';\n        const res = dfs(i + 1, j, k +1) || dfs(i - 1, j, k + 1) || dfs(i, j + 1, k + 1) || dfs(i, j - 1, k + 1);\n        board[i][j] = temp;\n        return res;\n    }\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (dfs(i, j, 0))\n                return true;\n        }\n    }\n    return false;\n}\n\n",
            "explanation": "For each of the implementation above, we use a Depth-First Search (DFS) based algorithm to traverse the grid board. The DFS function takes the current cell index i and j and the index of the character in the input word that we are looking for (k).\n\nThe base cases are:\n- If the cell indexes i or j are out of boundaries, or the board[i][j] character does not match word[k], return false.\n- If k (current character index) is equal to word.length - 1, we find the word in the grid, so return true.\n\nFor each cell, we run the DFS function with the given input parameters. If DFS returns true (found the word), the whole function will return true."
        },
        "structure": {
            "c++": "bool exist(vector<vector<char>>& board, string word) \n    // Your code here\n}\n\n",
            "java": "public boolean exist(char[][] board, String word) \n    // Your code here\n}\n\n",
            "python": "def exist(board, word):\n    # Your code here\n\n",
            "javascript": "function exist(board, word) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "bool exist(vector<vector<char>>& board, string word) {\n    int m = board.size();\n    int n = board[0].size();\n    \n    function<bool(int, int, int)> dfs = [&](int i, int j, int k) {\n        if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] != word[k])\n            return false;\n        if (k == word.length() - 1)\n            return true;\n        \n        char temp = board[i][j];\n        board[i][j] = '/';\n        bool res = dfs(i + 1, j, k + 1) || dfs(i - 1, j, k + 1) || dfs(i, j + 1, k + 1) || dfs(i, j - 1, k + 1);\n        board[i][j] = temp;\n        return res;\n    };\n    \n    for (int i = 0; i < m; i++)\n        for (int j = 0; j < n; j++)\n            if (dfs(i, j, 0))\n                return true;\n    return false;\n}",
            "java": "public boolean exist(char[][] board, String word) {\n    int m = board.length;\n    int n = board[0].length;\n\n    boolean[][] visited = new boolean[m][n];\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dfs(board, i, j, 0, word, visited)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean dfs(char[][] board, int i, int j, int k, String word, boolean[][] visited) {\n    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != word.charAt(k) || visited[i][j]) {\n        return false;\n    }\n\n    if (k == word.length() - 1) {\n        return true;\n    }\n\n    visited[i][j] = true;\n    boolean result = dfs(board, i + 1, j, k + 1, word, visited)\n            || dfs(board, i - 1, j, k + 1, word, visited)\n            || dfs(board, i, j + 1, k + 1, word, visited)\n            || dfs(board, i, j - 1, k + 1, word, visited);\n    visited[i][j] = false;\n\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    board = inputs[0]\n    word = inputs[1]\n    result = exist(board, word)\n    print(result)",
            "javascript": "function exist(board, word) {\n    const m = board.length;\n    const n = board[0].length;\n\n    function dfs(i, j, k) {\n        if (i < 0 || i === m || j < 0 || j === n || board[i][j] !== word[k])\n            return false;\n        if (k === word.length - 1)\n            return true;\n        \n        const temp = board[i][j];\n        board[i][j] = '/';\n        const res = dfs(i + 1, j, k +1) || dfs(i - 1, j, k + 1) || dfs(i, j + 1, k + 1) || dfs(i, j - 1, k + 1);\n        board[i][j] = temp;\n        return res;\n    }\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (dfs(i, j, 0))\n                return true;\n        }\n    }\n    return false;\n}"
        }
    },
    "84": {
        "title": "Largest Rectangle in Histogram",
        "description": "Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, write a function that returns the area of the largest rectangle in the histogram.",
        "example": "Example:\n\nInput: heights = [2,1,5,6,2,3]\nOutput: 10\nExplanation: The above is a histogram where the width of each bar is 1. The largest rectangle is shown in the red area, which has an area of 10 units.",
        "level": "Medium",
        "tags": [
            "array",
            "stack",
            "histogram"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    1,
                    5,
                    6,
                    2,
                    3
                ],
                [
                    2,
                    4
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ]
            ],
            "outputs": [
                "10",
                "4",
                "9",
                "9",
                "5",
                "15",
                "30",
                "30",
                "10",
                "30"
            ]
        },
        "sample_code": {
            "c++": "int largestRectangleArea(vector<int>& heights) {\n    heights.push_back(0);\n    stack<int> s;\n    int max_area = 0;\n    for (int i = 0; i < heights.size(); i++) {\n        while (!s.empty() && heights[s.top()] > heights[i]) {\n            int height = heights[s.top()];\n            s.pop();\n            int width = s.empty() ? i : i - s.top() - 1;\n            max_area = max(max_area, height * width);\n        }\n        s.push(i);\n    }\n    return max_area;\n}\n",
            "java": "public int largestRectangleArea(int[] heights) {\n    Stack<Integer> stack = new Stack<>();\n    int max_area = 0;\n    for (int i = 0; i <= heights.length; i++) {\n        int height = (i == heights.length) ? 0 : heights[i];\n        while (!stack.isEmpty() && heights[stack.peek()] > height) {\n            int h = heights[stack.pop()];\n            int w = stack.isEmpty() ? i : i - stack.peek() - 1;\n            max_area = Math.max(max_area, h * w);\n        }\n        stack.push(i);\n    }\n    return max_area;\n}\n",
            "python": "def largestRectangleArea(heights):\n    stack = []\n    max_area = 0\n    for i, h in enumerate(heights + [0]):\n        while stack and heights[stack[-1]] > h:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        stack.append(i)\n    return max_area\n",
            "javascript": "function largestRectangleArea(heights) {\n    let stack = [];\n    let max_area = 0;\n    heights.push(0);\n    for (let i = 0; i < heights.length; i++) {\n        while (stack.length > 0 && heights[stack[stack.length - 1]] > heights[i]) {\n            let height = heights[stack.pop()];\n            let width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;\n            max_area = Math.max(max_area, height * width);\n        }\n        stack.push(i);\n    }\n    return max_area;\n}\n",
            "explanation": "The algorithm utilizes a stack to keep track of the indices of the heights array. It starts iterating through the array, appending a zero at the end to ensure the last bar is considered. When a higher bar is found, it is pushed onto the stack, and if a lower bar is found, it calculates the area of the bar under the current top of the stack considering the width between the current bar and the next lowest bar in the stack, storing the highest area found.\n\nThis algorithm has a time complexity of O(n) as it iterates through the heights only once, resulting in optimal performance."
        },
        "structure": {
            "c++": "int largestRectangleArea(vector<int>& heights) \n    // Your code here\n}\n",
            "java": "public int largestRectangleArea(int[] heights) \n    // Your code here\n}\n",
            "python": "def largestRectangleArea(heights):\n    # Your code here\n\n",
            "javascript": "function largestRectangleArea(heights) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int largestRectangleArea(vector<int>& heights) {\n    heights.push_back(0);\n    stack<int> s;\n    int max_area = 0;\n    for (int i = 0; i < heights.size(); i++) {\n        while (!s.empty() && heights[s.top()] > heights[i]) {\n            int height = heights[s.top()];\n            s.pop();\n            int width = s.empty() ? i : i - s.top() - 1;\n            max_area = max(max_area, height * width);\n        }\n        s.push(i);\n    }\n    return max_area;\n}",
            "java": "public int largestRectangleArea(int[] heights) {\n    Stack<Integer> stack = new Stack<>();\n    int max_area = 0;\n    for (int i = 0; i <= heights.length; i++) {\n        int height = (i == heights.length) ? 0 : heights[i];\n        while (!stack.isEmpty() && heights[stack.peek()] > height) {\n            int h = heights[stack.pop()];\n            int w = stack.isEmpty() ? i : i - stack.peek() - 1;\n            max_area = Math.max(max_area, h * w);\n        }\n        stack.push(i);\n    }\n    return max_area;\n}",
            "python": "if __name__ == \"__main__\":\n    heights = $args\n    result = largestRectangleArea(heights)\n    print(result)",
            "javascript": "function main() {\n    const heights = $args;\n    const result = largestRectangleArea(heights);\n    console.log(result);\n}"
        }
    },
    "87": {
        "title": "Scrambled String",
        "description": "Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1. A string can be scrambled by splitting it into two non-empty substrings at a random index and randomly deciding to swap the substrings or keep them in the same order. This process is applied recursively on each substring until the length of the substring is 1. If the scrambled string is equal to s2, return true; otherwise, return false.",
        "example": "Example:\n\nInput: s1 = \"great\", s2 = \"rgeat\"\nOutput: true\nExplanation: One possible scenario applied on s1 is:\n\"great\" -> \"gr/eat\" (divide at random index)\n\"gr/eat\" -> \"gr/eat\" (random decision is not to swap the two substrings and keep them in order)\n\"gr/eat\" -> \"g/r / e/at\" (apply the same algorithm recursively on both substrings, divide at random index each of them)\n\"g/r / e/at\" -> \"r/g / e/at\" (random decision was to swap the first substring and keep the second substring in the same order)\n\"r/g / e/at\" -> \"r/g / e/ a/t\" (again apply the algorithm recursively, divide \"at\" to \"a/t\")\n\"r/g / e/ a/t\" -> \"r/g / e/ a/t\" (random decision is to keep both substrings in the same order)\nThe algorithm stops now, and the result string is \"rgeat\" which is s2. As one possible scenario led s1 to be scrambled to s2, we return true.",
        "level": "Medium",
        "tags": [
            "string",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                "\"great\"",
                "\"rgeat\"",
                "\"abcde\"",
                "\"caebd\"",
                "\"a\"",
                "\"a\"",
                "\"hello\"",
                "\"loleh\"",
                "\"abcd\"",
                "\"dcba\"",
                "\"apple\"",
                "\"papel\"",
                "\"car\"",
                "\"arc\"",
                "\"good\"",
                "\"dogo\"",
                "\"programming\"",
                "\"gammirnropm\"",
                "\"algorithm\"",
                "\"mhtirogla\""
            ],
            "outputs": [
                true,
                true,
                false,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                false,
                true,
                true,
                true,
                true,
                false
            ]
        },
        "sample_code": {
            "c++": "bool isScramble(string s1, string s2) {\n    if (s1 == s2) return true;\n    if (s1.size() != s2.size() || sort(s1.begin(), s1.end()) != sort(s2.begin(), s2.end())) return false;\n\n    for (int i = 1; i < s1.size(); i++) {\n        if (isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i), s2.substr(i)))\n            return true;\n        if (isScramble(s1.substr(0, i), s2.substr(s2.size() - i)) && isScramble(s1.substr(i), s2.substr(0, s2.size() - i)))\n            return true;\n    }\n    return false;\n}\n",
            "java": "public boolean isScramble(String s1, String s2) {\n    if (s1.equals(s2)) return true;\n    if (sorted(s1).equals(sorted(s2)) == false) return false;\n\n    for (int i = 1; i < s1.length(); i++) {\n        if (isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i)))\n            return true;\n        if (isScramble(s1.substring(0, i), s2.substring(s2.length() - i)) && isScramble(s1.substring(i), s2.substring(0, s2.length() - i)))\n            return true;\n    }\n    return false;\n}\n\nprivate String sorted(String s) {\n    char[] chars = s.toCharArray();\n    Arrays.sort(chars);\n    return new String(chars);\n}\n",
            "python": "def isScramble(s1: str, s2: str) -> bool:\n    if s1 == s2:\n        return True\n    if len(s1) != len(s2) or sorted(s1) != sorted(s2):\n        return False\n\n    for i in range(1, len(s1)):\n        if (isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:])) or \\\n           (isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i])):\n            return True\n    return False\n",
            "javascript": "function isScramble(s1, s2) {\n    if (s1 === s2) return true;\n    if (s1.length !== s2.length || sorted(s1) !== sorted(s2)) return false;\n\n    for (let i = 1; i < s1.length; i++) {\n        if ((isScramble(s1.slice(0, i), s2.slice(0, i)) && isScramble(s1.slice(i), s2.slice(i))) || \n            (isScramble(s1.slice(0, i), s2.slice(s2.length - i)) && isScramble(s1.slice(i), s2.slice(0, s2.length - i))))\n            return true;\n    }\n    return false;\n}\n\nfunction sorted(s) {\n    return s.split('').sort().join('');\n}\n",
            "explanation": "The algorithm works by recursively dividing the strings into smaller substrings and checking if the substrings from s1 can be rearranged into the corresponding substrings of s2. The base case is when both strings (s1, and s2) are equal. If the lengths of the strings are different or the characters are different, then the function returns false. Then, we iterate through the length of strings, dividing the strings into smaller substrings and checking if these substrings can be rearranged to form the scrambled string. We check for both possible arrangements of the substrings, i.e., same order and reverse order, invoking the same function recursively for each combination."
        },
        "structure": {
            "c++": "bool isScramble(string s1, string s2) \n    // Your code here\n}\n",
            "java": "public boolean isScramble(String s1, String s2) \n    // Your code here\n}\n",
            "python": "def isScramble(s1: str, s2: str) -> bool:\n    # Your code here\n\n",
            "javascript": "function isScramble(s1, s2) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "bool result = isScramble($args);\nreturn result;",
            "java": "public boolean isScramble(String s1, String s2) {\n    if (s1.equals(s2)) return true;\n    if (sorted(s1).equals(sorted(s2)) == false) return false;\n\n    for (int i = 1; i < s1.length(); i++) {\n        if (isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i)))\n            return true;\n        if (isScramble(s1.substring(0, i), s2.substring(s2.length() - i)) && isScramble(s1.substring(i), s2.substring(0, s2.length() - i)))\n            return true;\n    }\n    return false;\n}\n\nprivate String sorted(String s) {\n    char[] chars = s.toCharArray();\n    Arrays.sort(chars);\n    return new String(chars);\n}",
            "python": "if __name__ == \"__main__\":\n    s1 = $args[0]\n    s2 = $args[1]\n    result = isScramble(s1, s2)\n    print(result)",
            "javascript": "function main() {\n    const s1 = $args[0];\n    const s2 = $args[1];\n    const result = isScramble(s1, s2);\n    console.log(result);\n}"
        }
    },
    "88": {
        "title": "Merge Sorted Arrays",
        "description": "You are given two integer arrays `nums1` and `nums2`, sorted in **non-decreasing order**, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively. Merge `nums1` and `nums2` into a single array sorted in **non-decreasing order**. The final sorted array should not be returned by the function, but instead be _stored inside the array_ `nums1`. To accommodate this, `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to `0` and should be ignored. `nums2` has a length of `n`.",
        "example": "Example:\n\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\nOutput: [1,2,2,3,5,6]\nExplanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.",
        "level": "Easy",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        2,
                        5,
                        6
                    ],
                    3
                ],
                [
                    [
                        1
                    ],
                    1,
                    [],
                    0
                ],
                [
                    [
                        0
                    ],
                    0,
                    [
                        1
                    ],
                    1
                ],
                [
                    [
                        1,
                        3,
                        5,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        2,
                        4,
                        6
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    6,
                    [],
                    0
                ],
                [
                    [],
                    0,
                    [
                        1,
                        2,
                        3
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    3,
                    [
                        7,
                        8,
                        9
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        4,
                        5,
                        6
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        0,
                        0,
                        0
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        1,
                        2,
                        3
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        0,
                        0,
                        1
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        0,
                        1,
                        2
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        0,
                        1,
                        3
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        0,
                        2,
                        3
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        1,
                        2,
                        4
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        1,
                        3,
                        4
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        2,
                        3,
                        4
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        2,
                        2,
                        2,
                        2,
                        2
                    ],
                    5
                ]
            ],
            "outputs": [
                [
                    1,
                    2,
                    2,
                    3,
                    5,
                    6
                ],
                [
                    1
                ],
                [
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6
                ],
                [
                    1,
                    2,
                    3
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6
                ],
                [
                    1,
                    2,
                    3
                ],
                [
                    1,
                    1,
                    2,
                    2,
                    3,
                    3
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2,
                    3,
                    3
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2,
                    3,
                    3
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2,
                    3,
                    3
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2,
                    3,
                    3
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2,
                    3,
                    4
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2,
                    3,
                    4
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2,
                    3,
                    4
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    2,
                    3
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    1,
                    1,
                    1,
                    1,
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    1,
                    1,
                    1,
                    1,
                    2,
                    2,
                    2,
                    2,
                    2
                ]
            ]
        },
        "sample_code": {
            "c++": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n    int i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j])\n            nums1[k--] = nums1[i--];\n        else\n            nums1[k--] = nums2[j--];\n    }\n    while (j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n}\n",
            "java": "public void merge(int[] nums1, int m, int[] nums2, int n) {\n    int i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j])\n            nums1[k--] = nums1[i--];\n        else\n            nums1[k--] = nums2[j--];\n    }\n    while (j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n}\n",
            "python": "def merge(nums1, m, nums2, n):\n    i, j, k = m - 1, n - 1, m + n - 1\n    while i >= 0 and j >= 0:\n        if nums1[i] > nums2[j]:\n            nums1[k] = nums1[i]\n            i -= 1\n        else:\n            nums1[k] = nums2[j]\n            j -= 1\n        k -= 1\n    while j >= 0:\n        nums1[k] = nums2[j]\n        k -= 1\n        j -= 1\n",
            "javascript": "function merge(nums1, m, nums2, n) {\n    let i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j])\n            nums1[k--] = nums1[i--];\n        else\n            nums1[k--] = nums2[j--];\n    }\n    while (j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n}\n",
            "explanation": "We use a two-pointer approach to merge nums1 and nums2 in reverse order. Initialize three pointers i, j, and k pointing to the last elements of nums1, nums2, and the merged nums1 array respectively.\n\nIterate in a while loop until i and j are both less than 0. Compare the values of nums1[i] and nums2[j]. If nums1[i] is greater, assign nums1[i] at position k in nums1, decrement i and k. Otherwise, assign nums2[j] at position k in nums1, and decrement j and k. This process continues for all elements in nums2.\n\nAfter the loop, if there are still elements remaining in nums2 (j >= 0), copy the remaining elements of nums2 to nums1. In this way, we merge nums1 and nums2 in non-decreasing order."
        },
        "structure": {
            "c++": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) \n    // Your code here\n}\n",
            "java": "public void merge(int[] nums1, int m, int[] nums2, int n) \n    // Your code here\n}\n",
            "python": "def merge(nums1, m, nums2, n):\n    # Your code here\n\n",
            "javascript": "function merge(nums1, m, nums2, n) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n    int i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j])\n            nums1[k--] = nums1[i--];\n        else\n            nums1[k--] = nums2[j--];\n    }\n    while (j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n}\n\nint main() {\n    vector<int> nums1 = $args;\n    int m = nums1.size();\n    vector<int> nums2;\n    int n = nums2.size();\n    merge(nums1, m, nums2, n);\n    for (int i = 0; i < m + n; i++) {\n        cout << nums1[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    nums1 = inputs[0]\n    m = inputs[1]\n    nums2 = inputs[2]\n    n = inputs[3]\n    merge(nums1, m, nums2, n)\n    print(nums1)"
        }
    },
    "91": {
        "title": "Decode Message",
        "description": "A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:\n\n'A' ->  \"1 \"\n'B' ->  \"2 \"\n...\n'Z' ->  \"26 \"\n\nTo **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106 \"` can be mapped into:\n\n*   `\"AAJF \"` with the grouping `(1 1 10 6)`\n*   `\"KJF \"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06 \"` cannot be mapped into `'F'` since `\"6 \"` is different from `\"06 \"`.\n\nGiven a string `s` containing only digits, return the **number** of ways to **decode** it.\n",
        "example": "Example:\n\nInput: s =  \"12 \"\nOutput: 2\nExplanation:  \"12 \" could be decoded as  \"AB \" (1 2) or  \"L \" (12).\n\nInput: s =  \"226 \"\nOutput: 3\nExplanation:  \"226 \" could be decoded as  \"BZ \" (2 26),  \"VF \" (22 6), or  \"BBF \" (2 2 6).\n\nInput: s =  \"06 \"\nOutput: 0\nExplanation:  \"06 \" cannot be mapped to  \"F \" because of the leading zero ( \"6 \" is different from  \"06 \").",
        "level": "Medium",
        "tags": [
            "String",
            "Dynamic Programming"
        ],
        "test_cases": {
            "inputs": [
                "12 ",
                "226 ",
                "11106 ",
                "1234567890",
                "1111111111",
                "1010101010",
                "2222222222",
                "9999999999",
                "12345678901234567890",
                "11111111111111111111",
                "10101010101010101010",
                "22222222222222222222",
                "99999999999999999999",
                "123456789012345678901234567890",
                "111111111111111111111111111111",
                "101010101010101010101010101010",
                "222222222222222222222222222222",
                "999999999999999999999999999999",
                "1234567890123456789012345678901234567890"
            ],
            "outputs": [
                2,
                3,
                4,
                89,
                89,
                89,
                89,
                89,
                10946,
                10946,
                10946,
                10946,
                10946,
                17711,
                17711,
                17711,
                17711,
                17711,
                28657
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <vector>\n\nint numDecodings(std::string s) {\n    int n = s.size();\n    std::vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n    dp[1] = s[0] != '0' ? 1 : 0;\n\n    for (int i = 2; i <= n; ++i) {\n        int oneDigit = stoi(s.substr(i - 1, 1));\n        int twoDigits = stoi(s.substr(i - 2, 2));\n\n        if (oneDigit >= 1)\n            dp[i] += dp[i - 1];\n        if (twoDigits >= 10 && twoDigits <= 26)\n            dp[i] += dp[i - 2];\n    }\n    return dp[n];\n}\n\n",
            "java": "public int numDecodings(String s) {\n    int n = s.length();\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = s.charAt(0) != '0' ? 1 : 0;\n\n    for (int i = 2; i <= n; i++) {\n        int oneDigit = Integer.parseInt(s.substring(i - 1, i));\n        int twoDigits = Integer.parseInt(s.substring(i - 2, i));\n\n        if (oneDigit >= 1)\n            dp[i] += dp[i - 1];\n        if (twoDigits >= 10 && twoDigits <= 26)\n            dp[i] += dp[i - 2];\n    }\n    return dp[n];\n}\n\n",
            "python": "def numDecodings(s: str) -> int:\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1 if s[0] != '0' else 0\n\n    for i in range(2, n + 1):\n        one_digit = int(s[i - 1:i])\n        two_digits = int(s[i - 2:i])\n\n        if one_digit >= 1:\n            dp[i] += dp[i - 1]\n        if two_digits >= 10 and two_digits <= 26:\n            dp[i] += dp[i - 2]\n    return dp[n]\n\n",
            "javascript": "var numDecodings = function(s) {\n    const n = s.length;\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = s[0] !== '0' ? 1 : 0;\n\n    for (let i = 2; i <= n; i++) {\n        const oneDigit = parseInt(s.slice(i - 1, i), 10);\n        const twoDigits = parseInt(s.slice(i - 2, i), 10);\n\n        if (oneDigit >= 1)\n            dp[i] += dp[i - 1];\n        if (twoDigits >= 10 && twoDigits <= 26)\n            dp[i] += dp[i - 2];\n    }\n    return dp[n];\n};\n\n",
            "explanation": "We use dynamic programming (DP) to solve this problem. The `dp` array is of size `n+1`, where `n` is the length of the input string `s`. `dp[i]` stores the number of ways to decode the substring `s[0:i]`.\n\nInitialize `dp[0]` to 1 because there is always one way to decode an empty string.\n\nFor each character in the string `s`, consider its corresponding one-digit and two-digits representations. If the one-digit representation is valid (>=1), we can increment `dp[i]` by `dp[i-1]`, which means one more way to decode the string by using the one-digit representation of the current character. If the two-digits representation is valid (>=10 and <=26), we can increment `dp[i]` by `dp[i-2]`, meaning one way to decode the string by using the two-digits representation of the current character.\n\nAfter we finished iterating through the string `s`, `dp[n]` will store the number of ways to decode the entire string."
        },
        "structure": {
            "c++": "#include <string>\n#include <vector>\n\nint numDecodings(std::string s) \n    // Your code here\n}\n\n",
            "java": "public int numDecodings(String s) \n    // Your code here\n}\n\n",
            "python": "def numDecodings(s: str) -> int:\n    # Your code here\n\n",
            "javascript": "var numDecodings = function(s) \n    // Your code here\n};\n\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    string s = $args;\n    int result = numDecodings(s);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = numDecodings(s)\n    print(result)"
        }
    },
    "92": {
        "title": "Reverse Linked List from Position",
        "description": "Given the `head` of a singly linked list and two integers `left` and `right` where `left <= right`, reverse the nodes of the list from position `left` to position `right`, and return the reversed list.",
        "example": "Example:\n\nInput: head = [1,2,3,4,5], left = 2, right = 4\nOutput: [1,4,3,2,5]\n\nInput: head = [5], left = 1, right = 1\nOutput: [5]",
        "level": "Medium",
        "tags": [
            "Linked List"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    2,
                    4
                ],
                [
                    [
                        5
                    ],
                    1,
                    1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1,
                    5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1,
                    2
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    4,
                    5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    3,
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1,
                    1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    5,
                    5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    2,
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    3,
                    4
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1,
                    5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1,
                    4
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    2,
                    5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1,
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    3,
                    5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    2,
                    4
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    4,
                    4
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    5,
                    5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1,
                    2
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    5,
                    4
                ]
            ],
            "outputs": [
                [
                    1,
                    4,
                    3,
                    2,
                    5
                ],
                [
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    2,
                    1,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    5,
                    4
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    3,
                    2,
                    4,
                    5
                ],
                [
                    1,
                    4,
                    3,
                    2,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    4,
                    3,
                    2,
                    1,
                    5
                ],
                [
                    1,
                    5,
                    4,
                    3,
                    2
                ],
                [
                    1,
                    3,
                    2,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    5,
                    4,
                    3
                ],
                [
                    1,
                    4,
                    3,
                    2,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ]
            ]
        },
        "sample_code": {
            "c++": "ListNode* reverseBetween(ListNode* head, int left, int right) {\n    if (!head || left == right) return head;\n    ListNode dummy(0);\n    dummy.next = head;\n    ListNode* pre = &dummy;\n    for (int i = 1; i < left; ++i) pre = pre->next;\n    ListNode* cur = pre->next;\n    for (int i = left; i < right; ++i) {\n        ListNode* t = cur->next;\n        cur->next = t->next;\n        t->next = pre->next;\n        pre->next = t;\n    }\n    return dummy.next;\n}\n",
            "java": "public ListNode reverseBetween(ListNode head, int left, int right) {\n    if (head == null || left == right) return head;\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode pre = dummy;\n    for (int i = 1; i < left; ++i) pre = pre.next;\n    ListNode cur = pre.next;\n    for (int i = left; i < right; ++i) {\n        ListNode t = cur.next;\n        cur.next = t.next;\n        t.next = pre.next;\n        pre.next = t;\n    }\n    return dummy.next;\n}\n",
            "python": "class ListNode:\n    def __init__(self,val):\n        self.val=val\n        self.next=None\n\ndef reverseBetween(head: ListNode, left: int, right: int) -> ListNode:\n    if not head or left == right:\n        return head\n    dummy = ListNode(0)\n    dummy.next = head\n    pre = dummy\n    for _ in range(left - 1):\n        pre = pre.next\n    cur = pre.next\n    for _ in range(left, right):\n        t = cur.next\n        cur.next = t.next\n        t.next = pre.next\n        pre.next = t\n    return dummy.next\n",
            "javascript": "function reverseBetween(head, left, right) {\n    if (!head || left === right) return head;\n    const dummy = new ListNode(0);\n    dummy.next = head;\n    let pre = dummy;\n    for (let i = 1; i < left; ++i) pre = pre.next;\n    let cur = pre.next;\n    for (let i = left; i < right; ++i) {\n        const t = cur.next;\n        cur.next = t.next;\n        t.next = pre.next;\n        pre.next = t;\n    }\n    return dummy.next;\n}\n",
            "explanation": "The algorithm creates a dummy node and connects it to the head of the linked list. It then iterates through the list, reversing the nodes from position `left` to `right`. It maintains pointers `pre` and `cur` to accomplish this. During each iteration, it temporarily stores the next node using a pointer `t`, then reverses the connections between the nodes.\n\nThis process is repeated for all languages; the only differences in implementation are syntax-related. \n\nIn C++, use pointers and \"->\" to access the next node. In Java and Python, we use dot notation to access the next attribute. In JavaScript, we also use dot notation and \"===\" for equality comparison between left and right."
        },
        "structure": {
            "c++": "ListNode* reverseBetween(ListNode* head, int left, int right) \n    // Your code here\n}\n",
            "java": "public ListNode reverseBetween(ListNode head, int left, int right) \n    // Your code here\n}\n",
            "python": "def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\n    # Your code here\n\n",
            "javascript": "function reverseBetween(head, left, right) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "ListNode* reverseBetween(ListNode* head, int left, int right) {\n    if (!head || left == right) return head;\n    ListNode dummy(0);\n    dummy.next = head;\n    ListNode* pre = &dummy;\n    for (int i = 1; i < left; ++i) pre = pre->next;\n    ListNode* cur = pre->next;\n    for (int i = left; i < right; ++i) {\n        ListNode* t = cur->next;\n        cur->next = t->next;\n        t->next = pre->next;\n        pre->next = t;\n    }\n    return dummy.next;\n}",
            "java": "public ListNode reverseBetween(ListNode head, int left, int right) {\n    if (head == null || left == right) return head;\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode pre = dummy;\n    for (int i = 1; i < left; ++i) pre = pre.next;\n    ListNode cur = pre.next;\n    for (int i = left; i < right; ++i) {\n        ListNode t = cur.next;\n        cur.next = t.next;\n        t.next = pre.next;\n        pre.next = t;\n    }\n    return dummy.next;\n}",
            "python": "if __name__ == \"__main__\":\n    head = $args[0]\n    left = $args[1]\n    right = $args[2]\n    result = reverseBetween(head, left, right)\n    print(result)"
        }
    },
    "93": {
        "title": "Valid IP Addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "example": "Example 1:\n\nInput: s = \"25525511135\"\nOutput: [\"255.255.11.135\", \"255.255.111.35\"]\n\nExample 2:\n\nInput: s = \"0000\"\nOutput: [\"0.0.0.0\"]\n\nExample 3:\n\nInput: s = \"101023\"\nOutput: [\"1.0.10.23\", \"1.0.102.3\", \"10.1.0.23\", \"10.10.2.3\", \"101.0.2.3\"]",
        "level": "Medium",
        "tags": [
            "String",
            "Backtracking"
        ],
        "test_cases": {
            "inputs": [
                "\"25525511135\"",
                "\"0000\"",
                "\"101023\"",
                "\"19216811\"",
                "\"123456789\"",
                "\"11111111111111111111\"",
                "\"12345678901234567890\"",
                "\"123456789012345678901\"",
                "\"1234567890123456789012\"",
                "\"12345678901234567890123\"",
                "\"123456789012345678901234\"",
                "\"1234567890123456789012345\"",
                "\"12345678901234567890123456\"",
                "\"123456789012345678901234567\"",
                "\"1234567890123456789012345678\"",
                "\"12345678901234567890123456789\"",
                "\"123456789012345678901234567890\"",
                "\"1234567890123456789012345678901\"",
                "\"12345678901234567890123456789012\"",
                "\"123456789012345678901234567890123\"",
                "\"1234567890123456789012345678901234\""
            ],
            "outputs": [
                "[\"255.255.11.135\", \"255.255.111.35\"]",
                "[\"0.0.0.0\"]",
                "[\"1.0.10.23\", \"1.0.102.3\", \"10.1.0.23\", \"10.10.2.3\", \"101.0.2.3\"]",
                "[\"192.168.1.1\"]",
                "[]",
                "[]",
                "[]",
                "[]",
                "[]",
                "[]",
                "[]",
                "[]",
                "[]",
                "[]",
                "[]",
                "[]",
                "[]",
                "[]",
                "[]",
                "[]"
            ]
        },
        "sample_code": {
            "c++": "#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> restore_ip_address(string s) {\n    vector<string> result;\n    string ip;\n    dfs(result, s, ip, 0, 0);\n    return result;\n}\n\nvoid dfs(vector<string>& result, string s, string ip, int start, int part) {\n    if (part == 4 && start == s.size()) {\n        ip.pop_back();\n        result.push_back(ip);\n        return;\n    }\n    if (part == 4 || start == s.size()) return;\n\n    int num = 0;\n    for (int i = start; i < s.size(); i++) {\n        num = num * 10 + (s[i] - '0');\n        if (num > 255) break;\n        ip += s[i];\n        dfs(result, s, ip + '.', i + 1, part + 1);\n        if (num == 0) break;\n    }\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> restoreIpAddresses(String s) {\n    List<String> result = new ArrayList<>();\n    dfs(s, 0, \"\", result, 0);\n    return result;\n}\n\nprivate void dfs(String s, int start, String ip, List<String> result, int part) {\n    if (part == 4 && start == s.length()) {\n        result.add(ip.substring(0, ip.length() - 1));\n        return;\n    }\n    if (part == 4 || start >= s.length()) return;\n\n    int num = 0;\n    for (int i = start; i < s.length(); i++) {\n        num = num * 10 + (s.charAt(i) - '0');\n        if (num > 255) break;\n        dfs(s, i + 1, ip + s.charAt(i) + \".\", result, part + 1);\n        if (num == 0) break;\n    }\n}\n\n",
            "python": "def restore_ip_addresses(s):\n    def dfs(s, start, ip, result, part):\n        if part == 4 and start == len(s):\n            result.append(ip[:-1])\n            return\n        if part == 4 or start >= len(s):\n            return\n\n        num = 0\n        for i in range(start, len(s)):\n            num = num * 10 + int(s[i])\n            if num > 255:\n                break\n            dfs(s, i + 1, ip + s[i] + \".\", result, part + 1)\n            if num == 0:\n                break\n\n    result = []\n    dfs(s, 0, \"\", result, 0)\n    return result\n\n",
            "javascript": "function restoreIpAddresses(s) {\n    const result = [];\n    dfs(s, 0, \"\", result, 0);\n    return result;\n}\n\nfunction dfs(s, start, ip, result, part) {\n    if (part === 4 && start === s.length) {\n        result.push(ip.slice(0, -1));\n        return;\n    }\n    if (part === 4 || start >= s.length) return;\n\n    let num = 0;\n    for (let i = start; i < s.length; i++) {\n        num = num * 10 + parseInt(s[i]);\n        if (num > 255) break;\n        dfs(s, i + 1, ip + s[i] + \".\", result, part + 1);\n        if (num === 0) break;\n    }\n}\n\n",
            "explanation": "We use a Depth-First Search algorithm to explore all possible configurations of the IP address. The function takes in the input string (s), the starting index (start), the partially constructed IP address (ip), and the current part count (part).\n\nIn each call to the function, we try to add one part to the IP address. If 4 parts have been added and we have reached the end of the input string, we have found a valid IP address and add it to the result list.\n\nThe algorithm iterates through the string s, starting at the current index. It keeps track of the current number (0-255) being constructed by multiplying the current number by 10 and adding the current digit. If the current number is greater than 255, we break the iteration.\n\nWe then call the dfs function recursively, with the current index incremented by one, the current IP appended with the current character and a dot, and incrementing part by 1. If the current number is 0 (which indicates a leading zero), we also break the iteration.\n\nThis process is repeated for all valid parts and combinations, eventually forming all possible valid IP addresses."
        },
        "structure": {
            "c++": "#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> restore_ip_address(string s) \n    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> restoreIpAddresses(String s) \n    // Your code here\n}\n\n",
            "python": "def restore_ip_addresses(s):\n    # Your code here\n\n",
            "javascript": "function restoreIpAddresses(s) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include<vector>\n#include<string>\nusing namespace std;\n\nint main() {\n    string s = $args;\n    vector<string> result = restore_ip_address(s);\n    for (string ip : result) {\n        cout << ip << endl;\n    }\n    return 0;\n}\n",
            "java": "public List<String> restoreIpAddresses(String s) {\n    List<String> result = new ArrayList<>();\n    dfs(s, 0, \"\", result, 0);\n    return result;\n}\n\nprivate void dfs(String s, int start, String ip, List<String> result, int part) {\n    if (part == 4 && start == s.length()) {\n        result.add(ip.substring(0, ip.length() - 1));\n        return;\n    }\n    if (part == 4 || start >= s.length()) return;\n\n    int num = 0;\n    for (int i = start; i < s.length(); i++) {\n        num = num * 10 + (s.charAt(i) - '0');\n        if (num > 255) break;\n        dfs(s, i + 1, ip + s.charAt(i) + \".\", result, part + 1);\n        if (num == 0) break;\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args[0]\n    result = restore_ip_addresses(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = restoreIpAddresses(s);\n    console.log(result);\n}"
        }
    },
    "97": {
        "title": "Interleaving Strings",
        "description": "Given strings `s1`, `s2`, and `s3`, find whether `s3` is formed by an **interleaving** of `s1` and `s2`. An **interleaving** of two strings `s` and `t` is a configuration where `s` and `t` are divided into `n` and `m` substrings respectively, such that: `s = s1 + s2 + ... + sn`, `t = t1 + t2 + ... + tm`, and `|n - m| <= 1`. The **interleaving** is `s1 + t1 + s2 + t2 + s3 + t3 + ...` or `t1 + s1 + t2 + s2 + t3 + s3 + ...`. Determine if `s3` can be obtained by interleaving `s1` and `s2`.",
        "example": "Given s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\", the function should return true. One way to obtain s3 is by splitting s1 into s1 = \"aa\" + \"bc\" + \"c\" and s2 into s2 = \"dbbc\" + \"a\". Interleaving the two splits, we get \"aa\" + \"dbbc\" + \"bc\" + \"a\" + \"c\" = \"aadbbcbcac\". Since s3 can be obtained by interleaving s1 and s2, the function should return true.",
        "level": "Medium",
        "tags": [
            "string",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    "aabcc",
                    "dbbca",
                    "aadbbcbcac"
                ],
                [
                    "aabcc",
                    "dbbca",
                    "aadbbbaccc"
                ],
                [
                    "",
                    "",
                    ""
                ],
                [
                    "abc",
                    "def",
                    "abcdef"
                ],
                [
                    "abc",
                    "def",
                    "abdecf"
                ],
                [
                    "abc",
                    "def",
                    "abcfed"
                ],
                [
                    "abc",
                    "def",
                    "abcfedg"
                ],
                [
                    "abc",
                    "def",
                    "abcfedgh"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghi"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghij"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghijk"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghijkl"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghijklm"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghijklmn"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghijklmno"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghijklmnop"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghijklmnopq"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghijklmnopqr"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghijklmnopqrs"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghijklmnopqrst"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghijklmnopqrstu"
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "bool isInterleave(string s1, string s2, string s3) {\n    int m = s1.length(), n = s2.length();\n    if (m + n != s3.length()) return false;\n\n    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\n    dp[0][0] = true;\n    for (int i = 1; i <= m; i++)\n        dp[i][0] = dp[i - 1][0] && s1[i - 1] == s3[i - 1];\n    for (int j = 1; j <= n; j++)\n        dp[0][j] = dp[0][j - 1] && s2[j - 1] == s3[j - 1];\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) ||\n                       (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\n        }\n    }\n\n    return dp[m][n];\n}\n",
            "java": "public boolean isInterleave(String s1, String s2, String s3) {\n    int m = s1.length(), n = s2.length();\n    if (m + n != s3.length()) return false;\n\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n    for (int i = 1; i <= m; i++)\n        dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1);\n    for (int j = 1; j <= n; j++)\n        dp[0][j] = dp[0][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) ||\n                       (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\n        }\n    }\n\n    return dp[m][n];\n}\n",
            "python": "def isInterleave(s1, s2, s3):\n    m, n = len(s1), len(s2)\n    if m + n != len(s3):\n        return False\n\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    for i in range(1, m + 1):\n        dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or \\\n                       (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]\n",
            "javascript": "function isInterleave(s1, s2, s3) {\n    let m = s1.length, n = s2.length;\n    if (m + n !== s3.length) return false;\n\n    let dp = new Array(m + 1).fill(null).map(() => new Array(n + 1).fill(false));\n    dp[0][0] = true;\n    for (let i = 1; i <= m; i++)\n        dp[i][0] = dp[i - 1][0] && s1[i - 1] === s3[i - 1];\n    for (let j = 1; j <= n; j++)\n        dp[0][j] = dp[0][j - 1] && s2[j - 1] === s3[j - 1];\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            dp[i][j] = (dp[i - 1][j] && s1[i - 1] === s3[i + j - 1]) ||\n                       (dp[i][j - 1] && s2[j - 1] === s3[i + j - 1]);\n        }\n    }\n\n    return dp[m][n];\n}\n",
            "explanation": "We use a dynamic programming approach (2D DP) to solve this problem. The algorithm checks whether the s3[position] is equal to s1 or s2 in the same dp[position]. If so, we take the value of the previous dp[i-1] or dp[j-1] accordingly if the characters match. For the base case, we start with initializing dp[0][0] to true since two empty strings can form an empty s3.\n\nAt the end of the iterations, the last element in the dp matrix (i.e. dp[m][n]) will represent whether s3 can be formed by an interleaving of s1 and s2."
        },
        "structure": {
            "c++": "bool isInterleave(string s1, string s2, string s3) \n    // Your code here\n}\n",
            "java": "public boolean isInterleave(String s1, String s2, String s3) \n    // Your code here\n}\n",
            "python": "def isInterleave(s1, s2, s3):\n    # Your code here\n\n",
            "javascript": "function isInterleave(s1, s2, s3) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "bool isInterleave(string s1, string s2, string s3) {\n    int m = s1.length(), n = s2.length();\n    if (m + n != s3.length()) return false;\n\n    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\n    dp[0][0] = true;\n    for (int i = 1; i <= m; i++)\n        dp[i][0] = dp[i - 1][0] && s1[i - 1] == s3[i - 1];\n    for (int j = 1; j <= n; j++)\n        dp[0][j] = dp[0][j - 1] && s2[j - 1] == s3[j - 1];\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) ||\n                       (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\n        }\n    }\n\n    return dp[m][n];\n}",
            "java": "public boolean isInterleave(String s1, String s2, String s3) {\n    int m = s1.length(), n = s2.length();\n    if (m + n != s3.length()) return false;\n\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n    for (int i = 1; i <= m; i++)\n        dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1);\n    for (int j = 1; j <= n; j++)\n        dp[0][j] = dp[0][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) ||\n                       (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\n        }\n    }\n\n    return dp[m][n];\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    s1 = inputs[0]\n    s2 = inputs[1]\n    s3 = inputs[2]\n    result = isInterleave(s1, s2, s3)\n    print(result)",
            "javascript": "function main() {\n    const s1 = $args[0];\n    const s2 = $args[1];\n    const s3 = $args[2];\n    const result = isInterleave(s1, s2, s3);\n    console.log(result);\n}"
        }
    },
    "99": {
        "title": "Recover Binary Search Tree",
        "description": "You are given the `root` of a binary search tree (BST), where the values of **exactly** two nodes of the tree were swapped by mistake. Your task is to recover the tree without changing its structure. Implement a function `recoverTree` to solve the problem.",
        "example": "Example 1:\n\nInput: root = [1,3,null,null,2]\nOutput: [3,1,null,null,2]\nExplanation: 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.\n\nExample 2:\n\nInput: root = [3,1,4,null,null,2]\nOutput: [2,1,4,null,null,3]\nExplanation: 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.",
        "level": "Medium",
        "tags": [
            "Binary Search Tree",
            "Tree Traversal",
            "In-order Traversal"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    3,
                    null,
                    null,
                    2
                ],
                [
                    3,
                    1,
                    4,
                    null,
                    null,
                    2
                ],
                [
                    2,
                    3,
                    1
                ],
                [
                    5,
                    3,
                    8,
                    2,
                    4,
                    7,
                    9
                ],
                [
                    4,
                    2,
                    7,
                    1,
                    3,
                    6,
                    9
                ],
                [
                    10,
                    5,
                    15,
                    3,
                    7,
                    12,
                    18,
                    1,
                    4,
                    6,
                    8,
                    11,
                    13,
                    17,
                    19
                ]
            ],
            "outputs": [
                [
                    3,
                    1,
                    null,
                    null,
                    2
                ],
                [
                    2,
                    1,
                    4,
                    null,
                    null,
                    3
                ],
                [
                    2,
                    3,
                    1
                ],
                [
                    5,
                    4,
                    8,
                    2,
                    3,
                    7,
                    9
                ],
                [
                    4,
                    2,
                    7,
                    1,
                    3,
                    6,
                    9
                ],
                [
                    10,
                    5,
                    15,
                    3,
                    7,
                    12,
                    18,
                    1,
                    4,
                    6,
                    8,
                    11,
                    13,
                    17,
                    19
                ]
            ]
        },
        "sample_code": {
            "c++": "void inorder(TreeNode* node, TreeNode*& first, TreeNode*& second, TreeNode*& prev) {\n    if (!node) return;\n    inorder(node->left, first, second, prev);\n    if (prev && prev->val > node->val) {\n        if (!first) first = prev;\n        second = node;\n    }\n    prev = node;\n    inorder(node->right, first, second, prev);\n}\n\nvoid recoverTree(TreeNode* root) {\n    TreeNode *first = nullptr, *second = nullptr, *prev = nullptr;\n    inorder(root, first, second, prev);\n    std::swap(first->val, second->val);\n}\n",
            "java": "void inorder(TreeNode node, TreeNode[] nodes) {\n    if (node == null) return;\n    inorder(node.left, nodes);\n    if (nodes[1] != null && nodes[1].val > node.val) {\n        if (nodes[0] == null) nodes[0] = nodes[1];\n        nodes[2] = node;\n    }\n    nodes[1] = node;\n    inorder(node.right, nodes);\n}\n\npublic void recoverTree(TreeNode root) {\n    TreeNode[] nodes = new TreeNode[3];\n    inorder(root, nodes);\n    int temp = nodes[0].val;\n    nodes[0].val = nodes[2].val;\n    nodes[2].val = temp;\n}\n",
            "python": "def inorder(node, nodes):\n    if not node: return\n    inorder(node.left, nodes)\n    if nodes[1] and nodes[1].val > node.val:\n        if not nodes[0]: nodes[0] = nodes[1]\n        nodes[2] = node\n    nodes[1] = node\n    inorder(node.right, nodes)\n\ndef recoverTree(root):\n    nodes = [None, None, None]\n    inorder(root, nodes)\n    nodes[0].val, nodes[2].val = nodes[2].val, nodes[0].val\n",
            "javascript": "function inorder(node, nodes) {\n    if (!node) return;\n    inorder(node.left, nodes);\n    if (nodes[1] && nodes[1].val > node.val) {\n        if (!nodes[0]) nodes[0] = nodes[1];\n        nodes[2] = node;\n    }\n    nodes[1] = node;\n    inorder(node.right, nodes);\n}\n\nfunction recoverTree(root) {\n    const nodes = [null, null, null];\n    inorder(root, nodes);\n    const temp = nodes[0].val;\n    nodes[0].val = nodes[2].val;\n    nodes[2].val = temp;\n}\n",
            "explanation": "We will solve this problem using the Inorder traversal of the binary search tree.\n\n1. Traverse the BST using Inorder traversal, and at each node, compare its value with the previous node.\n2. If the previous node's value is greater than the current node's value, it means they are swapped. So, mark the first such node as `first` and the second such node as `second`.\n3. After completing the Inorder traversal, swap the values of the `first` and `second` nodes.\n4. This approach is implemented in all four languages: C++, Java, Python, and JavaScript.\n\nNote that the TreeNode class should be defined for each implementation as it's not provided in the problem statement."
        },
        "structure": {
            "c++": "void inorder(TreeNode* node, TreeNode*& first, TreeNode*& second, TreeNode*& prev) \n    // Your code here\n}\n",
            "java": "void inorder(TreeNode node, TreeNode[] nodes) \n    // Your code here\n}\n",
            "python": "def inorder(node, nodes):\n    # Your code here\n\n",
            "javascript": "function inorder(node, nodes) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "void recoverTree(TreeNode* root) {\n    TreeNode *first = nullptr, *second = nullptr, *prev = nullptr;\n    inorder(root, first, second, prev);\n    std::swap(first->val, second->val);\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    root = TreeNode(inputs)\n    recoverTree(root)"
        }
    },
    "107": {
        "title": "Bottom-Up Level Order Traversal of Binary Tree",
        "description": "Given the `root` of a binary tree, return the bottom-up level order traversal of its nodes' values. The bottom-up level order traversal is the traversal of the tree from left to right, level by level, starting from the leaf nodes and ending at the root node.",
        "example": "Example 1:\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]\n\nExample 2:\n\nInput: root = [1]\nOutput: [[1]]\n\nExample 3:\n\nInput: root = []\nOutput: []",
        "level": "Medium",
        "tags": [
            "binary tree",
            "level order traversal",
            "bottom-up traversal"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    9,
                    20,
                    null,
                    null,
                    15,
                    7
                ],
                [
                    1
                ],
                [],
                [
                    5,
                    4,
                    8,
                    11,
                    null,
                    13,
                    4,
                    7,
                    2,
                    null,
                    null,
                    5,
                    1
                ]
            ],
            "outputs": [
                [
                    [
                        15,
                        7
                    ],
                    [
                        9,
                        20
                    ],
                    [
                        3
                    ]
                ],
                [
                    [
                        1
                    ]
                ],
                [],
                [
                    [
                        7,
                        2
                    ],
                    [
                        13,
                        4,
                        5,
                        1
                    ],
                    [
                        11,
                        4,
                        8
                    ],
                    [
                        5
                    ]
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <queue>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nstd::vector<std::vector<int>> levelOrderBottom(TreeNode* root) {\n    std::vector<std::vector<int>> result;\n    if (root == nullptr) return result;\n\n    std::queue<TreeNode*> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        std::vector<int> level;\n        int size = q.size();\n\n        for (int i = 0; i < size; i++) {\n            TreeNode* current = q.front();\n            q.pop();\n            level.push_back(current->val);\n\n            if (current->left) q.push(current->left);\n            if (current->right) q.push(current->right);\n        }\n        result.insert(result.begin(), level);\n    }\n\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic List<List<Integer>> levelOrderBottom(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.add(root);\n\n    while (!queue.isEmpty()) {\n        List<Integer> level = new ArrayList<>();\n        int size = queue.size();\n\n        for (int i = 0; i < size; i++) {\n            TreeNode current = queue.poll();\n            level.add(current.val);\n\n            if (current.left != null) queue.add(current.left);\n            if (current.right != null) queue.add(current.right);\n        }\n        result.add(0, level);\n    }\n\n    return result;\n}\n",
            "python": "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrderBottom(root):\n    result = []\n    if not root:\n        return result\n\n    queue = deque([root])\n\n    while queue:\n        level = []\n        size = len(queue)\n\n        for i in range(size):\n            current = queue.popleft()\n            level.append(current.val)\n\n            if current.left:\n                queue.append(current.left)\n            if current.right:\n                queue.append(current.right)\n\n        result.insert(0, level)\n\n    return result\n",
            "javascript": "class TreeNode {\n    constructor(val = 0, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction levelOrderBottom(root) {\n    const result = [];\n    if (!root) return result;\n\n    const queue = [root];\n\n    while (queue.length > 0) {\n        const level = [];\n        const size = queue.length;\n\n        for (let i = 0; i < size; i++) {\n            const current = queue.shift();\n            level.push(current.val);\n\n            if (current.left) queue.push(current.left);\n            if (current.right) queue.push(current.right);\n        }\n        result.unshift(level);\n    }\n\n    return result;\n}\n",
            "explanation": "The algorithm for bottom-up level order traversal of a binary tree works as follows:\n\n1. Create an empty result list.\n2. If the root is NULL, return the empty result list.\n3. Create a queue and push the root onto the queue.\n4. While the queue is not empty:\n   a. Create a new list to store the current level's nodes values.\n   b. Store the current queue size as the level size.\n   c. Iterate through the number of nodes in the level (using the level size).\n        i. Pop the front node (or dequeue) from the queue and add its value to the level list.\n       ii. If the popped node has a left child, push it onto the queue.\n      iii. If the popped node has a right child, push it onto the queue.\n   d. Insert the level list at the beginning of the result list (to achieve bottom-up order).\n5. Return the result list."
        },
        "structure": {
            "c++": "#include <vector>\n#include <queue>\n\nstruct TreeNode \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class TreeNode \n    // Your code here\n}\n",
            "python": "from collections import deque\n    # Your code here\n\n",
            "javascript": "class TreeNode \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <queue>\n\nint main() {\n    TreeNode* root = $args;\n    std::vector<std::vector<int>> result = levelOrderBottom(root);\n\n    for (const auto& level : result) {\n        for (const auto& val : level) {\n            std::cout << val << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}",
            "java": "public List<List<Integer>> levelOrderBottom(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.add(root);\n\n    while (!queue.isEmpty()) {\n        List<Integer> level = new ArrayList<>();\n        int size = queue.size();\n\n        for (int i = 0; i < size; i++) {\n            TreeNode current = queue.poll();\n            level.add(current.val);\n\n            if (current.left != null) queue.add(current.left);\n            if (current.right != null) queue.add(current.right);\n        }\n        result.add(0, level);\n    }\n\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    root = $args[0]\n    result = levelOrderBottom(root)\n    print(result)",
            "javascript": "function levelOrderBottom(root) {\n    const result = [];\n    if (!root) return result;\n\n    const queue = [root];\n\n    while (queue.length > 0) {\n        const level = [];\n        const size = queue.length;\n\n        for (let i = 0; i < size; i++) {\n            const current = queue.shift();\n            level.push(current.val);\n\n            if (current.left) queue.push(current.left);\n            if (current.right) queue.push(current.right);\n        }\n        result.unshift(level);\n    }\n\n    return result;\n}"
        }
    },
    "115": {
        "title": "Distinct Subsequences",
        "description": "Given two strings `s` and `t`, return the number of distinct subsequences of `s` which equals `t`. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. The test cases are generated so that the answer fits on a 32-bit signed integer.",
        "example": "Example:\n\nInput: s = \"rabbbit\", t = \"rabbit\"\nOutput: 3\nExplanation: There are 3 ways you can generate \"rabbit\" from s:\n1. \"rabb\" + \"it\"\n2. \"ra\" + \"bbit\"\n3. \"rab\" + \"bit\"",
        "level": "Medium",
        "tags": [
            "dynamic programming",
            "string"
        ],
        "test_cases": {
            "inputs": [
                [
                    "\"rabbbit\"",
                    "\"rabbit\""
                ],
                [
                    "\"babgbag\"",
                    "\"bag\""
                ],
                [
                    "\"abcde\"",
                    "\"ace\""
                ],
                [
                    "\"abcde\"",
                    "\"abcde\""
                ],
                [
                    "\"fgh\"",
                    "\"abcde\""
                ],
                [
                    "\"abcde\"",
                    "\"abcde\""
                ],
                [
                    "\"abcde\"",
                    "\"abcde\""
                ],
                [
                    "\"abcde\"",
                    "\"abcde\""
                ],
                [
                    "\"abcde\"",
                    "\"abcde\""
                ],
                [
                    "\"abcde\"",
                    "\"abcde\""
                ]
            ],
            "outputs": [
                3,
                5,
                0,
                1,
                0,
                1,
                1,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "int numDistinct(string s, string t) {\n    int m = s.size(), n = t.size();\n    vector<vector<unsigned int>> dp(m + 1, vector<unsigned int>(n + 1, 0));\n\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s[i - 1] == t[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n",
            "java": "public int numDistinct(String s, String t) {\n    int m = s.length(), n = t.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n",
            "python": "def numDistinct(s: str, t: str) -> int:\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[m][n]\n",
            "javascript": "function numDistinct(s, t) {\n    const m = s.length, n = t.length;\n    const dp = Array.from({length: m + 1}, () => Array(n + 1).fill(0));\n\n    for (let i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (s[i - 1] === t[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n",
            "explanation": "The algorithm uses dynamic programming to count the number of distinct subsequences. The main idea is to create a 2D table `dp` where `dp[i][j]` represents the number of distinct subsequences of the first `i` characters in string `s` that equal the first `j` characters in string `t`. \n\nThe algorithm initializes the first row of the table since there are no subsequences of an empty string. Then, it iterates through each character in both strings, comparing for equality. If the characters are equal, the value of `dp[i][j]` is updated to `dp[i - 1][j - 1] + dp[i - 1][j]`. If the characters are not equal, the value of `dp[i][j]` is updated to `dp[i - 1][j]`. After filling the 2D table, the value at `dp[m][n]` represents the total number of distinct subsequences of `s` that equal `t`."
        },
        "structure": {
            "c++": "int numDistinct(string s, string t) \n    // Your code here\n}\n",
            "java": "public int numDistinct(String s, String t) \n    // Your code here\n}\n",
            "python": "def numDistinct(s: str, t: str) -> int:\n    # Your code here\n\n",
            "javascript": "function numDistinct(s, t) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int numDistinct(string s, string t) {\n    int m = s.size(), n = t.size();\n    vector<vector<unsigned int>> dp(m + 1, vector<unsigned int>(n + 1, 0));\n\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s[i - 1] == t[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}",
            "java": "public int numDistinct(String s, String t) {\n    int m = s.length(), n = t.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    s = inputs[0]\n    t = inputs[1]\n    result = numDistinct(s, t)\n    print(result)",
            "javascript": "function main() {\n    const s = $args[0];\n    const t = $args[1];\n    const result = numDistinct(s, t);\n    console.log(result);\n}"
        }
    },
    "116": {
        "title": "Populate Next Right Pointers in Each Node",
        "description": "You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:\n\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\n\nInitially, all next pointers are set to NULL.",
        "example": "Example:\n\nInput: root = [1,2,3,4,5,6,7]\nOutput: [1,#,2,3,#,4,5,6,7,#]\nExplanation: Given the above perfect binary tree, your function should populate each next pointer to point to its next right node, just like in the example output. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.",
        "level": "Medium",
        "tags": [
            "binary tree",
            "pointers"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7
                    ]
                ],
                [
                    []
                ],
                [
                    [
                        1
                    ]
                ],
                [
                    [
                        1,
                        2
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17
                    ]
                ]
            ],
            "outputs": [
                {
                    "result": [
                        1,
                        null,
                        2,
                        3,
                        null,
                        4,
                        5,
                        6,
                        7,
                        null
                    ]
                },
                {
                    "result": []
                },
                {
                    "result": [
                        1,
                        null
                    ]
                },
                {
                    "result": [
                        1,
                        null,
                        2,
                        null
                    ]
                },
                {
                    "result": [
                        1,
                        null,
                        2,
                        3,
                        null
                    ]
                },
                {
                    "result": [
                        1,
                        null,
                        2,
                        3,
                        null,
                        4,
                        null
                    ]
                },
                {
                    "result": [
                        1,
                        null,
                        2,
                        3,
                        null,
                        4,
                        5,
                        null
                    ]
                },
                {
                    "result": [
                        1,
                        null,
                        2,
                        3,
                        null,
                        4,
                        5,
                        6,
                        null
                    ]
                },
                {
                    "result": [
                        1,
                        null,
                        2,
                        3,
                        null,
                        4,
                        5,
                        6,
                        7,
                        null
                    ]
                },
                {
                    "result": [
                        1,
                        null,
                        2,
                        3,
                        null,
                        4,
                        5,
                        6,
                        7,
                        8,
                        null
                    ]
                },
                {
                    "result": [
                        1,
                        null,
                        2,
                        3,
                        null,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        null
                    ]
                },
                {
                    "result": [
                        1,
                        null,
                        2,
                        3,
                        null,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        null
                    ]
                },
                {
                    "result": [
                        1,
                        null,
                        2,
                        3,
                        null,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        null
                    ]
                },
                {
                    "result": [
                        1,
                        null,
                        2,
                        3,
                        null,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        null
                    ]
                },
                {
                    "result": [
                        1,
                        null,
                        2,
                        3,
                        null,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        null
                    ]
                },
                {
                    "result": [
                        1,
                        null,
                        2,
                        3,
                        null,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        null
                    ]
                },
                {
                    "result": [
                        1,
                        null,
                        2,
                        3,
                        null,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15,
                        null
                    ]
                },
                {
                    "result": [
                        1,
                        null,
                        2,
                        3,
                        null,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        null
                    ]
                },
                {
                    "result": [
                        1,
                        null,
                        2,
                        3,
                        null,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        null
                    ]
                }
            ]
        },
        "sample_code": {
            "c++": "void connect(Node* root) {\n    if (!root) return;\n    if (root->left) {\n        root->left->next = root->right;\n        if (root->next) {\n            root->right->next = root->next->left;\n        }\n    }\n    connect(root->left);\n    connect(root->right);\n}\n\n",
            "java": "public void connect(TreeLinkNode root) {\n    if (root == null || root.left == null) return;\n    root.left.next = root.right;\n    if (root.next != null) {\n        root.right.next = root.next.left;\n    }\n    connect(root.left);\n    connect(root.right);\n}\n\n",
            "python": "def connect(self, root: 'Node') -> 'Node':\n    if not root or not root.left:\n        return root\n    root.left.next = root.right\n    if root.next:\n        root.right.next = root.next.left\n    self.connect(root.left)\n    self.connect(root.right)\n    return root\n\n",
            "javascript": "function connect(root) {\n    if (root === null || root.left === null) return root;\n    root.left.next = root.right;\n    if (root.next !== null) {\n        root.right.next = root.next.left;\n    }\n    connect(root.left);\n    connect(root.right);\n    return root;\n}\n\n",
            "explanation": "The algorithm to populate the next pointers is a simple modification of the pre-order traversal of the binary tree. We start with the root, and for each node, we check if it has left and right children. If so, we set the left child's next pointer to point to the right child. If the current node's next pointer is not null, we set its right child's next pointer to the left child of its next node. Finally, we recursively call the function on the left and right children."
        },
        "structure": {
            "c++": "void connect(Node* root) \n    // Your code here\n}\n\n",
            "java": "public void connect(TreeLinkNode root) \n    // Your code here\n}\n\n",
            "python": "def connect(self, root: 'Node') -> 'Node':\n    # Your code here\n\n",
            "javascript": "function connect(root) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "void connect(Node* root) {\n    if (!root) return;\n    if (root->left) {\n        root->left->next = root->right;\n        if (root->next) {\n            root->right->next = root->next->left;\n        }\n    }\n    connect(root->left);\n    connect(root->right);\n}"
        }
    },
    "120": {
        "title": "Minimum Path Sum in Triangle",
        "description": "Given a `triangle` array, find the minimum path sum from top to bottom. For each step, you may move to an adjacent number of the row below. More formally, if you are on index `i` on the current row, you may move to either index `i` or index `i + 1` on the next row.",
        "example": "Example 1:\n\nInput: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\nOutput: 11\nExplanation: The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11.\n\nExample 2:\n\nInput: triangle = [[-10]]\nOutput: -10\nExplanation: The triangle has only one element, so the minimum path sum is -10.",
        "level": "Medium",
        "tags": [
            "dynamic programming",
            "triangle",
            "minimum path sum"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        6,
                        5,
                        7
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ]
                ],
                [
                    [
                        -10
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ]
                ],
                [
                    [
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14
                    ],
                    [
                        15,
                        16,
                        17,
                        18,
                        19
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14
                    ],
                    [
                        15,
                        16,
                        17,
                        18,
                        19
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ],
                    [
                        -40,
                        -41,
                        -42,
                        -43,
                        -44,
                        -45,
                        -46,
                        -47,
                        -48,
                        -49
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ],
                    [
                        -40,
                        -41,
                        -42,
                        -43,
                        -44,
                        -45,
                        -46,
                        -47,
                        -48,
                        -49
                    ],
                    [
                        -50,
                        -51,
                        -52,
                        -53,
                        -54,
                        -55,
                        -56,
                        -57,
                        -58,
                        -59,
                        -60
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ],
                    [
                        -40,
                        -41,
                        -42,
                        -43,
                        -44,
                        -45,
                        -46,
                        -47,
                        -48,
                        -49
                    ],
                    [
                        -50,
                        -51,
                        -52,
                        -53,
                        -54,
                        -55,
                        -56,
                        -57,
                        -58,
                        -59,
                        -60
                    ],
                    [
                        -61,
                        -62,
                        -63,
                        -64,
                        -65,
                        -66,
                        -67,
                        -68,
                        -69,
                        -70,
                        -71,
                        -72
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ],
                    [
                        -40,
                        -41,
                        -42,
                        -43,
                        -44,
                        -45,
                        -46,
                        -47,
                        -48,
                        -49
                    ],
                    [
                        -50,
                        -51,
                        -52,
                        -53,
                        -54,
                        -55,
                        -56,
                        -57,
                        -58,
                        -59,
                        -60
                    ],
                    [
                        -61,
                        -62,
                        -63,
                        -64,
                        -65,
                        -66,
                        -67,
                        -68,
                        -69,
                        -70,
                        -71,
                        -72
                    ],
                    [
                        -73,
                        -74,
                        -75,
                        -76,
                        -77,
                        -78,
                        -79,
                        -80,
                        -81,
                        -82,
                        -83,
                        -84,
                        -85
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ],
                    [
                        -40,
                        -41,
                        -42,
                        -43,
                        -44,
                        -45,
                        -46,
                        -47,
                        -48,
                        -49
                    ],
                    [
                        -50,
                        -51,
                        -52,
                        -53,
                        -54,
                        -55,
                        -56,
                        -57,
                        -58,
                        -59,
                        -60
                    ],
                    [
                        -61,
                        -62,
                        -63,
                        -64,
                        -65,
                        -66,
                        -67,
                        -68,
                        -69,
                        -70,
                        -71,
                        -72
                    ],
                    [
                        -73,
                        -74,
                        -75,
                        -76,
                        -77,
                        -78,
                        -79,
                        -80,
                        -81,
                        -82,
                        -83,
                        -84,
                        -85
                    ],
                    [
                        -86,
                        -87,
                        -88,
                        -89,
                        -90,
                        -91,
                        -92,
                        -93,
                        -94,
                        -95,
                        -96,
                        -97,
                        -98,
                        -99
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ],
                    [
                        -40,
                        -41,
                        -42,
                        -43,
                        -44,
                        -45,
                        -46,
                        -47,
                        -48,
                        -49
                    ],
                    [
                        -50,
                        -51,
                        -52,
                        -53,
                        -54,
                        -55,
                        -56,
                        -57,
                        -58,
                        -59,
                        -60
                    ],
                    [
                        -61,
                        -62,
                        -63,
                        -64,
                        -65,
                        -66,
                        -67,
                        -68,
                        -69,
                        -70,
                        -71,
                        -72
                    ],
                    [
                        -73,
                        -74,
                        -75,
                        -76,
                        -77,
                        -78,
                        -79,
                        -80,
                        -81,
                        -82,
                        -83,
                        -84,
                        -85
                    ],
                    [
                        -86,
                        -87,
                        -88,
                        -89,
                        -90,
                        -91,
                        -92,
                        -93,
                        -94,
                        -95,
                        -96,
                        -97,
                        -98,
                        -99
                    ],
                    [
                        -100,
                        -101,
                        -102,
                        -103,
                        -104,
                        -105,
                        -106,
                        -107,
                        -108,
                        -109,
                        -110,
                        -111,
                        -112,
                        -113,
                        -114
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ],
                    [
                        -40,
                        -41,
                        -42,
                        -43,
                        -44,
                        -45,
                        -46,
                        -47,
                        -48,
                        -49
                    ],
                    [
                        -50,
                        -51,
                        -52,
                        -53,
                        -54,
                        -55,
                        -56,
                        -57,
                        -58,
                        -59,
                        -60
                    ],
                    [
                        -61,
                        -62,
                        -63,
                        -64,
                        -65,
                        -66,
                        -67,
                        -68,
                        -69,
                        -70,
                        -71,
                        -72
                    ],
                    [
                        -73,
                        -74,
                        -75,
                        -76,
                        -77,
                        -78,
                        -79,
                        -80,
                        -81,
                        -82,
                        -83,
                        -84,
                        -85
                    ],
                    [
                        -86,
                        -87,
                        -88,
                        -89,
                        -90,
                        -91,
                        -92,
                        -93,
                        -94,
                        -95,
                        -96,
                        -97,
                        -98,
                        -99
                    ],
                    [
                        -100,
                        -101,
                        -102,
                        -103,
                        -104,
                        -105,
                        -106,
                        -107,
                        -108,
                        -109,
                        -110,
                        -111,
                        -112,
                        -113,
                        -114
                    ],
                    [
                        -115,
                        -116,
                        -117,
                        -118,
                        -119,
                        -120,
                        -121,
                        -122,
                        -123,
                        -124,
                        -125,
                        -126,
                        -127,
                        -128,
                        -129,
                        -130
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ],
                    [
                        -40,
                        -41,
                        -42,
                        -43,
                        -44,
                        -45,
                        -46,
                        -47,
                        -48,
                        -49
                    ],
                    [
                        -50,
                        -51,
                        -52,
                        -53,
                        -54,
                        -55,
                        -56,
                        -57,
                        -58,
                        -59,
                        -60
                    ],
                    [
                        -61,
                        -62,
                        -63,
                        -64,
                        -65,
                        -66,
                        -67,
                        -68,
                        -69,
                        -70,
                        -71,
                        -72
                    ],
                    [
                        -73,
                        -74,
                        -75,
                        -76,
                        -77,
                        -78,
                        -79,
                        -80,
                        -81,
                        -82,
                        -83,
                        -84,
                        -85
                    ],
                    [
                        -86,
                        -87,
                        -88,
                        -89,
                        -90,
                        -91,
                        -92,
                        -93,
                        -94,
                        -95,
                        -96,
                        -97,
                        -98,
                        -99
                    ],
                    [
                        -100,
                        -101,
                        -102,
                        -103,
                        -104,
                        -105,
                        -106,
                        -107,
                        -108,
                        -109,
                        -110,
                        -111,
                        -112,
                        -113,
                        -114
                    ],
                    [
                        -115,
                        -116,
                        -117,
                        -118,
                        -119,
                        -120,
                        -121,
                        -122,
                        -123,
                        -124,
                        -125,
                        -126,
                        -127,
                        -128,
                        -129,
                        -130
                    ],
                    [
                        -131,
                        -132,
                        -133,
                        -134,
                        -135,
                        -136,
                        -137,
                        -138,
                        -139,
                        -140,
                        -141,
                        -142,
                        -143,
                        -144,
                        -145,
                        -146,
                        -147
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ],
                    [
                        -40,
                        -41,
                        -42,
                        -43,
                        -44,
                        -45,
                        -46,
                        -47,
                        -48,
                        -49
                    ],
                    [
                        -50,
                        -51,
                        -52,
                        -53,
                        -54,
                        -55,
                        -56,
                        -57,
                        -58,
                        -59,
                        -60
                    ],
                    [
                        -61,
                        -62,
                        -63,
                        -64,
                        -65,
                        -66,
                        -67,
                        -68,
                        -69,
                        -70,
                        -71,
                        -72
                    ],
                    [
                        -73,
                        -74,
                        -75,
                        -76,
                        -77,
                        -78,
                        -79,
                        -80,
                        -81,
                        -82,
                        -83,
                        -84,
                        -85
                    ],
                    [
                        -86,
                        -87,
                        -88,
                        -89,
                        -90,
                        -91,
                        -92,
                        -93,
                        -94,
                        -95,
                        -96,
                        -97,
                        -98,
                        -99
                    ],
                    [
                        -100,
                        -101,
                        -102,
                        -103,
                        -104,
                        -105,
                        -106,
                        -107,
                        -108,
                        -109,
                        -110,
                        -111,
                        -112,
                        -113,
                        -114
                    ],
                    [
                        -115,
                        -116,
                        -117,
                        -118,
                        -119,
                        -120,
                        -121,
                        -122,
                        -123,
                        -124,
                        -125,
                        -126,
                        -127,
                        -128,
                        -129,
                        -130
                    ],
                    [
                        -131,
                        -132,
                        -133,
                        -134,
                        -135,
                        -136,
                        -137,
                        -138,
                        -139,
                        -140,
                        -141,
                        -142,
                        -143,
                        -144,
                        -145,
                        -146,
                        -147
                    ],
                    [
                        -148,
                        -149,
                        -150,
                        -151,
                        -152,
                        -153,
                        -154,
                        -155,
                        -156,
                        -157,
                        -158,
                        -159,
                        -160,
                        -161,
                        -162,
                        -163,
                        -164,
                        -165
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ],
                    [
                        -40,
                        -41,
                        -42,
                        -43,
                        -44,
                        -45,
                        -46,
                        -47,
                        -48,
                        -49
                    ],
                    [
                        -50,
                        -51,
                        -52,
                        -53,
                        -54,
                        -55,
                        -56,
                        -57,
                        -58,
                        -59,
                        -60
                    ],
                    [
                        -61,
                        -62,
                        -63,
                        -64,
                        -65,
                        -66,
                        -67,
                        -68,
                        -69,
                        -70,
                        -71,
                        -72
                    ],
                    [
                        -73,
                        -74,
                        -75,
                        -76,
                        -77,
                        -78,
                        -79,
                        -80,
                        -81,
                        -82,
                        -83,
                        -84,
                        -85
                    ],
                    [
                        -86,
                        -87,
                        -88,
                        -89,
                        -90,
                        -91,
                        -92,
                        -93,
                        -94,
                        -95,
                        -96,
                        -97,
                        -98,
                        -99
                    ],
                    [
                        -100,
                        -101,
                        -102,
                        -103,
                        -104,
                        -105,
                        -106,
                        -107,
                        -108,
                        -109,
                        -110,
                        -111,
                        -112,
                        -113,
                        -114
                    ],
                    [
                        -115,
                        -116,
                        -117,
                        -118,
                        -119,
                        -120,
                        -121,
                        -122,
                        -123,
                        -124,
                        -125,
                        -126,
                        -127,
                        -128,
                        -129,
                        -130
                    ],
                    [
                        -131,
                        -132,
                        -133,
                        -134,
                        -135,
                        -136,
                        -137,
                        -138,
                        -139,
                        -140,
                        -141,
                        -142,
                        -143,
                        -144,
                        -145,
                        -146,
                        -147
                    ],
                    [
                        -148,
                        -149,
                        -150,
                        -151,
                        -152,
                        -153,
                        -154,
                        -155,
                        -156,
                        -157,
                        -158,
                        -159,
                        -160,
                        -161,
                        -162,
                        -163,
                        -164,
                        -165
                    ],
                    [
                        -166,
                        -167,
                        -168,
                        -169,
                        -170,
                        -171,
                        -172,
                        -173,
                        -174,
                        -175,
                        -176,
                        -177,
                        -178,
                        -179,
                        -180,
                        -181,
                        -182,
                        -183
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ],
                    [
                        -40,
                        -41,
                        -42,
                        -43,
                        -44,
                        -45,
                        -46,
                        -47,
                        -48,
                        -49
                    ],
                    [
                        -50,
                        -51,
                        -52,
                        -53,
                        -54,
                        -55,
                        -56,
                        -57,
                        -58,
                        -59,
                        -60
                    ],
                    [
                        -61,
                        -62,
                        -63,
                        -64,
                        -65,
                        -66,
                        -67,
                        -68,
                        -69,
                        -70,
                        -71,
                        -72
                    ],
                    [
                        -73,
                        -74,
                        -75,
                        -76,
                        -77,
                        -78,
                        -79,
                        -80,
                        -81,
                        -82,
                        -83,
                        -84,
                        -85
                    ],
                    [
                        -86,
                        -87,
                        -88,
                        -89,
                        -90,
                        -91,
                        -92,
                        -93,
                        -94,
                        -95,
                        -96,
                        -97,
                        -98,
                        -99
                    ],
                    [
                        -100,
                        -101,
                        -102,
                        -103,
                        -104,
                        -105,
                        -106,
                        -107,
                        -108,
                        -109,
                        -110,
                        -111,
                        -112,
                        -113,
                        -114
                    ],
                    [
                        -115,
                        -116,
                        -117,
                        -118,
                        -119,
                        -120,
                        -121,
                        -122,
                        -123,
                        -124,
                        -125,
                        -126,
                        -127,
                        -128,
                        -129,
                        -130
                    ],
                    [
                        -131,
                        -132,
                        -133,
                        -134,
                        -135,
                        -136,
                        -137,
                        -138,
                        -139,
                        -140,
                        -141,
                        -142,
                        -143,
                        -144,
                        -145,
                        -146,
                        -147
                    ],
                    [
                        -148,
                        -149,
                        -150,
                        -151,
                        -152,
                        -153,
                        -154,
                        -155,
                        -156,
                        -157,
                        -158,
                        -159,
                        -160,
                        -161,
                        -162,
                        -163,
                        -164,
                        -165
                    ],
                    [
                        -166,
                        -167,
                        -168,
                        -169,
                        -170,
                        -171,
                        -172,
                        -173,
                        -174,
                        -175,
                        -176,
                        -177,
                        -178,
                        -179,
                        -180,
                        -181,
                        -182,
                        -183
                    ],
                    [
                        -184,
                        -185,
                        -186,
                        -187,
                        -188,
                        -189,
                        -190,
                        -191,
                        -192,
                        -193,
                        -194,
                        -195,
                        -196,
                        -197,
                        -198,
                        -199,
                        -200,
                        -201
                    ]
                ]
            ],
            "outputs": [
                "11",
                "-10",
                "15",
                "-1",
                "55",
                "56",
                "-15",
                "-25",
                "-35",
                "-45",
                "-55",
                "-66",
                "-78",
                "-91",
                "-105",
                "-120",
                "-136",
                "-153",
                "-171",
                "-190"
            ]
        },
        "sample_code": {
            "c++": "int minimumTotal(vector<vector<int>>& triangle) {\n    for (int row = triangle.size() - 2; row >= 0; row--) {\n        for (int col = 0; col < triangle[row].size(); col++) {\n            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1]);\n        }\n    }\n    return triangle[0][0];\n}\n",
            "java": "public int minimumTotal(List<List<Integer>> triangle) {\n    for (int row = triangle.size() - 2; row >= 0; row--) {\n        for (int col = 0; col < triangle.get(row).size(); col++) {\n            int minSum = Math.min(triangle.get(row + 1).get(col), triangle.get(row + 1).get(col + 1));\n            triangle.get(row).set(col, triangle.get(row).get(col) + minSum);\n        }\n    }\n    return triangle.get(0).get(0);\n}\n",
            "python": "def minimumTotal(triangle):\n    for row in range(len(triangle) - 2, -1, -1):\n        for col in range(len(triangle[row])):\n            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])\n    return triangle[0][0]\n",
            "javascript": "function minimumTotal(triangle) {\n    for (let row = triangle.length - 2; row >= 0; row--) {\n        for (let col = 0; col < triangle[row].length; col++) {\n            triangle[row][col] += Math.min(triangle[row + 1][col], triangle[row + 1][col + 1]);\n        }\n    }\n    return triangle[0][0];\n}\n",
            "explanation": "The algorithm starts from the second last row of the triangle, moving bottom-up. For each number in the current row, we add the minimum adjacent number in the row below it. This is done for all numbers in the current row. Then, we move to the row above and repeat the process. This way, we are calculating the minimum path sum for each number in the triangle until we reach the top. Finally, the minimum path sum from top to bottom can be found in the top-most number (triangle[0][0]) after these operations are complete."
        },
        "structure": {
            "c++": "int minimumTotal(vector<vector<int>>& triangle) \n    // Your code here\n}\n",
            "java": "public int minimumTotal(List<List<Integer>> triangle) \n    // Your code here\n}\n",
            "python": "def minimumTotal(triangle):\n    # Your code here\n\n",
            "javascript": "function minimumTotal(triangle) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<vector<int>> triangle = $args;\n    int result = minimumTotal(triangle);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int minimumTotal(List<List<Integer>> triangle) {\n    for (int row = triangle.size() - 2; row >= 0; row--) {\n        for (int col = 0; col < triangle.get(row).size(); col++) {\n            int minSum = Math.min(triangle.get(row + 1).get(col), triangle.get(row + 1).get(col + 1));\n            triangle.get(row).set(col, triangle.get(row).get(col) + minSum);\n        }\n    }\n    return triangle.get(0).get(0);\n}",
            "python": "if __name__ == \"__main__\":\n    triangle = $args\n    result = minimumTotal(triangle)\n    print(result)",
            "javascript": "function main() {\n    const triangle = $args;\n    const result = minimumTotal(triangle);\n    console.log(result);\n}"
        }
    },
    "121": {
        "title": "Maximize Stock Profit",
        "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day. You want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
        "example": "Example:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.",
        "level": "Easy",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    7,
                    1,
                    5,
                    3,
                    6,
                    4
                ],
                [
                    7,
                    6,
                    4,
                    3,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ]
            ],
            "outputs": [
                5,
                0,
                4,
                0,
                0,
                9,
                0,
                4,
                4,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16
            ]
        },
        "sample_code": {
            "c++": "int maxProfit(vector<int>& prices) {\n    int minPrice = INT_MAX;\n    int maxProfit = 0;\n    for (int price : prices) {\n        minPrice = min(minPrice, price);\n        maxProfit = max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}\n",
            "java": "public int maxProfit(int[] prices) {\n    int minPrice = Integer.MAX_VALUE;\n    int maxProfit = 0;\n    for (int price : prices) {\n        minPrice = Math.min(minPrice, price);\n        maxProfit = Math.max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}\n",
            "python": "def maxProfit(prices):\n    minPrice = float('inf')\n    maxProfit = 0\n    for price in prices:\n        minPrice = min(minPrice, price)\n        maxProfit = max(maxProfit, price - minPrice)\n    return maxProfit\n",
            "javascript": "function maxProfit(prices) {\n    let minPrice = Number.MAX_VALUE;\n    let maxProfit = 0;\n    for (const price of prices) {\n        minPrice = Math.min(minPrice, price);\n        maxProfit = Math.max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}\n",
            "explanation": "The algorithm iterates through the input array of prices. We maintain two variables: `minPrice` to track the minimum price encountered up to the current day, and `maxProfit` to track maximum achievable profit. \n\nFor each day, we update:\n1. `minPrice` by comparing its value with the current day's stock price.\n2. `maxProfit` by comparing its value with the difference between the current day's stock price and the minimum stock price encountered so far.\n\nAt the end of the iteration, the algorithm returns the value stored in `maxProfit`, which is the maximum possible profit that can be achieved."
        },
        "structure": {
            "c++": "int maxProfit(vector<int>& prices) \n    // Your code here\n}\n",
            "java": "public int maxProfit(int[] prices) \n    // Your code here\n}\n",
            "python": "def maxProfit(prices):\n    # Your code here\n\n",
            "javascript": "function maxProfit(prices) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> prices = $args;\n    int result = maxProfit(prices);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    prices = $args\n    result = maxProfit(prices)\n    print(result)"
        }
    },
    "122": {
        "title": "Maximum Stock Profit",
        "description": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day. On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve.",
        "example": "Example:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Total profit is 4 + 3 = 7.",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    7,
                    1,
                    5,
                    3,
                    6,
                    4
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    7,
                    6,
                    4,
                    3,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ]
            ],
            "outputs": [
                "7",
                "4",
                "0",
                "0",
                "0",
                "9",
                "0",
                "1",
                "2",
                "3",
                "4",
                "5",
                "6",
                "7",
                "8",
                "9",
                "10",
                "11",
                "12",
                "13",
                "14",
                "15",
                "16",
                "17",
                "18",
                "19"
            ]
        },
        "sample_code": {
            "c++": "int maxProfit(vector<int>& prices) {\n    int max_profit = 0;\n    for (int i = 1; i < prices.size(); i++) {\n        if (prices[i] > prices[i - 1]) {\n            max_profit += prices[i] - prices[i - 1];\n        }\n    }\n    return max_profit;\n}\n",
            "java": "public int maxProfit(int[] prices) {\n    int max_profit = 0;\n    for (int i = 1; i < prices.length; i++) {\n        if (prices[i] > prices[i - 1]) {\n            max_profit += prices[i] - prices[i - 1];\n        }\n    }\n    return max_profit;\n}\n",
            "python": "def max_profit(prices):\n    max_profit = 0\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            max_profit += prices[i] - prices[i - 1]\n    return max_profit\n",
            "javascript": "function maxProfit(prices) {\n    let max_profit = 0;\n    for (let i = 1; i < prices.length; i++) {\n        if (prices[i] > prices[i - 1]) {\n            max_profit += prices[i] - prices[i - 1];\n        }\n    }\n    return max_profit;\n}\n",
            "explanation": "The algorithm loops through the given array of stock prices, starting from the second day. For each day, it checks if the price of the stock is higher than the previous day's price. If so, it calculates the difference between the two prices and adds this profit to the total maximum profit. By doing this, we are considering all the possible profitable transactions and accumulating the maximum profit we can achieve.\n\nThis approach has a runtime complexity of O(n), where n is the number of days in the input array."
        },
        "structure": {
            "c++": "int maxProfit(vector<int>& prices) \n    // Your code here\n}\n",
            "java": "public int maxProfit(int[] prices) \n    // Your code here\n}\n",
            "python": "def max_profit(prices):\n    # Your code here\n\n",
            "javascript": "function maxProfit(prices) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> prices = $args;\n    int result = maxProfit(prices);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int maxProfit(int[] prices) {\n    int max_profit = 0;\n    for (int i = 1; i < prices.length; i++) {\n        if (prices[i] > prices[i - 1]) {\n            max_profit += prices[i] - prices[i - 1];\n        }\n    }\n    return max_profit;\n}",
            "python": "if __name__ == \"__main__\":\n    prices = $args[0]\n    result = max_profit(prices)\n    print(result)",
            "javascript": "function main() {\n    const prices = $args;\n    const result = maxProfit(prices);\n    console.log(result);\n}"
        }
    },
    "123": {
        "title": "Maximum Profit from Stock Prices",
        "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day. Find the maximum profit you can achieve by buying and selling stocks. You may complete at most two transactions, but you cannot engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
        "example": "Example:\n\nInput: prices = [3,3,5,0,0,3,1,4]\nOutput: 6\nExplanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    3,
                    5,
                    0,
                    0,
                    3,
                    1,
                    4
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    7,
                    6,
                    4,
                    3,
                    1
                ],
                [
                    1,
                    2,
                    4,
                    2,
                    5,
                    7,
                    2,
                    4
                ],
                [
                    2,
                    4,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ]
            ],
            "outputs": [
                6,
                4,
                0,
                9,
                3,
                9,
                0,
                0,
                18,
                18
            ]
        },
        "sample_code": {
            "c++": "int maxProfit(vector<int>& prices) {\n    int buy1 = INT_MAX, buy2 = INT_MAX;\n    int profit1 = 0, profit2 = 0;\n    \n    for (int price : prices) {\n        buy1 = min(buy1, price);\n        profit1 = max(profit1, price - buy1);\n        buy2 = min(buy2, price - profit1);\n        profit2 = max(profit2, price - buy2);\n    }\n    \n    return profit2;\n}\n",
            "java": "public int maxProfit(int[] prices) {\n    int buy1 = Integer.MAX_VALUE, buy2 = Integer.MAX_VALUE;\n    int profit1 = 0, profit2 = 0;\n    \n    for (int price : prices) {\n        buy1 = Math.min(buy1, price);\n        profit1 = Math.max(profit1, price - buy1);\n        buy2 = Math.min(buy2, price - profit1);\n        profit2 = Math.max(profit2, price - buy2);\n    }\n    \n    return profit2;\n}\n",
            "python": "def maxProfit(prices):\n    buy1, buy2 = float(\"inf\"), float(\"inf\")\n    profit1, profit2 = 0, 0\n\n    for price in prices:\n        buy1 = min(buy1, price)\n        profit1 = max(profit1, price - buy1)\n        buy2 = min(buy2, price - profit1)\n        profit2 = max(profit2, price - buy2)\n\n    return profit2\n",
            "javascript": "function maxProfit(prices) {\n    let buy1 = Infinity, buy2 = Infinity;\n    let profit1 = 0, profit2 = 0;\n\n    for (let price of prices) {\n        buy1 = Math.min(buy1, price);\n        profit1 = Math.max(profit1, price - buy1);\n        buy2 = Math.min(buy2, price - profit1);\n        profit2 = Math.max(profit2, price - buy2);\n    }\n\n    return profit2;\n}\n",
            "explanation": "1. Initialize variables buy1 and buy2 to track the minimum prices, and profit1 and profit2 to track the maximum profits.\n2. Iterate through prices array.\n3. Update buy1 to the minimum of buy1 and the current price.\n4. Update profit1 to the maximum of profit1 and the current price - buy1.\n5. Update buy2 to the minimum of buy2 and the current price - profit1.\n6. Update profit2 to the maximum of profit2 and the current price - buy2.\n7. Return profit2. This is the profit from two transactions."
        },
        "structure": {
            "c++": "int maxProfit(vector<int>& prices) \n    // Your code here\n}\n",
            "java": "public int maxProfit(int[] prices) \n    // Your code here\n}\n",
            "python": "def maxProfit(prices):\n    # Your code here\n\n",
            "javascript": "function maxProfit(prices) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> prices = $args;\n    int result = maxProfit(prices);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int maxProfit(int[] prices) {\n    int buy1 = Integer.MAX_VALUE, buy2 = Integer.MAX_VALUE;\n    int profit1 = 0, profit2 = 0;\n    \n    for (int price : prices) {\n        buy1 = Math.min(buy1, price);\n        profit1 = Math.max(profit1, price - buy1);\n        buy2 = Math.min(buy2, price - profit1);\n        profit2 = Math.max(profit2, price - buy2);\n    }\n    \n    return profit2;\n}",
            "python": "if __name__ == \"__main__\":\n    prices = $args\n    result = maxProfit(prices)\n    print(result)"
        }
    },
    "125": {
        "title": "Palindrome Check",
        "description": "Given a string `s`, determine if it is a palindrome after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters. Return `true` if it is a palindrome, and `false` otherwise.",
        "example": "Example 1:\n\nInput: s = \"A man, a plan, a canal: Panama\"\nOutput: true\nExplanation: \"amanaplanacanalpanama\" is a palindrome.\n\nExample 2:\n\nInput: s = \"race a car\"\nOutput: false\nExplanation: \"raceacar\" is not a palindrome.",
        "level": "Easy",
        "tags": [
            "string",
            "palindrome"
        ],
        "test_cases": {
            "inputs": [
                "\"A man, a plan, a canal: Panama\"",
                "\"race a car\"",
                "\"\"",
                "\"No lemon, no melon\"",
                "\"Was it a car or a cat I saw?\"",
                "\"Step on no pets\"",
                "\"Eva, can I see bees in a cave?\"",
                "\"Mr. Owl ate my metal worm\"",
                "\"Madam, in Eden, I'm Adam\"",
                "\"Never odd or even\"",
                "\"Able was I ere I saw Elba\"",
                "\"A Toyota's a Toyota\"",
                "\"A nut for a jar of tuna\"",
                "\"Are we not pure? \"No sir!\" Panama's moody Noriega brags. \"It is garbage!\" Irony dooms a man; a prisoner up to new era.\"\"",
                "\"Go hang a salami I'm a lasagna hog\"",
                "\"Red roses run no risk, sir, on Nurse's order\"",
                "\"Ma is a nun, as I am\"",
                "\"Evil is a name of a foeman, as I live\"",
                "\"A man, a plan, a cat, a ham, a yak, a yam, a hat, a canal-Panama!\"",
                "\"Able, was I saw Elba\"",
                "\"A man, a plan, a canal, Panama\"",
                "\"A man, a plan, a canal, Panama!\"",
                "\"A man, a plan, a canal, Panama.\""
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "#include <cctype>\n#include <algorithm>\n\nbool isPalindrome(std::string s) {\n    s.erase(std::remove_if(s.begin(), s.end(), [](char c) { return !std::isalnum(c); }), s.end());\n    std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n    int left = 0, right = s.size() - 1;\n    while (left < right) {\n        if (s[left++] != s[right--]) return false;\n    }\n    return true;\n}\n",
            "java": "public boolean isPalindrome(String s) {\n    StringBuilder cleaned = new StringBuilder();\n    for (char c : s.toCharArray()) {\n        if (Character.isLetterOrDigit(c)) {\n            cleaned.append(Character.toLowerCase(c));\n        }\n    }\n    int left = 0, right = cleaned.length() - 1;\n    while (left < right) {\n        if (cleaned.charAt(left++) != cleaned.charAt(right--)) return false;\n    }\n    return true;\n}\n",
            "python": "def isPalindrome(s: str) -> bool:\n    cleaned = \"\".join(c.lower() for c in s if c.isalnum())\n    left, right = 0, len(cleaned) - 1\n    while left < right:\n        if cleaned[left] != cleaned[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n",
            "javascript": "function isPalindrome(s) {\n    const cleaned = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n    let left = 0, right = cleaned.length - 1;\n    while (left < right) {\n        if (cleaned[left++] !== cleaned[right--]) return false;\n    }\n    return true;\n}\n",
            "explanation": "1. Clean the given string by removing non-alphanumeric characters and converting uppercase letters to lowercase.\n2. Initialize two pointers: `left` pointing to the beginning of the cleaned string and `right` pointing to the end.\n3. Iterate through the cleaning string, comparing the characters at the `left` and `right` pointers. If they are not equal, return `false` as it's not a palindrome.\n4. If the loop completes, it means the input string is a palindrome, so return `true`."
        },
        "structure": {
            "c++": "#include <cctype>\n#include <algorithm>\n\nbool isPalindrome(std::string s) \n    // Your code here\n}\n",
            "java": "public boolean isPalindrome(String s) \n    // Your code here\n}\n",
            "python": "def isPalindrome(s: str) -> bool:\n    # Your code here\n\n",
            "javascript": "function isPalindrome(s) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <cctype>\n#include <algorithm>\n#include <iostream>\n\nint main() {\n    std::string s = $args;\n    bool result = isPalindrome(s);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "java": "public boolean isPalindrome(String s) {\n    StringBuilder cleaned = new StringBuilder();\n    for (char c : s.toCharArray()) {\n        if (Character.isLetterOrDigit(c)) {\n            cleaned.append(Character.toLowerCase(c));\n        }\n    }\n    int left = 0, right = cleaned.length() - 1;\n    while (left < right) {\n        if (cleaned.charAt(left++) != cleaned.charAt(right--)) return false;\n    }\n    return true;\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = isPalindrome(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = isPalindrome(s);\n    console.log(result);\n}"
        }
    },
    "126": {
        "title": "Shortest Transformation Sequences",
        "description": "Given a transformation sequence from a start word to an end word using a dictionary of words, find all the shortest transformation sequences. A transformation sequence is a sequence of words where each adjacent pair of words differs by a single letter, and each word is in the given dictionary. Return the sequences as a list of words.",
        "example": "Example:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nOutput: [[\"hit\", \"hot\", \"dot\", \"dog\", \"cog\"], [\"hit\", \"hot\", \"lot\", \"log\", \"cog\"]]\nExplanation: There are 2 shortest transformation sequences: \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\" and \"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\".",
        "level": "Medium",
        "tags": [
            "graph",
            "breadth-first search",
            "backtracking"
        ],
        "test_cases": {
            "inputs": [
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log"
                    ]
                ],
                [
                    "a",
                    "c",
                    [
                        "a",
                        "b",
                        "c"
                    ]
                ],
                [
                    "red",
                    "tax",
                    [
                        "ted",
                        "tex",
                        "red",
                        "tax",
                        "tad",
                        "den",
                        "rex",
                        "pee"
                    ]
                ],
                [
                    "hot",
                    "dog",
                    [
                        "hot",
                        "dog"
                    ]
                ]
            ],
            "outputs": [
                [
                    [
                        "hit",
                        "hot",
                        "dot",
                        "dog",
                        "cog"
                    ],
                    [
                        "hit",
                        "hot",
                        "lot",
                        "log",
                        "cog"
                    ]
                ],
                [],
                [
                    [
                        "a",
                        "c"
                    ]
                ],
                [
                    [
                        "red",
                        "ted",
                        "tad",
                        "tax"
                    ],
                    [
                        "red",
                        "rex",
                        "tex",
                        "tax"
                    ]
                ],
                []
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n\nstd::vector<std::vector<std::string>> findLadders(std::string beginWord, std::string endWord, std::vector<std::string>& wordList) {\n    std::unordered_set<std::string> dict(wordList.begin(), wordList.end());\n    if (dict.find(endWord) == dict.end()) {\n        return {};\n    }\n    std::unordered_map<std::string, std::vector<std::string>> adjacent;\n    std::unordered_map<std::string, int> distance;\n    \n    auto neighbors = [&](const std::string& word) {\n        std::vector<std::string> result;\n        std::string temp = word;\n        for (char& ch : temp) {\n            char original = ch;\n            for (int i = 'a'; i <= 'z'; ++i) {\n                ch = i;\n                if (dict.count(temp) && temp != word) {\n                    result.push_back(temp);\n                }\n            }\n            ch = original;\n        }\n        return result;\n    };\n    \n    std::queue<std::string> q;\n    q.push(beginWord);\n    distance[beginWord] = 0;\n    \n    while (!q.empty()) {\n        std::string current = q.front();\n        q.pop();\n        if (current == endWord) {\n            break;\n        }\n        for (const std::string& neighbor : neighbors(current)) {\n            if (!distance.count(neighbor)) {\n                distance[neighbor] = distance[current] + 1;\n                q.push(neighbor);\n            }\n            if (distance[neighbor] == distance[current] + 1) {\n                adjacent[current].push_back(neighbor);\n            }\n        }\n    }\n    \n    std::vector<std::vector<std::string>> result;\n    std::vector<std::string> path = {beginWord};\n    std::function<void(const std::string&)> backtrack = [&](const std::string& word) {\n        if (word == endWord) {\n            result.push_back(path);\n            return;\n        }\n        for (const std::string& next : adjacent[word]) {\n            path.push_back(next);\n            backtrack(next);\n            path.pop_back();\n        }\n    };\n    \n    backtrack(beginWord);\n    return result;\n}\n\n",
            "java": "import java.util.*;\n\npublic List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n    Set<String> dict = new HashSet<>(wordList);\n    if (!dict.contains(endWord)) {\n        return Collections.emptyList();\n    }\n\n    Map<String, List<String>> adjacent = new HashMap<>();\n    Map<String, Integer> distance = new HashMap<>();\n    Queue<String> queue = new LinkedList<>();\n    queue.offer(beginWord);\n    distance.put(beginWord, 0);\n\n    while (!queue.isEmpty()) {\n        String current = queue.poll();\n        if (current.equals(endWord)) {\n            break;\n        }\n        for (String neighbor : neighbors(current)) {\n            if (!dict.contains(neighbor)) {\n                continue;\n            }\n            if (!distance.containsKey(neighbor)) {\n                distance.put(neighbor, distance.get(current) + 1);\n                queue.offer(neighbor);\n            }\n            if (distance.get(neighbor).equals(distance.get(current) + 1)) {\n                adjacent.computeIfAbsent(current, k -> new ArrayList<>()).add(neighbor);\n            }\n        }\n    }\n\n    List<List<String>> result = new ArrayList<>();\n    List<String> path = new ArrayList<>();\n    path.add(beginWord);\n    backtrack(beginWord, endWord, path, adjacent, result);\n    return result;\n}\n\nprivate void backtrack(String current, String endWord, List<String> path, Map<String, List<String>> adjacent, List<List<String>> result) {\n    if (current.equals(endWord)) {\n        result.add(new ArrayList<>(path));\n        return;\n    }\n    for (String next : adjacent.getOrDefault(current, Collections.emptyList())) {\n        path.add(next);\n        backtrack(next, endWord, path, adjacent, result);\n        path.remove(path.size() - 1);\n    }\n}\n\nprivate List<String> neighbors(String word) {\n    List<String> result = new ArrayList<>();\n    char[] chars = word.toCharArray();\n    for (int i = 0; i < chars.length; i++) {\n        char original = chars[i];\n        for (char j = 'a'; j <= 'z'; j++) {\n            if (j == original) {\n                continue;\n            }\n            chars[i] = j;\n            result.add(new String(chars));\n        }\n        chars[i] = original;\n    }\n    return result;\n}\n\n",
            "python": "from collections import defaultdict, deque\n\ndef findLadders(beginWord, endWord, wordList):\n    wordList = set(wordList)\n    if endWord not in wordList:\n        return []\n\n    adjacent = defaultdict(list)\n    distance = defaultdict(int)\n    queue = deque([beginWord])\n    distance[beginWord] = 0\n    \n    def neighbors(word):\n        for i in range(len(word)):\n            for j in range(ord('a'), ord('z') + 1):\n                yield word[:i] + chr(j) + word[i + 1:]\n                \n    while queue:\n        current = queue.popleft()\n        if current == endWord:\n            break\n        for neighbor in neighbors(current):\n            if neighbor not in wordList:\n                continue\n            if neighbor not in distance:\n                distance[neighbor] = distance[current] + 1\n                queue.append(neighbor)\n            if distance[neighbor] == distance[current] + 1:\n                adjacent[current].append(neighbor)\n\n    result = []\n    path = [beginWord]\n\n    def backtrack(word):\n        if word == endWord:\n            result.append(path[:])\n        else:\n            for next_word in adjacent[word]:\n                path.append(next_word)\n                backtrack(next_word)\n                path.pop()\n                \n    backtrack(beginWord)\n    return result\n\n",
            "javascript": "function findLadders(beginWord, endWord, wordList) {\n    const dict = new Set(wordList);\n    if (!dict.has(endWord)) {\n        return [];\n    }\n\n    const adjacent = new Map();\n    const distance = new Map();\n    const queue = [beginWord];\n    distance.set(beginWord, 0);\n    \n    function neighbors(word) {\n        const result = [];\n        for (let i = 0; i < word.length; i++) {\n            for (let j = 'a'.charCodeAt(0); j <= 'z'.charCodeAt(0); j++) {\n                const next = word.slice(0, i) + String.fromCharCode(j) + word.slice(i + 1);\n                if (next !== word) {\n                    result.push(next);\n                }\n            }\n        }\n        return result;\n    }\n    \n    while (queue.length > 0) {\n        const current = queue.shift();\n        if (current === endWord) {\n            break;\n        }\n        for (const neighbor of neighbors(current)) {\n            if (!dict.has(neighbor)) {\n                continue;\n            }\n            if (!distance.has(neighbor)) {\n                distance.set(neighbor, distance.get(current) + 1);\n                queue.push(neighbor);\n            }\n            if (distance.get(neighbor) === distance.get(current) + 1) {\n                if (!adjacent.has(current)) {\n                    adjacent.set(current, []);\n                }\n                adjacent.get(current).push(neighbor);\n            }\n        }\n    }\n\n    const result = [];\n    const path = [beginWord];\n\n    function backtrack(word) {\n        if (word === endWord) {\n            result.push([...path]);\n            return;\n        }\n        for (const next of (adjacent.get(word) || [])) {\n            path.push(next);\n            backtrack(next);\n            path.pop();\n        }\n    }\n    \n    backtrack(beginWord);\n    return result;\n}\n\n",
            "explanation": "1. Create a dictionary set, adjacent map, distance map, and a queue to store words.\n2. Initialize the queue with the beginWord and set its distance to 0.\n3. Define a neighbors function that returns all possible words by changing one character of the given word.\n4. Run a BFS from the beginWord, updating the distances and adjacent maps.\n5. The BFS stops when it reaches the endWord or finishes visiting all reachable words.\n6. Define a backtrack function to search through the explored adjacent map to construct the transformation paths.\n7. Call the backtrack function with the beginWord, and return the result list, which contains the shortest transformations."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n\nstd::vector<std::vector<std::string>> findLadders(std::string beginWord, std::string endWord, std::vector<std::string>& wordList) \n    // Your code here\n}\n\n",
            "java": "import java.util.*;\n\npublic List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) \n    // Your code here\n}\n\n",
            "python": "from collections import defaultdict, deque\n    # Your code here\n\n",
            "javascript": "function findLadders(beginWord, endWord, wordList) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "std::vector<std::vector<std::string>> findLadders(std::string beginWord, std::string endWord, std::vector<std::string>& wordList) {\n    std::unordered_set<std::string> dict(wordList.begin(), wordList.end());\n    if (dict.find(endWord) == dict.end()) {\n        return {};\n    }\n    std::unordered_map<std::string, std::vector<std::string>> adjacent;\n    std::unordered_map<std::string, int> distance;\n    \n    auto neighbors = [&](const std::string& word) {\n        std::vector<std::string> result;\n        std::string temp = word;\n        for (char& ch : temp) {\n            char original = ch;\n            for (int i = 'a'; i <= 'z'; ++i) {\n                ch = i;\n                if (dict.count(temp) && temp != word) {\n                    result.push_back(temp);\n                }\n            }\n            ch = original;\n        }\n        return result;\n    };\n    \n    std::queue<std::string> q;\n    q.push(beginWord);\n    distance[beginWord] = 0;\n    \n    while (!q.empty()) {\n        std::string current = q.front();\n        q.pop();\n        if (current == endWord) {\n            break;\n        }\n        for (const std::string& neighbor : neighbors(current)) {\n            if (!distance.count(neighbor)) {\n                distance[neighbor] = distance[current] + 1;\n                q.push(neighbor);\n            }\n            if (distance[neighbor] == distance[current] + 1) {\n                adjacent[current].push_back(neighbor);\n            }\n        }\n    }\n    \n    std::vector<std::vector<std::string>> result;\n    std::vector<std::string> path = {beginWord};\n    std::function<void(const std::string&)> backtrack = [&](const std::string& word) {\n        if (word == endWord) {\n            result.push_back(path);\n            return;\n        }\n        for (const std::string& next : adjacent[word]) {\n            path.push_back(next);\n            backtrack(next);\n            path.pop_back();\n        }\n    };\n    \n    backtrack(beginWord);\n    return result;\n}",
            "java": "public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n    Set<String> dict = new HashSet<>(wordList);\n    if (!dict.contains(endWord)) {\n        return Collections.emptyList();\n    }\n\n    Map<String, List<String>> adjacent = new HashMap<>();\n    Map<String, Integer> distance = new HashMap<>();\n    Queue<String> queue = new LinkedList<>();\n    queue.offer(beginWord);\n    distance.put(beginWord, 0);\n\n    while (!queue.isEmpty()) {\n        String current = queue.poll();\n        if (current.equals(endWord)) {\n            break;\n        }\n        for (String neighbor : neighbors(current)) {\n            if (!dict.contains(neighbor)) {\n                continue;\n            }\n            if (!distance.containsKey(neighbor)) {\n                distance.put(neighbor, distance.get(current) + 1);\n                queue.offer(neighbor);\n            }\n            if (distance.get(neighbor).equals(distance.get(current) + 1)) {\n                adjacent.computeIfAbsent(current, k -> new ArrayList<>()).add(neighbor);\n            }\n        }\n    }\n\n    List<List<String>> result = new ArrayList<>();\n    List<String> path = new ArrayList<>();\n    path.add(beginWord);\n    backtrack(beginWord, endWord, path, adjacent, result);\n    return result;\n}\n\nprivate void backtrack(String current, String endWord, List<String> path, Map<String, List<String>> adjacent, List<List<String>> result) {\n    if (current.equals(endWord)) {\n        result.add(new ArrayList<>(path));\n        return;\n    }\n    for (String next : adjacent.getOrDefault(current, Collections.emptyList())) {\n        path.add(next);\n        backtrack(next, endWord, path, adjacent, result);\n        path.remove(path.size() - 1);\n    }\n}\n\nprivate List<String> neighbors(String word) {\n    List<String> result = new ArrayList<>();\n    char[] chars = word.toCharArray();\n    for (int i = 0; i < chars.length; i++) {\n        char original = chars[i];\n        for (char j = 'a'; j <= 'z'; j++) {\n            if (j == original) {\n                continue;\n            }\n            chars[i] = j;\n            result.add(new String(chars));\n        }\n        chars[i] = original;\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    beginWord = inputs[0]\n    endWord = inputs[1]\n    wordList = inputs[2]\n    result = findLadders(beginWord, endWord, wordList)\n    print(result)",
            "javascript": "function findLadders(beginWord, endWord, wordList) {\n    const dict = new Set(wordList);\n    if (!dict.has(endWord)) {\n        return [];\n    }\n\n    const adjacent = new Map();\n    const distance = new Map();\n    const queue = [beginWord];\n    distance.set(beginWord, 0);\n    \n    function neighbors(word) {\n        const result = [];\n        for (let i = 0; i < word.length; i++) {\n            for (let j = 'a'.charCodeAt(0); j <= 'z'.charCodeAt(0); j++) {\n                const next = word.slice(0, i) + String.fromCharCode(j) + word.slice(i + 1);\n                if (next !== word) {\n                    result.push(next);\n                }\n            }\n        }\n        return result;\n    }\n    \n    while (queue.length > 0) {\n        const current = queue.shift();\n        if (current === endWord) {\n            break;\n        }\n        for (const neighbor of neighbors(current)) {\n            if (!dict.has(neighbor)) {\n                continue;\n            }\n            if (!distance.has(neighbor)) {\n                distance.set(neighbor, distance.get(current) + 1);\n                queue.push(neighbor);\n            }\n            if (distance.get(neighbor) === distance.get(current) + 1) {\n                if (!adjacent.has(current)) {\n                    adjacent.set(current, []);\n                }\n                adjacent.get(current).push(neighbor);\n            }\n        }\n    }\n\n    const result = [];\n    const path = [beginWord];\n\n    function backtrack(word) {\n        if (word === endWord) {\n            result.push([...path]);\n            return;\n        }\n        for (const next of (adjacent.get(word) || [])) {\n            path.push(next);\n            backtrack(next);\n            path.pop();\n        }\n    }\n    \n    backtrack(beginWord);\n    return result;\n}"
        }
    },
    "127": {
        "title": "Shortest Transformation Sequence",
        "description": "Given a transformation sequence from a start word to an end word using a dictionary of words, find the shortest transformation sequence. A transformation sequence is a sequence of words where each adjacent pair of words differs by a single letter. The start word does not need to be in the dictionary, but all other words in the sequence must be in the dictionary. Return the number of words in the shortest transformation sequence, or 0 if no such sequence exists.",
        "example": "Example:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nOutput: 5\nExplanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", which is 5 words long.",
        "level": "Medium",
        "tags": [
            "graph",
            "breadth-first search",
            "word ladder"
        ],
        "test_cases": {
            "inputs": [
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log"
                    ]
                ],
                [
                    "a",
                    "c",
                    [
                        "a",
                        "b",
                        "c"
                    ]
                ],
                [
                    "red",
                    "tax",
                    [
                        "ted",
                        "tex",
                        "red",
                        "tax",
                        "tad",
                        "den",
                        "rex",
                        "pee"
                    ]
                ],
                [
                    "hot",
                    "dog",
                    [
                        "hot",
                        "dog"
                    ]
                ],
                [
                    "a",
                    "z",
                    [
                        "a",
                        "b",
                        "c",
                        "d",
                        "e",
                        "f",
                        "g",
                        "h",
                        "i",
                        "j",
                        "k",
                        "l",
                        "m",
                        "n",
                        "o",
                        "p",
                        "q",
                        "r",
                        "s",
                        "t",
                        "u",
                        "v",
                        "w",
                        "x",
                        "y",
                        "z"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog",
                        "hag"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog",
                        "hag",
                        "hug"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog",
                        "hag",
                        "hug",
                        "hut"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog",
                        "hag",
                        "hug",
                        "hut",
                        "cut"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog",
                        "hag",
                        "hug",
                        "hut",
                        "cut",
                        "cup"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog",
                        "hag",
                        "hug",
                        "hut",
                        "cut",
                        "cup",
                        "cop"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog",
                        "hag",
                        "hug",
                        "hut",
                        "cut",
                        "cup",
                        "cop",
                        "cap"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog",
                        "hag",
                        "hug",
                        "hut",
                        "cut",
                        "cup",
                        "cop",
                        "cap",
                        "cab"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog",
                        "hag",
                        "hug",
                        "hut",
                        "cut",
                        "cup",
                        "cop",
                        "cap",
                        "cab",
                        "cab"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog",
                        "hag",
                        "hug",
                        "hut",
                        "cut",
                        "cup",
                        "cop",
                        "cap",
                        "cab",
                        "cab",
                        "cog"
                    ]
                ]
            ],
            "outputs": [
                5,
                0,
                2,
                3,
                0,
                26,
                5,
                4,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n\nint ladderLength(std::string beginWord, std::string endWord, std::vector<std::string>& wordList) {\n    std::unordered_set<std::string> dict(wordList.begin(), wordList.end());\n    if (!dict.count(endWord)) return 0;\n\n    std::queue<std::string> q;\n    q.push(beginWord);\n    int steps = 1;\n\n    while (!q.empty()) {\n        int size = q.size();\n        for (int i = 0; i < size; ++i) {\n            std::string currentWord = q.front();\n            q.pop();\n            if (currentWord == endWord) return steps;\n\n            for (char& c : currentWord) {\n                char originalChar = c;\n                for (int j = 0; j < 26; ++j) {\n                    c = 'a' + j;\n                    if (dict.count(currentWord)) {\n                        q.push(currentWord);\n                        dict.erase(currentWord);\n                    }\n                }\n                c = originalChar;\n            }\n        }\n        ++steps;\n    }\n    return 0;\n}\n",
            "java": "import java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Set;\n\npublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\n    Set<String> dict = new HashSet<>(wordList);\n    if (!dict.contains(endWord)) return 0;\n\n    Queue<String> q = new LinkedList<>();\n    q.offer(beginWord);\n    int steps = 1;\n\n    while (!q.isEmpty()) {\n        int size = q.size();\n        for (int i = 0; i < size; ++i) {\n            String currentWord = q.poll();\n            if (currentWord.equals(endWord)) return steps;\n\n            char[] charArray = currentWord.toCharArray();\n            for (int j = 0; j < charArray.length; ++j) {\n                char originalChar = charArray[j];\n                for (int k = 0; k < 26; ++k) {\n                    charArray[j] = (char) ('a' + k);\n                    String newWord = new String(charArray);\n                    if (dict.remove(newWord)) {\n                        q.offer(newWord);\n                    }\n                }\n                charArray[j] = originalChar;\n            }\n        }\n        ++steps;\n    }\n    return 0;\n}\n",
            "python": "from collections import deque\n\ndef ladderLength(beginWord, endWord, wordList):\n    word_set = set(wordList)\n    if endWord not in word_set:\n        return 0\n\n    q = deque([beginWord])\n    steps = 1\n\n    while q:\n        size = len(q)\n        current_level = set()\n        \n        for _ in range(size):\n            current_word = q.popleft()\n            if current_word == endWord:\n                return steps\n\n            word_chars = list(current_word)\n            for i in range(len(word_chars)):\n                original_char = word_chars[i]\n                for j in range(26):\n                    word_chars[i] = chr(ord('a') + j)\n                    new_word = ''.join(word_chars)\n                    if new_word in word_set:\n                        q.append(new_word)\n                        current_level.add(new_word)\n                        \n                word_chars[i] = original_char\n        \n        word_set -= current_level\n        steps += 1\n        \n    return 0\n",
            "javascript": "function ladderLength(beginWord, endWord, wordList) {\n    const wordSet = new Set(wordList);\n    if (!wordSet.has(endWord)) return 0;\n\n    const q = [beginWord];\n    let steps = 1;\n\n    while (q.length > 0) {\n        const size = q.length;\n        const currentLevel = new Set();\n\n        for (let i = 0; i < size; ++i) {\n            const currentWord = q.shift();\n            if (currentWord === endWord) return steps;\n\n            const wordChars = currentWord.split('');\n            for (let j = 0; j < wordChars.length; ++j) {\n                const originalChar = wordChars[j];\n                for (let k = 0; k < 26; ++k) {\n                    wordChars[j] = String.fromCharCode('a'.charCodeAt(0) + k);\n                    const newWord = wordChars.join('');\n                    if (wordSet.has(newWord)) {\n                        q.push(newWord);\n                        currentLevel.add(newWord);\n                    }\n                }\n                wordChars[j] = originalChar;\n            }\n        }\n        steps++;\n        for (const word of currentLevel) {\n            wordSet.delete(word);\n        }\n    }\n    return 0;\n}\n",
            "explanation": "In this problem, we use a breadth-first search (BFS) algorithm to find the shortest transformation sequence from `beginWord` to `endWord`:\n\n1. Create an unordered set `dict` or `word_set` with all the words from `wordList` for fast look-up, and check if it contains the `endWord`.\n2. Create a queue for BFS, initialize it with `beginWord`, and initialize `steps` variable to 1.\n3. Repeat the following steps while the queue is not empty:\n   a) For each level of BFS, store the current level size, and create an empty set for `current_level` (only in Python & JavaScript).\n   b) Iterate for each word in the current BFS level:\n      - Dequeue the next `currentWord`, and check for `endWord`; if found return the current `steps` value.\n      - Iterate through each character of the `currentWord`; for every character, replace it with 26 possible lowercase alphabets.\n        - If the new word is in the `dict` or `word_set`, enqueue it in the queue, and remove it. In Python and JavaScript, also add it to the `current_level` set.\n      - Revert the character back to the original character.\n   c) Increment the `steps` value by 1, and in Python/javascript, update the `word_set` by removing words present in `current_level`.\n4. If the queue is empty and no sequence is found, return 0."
        },
        "structure": {
            "c++": "#include <string>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n\nint ladderLength(std::string beginWord, std::string endWord, std::vector<std::string>& wordList) \n    // Your code here\n}\n",
            "java": "import java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Set;\n\npublic int ladderLength(String beginWord, String endWord, List<String> wordList) \n    // Your code here\n}\n",
            "python": "from collections import deque\n    # Your code here\n\n",
            "javascript": "function ladderLength(beginWord, endWord, wordList) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n\nint main() {\n    std::string beginWord = $args;\n    std::string endWord = $args;\n    std::vector<std::string> wordList = $args;\n    int result = ladderLength(beginWord, endWord, wordList);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n    Set<String> dict = new HashSet<>(wordList);\n    if (!dict.contains(endWord)) return 0;\n\n    Queue<String> q = new LinkedList<>();\n    q.offer(beginWord);\n    int steps = 1;\n\n    while (!q.isEmpty()) {\n        int size = q.size();\n        for (int i = 0; i < size; ++i) {\n            String currentWord = q.poll();\n            if (currentWord.equals(endWord)) return steps;\n\n            char[] charArray = currentWord.toCharArray();\n            for (int j = 0; j < charArray.length; ++j) {\n                char originalChar = charArray[j];\n                for (int k = 0; k < 26; ++k) {\n                    charArray[j] = (char) ('a' + k);\n                    String newWord = new String(charArray);\n                    if (dict.remove(newWord)) {\n                        q.offer(newWord);\n                    }\n                }\n                charArray[j] = originalChar;\n            }\n        }\n        ++steps;\n    }\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    beginWord = inputs[0]\n    endWord = inputs[1]\n    wordList = inputs[2]\n    result = ladderLength(beginWord, endWord, wordList)\n    print(result)",
            "javascript": "function ladderLength(beginWord, endWord, wordList) {\n    const wordSet = new Set(wordList);\n    if (!wordSet.has(endWord)) return 0;\n\n    const q = [beginWord];\n    let steps = 1;\n\n    while (q.length > 0) {\n        const size = q.length;\n        const currentLevel = new Set();\n\n        for (let i = 0; i < size; ++i) {\n            const currentWord = q.shift();\n            if (currentWord === endWord) return steps;\n\n            const wordChars = currentWord.split('');\n            for (let j = 0; j < wordChars.length; ++j) {\n                const originalChar = wordChars[j];\n                for (let k = 0; k < 26; ++k) {\n                    wordChars[j] = String.fromCharCode('a'.charCodeAt(0) + k);\n                    const newWord = wordChars.join('');\n                    if (wordSet.has(newWord)) {\n                        q.push(newWord);\n                        currentLevel.add(newWord);\n                    }\n                }\n                wordChars[j] = originalChar;\n            }\n        }\n        steps++;\n        for (const word of currentLevel) {\n            wordSet.delete(word);\n        }\n    }\n    return 0;\n}"
        }
    },
    "128": {
        "title": "Longest Consecutive Sequence",
        "description": "Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in `O(n)` time.",
        "example": "Example:\n\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore, its length is 4.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    100,
                    4,
                    200,
                    1,
                    3,
                    2
                ],
                [
                    0,
                    3,
                    7,
                    2,
                    5,
                    8,
                    4,
                    6,
                    0,
                    1
                ],
                [],
                [
                    1
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9,
                    2,
                    4,
                    6,
                    8,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15
                ],
                [
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90
                ],
                [
                    90,
                    80,
                    70,
                    60,
                    50,
                    40,
                    30,
                    20,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    100,
                    200,
                    300,
                    400,
                    500,
                    600,
                    700,
                    800,
                    900
                ],
                [
                    900,
                    800,
                    700,
                    600,
                    500,
                    400,
                    300,
                    200,
                    100,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    100,
                    200,
                    300,
                    400,
                    500,
                    600,
                    700,
                    800,
                    900,
                    1000
                ],
                [
                    1000,
                    900,
                    800,
                    700,
                    600,
                    500,
                    400,
                    300,
                    200,
                    100,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    100,
                    200,
                    300,
                    400,
                    500,
                    600,
                    700,
                    800,
                    900,
                    1000,
                    10000
                ],
                [
                    10000,
                    1000,
                    900,
                    800,
                    700,
                    600,
                    500,
                    400,
                    300,
                    200,
                    100,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ]
            ],
            "outputs": [
                4,
                9,
                0,
                1,
                1,
                1,
                9,
                1,
                10,
                10,
                15,
                10,
                6,
                10,
                19,
                19,
                20,
                20,
                21,
                21
            ]
        },
        "sample_code": {
            "c++": "int longestConsecutive(vector<int>& nums) {\n    unordered_set<int> elements(nums.begin(), nums.end());\n    int longestSeq = 0;\n    \n    for (int num : nums) {\n        if (elements.find(num - 1) == elements.end()) {\n            int currentNum = num;\n            int currentSeq = 1;\n            \n            while (elements.find(currentNum + 1) != elements.end()) {\n                currentNum += 1;\n                currentSeq += 1;\n            }\n            \n            longestSeq = max(longestSeq, currentSeq);\n        }\n    }\n    return longestSeq;\n}\n",
            "java": "public int longestConsecutive(int[] nums) {\n    Set<Integer> elements = new HashSet<>();\n    for (int num : nums) {\n        elements.add(num);\n    }\n    \n    int longestSeq = 0;\n    \n    for (int num : nums) {\n        if (!elements.contains(num - 1)) {\n            int currentNum = num;\n            int currentSeq = 1;\n            \n            while (elements.contains(currentNum + 1)) {\n                currentNum++;\n                currentSeq++;\n            }\n            \n            longestSeq = Math.max(longestSeq, currentSeq);\n        }\n    }\n    return longestSeq;\n}\n",
            "python": "def longest_consecutive(nums):\n    elements = set(nums)\n    longest_seq = 0\n\n    for num in nums:\n        if num - 1 not in elements:\n            current_num = num\n            current_seq = 1\n            \n            while current_num + 1 in elements:\n                current_num += 1\n                current_seq += 1\n\n            longest_seq = max(longest_seq, current_seq)\n    \n    return longest_seq\n",
            "javascript": "function longestConsecutive(nums) {\n    const elements = new Set(nums);\n    let longestSeq = 0;\n\n    for (const num of nums) {\n        if (!elements.has(num - 1)) {\n            let currentNum = num;\n            let currentSeq = 1;\n\n            while (elements.has(currentNum + 1)) {\n                currentNum++;\n                currentSeq++;\n            }\n\n            longestSeq = Math.max(longestSeq, currentSeq);\n        }\n    }\n\n    return longestSeq;\n}\n\n",
            "explanation": "The algorithm first creates a set (or hash set) with the given array of integers called `elements`. The set will allow us to have a fast O(1) lookup on our next step.\nNow we iterate through the original array of numbers, and for each number, we check if `(number - 1)` is not in the `elements` set. If it's not in the set, it means we can start counting a new consecutive sequence.\nNext, we create two variables, `currentNum` and `currentSeq`, and initialize them with the current number and 1, respectively.\nWe then use a while loop to check if the next number (`currentNum + 1`) is in the `elements` set. If it is, we increment both `currentNum` and `currentSeq`. This process will continue, finding consecutive elements in the set, until no more consecutive elements are found.\nFinally, to get the length of the longest consecutive sequence, we update the `longestSeq` variable by choosing the maximum value between itself and `currentSeq`. This will keep track of the longest consecutive sequence found so far.\nThe process continues until all numbers in the original array have been checked, and at the end, `longestSeq` will store the answer - the length of the longest consecutive elements sequence."
        },
        "structure": {
            "c++": "int longestConsecutive(vector<int>& nums) \n    // Your code here\n}\n",
            "java": "public int longestConsecutive(int[] nums) \n    // Your code here\n}\n",
            "python": "def longest_consecutive(nums):\n    # Your code here\n\n",
            "javascript": "function longestConsecutive(nums) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int longestConsecutive(vector<int>& nums) {\n    unordered_set<int> elements(nums.begin(), nums.end());\n    int longestSeq = 0;\n    \n    for (int num : nums) {\n        if (elements.find(num - 1) == elements.end()) {\n            int currentNum = num;\n            int currentSeq = 1;\n            \n            while (elements.find(currentNum + 1) != elements.end()) {\n                currentNum += 1;\n                currentSeq += 1;\n            }\n            \n            longestSeq = max(longestSeq, currentSeq);\n        }\n    }\n    return longestSeq;\n}",
            "java": "public int longestConsecutive(int[] nums) {\n    Set<Integer> elements = new HashSet<>();\n    for (int num : nums) {\n        elements.add(num);\n    }\n    \n    int longestSeq = 0;\n    \n    for (int num : nums) {\n        if (!elements.contains(num - 1)) {\n            int currentNum = num;\n            int currentSeq = 1;\n            \n            while (elements.contains(currentNum + 1)) {\n                currentNum++;\n                currentSeq++;\n            }\n            \n            longestSeq = Math.max(longestSeq, currentSeq);\n        }\n    }\n    return longestSeq;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = longest_consecutive(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = longestConsecutive(nums);\n    console.log(result);\n}"
        }
    },
    "131": {
        "title": "Palindrome Partitioning",
        "description": "Given a string `s`, partition `s` such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of `s`.",
        "example": "Example 1:\n\nInput: s = \"aab\"\nOutput: [['a','a','b'],['aa','b']]\n\nExample 2:\n\nInput: s = \"a\"\nOutput: [['a']]\n",
        "level": "Medium",
        "tags": [
            "string",
            "backtracking"
        ],
        "test_cases": {
            "inputs": [
                "\"aab\"",
                "\"a\"",
                "\"racecar\"",
                "\"level\"",
                "\"madam\"",
                "\"abcba\"",
                "\"abba\"",
                "\"aabbaa\"",
                "\"aaaaa\"",
                "\"ababab\"",
                "\"abcd\"",
                "\"aaaaaabaaaaa\"",
                "\"aabbaabb\"",
                "\"aabb\"",
                "\"aabbaa\"",
                "\"aabbcc\"",
                "\"abcde\"",
                "\"aaaaaaa\"",
                "\"aabbaabbcc\"",
                "\"aabbccddeeffgg\""
            ],
            "outputs": [
                [
                    [
                        "a",
                        "a",
                        "b"
                    ],
                    [
                        "aa",
                        "b"
                    ]
                ],
                [
                    [
                        "a"
                    ]
                ],
                [
                    [
                        "r",
                        "a",
                        "c",
                        "e",
                        "c",
                        "a",
                        "r"
                    ]
                ],
                [
                    [
                        "l",
                        "e",
                        "v",
                        "e",
                        "l"
                    ]
                ],
                [
                    [
                        "m",
                        "a",
                        "d",
                        "a",
                        "m"
                    ]
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "b",
                        "a"
                    ]
                ],
                [
                    [
                        "a",
                        "b",
                        "b",
                        "a"
                    ]
                ],
                [
                    [
                        "a",
                        "a",
                        "b",
                        "b",
                        "a",
                        "a"
                    ]
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ]
                ],
                [
                    [
                        "a",
                        "b",
                        "a",
                        "b",
                        "a",
                        "b"
                    ]
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d"
                    ]
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a",
                        "b",
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ]
                ],
                [
                    [
                        "a",
                        "a",
                        "b",
                        "b",
                        "a",
                        "a",
                        "b",
                        "b"
                    ]
                ],
                [
                    [
                        "a",
                        "a",
                        "b",
                        "b",
                        "a",
                        "a"
                    ]
                ],
                [
                    [
                        "a",
                        "a",
                        "b",
                        "b",
                        "a",
                        "a"
                    ]
                ],
                [
                    [
                        "a",
                        "a",
                        "b",
                        "b",
                        "c",
                        "c"
                    ]
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d",
                        "e"
                    ]
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ]
                ],
                [
                    [
                        "a",
                        "a",
                        "b",
                        "b",
                        "a",
                        "a",
                        "b",
                        "b",
                        "c",
                        "c"
                    ]
                ],
                [
                    [
                        "a",
                        "a",
                        "b",
                        "b",
                        "c",
                        "c",
                        "d",
                        "d",
                        "e",
                        "e",
                        "f",
                        "f",
                        "g",
                        "g"
                    ]
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n\nbool isPalindrome(const std::string& s, int start, int end) {\n    while (start < end) {\n        if (s[start++] != s[end--]) return false;\n    }\n    return true;\n}\n\nvoid dfs(const std::string& s, int start, std::vector<std::vector<std::string>>& results, std::vector<std::string> current) {\n    if (start == s.length()) {\n        results.push_back(current);\n        return;\n    }\n    \n    for (int end = start; end < s.length(); ++end) {\n        if (isPalindrome(s, start, end)) {\n            current.push_back(s.substr(start, end - start + 1));\n            dfs(s, end + 1, results, current);\n            current.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<std::string>> partition(std::string s) {\n    std::vector<std::vector<std::string>> results;\n    std::vector<std::string> current;\n    dfs(s, 0, results, current);\n    return results;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    private boolean isPalindrome(String s, int start, int end) {\n        while (start < end) {\n            if (s.charAt(start++) != s.charAt(end--)) return false;\n        }\n        return true;\n    }\n\n    private void dfs(String s, int start, List<List<String>> results, List<String> current) {\n        if (start == s.length()) {\n            results.add(new ArrayList<>(current));\n            return;\n        }\n        \n        for (int end = start; end < s.length(); end++) {\n            if (isPalindrome(s, start, end)) {\n                current.add(s.substring(start, end + 1));\n                dfs(s, end + 1, results, current);\n                current.remove(current.size() - 1);\n            }\n        }\n    }\n\n    public List<List<String>> partition(String s) {\n        List<List<String>> results = new ArrayList<>();\n        List<String> current = new ArrayList<>();\n        dfs(s, 0, results, current);\n        return results;\n    }\n}\n",
            "python": "def isPalindrome(s, start, end):\n    while start < end:\n        if s[start] != s[end]:\n            return False\n        start += 1\n        end -= 1\n    return True\n\ndef dfs(s, start, results, current):\n    if start == len(s):\n        results.append(current[:])\n        return\n    \n    for end in range(start, len(s)):\n        if isPalindrome(s, start, end):\n            current.append(s[start:end+1])\n            dfs(s, end + 1, results, current)\n            current.pop()\n\ndef partition(s):\n    results = []\n    dfs(s, 0, results, [])\n    return results\n",
            "javascript": "function isPalindrome(s, start, end) {\n    while (start < end) {\n        if (s[start++] !== s[end--]) return false;\n    }\n    return true;\n}\n\nfunction dfs(s, start, results, current) {\n    if (start === s.length) {\n        results.push([...current]);\n        return;\n    }\n    \n    for (let end = start; end < s.length; end++) {\n        if (isPalindrome(s, start, end)) {\n            current.push(s.slice(start, end + 1));\n            dfs(s, end + 1, results, current);\n            current.pop();\n        }\n    }\n}\n\nfunction partition(s) {\n    let results = [];\n    dfs(s, 0, results, []);\n    return results;\n}\n",
            "explanation": "The algorithm is based on depth-first search (DFS). It starts by iterating over substrings at each position and checks if the substring is a palindrome. If it is a palindrome, it adds the substring to the current list and does a depth-first search at the next position. When the search reaches the end of the string, it adds the current list to the results list. After searching at a given position, it backtracks to the previous position and continues to search for palindromes. The overall time complexity is O(N * 2^N) where N is the length of the string."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n\nbool isPalindrome(const std::string& s, int start, int end) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution \n    // Your code here\n}\n",
            "python": "def isPalindrome(s, start, end):\n    # Your code here\n\n",
            "javascript": "function isPalindrome(s, start, end) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <iostream>\n\nbool isPalindrome(const std::string& s, int start, int end) {\n    while (start < end) {\n        if (s[start++] != s[end--]) return false;\n    }\n    return true;\n}\n\nvoid dfs(const std::string& s, int start, std::vector<std::vector<std::string>>& results, std::vector<std::string> current) {\n    if (start == s.length()) {\n        results.push_back(current);\n        return;\n    }\n    \n    for (int end = start; end < s.length(); ++end) {\n        if (isPalindrome(s, start, end)) {\n            current.push_back(s.substr(start, end - start + 1));\n            dfs(s, end + 1, results, current);\n            current.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<std::string>> partition(std::string s) {\n    std::vector<std::vector<std::string>> results;\n    std::vector<std::string> current;\n    dfs(s, 0, results, current);\n    return results;\n}\n\nint main() {\n    std::string s = $args;\n    std::vector<std::vector<std::string>> result = partition(s);\n    for (const auto& vec : result) {\n        for (const auto& str : vec) {\n            std::cout << str << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}",
            "java": "public List<List<String>> partition(String s)",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = partition(s)\n    print(result)",
            "javascript": "function partition(s) {\n    let results = [];\n    dfs(s, 0, results, []);\n    return results;\n}"
        }
    },
    "134": {
        "title": "Gas Station Circuit",
        "description": "There are `n` gas stations along a circular route, where the amount of gas at the `ith` station is `gas[i]`. You have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `ith` station to its next `(i + 1)th` station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays `gas` and `cost`, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique.",
        "example": "Example:\n\nInput: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\nOutput: 3\nExplanation: Start at station 3 (index 3) and fill up with 4 units of gas. Your tank = 0 + 4 = 4. Travel to station 4. Your tank = 4 - 1 + 5 = 8. Travel to station 0. Your tank = 8 - 2 + 1 = 7. Travel to station 1. Your tank = 7 - 3 + 2 = 6. Travel to station 2. Your tank = 6 - 4 + 3 = 5. Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3. Therefore, return 3 as the starting index.",
        "level": "Medium",
        "tags": [
            "Array",
            "Greedy"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    3,
                    4,
                    5,
                    1,
                    2
                ],
                [
                    2,
                    3,
                    4
                ],
                [
                    3,
                    4,
                    3
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ]
            ],
            "outputs": [
                3,
                -1,
                0,
                -1,
                0,
                1,
                2,
                3,
                4,
                0,
                1,
                2,
                3,
                4,
                0,
                1,
                2,
                3,
                4,
                0
            ]
        },
        "sample_code": {
            "c++": "int can_complete_circuit(vector<int>& gas, vector<int>& cost) {\n    int total_gas = 0, total_cost = 0, start = 0, gas_tank = 0;\n    for (int i = 0; i < gas.size(); ++i) {\n        total_gas += gas[i];\n        total_cost += cost[i];\n        gas_tank += gas[i] - cost[i];\n        if (gas_tank < 0) {\n            start = i + 1;\n            gas_tank = 0;\n        }\n    }\n    return (total_gas < total_cost) ? -1 : start;\n}\n",
            "java": "public int canCompleteCircuit(int[] gas, int[] cost) {\n    int totalGas = 0, totalCost = 0, start = 0, gasTank = 0;\n    for (int i = 0; i < gas.length; i++) {\n        totalGas += gas[i];\n        totalCost += cost[i];\n        gasTank += gas[i] - cost[i];\n        if (gasTank < 0) {\n            start = i + 1;\n            gasTank = 0;\n        }\n    }\n    return (totalGas < totalCost) ? -1 : start;\n}\n",
            "python": "def can_complete_circuit(gas, cost):\n    total_gas, total_cost, start, gas_tank = 0, 0, 0, 0\n    for i in range(len(gas)):\n        total_gas += gas[i]\n        total_cost += cost[i]\n        gas_tank += gas[i] - cost[i]\n        if gas_tank < 0:\n            start = i + 1\n            gas_tank = 0\n    return -1 if total_gas < total_cost else start\n",
            "javascript": "function canCompleteCircuit(gas, cost) {\n    let totalGas = 0, totalCost = 0, start = 0, gasTank = 0;\n    for (let i = 0; i < gas.length; i++) {\n        totalGas += gas[i];\n        totalCost += cost[i];\n        gasTank += gas[i] - cost[i];\n        if (gasTank < 0) {\n            start = i + 1;\n            gasTank = 0;\n        }\n    }\n    return (totalGas < totalCost) ? -1 : start;\n}\n",
            "explanation": "The algorithm maintains four variables: `total_gas`, `total_cost`, `start`, and `gas_tank`. We initialize these variables to 0. We then loop through each gas station and perform the following steps:\n\n1. Add the gas at the current station to `total_gas`.\n2. Add the cost of traveling from this station to the next one to `total_cost`.\n3. Add the net gain/loss of gas (gas[i] - cost[i]) to `gas_tank`.\n4. If the `gas_tank` is negative, update the `start` position to the next station and reset the `gas_tank` to 0.\n\nAfter looping through all the gas stations, we check if `total_gas` is greater than or equal to `total_cost`. If it is, we return the `start` position, as this is the first gas station from which we can make a complete trip. If not, we return -1, because it is not possible to complete the circuit. \n\nThis algorithm guarantees a unique solution because if there are multiple valid starting points, there must be a gas station with a lower cost to travel from it to the next station for each solution. As a result, the one with the lowest starting cost would always be chosen, ensuring uniqueness."
        },
        "structure": {
            "c++": "int can_complete_circuit(vector<int>& gas, vector<int>& cost) \n    // Your code here\n}\n",
            "java": "public int canCompleteCircuit(int[] gas, int[] cost) \n    // Your code here\n}\n",
            "python": "def can_complete_circuit(gas, cost):\n    # Your code here\n\n",
            "javascript": "function canCompleteCircuit(gas, cost) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int can_complete_circuit(vector<int>& gas, vector<int>& cost) {\n    int total_gas = 0, total_cost = 0, start = 0, gas_tank = 0;\n    for (int i = 0; i < gas.size(); ++i) {\n        total_gas += gas[i];\n        total_cost += cost[i];\n        gas_tank += gas[i] - cost[i];\n        if (gas_tank < 0) {\n            start = i + 1;\n            gas_tank = 0;\n        }\n    }\n    return (total_gas < total_cost) ? -1 : start;\n}",
            "python": "if __name__ == \"__main__\":\n    gas = $args\n    cost = $args\n    result = can_complete_circuit(gas, cost)\n    print(result)"
        }
    },
    "135": {
        "title": "Minimum Number of Candies",
        "description": "There are `n` children standing in a line. Each child is assigned a rating value given in the integer array `ratings`. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. Return the minimum number of candies you need to have to distribute the candies to the children.",
        "example": "Example:\n\nInput: ratings = [1,0,2]\nOutput: 5\nExplanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n\nInput: ratings = [1,2,2]\nOutput: 4\nExplanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively. The third child gets 1 candy because it satisfies the above two conditions.",
        "level": "Medium",
        "tags": [
            "array",
            "greedy"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    0,
                    2
                ],
                [
                    1,
                    2,
                    2
                ],
                [
                    4,
                    2,
                    3,
                    4,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    1,
                    2,
                    3,
                    4,
                    5,
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1,
                    5,
                    4,
                    3,
                    2,
                    1,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1,
                    1,
                    2,
                    3,
                    4,
                    5
                ]
            ],
            "outputs": [
                5,
                4,
                9,
                5,
                15,
                15,
                16,
                9,
                15,
                25,
                15,
                25,
                20,
                20,
                30,
                30,
                10,
                15,
                15,
                25
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nint minCandies(vector<int>& ratings) {\n    int n = ratings.size();\n    vector<int> candies(n, 1);\n\n    for(int i = 1; i < n; i++) {\n        if(ratings[i] > ratings[i-1]) candies[i] = candies[i-1] + 1;\n    }\n    for(int i = n - 2; i >= 0; i--) {\n        if(ratings[i] > ratings[i+1]) candies[i] = max(candies[i], candies[i+1] + 1);\n    }\n\n    int sum = 0;\n    for(int candy : candies) sum += candy;\n\n    return sum;\n}\n",
            "java": "public int minCandies(int[] ratings) {\n    int n = ratings.length;\n    int[] candies = new int[n];\n    for (int i = 0; i < n; i++) candies[i] = 1;\n\n    for (int i = 1; i < n; i++) {\n        if (ratings[i] > ratings[i - 1]) candies[i] = candies[i - 1] + 1;\n    }\n    for (int i = n - 2; i >= 0; i--) {\n        if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n    }\n\n    int sum = 0;\n    for (int candy : candies) sum += candy;\n\n    return sum;\n}\n",
            "python": "def min_candies(ratings):\n    n = len(ratings)\n    candies = [1] * n\n\n    for i in range(1, n):\n        if ratings[i] > ratings[i - 1]:\n            candies[i] = candies[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n        if ratings[i] > ratings[i + 1]:\n            candies[i] = max(candies[i], candies[i + 1] + 1)\n\n    return sum(candies)\n",
            "javascript": "function minCandies(ratings) {\n    const n = ratings.length;\n    const candies = Array(n).fill(1);\n\n    for (let i = 1; i < n; i++) {\n        if (ratings[i] > ratings[i - 1]) candies[i] = candies[i - 1] + 1;\n    }\n    for (let i = n - 2; i >= 0; i--) {\n        if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n    }\n\n    return candies.reduce((a, b) => a + b, 0);\n}\n",
            "explanation": "The algorithm takes the following steps to find the minimum number of candies needed to be distributed among the children:\n1. Initialize an array or vector 'candies' with the same length as ratings and set all its elements to 1 as every child will have at least 1 candy.\n2. Iterate through the ratings array from the second child to the last child. If the rating of the current child is more than the rating of the previous child, update the candies for the current child as candies of the previous child plus 1.\n3. Now iterate through the ratings array from the second last child to the first child. If the rating of the current child is more than the rating of the next child, update the candies for the current child as maximum between the candies the child already holds and candies of the next child plus 1.\n4. Compute the sum of candies in the candies array or vector.\n5. Return the total number of candies needed.\n\nThis algorithm ensures that we give the proper number of candies to the children based on both their neighbors while also minimizing the total candies used."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nint minCandies(vector<int>& ratings) \n    // Your code here\n}\n",
            "java": "public int minCandies(int[] ratings) \n    // Your code here\n}\n",
            "python": "def min_candies(ratings):\n    # Your code here\n\n",
            "javascript": "function minCandies(ratings) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nint main() {\n    vector<int> ratings = $args;\n    int result = minCandies(ratings);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int minCandies(int[] ratings) {\n    int n = ratings.length;\n    int[] candies = new int[n];\n    for (int i = 0; i < n; i++) candies[i] = 1;\n\n    for (int i = 1; i < n; i++) {\n        if (ratings[i] > ratings[i - 1]) candies[i] = candies[i - 1] + 1;\n    }\n    for (int i = n - 2; i >= 0; i--) {\n        if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n    }\n\n    int sum = 0;\n    for (int candy : candies) sum += candy;\n\n    return sum;\n}",
            "python": "if __name__ == \"__main__\":\n    ratings = $args\n    result = min_candies(ratings)\n    print(result)"
        }
    },
    "139": {
        "title": "String Segmentation",
        "description": "Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation.",
        "example": "Example:\n\nInput: s = \"leetcode \", wordDict = [ \"leet \", \"code \"]\nOutput: true\nExplanation: Return true because \"leetcode \" can be segmented as \"leet code \".",
        "level": "Medium",
        "tags": [
            "dynamic programming",
            "string"
        ],
        "test_cases": {
            "inputs": [
                [
                    "leetcode ",
                    [
                        "leet ",
                        "code "
                    ]
                ],
                [
                    "applepenapple ",
                    [
                        "apple ",
                        "pen "
                    ]
                ],
                [
                    "catsandog ",
                    [
                        "cats ",
                        "dog ",
                        "sand ",
                        "and ",
                        "cat "
                    ]
                ],
                [
                    "programming ",
                    [
                        "program ",
                        "programming "
                    ]
                ],
                [
                    "algorithm ",
                    [
                        "algo ",
                        "rithm "
                    ]
                ],
                [
                    "hello ",
                    [
                        "hell ",
                        "hello "
                    ]
                ],
                [
                    "world ",
                    [
                        "world ",
                        "hello "
                    ]
                ],
                [
                    "leetcode ",
                    [
                        "leet ",
                        "code ",
                        "leet "
                    ]
                ],
                [
                    "applepenapple ",
                    [
                        "apple ",
                        "pen ",
                        "apple "
                    ]
                ],
                [
                    "catsandog ",
                    [
                        "cats ",
                        "dog ",
                        "sand ",
                        "and ",
                        "cat ",
                        "sand "
                    ]
                ],
                [
                    "programming ",
                    [
                        "program ",
                        "programming ",
                        "program "
                    ]
                ],
                [
                    "algorithm ",
                    [
                        "algo ",
                        "rithm ",
                        "algo "
                    ]
                ],
                [
                    "hello ",
                    [
                        "hell ",
                        "hello ",
                        "hell "
                    ]
                ],
                [
                    "world ",
                    [
                        "world ",
                        "hello ",
                        "world "
                    ]
                ],
                [
                    "leetcode ",
                    [
                        "leet ",
                        "code ",
                        "leet ",
                        "code "
                    ]
                ],
                [
                    "applepenapple ",
                    [
                        "apple ",
                        "pen ",
                        "apple ",
                        "pen "
                    ]
                ],
                [
                    "catsandog ",
                    [
                        "cats ",
                        "dog ",
                        "sand ",
                        "and ",
                        "cat ",
                        "sand ",
                        "dog "
                    ]
                ],
                [
                    "programming ",
                    [
                        "program ",
                        "programming ",
                        "program ",
                        "programming "
                    ]
                ],
                [
                    "algorithm ",
                    [
                        "algo ",
                        "rithm ",
                        "algo ",
                        "rithm "
                    ]
                ],
                [
                    "hello ",
                    [
                        "hell ",
                        "hello ",
                        "hell ",
                        "hello "
                    ]
                ],
                [
                    "world ",
                    [
                        "world ",
                        "hello ",
                        "world ",
                        "hello "
                    ]
                ]
            ],
            "outputs": [
                true,
                true,
                false,
                true,
                true,
                true,
                false,
                true,
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                false,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_set>\n\nbool wordBreak(std::string s, std::vector<std::string>& wordDict) {\n    std::unordered_set<std::string> dict(wordDict.begin(), wordDict.end());\n    std::vector<bool> dp(s.size() + 1, false);\n    dp[0] = true;\n    for (size_t i = 1; i <= s.size(); ++i) {\n        for (size_t j = 0; j < i; ++j) {\n            if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[s.size()];\n}\n\n",
            "java": "import java.util.List;\nimport java.util.Set;\nimport java.util.HashSet;\n\npublic boolean wordBreak(String s, List<String> wordDict) {\n    Set<String> dict = new HashSet<>(wordDict);\n    boolean[] dp = new boolean[s.length() + 1];\n    dp[0] = true;\n    for (int i = 1; i <= s.length(); i++) {\n        for (int j = 0; j < i; j++) {\n            if (dp[j] && dict.contains(s.substring(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[s.length()];\n}\n\n",
            "python": "def word_break(s, word_dict):\n    word_set = set(word_dict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    return dp[len(s)]\n\n",
            "javascript": "function wordBreak(s, wordDict) {\n    const dict = new Set(wordDict);\n    const dp = Array(s.length + 1).fill(false);\n    dp[0] = true;\n    for (let i = 1; i <= s.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (dp[j] && dict.has(s.slice(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[s.length];\n}\n\n",
            "explanation": "The algorithm uses dynamic programming to solve the problem. The dp array is created with the size of the input string s plus 1. dp[i] is true if there exists a segmentation of the first i characters of the string s into words from the dictionary. The algorithm initializes dp[0] as true since an empty string can be segmented.\n\nFor each character in the input string s, the algorithm checks all substrings ending at this character. If the substring s[j:i] is in the dictionary (or wordDict for Java and C++) and dp[j] is true, set dp[i] to true and break from the inner loop.\n\nAt the end of the algorithm, dp[s.size()] (or dp[s.length()] for Java and JavaScript, or dp[len(s)] in Python) contains the result for the entire input string s. If this value is true, the input string can be segmented into a sequence of one or more dictionary words, otherwise it cannot."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_set>\n\nbool wordBreak(std::string s, std::vector<std::string>& wordDict) \n    // Your code here\n}\n\n",
            "java": "import java.util.List;\nimport java.util.Set;\nimport java.util.HashSet;\n\npublic boolean wordBreak(String s, List<String> wordDict) \n    // Your code here\n}\n\n",
            "python": "def word_break(s, word_dict):\n    # Your code here\n\n",
            "javascript": "function wordBreak(s, wordDict) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_set>\n#include <iostream>\n\nbool wordBreak(std::string s, std::vector<std::string>& wordDict) {\n    std::unordered_set<std::string> dict(wordDict.begin(), wordDict.end());\n    std::vector<bool> dp(s.size() + 1, false);\n    dp[0] = true;\n    for (size_t i = 1; i <= s.size(); ++i) {\n        for (size_t j = 0; j < i; ++j) {\n            if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[s.size()];\n}\n\nint main() {\n    std::string s = $args;\n    std::vector<std::string> wordDict = {\"leet\", \"code\"};\n    bool result = wordBreak(s, wordDict);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}\n",
            "java": "public boolean wordBreak(String s, List<String> wordDict) {\n    Set<String> dict = new HashSet<>(wordDict);\n    boolean[] dp = new boolean[s.length() + 1];\n    dp[0] = true;\n    for (int i = 1; i <= s.length(); i++) {\n        for (int j = 0; j < i; j++) {\n            if (dp[j] && dict.contains(s.substring(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[s.length()];\n}",
            "python": "if __name__ == \"__main__\":\n    inputs =$args\n    s=inputs[0]\n    word_dict = inputs[1]\n    result = word_break(s, word_dict)\n    print(result)\n"
        }
    },
    "140": {
        "title": "Sentence Construction",
        "description": "Given a string `s` and a dictionary of strings `wordDict`, add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in **any order**. Note that the same word in the dictionary may be reused multiple times in the segmentation.",
        "example": "Example:\n\nInput: s =  \"catsanddog \", wordDict = [ \"cat \", \"cats \", \"and \", \"sand \", \"dog \"]\nOutput: [ \"cats and dog \", \"cat sand dog \"]\n\nInput: s =  \"pineapplepenapple \", wordDict = [ \"apple \", \"pen \", \"applepen \", \"pine \", \"pineapple \"]\nOutput: [ \"pine apple pen apple \", \"pineapple pen apple \", \"pine applepen apple \"]\nExplanation: Note that you are allowed to reuse a dictionary word.\n\nInput: s =  \"catsandog \", wordDict = [ \"cats \", \"dog \", \"sand \", \"and \", \"cat \"]\nOutput: []",
        "level": "Medium",
        "tags": [
            "string",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    "catsanddog ",
                    [
                        "cat ",
                        "cats ",
                        "and ",
                        "sand ",
                        "dog "
                    ]
                ],
                [
                    "pineapplepenapple ",
                    [
                        "apple ",
                        "pen ",
                        "applepen ",
                        "pine ",
                        "pineapple "
                    ]
                ],
                [
                    "catsandog ",
                    [
                        "cats ",
                        "dog ",
                        "sand ",
                        "and ",
                        "cat "
                    ]
                ],
                [
                    "iloveleetcode ",
                    [
                        "i ",
                        "love ",
                        "leetcode "
                    ]
                ],
                [
                    "programmingisfun ",
                    [
                        "programming ",
                        "is ",
                        "fun "
                    ]
                ],
                [
                    "hellothere ",
                    [
                        "hello ",
                        "there "
                    ]
                ],
                [
                    "thisisatest ",
                    [
                        "this ",
                        "is ",
                        "a ",
                        "test "
                    ]
                ],
                [
                    "codingisawesome ",
                    [
                        "coding ",
                        "is ",
                        "awesome "
                    ]
                ],
                [
                    "happynewyear ",
                    [
                        "happy ",
                        "new ",
                        "year "
                    ]
                ],
                [
                    "goodmorning ",
                    [
                        "good ",
                        "morning "
                    ]
                ],
                [
                    "helloworld ",
                    [
                        "hello ",
                        "world "
                    ]
                ],
                [
                    "programminglanguage ",
                    [
                        "programming ",
                        "language "
                    ]
                ],
                [
                    "computerscience ",
                    [
                        "computer ",
                        "science "
                    ]
                ],
                [
                    "datascience ",
                    [
                        "data ",
                        "science "
                    ]
                ],
                [
                    "algorithm ",
                    [
                        "algo ",
                        "rithm "
                    ]
                ],
                [
                    "python ",
                    [
                        "py ",
                        "thon "
                    ]
                ],
                [
                    "javascript ",
                    [
                        "java ",
                        "script "
                    ]
                ],
                [
                    "cplusplus ",
                    [
                        "c ",
                        "plus ",
                        "plus "
                    ]
                ],
                [
                    "ruby ",
                    [
                        "ru ",
                        "by "
                    ]
                ],
                [
                    "java ",
                    [
                        "ja ",
                        "va "
                    ]
                ]
            ],
            "outputs": [
                "[ \"cats and dog \", \"cat sand dog \"]",
                "[ \"pine apple pen apple \", \"pineapple pen apple \", \"pine applepen apple \"]",
                "[]",
                "[ \"i love leet code \", \"i love leetcode \"]",
                "[ \"programming is fun \"]",
                "[ \"hello there \"]",
                "[ \"this is a test \"]",
                "[ \"coding is awesome \"]",
                "[ \"happy new year \"]",
                "[ \"good morning \"]",
                "[ \"hello world \"]",
                "[ \"programming language \"]",
                "[ \"computer science \"]",
                "[ \"data science \"]",
                "[ \"algo rithm \"]",
                "[ \"py thon \"]",
                "[ \"java script \"]",
                "[ \"c plus plus \"]",
                "[ \"ru by \"]",
                "[ \"ja va \"]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_set>\n\nstd::vector<std::string> helper(const std::string& s, const std::unordered_set<std::string>& dict, std::unordered_map<std::string, std::vector<std::string>>& memo) {\n    if (memo.count(s)) return memo[s];\n\n    std::vector<std::string> res;\n    if (dict.count(s)) res.push_back(s);\n\n    for (int i = 1; i < s.size(); ++i) {\n        std::string prefix = s.substr(0, i);\n        if (!dict.count(prefix)) continue;\n        std::string suffix = s.substr(i);\n        auto temp = helper(suffix, dict, memo);\n        for (const auto& t : temp) {\n            res.push_back(prefix + \" \" + t);\n        }\n    }\n    memo[s] = res;\n    return res;\n}\n\nstd::vector<std::string> wordBreak(std::string s, std::vector<std::string>& wordDict) {\n    std::unordered_set<std::string> dict(wordDict.begin(), wordDict.end());\n    std::unordered_map<std::string, std::vector<std::string>> memo;\n    return helper(s, dict, memo);\n}\n",
            "java": "import java.util.*;\n\npublic List<String> wordBreak(String s, List<String> wordDict) {\n    HashSet<String> dict = new HashSet<>(wordDict);\n    HashMap<String, List<String>> memo = new HashMap<>();\n    return helper(s, dict, memo);\n}\n\nprivate List<String> helper(String s, HashSet<String> dict, HashMap<String, List<String>> memo) {\n    if (memo.containsKey(s)) {\n        return memo.get(s);\n    }\n    \n    List<String> res = new ArrayList<>();\n    if (dict.contains(s)) {\n        res.add(s);\n    }\n    \n    for (int i = 1; i < s.length(); ++i) {\n        String prefix = s.substring(0, i);\n        if (!dict.contains(prefix)) continue;\n        String suffix = s.substring(i);\n        List<String> temp = helper(suffix, dict, memo);\n        for (String t : temp) {\n            res.add(prefix + \" \" + t);\n        }\n    }\n\n    memo.put(s, res);\n    return res;\n}\n",
            "python": "def word_break(s, word_dict):\n    def helper(s, word_set, memo):\n        if s in memo:\n            return memo[s]\n\n        res = []\n        if s in word_set:\n            res.append(s)\n\n        for i in range(1, len(s)):\n            prefix = s[:i]\n            if prefix not in word_set:\n                continue\n            suffix = s[i:]\n            temp = helper(suffix, word_set, memo)\n            for t in temp:\n                res.append(prefix + \" \" + t)\n\n        memo[s] = res\n        return res\n\n    word_set = set(word_dict)\n    memo = {}\n    return helper(s, word_set, memo)",
            "javascript": "function wordBreak(s, wordDict) {\n    const dict = new Set(wordDict);\n    const memo = {};\n\n    function helper(s, dict, memo) {\n        if (s in memo) {\n            return memo[s];\n        }\n        \n        const res = [];\n        if (dict.has(s)) {\n            res.push(s);\n        }\n        \n        for (let i = 1; i < s.length; ++i) {\n            const prefix = s.slice(0, i);\n            if (!dict.has(prefix)) continue;\n            const suffix = s.slice(i);\n            const temp = helper(suffix, dict, memo);\n            for (const t of temp) {\n                res.push(prefix + \" \" + t);\n            }\n        }\n\n        memo[s] = res;\n        return res;\n    }\n\n    return helper(s, dict, memo);\n}\n",
            "explanation": "The algorithm used is a combination of depth-first search with memoization. We start from the first character of the given string `s`, then create all possible substrings by incrementing the index.\n\nFor each substring, we check if it exists in the dictionary. If it exists, we call the helper function recursively on the remaining part of the string (suffix). This will give us all the possible combinations for the suffix. Then, we combine the prefix with each combination and add it to the result.\n\nMemoization is used to store the results of the helper function for each substring encountered, so that we don't need to compute it multiple times. This speeds up the algorithm by reducing repeated computations.\n\nFinally, we return the list of combinations where all the words are found in the dictionary."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_set>\n\nstd::vector<std::string> helper(const std::string& s, const std::unordered_set<std::string>& dict, std::unordered_map<std::string, std::vector<std::string>>& memo) \n    // Your code here\n}\n",
            "java": "import java.util.*;\n\npublic List<String> wordBreak(String s, List<String> wordDict) \n    // Your code here\n}\n",
            "python": "def word_break(s, word_dict):\n    # Your code here\n\n",
            "javascript": "function wordBreak(s, wordDict) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_set>\n\nstd::vector<std::string> helper(const std::string& s, const std::unordered_set<std::string>& dict, std::unordered_map<std::string, std::vector<std::string>>& memo);\n\nstd::vector<std::string> wordBreak(std::string s, std::vector<std::string>& wordDict);\n\nint main() {\n    std::string s = $args;\n    std::vector<std::string> wordDict = {\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"};\n    std::vector<std::string> result = wordBreak(s, wordDict);\n    for (const auto& res : result) {\n        std::cout << res << std::endl;\n    }\n    return 0;\n}",
            "java": "public List<String> wordBreak(String s, List<String> wordDict) {\n    HashSet<String> dict = new HashSet<>(wordDict);\n    HashMap<String, List<String>> memo = new HashMap<>();\n    return helper(s, dict, memo);\n}\n\nprivate List<String> helper(String s, HashSet<String> dict, HashMap<String, List<String>> memo) {\n    if (memo.containsKey(s)) {\n        return memo.get(s);\n    }\n    \n    List<String> res = new ArrayList<>();\n    if (dict.contains(s)) {\n        res.add(s);\n    }\n    \n    for (int i = 1; i < s.length(); ++i) {\n        String prefix = s.substring(0, i);\n        if (!dict.contains(prefix)) continue;\n        String suffix = s.substring(i);\n        List<String> temp = helper(suffix, dict, memo);\n        for (String t : temp) {\n            res.add(prefix + \" \" + t);\n        }\n    }\n\n    memo.put(s, res);\n    return res;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs =$args\n    s=inputs[0]\n    word_dict = inputs[1]\n    result = word_break(s, word_dict)\n    for res in result:\n        print(res)\n"
        }
    },
    "141": {
        "title": "Linked List Cycle",
        "description": "Given the head of a linked list, determine if the linked list has a cycle in it. A cycle exists in a linked list if there is a node that can be reached again by continuously following the next pointer. The tail's next pointer is connected to a node at a specific index denoted by `pos`. Return true if there is a cycle in the linked list, otherwise return false.",
        "example": "Example 1:\n\nInput: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n\nExample 2:\n\nInput: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.\n\nExample 3:\n\nInput: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list.",
        "level": "Easy",
        "tags": [
            "Linked List",
            "Two Pointers"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        3,
                        2,
                        0,
                        -4
                    ],
                    1
                ],
                [
                    [
                        1,
                        2
                    ],
                    0
                ],
                [
                    [
                        1
                    ],
                    -1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    -1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    2
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    4
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    6
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    7
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    8
                ],
                [
                    [],
                    -1
                ],
                [
                    [
                        1
                    ],
                    0
                ],
                [
                    [
                        1,
                        2
                    ],
                    1
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    2
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    9
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    11
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    12
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    13
                ]
            ],
            "outputs": [
                true,
                true,
                false,
                false,
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "bool hasCycle(ListNode *head) {\n    ListNode *slow = head, *fast = head;\n    while (fast != nullptr && fast->next != nullptr) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) {\n            return true;\n        }\n    }\n    return false;\n}\n",
            "java": "public boolean hasCycle(ListNode head) {\n    ListNode slow = head, fast = head;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) {\n            return true;\n        }\n    }\n    return false;\n}\n",
            "python": "def hasCycle(head):\n    slow = fast = head\n    while fast is not None and fast.next is not None:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False\n",
            "javascript": "function hasCycle(head) {\n    let slow = head, fast = head;\n    while (fast !== null && fast.next !== null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) {\n            return true;\n        }\n    }\n    return false;\n}\n",
            "explanation": "The algorithm used is Floyd's cycle-finding algorithm, also known as the \"tortoise and the hare\" algorithm. There are two pointers, one slow (tortoise) and another fast (hare). The slow pointer moves one step at a time, and the fast pointer moves two steps. \n\nInitially, both pointers are set to the head of the linked list. The pointers are moved forward with their respective speeds until either the fast pointer reaches the end of the linked list or both pointers meet at the same node. \n\nIf the fast pointer reaches the end, it means that there is no cycle and the function returns false. If the pointers meet at some point in the linked list, there is a cycle and the function returns true."
        },
        "structure": {
            "c++": "bool hasCycle(ListNode *head) \n    // Your code here\n}\n",
            "java": "public boolean hasCycle(ListNode head) \n    // Your code here\n}\n",
            "python": "def hasCycle(head):\n    # Your code here\n\n",
            "javascript": "function hasCycle(head) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "bool hasCycle(ListNode *head) {\n    ListNode *slow = head, *fast = head;\n    while (fast != nullptr && fast->next != nullptr) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) {\n            return true;\n        }\n    }\n    return false;\n}",
            "java": "public boolean hasCycle(ListNode head) {\n    ListNode slow = head, fast = head;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) {\n            return true;\n        }\n    }\n    return false;\n}",
            "python": "if __name__ == \"__main__\":\n    head = $args[0]\n    result = hasCycle(head)\n    print(result)",
            "javascript": "function main() {\n    const head = $args;\n    const result = hasCycle(head);\n    console.log(result);\n}"
        }
    },
    "146": {
        "title": "LRU Cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class with the following methods: \n\n- `LRUCache(int capacity)`: Initialize the LRU cache with a positive size `capacity`. \n- `int get(int key)`: Return the value of the `key` if the key exists, otherwise return `-1`. \n- `void put(int key, int value)`: Update the value of the `key` if the `key` exists. Otherwise, add the `key-value` pair to the cache. If the number of keys exceeds the `capacity` from this operation, evict the least recently used key. \n\nThe functions `get` and `put` must each run in O(1) average time complexity.",
        "example": "Example:\n\nInput:\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput:\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation:\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4",
        "level": "Medium",
        "tags": [
            "Design",
            "Data Structure",
            "Cache"
        ],
        "test_cases": {
            "inputs": [
                "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
                "[\"LRUCache\", \"put\", \"get\", \"put\", \"get\", \"get\"]\n[[1], [2, 1], [2], [3, 2], [2], [3]]",
                "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"put\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [4, 4], [2]]",
                "[\"LRUCache\", \"put\", \"put\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [3, 3], [1], [2], [3]]",
                "[\"LRUCache\", \"put\", \"put\", \"put\", \"put\", \"get\", \"get\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [3, 3], [4, 4], [1], [2], [3], [4], [5]]"
            ],
            "outputs": [
                [
                    null,
                    null,
                    null,
                    1,
                    null,
                    -1,
                    null,
                    -1,
                    3,
                    4
                ],
                [
                    null,
                    null,
                    1,
                    null,
                    -1,
                    2
                ],
                [
                    null,
                    null,
                    null,
                    1,
                    null,
                    null,
                    -1
                ],
                [
                    null,
                    null,
                    null,
                    null,
                    -1,
                    2,
                    3
                ],
                [
                    null,
                    null,
                    null,
                    null,
                    null,
                    -1,
                    2,
                    3,
                    4,
                    -1
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <unordered_map>\n#include <list>\nusing namespace std;\n\nclass LRUCache {\n    int capacity;\n    list<pair<int, int>> lru_list;\n    unordered_map<int, list<pair<int, int>>::iterator> cache;\n\npublic:\n    LRUCache(int cap) : capacity(cap) {}\n\n    int get(int key) {\n        auto it = cache.find(key);\n        if (it == cache.end()) {\n            return -1;\n        }\n        lru_list.splice(lru_list.begin(), lru_list, it->second);\n        return it->second->second;\n    }\n\n    void put(int key, int value) {\n        auto it = cache.find(key);\n        if (it != cache.end()) {\n            lru_list.erase(it->second);\n        } else if (lru_list.size() == (size_t)capacity) {\n            cache.erase(lru_list.rbegin()->first);\n            lru_list.pop_back();\n        }\n        lru_list.emplace_front(key, value);\n        cache[key] = lru_list.begin();\n    }\n};\n\n",
            "java": "import java.util.HashMap;\n\npublic class LRUCache {\n    int capacity;\n    private HashMap<Integer, Node> cache;\n    private Node head, tail;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        cache = new HashMap<>();\n        head = new Node();\n        tail = new Node();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        Node node = cache.get(key);\n        if (node == null) return -1;\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        Node node = cache.get(key);\n        if (node != null) {\n            node.value = value;\n            moveToHead(node);\n        } else {\n            node = new Node(key, value);\n            cache.put(key, node);\n            addToHead(node);\n            if (cache.size() > capacity) {\n                cache.remove(removeTail().key);\n            }\n        }\n    }\n\n    private void addToHead(Node node) {\n        node.next = head.next;\n        node.prev = head;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void moveToHead(Node node) {\n        removeFromList(node);\n        addToHead(node);\n    }\n\n    private void removeFromList(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private Node removeTail() {\n        Node res = tail.prev;\n        removeFromList(res);\n        return res;\n    }\n\n    class Node {\n        int key;\n        int value;\n        Node prev;\n        Node next;\n\n        public Node() {\n        }\n\n        public Node(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n}\n\n",
            "python": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        value = self.cache.pop(key)\n        self.cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.pop(key)\n        elif len(self.cache) >= self.capacity:\n            self.cache.popitem(last=False)\n        self.cache[key] = value\n\n",
            "javascript": "class LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity;\n        this.cache = new Map();\n    }\n\n    get(key) {\n        if (!this.cache.has(key)) {\n            return -1;\n        }\n        const value = this.cache.get(key);\n        this.cache.delete(key);\n        this.cache.set(key, value);\n        return value;\n    }\n\n    put(key, value) {\n        if (this.cache.has(key)) {\n            this.cache.delete(key);\n        } else if (this.cache.size >= this.capacity) {\n            this.cache.delete(this.cache.keys().next().value);\n        }\n        this.cache.set(key, value);\n    }\n}\n\n",
            "explanation": "The LRU Cache data structure consists of a doubly-linked list and a hash map.\n\n- The get operation checks if the key exists in the cache using constant-time lookup. If it exists, move the corresponding node to the head/front of the linked list and return the value.\n- The put operation follows similar steps as the get function, but additionally updates the value of the key. If the key does not exist in the cache and the cache's size is at capacity, the tail/end node is removed from the cache, and the new item is inserted at the head/front of the list.\n\nIn all of the implementations above, the code follows this general algorithm taking advantage of the respective language's inbuilt functions to ensure O(1) average time complexity for both get and put operations."
        },
        "structure": {
            "c++": "#include <unordered_map>\n#include <list>\nusing namespace std;\n\nclass LRUCache \n    // Your code here\n};\n\n",
            "java": "import java.util.HashMap;\n\npublic class LRUCache \n    // Your code here\n}\n\n",
            "python": "from collections import OrderedDict\n    # Your code here\n\n",
            "javascript": "class LRUCache \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <unordered_map>\n#include <list>\nusing namespace std;\n\nint main() {\n    int capacity = $args;\n    LRUCache lru(capacity);\n    int result = lru.get(1);\n    lru.put(1, 1);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int get(int key) {\n        Node node = cache.get(key);\n        if (node == null) return -1;\n        moveToHead(node);\n        return node.value;\n    }",
            "python": "if __name__ == \"__main__\":\n    capacity = $args[0]\n    cache = LRUCache(capacity)\n    cache.put(1, 1)\n    cache.put(2, 2)\n    print(cache.get(1))\n    cache.put(3, 3)\n    print(cache.get(2))\n    cache.put(4, 4)\n    print(cache.get(1))\n    print(cache.get(3))\n    print(cache.get(4))",
            "javascript": "function main() {\n    const capacity = $args;\n    const cache = new LRUCache(capacity);\n    cache.put(1, 1);\n    cache.put(2, 2);\n    const value1 = cache.get(1);\n    console.log(value1);\n    cache.put(3, 3);\n    const value2 = cache.get(2);\n    console.log(value2);\n}"
        }
    },
    "149": {
        "title": "Maximum Points on a Line",
        "description": "Given an array of points where each point is represented as [x, y] coordinates on the X-Y plane, find the maximum number of points that lie on the same straight line.",
        "example": "Example 1:\n\nInput: points = [[1,1],[2,2],[3,3]]\nOutput: 3\n\nExplanation: All three points lie on the same line.\n\nExample 2:\n\nInput: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4\n\nExplanation: The maximum number of points that lie on the same line is 4.\n\n",
        "level": "Medium",
        "tags": [
            "Math",
            "Geometry",
            "Hash Table"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        3,
                        2
                    ],
                    [
                        5,
                        3
                    ],
                    [
                        4,
                        1
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        1,
                        4
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        0,
                        0
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ],
                    [
                        26,
                        26
                    ],
                    [
                        27,
                        27
                    ],
                    [
                        28,
                        28
                    ],
                    [
                        29,
                        29
                    ],
                    [
                        30,
                        30
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ],
                    [
                        26,
                        26
                    ],
                    [
                        27,
                        27
                    ],
                    [
                        28,
                        28
                    ],
                    [
                        29,
                        29
                    ],
                    [
                        30,
                        30
                    ],
                    [
                        31,
                        31
                    ],
                    [
                        32,
                        32
                    ],
                    [
                        33,
                        33
                    ],
                    [
                        34,
                        34
                    ],
                    [
                        35,
                        35
                    ],
                    [
                        36,
                        36
                    ],
                    [
                        37,
                        37
                    ],
                    [
                        38,
                        38
                    ],
                    [
                        39,
                        39
                    ],
                    [
                        40,
                        40
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ],
                    [
                        26,
                        26
                    ],
                    [
                        27,
                        27
                    ],
                    [
                        28,
                        28
                    ],
                    [
                        29,
                        29
                    ],
                    [
                        30,
                        30
                    ],
                    [
                        31,
                        31
                    ],
                    [
                        32,
                        32
                    ],
                    [
                        33,
                        33
                    ],
                    [
                        34,
                        34
                    ],
                    [
                        35,
                        35
                    ],
                    [
                        36,
                        36
                    ],
                    [
                        37,
                        37
                    ],
                    [
                        38,
                        38
                    ],
                    [
                        39,
                        39
                    ],
                    [
                        40,
                        40
                    ],
                    [
                        41,
                        41
                    ],
                    [
                        42,
                        42
                    ],
                    [
                        43,
                        43
                    ],
                    [
                        44,
                        44
                    ],
                    [
                        45,
                        45
                    ],
                    [
                        46,
                        46
                    ],
                    [
                        47,
                        47
                    ],
                    [
                        48,
                        48
                    ],
                    [
                        49,
                        49
                    ],
                    [
                        50,
                        50
                    ]
                ]
            ],
            "outputs": [
                "3",
                "4",
                "3",
                "5",
                "10",
                "15",
                "20",
                "25",
                "30",
                "35"
            ]
        },
        "sample_code": {
            "c++": "#include <unordered_map>\n\nint maxPoints(vector<vector<int>>& points) {\n    int n = points.size();\n    if (n <= 2) return n;\n    int max_count = 0;\n\n    for (int i = 0; i < n; i++) {\n        std::unordered_map<string, int> slope_map;\n        int duplicates = 0, local_max = 0;\n\n        for (int j = i + 1; j < n; j++) {\n            int deltaX = points[j][0] - points[i][0];\n            int deltaY = points[j][1] - points[i][1];\n\n            if (deltaX == 0 && deltaY == 0) {\n                duplicates++;\n                continue;\n            }\n\n            int gcd = std::gcd(deltaX, deltaY);\n            deltaX /= gcd;\n            deltaY /= gcd;\n\n            string key = to_string(deltaX) + \"_\" + to_string(deltaY);\n            slope_map[key]++;\n            local_max = max(local_max, slope_map[key]);\n        }\n        max_count = max(max_count, local_max + duplicates + 1);\n    }\n\n    return max_count;\n}\n\n",
            "java": "import java.util.HashMap;\n\npublic int maxPoints(int[][] points) {\n    int n = points.length;\n    if (n <= 2) return n;\n    int maxCount = 0;\n\n    for (int i = 0; i < n-1; i++) {\n        HashMap<String, Integer> slopeMap = new HashMap<>();\n        int duplicates = 0, localMax = 0;\n\n        for (int j = i+1; j < n; j++) {\n            int deltaX = points[j][0] - points[i][0];\n            int deltaY = points[j][1] - points[i][1];\n\n            if (deltaX == 0 && deltaY == 0) {\n                duplicates++;\n                continue;\n            }\n\n            int gcd = gcd(deltaX, deltaY);\n            deltaX /= gcd;\n            deltaY /= gcd;\n\n            String key = deltaX + \"_\" + deltaY;\n            slopeMap.put(key, slopeMap.getOrDefault(key, 0) + 1);\n            localMax = Math.max(localMax, slopeMap.get(key));\n        }\n        maxCount = Math.max(maxCount, localMax + duplicates + 1);\n    }\n\n    return maxCount;\n}\n\nprivate int gcd(int a, int b) {\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\n",
            "python": "from math import gcd\nfrom collections import defaultdict\n\ndef maxPoints(points):\n    n = len(points)\n    if n <= 2:\n        return n\n\n    max_count = 0\n\n    for i in range(n):\n        slope_map = defaultdict(int)\n        duplicates = 0\n        local_max = 0\n\n        for j in range(i+1, n):\n            deltaX = points[j][0] - points[i][0]\n            deltaY = points[j][1] - points[i][1]\n\n            if deltaX == 0 and deltaY == 0:\n                duplicates += 1\n                continue\n\n            g = gcd(deltaX, deltaY)\n            deltaX = deltaX // g\n            deltaY = deltaY // g\n\n            key = f\"{deltaX}_{deltaY}\"\n            slope_map[key] += 1\n            local_max = max(local_max, slope_map[key])\n\n        max_count = max(max_count, local_max + duplicates + 1)\n\n    return max_count\n\n",
            "javascript": "function maxPoints(points) {\n    const n = points.length;\n    if (n <= 2) return n;\n\n    let maxCount = 0;\n\n    for (let i = 0; i < n; i++) {\n        const slopeMap = new Map();\n        let duplicates = 0, localMax = 0;\n\n        for (let j = i + 1; j < n; j++) {\n            let deltaX = points[j][0] - points[i][0];\n            let deltaY = points[j][1] - points[i][1];\n\n            if (deltaX === 0 && deltaY === 0) {\n                duplicates++;\n                continue;\n            }\n\n            const gcdVal = gcd(deltaX, deltaY);\n            deltaX /= gcdVal;\n            deltaY /= gcdVal;\n\n            const key = `${deltaX}_${deltaY}`;\n            slopeMap.set(key, (slopeMap.get(key) || 0) + 1);\n            localMax = Math.max(localMax, slopeMap.get(key));\n        }\n        maxCount = Math.max(maxCount, localMax + duplicates + 1);\n    }\n\n    return maxCount;\n}\n\nfunction gcd(a, b) {\n    if (b === 0) return a;\n    return gcd(b, a % b);\n}\n\n",
            "explanation": "- Loop through all pairs of points.\n- Calculate the slope of the line determined by the two points `(deltaX / deltaY)`, as well as the number of duplicates of the same point.\n- Count the occurrences of each unique slope (i.e., the lines that go through the same two points), using a hashmap.\n- For each point, find the highest number of slopes and add the duplicates and itself to the count.\n- Find the maximum count of all points, which is the answer."
        },
        "structure": {
            "c++": "#include <unordered_map>\n\nint maxPoints(vector<vector<int>>& points) \n    // Your code here\n}\n\n",
            "java": "import java.util.HashMap;\n\npublic int maxPoints(int[][] points) \n    // Your code here\n}\n\n",
            "python": "from math import gcd\n    # Your code here\n\n",
            "javascript": "function maxPoints(points) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <unordered_map>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nint maxPoints(vector<vector<int>>& points) {\n    int n = points.size();\n    if (n <= 2) return n;\n    int max_count = 0;\n\n    for (int i = 0; i < n; i++) {\n        std::unordered_map<string, int> slope_map;\n        int duplicates = 0, local_max = 0;\n\n        for (int j = i + 1; j < n; j++) {\n            int deltaX = points[j][0] - points[i][0];\n            int deltaY = points[j][1] - points[i][1];\n\n            if (deltaX == 0 && deltaY == 0) {\n                duplicates++;\n                continue;\n            }\n\n            int gcd = std::gcd(deltaX, deltaY);\n            deltaX /= gcd;\n            deltaY /= gcd;\n\n            string key = to_string(deltaX) + \"_\" + to_string(deltaY);\n            slope_map[key]++;\n            local_max = max(local_max, slope_map[key]);\n        }\n        max_count = max(max_count, local_max + duplicates + 1);\n    }\n\n    return max_count;\n}\n\nint main() {\n    vector<vector<int>> points = $args;\n    int result = maxPoints(points);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int maxPoints(int[][] points) {\n    int n = points.length;\n    if (n <= 2) return n;\n    int maxCount = 0;\n\n    for (int i = 0; i < n-1; i++) {\n        HashMap<String, Integer> slopeMap = new HashMap<>();\n        int duplicates = 0, localMax = 0;\n\n        for (int j = i+1; j < n; j++) {\n            int deltaX = points[j][0] - points[i][0];\n            int deltaY = points[j][1] - points[i][1];\n\n            if (deltaX == 0 && deltaY == 0) {\n                duplicates++;\n                continue;\n            }\n\n            int gcd = gcd(deltaX, deltaY);\n            deltaX /= gcd;\n            deltaY /= gcd;\n\n            String key = deltaX + \"_\" + deltaY;\n            slopeMap.put(key, slopeMap.getOrDefault(key, 0) + 1);\n            localMax = Math.max(localMax, slopeMap.get(key));\n        }\n        maxCount = Math.max(maxCount, localMax + duplicates + 1);\n    }\n\n    return maxCount;\n}",
            "python": "if __name__ == \"__main__\":\n    points = $args\n    result = maxPoints(points)\n    print(result)",
            "javascript": "function main() {\n    const points = $args;\n    const result = maxPoints(points);\n    console.log(result);\n}"
        }
    },
    "150": {
        "title": "Evaluate Reverse Polish Notation",
        "description": "You are given an array of strings `tokens` that represents an arithmetic expression in a Reverse Polish Notation. Evaluate the expression and return an integer that represents the value of the expression. The valid operators are '+', '-', '*', and '/'. Each operand may be an integer or another expression. The division between two integers always truncates toward zero. There will not be any division by zero. The input represents a valid arithmetic expression in a reverse polish notation. The answer and all the intermediate calculations can be represented in a 32-bit integer.",
        "example": "Example:\n\nInput: tokens = [\"2\", \"1\", \"+\", \"3\", \"*\"]\nOutput: 9\nExplanation: ((2 + 1) * 3) = 9",
        "level": "Medium",
        "tags": [
            "Stack",
            "Math"
        ],
        "test_cases": {
            "inputs": [
                [
                    "2",
                    "1",
                    "+",
                    "3",
                    "*"
                ],
                [
                    "4",
                    "13",
                    "5",
                    "/",
                    "+"
                ],
                [
                    "10",
                    "6",
                    "9",
                    "3",
                    "+",
                    "-11",
                    "*",
                    "/",
                    "*",
                    "17",
                    "+",
                    "5",
                    "+"
                ],
                [
                    "5",
                    "2",
                    "*",
                    "10",
                    "3",
                    "/",
                    "+",
                    "4",
                    "-"
                ],
                [
                    "3",
                    "4",
                    "+",
                    "2",
                    "*",
                    "1",
                    "+"
                ],
                [
                    "4",
                    "2",
                    "5",
                    "*",
                    "+",
                    "1",
                    "3",
                    "2",
                    "*",
                    "+",
                    "/"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-"
                ],
                [
                    "4",
                    "13",
                    "5",
                    "/",
                    "+",
                    "2",
                    "3",
                    "*",
                    "-"
                ],
                [
                    "10",
                    "6",
                    "9",
                    "3",
                    "+",
                    "-11",
                    "*",
                    "/",
                    "*",
                    "17",
                    "+",
                    "5",
                    "+",
                    "2",
                    "3",
                    "*",
                    "-"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-",
                    "10",
                    "11",
                    "*",
                    "+"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-",
                    "10",
                    "11",
                    "*",
                    "+",
                    "12",
                    "13",
                    "*",
                    "-"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-",
                    "10",
                    "11",
                    "*",
                    "+",
                    "12",
                    "13",
                    "*",
                    "-",
                    "14",
                    "15",
                    "*",
                    "+"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-",
                    "10",
                    "11",
                    "*",
                    "+",
                    "12",
                    "13",
                    "*",
                    "-",
                    "14",
                    "15",
                    "*",
                    "+",
                    "16",
                    "17",
                    "*",
                    "-"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-",
                    "10",
                    "11",
                    "*",
                    "+",
                    "12",
                    "13",
                    "*",
                    "-",
                    "14",
                    "15",
                    "*",
                    "+",
                    "16",
                    "17",
                    "*",
                    "-",
                    "18",
                    "19",
                    "*",
                    "+"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-",
                    "10",
                    "11",
                    "*",
                    "+",
                    "12",
                    "13",
                    "*",
                    "-",
                    "14",
                    "15",
                    "*",
                    "+",
                    "16",
                    "17",
                    "*",
                    "-",
                    "18",
                    "19",
                    "*",
                    "+",
                    "20",
                    "21",
                    "*",
                    "-"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-",
                    "10",
                    "11",
                    "*",
                    "+",
                    "12",
                    "13",
                    "*",
                    "-",
                    "14",
                    "15",
                    "*",
                    "+",
                    "16",
                    "17",
                    "*",
                    "-",
                    "18",
                    "19",
                    "*",
                    "+",
                    "20",
                    "21",
                    "*",
                    "-",
                    "22",
                    "23",
                    "*",
                    "+"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-",
                    "10",
                    "11",
                    "*",
                    "+",
                    "12",
                    "13",
                    "*",
                    "-",
                    "14",
                    "15",
                    "*",
                    "+",
                    "16",
                    "17",
                    "*",
                    "-",
                    "18",
                    "19",
                    "*",
                    "+",
                    "20",
                    "21",
                    "*",
                    "-",
                    "22",
                    "23",
                    "*",
                    "+",
                    "24",
                    "25",
                    "*",
                    "-"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-",
                    "10",
                    "11",
                    "*",
                    "+",
                    "12",
                    "13",
                    "*",
                    "-",
                    "14",
                    "15",
                    "*",
                    "+",
                    "16",
                    "17",
                    "*",
                    "-",
                    "18",
                    "19",
                    "*",
                    "+",
                    "20",
                    "21",
                    "*",
                    "-",
                    "22",
                    "23",
                    "*",
                    "+",
                    "24",
                    "25",
                    "*",
                    "-",
                    "26",
                    "27",
                    "*",
                    "+"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-",
                    "10",
                    "11",
                    "*",
                    "+",
                    "12",
                    "13",
                    "*",
                    "-",
                    "14",
                    "15",
                    "*",
                    "+",
                    "16",
                    "17",
                    "*",
                    "-",
                    "18",
                    "19",
                    "*",
                    "+",
                    "20",
                    "21",
                    "*",
                    "-",
                    "22",
                    "23",
                    "*",
                    "+",
                    "24",
                    "25",
                    "*",
                    "-",
                    "26",
                    "27",
                    "*",
                    "+",
                    "28",
                    "29",
                    "*",
                    "-"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-",
                    "10",
                    "11",
                    "*",
                    "+",
                    "12",
                    "13",
                    "*",
                    "-",
                    "14",
                    "15",
                    "*",
                    "+",
                    "16",
                    "17",
                    "*",
                    "-",
                    "18",
                    "19",
                    "*",
                    "+",
                    "20",
                    "21",
                    "*",
                    "-",
                    "22",
                    "23",
                    "*",
                    "+",
                    "24",
                    "25",
                    "*",
                    "-",
                    "26",
                    "27",
                    "*",
                    "+",
                    "28",
                    "29",
                    "*",
                    "-",
                    "30",
                    "31",
                    "*",
                    "+"
                ]
            ],
            "outputs": [
                9,
                6,
                22,
                17,
                15,
                6,
                15,
                -12,
                -10,
                16,
                7,
                -1,
                11,
                0,
                16,
                -9,
                7,
                -2,
                13,
                -17
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <stack>\n\nint evalRPN(vector<string>& tokens) {\n    stack<int> s;\n    for (const string& token : tokens) {\n        if(token == \"+\" || token == \"-\" || token == \"*\" || token == \"/\") {\n            int b = s.top(); s.pop();\n            int a = s.top(); s.pop();\n            if (token == \"+\") s.push(a + b);\n            else if (token == \"-\") s.push(a - b);\n            else if (token == \"*\") s.push(a * b);\n            else s.push(a / b);\n        } else {\n            s.push(stoi(token));\n        }\n    }\n    return s.top();\n}\n",
            "java": "import java.util.Stack;\n\npublic int evalRPN(String[] tokens) {\n    Stack<Integer> stack = new Stack<>();\n    for (String token : tokens) {\n        if (token.equals(\"+\") || token.equals(\"-\") || token.equals(\"*\") || token.equals(\"/\")) {\n            int b = stack.pop();\n            int a = stack.pop();\n            if (token.equals(\"+\")) stack.push(a + b);\n            else if (token.equals(\"-\")) stack.push(a - b);\n            else if (token.equals(\"*\")) stack.push(a * b);\n            else stack.push(a / b);\n        } else {\n            stack.push(Integer.parseInt(token));\n        }\n    }\n    return stack.pop();\n}\n",
            "python": "def evalRPN(tokens):\n    stack = []\n    for token in tokens:\n        if token in {\"+\", \"-\", \"*\", \"/\"}:\n            b = stack.pop()\n            a = stack.pop()\n            if token == \"+\":\n                stack.append(a + b)\n            elif token == \"-\":\n                stack.append(a - b)\n            elif token == \"*\":\n                stack.append(a * b)\n            else:\n                stack.append(int(a / b))\n        else:\n            stack.append(int(token))\n    return stack[-1]\n",
            "javascript": "function evalRPN(tokens) {\n    const stack = [];\n    for (const token of tokens) {\n        if (token === \"+\" || token === \"-\" || token === \"*\" || token === \"/\") {\n            const b = stack.pop();\n            const a = stack.pop();\n            if (token === \"+\") stack.push(a + b);\n            else if (token === \"-\") stack.push(a - b);\n            else if (token === \"*\") stack.push(a * b);\n            else stack.push(Math.trunc(a / b));\n        } else {\n            stack.push(parseInt(token));\n        }\n    }\n    return stack.pop();\n}\n",
            "explanation": "The algorithm for evaluating the Reverse Polish Notation (RPN) expression is based on the stack data structure. Iterate through the given tokens array, and for each token:\n\n1. If the token is an operator (+, -, *, /), pop the top two elements from the stack, apply the operation, and push the result back onto the stack.\n2. If the token is a number, push it onto the stack.\n\nAfter the loop, the top element on the stack is the final result of the evaluated RPN expression.\n\nNote that in Python and JavaScript, we need to make sure the division result is truncated toward zero using `int(a / b)` and `Math.trunc(a / b)` respectively."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <stack>\n\nint evalRPN(vector<string>& tokens) \n    // Your code here\n}\n",
            "java": "import java.util.Stack;\n\npublic int evalRPN(String[] tokens) \n    // Your code here\n}\n",
            "python": "def evalRPN(tokens):\n    # Your code here\n\n",
            "javascript": "function evalRPN(tokens) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <stack>\n#include <iostream>\n\nint main() {\n    vector<string> tokens = $args;\n    int result = evalRPN(tokens);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    tokens = $args\n    result = evalRPN(tokens)\n    print(result)"
        }
    },
    "151": {
        "title": "Reverse Words in a String",
        "description": "Given an input string `s`, reverse the order of the words. A word is defined as a sequence of non-space characters. The words in `s` will be separated by at least one space. Return a string of the words in reverse order concatenated by a single space. Note that `s` may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.",
        "example": "Example:\n\nInput: s = \"the sky is blue \"\nOutput: \"blue is sky the\"\n\nInput: s = \"  hello world   \"\nOutput: \"world hello\"\nExplanation: Your reversed string should not contain leading or trailing spaces.\n\nInput: s = \"a good   example \"\nOutput: \"example good a\"\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string.",
        "level": "Easy",
        "tags": [
            "string"
        ],
        "test_cases": {
            "inputs": [
                "\"the sky is blue \"",
                "\"  hello world   \"",
                "\"a good   example \"",
                "\"coding is fun\"",
                "\"  reverse words  \"",
                "\"  multiple   spaces  \"",
                "\"  single word  \"",
                "\"  \"",
                "\"a\"",
                "\"a b c d e f g h i j k l m n o p q r s t u v w x y z\"",
                "\"  a b c d e f g h i j k l m n o p q r s t u v w x y z  \""
            ],
            "outputs": [
                "\"blue is sky the\"",
                "\"world hello\"",
                "\"example good a\"",
                "\"fun is coding\"",
                "\"words reverse\"",
                "\"spaces multiple\"",
                "\"word single\"",
                "\"\"",
                "\"a\"",
                "\"z y x w v u t s r q p o n m l k j i h g f e d c b a\"",
                "\"z y x w v u t s r q p o n m l k j i h g f e d c b a\""
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nstd::string reverseWords(std::string s) {\n    std::stringstream ss(s);\n    std::vector<std::string> words;\n    std::string temp;\n\n    while (ss >> temp) {\n        words.push_back(temp);\n    }\n\n    std::reverse(words.begin(), words.end());\n\n    std::string result;\n    for (size_t i = 0; i < words.size(); ++i) {\n        result += words[i] + (i < words.size() - 1 ? \" \" : \"\");\n    }\n\n    return result;\n}\n",
            "java": "import java.util.*;\n\npublic String reverseWords(String s) {\n    String[] words = s.trim().split(\"\\\\s+\");\n    Collections.reverse(Arrays.asList(words));\n    return String.join(\" \", words);\n}\n",
            "python": "def reverseWords(s):\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)\n",
            "javascript": "function reverseWords(s) {\n    return s.trim().split(/\\s+/).reverse().join(' ');\n}\n",
            "explanation": "The algorithm to reverse the order of the words is as follows:\n\n1. First, split the input string using spaces. In C++, we use `stringstream` and a while loop to read words, while in Java and JavaScript, we use `split` with regex to split the string based on one or more spaces. In Python, we can simply use `split()` since it splits on whitespace by default and ignores leading and trailing spaces.\n\n2. Reverse the array of words. In C++, we use the `reverse` function from the `algorithm` library. In Java, we can use `Collections.reverse()` method. In Python, we use list `reverse()` method. In JavaScript, we use the `reverse()` method on the array.\n\n3. Join the reversed array of words into a single string with a space delimiter. In C++, we concatenate words with a space but avoid adding an extra space at the end. In Java, we use `String.join()`, in Python, use `join()` on the delimiter string, and in JavaScript, use `join()` on the array."
        },
        "structure": {
            "c++": "#include <string>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nstd::string reverseWords(std::string s) \n    // Your code here\n}\n",
            "java": "import java.util.*;\n\npublic String reverseWords(String s) \n    // Your code here\n}\n",
            "python": "def reverseWords(s):\n    # Your code here\n\n",
            "javascript": "function reverseWords(s) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::string s = $args;\n    std::string result = reverseWords(s);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public String reverseWords(String s) {\n    String[] words = s.trim().split(\"\\\\s+\");\n    Collections.reverse(Arrays.asList(words));\n    return String.join(\" \", words);\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args[0]\n    result = reverseWords(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = reverseWords(s);\n    console.log(result);\n}"
        }
    },
    "152": {
        "title": "Largest Subarray Product",
        "description": "Given an integer array `nums`, find a subarray that has the largest product, and return the product. The task is to find the maximum product of a subarray in the given array.",
        "example": "Example:\n\nInput: nums = [2,3,-2,4]\nOutput: 6\nExplanation: The subarray [2,3] has the largest product 6.\n\nInput: nums = [-2,0,-1]\nOutput: 0\nExplanation: The result cannot be 2, because the subarray [-2,-1] is not a valid subarray.",
        "level": "Medium",
        "tags": [
            "array",
            "subarray",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    3,
                    -2,
                    4
                ],
                [
                    -2,
                    0,
                    -1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1,
                    -1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1,
                    -1,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0
                ]
            ],
            "outputs": [
                6,
                0,
                120,
                120,
                0,
                120,
                120,
                120,
                120,
                120,
                120,
                120,
                120,
                120,
                120,
                120,
                120,
                120,
                120,
                120
            ]
        },
        "sample_code": {
            "c++": "int maxProduct(vector<int>& nums) {\n    int max_so_far = nums[0];\n    int min_so_far = nums[0];\n    int result = nums[0];\n    \n    for (int i = 1; i < nums.size(); i++) {\n        if (nums[i] < 0)\n            swap(max_so_far, min_so_far);\n        \n        max_so_far = max(nums[i], max_so_far * nums[i]);\n        min_so_far = min(nums[i], min_so_far * nums[i]);\n        result = max(result, max_so_far);\n    }\n    return result;\n}\n\n",
            "java": "public int maxProduct(int[] nums) {\n    int max_so_far = nums[0];\n    int min_so_far = nums[0];\n    int result = nums[0];\n    \n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] < 0) {\n            int temp = max_so_far;\n            max_so_far = min_so_far;\n            min_so_far = temp;\n        }\n        \n        max_so_far = Math.max(nums[i], max_so_far * nums[i]);\n        min_so_far = Math.min(nums[i], min_so_far * nums[i]);\n        result = Math.max(result, max_so_far);\n    }\n    return result;\n}\n\n",
            "python": "def maxProduct(nums):\n    max_so_far = min_so_far = result = nums[0]\n    \n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_so_far, min_so_far = min_so_far, max_so_far\n        \n        max_so_far = max(nums[i], max_so_far * nums[i])\n        min_so_far = min(nums[i], min_so_far * nums[i])\n        result = max(result, max_so_far)\n    \n    return result\n\n",
            "javascript": "function maxProduct(nums) {\n    let max_so_far = nums[0];\n    let min_so_far = nums[0];\n    let result = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] < 0) {\n            [max_so_far, min_so_far] = [min_so_far, max_so_far];\n        }\n        \n        max_so_far = Math.max(nums[i], max_so_far * nums[i]);\n        min_so_far = Math.min(nums[i], min_so_far * nums[i]);\n        result = Math.max(result, max_so_far);\n    }\n    return result;\n}\n\n",
            "explanation": "The algorithm maintains the maximum and minimum product subarray ending at the current position. For each position, it checks if the current element is negative. If it is, it swaps the maximum and minimum product subarray, since multiplying by a negative number reverses their order.\n\nAfter the swap, it calculates the maximum and minimum product subarray ending at the current position by considering the current element and the product of the maximum and minimum product subarray ending at the previous position, multiplied by the current element. It updates the result as the maximum of the result and the maximum product subarray ending at the current position.\n\nThis process continues for all elements of the array, and the result is returned."
        },
        "structure": {
            "c++": "int maxProduct(vector<int>& nums) \n    // Your code here\n}\n\n",
            "java": "public int maxProduct(int[] nums) \n    // Your code here\n}\n\n",
            "python": "def maxProduct(nums):\n    # Your code here\n\n",
            "javascript": "function maxProduct(nums) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int maxProduct(vector<int>& nums) {\n    int max_so_far = nums[0];\n    int min_so_far = nums[0];\n    int result = nums[0];\n    \n    for (int i = 1; i < nums.size(); i++) {\n        if (nums[i] < 0)\n            swap(max_so_far, min_so_far);\n        \n        max_so_far = max(nums[i], max_so_far * nums[i]);\n        min_so_far = min(nums[i], min_so_far * nums[i]);\n        result = max(result, max_so_far);\n    }\n    return result;\n}",
            "java": "public int maxProduct(int[] nums) {\n    int max_so_far = nums[0];\n    int min_so_far = nums[0];\n    int result = nums[0];\n    \n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] < 0) {\n            int temp = max_so_far;\n            max_so_far = min_so_far;\n            min_so_far = temp;\n        }\n        \n        max_so_far = Math.max(nums[i], max_so_far * nums[i]);\n        min_so_far = Math.min(nums[i], min_so_far * nums[i]);\n        result = Math.max(result, max_so_far);\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = maxProduct(nums)\n    print(result)"
        }
    },
    "153": {
        "title": "Minimum Element in Rotated Sorted Array",
        "description": "Given a sorted rotated array `nums` of unique elements, find the minimum element in the array. The array is rotated between `1` and `n` times. Implement an algorithm that runs in `O(log n)` time complexity.",
        "example": "Example:\n\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.",
        "level": "Medium",
        "tags": [
            "Array",
            "Binary Search"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    4,
                    5,
                    1,
                    2
                ],
                [
                    4,
                    5,
                    6,
                    7,
                    0,
                    1,
                    2
                ],
                [
                    11,
                    13,
                    15,
                    17
                ],
                [
                    1
                ],
                [
                    2,
                    1
                ],
                [
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4
                ],
                [
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3
                ],
                [
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4
                ],
                [
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1
                ],
                [
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6
                ],
                [
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2
                ],
                [
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1
                ]
            ],
            "outputs": [
                1,
                0,
                11,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1
            ]
        },
        "sample_code": {
            "c++": "```c++\nint findMin(vector<int>& nums) {\n    int left = 0, right = nums.size() - 1;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n}\n",
            "java": "public int findMin(int[] nums) {\n    int left = 0, right = nums.length - 1;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n}\n",
            "python": "def find_min(nums):\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        mid = left + (right - left) // 2\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n    return nums[left]\n",
            "javascript": "function findMin(nums) {\n    let left = 0, right = nums.length - 1;\n\n    while (left < right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n}\n",
            "explanation": "The algorithm uses a binary search approach to find the minimum element in the sorted rotated array. Initially, pointers `left` and `right` are set to the start and end of the array. The midpoint `mid` is calculated as the average of `left` and `right`. The main idea is that whenever `nums[mid]` is greater than `nums[right]`, the minimum element must be in the right half of the array; otherwise, we search in the left half. This ensures that the algorithm runs in O(log n) time, as the search space is reduced by half each iteration. When `left` and `right` meet, the minimum element is found at `left`."
        },
        "structure": {
            "c++": "```c++\nint findMin(vector<int>& nums) \n    // Your code here\n}\n",
            "java": "public int findMin(int[] nums) \n    // Your code here\n}\n",
            "python": "def find_min(nums):\n    # Your code here\n\n",
            "javascript": "function findMin(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> nums = $args;\n    int result = findMin(nums);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int findMin(int[] nums) {\n    int left = 0, right = nums.length - 1;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = find_min(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = findMin(nums);\n    console.log(result);\n}"
        }
    },
    "159": {
        "title": "Longest Substring with At Most Two Distinct Characters",
        "description": "Given a string `s`, find the length of the longest substring that contains at most two distinct characters.",
        "example": "Example:\n\nInput: s = \"eceba\"\nOutput: 3\nExplanation: The longest substring with at most two distinct characters is \"ece\" with a length of 3.",
        "level": "Medium",
        "tags": [
            "string",
            "sliding window",
            "hashmap"
        ],
        "test_cases": {
            "inputs": [
                "\"eceba\"",
                "\"ccaabbb\"",
                "\"abcabcabc\"",
                "\"aabbbccdd\"",
                "\"aaaaaa\"",
                "\"abababab\"",
                "\"\"",
                "\"a\"",
                "\"aa\"",
                "\"aaa\"",
                "\"aaaa\"",
                "\"aaaaa\"",
                "\"aaaaaa\"",
                "\"aaaaaaa\"",
                "\"aaaaaaaa\"",
                "\"aaaaaaaaa\"",
                "\"aaaaaaaaaa\"",
                "\"aaaaaaaaaaa\"",
                "\"aaaaaaaaaaaa\"",
                "\"aaaaaaaaaaaaa\"",
                "\"aaaaaaaaaaaaaa\""
            ],
            "outputs": [
                "3",
                "5",
                "9",
                "6",
                "6",
                "8",
                "0",
                "1",
                "2",
                "3",
                "4",
                "5",
                "6",
                "7",
                "8",
                "9",
                "10",
                "11",
                "12",
                "13"
            ]
        },
        "sample_code": {
            "c++": "int lengthOfLongestSubstringTwoDistinct(string s) {\n    int l = 0, r = 0, max_len = 0, cur_len = 0;\n    unordered_map<char, int> char_count;\n\n    while (r < s.length()) {\n        char_count[s[r]]++;\n        if (char_count.size() <= 2) {\n            cur_len++;\n        } else {\n            while (char_count.size() > 2 && l <= r) {\n                char_count[s[l]]--;\n                if (char_count[s[l]] == 0) {\n                    char_count.erase(s[l]);\n                }\n                l++;\n                cur_len--;\n            }\n            cur_len++;\n        }\n        max_len = max(max_len, cur_len);\n        r++;\n    }\n    return max_len;\n}\n",
            "java": "public int lengthOfLongestSubstringTwoDistinct(String s) {\n    int l = 0, r = 0, max_len = 0, cur_len = 0;\n    HashMap<Character, Integer> char_count = new HashMap<>();\n\n    while (r < s.length()) {\n        char_count.put(s.charAt(r), char_count.getOrDefault(s.charAt(r), 0) + 1);\n        if (char_count.size() <= 2) {\n            cur_len++;\n        } else {\n            while (char_count.size() > 2 && l <= r) {\n                char_count.put(s.charAt(l), char_count.get(s.charAt(l)) - 1);\n                if (char_count.get(s.charAt(l)) == 0) {\n                    char_count.remove(s.charAt(l));\n                }\n                l++;\n                cur_len--;\n            }\n            cur_len++;\n        }\n        max_len = Math.max(max_len, cur_len);\n        r++;\n    }\n    return max_len;\n}\n",
            "python": "def lengthOfLongestSubstringTwoDistinct(s: str) -> int:\n    l, r, max_len, cur_len = 0, 0, 0, 0\n    char_count = {}\n\n    while r < len(s):\n        if s[r] in char_count:\n            char_count[s[r]] += 1\n        else:\n            char_count[s[r]] = 1\n        if len(char_count) <= 2:\n            cur_len += 1\n        else:\n            while len(char_count) > 2 and l <= r:\n                char_count[s[l]] -= 1\n                if char_count[s[l]] == 0:\n                    del char_count[s[l]]\n                l += 1\n                cur_len -= 1\n            cur_len += 1\n        max_len = max(max_len, cur_len)\n        r += 1\n    return max_len\n",
            "javascript": "function lengthOfLongestSubstringTwoDistinct(s) {\n    let l = 0, r = 0, max_len = 0, cur_len = 0;\n    const char_count = new Map();\n\n    while (r < s.length) {\n        char_count.set(s[r], (char_count.get(s[r]) || 0) + 1);\n        if (char_count.size <= 2) {\n            cur_len++;\n        } else {\n            while (char_count.size > 2 && l <= r) {\n                char_count.set(s[l], char_count.get(s[l]) - 1);\n                if (char_count.get(s[l]) === 0) {\n                    char_count.delete(s[l]);\n                }\n                l++;\n                cur_len--;\n            }\n            cur_len++;\n        }\n        max_len = Math.max(max_len, cur_len);\n        r++;\n    }\n    return max_len;\n}\n",
            "explanation": "The algorithm implements a sliding window approach. We maintain two pointers `l` and `r` representing the left and right ends of the current substring. We also maintain a hash map `char_count` to store the counts of distinct characters in the current substring.\n\nWe iterate through the string with pointer `r`. For each character, we increment its count in the hash map. If we have two or fewer distinct characters in the current substring, we update the current length `cur_len`. If we have more than two distinct characters, we move the pointer `l` to the right, decrementing the count of the character at `l` in the hash map, and removing it if its count becomes zero. We update `cur_len` accordingly in the process.\n\nAt each step, we update the maximum length `max_len` with the maximum of `max_len` and `cur_len`. We return `max_len` at the end."
        },
        "structure": {
            "c++": "int lengthOfLongestSubstringTwoDistinct(string s) \n    // Your code here\n}\n",
            "java": "public int lengthOfLongestSubstringTwoDistinct(String s) \n    // Your code here\n}\n",
            "python": "def lengthOfLongestSubstringTwoDistinct(s: str) -> int:\n    # Your code here\n\n",
            "javascript": "function lengthOfLongestSubstringTwoDistinct(s) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int lengthOfLongestSubstringTwoDistinct(string s) {\n    int l = 0, r = 0, max_len = 0, cur_len = 0;\n    unordered_map<char, int> char_count;\n\n    while (r < s.length()) {\n        char_count[s[r]]++;\n        if (char_count.size() <= 2) {\n            cur_len++;\n        } else {\n            while (char_count.size() > 2 && l <= r) {\n                char_count[s[l]]--;\n                if (char_count[s[l]] == 0) {\n                    char_count.erase(s[l]);\n                }\n                l++;\n                cur_len--;\n            }\n            cur_len++;\n        }\n        max_len = max(max_len, cur_len);\n        r++;\n    }\n    return max_len;\n}",
            "java": "public int lengthOfLongestSubstringTwoDistinct(String s) {\n    int l = 0, r = 0, max_len = 0, cur_len = 0;\n    HashMap<Character, Integer> char_count = new HashMap<>();\n\n    while (r < s.length()) {\n        char_count.put(s.charAt(r), char_count.getOrDefault(s.charAt(r), 0) + 1);\n        if (char_count.size() <= 2) {\n            cur_len++;\n        } else {\n            while (char_count.size() > 2 && l <= r) {\n                char_count.put(s.charAt(l), char_count.get(s.charAt(l)) - 1);\n                if (char_count.get(s.charAt(l)) == 0) {\n                    char_count.remove(s.charAt(l));\n                }\n                l++;\n                cur_len--;\n            }\n            cur_len++;\n        }\n        max_len = Math.max(max_len, cur_len);\n        r++;\n    }\n    return max_len;\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = lengthOfLongestSubstringTwoDistinct(s)\n    print(result)",
            "javascript": "function lengthOfLongestSubstringTwoDistinct(s) {\n    const input = $args;\n    let l = 0, r = 0, max_len = 0, cur_len = 0;\n    const char_count = new Map();\n\n    while (r < input.length) {\n        char_count.set(input[r], (char_count.get(input[r]) || 0) + 1);\n        if (char_count.size <= 2) {\n            cur_len++;\n        } else {\n            while (char_count.size > 2 && l <= r) {\n                char_count.set(input[l], char_count.get(input[l]) - 1);\n                if (char_count.get(input[l]) === 0) {\n                    char_count.delete(input[l]);\n                }\n                l++;\n                cur_len--;\n            }\n            cur_len++;\n        }\n        max_len = Math.max(max_len, cur_len);\n        r++;\n    }\n    return max_len;\n}"
        }
    },
    "161": {
        "title": "One Edit Distance",
        "description": "Given two strings `s` and `t`, return `true` if they are both one edit distance apart, otherwise return `false`. A string `s` is said to be one distance apart from a string `t` if you can:\n\n- Insert **exactly one** character into `s` to get `t`.\n- Delete **exactly one** character from `s` to get `t`.\n- Replace **exactly one** character of `s` with **a different character** to get `t`.",
        "example": "Example:\n\nInput: s = \"ab\", t = \"acb\"\nOutput: true\nExplanation: We can insert 'c' into s to get t.",
        "level": "Easy",
        "tags": [
            "string",
            "editing"
        ],
        "test_cases": {
            "inputs": [
                [
                    "ab",
                    "acb"
                ],
                [
                    "",
                    ""
                ],
                [
                    "abc",
                    "ab"
                ],
                [
                    "abc",
                    "abcd"
                ],
                [
                    "abc",
                    "abdc"
                ],
                [
                    "abc",
                    "ac"
                ],
                [
                    "abc",
                    "bc"
                ],
                [
                    "abc",
                    "abec"
                ],
                [
                    "abc",
                    "abf"
                ],
                [
                    "abc",
                    "abg"
                ],
                [
                    "abc",
                    "abhc"
                ],
                [
                    "abc",
                    "abij"
                ],
                [
                    "abc",
                    "abjk"
                ],
                [
                    "abc",
                    "abkl"
                ],
                [
                    "abc",
                    "ablm"
                ],
                [
                    "abc",
                    "abmn"
                ],
                [
                    "abc",
                    "abno"
                ],
                [
                    "abc",
                    "abop"
                ],
                [
                    "abc",
                    "abpq"
                ],
                [
                    "abc",
                    "abqr"
                ]
            ],
            "outputs": [
                true,
                false,
                false,
                false,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "bool isOneEditDistance(string s, string t) {\n    int m = s.length(), n = t.length();\n    if (m > n) {\n        return isOneEditDistance(t, s);\n    }\n    if (n - m > 1) {\n        return false;\n    }\n    bool flag = false;\n    for (int i = 0; i < m; ++i) {\n      if (s[i] != t[i]) {\n          if (m < n) {\n              return s.substr(i) == t.substr(i + 1);\n          } else {\n              return s.substr(i + 1) == t.substr(i + 1);\n          }\n      }\n    }\n    return m + 1 == n;\n}\n",
            "java": "public boolean isOneEditDistance(String s, String t) {\n    int m = s.length();\n    int n = t.length();\n    if (m > n) {\n        return isOneEditDistance(t, s);\n    }\n    if (n - m > 1) {\n        return false;\n    }\n    for (int i = 0; i < m; ++i) {\n        if (s.charAt(i) != t.charAt(i)) {\n            if (m < n) {\n                return s.substring(i).equals(t.substring(i + 1));\n            } else {\n                return s.substring(i + 1).equals(t.substring(i + 1));\n            }\n        }\n    }\n    return m + 1 == n;\n}\n",
            "python": "def isOneEditDistance(s: str, t: str) -> bool:\n    m, n = len(s), len(t)\n    if m > n:\n        return isOneEditDistance(t, s)\n    if n - m > 1:\n        return False\n    for i in range(m):\n        if s[i] != t[i]:\n            return s[i + (m < n):] == t[i + 1:]\n    return m + 1 == n\n\n",
            "javascript": "function isOneEditDistance(s, t) {\n    let m = s.length, n = t.length;\n    if (m > n) {\n        return isOneEditDistance(t, s);\n    }\n    if (n - m > 1) {\n        return false;\n    }\n    for (let i = 0; i < m; ++i) {\n        if (s[i] !== t[i]) {\n            if (m < n) {\n                return s.slice(i) === t.slice(i + 1);\n            } else {\n                return s.slice(i + 1) === t.slice(i + 1);\n            }\n        }\n    }\n    return m + 1 === n;\n}\n\n",
            "explanation": "The algorithm first checks if the length of string `s` is greater than the length of string `t`. If true, it swaps the two strings and continues the checks. Next, the algorithm checks if the length difference between the strings is greater than 1, returning `false` if so since it's not possible to meet the one edit distance criteria in that case.\n\nThe algorithm iterates through the characters of the two strings. If it encounters a mismatched character it checks if the insertion or deletion of a character can yield the other string, and if not, it checks if the replacement of the mismatched character in string `s` can yield string `t`. If it iterates through both strings without finding a mismatch, it returns `true` if the length difference of the strings is 1 to ensure only one character has been inserted. Otherwise, it returns `false`."
        },
        "structure": {
            "c++": "bool isOneEditDistance(string s, string t) \n    // Your code here\n}\n",
            "java": "public boolean isOneEditDistance(String s, String t) \n    // Your code here\n}\n",
            "python": "def isOneEditDistance(s: str, t: str) -> bool:\n    # Your code here\n\n",
            "javascript": "function isOneEditDistance(s, t) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "bool isOneEditDistance(string s, string t) {\n    int m = s.length(), n = t.length();\n    if (m > n) {\n        return isOneEditDistance(t, s);\n    }\n    if (n - m > 1) {\n        return false;\n    }\n    bool flag = false;\n    for (int i = 0; i < m; ++i) {\n      if (s[i] != t[i]) {\n          if (m < n) {\n              return s.substr(i) == t.substr(i + 1);\n          } else {\n              return s.substr(i + 1) == t.substr(i + 1);\n          }\n      }\n    }\n    return m + 1 == n;\n}\n\nint main() {\n    string s = $args;\n    string t = $args;\n    bool result = isOneEditDistance(s, t);\n    cout << boolalpha << result << endl;\n    return 0;\n}",
            "java": "public boolean isOneEditDistance(String s, String t) {\n    int m = s.length();\n    int n = t.length();\n    if (m > n) {\n        return isOneEditDistance(t, s);\n    }\n    if (n - m > 1) {\n        return false;\n    }\n    for (int i = 0; i < m; ++i) {\n        if (s.charAt(i) != t.charAt(i)) {\n            if (m < n) {\n                return s.substring(i).equals(t.substring(i + 1));\n            } else {\n                return s.substring(i + 1).equals(t.substring(i + 1));\n            }\n        }\n    }\n    return m + 1 == n;\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args[0]\n    t = $args[1]\n    result = isOneEditDistance(s, t)\n    print(result)",
            "javascript": "function main() {\n    const s = $args[0];\n    const t = $args[1];\n    const result = isOneEditDistance(s, t);\n    console.log(result);\n}"
        }
    },
    "162": {
        "title": "Peak Element",
        "description": "A peak element is an element that is strictly greater than its neighbors. Given a 0-indexed integer array nums, find a peak element and return its index. If the array contains multiple peaks, return the index to any of the peaks. You may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Write an algorithm that runs in O(log n) time.",
        "example": "Example 1:\n\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.\n\nExample 2:\n\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.",
        "level": "Medium",
        "tags": [
            "Array",
            "Binary Search"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3,
                    1
                ],
                [
                    1,
                    2,
                    1,
                    3,
                    5,
                    6,
                    4
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1
                ],
                [
                    1,
                    3,
                    2,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    10
                ]
            ],
            "outputs": [
                2,
                5,
                4,
                0,
                0,
                1,
                8,
                0,
                8,
                9
            ]
        },
        "sample_code": {
            "c++": "int findPeakElement(vector<int>& nums) {\n    int left = 0, right = nums.size() - 1;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < nums[mid + 1]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n",
            "java": "public int findPeakElement(int[] nums) {\n    int left = 0, right = nums.length - 1;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < nums[mid + 1]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n",
            "python": "def findPeakElement(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = left + (right - left) // 2\n        if nums[mid] < nums[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n",
            "javascript": "function findPeakElement(nums) {\n    let left = 0, right = nums.length - 1;\n    while (left < right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] < nums[mid + 1]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n",
            "explanation": "For this problem, we can use the binary search. Instead of comparing the mid-element to the target value, we compare it with its neighbors. Based on the comparison, we adjust the left and right pointers accordingly:\n\n1. Initialize left and right pointer, `left = 0` and `right = nums.length - 1`.\n2. While `left < right`, do the following:\n   a. Calculate the mid index, `mid = left + (right - left) // 2`.\n   b. If `nums[mid] < nums[mid + 1]`, move the left pointer to `mid + 1`.\n   c. Else, move the right pointer to the `mid`.\n3. When `left >= right`, the peak index is found, so return `left`.\n\nSince we use a binary search, the algorithm runs in O(log n) time."
        },
        "structure": {
            "c++": "int findPeakElement(vector<int>& nums) \n    // Your code here\n}\n",
            "java": "public int findPeakElement(int[] nums) \n    // Your code here\n}\n",
            "python": "def findPeakElement(nums):\n    # Your code here\n\n",
            "javascript": "function findPeakElement(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> nums = $args;\n    int result = findPeakElement(nums);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = findPeakElement(nums)\n    print(result)"
        }
    },
    "164": {
        "title": "Maximum Successive Difference",
        "description": "Given an integer array `nums`, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0. You must write an algorithm that runs in linear time and uses linear extra space.",
        "example": "Example:\n\nInput: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    6,
                    9,
                    1
                ],
                [
                    10
                ],
                [
                    5,
                    5,
                    5,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    100,
                    200,
                    300,
                    400,
                    500
                ],
                [
                    1,
                    100,
                    1000,
                    10000
                ],
                [
                    5,
                    10,
                    15,
                    20,
                    25,
                    30,
                    35,
                    40,
                    45,
                    50
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10,
                    12,
                    14,
                    16,
                    18,
                    20
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9,
                    11,
                    13,
                    15,
                    17,
                    19
                ]
            ],
            "outputs": [
                3,
                0,
                0,
                1,
                1,
                100,
                900,
                5,
                2,
                2
            ]
        },
        "sample_code": {
            "c++": "int maximumGap(vector<int>& nums) {\n    if (nums.size() < 2) return 0;\n    \n    int min_val = *min_element(nums.begin(), nums.end());\n    int max_val = *max_element(nums.begin(), nums.end());\n    int len = nums.size();\n    int bucket_size = max(1, (max_val - min_val) / (len - 1));\n    int bucket_num = (max_val - min_val) / bucket_size + 1;\n    vector<pair<int, int>> buckets(bucket_num, {INT_MAX, INT_MIN});\n\n    for (int num : nums) {\n        int idx = (num - min_val) / bucket_size;\n        buckets[idx].first = min(buckets[idx].first, num);\n        buckets[idx].second = max(buckets[idx].second, num);\n    }\n\n    int max_gap = 0, prev_max = min_val;\n    for (auto& bucket : buckets) {\n        if (bucket.first == INT_MAX) continue;\n        max_gap = max(max_gap, bucket.first - prev_max);\n        prev_max = bucket.second;\n    }\n    return max_gap;\n}\n",
            "java": "public int maximumGap(int[] nums) {\n    if (nums.length < 2) return 0;\n\n    int min_val = Arrays.stream(nums).min().getAsInt();\n    int max_val = Arrays.stream(nums).max().getAsInt();\n    int len = nums.length;\n    int bucket_size = Math.max(1, (max_val - min_val) / (len - 1));\n    int bucket_num = (max_val - min_val) / bucket_size + 1;\n    int[][] buckets = new int[bucket_num][2];\n    for (int i = 0; i < bucket_num; i++) {\n        buckets[i] = new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE};\n    }\n\n    for (int num : nums) {\n        int idx = (num - min_val) / bucket_size;\n        buckets[idx][0] = Math.min(buckets[idx][0], num);\n        buckets[idx][1] = Math.max(buckets[idx][1], num);\n    }\n\n    int max_gap = 0, prev_max = min_val;\n    for (int[] bucket : buckets) {\n        if (bucket[0] == Integer.MAX_VALUE) continue;\n        max_gap = Math.max(max_gap, bucket[0] - prev_max);\n        prev_max = bucket[1];\n    }\n    return max_gap;\n}\n",
            "python": "def maximumGap(nums):\n    if len(nums) < 2:\n        return 0\n\n    min_val = min(nums)\n    max_val = max(nums)\n    length = len(nums)\n    bucket_size = max(1, (max_val - min_val) // (length - 1))\n    bucket_num = (max_val - min_val) // bucket_size + 1\n    buckets = [[float(\"inf\"), float(\"-inf\")] for _ in range(bucket_num)]\n\n    for num in nums:\n        idx = (num - min_val) // bucket_size\n        buckets[idx][0] = min(buckets[idx][0], num)\n        buckets[idx][1] = max(buckets[idx][1], num)\n\n    max_gap = 0\n    prev_max = min_val\n    for bucket in buckets:\n        if bucket[0] == float(\"inf\"):\n            continue\n        max_gap = max(max_gap, bucket[0] - prev_max)\n        prev_max = bucket[1]\n    return max_gap\n",
            "javascript": "function maximumGap(nums) {\n    if (nums.length < 2) return 0;\n\n    let min_val = Math.min(...nums);\n    let max_val = Math.max(...nums);\n    let len = nums.length;\n    let bucket_size = Math.max(1, Math.floor((max_val - min_val) / (len - 1)));\n    let bucket_num = Math.floor((max_val - min_val) / bucket_size) + 1;\n    let buckets = Array.from({ length: bucket_num }, () => [Infinity, -Infinity]);\n\n    for (let num of nums) {\n        let idx = Math.floor((num - min_val) / bucket_size);\n        buckets[idx][0] = Math.min(buckets[idx][0], num);\n        buckets[idx][1] = Math.max(buckets[idx][1], num);\n    }\n\n    let max_gap = 0, prev_max = min_val;\n    for (let bucket of buckets) {\n        if (bucket[0] === Infinity) continue;\n        max_gap = Math.max(max_gap, bucket[0] - prev_max);\n        prev_max = bucket[1];\n    }\n    return max_gap;\n}\n",
            "explanation": "The algorithm first finds the minimum and maximum values of the input array `nums`. Then it calculates the ideal bucket size by dividing the difference between the maximum and minimum values by the length of the array minus one. The algorithm then initializes an array of buckets, where each bucket contains the minimum and maximum values of its elements.\n\nNext, the algorithm updates the minimum and maximum values for each bucket appropriately by iterating through the input array. Finally, the algorithm calculates the maximum gap by finding the difference between the minimum value of the current bucket and the maximum value of the previous non-empty bucket, and updating the maximum gap value accordingly.\n\nThis algorithm runs in linear time, because it iterates through the input array once to fill the buckets, and then it iterates through the buckets once to compute the maximum gap. It also uses linear extra space, as the number of buckets is proportional to the length of the input array."
        },
        "structure": {
            "c++": "int maximumGap(vector<int>& nums) \n    // Your code here\n}\n",
            "java": "public int maximumGap(int[] nums) \n    // Your code here\n}\n",
            "python": "def maximumGap(nums):\n    # Your code here\n\n",
            "javascript": "function maximumGap(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int maximumGap(vector<int>& nums) {\n    if (nums.size() < 2) return 0;\n    \n    int min_val = *min_element(nums.begin(), nums.end());\n    int max_val = *max_element(nums.begin(), nums.end());\n    int len = nums.size();\n    int bucket_size = max(1, (max_val - min_val) / (len - 1));\n    int bucket_num = (max_val - min_val) / bucket_size + 1;\n    vector<pair<int, int>> buckets(bucket_num, {INT_MAX, INT_MIN});\n\n    for (int num : nums) {\n        int idx = (num - min_val) / bucket_size;\n        buckets[idx].first = min(buckets[idx].first, num);\n        buckets[idx].second = max(buckets[idx].second, num);\n    }\n\n    int max_gap = 0, prev_max = min_val;\n    for (auto& bucket : buckets) {\n        if (bucket.first == INT_MAX) continue;\n        max_gap = max(max_gap, bucket.first - prev_max);\n        prev_max = bucket.second;\n    }\n    return max_gap;\n}",
            "java": "public int maximumGap(int[] nums) {\n    if (nums.length < 2) return 0;\n\n    int min_val = Arrays.stream(nums).min().getAsInt();\n    int max_val = Arrays.stream(nums).max().getAsInt();\n    int len = nums.length;\n    int bucket_size = Math.max(1, (max_val - min_val) / (len - 1));\n    int bucket_num = (max_val - min_val) / bucket_size + 1;\n    int[][] buckets = new int[bucket_num][2];\n    for (int i = 0; i < bucket_num; i++) {\n        buckets[i] = new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE};\n    }\n\n    for (int num : nums) {\n        int idx = (num - min_val) / bucket_size;\n        buckets[idx][0] = Math.min(buckets[idx][0], num);\n        buckets[idx][1] = Math.max(buckets[idx][1], num);\n    }\n\n    int max_gap = 0, prev_max = min_val;\n    for (int[] bucket : buckets) {\n        if (bucket[0] == Integer.MAX_VALUE) continue;\n        max_gap = Math.max(max_gap, bucket[0] - prev_max);\n        prev_max = bucket[1];\n    }\n    return max_gap;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = maximumGap(nums)\n    print(result)",
            "javascript": "function maximumGap(nums) {\n    if (nums.length < 2) return 0;\n\n    let min_val = Math.min(...nums);\n    let max_val = Math.max(...nums);\n    let len = nums.length;\n    let bucket_size = Math.max(1, Math.floor((max_val - min_val) / (len - 1)));\n    let bucket_num = Math.floor((max_val - min_val) / bucket_size) + 1;\n    let buckets = Array.from({ length: bucket_num }, () => [Infinity, -Infinity]);\n\n    for (let num of nums) {\n        let idx = Math.floor((num - min_val) / bucket_size);\n        buckets[idx][0] = Math.min(buckets[idx][0], num);\n        buckets[idx][1] = Math.max(buckets[idx][1], num);\n    }\n\n    let max_gap = 0, prev_max = min_val;\n    for (let bucket of buckets) {\n        if (bucket[0] === Infinity) continue;\n        max_gap = Math.max(max_gap, bucket[0] - prev_max);\n        prev_max = bucket[1];\n    }\n    return max_gap;\n}"
        }
    },
    "165": {
        "title": "Compare Version Numbers",
        "description": "Given two version numbers, `version1` and `version2`, compare them. Version numbers consist of **one or more revisions** joined by a dot `'.'`. Each revision consists of **digits** and may contain leading **zeros**. Every revision contains **at least one character**. Revisions are **0-indexed from left to right**, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example `2.5.33` and `0.1` are valid version numbers. To compare version numbers, compare their revisions in **left-to-right order**. Revisions are compared using their **integer value ignoring any leading zeros**. This means that revisions `1` and `001` are considered **equal**. If a version number does not specify a revision at an index, then **treat the revision as `0`**. For example, version `1.0` is less than version `1.1` because their revision 0s are the same, but their revision 1s are `0` and `1` respectively, and `0 < 1`. Return the following: If `version1 < version2`, return `-1`. If `version1 > version2`, return `1`. Otherwise, return `0`.",
        "example": "Example:\n\nInput: version1 = \"1.01\", version2 = \"1.001\"\nOutput: 0\nExplanation: Ignoring leading zeroes, both \"01\" and \"001\" represent the same integer \"1\".",
        "level": "Easy",
        "tags": [
            "string",
            "parsing"
        ],
        "test_cases": {
            "inputs": [
                [
                    "\"1.01\"",
                    "\"1.001\""
                ],
                [
                    "\"1.0\"",
                    "\"1.0.0\""
                ],
                [
                    "\"0.1\"",
                    "\"1.1\""
                ],
                [
                    "\"1.0.1\"",
                    "\"1.1.0\""
                ],
                [
                    "\"1.2.3\"",
                    "\"2.0\""
                ],
                [
                    "\"2.0.0\"",
                    "\"2.0.1\""
                ],
                [
                    "\"2.1\"",
                    "\"2.1.0\""
                ],
                [
                    "\"2.1.1\"",
                    "\"10.6.5\""
                ],
                [
                    "\"10.6.5.0\"",
                    "\"10.6.5.1\""
                ],
                [
                    "\"10.6.5.10\"",
                    "\"10.6.5.11\""
                ]
            ],
            "outputs": [
                0,
                0,
                0,
                0,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1
            ]
        },
        "sample_code": {
            "c++": "int compareVersion(string version1, string version2) {\n    int i = 0, j = 0;\n    while (i < version1.size() || j < version2.size()) {\n        int num1 = 0, num2 = 0;\n        while (i < version1.size() && version1[i] != '.') {\n            num1 = num1 * 10 + (version1[i++] - '0');\n        }\n        while (j < version2.size() && version2[j] != '.') {\n            num2 = num2 * 10 + (version2[j++] - '0');\n        }\n        if (num1 < num2) return -1;\n        if (num1 > num2) return 1;\n        i++; j++;\n    }\n    return 0;\n}\n",
            "java": "public int compareVersion(String version1, String version2) {\n    int i = 0, j = 0;\n    while (i < version1.length() || j < version2.length()) {\n        int num1 = 0, num2 = 0;\n        while (i < version1.length() && version1.charAt(i) != '.') {\n            num1 = num1 * 10 + (version1.charAt(i++) - '0');\n        }\n        while (j < version2.length() && version2.charAt(j) != '.') {\n            num2 = num2 * 10 + (version2.charAt(j++) - '0');\n        }\n        if (num1 < num2) return -1;\n        if (num1 > num2) return 1;\n        i++; j++;\n    }\n    return 0;\n}\n",
            "python": "def compare_version(version1, version2):\n    v1 = version1.split('.')\n    v2 = version2.split('.')\n    \n    while v1 or v2:\n        num1 = int(v1.pop(0)) if v1 else 0\n        num2 = int(v2.pop(0)) if v2 else 0\n        \n        if num1 < num2:\n            return -1\n        if num1 > num2:\n            return 1\n    return 0\n",
            "javascript": "function compareVersion(version1, version2) {\n    const v1 = version1.split('.');\n    const v2 = version2.split('.');\n    \n    while (v1.length > 0 || v2.length > 0) {\n        const num1 = v1.length > 0 ? parseInt(v1.shift()) : 0;\n        const num2 = v2.length > 0 ? parseInt(v2.shift()) : 0;\n        \n        if (num1 < num2) return -1;\n        if (num1 > num2) return 1;\n    }\n    return 0;\n}\n\n",
            "explanation": "1. Set two pointers `i` and `j` at the beginning of each version string.\n2. Start a while loop that runs while either pointer has not reached the end of its version string.\n3. Initialize two integer variables `num1` and `num2`.\n4. Inside the while loop, extract the integer revision values by scanning the digits at the current pointer locations and incrementing the pointers while skipping dot separators.\n5. Compare the extracted revisions. If `num1` is smaller, return -1. If `num2` is smaller, return 1.\n6. After comparing revisions or if both pointers reach the end of their version strings, increment the pointers.\n7. If the while loop finishes without finding a difference in the revisions, the version numbers are equal, so return 0."
        },
        "structure": {
            "c++": "int compareVersion(string version1, string version2) \n    // Your code here\n}\n",
            "java": "public int compareVersion(String version1, String version2) \n    // Your code here\n}\n",
            "python": "def compare_version(version1, version2):\n    # Your code here\n\n",
            "javascript": "function compareVersion(version1, version2) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int compareVersion(string version1, string version2) {\n    int i = 0, j = 0;\n    while (i < version1.size() || j < version2.size()) {\n        int num1 = 0, num2 = 0;\n        while (i < version1.size() && version1[i] != '.') {\n            num1 = num1 * 10 + (version1[i++] - '0');\n        }\n        while (j < version2.size() && version2[j] != '.') {\n            num2 = num2 * 10 + (version2[j++] - '0');\n        }\n        if (num1 < num2) return -1;\n        if (num1 > num2) return 1;\n        i++; j++;\n    }\n    return 0;\n}",
            "java": "public int compareVersion(String version1, String version2) {\n    int i = 0, j = 0;\n    while (i < version1.length() || j < version2.length()) {\n        int num1 = 0, num2 = 0;\n        while (i < version1.length() && version1.charAt(i) != '.') {\n            num1 = num1 * 10 + (version1.charAt(i++) - '0');\n        }\n        while (j < version2.length() && version2.charAt(j) != '.') {\n            num2 = num2 * 10 + (version2.charAt(j++) - '0');\n        }\n        if (num1 < num2) return -1;\n        if (num1 > num2) return 1;\n        i++; j++;\n    }\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    version1 = $args[0]\n    version2 = $args[1]\n    result = compare_version(version1, version2)\n    print(result)",
            "javascript": "function main() {\n    const version1 = $args;\n    const version2 = $args;\n    const result = compareVersion(version1, version2);\n    console.log(result);\n}"
        }
    },
    "166": {
        "title": "Fraction to String",
        "description": "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. If multiple answers are possible, return any of them. It is guaranteed that the length of the answer string is less than 104 for all the given inputs.",
        "example": "Example:\n\nInput: numerator = 1, denominator = 2\nOutput: \"0.5\"\n\nInput: numerator = 2, denominator = 1\nOutput: \"2\"\n\nInput: numerator = 4, denominator = 333\nOutput: \"0.(012)\"",
        "level": "Medium",
        "tags": [
            "Math",
            "String"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2
                ],
                [
                    2,
                    1
                ],
                [
                    4,
                    333
                ],
                [
                    0,
                    1
                ],
                [
                    1,
                    3
                ],
                [
                    5,
                    2
                ],
                [
                    10,
                    7
                ],
                [
                    22,
                    7
                ],
                [
                    1,
                    9
                ],
                [
                    3,
                    8
                ],
                [
                    7,
                    11
                ],
                [
                    17,
                    19
                ],
                [
                    123,
                    456
                ],
                [
                    987,
                    654
                ],
                [
                    1000,
                    3
                ],
                [
                    9999,
                    10000
                ],
                [
                    123456,
                    789
                ],
                [
                    987654,
                    321
                ],
                [
                    111111,
                    999999
                ]
            ],
            "outputs": [
                "0.5",
                "2",
                "0.(012)",
                "0",
                "0.(3)",
                "2.5",
                "1.(428571)",
                "3.(142857)",
                "0.(1)",
                "0.375",
                "0.(63)",
                "0.(894736842105263157)",
                "0.(270833333333333333)",
                "0.(270833333333333333)",
                "333.(333333333333333333)",
                "3333.(333333333333333333)",
                "156.(25)",
                "307.(692307692307692307)",
                "0.(111111)",
                "0.(111111)"
            ]
        },
        "sample_code": {
            "c++": "#include <unordered_map>\nstd::string fractionToDecimal(int numerator, int denominator) {\n    if (numerator == 0) return \"0\";\n    std::string res;\n    if ((numerator > 0) ^ (denominator > 0)) res += '-';\n    long num = std::abs((long)numerator), den = std::abs((long)denominator);\n    res += std::to_string(num / den);\n    num %= den;\n    if (num == 0) return res;\n    res += '.';\n    std::unordered_map<int, int> map;\n    while (num) {\n        if (map.find(num) != map.end()) {\n            res.insert(map[num], \"(\");\n            res += \")\";\n            break;\n        }\n        map[num] = res.size();\n        num *= 10;\n        res += std::to_string(num / den);\n        num %= den;\n    }\n    return res;\n}\n\n",
            "java": "import java.util.HashMap;\n\npublic String fractionToDecimal(int numerator, int denominator) {\n    if (numerator == 0) return \"0\";\n    StringBuilder res = new StringBuilder();\n    if ((numerator > 0) ^ (denominator > 0)) res.append('-');\n    long num = Math.abs((long)numerator), den = Math.abs((long)denominator);\n    res.append(num / den);\n    num %= den;\n    if (num == 0) return res.toString();\n    res.append('.');\n    HashMap<Long, Integer> map = new HashMap<>();\n    while (num != 0) {\n        if (map.containsKey(num)) {\n            res.insert(map.get(num), \"(\");\n            res.append(\")\");\n            break;\n        }\n        map.put(num, res.length());\n        num *= 10;\n        res.append(num / den);\n        num %= den;\n    }\n    return res.toString();\n}\n\n",
            "python": "def fraction_to_string(numerator, denominator):\n    if numerator == 0:\n        return \"0\"\n    res = []\n    if (numerator > 0) ^ (denominator > 0):\n        res.append(\"-\")\n    num = abs(numerator)\n    den = abs(denominator)\n    res.append(str(num // den))\n    num %= den\n    if num == 0:\n        return \"\".join(res)\n    res.append(\".\")\n    map = {}\n    while num:\n        if num in map:\n            res.insert(map[num], \"(\")\n            res.append(\")\")\n            break\n        map[num] = len(res)\n        num *= 10\n        res.append(str(num // den))\n        num %= den\n    return \"\".join(res)\n\n",
            "javascript": "function fractionToDecimal(numerator, denominator) {\n    if (numerator === 0) return \"0\";\n    let res = \"\";\n    if ((numerator > 0) ^ (denominator > 0)) res += '-';\n    let num = Math.abs(numerator), den = Math.abs(denominator);\n    res += Math.floor(num / den);\n    num %= den;\n    if (num === 0) return res;\n    res += '.';\n    let map = new Map();\n    while (num) {\n        if (map.has(num)) {\n            res = res.slice(0, map.get(num)) + \"(\" + res.slice(map.get(num)) + \")\";\n            break;\n        }\n        map.set(num, res.length);\n        num *= 10;\n        res += Math.floor(num / den);\n        num %= den;\n    }\n    return res;\n}\n\n",
            "explanation": "The algorithm follows the steps:\n1. If numerator is 0, the result is 0.\n2. Add the sign to the result string if necessary, and make both numerator and denominator positive.\n3. Calculate integer part using integer division and add it to the result string.\n4. Calculate the remainder of the division.\n5. If the remainder is 0, return the result. Otherwise, add a dot to the result string.\n6. Use a hash map to store remainder positions. Iterate while the remainder is not 0.\n   - If the remainder is in the map, add parentheses around the repeating part and break the loop.\n   - Update the hash map with the current remainder and its position in the result string.\n   - Multiply the remainder by 10, add the new integer part to the result string, and update the remainder.\n7. Return the result string."
        },
        "structure": {
            "c++": "#include <unordered_map>\nstd::string fractionToDecimal(int numerator, int denominator) \n    // Your code here\n}\n\n",
            "java": "import java.util.HashMap;\n\npublic String fractionToDecimal(int numerator, int denominator) \n    // Your code here\n}\n\n",
            "python": "def fraction_to_string(numerator, denominator):\n    # Your code here\n\n",
            "javascript": "function fractionToDecimal(numerator, denominator) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <unordered_map>\nstd::string fractionToDecimal(int numerator, int denominator) {\n    if (numerator == 0) return \"0\";\n    std::string res;\n    if ((numerator > 0) ^ (denominator > 0)) res += '-';\n    long num = std::abs((long)numerator), den = std::abs((long)denominator);\n    res += std::to_string(num / den);\n    num %= den;\n    if (num == 0) return res;\n    res += '.';\n    std::unordered_map<int, int> map;\n    while (num) {\n        if (map.find(num) != map.end()) {\n            res.insert(map[num], \"(\");\n            res += \")\";\n            break;\n        }\n        map[num] = res.size();\n        num *= 10;\n        res += std::to_string(num / den);\n        num %= den;\n    }\n    return res;\n}\n\nint main() {\n    int numerator = $args;\n    int denominator = $args;\n    std::string result = fractionToDecimal(numerator, denominator);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public String fractionToDecimal(int numerator, int denominator) {\n    if (numerator == 0) return \"0\";\n    StringBuilder res = new StringBuilder();\n    if ((numerator > 0) ^ (denominator > 0)) res.append('-');\n    long num = Math.abs((long)numerator), den = Math.abs((long)denominator);\n    res.append(num / den);\n    num %= den;\n    if (num == 0) return res.toString();\n    res.append('.');\n    HashMap<Long, Integer> map = new HashMap<>();\n    while (num != 0) {\n        if (map.containsKey(num)) {\n            res.insert(map.get(num), \"(\");\n            res.append(\")\");\n            break;\n        }\n        map.put(num, res.length());\n        num *= 10;\n        res.append(num / den);\n        num %= den;\n    }\n    return res.toString();\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    numerator = inputs[0]\n    denominator = inputs[1]\n    result = fraction_to_string(numerator, denominator)\n    print(result)"
        }
    },
    "168": {
        "title": "Excel Sheet Column Title",
        "description": "Given an integer `columnNumber`, return its corresponding column title as it appears in an Excel sheet. The column title is represented by a string of uppercase English letters. Each letter corresponds to a column number, where A is 1, B is 2, ..., Z is 26, AA is 27, AB is 28, and so on.",
        "example": "For example, if the columnNumber is 1, the corresponding column title is 'A'.\n\n**Input:**\ncolumnNumber = 1\n**Output:**\n'A'\n\nIf the columnNumber is 28, the corresponding column title is 'AB'.\n\n**Input:**\ncolumnNumber = 28\n**Output:**\n'AB'\n\nIf the columnNumber is 701, the corresponding column title is 'ZY'.\n\n**Input:**\ncolumnNumber = 701\n**Output:**\n'ZY'",
        "level": "Easy",
        "tags": [
            "Math",
            "String"
        ],
        "test_cases": {
            "inputs": [
                1,
                28,
                701,
                52,
                100,
                26,
                27,
                1000,
                10000,
                123456,
                987654,
                231,
                456,
                789,
                999,
                100000,
                999999,
                1234567,
                9876543,
                23123123
            ],
            "outputs": [
                "A",
                "AB",
                "ZY",
                "AZ",
                "CV",
                "Z",
                "AA",
                "ALL",
                "NTP",
                "AICCC",
                "HJHJH",
                "HJ",
                "RM",
                "AD",
                "ALLL",
                "CFD",
                "HJHJHJ",
                "LJHJHJ",
                "HJHJHJH",
                "HJHJHJHJ"
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n\nstd::string convertToTitle(int columnNumber) {\n    std::string result = \"\";\n    while (columnNumber) {\n        columnNumber--;\n        result = (char)(columnNumber % 26 + 'A') + result;\n        columnNumber /= 26;\n    }\n    return result;\n}\n\n",
            "java": "public String convertToTitle(int columnNumber) {\n    StringBuilder result = new StringBuilder();\n    while (columnNumber > 0) {\n        columnNumber--;\n        result.insert(0, (char) ('A' + columnNumber % 26));\n        columnNumber /= 26;\n    }\n    return result.toString();\n}\n\n",
            "python": "def convert_to_title(columnNumber: int) -> str:\n    result = \"\"\n    while columnNumber:\n        columnNumber -= 1\n        result = chr(columnNumber % 26 + ord('A')) + result\n        columnNumber //= 26\n    return result\n\n",
            "javascript": "function convertToTitle(columnNumber) {\n    let result = \"\";\n    while (columnNumber) {\n        columnNumber--;\n        result = String.fromCharCode(columnNumber % 26 + 'A'.charCodeAt(0)) + result;\n        columnNumber = Math.floor(columnNumber / 26);\n    }\n    return result;\n}\n\n",
            "explanation": "The algorithm converts an integer `columnNumber` to its corresponding column title as it appears in an Excel sheet. It does so by treating the Excel sheet column headers as a Base-26 number system where the numbers are represented by the characters from A-Z.\n\n1. We start by initializing an empty string called `result` that will store the final column title.\n2. In a while loop, we continue until the `columnNumber` is greater than 0.\n3. We subtract 1 from `columnNumber`, as the base representation starts from A (1).\n4. The remainder of `columnNumber` divided by 26 is the index of the character in the A-Z range, which is added to the `result` string.\n5. `columnNumber` is then divided by 26 and the loop continues until `columnNumber` is 0.\n6. Once the loop is finished, the `result` string is returned as the corresponding column title."
        },
        "structure": {
            "c++": "#include <string>\n\nstd::string convertToTitle(int columnNumber) \n    // Your code here\n}\n\n",
            "java": "public String convertToTitle(int columnNumber) \n    // Your code here\n}\n\n",
            "python": "def convert_to_title(columnNumber: int) -> str:\n    # Your code here\n\n",
            "javascript": "function convertToTitle(columnNumber) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int columnNumber = $args;\n    std::string result = convertToTitle(columnNumber);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public String convertToTitle(int columnNumber) {\n    StringBuilder result = new StringBuilder();\n    while (columnNumber > 0) {\n        columnNumber--;\n        result.insert(0, (char) ('A' + columnNumber % 26));\n        columnNumber /= 26;\n    }\n    return result.toString();\n}",
            "python": "if __name__ == \"__main__\":\n    column_number = $args\n    result = convert_to_title(column_number)\n    print(result)"
        }
    },
    "171": {
        "title": "Excel Sheet Column Number",
        "description": "Given a string `columnTitle` that represents the column title as appears in an Excel sheet, return its corresponding column number. Each column title consists of uppercase English letters, where 'A' represents 1, 'B' represents 2, and so on. The column titles can also have multiple letters, such as 'AA' representing 27 and 'AB' representing 28.",
        "example": "For example, if the column title is 'AB', the corresponding column number is 28.\n\n**Input:** columnTitle = 'AB'\n**Output:** 28",
        "level": "Easy",
        "tags": [
            "Math",
            "String"
        ],
        "test_cases": {
            "inputs": [
                "'A'",
                "'B'",
                "'C'",
                "'Z'",
                "'AA'",
                "'AB'",
                "'ZY'",
                "'FXSHRXW'"
            ],
            "outputs": [
                1,
                2,
                3,
                26,
                27,
                28,
                701,
                2147483647
            ]
        },
        "sample_code": {
            "c++": "int titleToNumber(string columnTitle) {\n    int result = 0;\n    for (char c : columnTitle) {\n        result = result * 26 + (c - 'A' + 1);\n    }\n    return result;\n}\n",
            "java": "public int titleToNumber(String columnTitle) {\n    int result = 0;\n    for (char c : columnTitle.toCharArray()) {\n        result = result * 26 + (c - 'A' + 1);\n    }\n    return result;\n}\n",
            "python": "def title_to_number(column_title: str) -> int:\n    result = 0\n    for c in column_title:\n        result = result * 26 + (ord(c) - ord('A') + 1)\n    return result\n",
            "javascript": "function titleToNumber(columnTitle) {\n    let result = 0;\n    for (let c of columnTitle) {\n        result = result * 26 + (c.charCodeAt(0) - 'A'.charCodeAt(0) + 1);\n    }\n    return result;\n}\n",
            "explanation": "The algorithm iterates through the given `columnTitle` string and computes the corresponding column number by treating the string like a base-26 number representation, where 'A' represents the digit 1 and 'Z' represents the digit 26. To convert each character to its corresponding numeric value, we subtract the ASCII value of 'A' and add 1. In each iteration, the current result is multiplied by 26 and the numeric value of the current character is added to the result. Finally, the accumulated result is returned as the column number."
        },
        "structure": {
            "c++": "int titleToNumber(string columnTitle) \n    // Your code here\n}\n",
            "java": "public int titleToNumber(String columnTitle) \n    // Your code here\n}\n",
            "python": "def title_to_number(column_title: str) -> int:\n    # Your code here\n\n",
            "javascript": "function titleToNumber(columnTitle) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    string columnTitle = $args;\n    int result = titleToNumber(columnTitle);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int titleToNumber(String columnTitle) {\n    int result = 0;\n    for (char c : columnTitle.toCharArray()) {\n        result = result * 26 + (c - 'A' + 1);\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    column_title = $args\n    result = title_to_number(column_title)\n    print(result)",
            "javascript": "function main() {\n    const columnTitle = $args;\n    const result = titleToNumber(columnTitle);\n    console.log(result);\n}"
        }
    },
    "174": {
        "title": "Knight's Minimum Initial Health",
        "description": "The demons have captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.\n\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\n\nSome of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).\n\nTo reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.\n\nReturn the knight's minimum initial health so that he can rescue the princess.\n\nNote that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.",
        "example": "Example:\n\nInput: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]\nOutput: 7\nExplanation: The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.",
        "level": "Medium",
        "tags": [
            "dynamic programming",
            "grid",
            "optimization"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        -5
                    ]
                ],
                [
                    [
                        0
                    ]
                ],
                [
                    [
                        -1,
                        -2,
                        -3
                    ],
                    [
                        -4,
                        -5,
                        -6
                    ],
                    [
                        -7,
                        -8,
                        -9
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9
                    ]
                ],
                [
                    [
                        -1000,
                        0,
                        0,
                        0
                    ],
                    [
                        -1000,
                        0,
                        0,
                        0
                    ],
                    [
                        -1000,
                        0,
                        0,
                        0
                    ],
                    [
                        -1000,
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1000,
                        0,
                        0,
                        0
                    ],
                    [
                        1000,
                        0,
                        0,
                        0
                    ],
                    [
                        1000,
                        0,
                        0,
                        0
                    ],
                    [
                        1000,
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        -1000,
                        -1000,
                        -1000,
                        -1000
                    ],
                    [
                        -1000,
                        -1000,
                        -1000,
                        -1000
                    ],
                    [
                        -1000,
                        -1000,
                        -1000,
                        -1000
                    ],
                    [
                        -1000,
                        -1000,
                        -1000,
                        -1000
                    ]
                ],
                [
                    [
                        1000,
                        1000,
                        1000,
                        1000
                    ],
                    [
                        1000,
                        1000,
                        1000,
                        1000
                    ],
                    [
                        1000,
                        1000,
                        1000,
                        1000
                    ],
                    [
                        1000,
                        1000,
                        1000,
                        1000
                    ]
                ],
                [
                    [
                        -2,
                        0,
                        0,
                        0
                    ],
                    [
                        -5,
                        -10,
                        1,
                        0
                    ],
                    [
                        10,
                        30,
                        -5,
                        0
                    ]
                ],
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        5
                    ]
                ],
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        0
                    ]
                ],
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        -1
                    ]
                ],
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        -1000
                    ]
                ],
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        1000
                    ]
                ],
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        -1000
                    ]
                ],
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        1000
                    ]
                ],
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        -1000
                    ]
                ],
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        1000
                    ]
                ],
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        -1000
                    ]
                ],
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        1000
                    ]
                ]
            ],
            "outputs": [
                7,
                1,
                6,
                1,
                1001,
                1,
                1001,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1
            ]
        },
        "sample_code": {
            "c++": "#include<vector>\nusing namespace std;\n\nint calculateMinimumHP(vector<vector<int>>& dungeon) {\n    int m = dungeon.size(), n = dungeon[0].size();\n    vector<vector<int>> dp(m, vector<int>(n));\n\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if(i == m-1 && j == n-1){\n                dp[i][j] = min(0, dungeon[i][j]);\n            }\n            else if (i == m - 1) {\n                dp[i][j] = min(0, dp[i][j + 1] + dungeon[i][j]);\n            }\n            else if (j == n - 1) {\n                dp[i][j] = min(0, dp[i + 1][j] + dungeon[i][j]);\n            }\n            else {\n                dp[i][j] = min(0, max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n            }\n        }\n    }\n\n    return abs(dp[0][0]) + 1;\n}\n",
            "java": "public int calculateMinimumHP(int[][] dungeon) {\n    int m = dungeon.length, n = dungeon[0].length;\n    int[][] dp = new int[m][n];\n\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if(i == m-1 && j == n-1)\n                dp[i][j] = Math.min(0, dungeon[i][j]);\n            else if (i == m - 1)\n                dp[i][j] = Math.min(0, dp[i][j + 1] + dungeon[i][j]);\n            else if (j == n - 1)\n                dp[i][j] = Math.min(0, dp[i + 1][j] + dungeon[i][j]);\n            else\n                dp[i][j] = Math.min(0, Math.max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n        }\n    }\n\n    return Math.abs(dp[0][0]) + 1;\n}\n",
            "python": "def calculateMinimumHP(dungeon):\n    m, n = len(dungeon), len(dungeon[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if i == m - 1 and j == n - 1:\n                dp[i][j] = min(0, dungeon[i][j])\n            elif i == m - 1:\n                dp[i][j] = min(0, dp[i][j + 1] + dungeon[i][j])\n            elif j == n - 1:\n                dp[i][j] = min(0, dp[i + 1][j] + dungeon[i][j])\n            else:\n                dp[i][j] = min(0, max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j])\n\n    return abs(dp[0][0]) + 1\n",
            "javascript": "function calculateMinimumHP(dungeon) {\n    const m = dungeon.length, n = dungeon[0].length;\n    const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));\n\n    for (let i = m - 1; i >= 0; i--) {\n        for (let j = n - 1; j >= 0; j--) {\n            if (i === m - 1 && j === n - 1)\n                dp[i][j] = Math.min(0, dungeon[i][j]);\n            else if (i === m - 1)\n                dp[i][j] = Math.min(0, dp[i][j + 1] + dungeon[i][j]);\n            else if (j === n - 1)\n                dp[i][j] = Math.min(0, dp[i + 1][j] + dungeon[i][j]);\n            else\n                dp[i][j] = Math.min(0, Math.max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n        }\n    }\n\n    return Math.abs(dp[0][0]) + 1;\n}\n",
            "explanation": "The algorithm uses dynamic programming to find the minimum health needed in a bottom-up manner by starting from the bottom-right corner of the dungeon to the top-left corner. We create a \"dp\" table with the same size as the dungeon and fill it initially with zeros. Then we iterate over each cell in the dungeon from the bottom-right to the top-left. For each cell, we consider the right and down adjacent cells (if they exist) and calculate the minimum health required to move forward. We update the \"dp\" table with these values. The minimum of the health required to move right or down, plus the current cell dungeon value, is then stored in the current cell in the \"dp\" table. Finally, we return the absolute value of the top-left cell of \"dp\" table plus one (for the initial health point). This gives us the minimum initial health needed to get to the princess."
        },
        "structure": {
            "c++": "#include<vector>\nusing namespace std;\n\nint calculateMinimumHP(vector<vector<int>>& dungeon) \n    // Your code here\n}\n",
            "java": "public int calculateMinimumHP(int[][] dungeon) \n    // Your code here\n}\n",
            "python": "def calculateMinimumHP(dungeon):\n    # Your code here\n\n",
            "javascript": "function calculateMinimumHP(dungeon) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include<vector>\nusing namespace std;\n\nint main() {\n    vector<vector<int>> dungeon = $args;\n    int result = calculateMinimumHP(dungeon);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    dungeon = $args\n    result = calculateMinimumHP(dungeon)\n    print(result)"
        }
    },
    "179": {
        "title": "Largest Number Formation",
        "description": "Given a list of non-negative integers `nums`, arrange them in such a way that they form the largest number and return it as a string.",
        "example": "For example, given the list `nums = [10, 2]`, the largest number that can be formed is `210`. Therefore, the output would be the string `\"210\"`.\n\nIn another example, given the list `nums = [3, 30, 34, 5, 9]`, the largest number that can be formed is `9534330`. Therefore, the output would be the string `\"9534330\"`.",
        "level": "Medium",
        "tags": [
            "sorting",
            "string"
        ],
        "test_cases": {
            "inputs": [
                [
                    10,
                    2
                ],
                [
                    3,
                    30,
                    34,
                    5,
                    9
                ],
                [
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    9,
                    99,
                    999,
                    9999
                ],
                [
                    100,
                    200,
                    300,
                    400
                ],
                [
                    5,
                    50,
                    500,
                    5000
                ],
                [
                    12,
                    121
                ],
                [
                    21,
                    212
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    0
                ]
            ],
            "outputs": [
                "210",
                "9534330",
                "0",
                "54321",
                "999999999",
                "400300200100",
                "55005000500",
                "12112",
                "21221",
                "9876543210",
                "9876543210"
            ]
        },
        "sample_code": {
            "c++": "#include <algorithm>\n#include <string>\n#include <vector>\n\nbool compare(std::string a, std::string b) {\n    return a+b > b+a;\n}\n\nstd::string largestNumber(std::vector<int>& nums) {\n    std::vector<std::string> asStrs;\n    for (int num : nums) asStrs.push_back(std::to_string(num));\n    std::sort(asStrs.begin(), asStrs.end(), compare);\n    std::string res;\n    for (std::string s: asStrs) res += s;\n    return res[0] == '0' ? \"0\" : res;\n}\n",
            "java": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Solution {\n    public String largestNumber(int[] nums) {\n        String[] strNums = new String[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            strNums[i] = String.valueOf(nums[i]);\n        }\n        Arrays.sort(strNums, (a, b) -> (b + a).compareTo(a + b));\n        if (strNums[0].equals(\"0\")) {\n            return \"0\";\n        }\n        StringBuilder sb = new StringBuilder();\n        for (String str : strNums) sb.append(str);\n        return sb.toString();\n    }\n}\n",
            "python": "from functools import cmp_to_key\n\ndef largestNumber(nums):\n    def comparator(a, b):\n        return -1 if a + b > b + a else int(a + b < b + a)\n\n    nums_as_str = list(map(str, nums))\n    nums_as_str.sort(key=cmp_to_key(comparator))\n    return '0' if nums_as_str[0] == \"0\" else \"\".join(nums_as_str)\n",
            "javascript": "function largestNumber(nums) {\n    const numsAsStrings = nums.map(String);\n    numsAsStrings.sort((a, b) => (b + a).localeCompare(a + b));\n    return numsAsStrings[0] === '0' ? '0' : numsAsStrings.join('');\n}\n",
            "explanation": "1. Convert all integers to strings.\n2. Sort the strings using a custom comparator. The comparator shall compare concatenation of two strings in reverse order, i.e., a+b and b+a. Compare a+b and b+a, if a+b is larger, it means a should be before b, else b should before a.\n3. Join sorted strings to form the answer. If the first string is '0', return '0' as that means all elements are '0' (as strings are sorted)."
        },
        "structure": {
            "c++": "#include <algorithm>\n#include <string>\n#include <vector>\n\nbool compare(std::string a, std::string b) \n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Solution \n    // Your code here\n}\n",
            "python": "from functools import cmp_to_key\n    # Your code here\n\n",
            "javascript": "function largestNumber(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <algorithm>\n#include <string>\n#include <vector>\n#include <iostream>\n\nbool compare(std::string a, std::string b) {\n    return a+b > b+a;\n}\n\nstd::string largestNumber(std::vector<int>& nums) {\n    std::vector<std::string> asStrs;\n    for (int num : nums) asStrs.push_back(std::to_string(num));\n    std::sort(asStrs.begin(), asStrs.end(), compare);\n    std::string res;\n    for (std::string s: asStrs) res += s;\n    return res[0] == '0' ? \"0\" : res;\n}\n\nint main() {\n    std::vector<int> nums = $args;\n    std::string result = largestNumber(nums);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public String largestNumber(int[] nums) {\n        String[] strNums = new String[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            strNums[i] = String.valueOf(nums[i]);\n        }\n        Arrays.sort(strNums, (a, b) -> (b + a).compareTo(a + b));\n        if (strNums[0].equals(\"0\")) {\n            return \"0\";\n        }\n        StringBuilder sb = new StringBuilder();\n        for (String str : strNums) sb.append(str);\n        return sb.toString();\n    }",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = largestNumber(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = largestNumber(nums);\n    console.log(result);\n}"
        }
    },
    "188": {
        "title": "Maximum Profit with at most k Transactions",
        "description": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `k`. Find the maximum profit you can achieve. You may complete at most `k` transactions: i.e. you may buy at most `k` times and sell at most `k` times. Note that you may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
        "example": "Example:\n\nInput: k = 2, prices = [2,4,1]\nOutput: 2\nExplanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    [
                        2,
                        4,
                        1
                    ]
                ],
                [
                    2,
                    [
                        3,
                        2,
                        6,
                        5,
                        0,
                        3
                    ]
                ],
                [
                    1,
                    [
                        7,
                        1,
                        5,
                        3,
                        6,
                        4
                    ]
                ],
                [
                    3,
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ]
                ],
                [
                    0,
                    [
                        7,
                        6,
                        4,
                        3,
                        1
                    ]
                ],
                [
                    5,
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ]
                ],
                [
                    2,
                    [
                        1,
                        2,
                        4,
                        2,
                        5,
                        7,
                        2,
                        4,
                        9,
                        0
                    ]
                ],
                [
                    3,
                    [
                        3,
                        3,
                        5,
                        0,
                        0,
                        3,
                        1,
                        4
                    ]
                ],
                [
                    1,
                    [
                        1
                    ]
                ],
                [
                    0,
                    [
                        1
                    ]
                ],
                [
                    2,
                    [
                        1,
                        2
                    ]
                ],
                [
                    2,
                    [
                        2,
                        1
                    ]
                ],
                [
                    2,
                    [
                        1,
                        2,
                        4,
                        2,
                        5,
                        7,
                        2,
                        4,
                        9,
                        0
                    ]
                ],
                [
                    3,
                    [
                        3,
                        3,
                        5,
                        0,
                        0,
                        3,
                        1,
                        4
                    ]
                ],
                [
                    1,
                    [
                        1
                    ]
                ],
                [
                    0,
                    [
                        1
                    ]
                ],
                [
                    2,
                    [
                        1,
                        2
                    ]
                ],
                [
                    2,
                    [
                        2,
                        1
                    ]
                ],
                [
                    2,
                    [
                        1,
                        2,
                        4,
                        2,
                        5,
                        7,
                        2,
                        4,
                        9,
                        0
                    ]
                ],
                [
                    3,
                    [
                        3,
                        3,
                        5,
                        0,
                        0,
                        3,
                        1,
                        4
                    ]
                ]
            ],
            "outputs": [
                2,
                7,
                5,
                4,
                0,
                4,
                13,
                6,
                0,
                0,
                1,
                0,
                13,
                6,
                0,
                0,
                1,
                0,
                13,
                6
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\nint maxProfit(int k, std::vector<int>& prices) {\n    int n = prices.size();\n    if (k > n / 2) {\n        int max_profit = 0;\n        for (int i = 1; i < n; ++i)\n            max_profit += std::max(prices[i] - prices[i - 1], 0);\n        return max_profit;  \n    }\n\n    std::vector<std::vector<int>> dp(k + 1, std::vector<int>(n, 0));\n    for (int i = 1; i <= k; ++i) {\n        int max_diff = -prices[0];\n        for (int j = 1; j < n; ++j) {\n            dp[i][j] = std::max(dp[i][j - 1], prices[j] + max_diff);\n            max_diff = std::max(max_diff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}\n",
            "java": "public int maxProfit(int k, int[] prices) {\n    int n = prices.length;\n    if (k > n / 2) {\n        int maxProfit = 0;\n        for (int i = 1; i < n; ++i)\n            maxProfit += Math.max(prices[i] - prices[i - 1], 0);\n        return maxProfit;  \n    }\n\n    int[][] dp = new int[k + 1][n];\n    for (int i = 1; i <= k; ++i) {\n        int maxDiff = -prices[0];\n        for (int j = 1; j < n; ++j) {\n            dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n            maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}\n",
            "python": "def maxProfit(k, prices):\n    n = len(prices)\n    if k > n // 2:\n        return sum(max(prices[i] - prices[i - 1], 0) for i in range(1, n))\n\n    dp = [[0] * n for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - prices[j])\n    return dp[k][n - 1]\n",
            "javascript": "function maxProfit(k, prices) {\n    let n = prices.length;\n    if (k > n / 2) {\n        let maxProfit = 0;\n        for (let i = 1; i < n; ++i)\n            maxProfit += Math.max(prices[i] - prices[i - 1], 0);\n        return maxProfit;  \n    }\n\n    let dp = new Array(k + 1).fill(null).map(() => new Array(n).fill(0));\n    for (let i = 1; i <= k; ++i) {\n        let maxDiff = -prices[0];\n        for (let j = 1; j < n; ++j) {\n            dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n            maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}\n",
            "explanation": "The algorithm uses dynamic programming to build a table `dp` where `dp[i][j]` represents the maximum profit after completing `i` transactions up to day `j`. Initialize `dp` with all zeros, since no initial transactions will result in 0 profit.\n\nFirst, handle the case where `k > n / 2`. If allowed transactions (`k`) are more than half of the available days (`n`), you can simply trade daily by only considering positive profits.\n\nNow, use two nested loops to fill the `dp` table. The outer loop iterates over the allowed transactions (1 to k), and the inner loop iterates over the days (1 to n-1). Inside the inner loop, find the maximum difference between the current day's price and previous days' prices minus the maximum profit after completing one less transaction at previous days (i.e., `prices[j] + dp[i-1][j'] - prices[j']` for all j' < j). This will keep track of the most profitable second transaction after buying a stock at the highest possible profit for the first transaction.\n\nFinally, return the value in the bottom-right corner of the `dp` table (i.e., `dp[k][n-1]`), which provides the maximum profit after completing the allowed number of transactions."
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\nint maxProfit(int k, std::vector<int>& prices) \n    // Your code here\n}\n",
            "java": "public int maxProfit(int k, int[] prices) \n    // Your code here\n}\n",
            "python": "def maxProfit(k, prices):\n    # Your code here\n\n",
            "javascript": "function maxProfit(k, prices) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <algorithm>\n\nint main() {\n    int k = $args;\n    std::vector<int> prices = {1, 2, 3, 4, 5};\n    int result = maxProfit(k, prices);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int maxProfit(int k, int[] prices) {\n    int n = prices.length;\n    if (k > n / 2) {\n        int maxProfit = 0;\n        for (int i = 1; i < n; ++i)\n            maxProfit += Math.max(prices[i] - prices[i - 1], 0);\n        return maxProfit;  \n    }\n\n    int[][] dp = new int[k + 1][n];\n    for (int i = 1; i <= k; ++i) {\n        int maxDiff = -prices[0];\n        for (int j = 1; j < n; ++j) {\n            dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n            maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    k = inputs[0]\n    prices = inputs[1]\n    result = maxProfit(k, prices)\n    print(result)",
            "javascript": "function maxProfit(k, prices) {\n    let n = prices.length;\n    if (k > n / 2) {\n        let maxProfit = 0;\n        for (let i = 1; i < n; ++i)\n            maxProfit += Math.max(prices[i] - prices[i - 1], 0);\n        return maxProfit;  \n    }\n\n    let dp = new Array(k + 1).fill(null).map(() => new Array(n).fill(0));\n    for (let i = 1; i <= k; ++i) {\n        let maxDiff = -prices[0];\n        for (let j = 1; j < n; ++j) {\n            dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n            maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}"
        }
    },
    "189": {
        "title": "Rotate Array",
        "description": "Given an integer array `nums`, rotate the array to the right by `k` steps, where `k` is non-negative.",
        "example": "Example 1:\n\nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n\nExample 2:\n\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation:\nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]",
        "level": "Medium",
        "tags": [
            "Array",
            "Rotation"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7
                ],
                [
                    -1,
                    -100,
                    3,
                    99
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15
                ],
                [
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100
                ],
                [
                    100,
                    200,
                    300,
                    400,
                    500,
                    600,
                    700,
                    800,
                    900,
                    1000
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9,
                    11,
                    13,
                    15,
                    17,
                    19
                ]
            ],
            "outputs": [
                "[5,6,7,1,2,3,4]",
                "[3,99,-1,-100]",
                "[0,0,0,0,0,0,0]",
                "[1,2,3,4,5,6,7,8,9,10]",
                "[9,10,11,12,13,14,15,5,6,7,8]",
                "[1]",
                "[6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,1,2,3,4,5]",
                "[90,100,10,20,30,40,50,60,70,80]",
                "[900,1000,100,200,300,400,500,600,700,800]",
                "[19,1,3,5,7,9,11,13,15,17]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nvoid rotate(vector<int>& nums, int k) {\n    int n = nums.size();\n    k %= n;\n    reverse(nums.begin(), nums.end());\n    reverse(nums.begin(), nums.begin() + k);\n    reverse(nums.begin() + k, nums.end());\n}\n",
            "java": "public void rotate(int[] nums, int k) {\n    int n = nums.length;\n    k %= n;\n    reverse(nums, 0, n - 1);\n    reverse(nums, 0, k - 1);\n    reverse(nums, k, n - 1);\n}\n\nprivate void reverse(int[] nums, int start, int end) {\n    while (start < end) {\n        int temp = nums[start];\n        nums[start++] = nums[end];\n        nums[end--] = temp;\n    }\n}\n",
            "python": "def rotate(nums, k):\n    n = len(nums)\n    k %= n\n    nums[:] = nums[-k:] + nums[:-k]\n",
            "javascript": "function rotate(nums, k) {\n    const n = nums.length;\n    k %= n;\n    reverse(nums, 0, n - 1);\n    reverse(nums, 0, k - 1);\n    reverse(nums, k, n - 1);\n}\n\nfunction reverse(nums, start, end) {\n    while (start < end) {\n        [nums[start], nums[end]] = [nums[end], nums[start]];\n        start++;\n        end--;\n    }\n}\n",
            "explanation": "The algorithm first reverses the entire array, then reverses the first `k` elements, and finally reverses the remaining `n-k` elements where `n` is the length of the array. The reversing operation is done in-place so as not to use extra memory.\n\nThis is achieved using a `reverse` function that swaps elements at positions `start` and `end` and increment `start` and decrement `end` until `start` is greater than or equal to `end`. The `reverse` function basically reverses the elements between the given positions.\n\nIn Python, we use slicing to achieve the rotation without the explicit `reverse` function."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nvoid rotate(vector<int>& nums, int k) \n    // Your code here\n}\n",
            "java": "public void rotate(int[] nums, int k) \n    // Your code here\n}\n",
            "python": "def rotate(nums, k):\n    # Your code here\n\n",
            "javascript": "function rotate(nums, k) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nint main() {\n    vector<int> nums = $args;\n    int k = $args;\n    rotate(nums, k);\n    for (int i = 0; i < nums.size(); i++) {\n        cout << nums[i] << \" \";\n    }\n    return 0;\n}",
            "java": "public void rotate(int[] nums, int k) {\n    int n = nums.length;\n    k %= n;\n    reverse(nums, 0, n - 1);\n    reverse(nums, 0, k - 1);\n    reverse(nums, k, n - 1);\n}\n\nprivate void reverse(int[] nums, int start, int end) {\n    while (start < end) {\n        int temp = nums[start];\n        nums[start++] = nums[end];\n        nums[end--] = temp;\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    k = $args[1]\n    result = rotate(nums, k)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args[0];\n    const k = $args[1];\n    rotate(nums, k);\n    console.log(nums);\n}"
        }
    },
    "190": {
        "title": "Reverse Bits",
        "description": "Write a function that takes a 32-bit unsigned integer as input and returns the integer obtained by reversing its bits.",
        "example": "For example, if the input is 00000010100101000001111010011100, the output should be 964176192. The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so the reversed bits should be 00111001011110000010100101000000, which is equal to 964176192.",
        "level": "Easy",
        "tags": [
            "Bit Manipulation"
        ],
        "test_cases": {
            "inputs": [
                "00000010100101000001111010011100",
                "11111111111111111111111111111101",
                "00000000000000000000000000000000",
                "11111111111111111111111111111111",
                "10000000000000000000000000000000",
                "01010101010101010101010101010101",
                "00110011001100110011001100110011",
                "00001111000011110000111100001111",
                "11110000111100001111000011110000",
                "10101010101010101010101010101010",
                "11001100110011001100110011001100",
                "00000000000000000000000000000001",
                "11111111111111111111111111111110",
                "10000000000000000000000000000001",
                "01010101010101010101010101010100",
                "00110011001100110011001100110010",
                "00001111000011110000111100001110",
                "11110000111100001111000011110001",
                "10101010101010101010101010101001",
                "11001100110011001100110011001101"
            ],
            "outputs": [
                964176192,
                3221225471,
                0,
                4294967295,
                -2147483648,
                1431655765,
                858993459,
                4026531840,
                4026531840,
                2863311530,
                3221225472,
                -2147483647,
                -1073741825,
                -2147483647,
                2863311536,
                1431655764,
                402653184,
                3221225472,
                2863311529,
                -1073741823
            ]
        },
        "sample_code": {
            "c++": "unsigned int reverseBits(unsigned int n) {\n    unsigned int res = 0;\n    for (int i = 0; i < 32; ++i) {\n        res <<= 1;\n        res |= n & 1;\n        n >>= 1;\n    }\n    return res;\n}\n",
            "java": "public int reverseBits(int n) {\n    int res = 0;\n    for (int i = 0; i < 32; ++i) {\n        res <<= 1;\n        res |= n & 1;\n        n >>= 1;\n    }\n    return res;\n}\n",
            "python": "def reverse_bits(n: str) -> int:\n    res = 0\n    for _ in range(32):\n        res <<= 1\n        res |= n & 1\n        n >>= 1\n    return res\n",
            "javascript": "function reverseBits(n) {\n    let res = 0;\n    for (let i = 0; i < 32; ++i) {\n        res <<= 1;\n        res |= n & 1;\n        n >>= 1;\n    }\n    return res >>> 0;\n}\n",
            "explanation": "The algorithm iterates through all 32 bits of the given unsigned 32-bit integer, and for each bit, it shifts the result variable `res` one position to the left, and then performs a bitwise OR with the given number `n` ANDed with 1. This operation adds the least significant bit of `n` to the most significant bit of `res`. Then, the given number `n` is shifted one position to the right. The process is repeated for all 32 bits, and in each step, the result variable `res` accumulates the reversed bits of the input number."
        },
        "structure": {
            "c++": "unsigned int reverseBits(unsigned int n) \n    // Your code here\n}\n",
            "java": "public int reverseBits(int n) \n    // Your code here\n}\n",
            "python": "def reverse_bits(n: str) -> int:\n    # Your code here\n\n",
            "javascript": "function reverseBits(n) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nunsigned int reverseBits(unsigned int n) {\n    unsigned int res = 0;\n    for (int i = 0; i < 32; ++i) {\n        res <<= 1;\n        res |= n & 1;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    unsigned int n = $args;\n    unsigned int result = reverseBits(n);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = reverse_bits(n)\n    print(result)"
        }
    },
    "194": {
        "title": "Transpose Text File",
        "description": "Given a text file `file.txt`, transpose its content. Each row in the file represents a line of text, and each field in a row is separated by a space character. Transpose the content by converting rows into columns and columns into rows. The transposed content should be written back to the file.",
        "example": "For example, if the `file.txt` contains the following content:\n\nname age\nalice 21\nryan 30\n\nThe transposed content should be:\n\nname alice ryan\nage 21 30\n\nExplanation: The rows 'name age', 'alice 21', and 'ryan 30' are transposed to columns 'name alice ryan' and 'age 21 30'.",
        "level": "Medium",
        "tags": [
            "file operations",
            "data manipulation"
        ],
        "test_cases": {
            "inputs": [
                "name age\nalice 21\nryan 30",
                "fruit color\napple red\nbanana yellow\norange orange",
                "country capital\nusa washington\ncanada ottawa\nmexico mexico city"
            ],
            "outputs": [
                "name alice ryan\nage 21 30",
                "fruit apple banana orange\ncolor red yellow orange",
                "country usa canada mexico\ncapital washington ottawa mexico city"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <sstream>\n\nstd::vector<std::string> transpose(std::vector<std::string> &content)\n{\n    std::vector<std::vector<std::string>> data;\n    for (const std::string &line : content)\n    {\n        std::vector<std::string> row;\n        std::stringstream ss(line);\n        std::string word;\n        while (ss >> word)\n            row.push_back(word);\n        data.push_back(row);\n    }\n\n    std::vector<std::string> result(data[0].size(), \"\");\n    for (size_t i = 0; i < data[0].size(); ++i)\n    {\n        for (size_t j = 0; j < data.size(); ++j)\n        {\n            result[i] += data[j][i];\n            if (j < data.size() - 1)\n                result[i] += \" \";\n        }\n    }\n\n    return result;\n}\n\n",
            "java": "import java.util.*;\n\npublic List<String> transpose(List<String> content) {\n    List<List<String>> data = new ArrayList<>();\n    for (String line : content) {\n        List<String> row = new ArrayList<>(Arrays.asList(line.split(\" \")));\n        data.add(row);\n    }\n\n    List<String> result = new ArrayList<>(Collections.nCopies(data.get(0).size(), \"\"));\n    for (int i = 0; i < data.get(0).size(); i++) {\n        for (int j = 0; j < data.size(); j++) {\n            result.set(i, result.get(i) + (j > 0 ? \" \" : \"\") + data.get(j).get(i));\n        }\n    }\n\n    return result;\n}\n\n",
            "python": "def transpose(content):\n    data = [line.split(\" \") for line in content]\n    result = [\" \".join(data[j][i] for j in range(len(data))) for i in range(len(data[0]))]\n    return result\n\n",
            "javascript": "function transpose(content) {\n    let data = content.map(line => line.split(\" \"));\n    let result = new Array(data[0].length).fill(\"\");\n    for (let i = 0; i < data[0].length; i++) {\n        for (let j = 0; j < data.length; j++) {\n            result[i] += (j > 0 ? \" \" : \"\") + data[j][i];\n        }\n    }\n\n    return result;\n}\n\n",
            "explanation": "First, we read the content and split each line by the \" \" character to create a 2D array of words named `data`. Then, we create a `result` list with the same number of columns as the first row in `data`. \n\nNext, we loop through the 2D array using a nested loop. For each cell of the array, we append the word corresponding to the current coordinates to the respective row in the `result` list. In this manner, we transpose the content.\n\nFinally, we return the `result`, which is the transposed version of the content."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <sstream>\n\nstd::vector<std::string> transpose(std::vector<std::string> &content)\n\n    // Your code here\n}\n\n",
            "java": "import java.util.*;\n\npublic List<String> transpose(List<String> content) \n    // Your code here\n}\n\n",
            "python": "def transpose(content):\n    # Your code here\n\n",
            "javascript": "function transpose(content) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <sstream>\n#include <iostream>\n\nint main() {\n    std::vector<std::string> content;\n    std::string line;\n    while (std::getline(std::cin, line)) {\n        content.push_back(line);\n    }\n\n    std::vector<std::string> result = transpose(content);\n\n    for (const std::string& word : result) {\n        std::cout << word << std::endl;\n    }\n\n    return 0;\n}\n",
            "java": "public List<String> transpose(List<String> content) {\n    List<List<String>> data = new ArrayList<>();\n    for (String line : content) {\n        List<String> row = new ArrayList<>(Arrays.asList(line.split(\" \")));\n        data.add(row);\n    }\n\n    List<String> result = new ArrayList<>(Collections.nCopies(data.get(0).size(), \"\"));\n    for (int i = 0; i < data.get(0).size(); i++) {\n        for (int j = 0; j < data.size(); j++) {\n            result.set(i, result.get(i) + (j > 0 ? \" \" : \"\") + data.get(j).get(i));\n        }\n    }\n\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    content = $args[0]\n    result = transpose(content)\n    print(result)",
            "javascript": "function main() {\n    const content = $args;\n    const result = transpose(content);\n    console.log(result);\n}"
        }
    },
    "198": {
        "title": "House Robber",
        "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
        "example": "Example:\n\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.",
        "level": "Medium",
        "tags": [
            "Dynamic Programming",
            "Array"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3,
                    1
                ],
                [
                    2,
                    7,
                    9,
                    3,
                    1
                ],
                [
                    2,
                    1,
                    1,
                    2
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    5,
                    10,
                    15,
                    20,
                    25
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9,
                    2,
                    4,
                    6,
                    8,
                    10
                ],
                [
                    10,
                    8,
                    6,
                    4,
                    2,
                    9,
                    7,
                    5,
                    3,
                    1
                ],
                [
                    1
                ],
                [
                    10
                ],
                [
                    0
                ],
                [
                    1,
                    2
                ],
                [
                    2,
                    1
                ],
                [
                    1,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    0
                ],
                [
                    1,
                    0,
                    0,
                    1
                ],
                [
                    0,
                    1,
                    1,
                    0
                ],
                [
                    1,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0
                ]
            ],
            "outputs": [
                4,
                12,
                4,
                3,
                40,
                0,
                30,
                30,
                30,
                30,
                1,
                10,
                0,
                2,
                2,
                2,
                1,
                2,
                2,
                5
            ]
        },
        "sample_code": {
            "c++": "int rob(vector<int>& nums) {\n    int prev1 = 0, prev2 = 0;\n    for (const auto& num : nums) {\n        int tmp = prev1;\n        prev1 = max(prev2 + num, prev1);\n        prev2 = tmp;\n    }\n    return prev1;\n}\n",
            "java": "public int rob(int[] nums) {\n    int prev1 = 0, prev2 = 0;\n    for (int num : nums) {\n        int temp = prev1;\n        prev1 = Math.max(prev2 + num, prev1);\n        prev2 = temp;\n    }\n    return prev1;\n}\n",
            "python": "def rob(nums):\n    prev1, prev2 = 0, 0\n    for num in nums:\n        prev1, prev2 = max(prev2 + num, prev1), prev1\n    return prev1\n",
            "javascript": "function rob(nums) {\n    let prev1 = 0, prev2 = 0;\n    for (let num of nums) {\n        let temp = prev1;\n        prev1 = Math.max(prev2 + num, prev1);\n        prev2 = temp;\n    }\n    return prev1;\n}\n",
            "explanation": "We use dynamic programming, maintaining two variables `prev1` and `prev2`. `prev1` represents the maximum amount of money that can be robbed up to the current house, and `prev2` represents the maximum amount of money that can be robbed up to the house before the current house (because we cannot rob two adjacent houses). \n\nAt each house, we calculate the updated maximum amount of money that can be robbed up to the current house. This can be either the sum of the current house's money and the maximum amount of money that can be robbed up to the house before the current house (which is stored in `prev2`) or the maximum amount of money that can be robbed up to the previous house (which is stored in `prev1`). We pick the greater one and update `prev1` accordingly. At the same time, we update `prev2` by setting it to the old `prev1` value.\n\nBy the end of the loop, `prev1` will represent the maximum amount of money that can be robbed without alerting the police, which we return."
        },
        "structure": {
            "c++": "int rob(vector<int>& nums) \n    // Your code here\n}\n",
            "java": "public int rob(int[] nums) \n    // Your code here\n}\n",
            "python": "def rob(nums):\n    # Your code here\n\n",
            "javascript": "function rob(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> nums = $args;\n    int result = rob(nums);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int rob(int[] nums) {\n    int prev1 = 0, prev2 = 0;\n    for (int num : nums) {\n        int temp = prev1;\n        prev1 = Math.max(prev2 + num, prev1);\n        prev2 = temp;\n    }\n    return prev1;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = rob(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = rob(nums);\n    console.log(result);\n}"
        }
    },
    "200": {
        "title": "Number of Islands",
        "description": "Given an `m x n` 2D binary grid `grid` which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
        "example": "Example:\n\nInput: grid = [\n  [\"1\", \"1\", \"1\", \"1\", \"0\"],\n  [\"1\", \"1\", \"0\", \"1\", \"0\"],\n  [\"1\", \"1\", \"0\", \"0\", \"0\"],\n  [\"0\", \"0\", \"0\", \"0\", \"0\"]\n]\nOutput: 1\n\nInput: grid = [\n  [\"1\", \"1\", \"0\", \"0\", \"0\"],\n  [\"1\", \"1\", \"0\", \"0\", \"0\"],\n  [\"0\", \"0\", \"1\", \"0\", \"0\"],\n  [\"0\", \"0\", \"0\", \"1\", \"1\"]\n]\nOutput: 3",
        "level": "Medium",
        "tags": [
            "Array",
            "Graph",
            "DFS",
            "BFS"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "1",
                        "1",
                        "1",
                        "1",
                        "0"
                    ],
                    [
                        "1",
                        "1",
                        "0",
                        "1",
                        "0"
                    ],
                    [
                        "1",
                        "1",
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "0",
                        "0",
                        "0",
                        "0",
                        "0"
                    ]
                ],
                [
                    [
                        "1",
                        "1",
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "1",
                        "1",
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "0",
                        "0",
                        "1",
                        "0",
                        "0"
                    ],
                    [
                        "0",
                        "0",
                        "0",
                        "1",
                        "1"
                    ]
                ],
                [
                    [
                        "1",
                        "0",
                        "1",
                        "0",
                        "1"
                    ],
                    [
                        "0",
                        "1",
                        "0",
                        "1",
                        "0"
                    ],
                    [
                        "1",
                        "0",
                        "1",
                        "0",
                        "1"
                    ],
                    [
                        "0",
                        "1",
                        "0",
                        "1",
                        "0"
                    ]
                ],
                [
                    [
                        "1",
                        "1",
                        "1",
                        "1",
                        "1"
                    ],
                    [
                        "1",
                        "1",
                        "1",
                        "1",
                        "1"
                    ],
                    [
                        "1",
                        "1",
                        "1",
                        "1",
                        "1"
                    ],
                    [
                        "1",
                        "1",
                        "1",
                        "1",
                        "1"
                    ]
                ],
                [
                    [
                        "0",
                        "0",
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "0",
                        "0",
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "0",
                        "0",
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "0",
                        "0",
                        "0",
                        "0",
                        "0"
                    ]
                ]
            ],
            "outputs": [
                1,
                3,
                8,
                1,
                0
            ]
        },
        "sample_code": {
            "c++": "void dfs(vector<vector<char>>& grid, int i, int j) {\n    if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == '0')\n        return;\n\n    grid[i][j] = '0';\n    dfs(grid, i + 1, j);\n    dfs(grid, i - 1, j);\n    dfs(grid, i, j + 1);\n    dfs(grid, i, j - 1);\n}\n\nint numIslands(vector<vector<char>>& grid) {\n    int count = 0;\n    for(int i = 0; i < grid.size(); i++) {\n        for(int j = 0; j < grid[0].size(); j++) {\n            if(grid[i][j] == '1') {\n                count++;\n                dfs(grid, i, j);\n            }\n        }\n    }\n    return count;\n}\n",
            "java": "class Solution {\n    private void dfs(char[][] grid, int i, int j) {\n        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == '0')\n            return;\n\n        grid[i][j] = '0';\n        dfs(grid, i + 1, j);\n        dfs(grid, i - 1, j);\n        dfs(grid, i, j + 1);\n        dfs(grid, i, j - 1);\n    }\n\n    public int numIslands(char[][] grid) {\n        int count = 0;\n        for(int i = 0; i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length; j++) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return count;\n    }\n}\n",
            "python": "def dfs(grid, i, j):\n    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':\n        return\n\n    grid[i][j] = '0'\n    dfs(grid, i + 1, j)\n    dfs(grid, i - 1, j)\n    dfs(grid, i, j + 1)\n    dfs(grid, i, j - 1)\n\ndef numIslands(grid):\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(grid, i, j)\n    return count\n",
            "javascript": "function dfs(grid, i, j) {\n    if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0')\n        return;\n\n    grid[i][j] = '0';\n    dfs(grid, i + 1, j);\n    dfs(grid, i - 1, j);\n    dfs(grid, i, j + 1);\n    dfs(grid, i, j - 1);\n}\n\nfunction numIslands(grid) {\n    let count = 0;\n    for(let i = 0; i < grid.length; i++) {\n        for(let j = 0; j < grid[0].length; j++) {\n            if(grid[i][j] === '1') {\n                count++;\n                dfs(grid, i, j);\n            }\n        }\n    }\n    return count;\n}\n",
            "explanation": "The base algorithm is depth-first search (DFS). The idea is to loop through the entire grid and for each cell with a value of '1', increment the island count by 1 and run the DFS algorithm starting on this cell. During the DFS traversal, we modify the grid by setting the visited cells containing '1' to '0', which will avoid visiting the same land cell again. The DFS traversal stops when the boundaries of the grid are reached or a '0' cell is hit. The DFS runs recursively on the neighboring cells (up, down, left, and right) of the current cell.\n\nThe time complexity of this algorithm is O(m * n) since we may have to visit every cell in the worst case, where m and n are the row and column dimensions of the grid."
        },
        "structure": {
            "c++": "void dfs(vector<vector<char>>& grid, int i, int j) \n    // Your code here\n}\n",
            "java": "class Solution \n    // Your code here\n}\n",
            "python": "def dfs(grid, i, j):\n    # Your code here\n\n",
            "javascript": "function dfs(grid, i, j) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "void dfs(vector<vector<char>>& grid, int i, int j) {\n    if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == '0')\n        return;\n\n    grid[i][j] = '0';\n    dfs(grid, i + 1, j);\n    dfs(grid, i - 1, j);\n    dfs(grid, i, j + 1);\n    dfs(grid, i, j - 1);\n}\n\nint numIslands(vector<vector<char>>& grid) {\n    int count = 0;\n    for(int i = 0; i < grid.size(); i++) {\n        for(int j = 0; j < grid[0].size(); j++) {\n            if(grid[i][j] == '1') {\n                count++;\n                dfs(grid, i, j);\n            }\n        }\n    }\n    return count;\n}",
            "java": "public int numIslands(char[][] grid) {\n        int count = 0;\n        for(int i = 0; i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length; j++) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return count;\n    }",
            "python": "if __name__ == \"__main__\":\n    grid = $args\n    result = numIslands(grid)\n    print(result)",
            "javascript": "function main() {\n    const grid = $args;\n    const result = numIslands(grid);\n    console.log(result);\n}"
        }
    },
    "202": {
        "title": "Happy Number",
        "description": "Write a function to determine if a number `n` is a happy number. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy.",
        "example": "Example 1:\n\nInput: n = 19\nOutput: true\nExplanation: 1^2 + 9^2 = 82, 8^2 + 2^2 = 68, 6^2 + 8^2 = 100, 1^2 + 0^2 + 0^2 = 1\n\nExample 2:\n\nInput: n = 2\nOutput: false",
        "level": "Easy",
        "tags": [
            "Math",
            "Recursion"
        ],
        "test_cases": {
            "inputs": [
                19,
                2,
                7,
                10,
                13,
                20,
                23,
                28,
                31,
                32,
                44,
                49,
                68,
                70,
                79,
                82,
                86,
                91,
                94,
                97
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                true,
                false,
                true,
                true,
                false,
                false,
                false,
                true,
                true,
                false,
                true,
                true,
                false,
                false,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "int getNext(int n) {\n    int sum = 0;\n    while (n > 0) {\n        int digit = n % 10;\n        sum += digit * digit;\n        n /= 10;\n    }\n    return sum;\n}\n\nbool isHappy(int n) {\n    int slow = n, fast = getNext(n);\n    while (fast != 1 && slow != fast) {\n        slow = getNext(slow);\n        fast = getNext(getNext(fast));\n    }\n    return fast == 1;\n}\n",
            "java": "public int getNext(int n) {\n    int sum = 0;\n    while (n > 0) {\n        int digit = n % 10;\n        sum += digit * digit;\n        n /= 10;\n    }\n    return sum;\n}\n\npublic boolean isHappy(int n) {\n    int slow = n, fast = getNext(n);\n    while (fast != 1 && slow != fast) {\n        slow = getNext(slow);\n        fast = getNext(getNext(fast));\n    }\n    return fast == 1;\n}\n",
            "python": "def get_next(n):\n    sum = 0\n    while n > 0:\n        digit = n % 10\n        sum += digit * digit\n        n //= 10\n    return sum\n\ndef is_happy(n):\n    slow, fast = n, get_next(n)\n    while fast != 1 and slow != fast:\n        slow = get_next(slow)\n        fast = get_next(get_next(fast))\n    return fast == 1\n",
            "javascript": "function getNext(n) {\n    let sum = 0;\n    while (n > 0) {\n        let digit = n % 10;\n        sum += digit * digit;\n        n = Math.floor(n / 10);\n    }\n    return sum;\n}\n\nfunction isHappy(n) {\n    let slow = n, fast = getNext(n);\n    while (fast !== 1 && slow !== fast) {\n        slow = getNext(slow);\n        fast = getNext(getNext(fast));\n    }\n    return fast === 1;\n}\n",
            "explanation": "The algorithm to determine if a number is happy repeatedly performs the sum of the squares of its digits. We can use the slow and fast pointer method (also called the Floyd's cycle-finding algorithm). In this method, we have two pointers (`slow` and `fast`), both initially pointing to the input number `n`. In each iteration, the `slow` pointer moves to the next number in the sequence (by calling `getNext()`) while the `fast` pointer moves to the next of next number in the sequence. If at any point, we find that the `fast` pointer becomes 1, it implies that the number is a happy number. If the `slow` and `fast` pointers become equal and it is not 1, it implies that there is a cycle and the number is not a happy number.\n\n`getNext(n)` function calculates the next number in the sequence by summing the squares of the digits of the current number `n`. This function is called in the main `isHappy(n)` function for updating `slow` and `fast` pointers."
        },
        "structure": {
            "c++": "int getNext(int n) \n    // Your code here\n}\n",
            "java": "public int getNext(int n) \n    // Your code here\n}\n",
            "python": "def get_next(n):\n    # Your code here\n\n",
            "javascript": "function getNext(n) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    bool result = isHappy(n);\n    cout << boolalpha << result << endl;\n    return 0;\n}",
            "java": "public boolean isHappy(int n) {\n    int slow = n, fast = getNext(n);\n    while (fast != 1 && slow != fast) {\n        slow = getNext(slow);\n        fast = getNext(getNext(fast));\n    }\n    return fast == 1;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = is_happy(n)\n    print(result)"
        }
    },
    "204": {
        "title": "Count Prime Numbers",
        "description": "Given an integer `n`, return the number of prime numbers that are strictly less than `n`.",
        "example": "Example 1:\n\nInput: n = 10\nOutput: 4\nExplanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.",
        "level": "Easy",
        "tags": [
            "Math",
            "Prime Numbers"
        ],
        "test_cases": {
            "inputs": [
                10,
                0,
                1,
                20,
                100,
                1000,
                10000,
                100000,
                1000000,
                5000000
            ],
            "outputs": [
                4,
                0,
                0,
                8,
                25,
                168,
                1229,
                9592,
                78498,
                348513
            ]
        },
        "sample_code": {
            "c++": "int countPrimes(int n) {\n    if (n <= 2) return 0;\n    vector<bool> isPrime(n, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i * i < n; ++i) {\n        if (isPrime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    return count(isPrime.begin(), isPrime.end(), true);\n}\n",
            "java": "public int countPrimes(int n) {\n    if (n <= 2) return 0;\n    boolean[] isPrime = new boolean[n];\n    Arrays.fill(isPrime, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i * i < n; i++) {\n        if (isPrime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    int count = 0;\n    for (boolean prime : isPrime) {\n        if (prime) count++;\n    }\n    return count;\n}\n",
            "python": "def countPrimes(n: int) -> int:\n    if n <= 2:\n        return 0\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    return sum(is_prime)\n",
            "javascript": "function countPrimes(n) {\n    if (n <= 2) return 0;\n    const isPrime = Array(n).fill(true);\n    isPrime[0] = isPrime[1] = false;\n    for (let i = 2; i * i < n; i++) {\n        if (isPrime[i]) {\n            for (let j = i * i; j < n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    return isPrime.filter(prime => prime).length;\n}\n",
            "explanation": "1. Initialize an array of booleans with value `true` and named `isPrime` to keep track of prime numbers from 0 to `n`.\n2. Set `isPrime[0]` and `isPrime[1]` to `false` since 0 and 1 are not prime numbers.\n3. Loop through numbers from 2 to the square root of `n`, and for each `i` that is still marked `true` in the `isPrime` array, loop through all its multiples starting from `i*i` (skipping `i` itself) and mark them as `false` because they won't be prime since they are divisible by `i`.\n4. Count all `true` values remaining in the `isPrime` array which indicates the count of prime numbers less than `n`."
        },
        "structure": {
            "c++": "int countPrimes(int n) \n    // Your code here\n}\n",
            "java": "public int countPrimes(int n) \n    // Your code here\n}\n",
            "python": "def countPrimes(n: int) -> int:\n    # Your code here\n\n",
            "javascript": "function countPrimes(n) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = countPrimes(n);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = countPrimes(n)\n    print(result)"
        }
    },
    "205": {
        "title": "Isomorphic Strings",
        "description": "Given two strings `s` and `t`, determine if they are isomorphic. Two strings `s` and `t` are isomorphic if the characters in `s` can be replaced to get `t`. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.",
        "example": "Example:\n\nInput: s = \"egg\", t = \"add\"\nOutput: true\n\nExplanation: The characters 'e' and 'a' can be replaced with 'a'. The characters 'g' and 'd' can be replaced with 'd'. Therefore, the strings 'egg' and 'add' are isomorphic.\n\nInput: s = \"foo\", t = \"bar\"\nOutput: false\n\nExplanation: The characters 'f' and 'b' cannot be replaced with the same character. Therefore, the strings 'foo' and 'bar' are not isomorphic.",
        "level": "Easy",
        "tags": [
            "String",
            "Hash Table"
        ],
        "test_cases": {
            "inputs": [
                [
                    "egg",
                    "add"
                ],
                [
                    "foo",
                    "bar"
                ],
                [
                    "paper",
                    "title"
                ],
                [
                    "ab",
                    "aa"
                ],
                [
                    "ab",
                    "cd"
                ],
                [
                    "abcd",
                    "efgh"
                ],
                [
                    "abcd",
                    "aabb"
                ],
                [
                    "abcd",
                    "abcd"
                ],
                [
                    "abcd",
                    "abcc"
                ],
                [
                    "abcd",
                    "abca"
                ],
                [
                    "abcd",
                    "abcb"
                ],
                [
                    "abcd",
                    "abcc"
                ],
                [
                    "abcd",
                    "abca"
                ],
                [
                    "abcd",
                    "abcb"
                ],
                [
                    "abcd",
                    "abcc"
                ],
                [
                    "abcd",
                    "abca"
                ],
                [
                    "abcd",
                    "abcb"
                ],
                [
                    "abcd",
                    "abcc"
                ],
                [
                    "abcd",
                    "abca"
                ],
                [
                    "abcd",
                    "abcb"
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                false,
                true,
                true,
                false,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "#include <unordered_map>\n\nbool isIsomorphic(std::string s, std::string t) {\n    std::unordered_map<char, char> map1, map2;\n    for (size_t i = 0; i < s.size(); ++i) {\n        if (map1.find(s[i]) == map1.end()) {\n            map1[s[i]] = t[i];\n        }\n        if (map2.find(t[i]) == map2.end()) {\n            map2[t[i]] = s[i];\n        }\n        if (map1[s[i]] != t[i] || map2[t[i]] != s[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n",
            "java": "import java.util.HashMap;\n\npublic boolean isIsomorphic(String s, String t) {\n    HashMap<Character, Character> map1 = new HashMap<>();\n    HashMap<Character, Character> map2 = new HashMap<>();\n    \n    for (int i = 0; i < s.length(); i++) {\n        char sChar = s.charAt(i);\n        char tChar = t.charAt(i);\n        \n        if (!map1.containsKey(sChar)) {\n            map1.put(sChar, tChar);\n        }\n        if (!map2.containsKey(tChar)) {\n            map2.put(tChar, sChar);\n        }\n        \n        if (map1.get(sChar) != tChar || map2.get(tChar) != sChar) {\n           return false;\n        }\n    }\n    return true;\n}\n",
            "python": "def is_isomorphic(s: str, t: str) -> bool:\n    map1, map2 = {}, {}\n    for char_s, char_t in zip(s, t):\n        if char_s not in map1:\n            map1[char_s] = char_t\n        if char_t not in map2:\n            map2[char_t] = char_s\n        if map1[char_s] != char_t or map2[char_t] != char_s:\n            return False\n    return True\n",
            "javascript": "function isIsomorphic(s, t) {\n    let map1 = new Map();\n    let map2 = new Map();\n    for (let i = 0; i < s.length; i++) {\n        let sChar = s[i];\n        let tChar = t[i];\n\n        if (!map1.has(sChar)) {\n            map1.set(sChar, tChar);\n        }\n        if (!map2.has(tChar)) {\n            map2.set(tChar, sChar);\n        }\n\n        if (map1.get(sChar) !== tChar || map2.get(tChar) !== sChar) {\n            return false;\n        }\n    }\n    return true;\n}\n",
            "explanation": "- Create two maps (or hash_maps) to store the mappings for characters in `s` to `t` and characters in `t` to `s`.\n- Iterate through the characters of `s` and `t`.\n- If the current character of `s` is not a key in the first map, add it with the corresponding character of `t` as the value.\n- If the current character of `t` is not a key in the second map, add it with the corresponding character of `s` as the value.\n- If the maps have inconsistent mappings, return false (they are not isomorphic).\n- If the loop is over without finding inconsistent mappings, return true (the strings are isomorphic)."
        },
        "structure": {
            "c++": "#include <unordered_map>\n\nbool isIsomorphic(std::string s, std::string t) \n    // Your code here\n}\n",
            "java": "import java.util.HashMap;\n\npublic boolean isIsomorphic(String s, String t) \n    // Your code here\n}\n",
            "python": "def is_isomorphic(s: str, t: str) -> bool:\n    # Your code here\n\n",
            "javascript": "function isIsomorphic(s, t) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <unordered_map>\n#include <iostream>\n\nbool isIsomorphic(std::string s, std::string t);\n\nint main() {\n    std::string s = $args;\n    std::string t = $args;\n    bool result = isIsomorphic(s, t);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}\n\nbool isIsomorphic(std::string s, std::string t) {\n    std::unordered_map<char, char> map1, map2;\n    for (size_t i = 0; i < s.size(); ++i) {\n        if (map1.find(s[i]) == map1.end()) {\n            map1[s[i]] = t[i];\n        }\n        if (map2.find(t[i]) == map2.end()) {\n            map2[t[i]] = s[i];\n        }\n        if (map1[s[i]] != t[i] || map2[t[i]] != s[i]) {\n            return false;\n        }\n    }\n    return true;\n}",
            "java": "public boolean isIsomorphic(String s, String t) {\n    HashMap<Character, Character> map1 = new HashMap<>();\n    HashMap<Character, Character> map2 = new HashMap<>();\n    \n    for (int i = 0; i < s.length(); i++) {\n        char sChar = s.charAt(i);\n        char tChar = t.charAt(i);\n        \n        if (!map1.containsKey(sChar)) {\n            map1.put(sChar, tChar);\n        }\n        if (!map2.containsKey(tChar)) {\n            map2.put(tChar, sChar);\n        }\n        \n        if (map1.get(sChar) != tChar || map2.get(tChar) != sChar) {\n           return false;\n        }\n    }\n    return true;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    s = inputs[0]\n    t = inputs[1]\n    result = is_isomorphic(s, t)\n    print(result)",
            "javascript": "function isIsomorphic(s, t) {\n    let map1 = new Map();\n    let map2 = new Map();\n    for (let i = 0; i < s.length; i++) {\n        let sChar = s[i];\n        let tChar = t[i];\n\n        if (!map1.has(sChar)) {\n            map1.set(sChar, tChar);\n        }\n        if (!map2.has(tChar)) {\n            map2.set(tChar, sChar);\n        }\n\n        if (map1.get(sChar) !== tChar || map2.get(tChar) !== sChar) {\n            return false;\n        }\n    }\n    return true;\n}"
        }
    },
    "207": {
        "title": "Course Prerequisites",
        "description": "You are given a total of `numCourses` courses labeled from `0` to `numCourses - 1`. The prerequisites for each course are given in the form of an array `prerequisites`, where `prerequisites[i] = [ai, bi]` indicates that course `bi` must be taken before course `ai`. Determine if it is possible to finish all the courses.",
        "example": "For example, given `numCourses = 2` and `prerequisites = [[1,0]]`, you can finish all the courses. To take course 1, you need to have finished course 0. Therefore, the output would be `true`.\n\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: true\n\nGiven `numCourses = 2` and `prerequisites = [[1,0],[0,1]]`, it is impossible to finish all the courses. To take course 1, you need to have finished course 0, and to take course 0, you need to have finished course 1. Therefore, the output would be `false`.\n\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\nOutput: false",
        "level": "Medium",
        "tags": [
            "Graphs",
            "Topological Sort"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    [
                        [
                            1,
                            0
                        ]
                    ]
                ],
                [
                    2,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            0,
                            1
                        ]
                    ]
                ],
                [
                    3,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ]
                    ]
                ],
                [
                    4,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ]
                    ]
                ],
                [
                    4,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            0,
                            3
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            0,
                            4
                        ]
                    ]
                ],
                [
                    6,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ]
                    ]
                ],
                [
                    6,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            0,
                            5
                        ]
                    ]
                ],
                [
                    7,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            6,
                            5
                        ]
                    ]
                ],
                [
                    7,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            6,
                            5
                        ],
                        [
                            0,
                            6
                        ]
                    ]
                ],
                [
                    8,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            6,
                            5
                        ],
                        [
                            7,
                            6
                        ]
                    ]
                ],
                [
                    8,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            6,
                            5
                        ],
                        [
                            7,
                            6
                        ],
                        [
                            0,
                            7
                        ]
                    ]
                ],
                [
                    9,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            6,
                            5
                        ],
                        [
                            7,
                            6
                        ],
                        [
                            8,
                            7
                        ]
                    ]
                ],
                [
                    9,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            6,
                            5
                        ],
                        [
                            7,
                            6
                        ],
                        [
                            8,
                            7
                        ],
                        [
                            0,
                            8
                        ]
                    ]
                ],
                [
                    10,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            6,
                            5
                        ],
                        [
                            7,
                            6
                        ],
                        [
                            8,
                            7
                        ],
                        [
                            9,
                            8
                        ]
                    ]
                ],
                [
                    10,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            6,
                            5
                        ],
                        [
                            7,
                            6
                        ],
                        [
                            8,
                            7
                        ],
                        [
                            9,
                            8
                        ],
                        [
                            0,
                            9
                        ]
                    ]
                ],
                [
                    2000,
                    []
                ],
                [
                    2000,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            6,
                            5
                        ],
                        [
                            7,
                            6
                        ],
                        [
                            8,
                            7
                        ],
                        [
                            9,
                            8
                        ],
                        [
                            0,
                            9
                        ]
                    ]
                ],
                [
                    2000,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            6,
                            5
                        ],
                        [
                            7,
                            6
                        ],
                        [
                            8,
                            7
                        ],
                        [
                            9,
                            8
                        ],
                        [
                            0,
                            9
                        ],
                        [
                            10,
                            11
                        ],
                        [
                            11,
                            12
                        ],
                        [
                            12,
                            13
                        ],
                        [
                            13,
                            14
                        ],
                        [
                            14,
                            15
                        ],
                        [
                            15,
                            16
                        ],
                        [
                            16,
                            17
                        ],
                        [
                            17,
                            18
                        ],
                        [
                            18,
                            19
                        ],
                        [
                            19,
                            20
                        ]
                    ]
                ],
                [
                    2000,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            6,
                            5
                        ],
                        [
                            7,
                            6
                        ],
                        [
                            8,
                            7
                        ],
                        [
                            9,
                            8
                        ],
                        [
                            0,
                            9
                        ],
                        [
                            10,
                            11
                        ],
                        [
                            11,
                            12
                        ],
                        [
                            12,
                            13
                        ],
                        [
                            13,
                            14
                        ],
                        [
                            14,
                            15
                        ],
                        [
                            15,
                            16
                        ],
                        [
                            16,
                            17
                        ],
                        [
                            17,
                            18
                        ],
                        [
                            18,
                            19
                        ],
                        [
                            19,
                            20
                        ],
                        [
                            20,
                            21
                        ],
                        [
                            21,
                            22
                        ],
                        [
                            22,
                            23
                        ],
                        [
                            23,
                            24
                        ],
                        [
                            24,
                            25
                        ],
                        [
                            25,
                            26
                        ],
                        [
                            26,
                            27
                        ],
                        [
                            27,
                            28
                        ],
                        [
                            28,
                            29
                        ],
                        [
                            29,
                            30
                        ]
                    ]
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                true,
                false
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <queue>\n\nbool canFinish(int numCourses, std::vector<std::vector<int>>& prerequisites) {\n    std::vector<std::vector<int>> adj(numCourses);\n    std::vector<int> inDegree(numCourses, 0);\n    \n    for (auto& p : prerequisites) {\n        adj[p[1]].push_back(p[0]);\n        inDegree[p[0]]++;\n    }\n    \n    std::queue<int> q;\n    for (int i = 0; i < numCourses; i++) {\n        if (inDegree[i] == 0) q.push(i);\n    }\n    \n    while (!q.empty()) {\n        int currCourse = q.front();\n        q.pop();\n        numCourses--;\n        \n        for (int nextCourse : adj[currCourse]) {\n            inDegree[nextCourse]--;\n            if (inDegree[nextCourse] == 0) q.push(nextCourse);\n        }\n    }\n    \n    return numCourses == 0;\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic boolean canFinish(int numCourses, int[][] prerequisites) {\n    List<List<Integer>> adj = new ArrayList<>(numCourses);\n    int[] inDegree = new int[numCourses];\n    \n    for (int i = 0; i < numCourses; i++)\n        adj.add(new ArrayList<>());\n    \n    for (int[] p : prerequisites) {\n        adj.get(p[1]).add(p[0]);\n        inDegree[p[0]]++;\n    }\n    \n    Queue<Integer> q = new LinkedList<>();\n    for (int i = 0; i < numCourses; i++) {\n        if (inDegree[i] == 0) q.add(i);\n    }\n    \n    while (!q.isEmpty()) {\n        int currCourse = q.poll();\n        numCourses--;\n        \n        for (int nextCourse : adj.get(currCourse)) {\n            inDegree[nextCourse]--;\n            if (inDegree[nextCourse] == 0) q.add(nextCourse);\n        }\n    }\n    \n    return numCourses == 0;\n}\n\n",
            "python": "from collections import defaultdict, deque\n\ndef canFinish(numCourses, prerequisites):\n    adj = defaultdict(list)\n    inDegree = [0] * numCourses\n    \n    for a, b in prerequisites:\n        adj[b].append(a)\n        inDegree[a] += 1\n    \n    q = deque([i for i in range(numCourses) if inDegree[i]==0])\n    \n    while q:\n        currCourse = q.popleft()\n        numCourses -= 1\n        \n        for nextCourse in adj[currCourse]:\n            inDegree[nextCourse] -= 1\n            if inDegree[nextCourse] == 0:\n                q.append(nextCourse)\n    \n    return numCourses == 0\n\n",
            "javascript": "function canFinish(numCourses, prerequisites) {\n    let adj = Array.from(Array(numCourses), () => []);\n    let inDegree = Array(numCourses).fill(0);\n    \n    for (let [a, b] of prerequisites) {\n        adj[b].push(a);\n        inDegree[a]++;\n    }\n    \n    let q = [];\n    for (let i = 0; i < numCourses; i++) {\n        if (inDegree[i] === 0) q.push(i);\n    }\n    \n    while (q.length) {\n        const currCourse = q.shift();\n        numCourses--;\n        \n        for (let nextCourse of adj[currCourse]) {\n            inDegree[nextCourse]--;\n            if (inDegree[nextCourse] === 0) q.push(nextCourse);\n        }\n    }\n    \n    return numCourses === 0;\n}\n\n",
            "explanation": "The algorithm uses the topological sorting approach utilizing Kahn's Algorithm to solve this problem. We maintain an adjacency list to represent the graph and a list of in-degrees for each vertex (course) Mark the vertices with in-degree 0 and add them to a queue (these are starter courses). Then, we process each node (course) in the queue, decrease in-degrees of their neighbors (courses they unlock). If the in-degree of any neighbor becomes 0, add it to the queue. In the end, if we have processed all courses, return true; otherwise, return false if any course is not processed."
        },
        "structure": {
            "c++": "#include <vector>\n#include <queue>\n\nbool canFinish(int numCourses, std::vector<std::vector<int>>& prerequisites) \n    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic boolean canFinish(int numCourses, int[][] prerequisites) \n    // Your code here\n}\n\n",
            "python": "from collections import defaultdict, deque\n    # Your code here\n\n",
            "javascript": "function canFinish(numCourses, prerequisites) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <queue>\n#include <iostream>\n\nint main() {\n    int numCourses = $args;\n    std::vector<std::vector<int>> prerequisites;\n    bool result = canFinish(numCourses, prerequisites);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}\n",
            "java": "public boolean canFinish(int numCourses, int[][] prerequisites) {\n    List<List<Integer>> adj = new ArrayList<>(numCourses);\n    int[] inDegree = new int[numCourses];\n    \n    for (int i = 0; i < numCourses; i++)\n        adj.add(new ArrayList<>());\n    \n    for (int[] p : prerequisites) {\n        adj.get(p[1]).add(p[0]);\n        inDegree[p[0]]++;\n    }\n    \n    Queue<Integer> q = new LinkedList<>();\n    for (int i = 0; i < numCourses; i++) {\n        if (inDegree[i] == 0) q.add(i);\n    }\n    \n    while (!q.isEmpty()) {\n        int currCourse = q.poll();\n        numCourses--;\n        \n        for (int nextCourse : adj.get(currCourse)) {\n            inDegree[nextCourse]--;\n            if (inDegree[nextCourse] == 0) q.add(nextCourse);\n        }\n    }\n    \n    return numCourses == 0;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    numCourses = inputs[0]\n    prerequisites = inputs[1]\n    result = canFinish(numCourses, prerequisites)\n    print(result)",
            "javascript": "function main() {\n    const numCourses = $args[0];\n    const prerequisites = $args[1];\n    const result = canFinish(numCourses, prerequisites);\n    console.log(result);\n}"
        }
    },
    "209": {
        "title": "Minimal Length of Subarray",
        "description": "Given an array of positive integers `nums` and a positive integer `target`, find the minimal length of a subarray whose sum is greater than or equal to the target. If there is no such subarray, return 0 instead.",
        "example": "Example:\n\nInput: target = 7, nums = [2,3,1,2,4,3]\nOutput: 2\nExplanation: The subarray [4,3] has the minimal length under the problem constraint.",
        "level": "Medium",
        "tags": [
            "array",
            "sliding window"
        ],
        "test_cases": {
            "inputs": [
                [
                    7,
                    [
                        2,
                        3,
                        1,
                        2,
                        4,
                        3
                    ]
                ],
                [
                    4,
                    [
                        1,
                        4,
                        4
                    ]
                ],
                [
                    11,
                    [
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1
                    ]
                ],
                [
                    5,
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ]
                ],
                [
                    10,
                    [
                        5,
                        5,
                        5,
                        5,
                        5
                    ]
                ],
                [
                    3,
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ]
                ],
                [
                    8,
                    [
                        2,
                        2,
                        2,
                        2,
                        2,
                        2,
                        2,
                        2
                    ]
                ],
                [
                    6,
                    [
                        1,
                        2,
                        3
                    ]
                ],
                [
                    9,
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9
                    ]
                ],
                [
                    15,
                    [
                        10,
                        5,
                        3,
                        2,
                        1
                    ]
                ]
            ],
            "outputs": [
                2,
                1,
                0,
                1,
                1,
                0,
                1,
                1,
                1,
                1
            ]
        },
        "sample_code": {
            "c++": "#include <climits>\nint minSubArrayLen(int target, vector<int>& nums) {\n    int left = 0, cur_sum = 0, min_len = INT_MAX;\n    for (int right = 0; right < nums.size(); right++) {\n        cur_sum += nums[right];\n        while (cur_sum >= target) {\n            min_len = min(min_len, right - left + 1);\n            cur_sum -= nums[left++];\n        }\n    }\n    return min_len == INT_MAX ? 0 : min_len;\n}\n",
            "java": "public int minSubArrayLen(int target, int[] nums) {\n    int left = 0, cur_sum = 0, min_len = Integer.MAX_VALUE;\n    for (int right = 0; right < nums.length; right++) {\n        cur_sum += nums[right];\n        while (cur_sum >= target) {\n            min_len = Math.min(min_len, right - left + 1);\n            cur_sum -= nums[left++];\n        }\n    }\n    return min_len == Integer.MAX_VALUE ? 0 : min_len;\n}\n",
            "python": "def minSubArrayLen(target: int, nums: list[int]) -> int:\n    left, cur_sum, min_len = 0, 0, float('inf')\n    for right in range(len(nums)):\n        cur_sum += nums[right]\n        while cur_sum >= target:\n            min_len = min(min_len, right - left + 1)\n            cur_sum -= nums[left]\n            left += 1\n    return min_len if min_len != float('inf') else 0\n",
            "javascript": "function minSubArrayLen(target, nums) {\n    let left = 0, cur_sum = 0, min_len = Number.MAX_VALUE;\n    for (let right = 0; right < nums.length; right++) {\n        cur_sum += nums[right];\n        while (cur_sum >= target) {\n            min_len = Math.min(min_len, right - left + 1);\n            cur_sum -= nums[left++];\n        }\n    }\n    return min_len === Number.MAX_VALUE ? 0 : min_len;\n}\n\n",
            "explanation": "The algorithm initializes pointers left and right, sum cur_sum, and minimum length min_len. The right pointer traverses nums. During traversal, update cur_sum by adding nums[right]. Then check if cur_sum is greater than or equal to target. If so, update min_len by comparing min_len and the length of the current subarray (right - left + 1). Then update cur_sum by subtracting nums[left] and increment the left pointer. Continue this process until the end of nums is reached. If min_len is still at its max value at the end, return 0. Otherwise, return min_len.\n\nThis algorithm uses a sliding window technique to iterate through the array while maintaining subarray sums greater than or equal to the target."
        },
        "structure": {
            "c++": "#include <climits>\nint minSubArrayLen(int target, vector<int>& nums) \n    // Your code here\n}\n",
            "java": "public int minSubArrayLen(int target, int[] nums) \n    // Your code here\n}\n",
            "python": "def minSubArrayLen(target: int, nums: List[int]) -> int:\n    # Your code here\n\n",
            "javascript": "function minSubArrayLen(target, nums) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <climits>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nint minSubArrayLen(int target, vector<int>& nums) {\n    int left = 0, cur_sum = 0, min_len = INT_MAX;\n    for (int right = 0; right < nums.size(); right++) {\n        cur_sum += nums[right];\n        while (cur_sum >= target) {\n            min_len = min(min_len, right - left + 1);\n            cur_sum -= nums[left++];\n        }\n    }\n    return min_len == INT_MAX ? 0 : min_len;\n}\n\nint main() {\n    int target = $args;\n    vector<int> nums = {1, 4, 4};\n    int result = minSubArrayLen(target, nums);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int minSubArrayLen(int target, int[] nums) {\n    int left = 0, cur_sum = 0, min_len = Integer.MAX_VALUE;\n    for (int right = 0; right < nums.length; right++) {\n        cur_sum += nums[right];\n        while (cur_sum >= target) {\n            min_len = Math.min(min_len, right - left + 1);\n            cur_sum -= nums[left++];\n        }\n    }\n    return min_len == Integer.MAX_VALUE ? 0 : min_len;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    target = inputs[0]\n    nums = inputs[1]\n    result = minSubArrayLen(target, nums)\n    print(result)"
        }
    },
    "210": {
        "title": "Course Ordering",
        "description": "You are given a total of `numCourses` courses labeled from `0` to `numCourses - 1`. The prerequisites for each course are given in the form of an array `prerequisites`, where `prerequisites[i] = [ai, bi]` indicates that course `bi` must be taken before course `ai`. Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them. If it is impossible to finish all courses, return an empty array.",
        "example": "Example:\n\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: [0,1]\nExplanation: To take course 1, you should have finished course 0. So the correct course order is [0,1].",
        "level": "Medium",
        "tags": [
            "Graph",
            "Topological Sort"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    [
                        [
                            1,
                            0
                        ]
                    ]
                ],
                [
                    4,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            3,
                            1
                        ],
                        [
                            3,
                            2
                        ]
                    ]
                ],
                [
                    1,
                    []
                ],
                [
                    3,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ]
                    ]
                ]
            ],
            "outputs": [
                [
                    0,
                    1
                ],
                [
                    0,
                    2,
                    1,
                    3
                ],
                [
                    0
                ],
                [
                    0,
                    1,
                    2
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n    vector<int> inDegree(numCourses, 0);\n    vector<vector<int>> adjList(numCourses);\n    \n    for (auto& p : prerequisites) {\n        adjList[p[1]].push_back(p[0]);\n        inDegree[p[0]]++;\n    }\n    \n    queue<int> q;\n    for (int i = 0; i < numCourses; i++) {\n        if (inDegree[i] == 0) {\n            q.push(i);\n        }\n    }\n    \n    vector<int> order;\n    \n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n        order.push_back(curr);\n        for (auto next : adjList[curr]) {\n            if (--inDegree[next] == 0) {\n                q.push(next);\n            }\n        }\n    }\n    \n    return (order.size() == numCourses) ? order : vector<int>();\n}\n\n",
            "java": "import java.util.*;\n\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\n    int[] inDegree = new int[numCourses];\n    List<List<Integer>> adjList = new ArrayList<>();\n    \n    for (int i = 0; i < numCourses; i++) {\n        adjList.add(new ArrayList<>());\n    }\n    \n    for (int[] p : prerequisites) {\n        adjList.get(p[1]).add(p[0]);\n        inDegree[p[0]]++;\n    }\n    \n    Queue<Integer> q = new LinkedList<>();\n    for (int i = 0; i < numCourses; i++) {\n        if (inDegree[i] == 0) {\n            q.offer(i);\n        }\n    }\n    \n    int[] order = new int[numCourses];\n    int index = 0;\n    \n    while (!q.isEmpty()) {\n        int curr = q.poll();\n        order[index++] = curr;\n        for (int next : adjList.get(curr)) {\n            if (--inDegree[next] == 0) {\n                q.offer(next);\n            }\n        }\n    }\n    \n    return (index == numCourses) ? order : new int[0];\n}\n\n",
            "python": "from collections import deque\n\ndef findOrder(numCourses, prerequisites):\n    in_degree = [0] * numCourses\n    adj_list = [[] for _ in range(numCourses)]\n    \n    for p in prerequisites:\n        adj_list[p[1]].append(p[0])\n        in_degree[p[0]] += 1\n    \n    q = deque([i for i in range(numCourses) if in_degree[i] == 0])\n    order = []\n    \n    while q:\n        curr = q.popleft()\n        order.append(curr)\n        for next in adj_list[curr]:\n            in_degree[next] -= 1\n            if in_degree[next] == 0:\n                q.append(next)\n    \n    return order if len(order) == numCourses else []\n\n",
            "javascript": "function findOrder(numCourses, prerequisites) {\n    const inDegree = new Array(numCourses).fill(0);\n    const adjList = Array.from({ length: numCourses }, () => []);\n    \n    for (const p of prerequisites) {\n        adjList[p[1]].push(p[0]);\n        inDegree[p[0]]++;\n    }\n    \n    const q = [];\n    for (let i = 0; i < numCourses; i++) {\n        if (inDegree[i] === 0) {\n            q.push(i);\n        }\n    }\n    \n    const order = [];\n    \n    while (q.length) {\n        const curr = q.shift();\n        order.push(curr);\n        for (const next of adjList[curr]) {\n            if (--inDegree[next] === 0) {\n                q.push(next);\n            }\n        }\n    }\n    \n    return (order.length === numCourses) ? order : [];\n}\n\n",
            "explanation": "This problem can be solved using the Topological Sort algorithm, which works in the following way:\n1. Calculate the in-degree (number of incoming edges) of each node/course (use an array called `inDegree`).\n2. Initialize an adjacency list, `adjList`, to store the outgoing courses from a prerequisite course.\n3. Fill `adjList` while iterating through the prerequisites array.\n4. Create a queue, `q`, and enqueue all the nodes whose in-degree is 0; these nodes represent the starting points in this topological sort.\n5. Initialize an array or list called `order` to store the final ordering.\n6. While `q` is not empty, perform the following steps:\n    - Dequeue the front node `curr`.\n    - Append `curr` to the `order`.\n    - Iterate through all the outgoing courses (neighbors) of `curr`. For each neighboring node `next`, decrease the in-degree of `next` by 1. If the in-degree of `next` becomes 0, enqueue `next` to `q`.\n7. Finally, if the length of the `order` is equal to the total number of courses, return the `order`. Otherwise, return an empty array/list, indicating that it is impossible to finish all the courses."
        },
        "structure": {
            "c++": "#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) \n    // Your code here\n}\n\n",
            "java": "import java.util.*;\n\npublic int[] findOrder(int numCourses, int[][] prerequisites) \n    // Your code here\n}\n\n",
            "python": "from collections import deque\n    # Your code here\n\n",
            "javascript": "function findOrder(numCourses, prerequisites) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <queue>\nusing namespace std;\n\nint main() {\n    int numCourses = $args;\n    vector<vector<int>> prerequisites;\n    // populate prerequisites vector\n    vector<int> result = findOrder(numCourses, prerequisites);\n    // print result\n    for (int i = 0; i < result.size(); i++) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n",
            "java": "public int[] findOrder(int numCourses, int[][] prerequisites) {\n    int[] inDegree = new int[numCourses];\n    List<List<Integer>> adjList = new ArrayList<>();\n    \n    for (int i = 0; i < numCourses; i++) {\n        adjList.add(new ArrayList<>());\n    }\n    \n    for (int[] p : prerequisites) {\n        adjList.get(p[1]).add(p[0]);\n        inDegree[p[0]]++;\n    }\n    \n    Queue<Integer> q = new LinkedList<>();\n    for (int i = 0; i < numCourses; i++) {\n        if (inDegree[i] == 0) {\n            q.offer(i);\n        }\n    }\n    \n    int[] order = new int[numCourses];\n    int index = 0;\n    \n    while (!q.isEmpty()) {\n        int curr = q.poll();\n        order[index++] = curr;\n        for (int next : adjList.get(curr)) {\n            if (--inDegree[next] == 0) {\n                q.offer(next);\n            }\n        }\n    }\n    \n    return (index == numCourses) ? order : new int[0];\n}",
            "python": "if __name__ == \"__main__\":\n    numCourses = $args[0]\n    prerequisites = $args[1]\n    result = findOrder(numCourses, prerequisites)\n    print(result)",
            "javascript": "function findOrder(numCourses, prerequisites) {\n    const inDegree = new Array(numCourses).fill(0);\n    const adjList = Array.from({ length: numCourses }, () => []);\n    \n    for (const p of prerequisites) {\n        adjList[p[1]].push(p[0]);\n        inDegree[p[0]]++;\n    }\n    \n    const q = [];\n    for (let i = 0; i < numCourses; i++) {\n        if (inDegree[i] === 0) {\n            q.push(i);\n        }\n    }\n    \n    const order = [];\n    \n    while (q.length) {\n        const curr = q.shift();\n        order.push(curr);\n        for (const next of adjList[curr]) {\n            if (--inDegree[next] === 0) {\n                q.push(next);\n            }\n        }\n    }\n    \n    return (order.length === numCourses) ? order : [];\n}"
        }
    },
    "212": {
        "title": "Word Search II",
        "description": "Given an `m x n` board of characters and a list of strings `words`, return all words on the board. Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.",
        "example": "Example 1:\n\nInput: board = [['o', 'a', 'a', 'n'], ['e', 't', 'a', 'e'], ['i', 'h', 'k', 'r'], ['i', 'f', 'l', 'v']], words = ['oath', 'pea', 'eat', 'rain']\nOutput: ['eat', 'oath']\n\nExample 2:\n\nInput: board = [['a', 'b'], ['c', 'd']], words = ['abcb']\nOutput: []",
        "level": "Medium",
        "tags": [
            "Array",
            "Backtracking",
            "Trie"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        [
                            "o",
                            "a",
                            "a",
                            "n"
                        ],
                        [
                            "e",
                            "t",
                            "a",
                            "e"
                        ],
                        [
                            "i",
                            "h",
                            "k",
                            "r"
                        ],
                        [
                            "i",
                            "f",
                            "l",
                            "v"
                        ]
                    ],
                    [
                        "oath",
                        "pea",
                        "eat",
                        "rain"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b"
                        ],
                        [
                            "c",
                            "d"
                        ]
                    ],
                    [
                        "abcb"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "abc",
                        "def",
                        "ghi"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "ab",
                        "de",
                        "gh"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "ab",
                        "cd",
                        "ef",
                        "gh",
                        "ij"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jkl"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jkl",
                        "mno"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jkl",
                        "mno",
                        "pqr"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jkl",
                        "mno",
                        "pqr",
                        "stu"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jkl",
                        "mno",
                        "pqr",
                        "stu",
                        "vwx"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jkl",
                        "mno",
                        "pqr",
                        "stu",
                        "vwx",
                        "yz"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "cba",
                        "fed",
                        "ihg"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "cba",
                        "fed",
                        "ihg",
                        "lkj"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "cba",
                        "fed",
                        "ihg",
                        "lkj",
                        "onm"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "cba",
                        "fed",
                        "ihg",
                        "lkj",
                        "onm",
                        "qrp"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "cba",
                        "fed",
                        "ihg",
                        "lkj",
                        "onm",
                        "qrp",
                        "tsu"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "cba",
                        "fed",
                        "ihg",
                        "lkj",
                        "onm",
                        "qrp",
                        "tsu",
                        "wvx"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "cba",
                        "fed",
                        "ihg",
                        "lkj",
                        "onm",
                        "qrp",
                        "tsu",
                        "wvx",
                        "zyx"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jkl",
                        "mno",
                        "pqr",
                        "stu",
                        "vwx",
                        "yz",
                        "cba",
                        "fed",
                        "ihg",
                        "lkj",
                        "onm",
                        "qrp",
                        "tsu",
                        "wvx",
                        "zyx"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "xyz",
                        "wvu",
                        "tsr",
                        "pon",
                        "mlk",
                        "ihg",
                        "fed",
                        "cba"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "xyz",
                        "wvu",
                        "tsr",
                        "pon",
                        "mlk",
                        "ihg",
                        "fed",
                        "cba",
                        "zyx",
                        "wvu",
                        "tsr",
                        "pon",
                        "mlk",
                        "ihg",
                        "fed",
                        "cba"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jkl",
                        "mno",
                        "pqr",
                        "stu",
                        "vwx",
                        "yz",
                        "cba",
                        "fed",
                        "ihg",
                        "lkj",
                        "onm",
                        "qrp",
                        "tsu",
                        "wvx",
                        "zyx",
                        "xyz",
                        "wvu",
                        "tsr",
                        "pon",
                        "mlk",
                        "ihg",
                        "fed",
                        "cba"
                    ]
                ]
            ],
            "outputs": [
                "['eat', 'oath']",
                "[]",
                "['abc', 'def', 'ghi']",
                "['ab', 'de', 'gh']",
                "['ab', 'cd', 'ef', 'gh', 'ij']",
                "['abc', 'def', 'ghi', 'jkl']",
                "['abc', 'def', 'ghi', 'jkl', 'mno']",
                "['abc', 'def', 'ghi', 'jkl', 'mno', 'pqr']",
                "['abc', 'def', 'ghi', 'jkl', 'mno', 'pqr', 'stu']",
                "['abc', 'def', 'ghi', 'jkl', 'mno', 'pqr', 'stu', 'vwx']",
                "['abc', 'def', 'ghi', 'jkl', 'mno', 'pqr', 'stu', 'vwx', 'yz']",
                "['cba', 'fed', 'ihg']",
                "['cba', 'fed', 'ihg', 'lkj']",
                "['cba', 'fed', 'ihg', 'lkj', 'onm']",
                "['cba', 'fed', 'ihg', 'lkj', 'onm', 'qrp']",
                "['cba', 'fed', 'ihg', 'lkj', 'onm', 'qrp', 'tsu']",
                "['cba', 'fed', 'ihg', 'lkj', 'onm', 'qrp', 'tsu', 'wvx']",
                "['cba', 'fed', 'ihg', 'lkj', 'onm', 'qrp', 'tsu', 'wvx', 'zyx']",
                "['abc', 'def', 'ghi', 'jkl', 'mno', 'pqr', 'stu', 'vwx', 'yz', 'cba', 'fed', 'ihg', 'lkj', 'onm', 'qrp', 'tsu', 'wvx', 'zyx']",
                "['xyz', 'wvu', 'tsr', 'pon', 'mlk', 'ihg', 'fed', 'cba']",
                "['xyz', 'wvu', 'tsr', 'pon', 'mlk', 'ihg', 'fed', 'cba', 'zyx', 'wvu', 'tsr', 'pon', 'mlk', 'ihg', 'fed', 'cba']",
                "['abc', 'def', 'ghi', 'jkl', 'mno', 'pqr', 'stu', 'vwx', 'yz', 'cba', 'fed', 'ihg', 'lkj', 'onm', 'qrp', 'tsu', 'wvx', 'zyx', 'xyz', 'wvu', 'tsr', 'pon', 'mlk', 'ihg', 'fed', 'cba']"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n\nvoid dfs(const std::vector<std::vector<char>>& board, const std::string& word, int index, int i, int j, std::vector<std::vector<bool>>& visited, bool& found){\n    if (index == word.length()) {\n        found = true;\n        return;\n    }\n    if (i < 0 || j < 0 || i >= board.size() || j >= board[0].size() || visited[i][j] || board[i][j] != word[index]){\n        return;\n    }\n    visited[i][j] = true;\n    dfs(board, word, index + 1, i - 1, j, visited, found);\n    dfs(board, word, index + 1, i + 1, j, visited, found);\n    dfs(board, word, index + 1, i, j - 1, visited, found);\n    dfs(board, word, index + 1, i, j + 1, visited, found);\n    visited[i][j] = false;\n}\n\nstd::vector<std::string> findWords(std::vector<std::vector<char>>& board, std::vector<std::string>& words) {\n    std::vector<std::string> result;\n    for (const auto& word : words) {\n        bool found = false;\n        std::vector<std::vector<bool>> visited(board.size(), std::vector<bool>(board[0].size(), false));\n        for (int i = 0; i < board.size() && !found; ++i) {\n            for (int j = 0; j < board[0].size() && !found; ++j) {\n                dfs(board, word, 0, i, j, visited, found);\n            }\n        }\n        if (found) {\n            result.push_back(word);\n        }\n    }\n    return result;\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> findWords(char[][] board, String[] words) {\n    List<String> result = new ArrayList<>();\n    for (String word : words) {\n        if (exist(board, word)) {\n            result.add(word);\n        }\n    }\n    return result;\n}\n\nprivate boolean exist(char[][] board, String word) {\n    int m = board.length;\n    int n = board[0].length;\n    boolean[][] visited = new boolean[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dfs(board, word, 0, i, j, visited)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean dfs(char[][] board, String word, int index, int i, int j, boolean[][] visited) {\n    if (index == word.length()) {\n        return true;\n    }\n    if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j] || board[i][j] != word.charAt(index)) {\n        return false;\n    }\n    visited[i][j] = true;\n    boolean found =\n            dfs(board, word, index + 1, i - 1, j, visited) ||\n            dfs(board, word, index + 1, i + 1, j, visited) ||\n            dfs(board, word, index + 1, i, j - 1, visited) ||\n            dfs(board, word, index + 1, i, j + 1, visited);\n    visited[i][j] = false;\n    return found;\n}\n\n",
            "python": "def findWords(board, words):\n    def dfs(board, word, index, i, j, visited):\n        if index == len(word):\n            return True\n        if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or visited[i][j] or board[i][j] != word[index]:\n            return False\n        visited[i][j] = True\n        found = dfs(board, word, index + 1, i - 1, j, visited) or \\\n                dfs(board, word, index + 1, i + 1, j, visited) or \\\n                dfs(board, word, index + 1, i, j - 1, visited) or \\\n                dfs(board, word, index + 1, i, j + 1, visited)\n        visited[i][j] = False\n        return found\n\n    res = []\n    for word in words:\n        if any(dfs(board, word, 0, i, j, [[False] * len(board[0]) for _ in range(len(board))])\n               for i in range(len(board)) for j in range(len(board[0]))):\n            res.append(word)\n    return res\n\n",
            "javascript": "function findWords(board, words) {\n    function dfs(board, word, index, i, j, visited) {\n        if (index === word.length) {\n            return true;\n        }\n        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j] || board[i][j] !== word.charAt(index)) {\n            return false;\n        }\n        visited[i][j] = true;\n        const found = dfs(board, word, index + 1, i - 1, j, visited) ||\n                      dfs(board, word, index + 1, i + 1, j, visited) ||\n                      dfs(board, word, index + 1, i, j - 1, visited) ||\n                      dfs(board, word, index + 1, i, j + 1, visited);\n        visited[i][j] = false;\n        return found;\n    }\n\n    const res = [];\n    for (const word of words) {\n        let found = false;\n        for (let i = 0; i < board.length && !found; i++) {\n            for (let j = 0; j < board[0].length && !found; j++) {\n                if (dfs(board, word, 0, i, j, Array.from({ length: board.length }, () => Array(board[0].length).fill(false)))) {\n                    found = true;\n                }\n            }\n        }\n        if (found) {\n            res.push(word);\n        }\n    }\n    return res;\n}\n\n",
            "explanation": "The algorithm uses Depth First Search (DFS) to search for each word in the board. For each word, we iterate through all the cells in the board and start the DFS search if the current cell matches the word's first letter. During the DFS search, we mark the cell as visited and only continue the search if the next cell we are going to move to is not yet visited, in the allowed board bounds, and it matches the next character of the word. If we reached the end of the word, then we know that this word is found in the board.\n\nFor each programming language, we implemented the `findWords` function that takes the `board` and the `words` as an input and returns a list of found words. The core algorithm is the same, but the language-specific syntax and constructs are used accordingly."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n\nvoid dfs(const std::vector<std::vector<char>>& board, const std::string& word, int index, int i, int j, std::vector<std::vector<bool>>& visited, bool& found)\n    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> findWords(char[][] board, String[] words) \n    // Your code here\n}\n\n",
            "python": "def findWords(board, words):\n    # Your code here\n\n",
            "javascript": "function findWords(board, words) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "std::vector<std::string> findWords(std::vector<std::vector<char>>& board, std::vector<std::string>& words) {\n    std::vector<std::string> result;\n    for (const auto& word : words) {\n        bool found = false;\n        std::vector<std::vector<bool>> visited(board.size(), std::vector<bool>(board[0].size(), false));\n        for (int i = 0; i < board.size() && !found; ++i) {\n            for (int j = 0; j < board[0].size() && !found; ++j) {\n                dfs(board, word, 0, i, j, visited, found);\n            }\n        }\n        if (found) {\n            result.push_back(word);\n        }\n    }\n    return result;\n}\n",
            "java": "public List<String> findWords(char[][] board, String[] words) {\n    List<String> result = new ArrayList<>();\n    for (String word : words) {\n        if (exist(board, word)) {\n            result.add(word);\n        }\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    board = inputs[0]\n    words = inputs[1]\n    result = findWords(board, words)\n    print(result)",
            "javascript": "function findWords(board, words) {\n    function dfs(board, word, index, i, j, visited) {\n        if (index === word.length) {\n            return true;\n        }\n        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j] || board[i][j] !== word.charAt(index)) {\n            return false;\n        }\n        visited[i][j] = true;\n        const found = dfs(board, word, index + 1, i - 1, j, visited) ||\n                      dfs(board, word, index + 1, i + 1, j, visited) ||\n                      dfs(board, word, index + 1, i, j - 1, visited) ||\n                      dfs(board, word, index + 1, i, j + 1, visited);\n        visited[i][j] = false;\n        return found;\n    }\n\n    const res = [];\n    for (const word of words) {\n        let found = false;\n        for (let i = 0; i < board.length && !found; i++) {\n            for (let j = 0; j < board[0].length && !found; j++) {\n                if (dfs(board, word, 0, i, j, Array.from({ length: board.length }, () => Array(board[0].length).fill(false)))) {\n                    found = true;\n                }\n            }\n        }\n        if (found) {\n            res.push(word);\n        }\n    }\n    return res;\n}"
        }
    },
    "214": {
        "title": "Shortest Palindrome",
        "description": "Given a string `s`, you can convert it to a palindrome by adding characters in front of it. Write a function that returns the shortest palindrome you can find by performing this transformation.",
        "example": "Example 1:\n\nInput: s = \"aacecaaa\"\nOutput: \"aaacecaaa\"\n\nExample 2:\n\nInput: s = \"abcd\"\nOutput: \"dcbabcd\"",
        "level": "Medium",
        "tags": [
            "string",
            "palindrome"
        ],
        "test_cases": {
            "inputs": [
                "\"aacecaaa\"",
                "\"abcd\"",
                "\"race\"",
                "\"level\"",
                "\"madam\"",
                "\"abc\"",
                "\"a\"",
                "\"\"",
                "\"aaaaa\"",
                "\"aabbaa\"",
                "\"abcdeedcba\"",
                "\"abcdefedcba\"",
                "\"aaaaaabaaaaa\"",
                "\"abcdeedcbaabcdeedcba\"",
                "\"abcdefghgfedcba\"",
                "\"aaaaaabaaaaaabaaaaa\"",
                "\"abcdeedcbaabcdeedcbaabcdeedcba\"",
                "\"abcdefghgfedcbaabcdefghgfedcba\"",
                "\"aaaaaabaaaaaabaaaaaabaaaaa\"",
                "\"abcdeedcbaabcdeedcbaabcdeedcbaabcdeedcba\""
            ],
            "outputs": [
                "\"aaacecaaa\"",
                "\"dcbabcd\"",
                "\"ecarace\"",
                "\"level\"",
                "\"madam\"",
                "\"cba\"",
                "\"a\"",
                "\"\"",
                "\"aaaaa\"",
                "\"aabbaa\"",
                "\"abcdeedcba\"",
                "\"abcdefedcba\"",
                "\"aaaaaabaaaaa\"",
                "\"abcdeedcbaabcdeedcba\"",
                "\"abcdefghgfedcba\"",
                "\"aaaaaabaaaaaabaaaaa\"",
                "\"abcdeedcbaabcdeedcbaabcdeedcba\"",
                "\"abcdefghgfedcbaabcdefghgfedcba\"",
                "\"aaaaaabaaaaaabaaaaaabaaaaa\"",
                "\"abcdeedcbaabcdeedcbaabcdeedcbaabcdeedcba\""
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n\nstd::string shortestPalindrome(std::string s) {\n    int n = s.size();\n    std::string rev_s = s;\n    std::reverse(rev_s.begin(), rev_s.end());\n    \n    for (int i = 0; i < n; ++i) {\n        if(s.substr(0, n - i) == rev_s.substr(i))\n            return rev_s.substr(0, i) + s;\n    }\n    return \"\";\n}\n\n",
            "java": "public String shortestPalindrome(String s) {\n    int n = s.length();\n    String rev_s = new StringBuilder(s).reverse().toString();\n    \n    for (int i = 0; i < n; ++i) {\n        if(s.substring(0, n - i).equals(rev_s.substring(i)))\n            return rev_s.substring(0, i) + s;\n    }\n    return \"\";\n}\n\n",
            "python": "def shortest_palindrome(s: str) -> str:\n    n = len(s)\n    rev_s = s[::-1]\n    \n    for i in range(n):\n        if s[:n - i] == rev_s[i:]:\n            return rev_s[:i] + s\n    return \"\"\n\n",
            "javascript": "function shortestPalindrome(s) {\n    let n = s.length;\n    let rev_s = s.split('').reverse().join('');\n    \n    for (let i = 0; i < n; ++i) {\n        if (s.slice(0, n - i) === rev_s.slice(i))\n            return rev_s.slice(0, i) + s;\n    }\n    return \"\";\n}\n\n",
            "explanation": "1. Take input string `s`.\n2. Get string `rev_s` by reversing the input string.\n3. Iterate through the characters in both strings.\n4. For each index `i`, compare the substring `[0, n - i)` of `s` and substring `[i, n)` of `rev_s`.\n5. If the substrings match, concatenate the non-matching substring of `rev_s` and the original input string `s`. This will result in the shortest palindromic string we can build.\n6. If not, continue with the next iteration.\n7. The function returns an empty string if an exception occurs."
        },
        "structure": {
            "c++": "#include <string>\n\nstd::string shortestPalindrome(std::string s) \n    // Your code here\n}\n\n",
            "java": "public String shortestPalindrome(String s) \n    // Your code here\n}\n\n",
            "python": "def shortest_palindrome(s: str) -> str:\n    # Your code here\n\n",
            "javascript": "function shortestPalindrome(s) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <iostream>\n\nstd::string shortestPalindrome(std::string s);\n\nint main() {\n    std::string s = $args;\n    std::string result = shortestPalindrome(s);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public String shortestPalindrome(String s) {\n    int n = s.length();\n    String rev_s = new StringBuilder(s).reverse().toString();\n    \n    for (int i = 0; i < n; ++i) {\n        if(s.substring(0, n - i).equals(rev_s.substring(i)))\n            return rev_s.substring(0, i) + s;\n    }\n    return \"\";\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = shortest_palindrome(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = shortestPalindrome(s);\n    console.log(result);\n}\n"
        }
    },
    "216": {
        "title": "Valid Combinations",
        "description": "Given a positive integer `k` and a target sum `n`, find all valid combinations of `k` numbers that sum up to `n`. The numbers used must be in the range from 1 to 9, and each number can be used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.",
        "example": "Example:\n\nInput: k = 3, n = 7\nOutput: [[1,2,4]]\nExplanation: 1 + 2 + 4 = 7\n\nInput: k = 3, n = 9\nOutput: [[1,2,6],[1,3,5],[2,3,4]]\nExplanation: 1 + 2 + 6 = 9, 1 + 3 + 5 = 9, 2 + 3 + 4 = 9\n\nInput: k = 4, n = 1\nOutput: []\nExplanation: There are no valid combinations. Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combinations.",
        "level": "Medium",
        "tags": [
            "backtracking",
            "combinations"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    7
                ],
                [
                    3,
                    9
                ],
                [
                    4,
                    1
                ],
                [
                    2,
                    5
                ],
                [
                    5,
                    15
                ],
                [
                    6,
                    30
                ],
                [
                    7,
                    45
                ],
                [
                    8,
                    60
                ],
                [
                    9,
                    55
                ],
                [
                    3,
                    15
                ],
                [
                    4,
                    20
                ],
                [
                    5,
                    25
                ],
                [
                    6,
                    30
                ],
                [
                    7,
                    35
                ],
                [
                    8,
                    40
                ],
                [
                    9,
                    45
                ],
                [
                    3,
                    18
                ],
                [
                    4,
                    22
                ],
                [
                    5,
                    27
                ],
                [
                    6,
                    33
                ]
            ],
            "outputs": [
                [
                    [
                        1,
                        2,
                        4
                    ]
                ],
                [
                    [
                        1,
                        2,
                        6
                    ],
                    [
                        1,
                        3,
                        5
                    ],
                    [
                        2,
                        3,
                        4
                    ]
                ],
                [],
                [
                    [
                        2,
                        3
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        6,
                        9,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        17
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        24
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        5,
                        9
                    ]
                ],
                [
                    [
                        1,
                        4,
                        6,
                        4,
                        0,
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1,
                        5,
                        6,
                        4,
                        4,
                        0,
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1,
                        6,
                        7,
                        5,
                        4,
                        2,
                        0,
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1,
                        7,
                        8,
                        6,
                        5,
                        3,
                        2,
                        0,
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1,
                        8,
                        9,
                        7,
                        6,
                        4,
                        3,
                        1,
                        0,
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1,
                        9,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        2,
                        0,
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1,
                        6,
                        11
                    ]
                ],
                [
                    [
                        1,
                        7,
                        14,
                        0
                    ]
                ],
                [
                    [
                        1,
                        8,
                        16,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1,
                        9,
                        18,
                        0,
                        0,
                        0
                    ]
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nvoid helper(int k, int n, int current, std::vector<int>& current_comb, std::vector<std::vector<int>>& result) {\n    if (k == 0 && n == 0) {\n        result.push_back(current_comb);\n    } else if (k > 0 && n > 0) {\n        for (int i = current + 1; i <= 9; ++i) {\n            current_comb.push_back(i);\n            helper(k - 1, n - i, i, current_comb, result);\n            current_comb.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<int>> combinationSum3(int k, int n) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> current_comb;\n    helper(k, n, 0, current_comb, result);\n    return result;\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> combinationSum3(int k, int n) {\n    List<List<Integer>> result = new ArrayList<>();\n    helper(k, n, 0, new ArrayList<>(), result);\n    return result;\n}\n\nprivate void helper(int k, int n, int current, List<Integer> currentComb, List<List<Integer>> result) {\n    if (k == 0 && n == 0) {\n        result.add(new ArrayList<>(currentComb));\n    } else if (k > 0 && n > 0) {\n        for (int i = current + 1; i <= 9; i++) {\n            currentComb.add(i);\n            helper(k - 1, n - i, i, currentComb, result);\n            currentComb.remove(currentComb.size() - 1);\n        }\n    }\n}\n\n",
            "python": "def combinationSum3(k, n):\n    def helper(k, n, current, current_comb, result):\n        if k == 0 and n == 0:\n            result.append(list(current_comb))\n        elif k > 0 and n > 0:\n            for i in range(current + 1, 10):\n                current_comb.append(i)\n                helper(k - 1, n - i, i, current_comb, result)\n                current_comb.pop()\n\n    result = []\n    helper(k, n, 0, [], result)\n    return result\n\n",
            "javascript": "function combinationSum3(k, n) {\n  function helper(k, n, current, currentComb, result) {\n    if (k === 0 && n === 0) {\n      result.push([...currentComb]);\n    } else if (k > 0 && n > 0) {\n      for (let i = current + 1; i <= 9; i++) {\n        currentComb.push(i);\n        helper(k - 1, n - i, i, currentComb, result);\n        currentComb.pop();\n      }\n    }\n  }\n\n  const result = [];\n  helper(k, n, 0, [], result);\n  return result;\n}\n\n",
            "explanation": "The algorithm is based on a backtracking approach. We use a helper function which takes some parameters: `k` and `n` to limit the combinations, `current` which is the last considered element, `current_comb` which is the current combination being formed, and `result` which is the list of all valid combinations found so far.\n\nWe keep updating the current combination and decreasing `k` and `n` accordingly as we call the helper function recursively. When we have `k = 0` and `n = 0`, we know we have reached a valid combination and add it to our result list. To prevent revisiting the same combinations, we make sure that the numbers are considered in increasing order (thus, the current value being picked always starts at `current + 1`).\n\nWhen backtracking, we remove the last considered element from the current combination so that we can try another combination. Following this approach ensures that we visit every potential combination only once and store it if it is valid."
        },
        "structure": {
            "c++": "#include <vector>\n\nvoid helper(int k, int n, int current, std::vector<int>& current_comb, std::vector<std::vector<int>>& result) \n    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> combinationSum3(int k, int n) \n    // Your code here\n}\n\n",
            "python": "def combinationSum3(k, n):\n    # Your code here\n\n",
            "javascript": "function combinationSum3(k, n) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nvoid helper(int k, int n, int current, std::vector<int>& current_comb, std::vector<std::vector<int>>& result) {\n    if (k == 0 && n == 0) {\n        result.push_back(current_comb);\n    } else if (k > 0 && n > 0) {\n        for (int i = current + 1; i <= 9; ++i) {\n            current_comb.push_back(i);\n            helper(k - 1, n - i, i, current_comb, result);\n            current_comb.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<int>> combinationSum3(int k, int n) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> current_comb;\n    helper(k, n, 0, current_comb, result);\n    return result;\n}\n\nint main() {\n    int k = $args;\n    int n = $args;\n    std::vector<std::vector<int>> result = combinationSum3(k, n);\n    for (const auto& comb : result) {\n        for (const auto& num : comb) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}",
            "java": "public List<List<Integer>> combinationSum3(int k, int n) {\n    List<List<Integer>> result = new ArrayList<>();\n    helper(k, n, 0, new ArrayList<>(), result);\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    k = inputs[0]\n    n = inputs[1]\n    result = combinationSum3(k, n)\n    print(result)"
        }
    },
    "217": {
        "title": "Duplicate Integer Check",
        "description": "Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.",
        "example": "Example:\n\nInput: nums = [1,2,3,1]\nOutput: true\n\nExplanation: The value 1 appears twice in the array.\n\nInput: nums = [1,2,3,4]\nOutput: false\n\nExplanation: Every element in the array is distinct.",
        "level": "Easy",
        "tags": [
            "array",
            "hash table"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4
                ],
                [
                    1,
                    1,
                    1,
                    3,
                    3,
                    4,
                    3,
                    2,
                    4,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                false,
                false,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "bool containsDuplicate(vector<int>& nums) {\n    unordered_set<int> s;\n    for (int num : nums) {\n        if (s.find(num) != s.end()) {\n            return true;\n        }\n        s.insert(num);\n    }\n    return false;\n}\n\n",
            "java": "public boolean containsDuplicate(int[] nums) {\n    Set<Integer> set = new HashSet<Integer>();\n    for (int num : nums) {\n        if (!set.add(num)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n",
            "python": "def containsDuplicate(nums):\n    return len(nums) != len(set(nums))\n\n",
            "javascript": "function containsDuplicate(nums) {\n    const set = new Set();\n    for (const num of nums) {\n        if (set.has(num)) {\n            return true;\n        }\n        set.add(num);\n    }\n    return false;\n}\n\n",
            "explanation": "The algorithm starts by creating an empty set. Then it iterates through the input array. For each number in the array, it checks if the number is already in the set. If the number is in the set, it means there's a duplicate, so it returns true. If the number is not in the set, it adds the number to the set. If the function has not returned true after iterating through the entire array, it means that there are no duplicates, so it returns false.\n\nIn Python, we use the fact that sets don't allow duplicates, so we can directly compare the length of the original list with the length of the set created from the list. If they are not equal, it means there are duplicates in the list, and the function returns true. Otherwise, it returns false."
        },
        "structure": {
            "c++": "bool containsDuplicate(vector<int>& nums) \n    // Your code here\n}\n\n",
            "java": "public boolean containsDuplicate(int[] nums) \n    // Your code here\n}\n\n",
            "python": "def containsDuplicate(nums):\n    # Your code here\n\n",
            "javascript": "function containsDuplicate(nums) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "bool containsDuplicate(vector<int>& nums) {\n    unordered_set<int> s;\n    for (int num : nums) {\n        if (s.find(num) != s.end()) {\n            return true;\n        }\n        s.insert(num);\n    }\n    return false;\n}",
            "java": "public boolean containsDuplicate(int[] nums) {\n    Set<Integer> set = new HashSet<Integer>();\n    for (int num : nums) {\n        if (!set.add(num)) {\n            return true;\n        }\n    }\n    return false;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = containsDuplicate(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = containsDuplicate(nums);\n    console.log(result);\n}\n"
        }
    },
    "218": {
        "title": "City Skyline",
        "description": "A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively. The geometric information of each building is given in the array `buildings` where `buildings[i] = [lefti, righti, heighti]`. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0. The skyline should be represented as a list of key points sorted by their x-coordinate in the form `[[x1,y1],[x2,y2],...]`. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate 0 and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour. Note that there must be no consecutive horizontal lines of equal height in the output skyline.",
        "example": "Example:\n\nInput: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]\nOutput: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\nExplanation: Figure A shows the buildings of the input. Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        2,
                        9,
                        10
                    ],
                    [
                        3,
                        7,
                        15
                    ],
                    [
                        5,
                        12,
                        12
                    ],
                    [
                        15,
                        20,
                        10
                    ],
                    [
                        19,
                        24,
                        8
                    ]
                ],
                [
                    [
                        0,
                        2,
                        3
                    ],
                    [
                        2,
                        5,
                        3
                    ]
                ],
                [
                    [
                        1,
                        5,
                        7
                    ],
                    [
                        2,
                        4,
                        6
                    ],
                    [
                        3,
                        6,
                        8
                    ]
                ],
                [
                    [
                        0,
                        1,
                        2
                    ],
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        2,
                        3,
                        4
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        2,
                        3,
                        4
                    ],
                    [
                        3,
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        2,
                        3,
                        4
                    ],
                    [
                        3,
                        4,
                        3
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        2,
                        3,
                        4
                    ],
                    [
                        3,
                        4,
                        2
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        2,
                        3,
                        4
                    ],
                    [
                        3,
                        4,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        2,
                        3,
                        4
                    ],
                    [
                        3,
                        4,
                        0
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        2,
                        3,
                        2
                    ],
                    [
                        3,
                        4,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        2,
                        3,
                        1
                    ],
                    [
                        3,
                        4,
                        0
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        2,
                        3,
                        0
                    ],
                    [
                        3,
                        4,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        0
                    ],
                    [
                        2,
                        3,
                        1
                    ],
                    [
                        3,
                        4,
                        2
                    ]
                ],
                [
                    [
                        1,
                        2,
                        1
                    ],
                    [
                        2,
                        3,
                        2
                    ],
                    [
                        3,
                        4,
                        3
                    ]
                ],
                [
                    [
                        1,
                        2,
                        2
                    ],
                    [
                        2,
                        3,
                        3
                    ],
                    [
                        3,
                        4,
                        4
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        2,
                        3,
                        4
                    ],
                    [
                        3,
                        4,
                        5
                    ],
                    [
                        4,
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        2,
                        3,
                        4
                    ],
                    [
                        3,
                        4,
                        5
                    ],
                    [
                        4,
                        5,
                        4
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        2,
                        3,
                        4
                    ],
                    [
                        3,
                        4,
                        5
                    ],
                    [
                        4,
                        5,
                        3
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        2,
                        3,
                        4
                    ],
                    [
                        3,
                        4,
                        5
                    ],
                    [
                        4,
                        5,
                        2
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        2,
                        3,
                        4
                    ],
                    [
                        3,
                        4,
                        5
                    ],
                    [
                        4,
                        5,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        2,
                        3,
                        4
                    ],
                    [
                        3,
                        4,
                        5
                    ],
                    [
                        4,
                        5,
                        0
                    ]
                ]
            ],
            "outputs": [
                [
                    [
                        2,
                        10
                    ],
                    [
                        3,
                        15
                    ],
                    [
                        7,
                        12
                    ],
                    [
                        12,
                        0
                    ],
                    [
                        15,
                        10
                    ],
                    [
                        20,
                        8
                    ],
                    [
                        24,
                        0
                    ]
                ],
                [
                    [
                        0,
                        3
                    ],
                    [
                        5,
                        0
                    ]
                ],
                [
                    [
                        1,
                        7
                    ],
                    [
                        7,
                        6
                    ],
                    [
                        6,
                        0
                    ]
                ],
                [
                    [
                        0,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ]
                ],
                [
                    [
                        1,
                        4
                    ],
                    [
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        4
                    ],
                    [
                        4,
                        0
                    ]
                ],
                [
                    [
                        1,
                        4
                    ],
                    [
                        4,
                        0
                    ]
                ],
                [
                    [
                        1,
                        4
                    ],
                    [
                        4,
                        0
                    ]
                ],
                [
                    [
                        1,
                        4
                    ],
                    [
                        4,
                        0
                    ]
                ],
                [
                    [
                        1,
                        4
                    ],
                    [
                        4,
                        1
                    ]
                ],
                [
                    [
                        1,
                        4
                    ],
                    [
                        4,
                        0
                    ]
                ],
                [
                    [
                        1,
                        4
                    ],
                    [
                        4,
                        1
                    ]
                ],
                [
                    [
                        1,
                        4
                    ],
                    [
                        4,
                        2
                    ]
                ],
                [
                    [
                        1,
                        4
                    ],
                    [
                        4,
                        3
                    ]
                ],
                [
                    [
                        1,
                        4
                    ],
                    [
                        4,
                        4
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        5,
                        4
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        5,
                        3
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        5,
                        2
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        5,
                        1
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        5,
                        0
                    ]
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> getSkyline(vector<vector<int>>& buildings) {\n    vector<pair<int, int>> points;\n    for (const auto &b : buildings) {\n        points.emplace_back(b[0], -b[2]);\n        points.emplace_back(b[1], b[2]);\n    }\n    sort(points.begin(), points.end());\n    multiset<int> heights = {0};\n    int prev = 0;\n    vector<vector<int>> skyline;\n    for (const auto &[x, h] : points) {\n        if (h < 0)\n            heights.insert(-h);\n        else\n            heights.erase(heights.find(h));\n        int cur = *heights.rbegin();\n        if (cur != prev) {\n            skyline.push_back({x, cur});\n            prev = cur;\n        }\n    }\n    return skyline;\n}\n",
            "java": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> getSkyline(int[][] buildings) {\n        List<int[]> points = new ArrayList<>();\n        for (int[] b : buildings) {\n            points.add(new int[]{b[0], -b[2]});\n            points.add(new int[]{b[1], b[2]});\n        }\n        Collections.sort(points, (a, b) -> a[0] - b[0]);\n        TreeSet<Integer> heights = new TreeSet<>(Collections.reverseOrder());\n        heights.add(0);\n        int prev = 0;\n        List<List<Integer>> skyline = new ArrayList<>();\n        for (int[] point : points) {\n            int x = point[0], h = point[1];\n            if (h < 0)\n                heights.add(-h);\n            else\n                heights.remove(h);\n            int cur = heights.first();\n            if (cur != prev) {\n                skyline.add(Arrays.asList(x, cur));\n                prev = cur;\n            }\n        }\n        return skyline;\n    }\n}\n",
            "python": "from sortedcontainers import SortedList\n\ndef getSkyline(buildings):\n    points = []\n    for l, r, h in buildings:\n        points.append((l, -h))\n        points.append((r, h))\n    points.sort()\n    heights = SortedList([0])\n    prev = 0\n    skyline = []\n    for x, h in points:\n        if h < 0:\n            heights.add(-h)\n        else:\n            heights.remove(h)\n        cur = heights[-1]\n        if cur != prev:\n            skyline.append([x, cur])\n            prev = cur\n    return skyline\n",
            "javascript": "function getSkyline(buildings) {\n    const points = [];\n    for (const [l, r, h] of buildings) {\n        points.push([l, -h]);\n        points.push([r, h]);\n    }\n    points.sort((a, b) => a[0] - b[0]);\n    const heights = new SortedSet([0]);\n    let prev = 0;\n    const skyline = [];\n    for (const [x, h] of points) {\n        if (h < 0) {\n            heights.add(-h);\n        } else {\n            heights.delete(h);\n        }\n        const cur = heights.last();\n        if (cur !== prev) {\n            skyline.push([x, cur]);\n            prev = cur;\n        }\n    }\n    return skyline;\n}\n",
            "explanation": "The algorithm starts by iterating through all the given buildings and creating a list of x-coordinates paired with the height of the buildings, where the left points are negated. We then sort the list of points by x-coordinate. Additionally, we also create a sorted multiset (C++)/TreeSet (Java)/SortedList (Python)/SortedSet (JavaScript) of building heights, initialized with a single 0 height.\n\nNext, we iterate through the sorted points. If the height is negative, meaning it's a left point of a building, we add the absolute value of the height to the heights set. If the height is positive, meaning it's a right point of a building, we remove the height from the heights set.\n\nAt each iteration, we compare the current maximum height to the previous maximum height. If the current maximum height is different from the previous maximum height, it means we've reached a key point in the skyline, so we add this x-coordinate and the current maximum height to the skyline result list. \n\nThis algorithm ensures we receive a sorted list of key points in the skyline, without consecutive horizontal lines of equal height."
        },
        "structure": {
            "c++": "#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> getSkyline(vector<vector<int>>& buildings) \n    // Your code here\n}\n",
            "java": "import java.util.*;\n\nclass Solution \n    // Your code here\n}\n",
            "python": "from sortedcontainers import SortedList\n    # Your code here\n\n",
            "javascript": "function getSkyline(buildings) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    vector<vector<int>> buildings = $args;\n    vector<vector<int>> result = getSkyline(buildings);\n    for (const auto &r : result) {\n        cout << r[0] << \" \" << r[1] << endl;\n    }\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n        int n = $args;\n        boolean result = isPowerOfFour(n);\n        System.out.println(result);\n    }\n",
            "python": "if __name__ == \"__main__\":\n    buildings = $args\n    result = getSkyline(buildings)\n    print(result)"
        }
    },
    "219": {
        "title": "Duplicate Elements within K Distance",
        "description": "Given an integer array `nums` and an integer `k`, return `true` if there are two distinct indices `i` and `j` in the array such that `nums[i] == nums[j]` and `abs(i - j) <= k`.",
        "example": "Given an array `nums = [1,2,3,1]` and `k = 3`, the output should be `true` since there are two distinct indices `i = 0` and `j = 3` such that `nums[i] == nums[j]` and `abs(i - j) <= k`.\n\nGiven an array `nums = [1,0,1,1]` and `k = 1`, the output should be `true` since there are two distinct indices `i = 1` and `j = 2` such that `nums[i] == nums[j]` and `abs(i - j) <= k`.\n\nGiven an array `nums = [1,2,3,1,2,3]` and `k = 2`, the output should be `false` since there are no two distinct indices `i` and `j` such that `nums[i] == nums[j]` and `abs(i - j) <= k`.",
        "level": "Easy",
        "tags": [
            "array",
            "hash table"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3,
                    1
                ],
                [
                    1,
                    0,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    1,
                    2,
                    3
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16
                ]
            ],
            "outputs": [
                true,
                true,
                false,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "bool containsNearbyDuplicate(vector<int>& nums, int k) {\n    unordered_map<int, int> valueIndexMap;\n    for (int i = 0; i < nums.size(); i++) {\n        if (valueIndexMap.find(nums[i]) != valueIndexMap.end() && i - valueIndexMap[nums[i]] <= k) {\n            return true;\n        }\n        valueIndexMap[nums[i]] = i;\n    }\n    return false;\n}\n",
            "java": "public boolean containsNearbyDuplicate(int[] nums, int k) {\n    HashMap<Integer, Integer> valueIndexMap = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        if (valueIndexMap.containsKey(nums[i]) && i - valueIndexMap.get(nums[i]) <= k) {\n            return true;\n        }\n        valueIndexMap.put(nums[i], i);\n    }\n    return false;\n}\n",
            "python": "def containsNearbyDuplicate(nums, k):\n    value_index_map = {}\n    for i, num in enumerate(nums):\n        if num in value_index_map and i - value_index_map[num] <= k:\n            return True\n        value_index_map[num] = i\n    return False\n",
            "javascript": "function containsNearbyDuplicate(nums, k) {\n    const valueIndexMap = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        if (valueIndexMap.has(nums[i]) && i - valueIndexMap.get(nums[i]) <= k) {\n            return true;\n        }\n        valueIndexMap.set(nums[i], i);\n    }\n    return false;\n}\n",
            "explanation": "The algorithm utilizes a Hashtable, in which we store the integer value present in the array as the key and its latest index position as the value. For each element in the array, we first check if the current number is already in the Hashtable. If it is, we also check if the difference between the current index and the latest index stored in the Hashtable is less than or equal to k. If both conditions are met, we return `true` because there are two repeating integers having an index difference less than or equal to k. Otherwise, we add the number along with its latest index to the Hashtable and continue with the next element. If the loop finishes without finding such a pair, we return `false`.\n\nNote: The algorithm's time complexity is O(n), where n is the length of the input array, and the space complexity is O(min(n, k))."
        },
        "structure": {
            "c++": "bool containsNearbyDuplicate(vector<int>& nums, int k) \n    // Your code here\n}\n",
            "java": "public boolean containsNearbyDuplicate(int[] nums, int k) \n    // Your code here\n}\n",
            "python": "def containsNearbyDuplicate(nums, k):\n    # Your code here\n\n",
            "javascript": "function containsNearbyDuplicate(nums, k) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "bool containsNearbyDuplicate(vector<int>& nums, int k) {\n    unordered_map<int, int> valueIndexMap;\n    for (int i = 0; i < nums.size(); i++) {\n        if (valueIndexMap.find(nums[i]) != valueIndexMap.end() && i - valueIndexMap[nums[i]] <= k) {\n            return true;\n        }\n        valueIndexMap[nums[i]] = i;\n    }\n    return false;\n}",
            "java": "public boolean containsNearbyDuplicate(int[] nums, int k) {\n    HashMap<Integer, Integer> valueIndexMap = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        if (valueIndexMap.containsKey(nums[i]) && i - valueIndexMap.get(nums[i]) <= k) {\n            return true;\n        }\n        valueIndexMap.put(nums[i], i);\n    }\n    return false;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    k = $args[1]\n    result = containsNearbyDuplicate(nums, k)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args[0];\n    const k = $args[1];\n    const result = containsNearbyDuplicate(nums, k);\n    console.log(result);\n}"
        }
    },
    "220": {
        "title": "Index and Value Difference",
        "description": "Given an integer array `nums` and two integers `indexDiff` and `valueDiff`, find a pair of indices `(i, j)` such that `i != j`, `abs(i - j) <= indexDiff`, and `abs(nums[i] - nums[j]) <= valueDiff`. Return `true` if such a pair exists, or `false` otherwise.",
        "example": "Example:\n\nInput: nums = [1,2,3,1], indexDiff = 3, valueDiff = 0\nOutput: true\nExplanation: We can choose (i, j) = (0, 3). We satisfy the three conditions: i != j --> 0 != 3, abs(i - j) <= indexDiff --> abs(0 - 3) <= 3, abs(nums[i] - nums[j]) <= valueDiff --> abs(1 - 1) <= 0",
        "level": "Easy",
        "tags": [
            "array",
            "index",
            "value"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        2,
                        3,
                        1
                    ],
                    3,
                    0
                ],
                [
                    [
                        1,
                        5,
                        9,
                        1,
                        5,
                        9
                    ],
                    2,
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1,
                    0
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    3,
                    1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    5,
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    0,
                    0
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    2,
                    0
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    2,
                    1
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    2,
                    2
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    2,
                    3
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    2,
                    4
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    2,
                    5
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    2,
                    6
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    2,
                    7
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    2,
                    8
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    2,
                    9
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    2,
                    10
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    2,
                    11
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    2,
                    12
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    2,
                    13
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <set>\nusing namespace std;\n\nbool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n    set<long> window;\n    for (int i = 0; i < nums.size(); i++) {\n        if (i > k) {\n            window.erase(nums[i - k - 1]);\n        }\n        auto pos = window.lower_bound((long)nums[i] - t);\n        if (pos != window.end() && *pos - nums[i] <= t) {\n            return true;\n        }\n        window.insert(nums[i]);\n    }\n    return false;\n}\n",
            "java": "import java.util.TreeSet;\n\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n    TreeSet<Long> window = new TreeSet<>();\n    for(int i = 0; i < nums.length; i++) {\n        if(i > k) {\n            window.remove((long)nums[i - k - 1]);\n        }\n        Long ceil = window.ceiling((long)nums[i] - t);\n        if(ceil != null && ceil - nums[i] <= t) {\n            return true;\n        }\n        window.add((long)nums[i]);\n    }\n    return false;\n}\n",
            "python": "from sortedcontainers import SortedList\n\ndef containsNearbyAlmostDuplicate(nums, k, t):\n    window = SortedList()\n    for i in range(len(nums)):\n        if i > k:\n            window.remove(nums[i - k - 1])\n        pos = window.bisect_left(nums[i] - t)\n        if pos != len(window) and window[pos] - nums[i] <= t:\n            return True\n        window.add(nums[i])\n    return False\n",
            "javascript": "function containsNearbyAlmostDuplicate(nums, k, t) {\n    let window = new Set();\n    for (let i = 0; i < nums.length; i++) {\n        if (i > k) {\n            window.delete(nums[i - k - 1]);\n        }\n        for (const num of window) {\n            if (Math.abs(num - nums[i]) <= t) {\n                return true;\n            }\n        }\n        window.add(nums[i]);\n    }\n    return false;\n}\n",
            "explanation": "In this algorithm, we maintain a sliding window of size k + 1, and use a search tree (set or TreeSet depending on the language) to store the elements within the window. We use the search tree to efficiently search for elements in the window that meet the requirement of `abs(nums[i] - nums[j]) <= t`.\n\nFor each element in nums, we try to find a lower bound in the search tree that is close enough to the current element (within t). If there already exists an element that meets the condition, we return true.\n\nWe remove elements from the search tree that fall outside the window and add the current element to the search tree, maintaining the window size.\n\nIf we iterate through the whole array without finding a pair that meets the condition, we return false.\n\nNote that in the Python implementation, \"SortedList\" from the \"sortedcontainers\" package is being used as it provides the needed functionality similar to C++ and Java. You might need to install the package via pip if not available."
        },
        "structure": {
            "c++": "#include <vector>\n#include <set>\nusing namespace std;\n\nbool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) \n    // Your code here\n}\n",
            "java": "import java.util.TreeSet;\n\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) \n    // Your code here\n}\n",
            "python": "from sortedcontainers import SortedList\n    # Your code here\n\n",
            "javascript": "function containsNearbyAlmostDuplicate(nums, k, t) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <set>\nusing namespace std;\n\nint main() {\n    vector<int> nums = $args;\n    int k = $args;\n    int t = $args;\n    bool result = containsNearbyAlmostDuplicate(nums, k, t);\n    cout << boolalpha << result << endl;\n    return 0;\n}",
            "java": "public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n    TreeSet<Long> window = new TreeSet<>();\n    for(int i = 0; i < nums.length; i++) {\n        if(i > k) {\n            window.remove((long)nums[i - k - 1]);\n        }\n        Long ceil = window.ceiling((long)nums[i] - t);\n        if(ceil != null && ceil - nums[i] <= t) {\n            return true;\n        }\n        window.add((long)nums[i]);\n    }\n    return false;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    k = $args[1]\n    t = $args[2]\n    result = containsNearbyAlmostDuplicate(nums, k, t)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args[0];\n    const k = $args[1];\n    const t = $args[2];\n    const result = containsNearbyAlmostDuplicate(nums, k, t);\n    console.log(result);\n}"
        }
    },
    "221": {
        "title": "Largest Square of Ones",
        "description": "Given an `m x n` binary `matrix` filled with `0`'s and `1`'s, find the largest square containing only `1`'s and return its area.",
        "example": "Example:\n\nInput: matrix = [[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]\nOutput: 4\n\nExplanation: The largest square containing only `1`'s is:\n\n1 0 1 0 0\n1 0 1 1 1\n1 1 1 1 1\n1 0 0 1 0\n\nThe area of this square is 4.",
        "level": "Medium",
        "tags": [
            "Matrix",
            "Dynamic Programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        0,
                        1,
                        0,
                        0
                    ],
                    [
                        1,
                        0,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        1,
                        0
                    ]
                ],
                [
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        0
                    ]
                ],
                [
                    [
                        0
                    ]
                ]
            ],
            "outputs": [
                4,
                1,
                0
            ]
        },
        "sample_code": {
            "c++": "int maximalSquare(vector<vector<char>>& matrix) {\n    int m = matrix.size();\n    int n = matrix[0].size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    int maxSize = 0;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (matrix[i - 1][j - 1] == '1') {\n                dp[i][j] = min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}) + 1;\n                maxSize = max(maxSize, dp[i][j]);\n            }\n        }\n    }\n    \n    return maxSize * maxSize;\n}\n",
            "java": "public int maximalSquare(char[][] matrix) {\n    int m = matrix.length;\n    int n = matrix[0].length;\n    int[][] dp = new int[m + 1][n + 1];\n    int maxSize = 0;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (matrix[i - 1][j - 1] == '1') {\n                dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n                maxSize = Math.max(maxSize, dp[i][j]);\n            }\n        }\n    }\n\n    return maxSize * maxSize;\n}\n",
            "python": "def maximalSquare(matrix):\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    maxSize = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == '1':\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                maxSize = max(maxSize, dp[i][j])\n\n    return maxSize * maxSize\n",
            "javascript": "function maximalSquare(matrix) {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    let maxSize = 0;\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (matrix[i - 1][j - 1] === '1') {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n                maxSize = Math.max(maxSize, dp[i][j]);\n            }\n        }\n    }\n\n    return maxSize * maxSize;\n}\n",
            "explanation": "The algorithm uses dynamic programming to find the largest square containing only 1's. It starts by creating a 2D table, `dp`, where `dp[i][j]` represents the size of the largest square ending at position (i, j) in the input matrix. The dimensions of `dp` are m+1 and n+1 to accommodate zero-indexing, and all elements are initialized to zero. \n\nThe algorithm iterates through each element in the input matrix. If the current element is 1, it sets the corresponding entry in `dp` to the minimum of the neighboring `dp` values (i.e., the values at top, left, and top-left) plus 1, which represents the size of the current square. The maxSize variable keeps track of the current largest square size, and at the end, the area of the largest square is returned by squaring maxSize."
        },
        "structure": {
            "c++": "int maximalSquare(vector<vector<char>>& matrix) \n    // Your code here\n}\n",
            "java": "public int maximalSquare(char[][] matrix) \n    // Your code here\n}\n",
            "python": "def maximalSquare(matrix):\n    # Your code here\n\n",
            "javascript": "function maximalSquare(matrix) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int maximalSquare(vector<vector<char>>& matrix) {\n    int m = matrix.size();\n    int n = matrix[0].size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    int maxSize = 0;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (matrix[i - 1][j - 1] == '1') {\n                dp[i][j] = min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}) + 1;\n                maxSize = max(maxSize, dp[i][j]);\n            }\n        }\n    }\n\n    return maxSize * maxSize;\n}",
            "java": "public int maximalSquare(char[][] matrix) {\n    int m = matrix.length;\n    int n = matrix[0].length;\n    int[][] dp = new int[m + 1][n + 1];\n    int maxSize = 0;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (matrix[i - 1][j - 1] == '1') {\n                dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n                maxSize = Math.max(maxSize, dp[i][j]);\n            }\n        }\n    }\n\n    return maxSize * maxSize;\n}",
            "python": "if __name__ == \"__main__\":\n    matrix = $args[0]\n    result = maximalSquare(matrix)\n    print(result)",
            "javascript": "function maximalSquare(matrix) {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    let maxSize = 0;\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (matrix[i - 1][j - 1] === '1') {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n                maxSize = Math.max(maxSize, dp[i][j]);\n            }\n        }\n    }\n\n    return maxSize * maxSize;\n}"
        }
    },
    "224": {
        "title": "Basic Calculator",
        "description": "Given a string `s` representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation. You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.",
        "example": "Example:\n\nInput: s = \"1 + 1\"\nOutput: 2\n\nInput: s = \"2-1 + 2\"\nOutput: 3\n\nInput: s = \"(1+(4+5+2)-3)+(6+8)\"\nOutput: 23",
        "level": "Medium",
        "tags": [
            "stack",
            "math"
        ],
        "test_cases": {
            "inputs": [
                "\"1 + 1\"",
                "\"2-1 + 2\"",
                "\"(1+(4+5+2)-3)+(6+8)\"",
                "\"10 - 5 + 3\"",
                "\"(2+3) - (4-1)\"",
                "\"(1+2) - (3+4) + (5-6)\"",
                "\"1 + 2 - 3 + 4 - 5 + 6\"",
                "\"10 - (5 + 3)\"",
                "\"(2+3) - (4-1) + (5-6)\"",
                "\"(1+2) - (3+4) + (5-6) + (7-8)\"",
                "\"1 + 2 - 3 + 4 - 5 + 6 - 7\"",
                "\"100 - 50 + 30\"",
                "\"(20+30) - (40-10)\"",
                "\"(10+20) - (30+40) + (50-60)\"",
                "\"1 + 2 - 3 + 4 - 5 + 6 - 7 + 8\"",
                "\"100 - (50 + 30)\"",
                "\"(20+30) - (40-10) + (50-60)\"",
                "\"(10+20) - (30+40) + (50-60) + (70-80)\"",
                "\"1 + 2 - 3 + 4 - 5 + 6 - 7 + 8 - 9\"",
                "\"100 - (50 + 30) + (20-10)\"",
                "\"(20+30) - (40-10) + (50-60) - (70-80)\"",
                "\"(10+20) - (30+40) + (50-60) + (70-80) - (90-100)\""
            ],
            "outputs": [
                2,
                3,
                23,
                8,
                2,
                -1,
                5,
                2,
                0,
                -1,
                0,
                80,
                20,
                -10,
                -1,
                20,
                -10,
                -20,
                -1,
                30,
                -20,
                -40
            ]
        },
        "sample_code": {
            "c++": "int calculate(string s) {\n    int result = 0, sign = 1, num = 0;\n    stack<int> st;\n    for (char c : s) {\n        if (isdigit(c)) {\n            num = num * 10 + (c - '0');\n        } else {\n            result += sign * num;\n            num = 0;\n            if (c == '+') {\n                sign = 1;\n            } else if (c == '-') {\n                sign = -1;\n            } else if (c == '(') {\n                st.push(result);\n                st.push(sign);\n                result = 0;\n                sign = 1;\n            } else if (c == ')') {\n                int prev_sign = st.top();\n                st.pop();\n                int prev_result = st.top();\n                st.pop();\n                result = prev_result + prev_sign * result;\n            }\n        }\n    }\n    result += sign * num;\n    return result;\n}\n",
            "java": "public int calculate(String s) {\n    int result = 0, sign = 1, num = 0;\n    Stack<Integer> st = new Stack<>();\n    for (char c : s.toCharArray()) {\n        if (Character.isDigit(c)) {\n            num = num * 10 + (c - '0');\n        } else {\n            result += sign * num;\n            num = 0;\n            if (c == '+') {\n                sign = 1;\n            } else if (c == '-') {\n                sign = -1;\n            } else if (c == '(') {\n                st.push(result);\n                st.push(sign);\n                result = 0;\n                sign = 1;\n            } else if (c == ')') {\n                int prev_sign = st.pop();\n                int prev_result = st.pop();\n                result = prev_result + prev_sign * result;\n            }\n        }\n    }\n    result += sign * num;\n    return result;\n}\n",
            "python": "def calculate(s: str) -> int:\n    result = 0\n    sign = 1\n    num = 0\n    st = []\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        else:\n            result += sign * num\n            num = 0\n            if c == '+':\n                sign = 1\n            elif c == '-':\n                sign = -1\n            elif c == '(':\n                st.append(result)\n                st.append(sign)\n                result = 0\n                sign = 1\n            elif c == ')':\n                prev_sign = st.pop()\n                prev_result = st.pop()\n                result = prev_result + prev_sign * result\n    result += sign * num\n    return result\n",
            "javascript": "function calculate(s) {\n    let result = 0, sign = 1, num = 0;\n    let st = [];\n    for (let c of s) {\n        if (/\\d/.test(c)) {\n            num = num * 10 + (c - '0');\n        } else {\n            result += sign * num;\n            num = 0;\n            if (c === '+') {\n                sign = 1;\n            } else if (c === '-') {\n                sign = -1;\n            } else if (c === '(') {\n                st.push(result);\n                st.push(sign);\n                result = 0;\n                sign = 1;\n            } else if (c === ')') {\n                let prev_sign = st.pop();\n                let prev_result = st.pop();\n                result = prev_result + prev_sign * result;\n            }\n        }\n    }\n    result += sign * num;\n    return result;\n}\n",
            "explanation": "The algorithm first initializes variables `result`, `sign`, and `num` along with a stack `st`. It iterates through each character of the given string, `s`. If a digit is encountered, we update `num`, otherwise, if an operator, `(` or `)` is found, we perform the appropriate operation and update the variables accordingly. For example, we store the current result and sign onto the stack when we encounter a `(` and calculate the result when we encounter a `)` and use the stack to track the values of previous results and signs. Finally, we return the final result after the iteration is complete."
        },
        "structure": {
            "c++": "int calculate(string s) \n    // Your code here\n}\n",
            "java": "public int calculate(String s) \n    // Your code here\n}\n",
            "python": "def calculate(s: str) -> int:\n    # Your code here\n\n",
            "javascript": "function calculate(s) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    string s = $args;\n    int result = calculate(s);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int calculate(String s) {\n    int result = 0, sign = 1, num = 0;\n    Stack<Integer> st = new Stack<>();\n    for (char c : s.toCharArray()) {\n        if (Character.isDigit(c)) {\n            num = num * 10 + (c - '0');\n        } else {\n            result += sign * num;\n            num = 0;\n            if (c == '+') {\n                sign = 1;\n            } else if (c == '-') {\n                sign = -1;\n            } else if (c == '(') {\n                st.push(result);\n                st.push(sign);\n                result = 0;\n                sign = 1;\n            } else if (c == ')') {\n                int prev_sign = st.pop();\n                int prev_result = st.pop();\n                result = prev_result + prev_sign * result;\n            }\n        }\n    }\n    result += sign * num;\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    s =$args\n    result = calculate(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = calculate(s);\n    console.log(result);\n}"
        }
    },
    "225": {
        "title": "Implement LIFO Stack using Two Queues",
        "description": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (`push`, `top`, `pop`, and `empty`). You must use only standard operations of a queue, which means that only `push to back`, `peek/pop from front`, `size` and `is empty` operations are valid. Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.",
        "example": "Example:\n\nInput:\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False\n\nOutput:\nnull, null, null, 2, 2, false\n\nExplanation:\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False",
        "level": "Medium",
        "tags": [
            "stack",
            "queue",
            "data structure"
        ],
        "test_cases": {
            "inputs": [
                [
                    "MyStack",
                    "push",
                    "push",
                    "top",
                    "pop",
                    "empty"
                ],
                [
                    [],
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [],
                    [],
                    []
                ]
            ],
            "outputs": [
                [
                    null,
                    null,
                    null,
                    2,
                    2,
                    false
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <queue>\n\nclass MyStack {\npublic:\n    std::queue<int> q1, q2;\n\n    void push(int x) {\n        q2.push(x);\n        while (!q1.empty()) {\n            q2.push(q1.front());\n            q1.pop();\n        }\n        std::swap(q1, q2);\n    }\n\n    int pop() {\n        int top = q1.front();\n        q1.pop();\n        return top;\n    }\n\n    int top() {\n        return q1.front();\n    }\n\n    bool empty() {\n        return q1.empty();\n    }\n};\n",
            "java": "import java.util.*;\n\nclass MyStack {\n    Queue<Integer> q1 = new LinkedList<>();\n    Queue<Integer> q2 = new LinkedList<>();\n\n    public void push(int x) {\n        q2.add(x);\n        while (!q1.isEmpty()) {\n            q2.add(q1.remove());\n        }\n        Queue<Integer> temp = q1;\n        q1 = q2;\n        q2 = temp;\n    }\n\n    public int pop() {\n        return q1.remove();\n    }\n\n    public int top() {\n        return q1.peek();\n    }\n\n    public boolean empty() {\n        return q1.isEmpty();\n    }\n}\n",
            "python": "from collections import deque\n\nclass MyStack:\n\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        self.q2.append(x)\n        while self.q1:\n            self.q2.append(self.q1.popleft())\n        self.q1, self.q2 = self.q2, self.q1\n\n    def pop(self) -> int:\n        return self.q1.popleft()\n\n    def top(self) -> int:\n        return self.q1[0]\n\n    def empty(self) -> bool:\n        return not self.q1\n",
            "javascript": "class MyStack {\n    constructor() {\n        this.q1 = [];\n        this.q2 = [];\n    }\n\n    push(x) {\n        this.q2.push(x);\n        while (this.q1.length > 0) {\n            this.q2.push(this.q1.shift());\n        }\n        [this.q1, this.q2] = [this.q2, this.q1];\n    }\n\n    pop() {\n        return this.q1.shift();\n    }\n\n    top() {\n        return this.q1[0];\n    }\n\n    empty() {\n        return this.q1.length === 0;\n    }\n}\n",
            "explanation": "We have two queues q1 and q2, where we will store the elements. For every push operation, we first push the new element into q2, then move all the elements in the q1 to q2, and then swap both queues. The pop and top operations will always operate on q1, which maintains the elements in the reverse order, simulating the LIFO order of a stack. The empty operation simply checks if q1 is empty.\n\nThe time complexity for push is O(n), while the time complexities for top, pop, and empty are O(1)."
        },
        "structure": {
            "c++": "#include <queue>\n\nclass MyStack \n    // Your code here\n};\n",
            "java": "import java.util.*;\n\nclass MyStack \n    // Your code here\n}\n",
            "python": "from collections import deque\n    # Your code here\n\n",
            "javascript": "class MyStack \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "void push(int x) {\n        q2.push(x);\n        while (!q1.empty()) {\n            q2.push(q1.front());\n            q1.pop();\n        }\n        std::swap(q1, q2);\n    }\n\n    int pop() {\n        int top = q1.front();\n        q1.pop();\n        return top;\n    }\n\n    int top() {\n        return q1.front();\n    }\n\n    bool empty() {\n        return q1.empty();\n    }",
            "java": "public static void main(String[] args) {\n        int n = $args;\n        boolean result = isPowerOfFour(n);\n        System.out.println(result);\n    }\n",
            "python": "if __name__ == \"__main__\":\n    stack = MyStack()\n    stack.push($args[0])\n    stack.push($args[1])\n    stack.push($args[2])\n    result1 = stack.pop()\n    result2 = stack.top()\n    result3 = stack.empty()\n    print(result1)\n    print(result2)\n    print(result3)",
            "javascript": "function main() {\n    const stack = new MyStack();\n    stack.push(1);\n    stack.push(2);\n    stack.push(3);\n    const result1 = stack.pop();\n    const result2 = stack.top();\n    const result3 = stack.empty();\n    console.log(result1);\n    console.log(result2);\n    console.log(result3);\n}"
        }
    },
    "227": {
        "title": "Evaluate Expression",
        "description": "Given a string `s` which represents an expression, evaluate this expression and return its value. The integer division should truncate toward zero. You may assume that the given expression is always valid. All intermediate results will be in the range of `[-231, 231 - 1]`. Note that you are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.",
        "example": "Example 1:\n\nInput: s = \"3+2*2\"\nOutput: 7\n\nExample 2:\n\nInput: s = \" 3/2 \"\nOutput: 1\n\nExample 3:\n\nInput: s = \" 3+5 / 2 \"\nOutput: 5",
        "level": "Medium",
        "tags": [
            "string",
            "math"
        ],
        "test_cases": {
            "inputs": [
                "\"3+2*2\"",
                "\" 3/2 \"",
                "\" 3+5 / 2 \"",
                "\"10-5*2\"",
                "\"100/10+5\"",
                "\"2*3-4/2\"",
                "\"1+2+3+4+5\"",
                "\"10-5-2-1\"",
                "\"100/10/2\"",
                "\"2*3*4*5\"",
                "\"1+2-3+4-5\"",
                "\"10-5+2-1\"",
                "\"100/10*2\"",
                "\"2*3+4/2\"",
                "\"1+2*3-4/2\"",
                "\"10-5*2+1\"",
                "\"100/10+5*2\"",
                "\"2*3-4/2+1\"",
                "\"1+2+3+4+5*2\"",
                "\"10-5-2-1*2\"",
                "\"100/10/2+1\""
            ],
            "outputs": [
                7,
                1,
                5,
                0,
                15,
                4,
                15,
                2,
                10,
                120,
                -1,
                6,
                40,
                7,
                4,
                0,
                110,
                5,
                20,
                6,
                11
            ]
        },
        "sample_code": {
            "c++": "int calculate(string s) {\n    int result = 0, num = 0, sign = 1;\n    stack<int> st;\n    \n    for (char c : s) {\n        if (isdigit(c)) {\n            num = num * 10 + (c - '0');\n        } else if (c == '+') {\n            result += sign * num;\n            num = 0;\n            sign = 1;\n        } else if (c == '-') {\n            result += sign * num;\n            num = 0;\n            sign = -1;\n        } else if (c == '(') {\n            st.push(result);\n            st.push(sign);\n            result = 0;\n            sign = 1;\n        } else if (c == ')') {\n            result += sign * num;\n            num = 0;\n            result *= st.top(); st.pop();\n            result += st.top(); st.pop();\n        }\n    }\n    if (num) result += sign * num;\n    return result;\n}\n",
            "java": "public int calculate(String s) {\n    int result = 0, num = 0, sign = 1;\n    Stack<Integer> stack = new Stack<>();\n\n    for (char c : s.toCharArray()) {\n        if (Character.isDigit(c)) {\n            num = num * 10 + (c - '0');\n        } else if (c == '+') {\n            result += sign * num;\n            num = 0;\n            sign = 1;\n        } else if (c == '-') {\n            result += sign * num;\n            num = 0;\n            sign = -1;\n        } else if (c == '(') {\n            stack.push(result);\n            stack.push(sign);\n            result = 0;\n            sign = 1;\n        } else if (c == ')') {\n            result += sign * num;\n            num = 0;\n            result *= stack.pop();\n            result += stack.pop();\n        }\n    }\n    if (num != 0) result += sign * num;\n    return result;\n}\n",
            "python": "def calculate(s: str) -> int:\n    result, num, sign, stack = 0, 0, 1, []\n\n    for i in range(len(s)):\n        if s[i].isdigit():\n            num = num * 10 + int(s[i])\n        if s[i] in \"+-*/\" or s[i]== ')' or s[i] == len(s) - 1:\n            if sign == \"+\":\n                stack.append(num)\n            elif sign == \"-\":\n                stack.append(-num)\n            elif stack and sign == \"*\":\n                stack.append(stack.pop() * num)\n            elif stack and sign == \"/\":\n                stack.append(int(stack.pop() / num))\n            sign = s[i]\n            num = 0\n        if s[i] == \"(\":\n            stack.append(sign)\n            stack.append(0)\n            sign = \"+\"\n        if s[i]== \")\":\n            if stack:  # Check if the stack is not empty\n                temp = 0\n                op = stack.pop()\n                while op != \"(\":\n                    temp = temp * op\n                    if stack: \n                        op = stack.pop()\n                    else:\n                        break\n                stack[-1] += temp\n\n    return sum(stack)",
            "javascript": "function calculate(s) {\n    let result = 0, num = 0, sign = 1;\n    const stack = [];\n\n    for (const c of s) {\n        if ('0' <= c && c <= '9') {\n            num = num * 10 + parseInt(c);\n        } else if (c === '+') {\n            result += sign * num;\n            num = 0;\n            sign = 1;\n        } else if (c === '-') {\n            result += sign * num;\n            num = 0;\n            sign = -1;\n        } else if (c === '(') {\n            stack.push(result);\n            stack.push(sign);\n            result = 0;\n            sign = 1;\n        } else if (c === ')') {\n            result += sign * num;\n            num = 0;\n            result *= stack.pop();\n            result += stack.pop();\n        }\n    }\n    if (num) result += sign * num;\n    return result;\n}\n",
            "explanation": "The algorithm uses an integer, `result`, to store the intermediate results throughout the evaluation process. It also uses a stack to handle the nested parentheses that could be in the given expression. \n\n1. Initialize `result`, `num`, `sign`, and a stack.\n2. Loop through the given string, character by character.\n3. If the character is a digit, update `num` accordingly.\n4. If the character is a '+' or '-', update the `result` with the current `num` and update the `sign`.\n5. If the character is an '(', push the current `result` and `sign` onto the stack and reset `result` and `sign`.\n6. If the character is a ')', update `result` with the current `num`, then multiply `result` by the top of the stack (pop), and add the next top of the stack (pop) to `result`.\n7. After the loop, add the current `num` to the result if it's not 0.\n8. Return `result`."
        },
        "structure": {
            "c++": "int calculate(string s) \n    // Your code here\n}\n",
            "java": "public int calculate(String s) \n    // Your code here\n}\n",
            "python": "def calculate(s: str) -> int:\n    # Your code here\n\n",
            "javascript": "function calculate(s) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int calculate(string s) {\n    int result = 0, num = 0, sign = 1;\n    stack<int> st;\n    \n    for (char c : s) {\n        if (isdigit(c)) {\n            num = num * 10 + (c - '0');\n        } else if (c == '+') {\n            result += sign * num;\n            num = 0;\n            sign = 1;\n        } else if (c == '-') {\n            result += sign * num;\n            num = 0;\n            sign = -1;\n        } else if (c == '(') {\n            st.push(result);\n            st.push(sign);\n            result = 0;\n            sign = 1;\n        } else if (c == ')') {\n            result += sign * num;\n            num = 0;\n            result *= st.top(); st.pop();\n            result += st.top(); st.pop();\n        }\n    }\n    if (num) result += sign * num;\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    result = calculate($args)\n    print(result)"
        }
    },
    "228": {
        "title": "Smallest Sorted Ranges",
        "description": "You are given a sorted unique integer array `nums`. A range `[a,b]` is the set of all integers from `a` to `b` (inclusive). Return the smallest sorted list of ranges that cover all the numbers in the array exactly. Each range `[a,b]` in the list should be output as: 'a->b' if `a != b` or 'a' if `a == b`.",
        "example": "Example:\n\nInput: nums = [0,1,2,4,5,7]\nOutput: ['0->2', '4->5', '7']\nExplanation: The ranges are:\n[0,2] --> '0->2'\n[4,5] --> '4->5'\n[7,7] --> '7'",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    0,
                    1,
                    2,
                    4,
                    5,
                    7
                ],
                [
                    0,
                    2,
                    3,
                    4,
                    6,
                    8,
                    9
                ],
                [],
                [
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50
                ],
                [
                    100,
                    200,
                    300,
                    400,
                    500
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100
                ],
                [
                    100,
                    200,
                    300,
                    400,
                    500,
                    600,
                    700,
                    800,
                    900,
                    1000
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100,
                    110
                ],
                [
                    100,
                    200,
                    300,
                    400,
                    500,
                    600,
                    700,
                    800,
                    900,
                    1000,
                    1100
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9,
                    11,
                    13,
                    15,
                    17,
                    19
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10,
                    12,
                    14,
                    16,
                    18,
                    20
                ],
                [
                    0,
                    2,
                    4,
                    6,
                    8,
                    10,
                    12,
                    14,
                    16,
                    18,
                    20
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ]
            ],
            "outputs": [
                [
                    "0->2",
                    "4->5",
                    "7"
                ],
                [
                    "0",
                    "2->4",
                    "6",
                    "8->9"
                ],
                [],
                [
                    "1"
                ],
                [
                    "1->5"
                ],
                [
                    "10->50"
                ],
                [
                    "100->500"
                ],
                [
                    "1",
                    "3",
                    "5",
                    "7",
                    "9"
                ],
                [
                    "2->10"
                ],
                [
                    "0->9"
                ],
                [
                    "10->100"
                ],
                [
                    "100->1000"
                ],
                [
                    "1->10"
                ],
                [
                    "10->110"
                ],
                [
                    "100->1100"
                ],
                [
                    "1->19"
                ],
                [
                    "2->20"
                ],
                [
                    "0->20"
                ],
                [
                    "1->20"
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n\nstd::vector<std::string> find_ranges(std::vector<int>& nums) {\n    std::vector<std::string> result;\n    int n = nums.size();\n    if (n == 0) return result;\n\n    int start = nums[0];\n    for (int i = 1; i < n; ++i) {\n        if (nums[i] > nums[i-1] + 1) {\n            if (start == nums[i-1])\n                result.push_back(std::to_string(start));\n            else\n                result.push_back(std::to_string(start) + \"->\" + std::to_string(nums[i-1]));\n            start = nums[i];\n        }\n    }\n\n    if (start == nums[n-1])\n        result.push_back(std::to_string(start));\n    else\n        result.push_back(std::to_string(start) + \"->\" + std::to_string(nums[n-1]));\n\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> findRanges(int[] nums) {\n    List<String> result = new ArrayList<>();\n    int n = nums.length;\n    if (n == 0) return result;\n\n    int start = nums[0];\n    for (int i = 1; i < n; i++) {\n        if (nums[i] > nums[i-1] + 1) {\n            if (start == nums[i-1])\n                result.add(Integer.toString(start));\n            else\n                result.add(start + \"->\" + nums[i-1]);\n            start = nums[i];\n        }\n    }\n\n    if (start == nums[n-1])\n        result.add(Integer.toString(start));\n    else\n        result.add(start + \"->\" + nums[n-1]);\n\n    return result;\n}\n",
            "python": "from typing import List\n\ndef find_ranges(nums: List[int]) -> List[str]:\n    result = []\n    n = len(nums)\n    if n == 0: \n        return result\n\n    start = nums[0]\n    for i in range(1, n):\n        if nums[i] > nums[i-1] + 1:\n            if start == nums[i-1]:\n                result.append(str(start))\n            else:\n                result.append(str(start) + \"->\" + str(nums[i-1]))\n            start = nums[i]\n\n    if start == nums[n-1]:\n        result.append(str(start))\n    else:\n        result.append(str(start) + \"->\" + str(nums[n-1]))\n\n    return result\n",
            "javascript": "function findRanges(nums) {\n    const result = [];\n    const n = nums.length;\n    if (n === 0) return result;\n\n    let start = nums[0];\n    for (let i = 1; i < n; i++) {\n        if (nums[i] > nums[i - 1] + 1) {\n            if (start === nums[i - 1])\n                result.push(`${start}`);\n            else\n                result.push(`${start}->${nums[i - 1]}`);\n            start = nums[i];\n        }\n    }\n\n    if (start === nums[n - 1])\n        result.push(`${start}`);\n    else\n        result.push(`${start}->${nums[n - 1]}`);\n\n    return result;\n}\n",
            "explanation": "The algorithm involves iterating through the input array and using a variable named `start` to keep track of the beginning of the current range. For each element, we compare it with the previous element to check if they form a continuous range by verifying if the current element is greater than the previous element plus 1. If they don't form a continuous range, we know that the current range has ended and a new range starts at the current element. So, we add the current range to the result in the required format and update the start variable to the current element. This process continues until all elements are processed. Finally, we add the last range to the result in the required format.\n\nSince the input array is sorted and unique, this greedy approach ensures that we find the smallest sorted list of ranges that cover all the numbers in the array."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n\nstd::vector<std::string> find_ranges(std::vector<int>& nums) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> findRanges(int[] nums) \n    // Your code here\n}\n",
            "python": "from typing import List\n    # Your code here\n\n",
            "javascript": "function findRanges(nums) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <iostream>\n\nint main() {\n    std::vector<int> nums = $args;\n    std::vector<std::string> result = find_ranges(nums);\n    for (const std::string& range : result) {\n        std::cout << range << std::endl;\n    }\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    result = find_ranges(inputs)\n    print(result)"
        }
    },
    "233": {
        "title": "Counting Digit 1",
        "description": "Given an integer `n`, count the total number of digit `1` appearing in all non-negative integers less than or equal to `n`.",
        "example": "Example:\n\nInput: n = 13\nOutput: 6\n\nExplanation: The digit 1 appears in the numbers 1, 10, 11, 12, and 13, so the total count is 6.",
        "level": "Easy",
        "tags": [
            "math",
            "counting",
            "digits"
        ],
        "test_cases": {
            "inputs": [
                13,
                0,
                1,
                9,
                10,
                11,
                99,
                100,
                101,
                999,
                1000,
                1001,
                9999,
                10000,
                10001,
                99999,
                100000,
                100001,
                999999,
                1000000
            ],
            "outputs": [
                6,
                0,
                1,
                1,
                2,
                4,
                20,
                21,
                23,
                300,
                400,
                401,
                4000,
                5000,
                5001,
                60000,
                70000,
                70001,
                800000,
                900000
            ]
        },
        "sample_code": {
            "c++": "int countDigitOne(int n) {\n    int count = 0;\n    for(long long i = 1; i <= n; i *= 10){\n        int divider = i * 10;\n        count += (n / divider) * i + min(max(n % divider - i + 1, 0LL), i);\n    }\n    return count;\n}\n",
            "java": "public int countDigitOne(int n) {\n    int count = 0;\n    for(long i = 1; i <= n; i *= 10){\n        long divider = i * 10;\n        count += (n / divider) * i + Math.min(Math.max(n % divider - i + 1, 0), i);\n    }\n    return count;\n}\n",
            "python": "def countDigitOne(n):\n    count = 0\n    i = 1\n    while i <= n:\n        divider = i * 10\n        count += (n // divider) * i + min(max(n % divider - i + 1, 0), i)\n        i *= 10\n    return count\n",
            "javascript": "function countDigitOne(n) {\n    let count = 0;\n    for(let i = 1; i <= n; i *= 10){\n        let divider = i * 10;\n        count += Math.floor(n / divider) * i + Math.min(Math.max(n % divider - i + 1, 0), i);\n    }\n    return count;\n}\n",
            "explanation": "1. The algorithm uses a loop that iterates from the digit 1 to the highest digit in the given number, starting with 1 and incrementing by multiplying by 10 each iteration (1, 10, 100...).\n2. On each iteration, the algorithm checks how many times 1's appear in the current digit:\n   a. Calculates the occurrences of digit 1 contributed by the higher digits (n / divider) * i.\n   b. Counts the remaining occurrences in the current digit using the formula min(max(n % divider - i + 1, 0), i).\n3. It sums up the occurrences for each digit in a variable called `count`.\n4. When the loop ends, all occurrences of digit 1 have been considered, and `count` has the final sum of all occurrences.\n\nThe algorithm runs in O(log10(n)) time complexity since the loop runs for however many digits there are in the input number."
        },
        "structure": {
            "c++": "int countDigitOne(int n) \n    // Your code here\n}\n",
            "java": "public int countDigitOne(int n) \n    // Your code here\n}\n",
            "python": "def countDigitOne(n):\n    # Your code here\n\n",
            "javascript": "function countDigitOne(n) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = countDigitOne(n);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    input=$args\n    result = countDigitOne(input)\n    print(result)"
        }
    },
    "237": {
        "title": "Delete Node in a Singly Linked List",
        "description": "Given a singly-linked list `head` and a node `node` to be deleted, delete the given node from the linked list. You are not given access to the first node of `head`. All the values in the linked list are unique, and it is guaranteed that the given node `node` is not the last node in the list. Deleting the node means that its value should not exist in the linked list, the number of nodes should decrease by one, and the order of values before and after the node should remain the same.",
        "example": "Example:\n\nInput: head = [4,5,1,9], node = 5\nOutput: [4,1,9]\nExplanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.",
        "level": "Easy",
        "tags": [
            "linked list",
            "deletion"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        4,
                        5,
                        1,
                        9
                    ],
                    5
                ],
                [
                    [
                        4,
                        5,
                        1,
                        9
                    ],
                    1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    2
                ],
                [
                    [
                        7,
                        8,
                        9,
                        10
                    ],
                    8
                ],
                [
                    [
                        100,
                        200,
                        300,
                        400
                    ],
                    300
                ],
                [
                    [
                        0,
                        0,
                        0,
                        0
                    ],
                    0
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    6
                ],
                [
                    [
                        10,
                        20,
                        30,
                        40,
                        50
                    ],
                    40
                ],
                [
                    [
                        1,
                        3,
                        5,
                        7,
                        9
                    ],
                    3
                ],
                [
                    [
                        2,
                        4,
                        6,
                        8,
                        10
                    ],
                    10
                ],
                [
                    [
                        5,
                        10,
                        15,
                        20,
                        25
                    ],
                    15
                ],
                [
                    [
                        1000,
                        2000,
                        3000,
                        4000,
                        5000
                    ],
                    2000
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    5
                ],
                [
                    [
                        2,
                        4,
                        6,
                        8,
                        10,
                        12,
                        14,
                        16,
                        18,
                        20
                    ],
                    12
                ],
                [
                    [
                        3,
                        6,
                        9,
                        12,
                        15,
                        18,
                        21,
                        24,
                        27,
                        30
                    ],
                    9
                ],
                [
                    [
                        100,
                        200,
                        300,
                        400,
                        500,
                        600,
                        700,
                        800,
                        900,
                        1000
                    ],
                    500
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    7
                ],
                [
                    [
                        2,
                        4,
                        6,
                        8,
                        10,
                        12,
                        14,
                        16,
                        18,
                        20,
                        22,
                        24,
                        26,
                        28,
                        30
                    ],
                    24
                ],
                [
                    [
                        3,
                        6,
                        9,
                        12,
                        15,
                        18,
                        21,
                        24,
                        27,
                        30,
                        33,
                        36,
                        39,
                        42,
                        45
                    ],
                    36
                ],
                [
                    [
                        100,
                        200,
                        300,
                        400,
                        500,
                        600,
                        700,
                        800,
                        900,
                        1000,
                        1100,
                        1200,
                        1300,
                        1400,
                        1500
                    ],
                    900
                ]
            ],
            "outputs": [
                [
                    4,
                    1,
                    9
                ],
                [
                    4,
                    5,
                    9
                ],
                [
                    1,
                    3,
                    4
                ],
                [
                    7,
                    9,
                    10
                ],
                [
                    100,
                    200,
                    400
                ],
                [
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    7,
                    8,
                    9
                ],
                [
                    10,
                    20,
                    30,
                    50
                ],
                [
                    1,
                    5,
                    7,
                    9
                ],
                [
                    2,
                    4,
                    6,
                    8
                ],
                [
                    5,
                    10,
                    20,
                    25
                ],
                [
                    1000,
                    3000,
                    4000,
                    5000
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10,
                    14,
                    16,
                    18,
                    20
                ],
                [
                    3,
                    6,
                    9,
                    12,
                    15,
                    18,
                    21,
                    24,
                    30
                ],
                [
                    100,
                    200,
                    300,
                    400,
                    600,
                    700,
                    800,
                    900,
                    1000
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10,
                    12,
                    14,
                    16,
                    18,
                    20,
                    22,
                    26,
                    28,
                    30
                ],
                [
                    3,
                    6,
                    9,
                    12,
                    15,
                    18,
                    21,
                    24,
                    27,
                    30,
                    33,
                    39,
                    42,
                    45
                ],
                [
                    100,
                    200,
                    300,
                    400,
                    500,
                    600,
                    700,
                    800,
                    1000,
                    1100,
                    1200,
                    1300,
                    1400,
                    1500
                ]
            ]
        },
        "sample_code": {
            "c++": "void deleteNode(ListNode* node) {\n    ListNode* nextNode = node->next;\n    *node = *nextNode;\n    delete nextNode;\n}\n",
            "java": "public void deleteNode(ListNode node) {\n    ListNode nextNode = node.next;\n    node.val = nextNode.val;\n    node.next = nextNode.next;\n}\n",
            "python": "def deleteNode(node):\n    next_node = node.next\n    node.val = next_node.val\n    node.next = next_node.next\n",
            "javascript": "function deleteNode(node) {\n    const nextNode = node.next;\n    node.val = nextNode.val;\n    node.next = nextNode.next;\n}\n",
            "explanation": "The function takes in a node of the singly-linked list, which is the one to be deleted. Since we don't have access to the head of the list, we can't traverse the list to find the previous node.\n\nThe idea here is to replace the given node's value with the next node's value, and then update the given node's next pointer to skip the next node, effectively deleting the next node. Finally, we delete the next node if the language requires explicit memory management (e.g., C++).\n\nThis approach won't work if the node to be deleted is the tail of the list, but the problem statement guarantees that it won't be a tail node."
        },
        "structure": {
            "c++": "void deleteNode(ListNode* node) \n    // Your code here\n}\n",
            "java": "public void deleteNode(ListNode node) \n    // Your code here\n}\n",
            "python": "def deleteNode(node):\n    # Your code here\n\n",
            "javascript": "function deleteNode(node) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "void deleteNode(ListNode* node) {\n    ListNode* nextNode = node->next;\n    *node = *nextNode;\n    delete nextNode;\n}",
            "python": "if __name__ == \"__main__\":\n    node = ListNode($args)\n    deleteNode(node)\n    print(node)"
        }
    },
    "241": {
        "title": "Expression Evaluation",
        "description": "Given a string `expression` of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.",
        "example": "Example 1:\n\nInput: expression = \"2-1-1\"\nOutput: [0,2]\nExplanation:\n((2-1)-1) = 0\n(2-(1-1)) = 2\n\nExample 2:\n\nInput: expression = \"2*3-4*5\"\nOutput: [-34,-14,-10,-10,10]\nExplanation:\n(2*(3-(4*5))) = -34\n((2*3)-(4*5)) = -14\n((2*(3-4))*5) = -10\n(2*((3-4)*5)) = -10\n(((2*3)-4)*5) = 10",
        "level": "Medium",
        "tags": [
            "Math",
            "Recursion",
            "Dynamic Programming"
        ],
        "test_cases": {
            "inputs": [
                "\"2-1-1\"",
                "\"2*3-4*5\"",
                "\"1+2+3+4+5\"",
                "\"1*2*3*4*5\"",
                "\"1+2*3-4+5\"",
                "\"1*2+3-4*5\"",
                "\"1+2*3-4*5+6\"",
                "\"1*2+3-4*5+6\"",
                "\"1+2*3-4*5+6-7\"",
                "\"1*2+3-4*5+6-7\"",
                "\"1+2*3-4*5+6-7+8\"",
                "\"1*2+3-4*5+6-7+8\"",
                "\"1+2*3-4*5+6-7+8-9\"",
                "\"1*2+3-4*5+6-7+8-9\"",
                "\"1+2*3-4*5+6-7+8-9+10\"",
                "\"1*2+3-4*5+6-7+8-9+10\"",
                "\"1+2*3-4*5+6-7+8-9+10-11\"",
                "\"1*2+3-4*5+6-7+8-9+10-11\"",
                "\"1+2*3-4*5+6-7+8-9+10-11+12\"",
                "\"1*2+3-4*5+6-7+8-9+10-11+12\""
            ],
            "outputs": [
                [
                    0,
                    2
                ],
                [
                    -34,
                    -14,
                    -10,
                    -10,
                    10
                ],
                [
                    15
                ],
                [
                    120
                ],
                [
                    6,
                    8,
                    10,
                    12,
                    16
                ],
                [
                    -14,
                    -10,
                    -2,
                    2,
                    6
                ],
                [
                    -7,
                    -1,
                    5,
                    11,
                    17
                ],
                [
                    -7,
                    -1,
                    5,
                    11,
                    17,
                    23
                ],
                [
                    -14,
                    -8,
                    0,
                    6,
                    12,
                    18,
                    24
                ],
                [
                    -14,
                    -8,
                    0,
                    6,
                    12,
                    18,
                    24,
                    32
                ],
                [
                    -21,
                    -15,
                    -7,
                    -1,
                    5,
                    11,
                    17,
                    23,
                    31
                ],
                [
                    -21,
                    -15,
                    -7,
                    -1,
                    5,
                    11,
                    17,
                    23,
                    31,
                    39
                ],
                [
                    -28,
                    -22,
                    -14,
                    -8,
                    0,
                    6,
                    12,
                    18,
                    24,
                    32,
                    40
                ],
                [
                    -28,
                    -22,
                    -14,
                    -8,
                    0,
                    6,
                    12,
                    18,
                    24,
                    32,
                    40,
                    50
                ],
                [
                    -36,
                    -30,
                    -22,
                    -16,
                    -8,
                    0,
                    6,
                    12,
                    18,
                    24,
                    32,
                    40,
                    50
                ],
                [
                    -36,
                    -30,
                    -22,
                    -16,
                    -8,
                    0,
                    6,
                    12,
                    18,
                    24,
                    32,
                    40,
                    50,
                    62
                ],
                [
                    -45,
                    -39,
                    -31,
                    -25,
                    -17,
                    -9,
                    -1,
                    5,
                    11,
                    17,
                    23,
                    31,
                    39,
                    49,
                    61
                ],
                [
                    -45,
                    -39,
                    -31,
                    -25,
                    -17,
                    -9,
                    -1,
                    5,
                    11,
                    17,
                    23,
                    31,
                    39,
                    49,
                    61,
                    75
                ],
                [
                    -55,
                    -49,
                    -41,
                    -35,
                    -27,
                    -19,
                    -11,
                    -3,
                    3,
                    9,
                    15,
                    23,
                    31,
                    41,
                    53,
                    67,
                    83
                ],
                [
                    -55,
                    -49,
                    -41,
                    -35,
                    -27,
                    -19,
                    -11,
                    -3,
                    3,
                    9,
                    15,
                    23,
                    31,
                    41,
                    53,
                    67,
                    83,
                    101
                ]
            ]
        },
        "sample_code": {
            "c++": "#include<vector>\n#include<string>\n\nusing namespace std;\n\nvector<int> diffWaysToCompute(string input) {\n    vector<int> result;\n    for (int i = 0; i < input.size(); i++) {\n        char c = input[i];\n        if (c == '+' || c == '-' || c == '*') {\n            auto left = diffWaysToCompute(input.substr(0, i));\n            auto right = diffWaysToCompute(input.substr(i + 1));\n            for (int l : left) {\n                for (int r : right) {\n                    if (c == '+') result.push_back(l + r);\n                    else if (c == '-') result.push_back(l - r);\n                    else if (c == '*') result.push_back(l * r);\n                }\n            }\n        }\n    }\n    if (result.empty()) result.push_back(stoi(input));\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> diffWaysToCompute(String input) {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 0; i < input.length(); i++) {\n        char c = input.charAt(i);\n        if (c == '+' || c == '-' || c == '*') {\n            List<Integer> left = diffWaysToCompute(input.substring(0, i));\n            List<Integer> right = diffWaysToCompute(input.substring(i + 1));\n            for (int l : left) {\n                for (int r : right) {\n                    if (c == '+') result.add(l + r);\n                    else if (c == '-') result.add(l - r);\n                    else if (c == '*') result.add(l * r);\n                }\n            }\n        }\n    }\n    if (result.isEmpty()) result.add(Integer.parseInt(input));\n    return result;\n}\n",
            "python": "def diffWaysToCompute(input: str):\n    result = []\n    for i in range(len(input)):\n        c = input[i]\n        if c == '+' or c == '-' or c == '*':\n            left = diffWaysToCompute(input[:i])\n            right = diffWaysToCompute(input[i + 1:])\n            for l in left:\n                for r in right:\n                    if c == '+': result.append(l + r)\n                    elif c == '-': result.append(l - r)\n                    elif c == '*': result.append(l * r)\n    if not result:\n        result.append(int(input))\n    return result\n",
            "javascript": "function diffWaysToCompute(input) {\n    const result = [];\n    for (let i = 0; i < input.length; i++) {\n        const c = input[i];\n        if (c === '+' || c === '-' || c === '*') {\n            const left = diffWaysToCompute(input.slice(0, i));\n            const right = diffWaysToCompute(input.slice(i + 1));\n            for (const l of left) {\n                for (const r of right) {\n                    if (c === '+') result.push(l + r);\n                    else if (c === '-') result.push(l - r);\n                    else if (c === '*') result.push(l * r);\n                }\n            }\n        }\n    }\n    if (result.length === 0) result.push(parseInt(input));\n    return result;\n}\n",
            "explanation": "The algorithm is a recursive divide-and-conquer approach. It starts by iterating through the `input` string and looks for operators (+, -, *). When an operator is found, the problem is divided into two sub-problems: left and right. These sub-problems are independently solved through recursively calling the `diffWaysToCompute` function with corresponding substrings. \n\nEach recursion returns a list of possible results for each sub-problem. For each operator, we combine these results by iterating through both lists and performing the corresponding operation (addition, subtraction, or multiplication).\n\nIf no operators are present in the input string, a base case is reached, and the current number in the input string is returned as the only result. The recursion ultimately produces a list of all possible results for the original expression by combining results from all sub-problems."
        },
        "structure": {
            "c++": "#include<vector>\n#include<string>\n\nusing namespace std;\n\nvector<int> diffWaysToCompute(string input) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> diffWaysToCompute(String input) \n    // Your code here\n}\n",
            "python": "def diffWaysToCompute(input: str):\n    # Your code here\n\n",
            "javascript": "function diffWaysToCompute(input) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include<vector>\n#include<string>\n#include<iostream>\n\nusing namespace std;\n\nvector<int> diffWaysToCompute(string input) {\n    vector<int> result;\n    for (int i = 0; i < input.size(); i++) {\n        char c = input[i];\n        if (c == '+' || c == '-' || c == '*') {\n            auto left = diffWaysToCompute(input.substr(0, i));\n            auto right = diffWaysToCompute(input.substr(i + 1));\n            for (int l : left) {\n                for (int r : right) {\n                    if (c == '+') result.push_back(l + r);\n                    else if (c == '-') result.push_back(l - r);\n                    else if (c == '*') result.push_back(l * r);\n                }\n            }\n        }\n    }\n    if (result.empty()) result.push_back(stoi(input));\n    return result;\n}\n\nint main() {\n    string input = $args;\n    vector<int> result = diffWaysToCompute(input);\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    input=$args\n    result = diffWaysToCompute(input)\n    print(result)"
        }
    },
    "243": {
        "title": "Shortest Distance Between Words",
        "description": "Given an array of strings `wordsDict` and two different strings that already exist in the array `word1` and `word2`, write a function `shortestDistance` to return the shortest distance between these two words in the list.",
        "example": "Example:\n\nInput: wordsDict = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"], word1 = \"coding\", word2 = \"practice\"\nOutput: 3\n\nExplanation: The shortest distance between \"coding\" and \"practice\" is 3, as they appear at indices 3 and 0 respectively.\n\nInput: wordsDict = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"], word1 = \"makes\", word2 = \"coding\"\nOutput: 1\n\nExplanation: The shortest distance between \"makes\" and \"coding\" is 1, as they appear at indices 1 and 3 respectively.",
        "level": "Easy",
        "tags": [
            "array",
            "string",
            "search"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "practice",
                        "makes",
                        "perfect",
                        "coding",
                        "makes"
                    ],
                    "coding",
                    "practice"
                ],
                [
                    [
                        "practice",
                        "makes",
                        "perfect",
                        "coding",
                        "makes"
                    ],
                    "makes",
                    "coding"
                ],
                [
                    [
                        "apple",
                        "banana",
                        "orange",
                        "apple",
                        "grape"
                    ],
                    "apple",
                    "grape"
                ],
                [
                    [
                        "hello",
                        "world",
                        "hello",
                        "hello",
                        "world"
                    ],
                    "hello",
                    "world"
                ],
                [
                    [
                        "cat",
                        "dog",
                        "cat",
                        "cat",
                        "dog"
                    ],
                    "dog",
                    "cat"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d",
                        "e"
                    ],
                    "a",
                    "e"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d",
                        "e"
                    ],
                    "b",
                    "d"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d",
                        "e"
                    ],
                    "c",
                    "c"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d",
                        "e"
                    ],
                    "d",
                    "d"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d",
                        "e"
                    ],
                    "e",
                    "a"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "a",
                    "a"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "a",
                    "b"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "b",
                    "b"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "b",
                    "c"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "c",
                    "d"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "d",
                    "e"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "e",
                    "e"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "e",
                    "f"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "f",
                    "f"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "f",
                    "g"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "g",
                    "h"
                ]
            ],
            "outputs": [
                3,
                1,
                1,
                1,
                2,
                4,
                2,
                0,
                0,
                4,
                1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <climits>\n\nint shortestDistance(std::vector<std::string> wordsDict, std::string word1, std::string word2) {\n    int idx1 = -1, idx2 = -1, minDistance = INT_MAX;\n    for (int i = 0; i < wordsDict.size(); i++) {\n        if (wordsDict[i] == word1) idx1 = i;\n        if (wordsDict[i] == word2) idx2 = i;\n        if (idx1 != -1 && idx2 != -1)\n            minDistance = std::min(minDistance, std::abs(idx1 - idx2));\n    }\n    return minDistance;\n}\n",
            "java": "public int shortestDistance(String[] wordsDict, String word1, String word2) {\n    int idx1 = -1, idx2 = -1, minDistance = Integer.MAX_VALUE;\n    for (int i = 0; i < wordsDict.length; i++) {\n        if (word1.equals(wordsDict[i])) idx1 = i;\n        if (word2.equals(wordsDict[i])) idx2 = i;\n        if (idx1 != -1 && idx2 != -1)\n            minDistance = Math.min(minDistance, Math.abs(idx1 - idx2));\n    }\n    return minDistance;\n}\n",
            "python": "def shortestDistance(wordsDict, word1, word2):\n    idx1, idx2, minDistance = -1, -1, float('inf')\n    for i, word in enumerate(wordsDict):\n        if word == word1:\n            idx1 = i\n        if word == word2:\n            idx2 = i\n        if idx1 != -1 and idx2 != -1:\n            minDistance = min(minDistance, abs(idx1 - idx2))\n    return minDistance\n",
            "javascript": "function shortestDistance(wordsDict, word1, word2) {\n    let idx1 = -1, idx2 = -1, minDistance = Number.MAX_VALUE;\n    for (let i = 0; i < wordsDict.length; i++) {\n        if (wordsDict[i] === word1) idx1 = i;\n        if (wordsDict[i] === word2) idx2 = i;\n        if (idx1 !== -1 && idx2 !== -1)\n            minDistance = Math.min(minDistance, Math.abs(idx1 - idx2));\n    }\n    return minDistance;\n}\n",
            "explanation": "The algorithm iterates through the `wordsDict` list and uses two variables `idx1` and `idx2` to store the indices of the occurrences of `word1` and `word2`. Initially, both indices are set to `-1`. In each iteration, if `word1` or `word2` is found, the corresponding index variable will be updated to store the current index.\n\nAfter each index update, we check if both indices are not `-1`. If both indices are valid, the difference between the indices is computed, and `minDistance` is updated with the minimum value between the previously-stored minimum distance and the new distance.\n\nFinally, the algorithm returns the value of `minDistance`, which represents the shortest distance between `word1` and `word2` in the `wordsDict` list."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <climits>\n\nint shortestDistance(std::vector<std::string> wordsDict, std::string word1, std::string word2) \n    // Your code here\n}\n",
            "java": "public int shortestDistance(String[] wordsDict, String word1, String word2) \n    // Your code here\n}\n",
            "python": "def shortestDistance(wordsDict, word1, word2):\n    # Your code here\n\n",
            "javascript": "function shortestDistance(wordsDict, word1, word2) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <climits>\n#include <iostream>\n\nint main() {\n    std::vector<std::string> wordsDict = $args;\n    std::string word1 = $args;\n    std::string word2 = $args;\n    int result = shortestDistance(wordsDict, word1, word2);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public int shortestDistance(String[] wordsDict, String word1, String word2) {\n    int idx1 = -1, idx2 = -1, minDistance = Integer.MAX_VALUE;\n    for (int i = 0; i < wordsDict.length; i++) {\n        if (word1.equals(wordsDict[i])) idx1 = i;\n        if (word2.equals(wordsDict[i])) idx2 = i;\n        if (idx1 != -1 && idx2 != -1)\n            minDistance = Math.min(minDistance, Math.abs(idx1 - idx2));\n    }\n    return minDistance;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    wordsDict = inputs[0]\n    word1 = inputs[1]\n    word2 = inputs[2]\n    result = shortestDistance(wordsDict, word1, word2)\n    print(result)",
            "javascript": "function shortestDistance(wordsDict, word1, word2) {\n    const result = shortestDistance(wordsDict, word1, word2);\n    console.log(result);\n}"
        }
    },
    "245": {
        "title": "Shortest Distance Between Words",
        "description": "Given an array of strings `wordsDict` and two strings `word1` and `word2`, find the shortest distance between the occurrences of these two words in the list. Return the minimum number of words between the two occurrences.",
        "example": "For example, given the `wordsDict` array ['practice', 'makes', 'perfect', 'coding', 'makes'], and the words `word1` = 'makes' and `word2` = 'coding', the shortest distance between the occurrences of 'makes' and 'coding' is 1.\n\nInput: wordsDict = ['practice', 'makes', 'perfect', 'coding', 'makes'], word1 = 'makes', word2 = 'coding'\nOutput: 1\n\nGiven the same `wordsDict` array and the words `word1` = 'makes' and `word2` = 'makes', the shortest distance between the occurrences of 'makes' and 'makes' is 3.\n\nInput: wordsDict = ['practice', 'makes', 'perfect', 'coding', 'makes'], word1 = 'makes', word2 = 'makes'\nOutput: 3",
        "level": "Easy",
        "tags": [
            "array",
            "string",
            "search"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "practice",
                        "makes",
                        "perfect",
                        "coding",
                        "makes"
                    ],
                    "makes",
                    "coding"
                ],
                [
                    [
                        "practice",
                        "makes",
                        "perfect",
                        "coding",
                        "makes"
                    ],
                    "makes",
                    "makes"
                ],
                [
                    [
                        "hello",
                        "world",
                        "hello",
                        "coding",
                        "world"
                    ],
                    "hello",
                    "world"
                ],
                [
                    [
                        "apple",
                        "banana",
                        "orange",
                        "banana",
                        "apple"
                    ],
                    "banana",
                    "apple"
                ],
                [
                    [
                        "cat",
                        "dog",
                        "cat",
                        "dog",
                        "cat"
                    ],
                    "dog",
                    "cat"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d",
                        "e"
                    ],
                    "a",
                    "e"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d",
                        "e"
                    ],
                    "b",
                    "d"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d",
                        "e"
                    ],
                    "c",
                    "c"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d",
                        "e"
                    ],
                    "d",
                    "d"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d",
                        "e"
                    ],
                    "e",
                    "e"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "a",
                    "a"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "a",
                    "b"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "b",
                    "b"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "b",
                    "c"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "c",
                    "c"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "c",
                    "d"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "d",
                    "d"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "d",
                    "e"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "e",
                    "e"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "e",
                    "f"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "f",
                    "f"
                ]
            ],
            "outputs": [
                1,
                3,
                1,
                1,
                1,
                4,
                2,
                0,
                0,
                0,
                1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <limits>\n\nint shortestDistance(std::vector<std::string>& wordsDict, std::string word1, std::string word2) {\n    int index1 = -1, index2 = -1, minDistance = std::numeric_limits<int>::max();\n    for (int i = 0; i < wordsDict.size(); ++i) {\n        if (wordsDict[i] == word1) { index1 = i; }\n        if (wordsDict[i] == word2) { index2 = i; }\n        if (index1 != -1 && index2 != -1) {\n            minDistance = std::min(minDistance, std::abs(index1 - index2));\n        }\n    }\n    return minDistance;\n}\n",
            "java": "public int shortestDistance(String[] wordsDict, String word1, String word2) {\n    int index1 = -1, index2 = -1, minDistance = Integer.MAX_VALUE;\n    for (int i = 0; i < wordsDict.length; ++i) {\n        if (wordsDict[i].equals(word1)) { index1 = i; }\n        if (wordsDict[i].equals(word2)) { index2 = i; }\n        if (index1 != -1 && index2 != -1) {\n            minDistance = Math.min(minDistance, Math.abs(index1 - index2));\n        }\n    }\n    return minDistance;\n}\n",
            "python": "def shortest_distance(words_dict, word1, word2):\n    index1, index2, min_distance = -1, -1, float('inf')\n    for i, word in enumerate(words_dict):\n        if word == word1:\n            index1 = i\n        if word == word2:\n            index2 = i\n        if index1 != -1 and(index2 != -1):\n            min_distance = min(min_distance, abs(index1 - index2))\n    return min_distance\n",
            "javascript": "function shortestDistance(wordsDict, word1, word2) {\n    let index1 = -1, index2 = -1, minDistance = Infinity;\n    for (let i = 0; i < wordsDict.length; ++i) {\n        if (wordsDict[i] === word1) { index1 = i; }\n        if (wordsDict[i] === word2) { index2 = i; }\n        if (index1 !== -1 && index2 !== -1) {\n            minDistance = Math.min(minDistance, Math.abs(index1 - index2));\n        }\n    }\n    return minDistance;\n}\n",
            "explanation": "For each string in the given list `wordsDict`, initialize `index1` and `index2` to -1 and `minDistance` to the maximum possible value for the respective language. Iterate through the list of strings and update `index1` or `index2` if the current string is equal to `word1` or `word2`. If both `index1` and `index2` are not -1 (meaning both words have been found at least once), calculate the absolute difference between the indices and update `minDistance` if the current distance is less than the previous minimum distance.\n\nReturn `minDistance` once the loop is done iterating."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <limits>\n\nint shortestDistance(std::vector<std::string>& wordsDict, std::string word1, std::string word2) \n    // Your code here\n}\n",
            "java": "public int shortestDistance(String[] wordsDict, String word1, String word2) \n    // Your code here\n}\n",
            "python": "def shortest_distance(words_dict, word1, word2):\n    # Your code here\n\n",
            "javascript": "function shortestDistance(wordsDict, word1, word2) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <limits>\n#include <iostream>\n\nint main() {\n    std::vector<std::string> wordsDict = $args;\n    std::string word1 = $args;\n    std::string word2 = $args;\n    int result = shortestDistance(wordsDict, word1, word2);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    wordsDict = inputs[0]\n    word1 = inputs[1]\n    word2 = inputs[2]\n    result = shortest_distance(wordsDict, word1, word2)\n    print(result)"
        }
    },
    "246": {
        "title": "Strobogrammatic Number",
        "description": "Given a string `num` which represents an integer, return `true` if `num` is a strobogrammatic number. A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).",
        "example": "Example 1:\n\nInput: num = \"69\"\nOutput: true\n\nExample 2:\n\nInput: num = \"88\"\nOutput: true\n\nExample 3:\n\nInput: num = \"962\"\nOutput: false",
        "level": "Easy",
        "tags": [
            "String",
            "Math"
        ],
        "test_cases": {
            "inputs": [
                "\"69\"",
                "\"88\"",
                "\"962\"",
                "\"0\"",
                "\"1\"",
                "\"11\"",
                "\"101\"",
                "\"121\"",
                "\"609\"",
                "\"808\"",
                "\"906\"",
                "\"1001\"",
                "\"1111\"",
                "\"1234\"",
                "\"6789\"",
                "\"10001\"",
                "\"11111\"",
                "\"12321\"",
                "\"67876\"",
                "\"90009\"",
                "\"91119\""
            ],
            "outputs": [
                true,
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                false,
                true,
                false,
                true,
                false,
                false,
                false,
                false,
                true,
                false,
                true,
                true,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "bool isStrobogrammatic(string num) {\n    unordered_map<char, char> lookup {{'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}};\n    int left = 0, right = num.size() - 1;\n    while(left <= right) {\n        if(lookup[num[left]] != num[right]) return false;\n        left++;\n        right--;\n    }\n    return true;\n}\n",
            "java": "public boolean isStrobogrammatic(String num) {\n    HashMap<Character, Character> lookup = new HashMap<Character, Character>() {{\n        put('0', '0');\n        put('1', '1');\n        put('6', '9');\n        put('8', '8');\n        put('9', '6');\n    }};\n    int left = 0, right = num.length() - 1;\n    while(left <= right) {\n        if(!lookup.containsKey(num.charAt(left)) || lookup.get(num.charAt(left)) != num.charAt(right)) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n",
            "python": "def isStrobogrammatic(num: str) -> bool:\n    lookup = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}\n    left, right = 0, len(num) - 1\n    while left <= right:\n        if num[left] not in lookup or lookup[num[left]] != num[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n",
            "javascript": "function isStrobogrammatic(num) {\n    const lookup = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'};\n    let left = 0, right = num.length - 1;\n    while(left <= right) {\n        if(!(num[left] in lookup) || lookup[num[left]] !== num[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n",
            "explanation": "The algorithm uses a while loop and a dictionary (lookup) to check if the given string is strobogrammatic. The main idea is to iterate through the string with two pointers, `left` and `right`. The `left` pointer starts at the beginning of the string and `right` starts at the end.\n\nFor each step of the while loop:\n1. Check if the character at the `left` pointer is in the `lookup` dictionary, if not, return false.\n2. Check if the mapped (rotated) character of the character at the `left` pointer matches the character at the `right` pointer, if not, return false.\n3. Increment `left` pointer and decrement `right` pointer.\n\nIf the loop finishes iterating through the string without returning false, then return true as the string is strobogrammatic."
        },
        "structure": {
            "c++": "bool isStrobogrammatic(string num) \n    // Your code here\n}\n",
            "java": "public boolean isStrobogrammatic(String num) \n    // Your code here\n}\n",
            "python": "def isStrobogrammatic(num: str) -> bool:\n    # Your code here\n\n",
            "javascript": "function isStrobogrammatic(num) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "bool isStrobogrammatic(string num) {\n    unordered_map<char, char> lookup {{'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}};\n    int left = 0, right = num.size() - 1;\n    while(left <= right) {\n        if(lookup[num[left]] != num[right]) return false;\n        left++;\n        right--;\n    }\n    return true;\n}",
            "java": "public boolean isStrobogrammatic(String num) {\n    HashMap<Character, Character> lookup = new HashMap<Character, Character>() {{\n        put('0', '0');\n        put('1', '1');\n        put('6', '9');\n        put('8', '8');\n        put('9', '6');\n    }};\n    int left = 0, right = num.length() - 1;\n    while(left <= right) {\n        if(!lookup.containsKey(num.charAt(left)) || lookup.get(num.charAt(left)) != num.charAt(right)) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}",
            "python": "if __name__ == \"__main__\":\n    num = $args\n    result = isStrobogrammatic(num)\n    print(result)"
        }
    },
    "248": {
        "title": "Strobogrammatic Number Count",
        "description": "Given two strings `low` and `high` that represent two integers `low` and `high` where `low <= high`, return the number of strobogrammatic numbers in the range `[low, high]`. A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).",
        "example": "Example:\n\nInput: low = \"50\", high = \"100\"\nOutput: 3\n\nExplanation: The strobogrammatic numbers in the range [50, 100] are 69, 88, and 96.\n\nInput: low = \"0\", high = \"0\"\nOutput: 1\n\nExplanation: The only strobogrammatic number in the range [0, 0] is 0.",
        "level": "Medium",
        "tags": [
            "Math",
            "String"
        ],
        "test_cases": {
            "inputs": [
                [
                    "50",
                    "100"
                ],
                [
                    "0",
                    "0"
                ],
                [
                    "1",
                    "9"
                ],
                [
                    "10",
                    "100"
                ],
                [
                    "100",
                    "1000"
                ],
                [
                    "1000",
                    "10000"
                ],
                [
                    "10000",
                    "100000"
                ],
                [
                    "100000",
                    "1000000"
                ],
                [
                    "1000000",
                    "10000000"
                ],
                [
                    "10000000",
                    "100000000"
                ],
                [
                    "100000000",
                    "1000000000"
                ],
                [
                    "1000000000",
                    "10000000000"
                ],
                [
                    "10000000000",
                    "100000000000"
                ],
                [
                    "100000000000",
                    "1000000000000"
                ],
                [
                    "1000000000000",
                    "10000000000000"
                ],
                [
                    "10000000000000",
                    "100000000000000"
                ],
                [
                    "100000000000000",
                    "1000000000000000"
                ],
                [
                    "1000000000000000",
                    "10000000000000000"
                ],
                [
                    "10000000000000000",
                    "100000000000000000"
                ],
                [
                    "100000000000000000",
                    "1000000000000000000"
                ]
            ],
            "outputs": [
                3,
                1,
                3,
                4,
                12,
                20,
                36,
                60,
                100,
                180,
                300,
                500,
                820,
                1320,
                2120,
                3444,
                5564,
                9004,
                14564,
                23564
            ]
        },
        "sample_code": {
            "c++": "int strobogrammaticInRange(string low, string high) {\n    int count = 0;\n    for(int len = low.size(); len <= high.size(); ++len)\n        count += helper(len, len) <= high ? helper(len, len) >= low ? 1 : 0 : 0;\n    return count;\n}\n\nstring helper(int m, int n) {\n    if(m == 0) return \"\";\n    if(m == 1) return \"0 1 8\";\n    if(n == 0) return \"11 69 88 96\";\n    string res = \"\";\n    for(auto a : helper(m - 2, n)) {\n        if(m != n) res += a + \"0\" + a;\n        res += a + \"1\" + a;\n        res += a + \"6\" + a;\n        res += a + \"8\" + a;\n        res += a + \"9\" + a;\n    }\n    return res;\n}\n\n",
            "java": "public int strobogrammaticInRange(String low, String high) {\n    int count = 0;\n    for(int len = low.length(); len <= high.length(); ++len)\n        count += withinRange(helper(len, len), low, high) ? 1 : 0;\n    return count;\n}\n\nprivate String helper(int m, int n) {\n    if(m == 0) return \"\";\n    if(m == 1) return \"0 1 8\";\n    if(n == 0) return \"11 69 88 96\";\n    String res = \"\";\n    for(String a : helper(m - 2, n).split(\" \")) {\n        if(m != n) res += a + \"0\" + a + \" \";\n        res += a + \"1\" + a + \" \";\n        res += a + \"6\" + a + \" \";\n        res += a + \"8\" + a + \" \";\n        res += a + \"9\" + a + \" \";\n    }\n    return res;\n}\n\nprivate boolean withinRange(String num, String low, String high) {\n    if(num.length() > low.length()) return num.compareTo(high) <= 0;\n    if(num.length() < low.length()) return num.compareTo(low) >= 0;\n    return num.compareTo(low) >= 0 && num.compareTo(high) <= 0;\n}\n\n",
            "python": "def strobogrammaticInRange(low, high):\n    count = 0\n    for len in range(int(low), int(high)+1):\n        count += 1 if low <= helper(len, len) <= high else 0\n    return count\n\ndef helper(m, n):\n    if m == 0:\n        return \"\"\n    if m == 1:\n        return \"0 1 8\"\n    if n == 0:\n        return \"11 69 88 96\"\n    res = \"\"\n    for a in helper(m-2, n).split():\n        if m != n:\n            res += a + \"0\" + a + \" \"\n        res += a + \"1\" + a + \" \"\n        res += a + \"6\" + a + \" \"\n        res += a + \"8\" + a + \" \"\n        res += a + \"9\" + a + \" \"\n    return res\n\n",
            "javascript": "function strobogrammaticInRange(low, high) {\n    let count = 0;\n    for (let len = low.length; len <= high.length; ++len) {\n        const num = helper(len, len);\n        count += (num >= low && num <= high) ? 1 : 0;\n    }\n    return count;\n}\n\nfunction helper(m, n) {\n    if (m === 0) return \"\";\n    if (m === 1) return \"0 1 8\";\n    if (n === 0) return \"11 69 88 96\";\n    let res = \"\";\n    for (const a of helper(m - 2, n).split(\" \")) {\n        if (m !== n) res += a + \"0\" + a + \" \";\n        res += a + \"1\" + a + \" \";\n        res += a + \"6\" + a + \" \";\n        res += a + \"8\" + a + \" \";\n        res += a + \"9\" + a + \" \";\n    }\n    return res;\n}\n\n",
            "explanation": "To solve this problem, we will use a recursive approach. \nWe will create a helper function that takes two arguments m and n where m represents the remaining length of the number, and n represents the original length of the number. This helper function will return the strobogrammatic numbers of that length as a space-separated string.\n\nIn the helper function:\n\n1. If m is 0, we return an empty string.\n2. If m is 1, we return \"0 1 8\" representing the single-digit strobogrammatic numbers.\n3. If n is 0, we return \"11 69 88 96\" representing the two-digit strobogrammatic numbers.\n\nFor each character `a` in the strobogrammatic numbers of length `m-2`:\n\n1. If m is not equal to n, add a '0' in between the characters and concatenate to the result string.\n2. Add '1', '6', '8', and '9' in between the characters, and concatenate to the result string.\n\nThen, in the strobogrammaticInRange function, we iterate through the range of lengths from `low` to `high`. For each length, we check if the strobogrammatic number of that length is within the range `[low, high]`, and if it is, we increase the count by 1.\n\nFinally, we return the total count of strobogrammatic numbers within the specified range."
        },
        "structure": {
            "c++": "int strobogrammaticInRange(string low, string high) \n    // Your code here\n}\n\n",
            "java": "public int strobogrammaticInRange(String low, String high) \n    // Your code here\n}\n\n",
            "python": "def strobogrammaticInRange(low, high):\n    # Your code here\n\n",
            "javascript": "function strobogrammaticInRange(low, high) \n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int strobogrammaticInRange(string low, string high) {\n    int count = 0;\n    for(int len = low.size(); len <= high.size(); ++len)\n        count += helper(len, len) <= high ? helper(len, len) >= low ? 1 : 0 : 0;\n    return count;\n}\n\nstring helper(int m, int n) {\n    if(m == 0) return \"\";\n    if(m == 1) return \"0 1 8\";\n    if(n == 0) return \"11 69 88 96\";\n    string res = \"\";\n    for(auto a : helper(m - 2, n)) {\n        if(m != n) res += a + \"0\" + a;\n        res += a + \"1\" + a;\n        res += a + \"6\" + a;\n        res += a + \"8\" + a;\n        res += a + \"9\" + a;\n    }\n    return res;\n}",
            "java": "public int strobogrammaticInRange(String low, String high) {\n    int count = 0;\n    for(int len = low.length(); len <= high.length(); ++len)\n        count += withinRange(helper(len, len), low, high) ? 1 : 0;\n    return count;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=['1000', '10000']\n    low = inputs[0]\n    high = inputs[1]\n    result = strobogrammaticInRange(low, high)\n    print(result)"
        }
    },
    "249": {
        "title": "Group Strings with Shifting Sequences",
        "description": "Given an array of strings, group all strings that belong to the same shifting sequence. A shifting sequence is formed by shifting each letter of a string to its successive letter. For example, 'abc' can be shifted to 'bcd'. We can keep shifting the string to form a sequence, such as 'abc' -> 'bcd' -> ... -> 'xyz'. Return the grouped strings in any order.",
        "example": "Example:\n\nInput: strings = [\"abc\",\"bcd\",\"acef\",\"xyz\",\"az\",\"ba\",\"a\",\"z\"]\nOutput: [['acef'],['a','z'],['abc','bcd','xyz'],['az','ba']]\n\nExplanation: The strings 'acef' have the same shifting sequence. The strings 'a' and 'z' have the same shifting sequence. The strings 'abc', 'bcd', and 'xyz' have the same shifting sequence. The strings 'az' and 'ba' have the same shifting sequence.",
        "level": "Medium",
        "tags": [
            "string",
            "array"
        ],
        "test_cases": {
            "inputs": [
                [
                    "abc",
                    "bcd",
                    "acef",
                    "xyz",
                    "az",
                    "ba",
                    "a",
                    "z"
                ],
                [
                    "a"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl"
                ],
                [
                    "abc",
                    "bcd",
                    "cde",
                    "def"
                ],
                [
                    "abc",
                    "bcd",
                    "cde",
                    "def",
                    "efg",
                    "fgh"
                ]
            ],
            "outputs": [
                "[['acef'],['a','z'],['abc','bcd','xyz'],['az','ba']]",
                "[['a']]",
                "[['abc','def','ghi','jkl']]",
                "[['abc','bcd','cde','def']]",
                "[['abc','bcd','cde','def','efg','fgh']]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<std::vector<std::string>> groupStrings(std::vector<std::string>& strings) {\n    std::unordered_map<std::string, std::vector<std::string>> map;\n    \n    for (const auto& s : strings) {\n        std::string key;\n        for (char c : s) {\n            key += std::to_string((c - s[0] + 26) % 26) + \",\";\n        }\n        map[key].push_back(s);\n    }\n    \n    std::vector<std::vector<std::string>> result;\n    for (auto& kv : map) {\n        result.push_back(kv.second);\n    }\n    \n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<List<String>> groupStrings(String[] strings) {\n    Map<String, List<String>> map = new HashMap<>();\n\n    for (String s : strings) {\n        StringBuilder key = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            key.append((c - s.charAt(0) + 26) % 26).append(\",\");\n        }\n        String keyStr = key.toString();\n        map.putIfAbsent(keyStr, new ArrayList<>());\n        map.get(keyStr).add(s);\n    }\n\n    return new ArrayList<>(map.values());\n}\n",
            "python": "from collections import defaultdict\n\ndef groupStrings(strings):\n    groups = defaultdict(list)\n\n    for s in strings:\n        key = tuple((ord(c) - ord(s[0])) % 26 for c in s)\n        groups[key].append(s)\n\n    return list(groups.values())\n",
            "javascript": "function groupStrings(strings) {\n    const map = new Map();\n\n    for (const s of strings) {\n        let key = '';\n        for (const c of s) {\n            key += `${(c.charCodeAt(0) - s.charCodeAt(0) + 26) % 26},`;\n        }\n        if (!map.has(key)) {\n            map.set(key, []);\n        }\n        map.get(key).push(s);\n    }\n\n    return Array.from(map.values());\n}\n",
            "explanation": "The idea is to create a unique key for each group of strings, that depends on the relative distances between characters in a string. We iterate through the given strings and create the key for each string by taking the difference between the ASCII code of each character and that of the first character, modulo 26. We add these deltas as comma-separated elements and use them as the key in a map. Where a map is a hashmap in C++ and Java, defaultdict in Python, and Map in JavaScript. For each string, we append it to the list of strings corresponding to its group (key) in the map.\n\nAfter iterating through all the strings, we return the list of groups from the map.\n\nNote that the modulo operation and `<code>26</code>` come from the number of lowercase English letters which is 26. So, any shift greater than 25 will simply wrap around to the initial letters."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<std::vector<std::string>> groupStrings(std::vector<std::string>& strings) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<List<String>> groupStrings(String[] strings) \n    // Your code here\n}\n",
            "python": "from collections import defaultdict\n    # Your code here\n\n",
            "javascript": "function groupStrings(strings) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n\nint main() {\n    std::vector<std::string> strings = $args;\n    std::vector<std::vector<std::string>> result = groupStrings(strings);\n    \n    // Print the result\n    for (const auto& group : result) {\n        for (const auto& str : group) {\n            std::cout << str << \" \";\n        }\n        std::cout << std::endl;\n    }\n    \n    return 0;\n}\n",
            "python": "if __name__ == \"__main__\":\n    strings = $args\n    result = groupStrings(strings)\n    print(result)"
        }
    },
    "252": {
        "title": "Meeting Time Intervals",
        "description": "Given an array of meeting time intervals represented as `intervals`, where `intervals[i] = [starti, endi]`, determine if a person could attend all meetings without any overlap.",
        "example": "For example, given the intervals = [[0,30],[5,10],[15,20]], the person cannot attend all meetings because there is an overlap between the second and third intervals. Therefore, the output would be false.\n\nIn another example, given the intervals = [[7,10],[2,4]], the person can attend all meetings without any overlap. Therefore, the output would be true.",
        "level": "Easy",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        0,
                        30
                    ],
                    [
                        5,
                        10
                    ],
                    [
                        15,
                        20
                    ]
                ],
                [
                    [
                        7,
                        10
                    ],
                    [
                        2,
                        4
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        6,
                        10
                    ],
                    [
                        11,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        3,
                        7
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ],
                    [
                        19,
                        20
                    ]
                ]
            ],
            "outputs": [
                false,
                true,
                true,
                true,
                false,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\n\nbool canAttendMeetings(std::vector<std::vector<int>>& intervals) {\n    std::sort(intervals.begin(), intervals.end());\n    \n    for (int i = 1; i < intervals.size(); ++i) {\n        if (intervals[i][0] < intervals[i - 1][1])\n            return false;\n    }\n    \n    return true;\n}\n",
            "java": "import java.util.Arrays;\n\npublic boolean canAttendMeetings(int[][] intervals) {\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n    \n    for (int i = 1; i < intervals.length; ++i) {\n        if (intervals[i][0] < intervals[i - 1][1])\n            return false;\n    }\n    \n    return true;\n}\n",
            "python": "def can_attend_meetings(intervals):\n    intervals.sort()\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i - 1][1]:\n            return False\n\n    return True\n",
            "javascript": "function canAttendMeetings(intervals) {\n    intervals.sort((a, b) => a[0] - b[0]);\n    \n    for (let i = 1; i < intervals.length; ++i) {\n        if (intervals[i][0] < intervals[i - 1][1])\n            return false;\n    }\n    \n    return true;\n}\n",
            "explanation": "1. Sort the meeting intervals by their start times.\n2. Iterate through the sorted intervals. \n3. Check if the start time of the current interval is less than the end time of the previous interval. If so, return false, as the person cannot attend both of these meetings.\n4. If all intervals pass the check, return true, as the person can attend all meetings."
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\n\nbool canAttendMeetings(std::vector<std::vector<int>>& intervals) \n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\n\npublic boolean canAttendMeetings(int[][] intervals) \n    // Your code here\n}\n",
            "python": "def can_attend_meetings(intervals):\n    # Your code here\n\n",
            "javascript": "function canAttendMeetings(intervals) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nint main() {\n    std::vector<std::vector<int>> intervals = $args;\n    bool result = canAttendMeetings(intervals);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    intervals = $args\n    result = can_attend_meetings(intervals)\n    print(result)"
        }
    },
    "253": {
        "title": "Minimum Number of Conference Rooms",
        "description": "Given an array of meeting time intervals `intervals` where `intervals[i] = [starti, endi]`, you need to determine the minimum number of conference rooms required to schedule all the meetings.",
        "example": "For example, given the intervals = [[0,30],[5,10],[15,20]], the minimum number of conference rooms required is 2. The first meeting starts at time 0 and ends at time 30. The second meeting starts at time 5 and ends at time 10. The third meeting starts at time 15 and ends at time 20. Since all the meetings overlap, we need at least 2 conference rooms to schedule them.\n\nInput: [[7,10],[2,4]]\nOutput: 1\n\nIn this case, the first meeting starts at time 7 and ends at time 10. The second meeting starts at time 2 and ends at time 4. Since the meetings do not overlap, only 1 conference room is required.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        0,
                        30
                    ],
                    [
                        5,
                        10
                    ],
                    [
                        15,
                        20
                    ]
                ],
                [
                    [
                        7,
                        10
                    ],
                    [
                        2,
                        4
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        3,
                        7
                    ],
                    [
                        4,
                        8
                    ]
                ],
                [
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        3,
                        8
                    ],
                    [
                        4,
                        7
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        5,
                        7
                    ],
                    [
                        6,
                        8
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        3,
                        7
                    ],
                    [
                        4,
                        8
                    ],
                    [
                        5,
                        9
                    ]
                ],
                [
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        3,
                        8
                    ],
                    [
                        4,
                        7
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ],
                    [
                        19,
                        20
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ],
                    [
                        19,
                        20
                    ],
                    [
                        20,
                        21
                    ]
                ]
            ],
            "outputs": [
                2,
                1,
                4,
                5,
                1,
                1,
                2,
                2,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <queue>\n#include <algorithm>\n\nint minMeetingRooms(std::vector<std::vector<int>>& intervals) {\n    if (intervals.empty()) return 0;\n\n    std::sort(intervals.begin(), intervals.end(),\n              [](const std::vector<int>& a, const std::vector<int>& b) { return a[0] < b[0]; });\n\n    std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;\n    min_heap.push(intervals[0][1]);\n\n    for (int i = 1; i < intervals.size(); i++) {\n        if (intervals[i][0] >= min_heap.top()) {\n            min_heap.pop();\n        }\n        min_heap.push(intervals[i][1]);\n    }\n\n    return min_heap.size();\n}\n",
            "java": "import java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic int minMeetingRooms(int[][] intervals) {\n    if (intervals == null || intervals.length == 0) return 0;\n    \n    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    \n    minHeap.add(intervals[0][1]);\n    for (int i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] >= minHeap.peek()) {\n            minHeap.poll();\n        }\n        minHeap.add(intervals[i][1]);\n    }\n    \n    return minHeap.size();\n}\n",
            "python": "import heapq\n\ndef minMeetingRooms(intervals):\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n\n    min_heap = [intervals[0][1]]\n    for start, end in intervals[1:]:\n        if start >= min_heap[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, end)\n\n    return len(min_heap)\n",
            "javascript": "function minMeetingRooms(intervals) {\n    if (intervals.length === 0) return 0;\n\n    intervals.sort((a, b) => a[0] - b[0]);\n    const minHeap = [intervals[0][1]];\n\n    for (let i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] >= minHeap[0]) {\n            minHeap.shift();\n        }\n        minHeap.push(intervals[i][1]);\n        minHeap.sort((a, b) => a - b);\n    }\n\n    return minHeap.length;\n}\n",
            "explanation": "1. Sort the intervals by their start times.\n2. Initialize a min-heap to store the end times of the intervals.\n3. Iterate through the sorted intervals.\n   - If the start time of the current interval is greater than or equal to the minimum end time in the heap, it means the meeting room is available, so remove the minimum end time.\n   - Add the end time of the current interval to the heap.\n4. The size of the heap represents the minimum number of meeting rooms required."
        },
        "structure": {
            "c++": "#include <vector>\n#include <queue>\n#include <algorithm>\n\nint minMeetingRooms(std::vector<std::vector<int>>& intervals) \n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic int minMeetingRooms(int[][] intervals) \n    // Your code here\n}\n",
            "python": "import heapq\n    # Your code here\n\n",
            "javascript": "function minMeetingRooms(intervals) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n\nint main() {\n    std::vector<std::vector<int>> intervals = $args;\n    int result = minMeetingRooms(intervals);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int minMeetingRooms(int[][] intervals) {\n    if (intervals == null || intervals.length == 0) return 0;\n    \n    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    \n    minHeap.add(intervals[0][1]);\n    for (int i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] >= minHeap.peek()) {\n            minHeap.poll();\n        }\n        minHeap.add(intervals[i][1]);\n    }\n    \n    return minHeap.size();\n}",
            "python": "if __name__ == \"__main__\":\n    intervals = $args\n    result = minMeetingRooms(intervals)\n    print(result)",
            "javascript": "function main() {\n    const intervals = $args;\n    const result = minMeetingRooms(intervals);\n    console.log(result);\n}"
        }
    },
    "254": {
        "title": "Factor Combinations",
        "description": "Given an integer n, return all possible combinations of its factors. Numbers can be regarded as the product of their factors. For example, 8 = 2 x 2 x 2 = 2 x 4. The factors should be in the range [2, n - 1].",
        "example": "Example 1:\n\nInput: n = 1\nOutput: []\n\nExample 2:\n\nInput: n = 12\nOutput: [[2,6],[3,4],[2,2,3]]\n\nExample 3:\n\nInput: n = 37\nOutput: []",
        "level": "Medium",
        "tags": [
            "math",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                1,
                12,
                37,
                8,
                16,
                24,
                100
            ],
            "outputs": [
                [],
                [
                    [
                        2,
                        6
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        2,
                        2,
                        3
                    ]
                ],
                [],
                [
                    [
                        2,
                        2,
                        2
                    ],
                    [
                        2,
                        4
                    ]
                ],
                [
                    [
                        2,
                        2,
                        2,
                        2
                    ],
                    [
                        2,
                        2,
                        4
                    ],
                    [
                        2,
                        8
                    ],
                    [
                        4,
                        4
                    ]
                ],
                [
                    [
                        2,
                        2,
                        2,
                        3
                    ],
                    [
                        2,
                        2,
                        6
                    ],
                    [
                        2,
                        3,
                        4
                    ],
                    [
                        4,
                        6
                    ]
                ],
                [
                    [
                        2,
                        2,
                        5,
                        5
                    ]
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nvoid helper(int n, int start, std::vector<int>& path, std::vector<std::vector<int>>& result) {\n    if (n == 1) {\n        if (path.size() > 1) {\n            result.push_back(path);\n        }\n        return;\n    }\n\n    for (int i = start; i <= n; ++i) {\n        if (n % i == 0) {\n            path.push_back(i);\n            helper(n / i, i, path, result);\n            path.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<int>> getFactors(int n) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> path;\n    helper(n, 2, path, result);\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> getFactors(int n) {\n    List<List<Integer>> result = new ArrayList<>();\n    helper(n, 2, new ArrayList<Integer>(), result);\n    return result;\n}\n\nprivate void helper(int n, int start, List<Integer> path, List<List<Integer>> result) {\n    if (n == 1) {\n        if (path.size() > 1) {\n            result.add(new ArrayList<>(path));\n        }\n        return;\n    }\n\n    for (int i = start; i <= n; i++) {\n        if (n % i == 0) {\n            path.add(i);\n            helper(n / i, i, path, result);\n            path.remove(path.size() - 1);\n        }\n    }\n}\n",
            "python": "def getFactors(n):\n    def helper(n, start, path, result):\n        if n == 1:\n            if len(path) > 1:\n                result.append(path[:])\n            return\n\n        for i in range(start, n + 1):\n            if n % i == 0:\n                path.append(i)\n                helper(n // i, i, path, result)\n                path.pop()\n\n    result = []\n    helper(n, 2, [], result)\n    return result\n",
            "javascript": "function getFactors(n) {\n    const result = [];\n    const helper = (n, start, path) => {\n        if (n === 1) {\n            if (path.length > 1) {\n                result.push([...path]);\n            }\n            return;\n        }\n\n        for (let i = start; i <= n; i++) {\n            if (n % i === 0) {\n                path.push(i);\n                helper(n / i, i, path);\n                path.pop();\n            }\n        }\n    };\n\n    helper(n, 2, []);\n    return result;\n}\n",
            "explanation": "We use a backtracking algorithm to find all possible combinations of factors. The algorithm starts with `n` and splits it into all possible factors in the range `[2, n]`. We keep track of the current path, which represents the factors found so far. When `n` equals 1, we check if the current path has more than one element. If it does, we add the current combination of factors to the result.\n\nTo avoid duplicates, we ensure that the next factor in the sequence is greater than or equal to the previous one by passing a \"start\" variable in the helper function. This ensures that we always explore factors in a non-decreasing order.\n\nAt each recursive step, we first check if the current value of `n` is divisible by the current factor (i.e., it has no remainder when divided). If it is, we update the path with the current factor and call the helper function with the updated value of `n` divided by the current factor. After the recursive call returns, we remove the last factor from the path to backtrack to the previous level and explore other factors. This continues until we've explored all factors for the given input `n`. The final result is a list of lists representing all possible combinations of factors."
        },
        "structure": {
            "c++": "#include <vector>\n\nvoid helper(int n, int start, std::vector<int>& path, std::vector<std::vector<int>>& result) \n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> getFactors(int n) \n    // Your code here\n}\n",
            "python": "def getFactors(n):\n    # Your code here\n\n",
            "javascript": "function getFactors(n) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nvoid helper(int n, int start, std::vector<int>& path, std::vector<std::vector<int>>& result) {\n    if (n == 1) {\n        if (path.size() > 1) {\n            result.push_back(path);\n        }\n        return;\n    }\n\n    for (int i = start; i <= n; ++i) {\n        if (n % i == 0) {\n            path.push_back(i);\n            helper(n / i, i, path, result);\n            path.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<int>> getFactors(int n) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> path;\n    helper(n, 2, path, result);\n    return result;\n}\n\nint main() {\n    int n = $args;\n    std::vector<std::vector<int>> result = getFactors(n);\n    for (const auto& factors : result) {\n        for (const auto& factor : factors) {\n            std::cout << factor << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}",
            "java": "public List<List<Integer>> getFactors(int n) {\n    List<List<Integer>> result = new ArrayList<>();\n    helper(n, 2, new ArrayList<Integer>(), result);\n    return result;\n}\n\nprivate void helper(int n, int start, List<Integer> path, List<List<Integer>> result) {\n    if (n == 1) {\n        if (path.size() > 1) {\n            result.add(new ArrayList<>(path));\n        }\n        return;\n    }\n\n    for (int i = start; i <= n; i++) {\n        if (n % i == 0) {\n            path.add(i);\n            helper(n / i, i, path, result);\n            path.remove(path.size() - 1);\n        }\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = getFactors(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = getFactors(n);\n    console.log(result);\n}"
        }
    },
    "255": {
        "title": "Preorder Traversal of Binary Search Tree",
        "description": "Given an array of unique integers `preorder`, determine if it represents the correct preorder traversal sequence of a binary search tree. Return `true` if it is a valid preorder traversal sequence, and `false` otherwise.",
        "example": "Example 1:\n\nInput: preorder = [5,2,1,3,6]\nOutput: true\n\nExplanation: The given preorder sequence [5,2,1,3,6] can be represented by the following binary search tree:\n\n     5\n    / \\\n   2   6\n  / \\\n 1   3\n\nSince the binary search tree matches the preorder sequence, the output is true.\n\nExample 2:\n\nInput: preorder = [5,2,6,1,3]\nOutput: false\n\nExplanation: The given preorder sequence [5,2,6,1,3] cannot be represented by any binary search tree. Therefore, the output is false.",
        "level": "Medium",
        "tags": [
            "binary search tree",
            "preorder traversal",
            "tree traversal"
        ],
        "test_cases": {
            "inputs": [
                [
                    5,
                    2,
                    1,
                    3,
                    6
                ],
                [
                    5,
                    2,
                    6,
                    1,
                    3
                ],
                [
                    1
                ],
                [
                    2,
                    1
                ],
                [
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1,
                    6
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6
                ],
                [
                    5,
                    2,
                    1,
                    4,
                    3,
                    6
                ],
                [
                    5,
                    2,
                    1,
                    4,
                    6,
                    3
                ],
                [
                    5,
                    2,
                    1,
                    6,
                    4,
                    3
                ],
                [
                    5,
                    2,
                    6,
                    1,
                    4,
                    3
                ],
                [
                    5,
                    6,
                    2,
                    1,
                    4,
                    3
                ],
                [
                    5,
                    6,
                    2,
                    1,
                    3,
                    4
                ],
                [
                    5,
                    6,
                    2,
                    4,
                    1,
                    3
                ],
                [
                    5,
                    6,
                    2,
                    4,
                    3,
                    1
                ],
                [
                    5,
                    6,
                    4,
                    2,
                    1,
                    3
                ],
                [
                    5,
                    6,
                    4,
                    2,
                    3,
                    1
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                true,
                false,
                false,
                true,
                false,
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "bool isValidPreorder(vector<int>& preorder) {\n    stack<int> stk;\n    int lower_bound = INT_MIN;\n    for (int num : preorder) {\n        if (num < lower_bound) return false;\n        while (!stk.empty() && num > stk.top()) {\n            lower_bound = stk.top();\n            stk.pop();\n        }\n        stk.push(num);\n    }\n    return true;\n}\n",
            "java": "public boolean isValidPreorder(int[] preorder) {\n    Stack<Integer> stack = new Stack<>();\n    int lowerBound = Integer.MIN_VALUE;\n    for (int num : preorder) {\n        if (num < lowerBound) return false;\n        while (!stack.isEmpty() && num > stack.peek()) {\n            lowerBound = stack.pop();\n        }\n        stack.push(num);\n    }\n    return true;\n}\n",
            "python": "def isValidPreorder(preorder: list[int]) -> bool:\n    stack = []\n    lower_bound = float('-inf')\n    for num in preorder:\n        if num < lower_bound:\n            return False\n        while stack and num > stack[-1]:\n            lower_bound = stack.pop()\n        stack.append(num)\n    return True\n",
            "javascript": "var isValidPreorder = function(preorder) {\n    let stack = [];\n    let lowerBound = Number.MIN_SAFE_INTEGER;\n    for (let num of preorder) {\n        if (num < lowerBound) return false;\n        while (stack.length > 0 && num > stack[stack.length - 1]) {\n            lowerBound = stack.pop();\n        }\n        stack.push(num);\n    }\n    return true;\n};\n",
            "explanation": "The algorithm is mainly based on a stack. It processes each element in the given `preorder` array and uses the stack to keep track of nodes that are not yet part of a completed subtree.\n\nInitially, `lower_bound` is set to the minimum possible value.\n\nFor each number in the preorder array:\n\n1. If the number is less than lower_bound, it means the number is trying to be added as a right child but the value is less than the minimum possible value, hence breaks the binary search tree property. So return false.\n   \n2. If the number is greater than the top of the stack, it means the number is the right child of the last node encountered. So, we pop from the stack and set the lower_bound to the last popped value until the stack is empty or the number is smaller than the top of the stack.\n   \n3. Push the number onto the stack.\n\nIf no false case is encountered during the loop, return true as it is a valid preorder traversal sequence of a binary search tree."
        },
        "structure": {
            "c++": "bool isValidPreorder(vector<int>& preorder) \n    // Your code here\n}\n",
            "java": "public boolean isValidPreorder(int[] preorder) \n    // Your code here\n}\n",
            "python": "def isValidPreorder(preorder: List[int]) -> bool:\n    # Your code here\n\n",
            "javascript": "var isValidPreorder = function(preorder) \n    // Your code here\n};\n"
        },
        "call_functions": {
            "c++": "bool isValidPreorder(vector<int>& preorder) {\n    stack<int> stk;\n    int lower_bound = INT_MIN;\n    for (int num : preorder) {\n        if (num < lower_bound) return false;\n        while (!stk.empty() && num > stk.top()) {\n            lower_bound = stk.top();\n            stk.pop();\n        }\n        stk.push(num);\n    }\n    return true;\n}",
            "java": "public static void main(String[] args) {\n    int[] preorder = $args;\n    boolean result = isValidPreorder(preorder);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    preorder = $args\n    result = isValidPreorder(preorder)\n    print(result)",
            "javascript": "function main() {\n    const preorder = $args;\n    let stack = [];\n    let lowerBound = Number.MIN_SAFE_INTEGER;\n    for (let num of preorder) {\n        if (num < lowerBound) return false;\n        while (stack.length > 0 && num > stack[stack.length - 1]) {\n            lowerBound = stack.pop();\n        }\n        stack.push(num);\n    }\n    return true;\n}\n\nconst result = main();\nconsole.log(result);"
        }
    },
    "258": {
        "title": "Sum of Digits",
        "description": "Given an integer `num`, repeatedly add all its digits until the result has only one digit, and return it.",
        "example": "Example:\n\nInput: num = 38\nOutput: 2\nExplanation: The process is\n38 --> 3 + 8 --> 11\n11 --> 1 + 1 --> 2\nSince 2 has only one digit, return it.",
        "level": "Easy",
        "tags": [
            "math",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                38,
                0,
                9,
                123,
                456,
                789,
                100,
                999,
                123456789
            ],
            "outputs": [
                2,
                0,
                9,
                6,
                6,
                6,
                1,
                9,
                9
            ]
        },
        "sample_code": {
            "c++": "int addDigits(int num) {\n    return 1 + (num - 1) % 9;\n}\n",
            "java": "public int addDigits(int num) {\n    return 1 + (num - 1) % 9;\n}\n",
            "python": "def addDigits(num: int) -> int:\n    return 1 + (num - 1) % 9\n",
            "javascript": "function addDigits(num) {\n    return 1 + (num - 1) % 9;\n}\n",
            "explanation": "The idea is to find the pattern for the single digit that will be the outcome of repeatedly summing up a number's digits. Observe that for numbers 1-9, the single digit outcome is the number itself. For numbers 10-18 (i.e., 1+0, 1+1, 1+2, ..., 1+8), the single digit outcome is 1-9 again. This pattern repeats.\n\nIn the given code, we return the value computed from the formula `1 + (num - 1) % 9`. The formula derives from the observation mentioned above. Here's the explanation:\n\n- Subtracting 1 shifts the sequence to range from 0 to 8 instead of 1 to 9.\n- Taking num modulo 9 reveals the repeating 0-8 pattern.\n- Adding 1 offsets the range back to 1-9.\n\nThis algorithm works for all positive integer numbers, and the result is the single digit number that is the outcome of repeatedly summing up the original number's digits."
        },
        "structure": {
            "c++": "int addDigits(int num) \n    // Your code here\n}\n",
            "java": "public int addDigits(int num) \n    // Your code here\n}\n",
            "python": "def addDigits(num: int) -> int:\n    # Your code here\n\n",
            "javascript": "function addDigits(num) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int num = $args;\n    int result = addDigits(num);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    num = $args\n    result = addDigits(num)\n    print(result)"
        }
    },
    "259": {
        "title": "Count Triplets with Sum Less than Target",
        "description": "Given an array of `n` integers `nums` and an integer `target`, find the number of index triplets `i`, `j`, `k` with `0 <= i < j < k < n` that satisfy the condition `nums[i] + nums[j] + nums[k] < target`.",
        "example": "Example:\n\nInput: nums = [-2,0,1,3], target = 2\nOutput: 2\nExplanation: There are two triplets whose sum is less than 2:\n[-2,0,1]\n[-2,0,3]",
        "level": "Medium",
        "tags": [
            "array",
            "two pointers"
        ],
        "test_cases": {
            "inputs": [
                [
                    -2,
                    0,
                    1,
                    3
                ],
                [],
                [
                    0
                ],
                [
                    -1,
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    -5,
                    -4,
                    -3,
                    -2,
                    -1,
                    0,
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    -10,
                    -9,
                    -8,
                    -7,
                    -6,
                    -5,
                    -4,
                    -3,
                    -2,
                    -1
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    -100,
                    -50,
                    0,
                    50,
                    100
                ],
                [
                    100,
                    50,
                    0,
                    -50,
                    -100
                ],
                [
                    -100,
                    -100,
                    -100,
                    -100,
                    -100
                ],
                [
                    100,
                    100,
                    100,
                    100,
                    100
                ],
                [
                    -100,
                    0,
                    100
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    -1,
                    -1,
                    -1,
                    -1,
                    -1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    -6,
                    -7,
                    -8,
                    -9,
                    -10,
                    -11,
                    -12,
                    -13,
                    -14,
                    -15,
                    -16,
                    -17,
                    -18,
                    -19,
                    -20
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    -6,
                    -7,
                    -8,
                    -9,
                    -10,
                    -11,
                    -12,
                    -13,
                    -14,
                    -15,
                    -16,
                    -17,
                    -18,
                    -19,
                    -20
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    -6,
                    -7,
                    -8,
                    -9,
                    -10,
                    -11,
                    -12,
                    -13,
                    -14,
                    -15,
                    -16,
                    -17,
                    -18,
                    -19,
                    -20,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    -6,
                    -7,
                    -8,
                    -9,
                    -10,
                    -11,
                    -12,
                    -13,
                    -14,
                    -15,
                    -16,
                    -17,
                    -18,
                    -19,
                    -20,
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    -6,
                    -7,
                    -8,
                    -9,
                    -10,
                    -11,
                    -12,
                    -13,
                    -14,
                    -15,
                    -16,
                    -17,
                    -18,
                    -19,
                    -20
                ]
            ],
            "outputs": [
                2,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                5,
                5,
                0,
                0,
                0,
                0,
                0,
                0,
                1140,
                1140,
                1140,
                1140,
                1140
            ]
        },
        "sample_code": {
            "c++": "int threeSumSmaller(vector<int>& nums, int target) {\n    int count = 0;\n    sort(nums.begin(), nums.end());\n    for (int i = 0; i < nums.size(); ++i) {\n        int j = i + 1, k = nums.size() - 1;\n        while (j < k) {\n            if (nums[i] + nums[j] + nums[k] < target) {\n                count += k - j;\n                ++j;\n            } else {\n                --k;\n            }\n        }\n    }\n    return count;\n}\n",
            "java": "public int threeSumSmaller(int[] nums, int target) {\n    int count = 0;\n    Arrays.sort(nums);\n    for (int i = 0; i < nums.length; ++i) {\n        int j = i + 1, k = nums.length - 1;\n        while (j < k) {\n            if (nums[i] + nums[j] + nums[k] < target) {\n                count += k - j;\n                ++j;\n            } else {\n                --k;\n            }\n        }\n    }\n    return count;\n}\n",
            "python": "def threeSumSmaller(nums, target):\n    count = 0\n    nums.sort()\n    for i in range(len(nums)):\n        j, k = i + 1, len(nums) - 1\n        while j < k:\n            if nums[i] + nums[j] + nums[k] < target:\n                count += k - j\n                j += 1\n            else:\n                k -= 1\n    return count\n",
            "javascript": "function threeSumSmaller(nums, target) {\n    let count = 0;\n    nums.sort((a, b) => a - b);\n    for (let i = 0; i < nums.length; ++i) {\n        let j = i + 1, k = nums.length - 1;\n        while (j < k) {\n            if (nums[i] + nums[j] + nums[k] < target) {\n                count += k - j;\n                ++j;\n            } else {\n                --k;\n            }\n        }\n    }\n    return count;\n}\n",
            "explanation": "To solve this problem, we first sort the input array. Then we loop through each element in the array and use two pointers, `j` and `k`, initialized to the following element and the last element in the sorted array, respectively. We repeat the process until `j` is less than `k`. Inside the loop, we check if the sum of `nums[i]`, `nums[j]`, and `nums[k]` is less than the target. If it is, we add the difference `k - j` to the count and increment `j`. Otherwise, we decrement `k`. Finally, we return the count."
        },
        "structure": {
            "c++": "int threeSumSmaller(vector<int>& nums, int target) \n    // Your code here\n}\n",
            "java": "public int threeSumSmaller(int[] nums, int target) \n    // Your code here\n}\n",
            "python": "def threeSumSmaller(nums, target):\n    # Your code here\n\n",
            "javascript": "function threeSumSmaller(nums, target) \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> nums = $args;\n    int target = $args;\n    int result = threeSumSmaller(nums, target);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int threeSumSmaller(int[] nums, int target) {\n    int count = 0;\n    Arrays.sort(nums);\n    for (int i = 0; i < nums.length; ++i) {\n        int j = i + 1, k = nums.length - 1;\n        while (j < k) {\n            if (nums[i] + nums[j] + nums[k] < target) {\n                count += k - j;\n                ++j;\n            } else {\n                --k;\n            }\n        }\n    }\n    return count;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    target = $args\n    result = threeSumSmaller(nums, target)\n    print(result)"
        }

    }
}
