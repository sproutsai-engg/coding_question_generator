[
    {
        "_id": {
            "$oid": "661d1833cb4648900af06091"
        },
        "title": "Two Sum",
        "description": "Given an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
        "example": "Given an array nums = [2,7,11,15] and target = 9, the output should be [0,1] because nums[0] + nums[1] = 2 + 7 = 9.",
        "level": "Easy",
        "tags": [
            "Array",
            "Two Pointers"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        2,
                        7,
                        11,
                        15
                    ],
                    9
                ],
                [
                    [
                        3,
                        2,
                        4
                    ],
                    6
                ],
                [
                    [
                        3,
                        3
                    ],
                    6
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    9
                ],
                [
                    [
                        10,
                        20,
                        30,
                        40,
                        50
                    ],
                    70
                ],
                [
                    [
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    0
                ],
                [
                    [
                        -1,
                        -2,
                        -3,
                        -4,
                        -5
                    ],
                    -8
                ],
                [
                    [
                        100,
                        200,
                        300,
                        400,
                        500
                    ],
                    600
                ],
                [
                    [
                        1,
                        3,
                        5,
                        7,
                        9
                    ],
                    12
                ],
                [
                    [
                        2,
                        4,
                        6,
                        8,
                        10
                    ],
                    14
                ],
                [
                    [
                        9,
                        8,
                        7,
                        6,
                        5
                    ],
                    14
                ],
                [
                    [
                        5,
                        10,
                        15,
                        20,
                        25
                    ],
                    30
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    2
                ],
                [
                    [
                        2,
                        2,
                        2,
                        2,
                        2
                    ],
                    4
                ],
                [
                    [
                        3,
                        6,
                        9,
                        12,
                        15
                    ],
                    18
                ],
                [
                    [
                        4,
                        8,
                        12,
                        16,
                        20
                    ],
                    24
                ],
                [
                    [
                        5,
                        5,
                        5,
                        5,
                        5
                    ],
                    10
                ],
                [
                    [
                        6,
                        12,
                        18,
                        24,
                        30
                    ],
                    36
                ],
                [
                    [
                        7,
                        14,
                        21,
                        28,
                        35
                    ],
                    42
                ],
                [
                    [
                        8,
                        16,
                        24,
                        32,
                        40
                    ],
                    48
                ]
            ],
            "outputs": [
                [
                    0,
                    1
                ],
                [
                    1,
                    2
                ],
                [
                    0,
                    1
                ],
                [
                    2,
                    4
                ],
                [
                    1,
                    3
                ],
                [
                    0,
                    1
                ],
                [
                    1,
                    4
                ],
                [
                    1,
                    3
                ],
                [
                    1,
                    3
                ],
                [
                    0,
                    2
                ],
                [
                    1,
                    2
                ],
                [
                    0,
                    3
                ],
                [
                    0,
                    1
                ],
                [
                    0,
                    1
                ],
                [
                    2,
                    4
                ],
                [
                    1,
                    3
                ],
                [
                    0,
                    4
                ],
                [
                    1,
                    3
                ],
                [
                    0,
                    2
                ],
                [
                    1,
                    3
                ]
            ],
            "input_data_type": [
                "array",
                "int"
            ],
            "output_data_type": [
                "array"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <unordered_map>\n\nstd::vector<int> twoSum(std::vector<int>& nums, int target) {\n    std::unordered_map<int, int> map;\n    for (int i = 0; i < nums.size(); i++) {\n        int complement = target - nums[i];\n        if (map.find(complement) != map.end()) {\n            return {map[complement], i};\n        }\n        map[nums[i]] = i;\n    }\n    return {};\n}\n",
            "java": "\npublic static int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[]{map.get(complement), i};\n        }\n        map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}\n",
            "python": "def twoSum(nums, target):\n    map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in map:\n            return [map[complement], i]\n        map[num] = i\n    return []\n",
            "javascript": "function twoSum(nums, target) {\n    const map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (map.has(complement)) {\n            return [map.get(complement), i];\n        }\n        map.set(nums[i], i);\n    }\n    return [];\n}\n",
            "explanation": "The algorithm leverages a hash map (unordered_map in C++, HashMap in Java, dictionary in Python, and Map in JavaScript). It iterates through the given 'nums' array and calculates the complementary value (target - current value). If the complementary value is already in the hash map, it means that we found a solution, and we return those indices. If the complement is not in the hash map, we store the current element in the hash map with its index. If the algorithm doesn't find the solution, it returns an empty array or throws an exception (in Java).\n\nThis approach has a time complexity of O(n) and a space complexity of O(n) as well."
        },
        "structure": {
            "c++": "#include <vector>\n#include <unordered_map>\n\nstd::vector<int> twoSum(std::vector<int>& nums, int target) {\n    // Your code here\n}\n",
            "java": "public static int[] twoSum(int[] nums, int target) {\n    // Your code here\n}\n",
            "python": "def twoSum(nums, target):\n    # Your code here\n\n",
            "javascript": "function twoSum(nums, target) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nint main() {\n    std::vector<int> nums =$args1;\n    int target = $args2;\n    std::vector<int> result = twoSum(nums, target);\n    for (int i = 0; i < result.size(); i++) {\n        std::cout << result[i] << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs =  $args\n    nums = inputs[0]\n    target = inputs[1]\n    result = twoSum(nums, target)\n    print(result)",
            "javascript": "function main() {\n    const input = $args\n    const nums = input[0];\n    const target = input[1];\n    const result = twoSum(nums, target);\n    console.log(result);\n}\nmain();",
            "java": "public static void main(String[] args) {\n    int[] nums = $args1;\n    int target = $args2;\n    int[] result = twoSum(nums, target);\n    System.out.println(Arrays.toString(result));\n}"
        },
        "Qid": "1",
        "languages verified": [
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d1833cb4648900af06093"
        },
        "title": "Median of Two Sorted Arrays",
        "description": "Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).",
        "example": "Given nums1 = [1,3] and nums2 = [2], the merged array is [1,2,3] and the median is 2.0.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        3
                    ],
                    [
                        2
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ]
                ],
                [
                    [
                        1,
                        2,
                        5,
                        9
                    ],
                    [
                        3,
                        4,
                        6,
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        8,
                        9,
                        10,
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        8,
                        9,
                        10,
                        11,
                        12,
                        13
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12,
                        13
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12,
                        13,
                        14
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        10,
                        11,
                        12,
                        13,
                        14
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        12,
                        13,
                        14,
                        15,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        12,
                        13,
                        14,
                        15,
                        16,
                        17
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16,
                        17
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16,
                        17,
                        18
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13
                    ],
                    [
                        14,
                        15,
                        16,
                        17,
                        18
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13
                    ],
                    [
                        14,
                        15,
                        16,
                        17,
                        18,
                        19
                    ]
                ]
            ],
            "outputs": [
                2,
                2.5,
                5.5,
                5.5,
                6,
                6,
                6.5,
                6.5,
                7,
                7,
                7.5,
                7.5,
                8,
                8,
                8.5,
                8.5,
                9,
                9,
                9.5,
                9.5
            ],
            "input_data_type": [
                "array",
                "array"
            ],
            "output_data_type": [
                "float"
            ]
        },
        "sample_code": {
            "c++": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\n\ndouble findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n    if (nums1.size() > nums2.size()) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    int x = nums1.size();\n    int y = nums2.size();\n    int low = 0;\n    int high = x;\n    \n    while (low <= high) {\n        int partitionX = (low + high) / 2;\n        int partitionY = (x + y + 1) / 2 - partitionX;\n        \n        int maxLeftX = (partitionX == 0) ? INT_MIN : nums1[partitionX - 1];\n        int minRightX = (partitionX == x) ? INT_MAX : nums1[partitionX];\n        \n        int maxLeftY = (partitionY == 0) ? INT_MIN : nums2[partitionY - 1];\n        int minRightY = (partitionY == y) ? INT_MAX : nums2[partitionY];\n        \n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 == 0) {\n                return (double(max(maxLeftX, maxLeftY) + min(minRightX, minRightY))) / 2;\n            } else {\n                return double(max(maxLeftX, maxLeftY));\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }    \n    return 0;\n}\n",
            "java": "public static double findMedianSortedArrays(int[] nums1, int[] nums2) {\n    if (nums1.length > nums2.length) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    int x = nums1.length;\n    int y = nums2.length;\n    int low = 0;\n    int high = x;\n    \n    while (low <= high) {\n        int partitionX = (low + high) / 2;\n        int partitionY = (x + y + 1) / 2 - partitionX;\n        \n        int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];\n        int minRightX = (partitionX == x) ? Integer.MAX_VALUE : nums1[partitionX];\n        \n        int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : nums2[partitionY - 1];\n        int minRightY = (partitionY == y) ? Integer.MAX_VALUE : nums2[partitionY];\n        \n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 == 0) {\n                return (double)(Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\n            } else {\n                return (double)Math.max(maxLeftX, maxLeftY);\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }    \n    return 0;\n}\n",
            "python": "def findMedianSortedArrays(nums1, nums2):\n    if len(nums1) > len(nums2):\n        return findMedianSortedArrays(nums2, nums1)\n    \n    x, y = len(nums1), len(nums2)\n    low, high = 0, x\n\n    while low <= high:\n        partition_x = (low + high) // 2\n        partition_y = (x + y + 1) // 2 - partition_x\n\n        max_left_x = float('-inf') if partition_x == 0 else nums1[partition_x - 1]\n        min_right_x = float('inf') if partition_x == x else nums1[partition_x]\n\n        max_left_y = float('-inf') if partition_y == 0 else nums2[partition_y - 1]\n        min_right_y = float('inf') if partition_y == y else nums2[partition_y]\n\n        if max_left_x <= min_right_y and max_left_y <= min_right_x:\n            if (x + y) % 2 == 0:\n                return (max(max_left_x, max_left_y) + min(min_right_x, min_right_y)) / 2\n            else:\n                return max(max_left_x, max_left_y)\n        elif max_left_x > min_right_y:\n            high = partition_x - 1\n        else:\n            low = partition_x + 1\n    \n    return 0\n",
            "javascript": "function findMedianSortedArrays(nums1, nums2) {\n    if (nums1.length > nums2.length) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    const x = nums1.length;\n    const y = nums2.length;\n    let low = 0;\n    let high = x;\n    \n    while (low <= high) {\n        const partitionX = Math.floor((low + high) / 2);\n        const partitionY = Math.floor((x + y + 1) / 2) - partitionX;\n        \n        const maxLeftX = (partitionX === 0) ? Number.NEGATIVE_INFINITY : nums1[partitionX - 1];\n        const minRightX = (partitionX === x) ? Number.POSITIVE_INFINITY : nums1[partitionX];\n        \n        const maxLeftY = (partitionY === 0) ? Number.NEGATIVE_INFINITY : nums2[partitionY - 1];\n        const minRightY = (partitionY === y) ? Number.POSITIVE_INFINITY : nums2[partitionY];\n        \n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 === 0) {\n                return (Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\n            } else {\n                return Math.max(maxLeftX, maxLeftY);\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }    \n    return 0;\n}\n\n",
            "explanation": "1. Choose the smaller array as nums1 so that the problem is simpler with less log(n) complexity.\n2. Use Binary Search (BS) to partition the smallest array.\n3. Now we calculate the position of partition in the larger array (nums2) having fetched the smaller one.\n4. Find the four important numbers - maxSize - left and right of partition in the two arrays.\n5. If maxSizeLeft <= minSizeRight and maxSizeLeft2 <= minSizeRight2, then the partition of both arrays is correct, if not, adjust the partition of nums1. If maxLeftX > minRightY, move the BS partition to the left; if maxLeftY > minRightX, move the BS partition to the right.\n6. When the correct partition is found, calculate the median based on the length of the merged array, even or odd."
        },
        "structure": {
            "c++": "double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n    // Your code here\n}\n",
            "java": "public static double findMedianSortedArrays(int[] nums1, int[] nums2) {\n    // Your code here\n}\n",
            "python": "def findMedianSortedArrays(nums1, nums2):\n    # Your code here\n\n",
            "javascript": "function findMedianSortedArrays(nums1, nums2) {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    // Argument Assignment\n    vector<int> nums1 = $args1;\n    vector<int> nums2 = $args2;\n    \n    // Function Invocation\n    double result = findMedianSortedArrays(nums1, nums2);\n    \n    // Output\n    cout << result << endl;\n    return 0;\n}\n",
            "java": "public static void main(String[] args) {\n        int[] nums1 = $args1;\n        int[] nums2 = $args2;\n        double median = findMedianSortedArrays(nums1, nums2);\n        System.out.println(\"Median: \" + median);\n    }",
            "python": "if __name__ == \"__main__\":\n    inputs =$args\n    nums1 = inputs[0]\n    nums2 = inputs[1]\n    result = findMedianSortedArrays(nums1, nums2)\n    print(result)",
            "javascript": "function main(){\n    const inputs = $args;\n    const nums1 = inputs[0];\n    const nums2 = inputs[1];\n    const result = findMedianSortedArrays(nums1, nums2);\n    console.log(result);\n}\nmain();"
        },
        "Qid": "4",
        "languages verified": [
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d1833cb4648900af06094"
        },
        "title": "Longest Palindromic Substring",
        "description": "Given a string `s`, find and return the longest palindromic substring in `s`. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward. If there are multiple longest palindromic substrings, return any one of them.",
        "example": "Example 1:\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\nExample 2:\n\nInput: s = \"cbbd\"\nOutput: \"bb\"",
        "level": "Medium",
        "tags": [
            "String",
            "Dynamic Programming"
        ],
        "test_cases": {
            "inputs": [
                "babad",
                "\"cbbd\"",
                "\"a\"",
                "\"ac\"",
                "\"bb\"",
                "\"racecar\"",
                "\"abcdeedcba\"",
                "\"abcdefedcba\"",
                "\"abcdeedcbafg\"",
                "\"abcdefedcbagf\"",
                "\"abacdfgdcaba\"",
                "\"abacdfgdcabba\"",
                "\"abacdfgdcabbaa\"",
                "\"abacdfgdcabbaaa\"",
                "\"abacdfgdcabbaaaa\"",
                "\"abacdfgdcabbaaaaa\"",
                "\"abacdfgdcabbaaaaaa\"",
                "\"abacdfgdcabbaaaaaaa\"",
                "\"abacdfgdcabbaaaaaaaa\"",
                "\"abacdfgdcabbaaaaaaaaa\"",
                "\"abacdfgdcabbaaaaaaaaaa\""
            ],
            "outputs": [
                "\"bab\"",
                "\"bb\"",
                "\"a\"",
                "\"a\"",
                "\"bb\"",
                "\"racecar\"",
                "\"abcdeedcba\"",
                "\"abcdefedcba\"",
                "\"abcdeedcba\"",
                "\"abcdefedcba\"",
                "\"aba\"",
                "\"abba\"",
                "\"abba\"",
                "\"abba\"",
                "\"abba\"",
                "\"aaaaa\"",
                "\"aaaaaa\"",
                "\"aaaaaaa\"",
                "\"aaaaaaaa\"",
                "\"aaaaaaaaa\"",
                "\"aaaaaaaaaa\""
            ],
            "input_data_type": [
                "string"
            ],
            "output_data_type": [
                "string"
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n\nstd::string longestPalindromicSubstring(std::string s) {\n  int n = s.size();\n  if (n == 0) return \"\";\n  int start = 0, maxLength = 1;\n\n  for (int i = 0; i < n; ++i) {\n    int l = i, r = i;\n\n    while (r < n - 1 && s[r] == s[r + 1])\n      r++;\n    i = r;\n\n    while (l > 0 && r < n - 1 && s[l - 1] == s[r + 1]) {\n      l--;\n      r++;\n    }\n\n    int length = r - l + 1;\n    if (length > maxLength) {\n      start = l;\n      maxLength = length;\n    }\n  }\n\n  return s.substr(start, maxLength);\n}\n",
            "java": "public static String longestPalindromicSubstring(String s) {\n    int n = s.length();\n    if (n == 0) return \"\";\n\n    int start = 0, maxLength = 1;\n\n    for (int i = 0; i < n; ++i) {\n        int l = i, r = i;\n\n        while (r < n - 1 && s.charAt(r) == s.charAt(r + 1))\n            r++;\n        i = r;\n\n        while (l > 0 && r < n - 1 && s.charAt(l - 1) == s.charAt(r + 1)) {\n            l--;\n            r++;\n        }\n\n        int length = r - l + 1;\n        if (length > maxLength) {\n            start = l;\n            maxLength = length;\n        }\n    }\n\n    return s.substring(start, start + maxLength);\n}\n",
            "python": "def longest_palindromic_substring(s: str) -> str:\n    n = len(s)\n    if n == 0: return \"\"\n\n    start, max_length = 0, 1\n\n    for i in range(n):\n        l, r = i, i\n\n        while r < n - 1 and s[r] == s[r + 1]:\n            r += 1\n        i = r\n\n        while l > 0 and r < n - 1 and s[l - 1] == s[r + 1]:\n            l -= 1\n            r += 1\n\n        length = r - l + 1\n        if length > max_length:\n            start, max_length = l, length\n\n    return s[start:start + max_length]\n",
            "javascript": "function longestPalindromicSubstring(s) {\n  let n = s.length;\n  if (n === 0) return \"\";\n\n  let start = 0, maxLength = 1;\n\n  for (let i = 0; i < n; ++i) {\n    let l = i, r = i;\n\n    while (r < n - 1 && s[r] === s[r + 1])\n      r++;\n    i = r;\n\n    while (l > 0 && r < n - 1 && s[l - 1] === s[r + 1]) {\n      l--;\n      r++;\n    }\n\n    let length = r - l + 1;\n    if (length > maxLength) {\n      start = l;\n      maxLength = length;\n    }\n  }\n\n  return s.substring(start, start + maxLength);\n}\n",
            "explanation": "1. Initialize `start` and `maxLength` for result substring.\n2. Iterate through the given string `s` using the index `i`.\n3. For each index `i`, create two pointers `l` and `r` starting at `i`.\n4. Check if there's a consecutive sequence of identical characters, increment the right pointer `r` until the end of the sequence is reached.\n5. Update the index `i` to the current value of `r`.\n6. Expand the pointers `l` and `r` outwards to find the longest palindromic substring, checking that characters on both sides are equal.\n7. If the current length of the substring is greater than `maxLength`, update `start` and `maxLength`.\n8. Return the longest palindromic substring using the `start` and `maxLength`."
        },
        "structure": {
            "c++": "#include <string>\n\nstd::string longestPalindromicSubstring(std::string s) {\n    // Your code here\n}\n",
            "java": "public static String longestPalindromicSubstring(String s) {\n    // Your code here\n}\n",
            "python": "def longest_palindromic_substring(s: str) -> str:\n    # Your code here\n\n",
            "javascript": "function longestPalindromicSubstring(s) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <string>\n\nstd::string longestPalindromicSubstring(std::string s);\n\nint main() {\n    std::string input = $args;\n    std::string result = longestPalindromicSubstring(input);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n        String input = $args;\n        String result = longestPalindromicSubstring(input);\n        System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = longest_palindromic_substring(s)\n    print(result)",
            "javascript": "function main() {\n  const s = $args;\n  const result = longestPalindromicSubstring(s);\n  console.log(result);\n}\nmain();"
        },
        "Qid": "5",
        "languages verified": [
            "c++",
            "javascript",
            "python",
            "java"
        ]
    },
    {
        "_id": {
            "$oid": "661d1833cb4648900af06096"
        },
        "title": "Palindrome Integer",
        "description": "Given an integer `x`, determine if it is a palindrome. Return `true` if `x` is a palindrome, and `false` otherwise.",
        "example": "Example 1:\n\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.",
        "level": "Easy",
        "tags": [
            "math"
        ],
        "test_cases": {
            "inputs": [
                121,
                -121,
                10,
                12321,
                1234321,
                123454321,
                {
                    "$numberLong": "12345654321"
                },
                {
                    "$numberLong": "123456654321"
                },
                {
                    "$numberLong": "1234567654321"
                },
                {
                    "$numberLong": "12345677654321"
                },
                {
                    "$numberLong": "123456787654321"
                }
            ],
            "outputs": [
                true,
                false,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ],
            "input_data_type": [
                "int"
            ],
            "output_data_type": [
                "bool"
            ]
        },
        "sample_code": {
            "c++": "bool isPalindrome(int x) {\n    if (x < 0) return false;\n    int original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x /= 10;\n    }\n    return original == reversed;\n}\n\n",
            "java": "public static boolean isPalindrome(int x) {\n    if (x < 0) return false;\n    int original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x /= 10;\n    }\n    return original == reversed;\n}\n\n",
            "python": "def is_palindrome(x: int) -> bool:\n    if x < 0:\n        return False\n    original, reversed = x, 0\n    while x > 0:\n        reversed = reversed * 10 + x % 10\n        x //= 10\n    return original == reversed\n\n",
            "javascript": "function isPalindrome(x) {\n    if (x < 0) return false;\n    let original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x = Math.floor(x / 10);\n    }\n    return original === reversed;\n}\n\n",
            "explanation": "Here is the algorithm:\n\n1. If the integer is negative, immediately return false, as negative numbers cannot be palindromes.\n2. Create a variable named `original` to store the original integer value and `reversed` initialized with 0 to store the reversed integer value.\n3. Iterate through the integer while it's greater than zero and, in each iteration, perform the following operations:\n   a. Multiply the `reversed` value by 10 and add the modulus of the integer (x) by 10.\n   b. Divide the integer (x) by 10, discarding the remainder.\n4. Compare `original` and `reversed` integers; if they are equal, return true; otherwise, return false.\n\nThis approach requires O(log10(n)) time complexity as we are dividing the input by 10 in each iteration."
        },
        "structure": {
            "c++": "bool isPalindrome(int x) {\n    // Your code here\n}\n\n",
            "java": "public static boolean isPalindrome(int x) {\n    // Your code here\n}\n\n",
            "python": "def is_palindrome(x: int) -> bool:\n    # Your code here\n\n",
            "javascript": "function isPalindrome(x) {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n = $args;\n    bool result = isPalindrome(n);\n    cout <<std::boolalpha<< result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    int x = $args;\n    boolean result = isPalindrome(x);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    x = $args\n    result = is_palindrome(x)\n    print(result)\n",
            "javascript": "function main() {\n    const x = $args;\n    const result = isPalindrome(x);\n    console.log(result);\n}\nmain();\n"
        },
        "Qid": "9",
        "languages verified": [
            "python",
            "javascript",
            "c++",
            "java"
        ]
    },
    {
        "_id": {
            "$oid": "661d1833cb4648900af06097"
        },
        "title": "Regular Expression Matching",
        "description": "Given an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:\n\n*   `'.'` Matches any single character.\n*   `'*'` Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).",
        "example": "Example:\n\nInput:\n\ns = \"aa \", p = \"a \"\nOutput:\nfalse\nExplanation:\n\"a \" does not match the entire string \"aa \".",
        "level": "Medium",
        "tags": [
            "string",
            "regular expression",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    "aa ",
                    "a "
                ],
                [
                    "aa ",
                    "a* "
                ],
                [
                    "ab ",
                    ".* "
                ],
                [
                    "abc ",
                    "a.c "
                ],
                [
                    "aab ",
                    "c*a*b "
                ],
                [
                    "mississippi ",
                    "mis*is*p*. "
                ],
                [
                    "aaa ",
                    "a*a "
                ],
                [
                    "aaa ",
                    "ab*a*c*a "
                ],
                [
                    "a ",
                    ".*..a* "
                ],
                [
                    "a ",
                    "a*a "
                ],
                [
                    "a ",
                    "a* "
                ],
                [
                    "a ",
                    "a. "
                ],
                [
                    "a ",
                    "a.* "
                ],
                [
                    "a ",
                    "a.. "
                ],
                [
                    "a ",
                    "a... "
                ],
                [
                    "a ",
                    "a.... "
                ],
                [
                    "a ",
                    "a..... "
                ],
                [
                    "a ",
                    "a...... "
                ],
                [
                    "a ",
                    "a....... "
                ],
                [
                    "a ",
                    "a........ "
                ]
            ],
            "outputs": [
                false,
                true,
                true,
                true,
                true,
                false,
                true,
                true,
                false,
                true,
                true,
                false,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "bool isMatch(std::string s, std::string p) {\n    int m = s.length(), n = p.length();\n    std::vector<std::vector<bool>> dp(m + 1, std::vector<bool>(n + 1, false));\n    dp[0][0] = true;\n\n    for (int j = 1; j <= n; j++) {\n        if (p[j - 1] == '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (p[j - 1] == s[i - 1] || p[j - 1] == '.') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p[j - 1] == '*') {\n                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n",
            "java": "public boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n\n    for (int j = 1; j <= n; j++) {\n        if (p.charAt(j - 1) == '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (p.charAt(j - 1) == s.charAt(i - 1) || p.charAt(j - 1) == '.') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p.charAt(j - 1) == '*') {\n                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'));\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n",
            "python": "def is_match(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        if p[j - 1] == '*' and dp[0][j - 2]:\n            dp[0][j] = True\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                dp[i][j] = dp[i - 1][j - 1]\n            elif p[j - 1] == '*':\n                dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))\n\n    return dp[m][n]\n",
            "javascript": "function isMatch(s, p) {\n    const m = s.length, n = p.length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(false));\n    dp[0][0] = true;\n\n    for (let j = 1; j <= n; j++) {\n        if (p[j - 1] === '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n          if (p[j - 1] === s[i - 1] || p[j - 1] === '.') {\n              dp[i][j] = dp[i - 1][j - 1];\n          } else if (p[j - 1] === '*') {\n              dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] === p[j - 2] || p[j - 2] === '.'));\n          }\n      }\n    }\n\n    return dp[m][n];\n}\n",
            "explanation": "We use Dynamic Programming to solve this problem. We store intermediate results in a 2D boolean array `dp`, where `dp[i][j]` indicates whether the first `i` characters of `s` match the first `j` characters of `p`. We then loop through the characters of both strings and update the `dp` table.\n\nIf the current characters in `s` and `p` are equal or `p` has a '.', we update the `dp[i][j]` to the value `dp[i - 1][j - 1]`, because the match continues.\n\nIf the current character in `p` is '*', we have two options:\n\n1. Consider the matching of the previous character in `p` as 0 occurrences. We update the `dp[i][j]` value to `dp[i][j - 2]`.\n2. Consider the matching of the previous character in `p` as at least 1 occurrence. We update `dp[i][j]` to the value of `dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')`.\n\nFinally, `dp[m][n]` stores the result, where `m` and `n` are the lengths of strings `s` and `p` respectively."
        },
        "structure": {
            "c++": "bool isMatch(std::string s, std::string p)  {\n    // Your code here\n}\n",
            "java": "public boolean isMatch(String s, String p)  {\n    // Your code here\n}\n",
            "python": "def is_match(s: str, p: str) -> bool:\n    # Your code here\n\n",
            "javascript": "function isMatch(s, p) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\n\nbool isMatch(std::string s, std::string p) {\n    int m = s.length(), n = p.length();\n    std::vector<std::vector<bool>> dp(m + 1, std::vector<bool>(n + 1, false));\n    dp[0][0] = true;\n\n    for (int j = 1; j <= n; j++) {\n        if (p[j - 1] == '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (p[j - 1] == s[i - 1] || p[j - 1] == '.') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p[j - 1] == '*') {\n                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n\nint main() {\n    std::string s = $args;\n    std::string p = $args;\n    bool result = isMatch(s, p);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "java": "public boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n\n    for (int j = 1; j <= n; j++) {\n        if (p.charAt(j - 1) == '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (p.charAt(j - 1) == s.charAt(i - 1) || p.charAt(j - 1) == '.') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p.charAt(j - 1) == '*') {\n                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'));\n            }\n        }\n    }\n\n    return dp[m][n];\n}",
            "python": "if __name__ == \"__main__\":\n    inputs =$args\n    s = inputs[0]\n    p = inputs[1]\n    result = is_match(s, p)\n    print(result)",
            "javascript": "function main() {\n    const inputs =$args;\n    const s = inputs[0];\n    const p = inputs[1];\n    const result = isMatch(s, p);\n    console.log(result);\n}\nmain();"
        },
        "Qid": "10",
        "languages verified": [
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d1833cb4648900af06098"
        },
        "title": "Container With Most Water",
        "description": "Given an integer array `height` of length `n`, where each element represents the height of a vertical line, find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water the container can store.",
        "example": "Example:\n\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.",
        "level": "Medium",
        "tags": [
            "Array",
            "Two Pointers",
            "Greedy"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    8,
                    6,
                    2,
                    5,
                    4,
                    8,
                    3,
                    7
                ],
                [
                    1,
                    1
                ],
                [
                    4,
                    3,
                    2,
                    1,
                    4
                ],
                [
                    1,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    20,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ]
            ],
            "outputs": [
                49,
                1,
                16,
                2,
                6,
                6,
                4,
                25,
                25,
                100,
                100
            ],
            "input_data_type": [
                "array"
            ],
            "output_data_type": [
                "int"
            ]
        },
        "sample_code": {
            "c++": "#include <iostream>\n#include <vector>\n#include <algorithm> \nusing namespace std;\n\nint maxArea(vector<int>& height) {\n    int max_area = 0, left = 0, right = height.size() - 1;\n    while (left < right) {\n        max_area = max(max_area, min(height[left], height[right]) * (right - left));\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return max_area;\n}\n",
            "java": "\npublic static int maxArea(int[] height) {\n    int max_area = 0, left = 0, right = height.length - 1;\n    while (left < right) {\n        max_area = Math.max(max_area, Math.min(height[left], height[right]) * (right - left));\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return max_area;\n}\n",
            "python": "def max_area(height):\n    max_area, left, right = 0, 0, len(height) - 1\n    while left < right:\n        max_area = max(max_area, min(height[left], height[right]) * (right - left))\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_area\n",
            "javascript": "function maxArea(height) {\n    let max_area = 0, left = 0, right = height.length - 1;\n    while (left < right) {\n        max_area = Math.max(max_area, Math.min(height[left], height[right]) * (right - left));\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return max_area;\n}\n",
            "explanation": "The algorithm uses a two-pointer approach, with one pointer starting from the left end and the other from the right end. It calculates the area between these two lines and updates the maximum area if the current area is larger than the previously calculated maximum area. If the height at the left pointer is less than the height at the right pointer, it moves the left pointer to the right. Otherwise, it moves the right pointer to the left. The algorithm continues until the pointers meet.\n\nThis algorithm ensures that the maximum area is found without having to check all possible pairs of lines because it always chooses the pair of lines with the maximum possible distance and minimum height difference at each step."
        },
        "structure": {
            "c++": "int maxArea(vector<int>& height) {\n    // Your code here\n}\n",
            "java": "public static int maxArea(int[] height) {\n    // Your code here\n}\n",
            "python": "def max_area(height):\n    # Your code here\n\n",
            "javascript": "function maxArea(height) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\n#include <algorithm> \nusing namespace std;\n\nint main() {\n    vector<int> height = {5, 4, 3, 2, 1};\n    int result = maxArea(height);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    int[] height = new int[]{1, 2, 1};\n    int result = maxArea(height);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    height = [5, 4, 3, 2, 1]\n    result = max_area(height)\n    print(result)",
            "javascript": "function main() {\n    const height = [5, 4, 3, 2, 1];\n    const result = maxArea(height);\n    console.log(result);\n}\nmain();"
        },
        "Qid": "11",
        "languages verified": [
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d1833cb4648900af06099"
        },
        "title": "Zigzag Conversion",
        "description": "The string `PAYPALISHIRING` is written in a zigzag pattern on a given number of rows. Write a function `convert` that takes a string and the number of rows and returns the string in the zigzag pattern.",
        "example": "Example 1:\n\nInput: s = `PAYPALISHIRING`, numRows = 3\nOutput: `PAHNAPLSIIGYIR`\n\nExample 2:\n\nInput: s = `PAYPALISHIRING`, numRows = 4\nOutput: `PINALSIGYAHRPI`\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n\nExample 3:\n\nInput: s = `A`, numRows = 1\nOutput: `A`",
        "level": "Medium",
        "tags": [
            "string",
            "pattern"
        ],
        "test_cases": {
            "inputs": [
                [
                    "PAYPALISHIRING",
                    3
                ],
                [
                    "PAYPALISHIRING",
                    4
                ],
                [
                    "A",
                    1
                ],
                [
                    "HELLO",
                    2
                ],
                [
                    "WORLD",
                    2
                ],
                [
                    "ZIGZAG",
                    4
                ],
                [
                    "CONVERSION",
                    5
                ],
                [
                    "CODING",
                    3
                ],
                [
                    "QUESTION",
                    4
                ],
                [
                    "EXAMPLE",
                    3
                ],
                [
                    "TEST",
                    2
                ],
                [
                    "CASES",
                    3
                ],
                [
                    "ZIGZAGCONVERSION",
                    5
                ],
                [
                    "STRING",
                    4
                ],
                [
                    "PATTERN",
                    3
                ],
                [
                    "ALGORITHM",
                    6
                ],
                [
                    "PROGRAMMING",
                    5
                ],
                [
                    "CHALLENGE",
                    4
                ],
                [
                    "SOLUTION",
                    3
                ],
                [
                    "LEETCODE",
                    2
                ]
            ],
            "outputs": [
                "\"PAHNAPLSIIGYIR\"",
                "\"PINALSIGYAHRPI\"",
                "\"A\"",
                "\"HLOEL\"",
                "\"WDLRO\"",
                "\"ZGZAI\"",
                "\"CNOIOTVN\"",
                "\"CIGDNO\"",
                "\"QETNUSO\"",
                "\"EPEXMLA\"",
                "\"TSET\"",
                "\"SECA\"",
                "\"ZGZAIOTNNOVC\"",
                "\"SRTNI\"",
                "\"PTNREA\"",
                "\"AOLGMRITHM\"",
                "\"PORMGAMRIN\"",
                "\"CEGELLNAH\"",
                "\"NIOITULOS\"",
                "\"ETACODEEL\""
            ]
        },
        "sample_code": {
            "c++": "#include <iostream>\n#include <string>\n#include <vector>\n\nstd::string convert(std::string s, int numRows) {\n    if (numRows == 1 || numRows >= s.size()) return s;\n\n    std::vector<std::string> rows(std::min(numRows, int(s.size())));\n    int curRow = 0;\n    bool goingDown = false;\n\n    for (char c : s) {\n        rows[curRow] += c;\n        if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;\n        curRow += goingDown ? 1 : -1;\n    }\n\n    std::string result;\n    for (std::string row : rows) result += row;\n    return result;\n}\n",
            "java": "\n    public static String convert(String s, int numRows) {\n        if (numRows == 1 || numRows >= s.length()) return s;\n\n        StringBuilder[] rows = new StringBuilder[numRows];\n        for (int i = 0; i < numRows; i++) rows[i] = new StringBuilder();\n        \n        int curRow = 0;\n        boolean goingDown = false;\n\n        for (char c : s.toCharArray()) {\n            rows[curRow].append(c);\n            if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;\n            curRow += goingDown ? 1 : -1;\n        }\n\n        StringBuilder result = new StringBuilder();\n        for (StringBuilder row : rows) result.append(row);\n        return result.toString();\n    }\n\n",
            "python": "def convert(s: str, numRows: int) -> str:\n    if numRows == 1 or numRows >= len(s):\n        return s\n\n    rows = [\"\"] * numRows\n    curRow = 0\n    goingDown = False\n\n    for c in s:\n        rows[curRow] += c\n        if curRow == 0 or curRow == numRows - 1:\n            goingDown = not goingDown\n        curRow += 1 if goingDown else -1\n\n    return \"\".join(rows)\n",
            "javascript": "function convert(s, numRows) {\n    if (numRows === 1 || numRows >= s.length) return s;\n\n    let rows = new Array(numRows).fill(\"\");\n    let curRow = 0;\n    let goingDown = false;\n\n    for (let c of s) {\n        rows[curRow] += c;\n        if (curRow === 0 || curRow === numRows - 1) goingDown = !goingDown;\n        curRow += goingDown ? 1 : -1;\n    }\n\n    return rows.join(\"\");\n}\n",
            "explanation": "1. If the number of rows is 1 or is greater than or equal to the length of the string, the string is just returned as is.\n2. Create an array called \"rows\" to contain the characters that would reside in each row of the zigzag pattern.\n3. Iterate through the string one character at a time.\n4. For each character in the string, place it into the appropriate row of the \"rows\" array.\n5. Determine whether the next character should be placed in the row above or below the current row by checking if the current row is 0 (at the top) or equal to the number of rows minus 1 (at the bottom). If at the top or the bottom, the direction will change.\n6. Update the current row index according to the direction (going up or down).\n7. After iterating through the entire string, join the rows array into a single string and return it."
        },
        "structure": {
            "c++": "#include <string>\n#include <vector>\n\nstd::string convert(std::string s, int numRows) {\n    // Your code here\n}\n",
            "java": "public class ZigzagConversion {\n    // Your code here\n}\n",
            "python": "def convert(s: str, numRows: int) -> str:\n    # Your code here\n\n",
            "javascript": "function convert(s, numRows)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "\nint main() {\n    std::string s =\"CODING\";\n    int numRows = 3;\n    std::string result = convert(s, numRows);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs = $args\n    s = inputs[0]\n    numRows = inputs[1]\n    result = convert(s, numRows)\n    print(result)",
            "javascript": "function main() {\n    const inputs = $args;\n    const s = inputs[0];\n    const numRows = inputs[1];\n    const result = convert(s, numRows);\n    console.log(result);\n}\nmain();",
            "java": "\npublic static void main(String[] args) {\n    String s = \"CONVERSION\";\n    int numRows= 5;\n    String result = convert(s, numRows) ;\n    System.out.println(result);\n}"
        },
        "Qid": "6",
        "languages verified": [
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d1833cb4648900af0609a"
        },
        "title": "String to Integer (atoi)",
        "description": "Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).\n\nThe algorithm for `myAtoi(string s)` is as follows:\n\n1. Read in and ignore any leading whitespace.\n2. Check if the next character (if not already at the end of the string) is \"-\" or \"+\". Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n3. Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n4. Convert these digits into an integer (i.e. \"123 \" -> 123, \"0032 \" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\n5. If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\n6. Return the integer as the final result.\n\n**Note:**\n\n- Only the space character \" \" is considered a whitespace character.\n- **Do not ignore** any characters other than the leading whitespace or the rest of the string after the digits.",
        "example": "Example 1:\n\nInput: s = \"42 \"\nOutput: 42\nExplanation: The underlined characters are what is read in, the caret is the current reader position.\nStep 1: \"42 \" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42 \" (no characters read because there is neither a \"-\" nor \"+\")\n         ^\nStep 3: \"42 \" (\"42\" is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range [-231, 231 - 1], the final result is 42.\n\nExample 2:\n\nInput: s = \"   -42 \"\nOutput: -42\nExplanation: Step 1: \"   -42 \" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   -42 \" (\"-\" is read, so the result should be negative)\n             ^\nStep 3: \"   -42 \" (\"42\" is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range [-231, 231 - 1], the final result is -42.\n\nExample 3:\n\nInput: s = \"4193 with words \"\nOutput: 4193\nExplanation: Step 1: \"4193 with words \" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"4193 with words \" (no characters read because there is neither a \"-\" nor \"+\")\n         ^\nStep 3: \"4193 with words \" (\"4193\" is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\nSince 4193 is in the range [-231, 231 - 1], the final result is 4193.",
        "level": "Medium",
        "tags": [
            "string",
            "parsing",
            "integer"
        ],
        "test_cases": {
            "inputs": [
                "\"42 \"",
                "\"   -42 \"",
                "\"4193 with words \"",
                "\"words and 987\"",
                "\"-91283472332\"",
                "\"3.14159\"",
                "\"-3.14159\"",
                "\"-1234567890123456789012345678901234567890\"",
                "\"1234567890123456789012345678901234567890\"",
                "\"\"",
                "\"0\"",
                "\"-\"",
                "\"+\"",
                "\"-0\"",
                "\"+0\"",
                "\"-123\"",
                "\"+123\"",
                "\"-000123\"",
                "\"+000123\"",
                "\"-000\"",
                "\"+000\""
            ],
            "outputs": [
                42,
                -42,
                4193,
                0,
                -2147483648,
                3,
                -3,
                -2147483648,
                2147483647,
                0,
                0,
                0,
                0,
                0,
                -123,
                123,
                -123,
                123,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "#include <iostream>\n#include <string>\n#include <climits> // For INT_MAX and INT_MIN\n#include <cctype>  // For isdigit\n\nint myAtoi(const std::string& s) {\n    long result = 0;\n    int i = 0, sign = 1;\n    while (s[i] == ' ') i++;\n    if (s[i] == '-' || s[i] == '+') sign = (s[i++] == '+') ? 1 : -1;\n    while (isdigit(s[i])) {\n        result = result * 10 + (s[i++] - '0');\n        if (result * sign > INT_MAX) return INT_MAX;\n        if (result * sign < INT_MIN) return INT_MIN;\n    }\n    return result * sign;\n}\n",
            "java": "public static int myAtoi(String s) {\n    long result = 0;\n    int i = 0, sign = 1;\n    while (i < s.length() && s.charAt(i) == ' ') i++;\n    if (i < s.length() && (s.charAt(i) == '-' || s.charAt(i) == '+')) {\n        sign = (s.charAt(i++) == '+') ? 1 : -1;\n    }\n    while (i < s.length() && Character.isDigit(s.charAt(i))) {\n        result = result * 10 + (s.charAt(i++) - '0');\n        if (result * sign > Integer.MAX_VALUE) return Integer.MAX_VALUE;\n        if (result * sign < Integer.MIN_VALUE) return Integer.MIN_VALUE;\n    }\n    return (int) (result * sign);\n}\n",
            "python": "def myAtoi(s):\n    result, i, sign = 0, 0, 1\n    while i < len(s) and s[i] == ' ': i += 1\n    if i < len(s) and (s[i] == '-' or s[i] == '+'):\n        sign = -1 if s[i] == '-' else 1\n        i += 1\n    while i < len(s) and s[i].isdigit():\n        result = result * 10 + int(s[i])\n        i += 1\n        if result * sign > 2**31 - 1: return 2**31 - 1\n        if result * sign < -2**31: return -2**31\n    return result * sign\n",
            "javascript": "function myAtoi(s) {\n    let result = 0, i = 0, sign = 1;\n    while (s[i] === ' ') i++;\n    if (s[i] === '-' || s[i] === '+') sign = (s[i++] === '+') ? 1 : -1;\n    while (!isNaN(s[i]) && s[i] !== ' ') {\n        result = result * 10 + parseInt(s[i++], 10);\n        if (result * sign > 2147483647) return 2147483647;\n        if (result * sign < -2147483648) return -2147483648;\n    }\n    return result * sign;\n}\n",
            "explanation": "1. Initialize `result` as 0, index `i` as 0, and `sign` as 1 (positive).\n2. Loop through the string until a non-space character is found or the end of the string is reached.\n3. If the current character is '+' or '-', update the `sign` according to the character and increment the index `i`.\n4. If a digit is found, multiply the previous `result` by 10 and add the digit to it. Increment the index `i`.\n5. Check if the result multiplied by the sign is out of the 32-bit signed integer range. If so, return the appropriate boundary value.\n6. When no more digits are found, return the final result multiplied by the sign."
        },
        "structure": {
            "c++": "#include <iostream>\n#include <string>\n#include <climits> // For INT_MAX and INT_MIN\n#include <cctype>  // For isdigit\n\nint myAtoi(const std::string& s) { \n    // Your code here\n}\n",
            "java": "public int myAtoi(String s) {\n    // Your code here\n}\n",
            "python": "def myAtoi(s):\n    # Your code here\n\n",
            "javascript": "function myAtoi(s) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "\n\nint main() {\n    std::string s = $args;\n    int result = myAtoi(s);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "\n\npublic static void main(String[] args) {\n    String s = $args;\n    int result = myAtoi(s);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = myAtoi(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = myAtoi(s);\n    console.log(result);\n}\nmain();"
        },
        "Qid": "8",
        "languages verified": [
            "python",
            "javascript",
            "java",
            "c++"
        ]
    },
    {
        "_id": {
            "$oid": "661d1833cb4648900af0609b"
        },
        "title": "Convert Integer to Roman Numeral",
        "description": "Given an integer, convert it to a Roman numeral. Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D`, and `M`. The symbols and their corresponding values are as follows:\n\n`I` - 1\n`V` - 5\n`X` - 10\n`L` - 50\n`C` - 100\n`D` - 500\n`M` - 1000\n\nRoman numerals are usually written largest to smallest from left to right. However, there are six instances where subtraction is used. For example, `IV` represents 4, `IX` represents 9, `XL` represents 40, `XC` represents 90, `CD` represents 400, and `CM` represents 900.\n\nWrite a function `convertToRoman` that takes an integer `num` as input and returns its Roman numeral representation as a string.",
        "example": "Example:\n\nInput:\nnum = 3\n\nOutput:\n\"III\"\n\nExplanation:\n3 is represented as 3 ones.\n\nInput:\nnum = 58\n\nOutput:\n\"LVIII\"\n\nExplanation:\nL = 50, V = 5, III = 3.\n\nInput:\nnum = 1994\n\nOutput:\n\"MCMXCIV\"\n\nExplanation:\nM = 1000, CM = 900, XC = 90, and IV = 4.",
        "level": "Medium",
        "tags": [
            "Math",
            "String"
        ],
        "test_cases": {
            "inputs": [
                3,
                58,
                1994,
                4,
                9,
                40,
                90,
                400,
                900,
                3999,
                1,
                10,
                100,
                1000,
                399,
                444,
                555,
                666,
                777,
                888
            ],
            "outputs": [
                "III",
                "LVIII",
                "MCMXCIV",
                "IV",
                "IX",
                "XL",
                "XC",
                "CD",
                "CM",
                "MMMCMXCIX",
                "I",
                "X",
                "C",
                "M",
                "CCCXCIX",
                "CDXLIV",
                "DLV",
                "DCLXVI",
                "DCCLXXVII",
                "DCCCLXXXVIII"
            ]
        },
        "sample_code": {
            "c++": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::string intToRoman(int num) {\n    std::vector<std::pair<int, std::string>> romans = {\n        {1000, \"M\"},\n        {900, \"CM\"},\n        {500, \"D\"},\n        {400, \"CD\"},\n        {100, \"C\"},\n        {90, \"XC\"},\n        {50, \"L\"},\n        {40, \"XL\"},\n        {10, \"X\"},\n        {9, \"IX\"},\n        {5, \"V\"},\n        {4, \"IV\"},\n        {1, \"I\"}\n    };\n    std::string roman = \"\";\n    for (const auto& p : romans) {\n        while (num >= p.first) {\n            roman += p.second;\n            num -= p.first;\n        }\n    }\n    return roman;\n}\n",
            "java": "\n    public static String intToRoman(int num) {\n        List<Pair> romans = Arrays.asList(\n            new Pair(1000, \"M\"), new Pair(900, \"CM\"), new Pair(500, \"D\"), \n            new Pair(400, \"CD\"), new Pair(100, \"C\"), new Pair(90, \"XC\"),\n            new Pair(50, \"L\"), new Pair(40, \"XL\"), new Pair(10, \"X\"), \n            new Pair(9, \"IX\"), new Pair(5, \"V\"), new Pair(4, \"IV\"),\n            new Pair(1, \"I\")\n        );\n        StringBuilder roman = new StringBuilder();\n        for (Pair p : romans) {\n            while (num >= p.num) {\n                roman.append(p.symbol);\n                num -= p.num;\n            }\n        }\n        return roman.toString();\n    }\n    \n    private static class Pair {\n        final int num;\n        final String symbol;\n        \n        Pair(int num, String symbol) {\n            this.num = num;\n            this.symbol = symbol;\n        }\n    }\n\n",
            "python": "def int_to_roman(num):\n    romans = [\n        (1000, \"M\"), (900, \"CM\"), (500, \"D\"),\n        (400, \"CD\"), (100, \"C\"), (90, \"XC\"),\n        (50, \"L\"), (40, \"XL\"), (10, \"X\"), \n        (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")\n    ]\n    roman = \"\"\n    for value, symbol in romans:\n        while num >= value:\n            roman += symbol\n            num -= value\n    return roman\n",
            "javascript": "function intToRoman(num) {\n    const romans = [\n        [1000, \"M\"], [900, \"CM\"], [500, \"D\"],\n        [400, \"CD\"], [100, \"C\"], [90, \"XC\"],\n        [50, \"L\"], [40, \"XL\"], [10, \"X\"], \n        [9, \"IX\"], [5, \"V\"], [4, \"IV\"], [1, \"I\"]\n    ];\n    let roman = \"\";\n    for (const [value, symbol] of romans) {\n        while (num >= value) {\n            roman += symbol;\n            num -= value;\n        }\n    }\n    return roman;\n}\n",
            "explanation": "The algorithm starts with a list of pairs, where each pair contains a decimal value and its corresponding roman numeral. Then, it iteratively go through the list of pairs and checks if the num is greater than or equal to the decimal value. If it is, it appends the roman numeral to the result, and subtracts the decimal value from the num. This is done until the num becomes 0."
        },
        "structure": {
            "c++": "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::string intToRoman(int num) {\n    // Your code here\n}\n",
            "java": "public static class RomanNumerals {\n    // Your code here\n}\n",
            "python": "def int_to_roman(num):\n    # Your code here\n\n",
            "javascript": "function intToRoman(num)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "std::string intToRoman(int num);\nint main() {\n    int n = $args;\n    std::string result = intToRoman(n);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public static void main(String[] args) {\n    int num = $args;\n    String result = intToRoman(num);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    num = $args\n    result = int_to_roman(num)\n    print(result)",
            "javascript": "function main() {\n    const num = $args;\n    const result = intToRoman(num);\n    console.log(result);\n}\nmain();"
        },
        "Qid": "12",
        "languages verified": [
            "python",
            "c++",
            "javascript",
            "java"
        ]
    },
    {
        "_id": {
            "$oid": "661d1833cb4648900af0609c"
        },
        "title": "Roman Numeral to Integer Conversion",
        "description": "Given a Roman numeral, convert it to an integer. Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D`, and `M`. The symbols and their corresponding values are as follows: \n\n`I` - 1\n`V` - 5\n`X` - 10\n`L` - 50\n`C` - 100\n`D` - 500\n`M` - 1000\n\nRoman numerals are usually written largest to smallest from left to right. However, there are six instances where subtraction is used. For example, `IV` represents 4 (5 - 1) and `IX` represents 9 (10 - 1). The goal is to convert the given Roman numeral into its corresponding integer value.",
        "example": "Example:\n\nInput: \"III\"\nOutput: 3\nExplanation: The Roman numeral \"III\" represents the number 3.\n\nInput: \"LVIII\"\nOutput: 58\nExplanation: The Roman numeral \"LVIII\" represents the number 58. It can be broken down as follows: L (50) + V (5) + III (3).\n\nInput: \"MCMXCIV\"\nOutput: 1994\nExplanation: The Roman numeral \"MCMXCIV\" represents the number 1994. It can be broken down as follows: M (1000) + CM (900) + XC (90) + IV (4).",
        "level": "Easy",
        "tags": [
            "String",
            "Math"
        ],
        "test_cases": {
            "inputs": [
                "\"III\"",
                "\"LVIII\"",
                "\"MCMXCIV\"",
                "\"IV\"",
                "\"IX\"",
                "\"XL\"",
                "\"XC\"",
                "\"CD\"",
                "\"CM\"",
                "\"XIV\"",
                "\"XXIX\"",
                "\"XLV\"",
                "\"XCIX\"",
                "\"CDXLIV\"",
                "\"CMXCIX\"",
                "\"MMMCMXCIX\"",
                "\"I\"",
                "\"V\"",
                "\"X\"",
                "\"L\"",
                "\"C\"",
                "\"D\"",
                "\"M\""
            ],
            "outputs": [
                "3",
                "58",
                "1994",
                "4",
                "9",
                "40",
                "90",
                "400",
                "900",
                "14",
                "29",
                "45",
                "99",
                "444",
                "999",
                "3999",
                "1",
                "5",
                "10",
                "50",
                "100",
                "500",
                "1000"
            ]
        },
        "sample_code": {
            "c++": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\n\nint romanToInt(string s) {\n    unordered_map<char, int> roman_values = { {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000} };\n    int total = 0;\n    int prev_value = 0;\n\n    for (char c : s) {\n        int current_value = roman_values[c];\n        if (current_value > prev_value)\n            total += current_value - (2 * prev_value);\n        else\n            total += current_value;\n        prev_value = current_value;\n    }\n\n    return total;\n}\n\n",
            "java": "public static int romanToInt(String s) {\n    Map<Character, Integer> romanValues = new HashMap<>();\n    romanValues.put('I', 1);\n    romanValues.put('V', 5);\n    romanValues.put('X', 10);\n    romanValues.put('L', 50);\n    romanValues.put('C', 100);\n    romanValues.put('D', 500);\n    romanValues.put('M', 1000);\n\n    int total = 0;\n    int prevValue = 0;\n\n    for (char c : s.toCharArray()) {\n        int currValue = romanValues.get(c);\n        total += currValue > prevValue ? currValue - 2 * prevValue : currValue;\n        prevValue = currValue;\n    }\n\n    return total;\n}\n\n",
            "python": "def roman_to_int(s):\n    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    total = 0\n    prev_value = 0\n    \n    for c in s:\n        current_value = roman_values[c]\n        if current_value > prev_value:\n            total += current_value - 2 * prev_value\n        else:\n            total += current_value\n        prev_value = current_value\n\n    return total\n\n",
            "javascript": "function romanToInt(s) {\n    const romanValues = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000};\n    let total = 0;\n    let prevValue = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        let currValue = romanValues[s[i]];\n        if (currValue > prevValue)\n            total += currValue - (2 * prevValue);\n        else\n            total += currValue;\n        prevValue = currValue;\n    }\n\n    return total;\n}\n\n",
            "explanation": "The algorithm iterates through the input string, which represents the Roman numeral. At each iteration, the character is converted to its corresponding integer value using a hash map. Then, the value is added to the total. However, if the current value is greater than the previous value, it means that we need to subtract the previous value from the current value (while considering that the previous value has already been added once). To do this, we add to the total the current value minus 2 times the previous value. Finally, the previous value is updated, and the loop continues. After the loop finishes, the total gives us the integer value equivalent to the Roman numeral."
        },
        "structure": {
            "c++": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint romanToInt(string s) {\n    // Your code here\n}\n\n",
            "java": "public static int romanToInt(String s) {\n    // Your code here\n}\n\n",
            "python": "def roman_to_int(s):\n    # Your code here\n\n",
            "javascript": "function romanToInt(s) {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "\nint main() {\n    string s = $args;\n    int result = romanToInt(s);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[ ] args){\n    String input = $args;\n    int result = romanToInt(input);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    s = \"III\"\n    result = roman_to_int(s)\n    print(result)",
            "javascript": "function main() {\n    const s = \"III\";\n    const result = romanToInt(s);\n    console.log(result);\n}"
        },
        "Qid": "13",
        "languages verified": [
            "python",
            "c++"
        ]
    },
    {
        "_id": {
            "$oid": "661d1833cb4648900af0609d"
        },
        "title": "Longest Common Prefix",
        "description": "Write a function that takes an array of strings and returns the longest common prefix string among them. If there is no common prefix, return an empty string.",
        "example": "For example, given the input strs = [\"flower\", \"flow\", \"flight\"], the output should be \"fl\". \n\nExplanation: The longest common prefix among the strings is \"fl\".\n\nGiven the input strs = [\"dog\", \"racecar\", \"car\"], the output should be an empty string. \n\nExplanation: There is no common prefix among the strings.",
        "level": "Easy",
        "tags": [
            "Array",
            "String"
        ],
        "test_cases": {
            "inputs": [
                [
                    "flower",
                    "flow",
                    "flight"
                ],
                [
                    "dog",
                    "racecar",
                    "car"
                ],
                [
                    "apple",
                    "app",
                    "application"
                ],
                [
                    "coding",
                    "code",
                    "coder"
                ],
                [
                    "hello",
                    "hell",
                    "help"
                ],
                [
                    "prefix",
                    "pre",
                    "preparation"
                ],
                [
                    "",
                    "abc",
                    "def"
                ],
                [
                    "",
                    "",
                    ""
                ],
                [
                    "abc",
                    "abc",
                    "abc"
                ],
                [
                    "abc",
                    "abcd",
                    "abcde"
                ],
                [
                    "abc",
                    "def",
                    "ghi"
                ],
                [
                    "abc",
                    "ab",
                    "a"
                ],
                [
                    "abc",
                    "ab",
                    "abc"
                ],
                [
                    "abc",
                    "ab",
                    "abcd"
                ],
                [
                    "abc",
                    "ab",
                    "abcde"
                ],
                [
                    "abc",
                    "ab",
                    "abcdefgh"
                ],
                [
                    "abc",
                    "ab",
                    "abcdefghi"
                ],
                [
                    "abc",
                    "ab",
                    "abcdefghij"
                ],
                [
                    "abc",
                    "ab",
                    "abcdefghijk"
                ],
                [
                    "abc",
                    "ab",
                    "abcdefghijkl"
                ]
            ],
            "outputs": [
                "fl",
                "",
                "app",
                "cod",
                "hel",
                "pre",
                "",
                "",
                "abc",
                "abc",
                "",
                "a",
                "ab",
                "abc",
                "abc",
                "abc",
                "abc",
                "abc",
                "abc",
                "abc"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <iostream>  // Include for cout\n\nusing namespace std;\n\nstring longestCommonPrefix(vector<string>& strs) {\n    if (strs.empty()) return \"\";\n\n    for (int i = 0; i < strs[0].size(); ++i) {\n        char c = strs[0][i];\n        for (int j = 1; j < strs.size(); ++j) {\n            if (i == strs[j].size() || strs[j][i] != c) {\n                return strs[0].substr(0, i);\n            }\n        }\n    }\n    return strs[0];\n}",
            "java": "public static String longestCommonPrefix(String[] strs) {\n    if (strs.length == 0) return \"\";\n\n    for (int i = 0; i < strs[0].length(); ++i) {\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; ++j) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c) {\n                return strs[0].substring(0, i);\n            }\n        }\n    }\n    return strs[0];\n}\n",
            "python": "def longest_common_prefix(strs):\n    if not strs:\n        return \"\"\n\n    for i, c in enumerate(strs[0]):\n        for j in range(1, len(strs)):\n            if i == len(strs[j]) or strs[j][i] != c:\n                return strs[0][:i]\n    return strs[0]\n",
            "javascript": "function longestCommonPrefix(strs) {\n    if (strs.length === 0) return \"\";\n\n    for (let i = 0; i < strs[0].length; ++i) {\n        const c = strs[0][i];\n        for (let j = 1; j < strs.length; ++j) {\n            if (i === strs[j].length || strs[j][i] !== c) {\n                return strs[0].substr(0, i);\n            }\n        }\n    }\n    return strs[0];\n}\n",
            "explanation": "The algorithm iterates through the characters in the first string and compares the equivalent characters in the subsequent strings. If there is a mismatch detected, return the common prefix up to the mismatch point. If the algorithm finishes iterating over the first string, return the entire first string as the common prefix.\n\n1. Check if the input array is empty, if it is, return an empty string as there is no common prefix.\n2. Iterate through the characters of the first string.\n3. For each character, iterate through the rest of the strings in the array.\n4. Compare the current character with the corresponding character in the other strings.\n5. If there is a mismatch or if we reach the end of a string, return the common prefix substring up to the current index.\n6. If the loop reaches the end of the first string, then the whole first string is the common prefix. Return the entire first string."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <iostream>  // Include for cout\nusing namespace std;\nstring longestCommonPrefix(vector<string>& strs) {\n    // Your code here\n}\n",
            "java": "public String longestCommonPrefix(String[] strs) {\n    // Your code here\n}\n",
            "python": "def longest_common_prefix(strs):\n    # Your code here\n\n",
            "javascript": "function longestCommonPrefix(strs) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<string> strs = $args;  // Use double quotes for strings\n    string result = longestCommonPrefix(strs);\n    std::cout <<\"$sprouts@pankaj\"<<result<<\"$sprouts@pankaj\";\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    String[] strs = $args;\n    String result = longestCommonPrefix(strs);\n    System.out.println(\"$sprouts@pankaj\"+result+\"$sprouts@pankaj\"\n);\n}",
            "python": "if __name__ == \"__main__\":\n    strs = $args\n    result = longest_common_prefix(strs)\n    print(\"$sprouts@pankaj\",result,\"$sprouts@pankaj\")",
            "javascript": "function main() {\n    const strs = $args;\n    const result = longestCommonPrefix(strs);\n    console.log(\"$sprouts@pankaj\",result,\"$sprouts@pankaj\");\n}\nmain();"
        },
        "Qid": "14",
        "languages verified": [
            "python",
            "c++",
            "javascript",
            "java"
        ]
    },
    {
        "_id": {
            "$oid": "661d1833cb4648900af0609e"
        },
        "title": "Triplets with Zero Sum",
        "description": "Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`. Notice that the solution set must not contain duplicate triplets.",
        "example": "Example 1:\n\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0. nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0. The distinct triplets are [-1,0,1] and [-1,-1,2]. Notice that the order of the output and the order of the triplets does not matter.\n\nExample 2:\n\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\n\nExample 3:\n\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.",
        "level": "Medium",
        "tags": [
            "Array",
            "Two Pointers"
        ],
        "test_cases": {
            "inputs": [
                [
                    -1,
                    0,
                    1,
                    2,
                    -1,
                    -4
                ],
                [
                    0,
                    1,
                    1
                ],
                [
                    0,
                    0,
                    0
                ],
                [
                    -2,
                    0,
                    1,
                    1,
                    2
                ],
                [
                    1,
                    2,
                    -2,
                    -1
                ],
                [
                    3,
                    0,
                    -2,
                    -1,
                    1,
                    2
                ],
                [
                    -1,
                    -1,
                    -1,
                    0,
                    0,
                    0,
                    1,
                    1,
                    1
                ],
                [
                    -1,
                    0,
                    1,
                    2,
                    -1,
                    -4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ]
            ],
            "outputs": [
                "[[-1,-1,2],[-1,0,1]]",
                "[]",
                "[[0,0,0]]",
                "[[-2,0,2],[-2,1,1]]",
                "[[-2,-1,3],[-2,0,2],[-1,0,1]]",
                "[[-2,-1,3],[-2,0,2],[-1,0,1]]",
                "[[-1,-1,2],[-1,0,1],[0,0,0]]",
                "[[-1,-1,2],[-1,0,1],[0,0,0]]",
                "[]",
                "[]",
                "[[0,0,0]]",
                "[]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> threeSum(std::vector<int>& nums) {\n    std::vector<std::vector<int>> result;\n    std::sort(nums.begin(), nums.end());\n\n    for (int i = 0; i < (int)nums.size() - 2; ++i) {\n        if (i == 0 || nums[i] != nums[i - 1]) {\n            int j = i + 1, k = nums.size() - 1;\n            while (j < k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                if (sum == 0) {\n                    result.push_back({nums[i], nums[j], nums[k]});\n                    while (j < k && nums[j] == nums[j + 1]) ++j;\n                    while (j < k && nums[k] == nums[k - 1]) --k;\n                    ++j;\n                    --k;\n                } else if (sum < 0) {\n                    ++j;\n                } else {\n                    --k;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n",
            "java": "import java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> threeSum(int[] nums) {\n    Arrays.sort(nums);\n    List<List<Integer>> result = new ArrayList<>();\n\n    for (int i = 0; i < nums.length - 2; i++) {\n        if (i == 0 || nums[i] != nums[i - 1]) {\n            int j = i + 1, k = nums.length - 1;\n            while (j < k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                if (sum == 0) {\n                    result.add(Arrays.asList(nums[i], nums[j], nums[k]));\n                    while (j < k && nums[j] == nums[j + 1]) j++;\n                    while (j < k && nums[k] == nums[k - 1]) k--;\n                    j++;\n                    k--;\n                } else if (sum < 0) {\n                    j++;\n                } else {\n                    k--;\n                }                    \n            }\n        }\n    }\n\n    return result;\n}\n",
            "python": "def threeSum(nums):\n    nums.sort()\n    result = []\n\n    for i in range(len(nums) - 2):\n        if i == 0 or nums[i] != nums[i - 1]:\n            j, k = i + 1, len(nums) - 1\n            while j < k:\n                s = nums[i] + nums[j] + nums[k]\n                if s == 0:\n                    result.append([nums[i], nums[j], nums[k]])\n                    while j < k and nums[j] == nums[j + 1]:\n                        j += 1\n                    while j < k and nums[k] == nums[k - 1]:\n                        k -= 1\n                    j += 1\n                    k -= 1\n                elif s < 0:\n                    j += 1\n                else:\n                    k -= 1\n\n    return result\n",
            "javascript": "function threeSum(nums) {\n    nums.sort((a, b) => a - b);\n    const result = [];\n\n    for (let i = 0; i < nums.length - 2; i++) {\n        if (i == 0 || nums[i] != nums[i - 1]) {\n            let j = i + 1, k = nums.length - 1;\n            while (j < k) {\n                const sum = nums[i] + nums[j] + nums[k];\n                if (sum === 0) {\n                    result.push([nums[i], nums[j], nums[k]]);\n                    while (j < k && nums[j] === nums[j + 1]) j++;\n                    while (j < k && nums[k] === nums[k - 1]) k--;\n                    j++;\n                    k--;\n                } else if (sum < 0) {\n                    j++;\n                } else {\n                    k--;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n",
            "explanation": "1. Sort the input array `nums`.\n2. Loop through `nums` from index `0` to `length - 2`. Let the current index be `i`.\n    - If `i` is `0` or `nums[i]` is not equal to the previous element (`nums[i - 1]`), perform the following steps:\n        - Initialize two pointers `j` and `k`, where `j` is the next index after `i`, and `k` is the last index of `nums`.\n        - While `j` is less than `k`, perform the following steps:\n            - Calculate the sum `s` of the elements at indices `i`, `j`, and `k`.\n            - If the sum `s` is equal to `0`, then we've found a valid triplet. Add it to the `result` array and move the pointers, `j` and `k`, skipping duplicates if any.\n            - If the sum `s` is less than `0`, increment `j` to move towards positive values.\n            - If the sum `s` is greater than `0`, decrement `k` to move towards negative values.\n3. Return the `result` array.\n\nThe algorithm removes duplicates by checking if the current numbers being processed are equal to previously processed numbers. The sorting step helps in simplifying the algorithm and reducing the search space."
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> threeSum(std::vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> threeSum(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def threeSum(nums):\n    # Your code here\n\n",
            "javascript": "function threeSum(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> threeSum(std::vector<int>& nums) {\n    std::vector<std::vector<int>> result;\n    std::sort(nums.begin(), nums.end());\n\n    for (int i = 0; i < (int)nums.size() - 2; ++i) {\n        if (i == 0 || nums[i] != nums[i - 1]) {\n            int j = i + 1, k = nums.size() - 1;\n            while (j < k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                if (sum == 0) {\n                    result.push_back({nums[i], nums[j], nums[k]});\n                    while (j < k && nums[j] == nums[j + 1]) ++j;\n                    while (j < k && nums[k] == nums[k - 1]) --k;\n                    ++j;\n                    --k;\n                } else if (sum < 0) {\n                    ++j;\n                } else {\n                    --k;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    std::vector<int> nums = $args;\n    std::vector<std::vector<int>> result = threeSum(nums);\n\n    for (const auto& triplet : result) {\n        for (const auto& num : triplet) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = threeSum(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = threeSum(nums);\n\n    for (const triplet of result) {\n        console.log(triplet.join(' '));\n    }\n}\n",
            "java": "public static void main(String[] args) {\n    int[] nums = $args;\n    List<List<Integer>> result = threeSum(nums);\n\n    for (List<Integer> triplet : result) {\n        for (int num : triplet) {\n            System.out.print(num + \" \");\n        }\n        System.out.println();\n    }\n}"
        },
        "Qid": "15",
        "languages verified": [
            "python"
        ]
    },
    {
        "_id": {
            "$oid": "661d1833cb4648900af0609f"
        },
        "title": "Closest Three Sum",
        "description": "Given an integer array `nums` of length `n` and an integer `target`, find three integers in `nums` such that the sum is closest to `target`. Return the sum of the three integers. You may assume that each input would have exactly one solution.",
        "example": "Example:\n\nInput: nums = [-1,2,1,-4], target = 1\nOutput: 2\nExplanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).",
        "level": "Medium",
        "tags": [
            "Array",
            "Two Pointers"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        -1,
                        2,
                        1,
                        -4
                    ],
                    1
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    10
                ],
                [
                    [
                        -10,
                        -5,
                        0,
                        5,
                        10
                    ],
                    0
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    3
                ],
                [
                    [
                        -1,
                        -2,
                        -3,
                        -4,
                        -5
                    ],
                    -10
                ],
                [
                    [
                        10,
                        20,
                        30,
                        40,
                        50
                    ],
                    100
                ],
                [
                    [
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    5
                ],
                [
                    [
                        -1,
                        -1,
                        -1,
                        -1,
                        -1
                    ],
                    -3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    -10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    15
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    6
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    7
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    8
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    9
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    11
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    12
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    13
                ]
            ],
            "outputs": [
                2,
                0,
                9,
                0,
                3,
                -9,
                60,
                0,
                -3,
                3,
                15,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                6
            ]
        },
        "sample_code": {
            "c++": "#include <algorithm>\n#include <vector>\n\nint threeSumClosest(std::vector<int>& nums, int target) {\n    std::sort(nums.begin(), nums.end());\n    int closest = nums[0] + nums[1] + nums[2];\n    for (int i = 0; i < nums.size() - 2; ++i) {\n        int left = i + 1;\n        int right = nums.size() - 1;\n        while (left < right) {\n            int sum = nums[i] + nums[left] + nums[right];\n            if (sum == target) {\n                return sum;\n            }\n            if (abs(target - sum) < abs(target - closest)) {\n                closest = sum;\n            }\n            if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return closest;\n}\n",
            "java": "import java.util.Arrays;\n\npublic int threeSumClosest(int[] nums, int target) {\n    Arrays.sort(nums);\n    int closest = nums[0] + nums[1] + nums[2];\n    for (int i = 0; i < nums.length - 2; ++i) {\n        int left = i + 1;\n        int right = nums.length - 1;\n        while (left < right) {\n            int sum = nums[i] + nums[left] + nums[right];\n            if (sum == target) {\n                return sum;\n            }\n            if (Math.abs(target - sum) < Math.abs(target - closest)) {\n                closest = sum;\n            }\n            if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return closest;\n}\n",
            "python": "def threeSumClosest(nums, target):\n    nums.sort()\n    closest = sum(nums[:3])\n    for i in range(len(nums) - 2):\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            cur_sum = nums[i] + nums[left] + nums[right]\n            if cur_sum == target:\n                return cur_sum\n            if abs(target - cur_sum) < abs(target - closest):\n                closest = cur_sum\n            if cur_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return closest\n",
            "javascript": "function threeSumClosest(nums, target) {\n    nums.sort((a, b) => a - b);\n    let closest = nums[0] + nums[1] + nums[2];\n    for (let i = 0; i < nums.length - 2; ++i) {\n        let left = i + 1;\n        let right = nums.length - 1;\n        while (left < right) {\n            let sum = nums[i] + nums[left] + nums[right];\n            if (sum === target) {\n                return sum;\n            }\n            if (Math.abs(target - sum) < Math.abs(target - closest)) {\n                closest = sum;\n            }\n            if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return closest;\n}\n",
            "explanation": "1. Sort the input array `nums`.\n2. Initialize the `closest` variable to be the sum of the first three elements.\n3. Iterate through the sorted array with a pointer `i` running from the first element to the third-to-last element.\n4. Initialize two-pointers `left` (set to `i + 1`) and `right` (set to the last element).\n5. While `left` is less than `right`:\n    a. Calculate the current sum `cur_sum` using the elements at positions `i`, `left`, and `right`.\n    b. If `cur_sum` is equal to `target`, return it as the closest sum.\n    c. Update the `closest` sum if the difference between `target` and `cur_sum` is less than the difference between `target` and `closest`.\n    d. Move the `left` pointer forward if `cur_sum` is less than `target`, otherwise move the `right` pointer backward.\n6. Return the `closest` sum found."
        },
        "structure": {
            "c++": "#include <algorithm>\n#include <vector>\n\nint threeSumClosest(std::vector<int>& nums, int target)  {\n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\n\npublic int threeSumClosest(int[] nums, int target)  {\n    // Your code here\n}\n",
            "python": "def threeSumClosest(nums, target):\n    # Your code here\n\n",
            "javascript": "function threeSumClosest(nums, target)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\n\nint threeSumClosest(std::vector<int>& nums, int target);\n\nint main() {\n    std::vector<int> nums = $args;\n    int target = 0;\n    int result = threeSumClosest(nums, target);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "python": "if __name__ == \"__main__\":\n    inputs = $args\n    nums = inputs[0]\n    target = inputs[1]\n    result = threeSumClosest(nums, target)\n    print(result)",
            "javascript": "function main() {\n    const inputs =$args;\n    const nums = inputs[0];\n    const target = inputs[1];\n    const result = threeSumClosest(nums, target);\n    console.log(result);\n}\n",
            "java": ""
        },
        "Qid": "16",
        "languages verified": [
            "python"
        ]
    },
    {
        "_id": {
            "$oid": "661d1833cb4648900af060a0"
        },
        "title": "Letter Combinations of a Phone Number",
        "description": "Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.\n\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.",
        "example": "Example:\n\n**Input:** digits = \"23\"\n**Output:** [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]\n\n**Input:** digits = \"\"\n**Output:** []\n\n**Input:** digits = \"2\"\n**Output:** [\"a\", \"b\", \"c\"]",
        "level": "Medium",
        "tags": [
            "String",
            "Recursion",
            "Backtracking"
        ],
        "test_cases": {
            "inputs": [
                "\"23\"",
                "\"\"",
                "\"2\"",
                "\"234\"",
                "\"567\"",
                "\"89\"",
                "\"999\"",
                "\"7777\"",
                "\"2222\"",
                "\"3333\"",
                "\"4444\"",
                "\"5555\"",
                "\"6666\"",
                "\"8888\"",
                "\"9999\"",
                "\"222\"",
                "\"333\"",
                "\"444\"",
                "\"555\"",
                "\"666\"",
                "\"777\"",
                "\"888\"",
                "\"999\"",
                "\"2222\"",
                "\"3333\"",
                "\"4444\"",
                "\"5555\"",
                "\"6666\"",
                "\"7777\"",
                "\"8888\"",
                "\"9999\""
            ],
            "outputs": [
                "[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]",
                "[]",
                "[\"a\", \"b\", \"c\"]",
                "[\"adg\", \"adh\", \"adi\", \"aeg\", \"aeh\", \"aei\", \"afg\", \"afh\", \"afi\", \"bdg\", \"bdh\", \"bdi\", \"beg\", \"beh\", \"bei\", \"bfg\", \"bfh\", \"bfi\", \"cdg\", \"cdh\", \"cdi\", \"ceg\", \"ceh\", \"cei\", \"cfg\", \"cfh\", \"cfi\"]",
                "[\"jm\", \"jn\", \"jo\", \"km\", \"kn\", \"ko\", \"lm\", \"ln\", \"lo\"]",
                "[\"tw\", \"tx\", \"ty\", \"uw\", \"ux\", \"uy\", \"vw\", \"vx\", \"vy\"]",
                "[\"w\", \"x\", \"y\", \"z\"]",
                "[\"aa\", \"ab\", \"ac\", \"ba\", \"bb\", \"bc\", \"ca\", \"cb\", \"cc\"]",
                "[\"aa\", \"ad\", \"ae\", \"af\", \"ba\", \"bd\", \"be\", \"bf\", \"ca\", \"cd\", \"ce\", \"cf\"]",
                "[\"dd\", \"de\", \"df\", \"ed\", \"ee\", \"ef\", \"fd\", \"fe\", \"ff\"]",
                "[\"gg\", \"gh\", \"gi\", \"hg\", \"hh\", \"hi\", \"ig\", \"ih\", \"ii\"]",
                "[\"jj\", \"jk\", \"jl\", \"kj\", \"kk\", \"kl\", \"lj\", \"lk\", \"ll\"]",
                "[\"pp\", \"pq\", \"pr\", \"ps\", \"qp\", \"qq\", \"qr\", \"qs\", \"rp\", \"rq\", \"rr\", \"rs\", \"sp\", \"sq\", \"sr\", \"ss\"]",
                "[\"tt\", \"tu\", \"tv\", \"ut\", \"uu\", \"uv\", \"vt\", \"vu\", \"vv\"]",
                "[\"ww\", \"wx\", \"wy\", \"wz\", \"xw\", \"xx\", \"xy\", \"xz\", \"yw\", \"yx\", \"yy\", \"yz\", \"zw\", \"zx\", \"zy\", \"zz\"]",
                "[\"aa\", \"ad\", \"ae\", \"af\", \"ba\", \"bd\", \"be\", \"bf\", \"ca\", \"cd\", \"ce\", \"cf\"]",
                "[\"dd\", \"de\", \"df\", \"ed\", \"ee\", \"ef\", \"fd\", \"fe\", \"ff\"]",
                "[\"gg\", \"gh\", \"gi\", \"hg\", \"hh\", \"hi\", \"ig\", \"ih\", \"ii\"]",
                "[\"jj\", \"jk\", \"jl\", \"kj\", \"kk\", \"kl\", \"lj\", \"lk\", \"ll\"]",
                "[\"pp\", \"pq\", \"pr\", \"ps\", \"qp\", \"qq\", \"qr\", \"qs\", \"rp\", \"rq\", \"rr\", \"rs\", \"sp\", \"sq\", \"sr\", \"ss\"]",
                "[\"tt\", \"tu\", \"tv\", \"ut\", \"uu\", \"uv\", \"vt\", \"vu\", \"vv\"]",
                "[\"ww\", \"wx\", \"wy\", \"wz\", \"xw\", \"xx\", \"xy\", \"xz\", \"yw\", \"yx\", \"yy\", \"yz\", \"zw\", \"zx\", \"zy\", \"zz\"]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <iostream> // Added for input/output operations\n\nusing namespace std;\n\nvector<string> letterCombinations(string digits) {\n    if(digits.empty()) return {};\n    vector<string> phone = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    vector<string> result = {\"\"};\n\n    for (char d : digits) {\n        vector<string> temp;\n        for (const string &s : result) {\n            for (char c : phone[d - '2']) {\n                temp.push_back(s + c);\n            }\n        }\n        result.swap(temp);\n    }\n    return result;\n}\n",
            "java": "public static List<String> letterCombinations(String digits) {\n    LinkedList<String> output = new LinkedList<>();\n    if(digits.isEmpty()) return output;\n    \n    String[] phone = new String[] {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    output.add(\"\");\n    \n    for(char d : digits.toCharArray()){\n        while(output.peek().length() == digits.indexOf(d)){\n            String perm = output.remove();\n            for(char c : phone[d - '2'].toCharArray()){\n                output.add(perm + c);\n            }\n        }\n    }\n    \n    return output;\n}\n",
            "python": "def letter_combinations(digits: str):\n    if not digits: return []\n    phone = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\n    result = [\"\"]\n\n    for digit in digits:\n        temp = []\n        for s in result:\n            for c in phone[int(digit) - 2]:\n                temp.append(s + c)\n        result = temp\n\n    return result\n",
            "javascript": "function letterCombinations(digits) {\n    if (digits.length === 0) return [];\n    \n    let phone = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];\n    let result = [\"\"];\n\n    for (let i = 0; i < digits.length; i++) {\n        let digit = digits[i];\n        let temp = [];\n\n        for (let s of result) {\n            for (let c of phone[digit - 2]) {\n                temp.push(s + c);\n            }\n        }\n\n        result = temp;\n    }\n\n    return result;\n}\n",
            "explanation": "The algorithm visits each digit from the given `digits` string one by one. For each digit, it appends all possible characters corresponding to that digit, in a breadth-first search manner. The current stage's results are saved in the `result` list (or `output` list in Java). A temporary list `temp` is used to store the combinations formed at each stage before replacing the `result` list. The phone buttons mapping is stored in the `phone` list/array."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> letterCombinations(string digits) {\n    // Your code here\n}\n",
            "java": "public List<String> letterCombinations(String digits) {\n    // Your code here\n}\n",
            "python": "def letter_combinations(digits: str):\n    # Your code here\n\n",
            "javascript": "function letterCombinations(digits) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    string digits = $args;\n    vector<string> result = letterCombinations(digits);\n    for (const string &s : result) {\n        cout << s << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n        String digits = $args;\n        List<String> results = letterCombinations(digits); // Get combinations\n        System.out.println(results); // Print the result as a list\n    }",
            "python": "if __name__ == \"__main__\":\n    digits = $args\n    result = letter_combinations(digits)\n    print(result)",
            "javascript": "function main() {\n    const digits = $args;\n    const result = letterCombinations(digits);\n    console.log(result);\n}\nmain();"
        },
        "Qid": "17",
        "languages verified": [
            "python",
            "javascript",
            "c++",
            "java"
        ]
    },
    {
        "_id": {
            "$oid": "661d1833cb4648900af060a1"
        },
        "title": "Remove Elements and Count",
        "description": "Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` in-place. The order of the elements may be changed. Then return the number of elements in `nums` which are not equal to `val`.\n\nConsider the number of elements in `nums` which are not equal to `val` be `k`, to get accepted, you need to do the following things:\n\n- Change the array `nums` such that the first `k` elements of `nums` contain the elements which are not equal to `val`. The remaining elements of `nums` are not important as well as the size of `nums`.\n- Return `k`.",
        "example": "Example:\n\nInput: nums = [3,2,2,3], val = 3\nOutput: 2\nExplanation: Your function should return k = 2, with the first two elements of nums being 2. It does not matter what you leave beyond the returned k (hence they are underscores).",
        "level": "Easy",
        "tags": [
            "array",
            "in-place"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        3,
                        2,
                        2,
                        3
                    ],
                    3
                ],
                [
                    [
                        0,
                        1,
                        2,
                        2,
                        3,
                        0,
                        4,
                        2
                    ],
                    2
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    6
                ],
                [
                    [
                        5,
                        5,
                        5,
                        5,
                        5,
                        5,
                        5,
                        5
                    ],
                    5
                ],
                [
                    [
                        2,
                        4,
                        6,
                        8,
                        10
                    ],
                    5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    0
                ],
                [
                    [],
                    0
                ]
            ],
            "outputs": [
                "2",
                "5",
                "0",
                "0",
                "5",
                "10",
                "0"
            ]
        },
        "sample_code": {
            "c++": "int removeElement(vector<int>& nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.size(); j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n",
            "java": "public int removeElement(int[] nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.length; j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n",
            "python": "def removeElement(nums, val):\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != val:\n            nums[i] = nums[j]\n            i += 1\n    return i\n",
            "javascript": "function removeElement(nums, val) {\n    let i = 0;\n    for (let j = 0; j < nums.length; j++) {\n        if (nums[j] !== val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n",
            "explanation": "The algorithm uses two pointers approach. The pointer `i` maintains the position where the next non-val element should be placed, and pointer `j` iterates through the array. If the element at `j` is not equal to `val`, we place it at the position `i` and increment the `i` pointer. The loop continues until we have checked all the elements in the array. The `i` pointer will give us the count of elements that are not equal to `val`, which is the result. Thus, we return the value of `i` as the final result.\n\nThe time complexity of this algorithm is O(n), where n is the number of elements in the array, as we only iterate through the array once. The space complexity is O(1) since we do not use any extra memory. We modify the input array in-place."
        },
        "structure": {
            "c++": "int removeElement(vector<int>& nums, int val)  {\n    // Your code here\n}\n",
            "java": "public int removeElement(int[] nums, int val)  {\n    // Your code here\n}\n",
            "python": "def removeElement(nums, val):\n    # Your code here\n\n",
            "javascript": "function removeElement(nums, val)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "python": "if __name__ == \"__main__\":\n    inputs = $args\n    nums = inputs[0]\n    val = inputs[1]\n    result =removeElement(nums, val)\n    print(result)",
            "c++": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint removeElement(vector<int>& nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.size(); j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n\nint main() {\n    vector<int> nums = $args;\n    int val = 5;\n    int result = removeElement(nums, val);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    int[] nums = {1, 2, 3, 4, 5};\n    int val = 3;\n    int result = removeElement(nums, val);\n    System.out.println(result);\n}",
            "javascript": "function main() {\n    const inputs = $args;\n    const nums = inputs[0];\n    const val = inputs[1];\n    const result = removeElement(nums, val);\n    console.log(result);\n}\n"
        },
        "Qid": "27",
        "languages verified": [
            "python"
        ]
    },
    {
        "_id": {
            "$oid": "661d1833cb4648900af060a2"
        },
        "title": "Integer Division without Using Multiplication, Division, and Mod Operator",
        "description": "Given two integers `dividend` and `divisor`, divide two integers without using multiplication, division, and mod operator. The integer division should truncate toward zero, which means losing its fractional part. Return the quotient after dividing `dividend` by `divisor`. If the quotient is greater than 231 - 1, return 231 - 1. If the quotient is less than -231, return -231.",
        "example": "Example:\n\nInput: dividend = 10, divisor = 3\nOutput: 3\nExplanation: 10/3 = 3.33333.. which is truncated to 3.",
        "level": "Medium",
        "tags": [
            "Math",
            "Bit Manipulation"
        ],
        "test_cases": {
            "inputs": [
                [
                    10,
                    3
                ],
                [
                    7,
                    -3
                ],
                [
                    0,
                    1
                ],
                [
                    1,
                    1
                ],
                [
                    100,
                    10
                ],
                [
                    100,
                    -10
                ],
                [
                    123456789,
                    987654321
                ],
                [
                    -123456789,
                    987654321
                ],
                [
                    2147483647,
                    1
                ],
                [
                    2147483647,
                    -1
                ],
                [
                    -2147483648,
                    1
                ],
                [
                    -2147483648,
                    -1
                ],
                [
                    2147483647,
                    2
                ],
                [
                    2147483647,
                    -2
                ],
                [
                    -2147483648,
                    2
                ],
                [
                    -2147483648,
                    -2
                ],
                [
                    2147483647,
                    2147483647
                ],
                [
                    2147483647,
                    -2147483647
                ],
                [
                    -2147483648,
                    2147483647
                ],
                [
                    -2147483648,
                    -2147483647
                ]
            ],
            "outputs": [
                3,
                -2,
                0,
                1,
                10,
                -10,
                0,
                0,
                2147483647,
                -2147483648,
                -2147483648,
                2147483647,
                1073741823,
                -1073741824,
                -1073741824,
                1073741823,
                1,
                -1,
                -1,
                1
            ]
        },
        "sample_code": {
            "c++": "int divide(int dividend, int divisor) {\n    if (dividend == INT_MIN && divisor == -1) {\n        return INT_MAX;\n    }\n\n    int sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n\n    long long dvd = labs(dividend);\n    long long dvs = labs(divisor);\n    int ans = 0;\n\n    while (dvd >= dvs) {\n        long long temp = dvs, multiple = 1;\n        while (dvd >= (temp << 1)) {\n            temp <<= 1;\n            multiple <<= 1;\n        }\n        dvd -= temp;\n        ans += multiple;\n    }\n\n    return ans * sign;\n}\n",
            "java": "public int divide(int dividend, int divisor) {\n    if (dividend == Integer.MIN_VALUE && divisor == -1) {\n        return Integer.MAX_VALUE;\n    }\n\n    int sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n\n    long dvd = Math.abs((long) dividend);\n    long dvs = Math.abs((long) divisor);\n    int ans = 0;\n\n    while (dvd >= dvs) {\n        long temp = dvs, multiple = 1;\n        while (dvd >= (temp << 1)) {\n            temp <<= 1;\n            multiple <<= 1;\n        }\n        dvd -= temp;\n        ans += multiple;\n    }\n\n    return ans * sign;\n}\n",
            "python": "def divide(dividend: int, divisor: int) -> int:\n    if dividend == -(2**31) and divisor == -1:\n        return 2**31 - 1\n\n    sign = -1 if (dividend > 0) ^ (divisor > 0) else 1\n\n    dvd = abs(dividend)\n    dvs = abs(divisor)\n    ans = 0\n\n    while dvd >= dvs:\n        temp = dvs\n        multiple = 1\n        while dvd >= (temp << 1):\n            temp <<= 1\n            multiple <<= 1\n        dvd -= temp\n        ans += multiple\n\n    return ans * sign\n",
            "javascript": "function divide(dividend, divisor) {\n    if (dividend === -Math.pow(2, 31) && divisor === -1) {\n        return Math.pow(2, 31) - 1;\n    }\n\n    const sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n\n    let dvd = Math.abs(dividend);\n    let dvs = Math.abs(divisor);\n    let ans = 0;\n\n    while (dvd >= dvs) {\n        let temp = dvs;\n        let multiple = 1;\n        while (dvd >= (temp << 1)) {\n            temp <<= 1;\n            multiple <<= 1;\n        }\n        dvd -= temp;\n        ans += multiple;\n    }\n\n    return ans * sign;\n}\n",
            "explanation": "1. First, we handle the edge case where dividend = -2^31 and divisor = -1. The result must be 2^31, but since it's out of the signed integer range, we should return 2^31 - 1.\n2. Calculate the sign of the result based on the signs of dividend and divisor.\n3. We use the bitwise shift operator to handle divisions by powers of 2. In each iteration, we initialize the temp variable as the absolute value of the divisor to calculate how many times it fits into the remaining dividend. We then use another loop to repeatedly double the temp variable (by bitwise left shift) and check if the dividend is still greater or equal. If so, we also double the 'multiple' value associated with temp, as that's the actual quotient in the current iteration.\n4. When the shifting loop exits, we subtract the current temp from dividend and accumulate the current multiple to our answer.\n5. Once the dividend is less than the divisor, we break the loop and return the signed quotient by multiplying the sign variable to our answer."
        },
        "structure": {
            "c++": "int divide(int dividend, int divisor)  {\n    // Your code here\n}\n",
            "java": "public int divide(int dividend, int divisor)  {\n    // Your code here\n}\n",
            "python": "def divide(dividend: int, divisor: int) -> int:\n    # Your code here\n\n",
            "javascript": "function divide(dividend, divisor)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <climits>\nusing namespace std;\n\nint divide(int dividend, int divisor) {\n    if (dividend == INT_MIN && divisor == -1) {\n        return INT_MAX;\n    }\n\n    int sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n\n    long long dvd = labs(dividend);\n    long long dvs = labs(divisor);\n    int ans = 0;\n\n    while (dvd >= dvs) {\n        long long temp = dvs, multiple = 1;\n        while (dvd >= (temp << 1)) {\n            temp <<= 1;\n            multiple <<= 1;\n        }\n        dvd -= temp;\n        ans += multiple;\n    }\n\n    return ans * sign;\n}\n\nint main() {\n    int dividend = $args;\n    int divisor = $args;\n    int result = divide(dividend, divisor);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static int divide(int dividend, int divisor) {\n    if (dividend == Integer.MIN_VALUE && divisor == -1) {\n        return Integer.MAX_VALUE;\n    }\n\n    int sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n\n    long dvd = Math.abs((long) dividend);\n    long dvs = Math.abs((long) divisor);\n    int ans = 0;\n\n    while (dvd >= dvs) {\n        long temp = dvs, multiple = 1;\n        while (dvd >= (temp << 1)) {\n            temp <<= 1;\n            multiple <<= 1;\n        }\n        dvd -= temp;\n        ans += multiple;\n    }\n\n    return ans * sign;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs = $args\n    dividend = inputs[0]\n    divisor = inputs[1]\n    result = divide(dividend, divisor)\n    print(result)",
            "javascript": "function main() {\n    const inputs = $args;\n    const dividend = inputs[0];\n    const divisor = inputs[1];\n    const result = divide(dividend, divisor);\n    console.log(result);\n}\n"
        },
        "Qid": "29",
        "languages verified": [
            "python"
        ]
    },
    {
        "_id": {
            "$oid": "661d1833cb4648900af060a3"
        },
        "title": "Concatenated Substring",
        "description": "You are given a string `s` and an array of strings `words`. All the strings of `words` are of the same length. A concatenated substring in `s` is a substring that contains all the strings of any permutation of `words` concatenated. Return the starting indices of all the concatenated substrings in `s`. You can return the answer in any order.",
        "example": "Example 1:\n\nInput: s = \"barfoothefoobarman\", words = [\"foo\", \"bar\"]\nOutput: [0, 9]\nExplanation: The substring starting at index 0 is \"barfoo\" which is the concatenation of [\"bar\", \"foo\"]. The substring starting at index 9 is \"foobar\" which is the concatenation of [\"foo\", \"bar\"].\n\nExample 2:\n\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\", \"good\", \"best\", \"word\"]\nOutput: []\nExplanation: There is no substring in s that is the concatenation of any permutation of words.\n\nExample 3:\n\nInput: s = \"barfoofoobarthefoobarman\", words = [\"bar\", \"foo\", \"the\"]\nOutput: [6, 9, 12]\nExplanation: The substring starting at index 6 is \"foobarthe\" which is the concatenation of [\"foo\", \"bar\", \"the\"]. The substring starting at index 9 is \"barthefoo\" which is the concatenation of [\"bar\", \"the\", \"foo\"]. The substring starting at index 12 is \"thefoobar\" which is the concatenation of [\"the\", \"foo\", \"bar\"].",
        "level": "Medium",
        "tags": [
            "String",
            "Array",
            "Permutation"
        ],
        "test_cases": {
            "inputs": [
                [
                    "barfoothefoobarman",
                    [
                        "foo",
                        "bar"
                    ]
                ],
                [
                    "wordgoodgoodgoodbestword",
                    [
                        "word",
                        "good",
                        "best",
                        "word"
                    ]
                ],
                [
                    "barfoofoobarthefoobarman",
                    [
                        "bar",
                        "foo",
                        "the"
                    ]
                ],
                [
                    "abcdefg",
                    [
                        "abc",
                        "def",
                        "g"
                    ]
                ],
                [
                    "hellohellohello",
                    [
                        "hello",
                        "hello"
                    ]
                ],
                [
                    "abcdabcdabcd",
                    [
                        "abcd",
                        "abcd",
                        "abcd"
                    ]
                ],
                [
                    "foobarfoobar",
                    [
                        "foo",
                        "bar"
                    ]
                ],
                [
                    "abcabcabc",
                    [
                        "abc",
                        "abc"
                    ]
                ],
                [
                    "xyzxyzxyz",
                    [
                        "xyz",
                        "xyz"
                    ]
                ],
                [
                    "aaaabbbbcccc",
                    [
                        "aaa",
                        "bbb",
                        "ccc"
                    ]
                ],
                [
                    "abcdefghijabcdefghijabcdefghij",
                    [
                        "abc",
                        "def",
                        "ghi",
                        "j"
                    ]
                ],
                [
                    "abcdefghijabcdefghijabcdefghij",
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jkl"
                    ]
                ],
                [
                    "abcdefghijabcdefghijabcdefghij",
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jklm"
                    ]
                ],
                [
                    "abcdefghijabcdefghijabcdefghij",
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jklmn"
                    ]
                ],
                [
                    "abcdefghijabcdefghijabcdefghij",
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jklmno"
                    ]
                ],
                [
                    "abcdefghijabcdefghijabcdefghij",
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jklmnop"
                    ]
                ],
                [
                    "abcdefghijabcdefghijabcdefghij",
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jklmnopq"
                    ]
                ],
                [
                    "abcdefghijabcdefghijabcdefghij",
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jklmnopqr"
                    ]
                ],
                [
                    "abcdefghijabcdefghijabcdefghij",
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jklmnopqrs"
                    ]
                ],
                [
                    "abcdefghijabcdefghijabcdefghij",
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jklmnopqrst"
                    ]
                ]
            ],
            "outputs": [
                [
                    0,
                    9
                ],
                [],
                [
                    6,
                    9,
                    12
                ],
                [
                    0
                ],
                [
                    0,
                    5
                ],
                [
                    0,
                    4,
                    8
                ],
                [
                    0,
                    3
                ],
                [
                    0,
                    3,
                    6
                ],
                [
                    0,
                    3,
                    6
                ],
                [
                    0,
                    4,
                    8
                ],
                [
                    0,
                    10,
                    20
                ],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                []
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<int> findSubstring(std::string s, std::vector<std::string>& words) {\n    if (s.empty() || words.empty()) return {};\n    \n    std::unordered_map<std::string, int> word_count;\n    for (const auto& word : words) {\n        ++word_count[word];\n    }\n    \n    int word_length = words[0].size();\n    int total_words = words.size();\n    int total_length = word_length * total_words;\n    std::vector<int> result;\n    \n    for (int i = 0; i <= (int)s.size() - total_length; ++i) {\n        std::unordered_map<std::string, int> temp_word_count;\n        for (int j = 0; j < total_words; ++j) {\n            std::string current_word = s.substr(i + j * word_length, word_length);\n            if (word_count.find(current_word) == word_count.end()) break;\n            ++temp_word_count[current_word];\n            if (temp_word_count[current_word] > word_count[current_word]) break;\n            if (j + 1 == total_words) result.push_back(i);\n        }\n    }\n    \n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<Integer> findSubstring(String s, String[] words) {\n    if (s == null || s.length() == 0 || words == null || words.length == 0) return new ArrayList<>();\n    \n    Map<String, Integer> word_count = new HashMap<>();\n    for (String word : words) {\n        word_count.put(word, word_count.getOrDefault(word, 0) + 1);\n    }\n    \n    int word_length = words[0].length();\n    int total_words = words.length;\n    int total_length = word_length * total_words;\n    List<Integer> result = new ArrayList<>();\n    \n    for (int i = 0; i <= s.length() - total_length; i++) {\n        Map<String, Integer> temp_word_count = new HashMap<>();\n        for (int j = 0; j < total_words; j++) {\n            String current_word = s.substring(i + j * word_length, i + (j + 1) * word_length);\n            if (!word_count.containsKey(current_word)) break;\n            temp_word_count.put(current_word, temp_word_count.getOrDefault(current_word, 0) + 1);\n            if (temp_word_count.get(current_word) > word_count.get(current_word)) break;\n            if (j + 1 == total_words) result.add(i);\n        }\n    }\n    \n    return result;\n}\n",
            "python": "from collections import Counter\n\ndef findSubstring(s, words):\n    if not s or not words:\n        return []\n\n    word_count = Counter(words)\n    word_length = len(words[0])\n    total_words = len(words)\n    total_length = word_length * total_words\n    result = []\n\n    for i in range(len(s) - total_length + 1):\n        temp_word_count = Counter()\n        for j in range(total_words):\n            current_word = s[i + j * word_length:i + (j + 1) * word_length]\n            if current_word not in word_count:\n                break\n            temp_word_count[current_word] += 1\n            if temp_word_count[current_word] > word_count[current_word]:\n                break\n            if j + 1 == total_words:\n                result.append(i)\n\n    return result\n",
            "javascript": "function findSubstring(s, words) {\n    if (!s || !words || words.length === 0) return [];\n\n    const word_count = new Map();\n    for (const word of words) {\n        word_count.set(word, (word_count.get(word) || 0) + 1);\n    }\n\n    const word_length = words[0].length;\n    const total_words = words.length;\n    const total_length = word_length * total_words;\n    const result = [];\n\n    for (let i = 0; i <= s.length - total_length; i++) {\n        const temp_word_count = new Map();\n        for (let j = 0; j < total_words; j++) {\n            const current_word = s.substr(i + j * word_length, word_length);\n            if (!word_count.has(current_word)) break;\n            temp_word_count.set(current_word, (temp_word_count.get(current_word) || 0) + 1);\n            if (temp_word_count.get(current_word) > word_count.get(current_word)) break;\n            if (j + 1 === total_words) result.push(i);\n        }\n    }\n\n    return result;\n}\n",
            "explanation": "1. If the input string `s` or `words` array is empty, return an empty list.\n2. Create a hashmap `word_count` to store the count of each word present in the `words` array.\n3. Get the length of a single word, the total number of words, and the total length of the concatenated string.\n4. Iterate through the string `s` with an index `i`, starting from 0 and up to `s.size() - total_length`.\n5. For each index `i`, create a temporary hashmap `temp_word_count`, and iterate through the words starting from index `j` to `total_words - 1`.\n6. Extract the current word from the substring with the starting position `(i + j * word_length)`, and length `word_length`.\n7. Look for the current word in the hashmap `word_count`. If it's not present, break the loop and check the next index.\n8. Add the current word to the temporary hashmap `temp_word_count`. If the word's count in `temp_word_count` exceeds the count in `word_count`, break the loop.\n9. If all words are present in the substring and satisfy the required counts, add the current index `i` to the result list.\n10. Return the result list after processing all indices."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<int> findSubstring(std::string s, std::vector<std::string>& words)  {\n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<Integer> findSubstring(String s, String[] words)  {\n    // Your code here\n}\n",
            "python": "from collections import Counter\n    # Your code here\n\n",
            "javascript": "function findSubstring(s, words)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<int> findSubstring(std::string s, std::vector<std::string>& words);\n\nint main() {\n    std::string s = $args;\n    std::vector<std::string> words = {\"word1\", \"word2\", \"word3\"}; // Replace with actual words\n    std::vector<int> result = findSubstring(s, words);\n    \n    for (int i : result) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}",
            "java": "public List<Integer> findSubstring(String s, String[] words) {\n    if (s == null || s.length() == 0 || words == null || words.length == 0) return new ArrayList<>();\n    \n    Map<String, Integer> word_count = new HashMap<>();\n    for (String word : words) {\n        word_count.put(word, word_count.getOrDefault(word, 0) + 1);\n    }\n    \n    int word_length = words[0].length();\n    int total_words = words.length;\n    int total_length = word_length * total_words;\n    List<Integer> result = new ArrayList<>();\n    \n    for (int i = 0; i <= s.length() - total_length; i++) {\n        Map<String, Integer> temp_word_count = new HashMap<>();\n        for (int j = 0; j < total_words; j++) {\n            String current_word = s.substring(i + j * word_length, i + (j + 1) * word_length);\n            if (!word_count.containsKey(current_word)) break;\n            temp_word_count.put(current_word, temp_word_count.getOrDefault(current_word, 0) + 1);\n            if (temp_word_count.get(current_word) > word_count.get(current_word)) break;\n            if (j + 1 == total_words) result.add(i);\n        }\n    }\n    \n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs = $args\n    s = inputs[0]\n    words =inputs[1]\n    print(findSubstring(s, words))",
            "javascript": "function main() {\n    const inputs = $args;\n    const s = inputs[0];\n    const words = inputs[1];\n    console.log(findSubstring(s, words));\n}\n"
        },
        "Qid": "30",
        "languages verified": [
            "python"
        ]
    },
    {
        "_id": {
            "$oid": "661d1ca0fa2a2d86b4aa31f0"
        },
        "title": "Reverse Integer",
        "description": "Given a signed 32-bit integer `x`, return `x` with its digits reversed. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-231, 231 - 1]`, then return `0`.\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).",
        "example": "Example 1:\n\nInput: x = 123\nOutput: 321\n\nExample 2:\n\nInput: x = -123\nOutput: -321\n\nExample 3:\n\nInput: x = 120\nOutput: 21",
        "level": "Easy",
        "tags": [
            "Math"
        ],
        "test_cases": {
            "inputs": [
                123,
                -123,
                120,
                0,
                1,
                -1,
                10,
                -10,
                100,
                -100,
                123456789,
                -123456789,
                2147483647,
                -2147483648,
                2147483646,
                -2147483647,
                1534236469,
                -2147483412,
                0,
                987654321
            ],
            "outputs": [
                321,
                -321,
                21,
                0,
                1,
                -1,
                1,
                -1,
                1,
                -1,
                987654321,
                -987654321,
                0,
                0,
                0,
                0,
                0,
                -2147483412,
                0,
                123456789
            ],
            "input_data_type": [
                "int"
            ],
            "output_data_type": [
                "int"
            ]
        },
        "sample_code": {
            "c++": "#include <limits>\n#include <iostream>\n#include <climits>\nusing namespace std;\n\nint reverse(int x) {\n    long long res = 0;\n    while (x != 0) {\n        res = res * 10 + x % 10;\n        x /= 10;\n    }\n    return (res < INT_MIN || res > INT_MAX) ? 0 : res;\n}\n",
            "java": "public static int reverse(int x) {\n    long res = 0;\n    while (x != 0) {\n        res = res * 10 + x % 10;\n        x /= 10;\n    }\n    return (res < Integer.MIN_VALUE || res > Integer.MAX_VALUE) ? 0 : (int)res;\n}\n",
            "python": "def reverse(x: int) -> int:\n    sign = -1 if x < 0 else 1\n    x = abs(x)\n    res = 0\n    while x:\n        res = res * 10 + x % 10\n        x //= 10\n    res *= sign\n    return res if -2**31 <= res <= 2**31 - 1 else 0\n",
            "javascript": "function reverse(x) {\n    let sign = x < 0 ? -1 : 1;\n    x = Math.abs(x);\n    let res = 0;\n    while (x !== 0) {\n        res = res * 10 + x % 10;\n        x = Math.floor(x / 10);\n    }\n    res *= sign;\n    return (res < -(2 ** 31) || res > 2 ** 31 - 1) ? 0 : res;\n}\n",
            "explanation": "The algorithm initializes `res` as 0. Then, we determine the sign of the input integer and take its absolute value. We use a while loop to iterate through each digit of `x` from right to left. In each iteration, we multiply the current `res` by 10 and add the last digit of `x` to it. The last digit of `x` is obtained by `x % 10`. After adding the last digit, we remove it from `x` by doing either `x /= 10` or `x //= 10`.\n\nAfter processing all the digits, we adjust `res` with the sign we computed earlier. Finally, we check if the reversed integer is within the 32-bit integer range. If it is, we return the result; otherwise, we return 0."
        },
        "structure": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint reverse(int x) {\n    // Your code here\n}\n",
            "java": "public static int reverse(int x) {\n    // Your code here\n}\n",
            "python": "def reverse(x: int) -> int:\n    # Your code here\n\n",
            "javascript": "function reverse(x) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n#include <climits>\nint main() {\n    int input = $args; \n    int reversed = reverse(input);\n    std::cout<< reversed << std::endl;\n    return 0; \n}",
            "java": "public static void main(String[] args) {\n    int x = $args;\n    int result = reverse(x);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    x = $args\n    result = reverse(x)\n    print(result)",
            "javascript": "function main() {\n  const s = $args;\n  const result = reverse(s);\n  console.log(result);\n}\nmain();"
        },
        "Qid": "7",
        "languages verified": [
            "python",
            "javascript",
            "c++"
        ]
    },
    {
        "_id": {
            "$oid": "661d1d97fa2a2d86b4aa31f1"
        },
        "title": "Next Permutation",
        "description": "Given an array of integers, find the next lexicographically greater permutation of the array. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). Implement the function `nextPermutation(nums: List[int]) -> None` to find the next permutation in place using constant extra memory.",
        "example": "Example:\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n\nExplanation: The next permutation of [1,2,3] is [1,3,2].\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n\nExplanation: The next permutation of [3,2,1] is [1,2,3].\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n\nExplanation: The next permutation of [1,1,5] is [1,5,1].",
        "level": "Medium",
        "tags": [
            "Array",
            "Sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3
                ],
                [
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4
                ],
                [
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    5,
                    4
                ],
                [
                    1,
                    2,
                    4,
                    3,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1,
                    0
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    5,
                    4,
                    0
                ],
                [
                    1,
                    2,
                    4,
                    3,
                    5,
                    0
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1,
                    0,
                    9
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    0,
                    9
                ],
                [
                    1,
                    2,
                    3,
                    5,
                    4,
                    0,
                    9
                ],
                [
                    1,
                    2,
                    4,
                    3,
                    5,
                    0,
                    9
                ]
            ],
            "outputs": [
                "[1,3,2]",
                "[1,2,3]",
                "[1,5,1]",
                "[1,2,4,3]",
                "[1,2,3,4]",
                "[1,1,1,1]",
                "[1,2,3,5,4]",
                "[1,2,3,5,4]",
                "[1,2,4,0,3,5]",
                "[1,2,4,5,3,0]",
                "[0,1,2,3,4,5]",
                "[0,1,2,3,4,5]",
                "[0,1,2,3,5,4]",
                "[0,1,2,3,5,4]",
                "[0,1,2,3,5,4]",
                "[0,1,2,3,5,4,9]",
                "[0,1,2,3,4,5,6,7,8,9]",
                "[0,1,2,3,5,4,9]",
                "[0,1,2,3,5,4,9]",
                "[0,1,2,3,5,4,9]"
            ]
        },
        "sample_code": {
            "c++": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid nextPermutation(vector<int>& nums) {\n    int n = nums.size(), k, l;\n    for (k = n - 2; k >= 0; k--) {\n        if (nums[k] < nums[k + 1]) break;\n    }\n    if (k < 0) {\n        reverse(nums.begin(), nums.end());\n    } else {\n        for (l = n - 1; l > k; l--) {\n            if (nums[l] > nums[k]) break;\n        }\n        swap(nums[k], nums[l]);\n        reverse(nums.begin() + k + 1, nums.end());\n    }\n}\n",
            "java": "public static void nextPermutation(int[] nums) {\n    int n = nums.length, k = n - 2, l;\n    while(k >= 0 && nums[k] >= nums[k + 1]) k--;\n\n    if(k < 0) {\n        Arrays.sort(nums);\n    } else {\n        for (l = n - 1; l > k; l--) {\n            if (nums[l] > nums[k]) break;\n        }\n        int temp = nums[k];\n        nums[k] = nums[l];\n        nums[l] = temp;\n        Arrays.sort(nums, k + 1, n);\n    }\n}\n",
            "python": "def nextPermutation(nums):\n    n, k = len(nums), -1\n    for i in range(n - 1, 0, -1):\n        if nums[i - 1] < nums[i]:\n            k = i - 1\n            break\n    if k == -1:\n        nums.reverse()\n    else:\n        l = 0\n        for i in range(n - 1, k, -1):\n            if nums[i] > nums[k]:\n                l = i\n                break\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k + 1:] = reversed(nums[k + 1:])\n    return nums\n",
            "javascript": "function nextPermutation(nums) {\n    let n = nums.length, k = n - 2, l;\n    while(k >= 0 && nums[k] >= nums[k + 1]) k--;\n\n    if(k < 0) {\n        nums.sort((a, b) => a - b);\n    } else {\n        for (l = n - 1; l > k; l--) {\n            if (nums[l] > nums[k]) break;\n        }\n        [nums[k], nums[l]] = [nums[l], nums[k]];\n        let tempArr = nums.slice(k + 1).sort((a, b) => a - b);\n        nums.splice(k + 1, n - k - 1, ...tempArr);\n    }\n}\n",
            "explanation": "We can solve this problem by following the steps below:\n\n1. Identify the largest index `k` such that `nums[k] < nums[k + 1]`. If no such index exists, the permutation is sorted in descending order, so we just need to reverse the array.\n2. Identify the largest index `l` greater than `k` such that `nums[k] < nums[l]`.\n3. Swap the value of `nums[k]` with that of `nums[l]`.\n4. Reverse the sub-array `nums[k + 1:]` which is guaranteed to be in non-increasing order.\n\nBy making these changes in place and only using constant extra memory, we obtain the next permutation of the array nums."
        },
        "structure": {
            "c++": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nvoid nextPermutation(vector<int>& nums) {\n    // Your code here\n}\n",
            "java": "public void nextPermutation(int[] nums) {\n    // Your code here\n}\n",
            "python": "def nextPermutation(nums):\n    # Your code here\n\n",
            "javascript": "function nextPermutation(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> nums = $args;\n    nextPermutation(nums);\n    std::cout << \"$sprouts@pankaj[\";\n    for (size_t i = 0; i < nums.size(); ++i) {\n        std::cout << nums[i];\n        if (i < nums.size() - 1) {\n            std::cout << \", \";  // Add comma and space between numbers\n        }\n    }\n    std::cout << \"]$sprouts@pankaj\" << std::endl;\n\n    return 0;\n}",
            "java": "public static void main(String[] args){\n        int[] nums = $args;\n        nextPermutation(nums);\n        System.out.print(\"$sprouts@pankaj[\");\n        for (int i = 0; i < nums.length; i++) {\n            System.out.print(nums[i]);\n            if (i < nums.length - 1) {\n                System.out.print(\",\");\n            }\n        }\n        System.out.println(\"]$sprouts@pankaj\");\n    }\n ",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    nextPermutation(nums)\n    print(\"$sprouts@pankaj\",nums,\"$sprouts@pankaj\")",
            "javascript": "function main() {\n    const nums = $args;\n    nextPermutation(nums);\n    console.log(\"$sprouts@pankaj\",nums,\"$sprouts@pankaj\"\n);\n}\nmain();"
        },
        "Qid": "31",
        "languages verified": [
            "python",
            "javascript",
            "c++",
            "java"
        ]
    },
    {
        "_id": {
            "$oid": "661d3b26949b33b6c4e2b085"
        },
        "title": "Search in Rotated Sorted Array",
        "description": "You are given an integer array `nums` sorted in ascending order (with **distinct** values). Prior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`. Given the array `nums` **after** the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or -1 if it is not in `nums`. You must write an algorithm with O(log n) runtime complexity.",
        "example": "Example:\n\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\n\nExplanation: The target element 0 is present at index 4 in the rotated sorted array.\n\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\n\nExplanation: The target element 3 is not present in the rotated sorted array.\n\nInput: nums = [1], target = 0\nOutput: -1\n\nExplanation: The target element 0 is not present in the rotated sorted array.",
        "level": "Medium",
        "tags": [
            "Array",
            "Binary Search"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        4,
                        5,
                        6,
                        7,
                        0,
                        1,
                        2
                    ],
                    0
                ],
                [
                    [
                        4,
                        5,
                        6,
                        7,
                        0,
                        1,
                        2
                    ],
                    3
                ],
                [
                    [
                        1
                    ],
                    0
                ],
                [
                    [
                        1,
                        3,
                        5
                    ],
                    1
                ],
                [
                    [
                        3,
                        5,
                        1
                    ],
                    1
                ],
                [
                    [
                        5,
                        1,
                        3
                    ],
                    1
                ],
                [
                    [
                        1,
                        3
                    ],
                    1
                ],
                [
                    [
                        3,
                        1
                    ],
                    1
                ],
                [
                    [
                        1
                    ],
                    1
                ]
            ],
            "outputs": [
                "4",
                "-1",
                "-1",
                "0",
                "2",
                "1",
                "0",
                "1",
                "-1"
            ]
        },
        "sample_code": {
            "c++": "int search(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        }\n        if (nums[mid] >= nums[left]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n",
            "java": "public int search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        }\n        if (nums[mid] >= nums[left]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n",
            "python": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] >= nums[left]:\n            if target >= nums[left] and target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if target > nums[mid] and target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return -1\n",
            "javascript": "function search(nums, target) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] === target) {\n            return mid;\n        }\n        if (nums[mid] >= nums[left]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n",
            "explanation": "The algorithm is a variation of binary search. The main idea is to decide whether the target is in the left or the right half of the current subarray. If nums[mid] >= nums[left], the left half is sorted. If target is in the range [nums[left], nums[mid]), set right = mid - 1. Otherwise, set left = mid + 1. If nums[mid] < nums[left], the right half must be sorted. If target is in the range (nums[mid], nums[right]], set left = mid + 1. Otherwise, set right = mid - 1. Continue the process until the target is found or the subarray is empty, in which case return -1. This algorithm has a runtime complexity of O(log n) because it eliminates half of the remaining elements at each step, similar to a binary search."
        },
        "structure": {
            "c++": "int search(vector<int>& nums, int target)  {\n    // Your code here\n}\n",
            "java": "public int search(int[] nums, int target)  {\n    // Your code here\n}\n",
            "python": "def search(nums, target):\n    # Your code here\n\n",
            "javascript": "function search(nums, target)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint search(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        }\n        if (nums[mid] >= nums[left]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    vector<int> nums = $args;\n    int target = $args;\n    int result = search(nums, target);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        }\n        if (nums[mid] >= nums[left]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs  = $args\n    nums = inputs[0]\n    target = inputs[1]\n    result = search(nums, target)\n    print(result)",
            "javascript": "function main() {\n    const inputs = $args;\n    const nums = inputs[0];\n    const target = inputs[1];\n    console.log(search(nums, target));\n}\nmain();"
        },
        "Qid": "33",
        "languages verified": [
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d3d1f949b33b6c4e2b086"
        },
        "title": "Search Insert Position",
        "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou must write an algorithm with O(log n) runtime complexity.",
        "example": "Example:\n\nInput: nums = [1,3,5,6], target = 5\nOutput: 2\n\nExplanation: The target value 5 is found at index 2 in the given array.\n\nInput: nums = [1,3,5,6], target = 2\nOutput: 1\n\nExplanation: The target value 2 is not found in the given array. If it were to be inserted, it would be at index 1.\n\nInput: nums = [1,3,5,6], target = 7\nOutput: 4\n\nExplanation: The target value 7 is not found in the given array. If it were to be inserted, it would be at index 4.",
        "level": "Easy",
        "tags": [
            "Array",
            "Binary Search"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    5
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    2
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    7
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    0
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    4
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    6
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    3
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    1
                ],
                [
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    8
                ],
                [
                    [
                        [
                            1,
                            3,
                            5,
                            6
                        ],
                        -1
                    ]
                ],
                [
                    [
                        [
                            1,
                            3,
                            5,
                            6
                        ],
                        10
                    ]
                ],
                [
                    [
                        [
                            1,
                            3,
                            5,
                            6
                        ],
                        -5
                    ]
                ],
                [
                    [
                        [
                            1,
                            3,
                            5,
                            6,
                            8,
                            10
                        ],
                        5
                    ]
                ],
                [
                    [
                        [
                            1,
                            3,
                            5,
                            6,
                            8,
                            10
                        ],
                        2
                    ]
                ],
                [
                    [
                        [
                            1,
                            3,
                            5,
                            6,
                            8,
                            10
                        ],
                        7
                    ]
                ],
                [
                    [
                        [
                            1,
                            3,
                            5,
                            6,
                            8,
                            10
                        ],
                        0
                    ]
                ],
                [
                    [
                        [
                            1,
                            3,
                            5,
                            6,
                            8,
                            10
                        ],
                        4
                    ]
                ],
                [
                    [
                        [
                            1,
                            3,
                            5,
                            6,
                            8,
                            10
                        ],
                        6
                    ]
                ],
                [
                    [
                        [
                            1,
                            3,
                            5,
                            6,
                            8,
                            10
                        ],
                        3
                    ]
                ],
                [
                    [
                        [
                            1,
                            3,
                            5,
                            6,
                            8,
                            10
                        ],
                        1
                    ]
                ]
            ],
            "outputs": [
                "2",
                "1",
                "4",
                "0",
                "2",
                "3",
                "1",
                "0",
                "6",
                "0",
                "6",
                "0",
                "2",
                "1",
                "4",
                "0",
                "2",
                "3",
                "1",
                "0"
            ]
        },
        "sample_code": {
            "c++": "int searchInsert(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n}\n",
            "java": "public int searchInsert(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n}\n",
            "python": "def searchInsert(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left\n",
            "javascript": "function searchInsert(nums, target) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] === target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n}\n",
            "explanation": "The given problem requires a binary search algorithm. We define two pointers, `left` and `right`, initially set to the first and last index of the array. We then enter a loop that continues as long as left is less than or equal to right. Inside the loop, we calculate the middle index, `mid`, as the average of left and right. If the value at this middle index is equal to the target value, we return the middle index. If the middle value is less than the target value, we set left to `mid + 1`, meaning we search the right half of the remaining array. If the middle value is greater than the target value, we set the right to `mid - 1`, meaning we search the left half of the remaining array. After the loop, if the target value is not found, we return the value of the left pointer, which represents the index where the target value should be inserted."
        },
        "structure": {
            "c++": "int searchInsert(vector<int>& nums, int target)  {\n    // Your code here\n}\n",
            "java": "public int searchInsert(int[] nums, int target)  {\n    // Your code here\n}\n",
            "python": "def searchInsert(nums, target):\n    # Your code here\n\n",
            "javascript": "function searchInsert(nums, target)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint searchInsert(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n}\n\nint main() {\n    vector<int> nums = $args;\n    int target = $args;\n    int result = searchInsert(nums, target);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    int[] nums = {1, 3, 5, 6};\n    int target = 5;\n    int result = searchInsert(nums, target);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    inputs= $args\n    nums = inputs[0]\n    target = inputs[1]\n    result = searchInsert(nums, target)\n    print(result)",
            "javascript": "function main() {\n    const inputs = $args;\n    const nums = inputs[0];\n    const target = inputs[1];\n    console.log(searchInsert(nums, target));\n}\nmain();"
        },
        "Qid": "35",
        "languages verified": [
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d3d79949b33b6c4e2b087"
        },
        "title": "Sudoku Solver",
        "description": "Write a program to solve a Sudoku puzzle by filling the empty cells. A Sudoku solution must satisfy all of the following rules:\n\n1. Each of the digits `1-9` must occur exactly once in each row.\n2. Each of the digits `1-9` must occur exactly once in each column.\n3. Each of the digits `1-9` must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.\n\nThe '.' character indicates empty cells.",
        "example": "**Example:**\n\n**Input:**\nboard = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n]\n**Output:**\n[\n    [\"5\", \"3\", \"4\", \"6\", \"7\", \"8\", \"9\", \"1\", \"2\"],\n    [\"6\", \"7\", \"2\", \"1\", \"9\", \"5\", \"3\", \"4\", \"8\"],\n    [\"1\", \"9\", \"8\", \"3\", \"4\", \"2\", \"5\", \"6\", \"7\"],\n    [\"8\", \"5\", \"9\", \"7\", \"6\", \"1\", \"4\", \"2\", \"3\"],\n    [\"4\", \"2\", \"6\", \"8\", \"5\", \"3\", \"7\", \"9\", \"1\"],\n    [\"7\", \"1\", \"3\", \"9\", \"2\", \"4\", \"8\", \"5\", \"6\"],\n    [\"9\", \"6\", \"1\", \"5\", \"3\", \"7\", \"2\", \"8\", \"4\"],\n    [\"2\", \"8\", \"7\", \"4\", \"1\", \"9\", \"6\", \"3\", \"5\"],\n    [\"3\", \"4\", \"5\", \"2\", \"8\", \"6\", \"1\", \"7\", \"9\"]\n]\n**Explanation:** The input board is shown above and the only valid solution is shown below:",
        "level": "Medium",
        "tags": [
            "array",
            "backtracking"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "5",
                        "3",
                        ".",
                        ".",
                        "7",
                        ".",
                        ".",
                        ".",
                        "."
                    ],
                    [
                        "6",
                        ".",
                        ".",
                        "1",
                        "9",
                        "5",
                        ".",
                        ".",
                        "."
                    ],
                    [
                        ".",
                        "9",
                        "8",
                        ".",
                        ".",
                        ".",
                        ".",
                        "6",
                        "."
                    ],
                    [
                        "8",
                        ".",
                        ".",
                        ".",
                        "6",
                        ".",
                        ".",
                        ".",
                        "3"
                    ],
                    [
                        "4",
                        ".",
                        ".",
                        "8",
                        ".",
                        "3",
                        ".",
                        ".",
                        "1"
                    ],
                    [
                        "7",
                        ".",
                        ".",
                        ".",
                        "2",
                        ".",
                        ".",
                        ".",
                        "6"
                    ],
                    [
                        ".",
                        "6",
                        ".",
                        ".",
                        ".",
                        ".",
                        "2",
                        "8",
                        "."
                    ],
                    [
                        ".",
                        ".",
                        ".",
                        "4",
                        "1",
                        "9",
                        ".",
                        ".",
                        "5"
                    ],
                    [
                        ".",
                        ".",
                        ".",
                        ".",
                        "8",
                        ".",
                        ".",
                        "7",
                        "9"
                    ]
                ]
            ],
            "outputs": [
                "[[\"5\", \"3\", \"4\", \"6\", \"7\", \"8\", \"9\", \"1\", \"2\"],[\"6\", \"7\", \"2\", \"1\", \"9\", \"5\", \"3\", \"4\", \"8\"],[\"1\", \"9\", \"8\", \"3\", \"4\", \"2\", \"5\", \"6\", \"7\"],[\"8\", \"5\", \"9\", \"7\", \"6\", \"1\", \"4\", \"2\", \"3\"],[\"4\", \"2\", \"6\", \"8\", \"5\", \"3\", \"7\", \"9\", \"1\"],[\"7\", \"1\", \"3\", \"9\", \"2\", \"4\", \"8\", \"5\", \"6\"],[\"9\", \"6\", \"1\", \"5\", \"3\", \"7\", \"2\", \"8\", \"4\"],[\"2\", \"8\", \"7\", \"4\", \"1\", \"9\", \"6\", \"3\", \"5\"],[\"3\", \"4\", \"5\", \"2\", \"8\", \"6\", \"1\", \"7\", \"9\"]]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nbool isValid(vector<vector<char>>& board, int row, int col, char c) {\n    for (int i = 0; i < 9; i++) {\n        if (board[i][col] == c) return false; \n        if (board[row][i] == c) return false; \n        if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false; \n    }\n    return true;\n}\n\nbool solveSudokuHelper(vector<vector<char>>& board) {\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            if (board[i][j] == '.') {\n                for (char c = '1'; c <= '9'; c++) {\n                    if (isValid(board, i, j, c)) {\n                        board[i][j] = c;\n\n                        if (solveSudokuHelper(board))\n                            return true;\n\n                        board[i][j] = '.';\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid solveSudoku(vector<vector<char>>& board) {\n    solveSudokuHelper(board);\n}\n",
            "java": "import java.util.*;\n\nclass Solution {\n    public boolean isValid(char[][] board, int row, int col, char c) {\n        for (int i = 0; i < 9; i++) {\n            if (board[i][col] == c) return false;\n            if (board[row][i] == c) return false;\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false;\n        }\n        return true;\n    }\n\n    public boolean solveSudokuHelper(char[][] board) {\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if (board[i][j] == '.') {\n                    for (char c = '1'; c <= '9'; c++) {\n                        if (isValid(board, i, j, c)) {\n                            board[i][j] = c;\n\n                            if (solveSudokuHelper(board)) {\n                                return true;\n                            }\n\n                            board[i][j] = '.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void solveSudoku(char[][] board) {\n        solveSudokuHelper(board);\n    }\n}\n",
            "python": "def isValid(board, row, col, c):\n    for i in range(9):\n        if board[i][col] == c:\n            return False\n        if board[row][i] == c:\n            return False\n        if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == c:\n            return False\n    return True\n\ndef solveSudokuHelper(board):\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == '.':\n                for c in '123456789':\n                    if isValid(board, i, j, c):\n                        board[i][j] = c\n\n                        if solveSudokuHelper(board):\n                            return True\n\n                        board[i][j] = '.'\n                return False\n\n    return True\n\ndef solveSudoku(board):\n    solveSudokuHelper(board)\n",
            "javascript": "function isValid(board, row, col, c) {\n    for (let i = 0; i < 9; i++) {\n        if (board[i][col] === c) return false;\n        if (board[row][i] === c) return false;\n        if (board[3 * Math.floor(row / 3) + Math.floor(i / 3)][3 * Math.floor(col / 3) + i % 3] === c) return false;\n    }\n    return true;\n}\n\nfunction solveSudokuHelper(board) {\n    for (let i = 0; i < 9; i++) {\n        for (let j = 0; j < 9; j++) {\n            if (board[i][j] === '.') {\n                for (let c = 1; c <= 9; c++) {\n                    if (isValid(board, i, j, c.toString())) {\n                        board[i][j] = c.toString();\n\n                        if (solveSudokuHelper(board)) {\n                            return true;\n                        }\n\n                        board[i][j] = '.';\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nfunction solveSudoku(board) {\n    solveSudokuHelper(board);\n}\n",
            "explanation": "1. The algorithm starts by searching for an empty cell (denoted by '.').\n2. Once an empty cell is found, it tries to insert a number from 1 to 9.\n3. For each inserted number, it checks if its placement is valid based on Sudoku rules:\n   - The number must not be present in the same row or column.\n   - The number must not be present in its corresponding 3x3 grid.\n4. It calls itself (backtracks) recursively whenever a valid number is inserted into the cell.\n5. If inserting a number fails to lead to a valid solution, the algorithm reverts that cell to '.' and tries the next number.\n6. The process is repeated until a valid board is created or all possibilities have failed.\n7. Once an empty cell is not found, it considers the board solved and exits the process."
        },
        "structure": {
            "c++": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nbool isValid(vector<vector<char>>& board, int row, int col, char c)  {\n    // Your code here\n}\n",
            "java": "i {mport java.util.*;\n\nclass Solution \n    // Your code here\n}\n",
            "python": "def isValid(board, row, col, c):\n    # Your code here\n\n",
            "javascript": "function isValid(board, row, col, c)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nbool isValid(vector<vector<char>>& board, int row, int col, char c) {\n    for (int i = 0; i < 9; i++) {\n        if (board[i][col] == c) return false; \n        if (board[row][i] == c) return false; \n        if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false; \n    }\n    return true;\n}\n\nbool solveSudokuHelper(vector<vector<char>>& board) {\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            if (board[i][j] == '.') {\n                for (char c = '1'; c <= '9'; c++) {\n                    if (isValid(board, i, j, c)) {\n                        board[i][j] = c;\n\n                        if (solveSudokuHelper(board))\n                            return true;\n\n                        board[i][j] = '.';\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid solveSudoku(vector<vector<char>>& board) {\n    solveSudokuHelper(board);\n}\n\nint main() {\n    vector<vector<char>> board = $args;\n    solveSudoku(board);\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            cout << board[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n        int n = $args;\n        boolean result = isPowerOfFour(n);\n        System.out.println(result);\n    }\n",
            "python": "if __name__ == \"__main__\":\n    board = [['5', '3', '.', '.', '7', '.', '.', '.', '.'], ['6', '.', '.', '1', '9', '5', '.', '.', '.'], ['.', '9', '8', '.', '.', '.', '.', '6', '.'], ['8', '.', '.', '.', '6', '.', '.', '.', '3'], ['4', '.', '.', '8', '.', '3', '.', '.', '1'], ['7', '.', '.', '.', '2', '.', '.', '.', '6'], ['.', '6', '.', '.', '.', '.', '2', '8', '.'], ['.', '.', '.', '4', '1', '9', '.', '.', '5'], ['.', '.', '.', '.', '8', '.', '.', '7', '9']]\n    solveSudoku(board)\n    print(board)",
            "javascript": "function main() {\n    const board = $args;\n    solveSudoku(board);\n    for (let i = 0; i < 9; i++) {\n        console.log(board[i].join(' '));\n    }\n}\nmain();"
        },
        "Qid": "37",
        "languages verified": [
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d3e68949b33b6c4e2b088"
        },
        "title": "Count and Say Sequence",
        "description": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula. Given a positive integer n, return the nth term of the count-and-say sequence.",
        "example": "Example:\n\nInput: n = 4\nOutput: \"1211\"\nExplanation:\ncountAndSay(1) = \"1\"\ncountAndSay(2) = say \"1\" = one 1 = \"11\"\ncountAndSay(3) = say \"11\" = two 1's = \"21\"\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"",
        "level": "Easy",
        "tags": [
            "recursion",
            "string"
        ],
        "test_cases": {
            "inputs": [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                15,
                20,
                25,
                30
            ],
            "outputs": [
                "1",
                "11",
                "21",
                "1211",
                "111221",
                "312211",
                "13112221",
                "1113213211",
                "31131211131221",
                "13211311123113112211",
                "311311222113111231131112132112311321322112111312211312111322212311322113212221",
                "11131221131211131231121113112221121321132132211331222113112211",
                "311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111312211311123113322112111312211312111322212311322113212221",
                "111312211312111312311211131122211213211321322113312221131122111213122112311311222112111312211311123113322112111312211312111322212311322113212221"
            ],
            "input_data_type": [
                "int"
            ],
            "output_data_type": [
                "string"
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n\nstd::string countAndSay(int n) {\n    if (n == 1) return \"1\";\n    std::string previous = countAndSay(n-1);\n    std::string result = \"\";\n    int count = 1;\n    for (int i = 1; i < previous.length(); i++) {\n        if (previous[i] == previous[i-1]) {\n            count++;\n        } else {\n            result += std::to_string(count) + previous[i-1];\n            count = 1;\n        }\n    }\n    result += std::to_string(count) + previous.back();\n    return result;\n}\n",
            "java": "public static String countAndSay(int n) {\n    if (n == 1) return \"1\";\n    String previous = countAndSay(n-1);\n    StringBuilder result = new StringBuilder();\n    int count = 1;\n    for (int i = 1; i < previous.length(); i++) {\n        if (previous.charAt(i) == previous.charAt(i-1)) {\n            count++;\n        } else {\n            result.append(count).append(previous.charAt(i-1));\n            count = 1;\n        }\n    }\n    result.append(count).append(previous.charAt(previous.length()-1));\n    return result.toString();\n}\n",
            "python": "def count_and_say(n):\n    if n == 1:\n        return \"1\"\n    previous = count_and_say(n - 1)\n    result = []\n    count = 1\n    for i in range(1, len(previous)):\n        if previous[i] == previous[i - 1]:\n            count += 1\n        else:\n            result.append(str(count))\n            result.append(previous[i - 1])\n            count = 1\n    result.append(str(count))\n    result.append(previous[-1])\n    return \"\".join(result)\n",
            "javascript": "function countAndSay(n) {\n    if (n === 1) return \"1\";\n    let previous = countAndSay(n - 1);\n    let result = \"\";\n    let count = 1;\n    for (let i = 1; i < previous.length; i++) {\n        if (previous[i] === previous[i - 1]) {\n            count++;\n        } else {\n            result += count.toString() + previous[i - 1];\n            count = 1;\n        }\n    }\n    result += count.toString() + previous[previous.length - 1];\n    return result;\n}\n",
            "explanation": "The algorithm is a recursive solution. It starts with the base case, when `n` is 1, it returns the first term of the sequence \"1\". In other cases, it makes a recursive call to the function with `n-1` to get the previous term in the sequence. Then it iterates through the previous term, comparing each character with the previous one to count the number of consecutive equal digits. When it encounters a different character, it appends the count and the character to the result string and resets the count to 1. Finally, it appends the last count and character to the result string and returns it."
        },
        "structure": {
            "c++": "#include <string>\n\nstd::string countAndSay(int n) {\n    // Your code here\n}\n",
            "java": "public static String countAndSay(int n) {\n    // Your code here\n}\n",
            "python": "def count_and_say(n):\n    # Your code here\n\n",
            "javascript": "function countAndSay(n) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <string>\n\nint main() {\n    int n = $args;\n    std::string result = countAndSay(n);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    print(count_and_say(n))",
            "javascript": "function main() {\n    const n = $args;\n    const result = countAndSay(n);\n    console.log(result);\n}\nmain();",
            "java": "public static void main(String[] args){\n    int input = $args;\n    String result = countAndSay(input);\n    System.out.println(result);\n}"
        },
        "Qid": "38",
        "languages verified": [
            "c++",
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d3e8e949b33b6c4e2b089"
        },
        "title": "Smallest Missing Positive Integer",
        "description": "Given an unsorted integer array `nums`, find the smallest missing positive integer. Implement an algorithm that runs in `O(n)` time and uses constant extra space.",
        "example": "Example 1:\n\nInput: nums = [1,2,0]\nOutput: 3\nExplanation: The numbers in the range [1,2] are all in the array.\n\nExample 2:\n\nInput: nums = [3,4,-1,1]\nOutput: 2\nExplanation: 1 is in the array but 2 is missing.\n\nExample 3:\n\nInput: nums = [7,8,9,11,12]\nOutput: 1\nExplanation: The smallest positive integer 1 is missing.",
        "level": "Medium",
        "tags": [
            "Array",
            "Sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    0
                ],
                [
                    3,
                    4,
                    -1,
                    1
                ],
                [
                    7,
                    8,
                    9,
                    11,
                    12
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    2,
                    3,
                    4,
                    5
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    -1,
                    -2,
                    -3
                ],
                [
                    0
                ],
                [
                    -1
                ],
                [
                    1
                ],
                [
                    2
                ],
                [
                    3
                ],
                [
                    4
                ],
                [
                    5
                ],
                [
                    6
                ],
                [
                    7
                ],
                [
                    8
                ],
                [
                    9
                ],
                [
                    10
                ]
            ],
            "outputs": [
                3,
                2,
                1,
                6,
                6,
                1,
                1,
                1,
                1,
                1,
                2,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1
            ]
        },
        "sample_code": {
            "c++": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint firstMissingPositive(vector<int>& nums) {\n    int n = nums.size();\n    for(int i = 0; i < n; ++i)\n        while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])\n            swap(nums[i], nums[nums[i] - 1]);\n\n    for(int i = 0; i < n; ++i)\n        if(nums[i] != i + 1)\n            return i + 1;\n    return n + 1;\n}\n",
            "java": "public static int firstMissingPositive(int[] nums) {\n        int n = nums.length;\n        for(int i = 0; i < n; i++) {\n            while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {\n                int temp = nums[i];\n                nums[i] = nums[temp - 1];\n                nums[temp - 1] = temp;\n            }\n        }\n\n        for(int i = 0; i < n; i++) {\n            if(nums[i] != i + 1) {\n                return i + 1;\n            }\n        }\n        return n + 1;\n    }\n",
            "python": "def firstMissingPositive(nums):\n    n = len(nums)\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    return n + 1\n",
            "javascript": "function firstMissingPositive(nums) {\n    let n = nums.length;\n    for(let i = 0; i < n; i++) {\n        while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] !== nums[i]) {\n            let temp = nums[i];\n            nums[i] = nums[temp - 1];\n            nums[temp - 1] = temp;\n        }\n    }\n\n    for(let i = 0; i < n; i++) {\n        if(nums[i] !== i + 1) {\n            return i + 1;\n        }\n    }\n    return n + 1;\n}\n",
            "explanation": "In this algorithm, the elements are swapped with the values at their correct index if they are positive, in range, and not equal to the value already at that index. After the first loop, the array will have correct values at correct indices where possible (1-based), so we just need to find the index `i` where `nums[i] != i+1`. If not found, return the next positive integer `n + 1`. The loop has O(n) complexity, because each time at least one element gets placed at its correct position, so we need a max of n iterations on average."
        },
        "structure": {
            "c++": "int firstMissingPositive(vector<int>& nums) {\n    // Your code here\n}\n",
            "java": "public static int firstMissingPositive(int[] nums) {\n    // Your code here\n}\n",
            "python": "def firstMissingPositive(nums):\n    # Your code here\n\n",
            "javascript": "function firstMissingPositive(nums) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> nums = $args;\n    int result = firstMissingPositive(nums);\n    std::cout <<\"$sprouts@pankaj\"<<result<<\"$sprouts@pankaj\";\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n        int[] nums = $args;\n        int result = firstMissingPositive(nums);\n        System.out.println(\"$sprouts@pankaj\" + result + \"$sprouts@pankaj\");\n    }\n",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = firstMissingPositive(nums)\n    print(\"$sprouts@pankaj\",result,\"$sprouts@pankaj\"\n)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = firstMissingPositive(nums);\n    console.log(\"$sprouts@pankaj\",result,\"$sprouts@pankaj\"\n);\n}\nmain();"
        },
        "Qid": "41",
        "languages verified": [
            "python",
            "javascript",
            "c++",
            "java"
        ]
    },
    {
        "_id": {
            "$oid": "661d3ebc949b33b6c4e2b08a"
        },
        "title": "Trapping Rain Water",
        "description": "Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.",
        "example": "Example:\n\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.",
        "level": "Medium",
        "tags": [
            "array",
            "two pointers",
            "stack"
        ],
        "test_cases": {
            "inputs": [
                [
                    0,
                    1,
                    0,
                    2,
                    1,
                    0,
                    1,
                    3,
                    2,
                    1,
                    2,
                    1
                ],
                [
                    4,
                    2,
                    0,
                    3,
                    2,
                    5
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    3,
                    1,
                    2,
                    1,
                    3
                ],
                [
                    2,
                    1,
                    2,
                    1,
                    2
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    0,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    1,
                    2,
                    1
                ],
                [
                    2,
                    1,
                    2,
                    1,
                    2
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    3,
                    3,
                    3,
                    3,
                    3
                ],
                [
                    4,
                    4,
                    4,
                    4,
                    4
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1,
                    2,
                    3,
                    4,
                    5
                ]
            ],
            "outputs": [
                6,
                9,
                0,
                0,
                0,
                4,
                1,
                0,
                1,
                0,
                1,
                1,
                1,
                1,
                0,
                0,
                0,
                0,
                16,
                16
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <iostream>\nusing namespace std;\n\nint trap(vector<int>& height) {\n    int n = height.size();\n    int left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\n\n    while (left < right) {\n        if (height[left] <= height[right]) {\n            maxLeft = max(maxLeft, height[left]);\n            water += maxLeft - height[left];\n            left++;\n        } else {\n            maxRight = max(maxRight, height[right]);\n            water += maxRight - height[right];\n            right--;\n        }\n    }\n\n    return water;\n}\n",
            "java": "public static int trap(int[] height) {\n        int n = height.length, left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\n\n        while (left < right) {\n            if (height[left] <= height[right]) {\n                maxLeft = Math.max(maxLeft, height[left]);\n                water += maxLeft - height[left];\n                left++;\n            } else {\n                maxRight = Math.max(maxRight, height[right]);\n                water += maxRight - height[right];\n                right--;\n            }\n        }\n\n        return water;\n    }\n",
            "python": "def trap(height):\n    n = len(height)\n    left, right, max_left, max_right, water = 0, n - 1, 0, 0, 0\n\n    while left < right:\n        if height[left] <= height[right]:\n            max_left = max(max_left, height[left])\n            water += max_left - height[left]\n            left += 1\n        else:\n            max_right = max(max_right, height[right])\n            water += max_right - height[right]\n            right -= 1\n\n    return water\n",
            "javascript": "function trap(height) {\n    const n = height.length;\n    let left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\n\n    while (left < right) {\n        if (height[left] <= height[right]) {\n            maxLeft = Math.max(maxLeft, height[left]);\n            water += maxLeft - height[left];\n            left++;\n        } else {\n            maxRight = Math.max(maxRight, height[right]);\n            water += maxRight - height[right];\n            right--;\n        }\n    }\n\n    return water;\n}\n",
            "explanation": "The algorithm uses a two-pointer approach, initializing left and right pointers to the beginning and end of the elevation map, respectively. It also initializes two variables `maxLeft` and `maxRight` to keep track of the maximum heights on the left and right of the pointers, as well as a variable `water` to store the trapped water.\n\nThe algorithm iterates through the elevation map until the left pointer is less than the right pointer. In each iteration, it compares the values at both pointers to determine which side is shorter. If the value at the left pointer is less than or equal to the value at the right pointer, it means water can be trapped on the left side up to the height of the shorter bar. The algorithm updates `maxLeft` with the maximum height on the left side and then adds the trapped water (which is the difference between the maximum height and the current height) to the `water` variable. The left pointer is then incremented. If the value at the right pointer is smaller, the same logic is applied to the right side and the right pointer is decremented.\n\nThis process is repeated until the left pointer is no longer less than the right pointer, at which point the total trapped water has been calculated and the `water` variable is returned. This algorithm has a time complexity of O(n) and a space complexity of O(1) as it only uses constant extra space."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n#include <iostream>\n\nint trap(vector<int>& height)  {\n    // Your code here\n}\n",
            "java": "public int trap(int[] height)  {\n    // Your code here\n}\n",
            "python": "def trap(height):\n    # Your code here\n\n",
            "javascript": "function trap(height)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> height = $args;\n    int result = trap(height);\n    std::cout <<\"$sprouts@pankaj\"<<result<<\"$sprouts@pankaj\";\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n        int[] height = $args;\n        int result = trap(height);\n        System.out.println(\"$sprouts@pankaj\" + result + \"$sprouts@pankaj\");\n    }\n    ",
            "python": "if __name__ == \"__main__\":\n    height = $args\n    result = trap(height)\n    print(\"$sprouts@pankaj\",result,\"$sprouts@pankaj\"\n)",
            "javascript": "function main() {\n    const height = $args;\n    const result = trap(height);\n    console.log(\"$sprouts@pankaj\",result,\"$sprouts@pankaj\");\n}\nmain();"
        },
        "Qid": "42",
        "languages verified": [
            "python",
            "javascript",
            "c++",
            "java"
        ]
    },
    {
        "_id": {
            "$oid": "661d40b7949b33b6c4e2b08b"
        },
        "title": "Wildcard Pattern Matching",
        "description": "Given an input string (`s`) and a pattern (`p`), implement wildcard pattern matching with support for `'?'` and `'*'` where:\n\n*   `'?'` Matches any single character.\n*   `'*'` Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the **entire** input string (not partial).",
        "example": "Example:\n\n**Input:** s =  \"aa \", p =  \"a \"\n**Output:** false\n**Explanation:**  \"a \" does not match the entire string  \"aa \".",
        "level": "Medium",
        "tags": [
            "string",
            "pattern matching",
            "wildcard"
        ],
        "test_cases": {
            "inputs": [
                [
                    "aa ",
                    "a "
                ],
                [
                    "aa ",
                    "* "
                ],
                [
                    "cb ",
                    "?a "
                ],
                [
                    "abc ",
                    "a*c "
                ],
                [
                    "abc ",
                    "a?c "
                ],
                [
                    "abc ",
                    "a?*c "
                ],
                [
                    "abc ",
                    "a?*d "
                ],
                [
                    "abc ",
                    "a?* "
                ],
                [
                    "abc ",
                    "a?*? "
                ],
                [
                    "abc ",
                    "a?*?* "
                ],
                [
                    "abc ",
                    "a?*?*? "
                ],
                [
                    "abc ",
                    "a?*?*?* "
                ],
                [
                    "abc ",
                    "a?*?*?*? "
                ],
                [
                    "abc ",
                    "a?*?*?*?* "
                ],
                [
                    "abc ",
                    "a?*?*?*?*? "
                ],
                [
                    "abc ",
                    "a?*?*?*?*?* "
                ],
                [
                    "abc ",
                    "a?*?*?*?*?*? "
                ],
                [
                    "abc ",
                    "a?*?*?*?*?*?* "
                ],
                [
                    "abc ",
                    "a?*?*?*?*?*?*? "
                ],
                [
                    "abc ",
                    "a?*?*?*?*?*?*?* "
                ],
                [
                    "abc ",
                    "a?*?*?*?*?*?*?*? "
                ],
                [
                    "abc ",
                    "a?*?*?*?*?*?*?*?* "
                ],
                [
                    "abc ",
                    "a?*?*?*?*?*?*?*?*? "
                ]
            ],
            "outputs": [
                false,
                true,
                false,
                true,
                true,
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "bool isMatch(const std::string& s, const std::string& p) {\n    int m = s.size(), n = p.size();\n    int i = 0, j = 0, asterisk = -1, match;\n    while (i < m) {\n        if (j < n && (s[i] == p[j] || p[j] == '?')) {\n            i++; j++;\n        } else if (j < n && p[j] == '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk >= 0) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p[j] == '*') j++;\n    return j == n;\n}\n",
            "java": "public boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    int i = 0, j = 0, asterisk = -1, match = 0;\n    while (i < m) {\n        if (j < n && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')) {\n            i++; j++;\n        } else if (j < n && p.charAt(j) == '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk != -1) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p.charAt(j) == '*') j++;\n    return j == n;\n}\n",
            "python": "def is_match(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    i = j = 0\n    match = asterisk = -1\n    while i < m:\n        if j < n and (s[i] == p[j] or p[j] == '?'):\n            i, j = i + 1, j + 1\n        elif j < n and p[j] == '*':\n            match, asterisk = i, j\n            j += 1\n        elif asterisk >= 0:\n            i, j = match + 1, asterisk + 1\n            match += 1\n        else:\n            return False\n    while j < n and p[j] == '*':\n        j += 1\n    return j == n\n",
            "javascript": "function isMatch(s, p) {\n    let m = s.length,\n        n = p.length;\n    let i = 0,\n        j = 0,\n        asterisk = -1,\n        match = 0;\n    while (i < m) {\n        if (j < n && (s[i] === p[j] || p[j] === '?')) {\n            i++;\n            j++;\n        } else if (j < n && p[j] === '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk >= 0) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p[j] === '*') j++;\n    return j === n;\n}\n",
            "explanation": "- Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.\n- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.\n  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.\n  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.\n  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.\n  - If none of the above conditions are met, return `false` as the input string and pattern don't match.\n- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.\n- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`."
        },
        "structure": {
            "c++": "bool isMatch(const std::string& s, const std::string& p)  {\n    // Your code here\n}\n",
            "java": "public boolean isMatch(String s, String p)  {\n    // Your code here\n}\n",
            "python": "def is_match(s: str, p: str) -> bool:\n    # Your code here\n\n",
            "javascript": "function isMatch(s, p)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <string>\n\nbool isMatch(const std::string& s, const std::string& p) {\n    int m = s.size(), n = p.size();\n    int i = 0, j = 0, asterisk = -1, match;\n    while (i < m) {\n        if (j < n && (s[i] == p[j] || p[j] == '?')) {\n            i++; j++;\n        } else if (j < n && p[j] == '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk >= 0) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p[j] == '*') j++;\n    return j == n;\n}\n\nint main() {\n    std::string s = $args;\n    std::string p = $args;\n    bool result = isMatch(s, p);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "java": "public boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    int i = 0, j = 0, asterisk = -1, match = 0;\n    while (i < m) {\n        if (j < n && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')) {\n            i++; j++;\n        } else if (j < n && p.charAt(j) == '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk != -1) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p.charAt(j) == '*') j++;\n    return j == n;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    s = inputs[0]\n    p = inputs[1]\n    result = is_match(s, p)\n    print(result)",
            "javascript": "function main() {\n    const inputs = $args;\n    const s = inputs[0];\n    const p = inputs[1];\n    const result = isMatch(s, p);\n    console.log(result);\n}\nmain();"
        },
        "Qid": "44",
        "languages verified": [
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d40eb949b33b6c4e2b08c"
        },
        "title": "Permutations of Distinct Integers",
        "description": "Given an array `nums` of distinct integers, return all the possible permutations. You can return the answer in any order.",
        "example": "Example 1:\n\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\nExample 2:\n\nInput: nums = [0,1]\nOutput: [[0,1],[1,0]]\n\nExample 3:\n\nInput: nums = [1]\nOutput: [[1]]",
        "level": "Medium",
        "tags": [
            "Array",
            "Permutations"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3
                ],
                [
                    0,
                    1
                ],
                [
                    1
                ],
                [
                    4,
                    5,
                    6,
                    7
                ],
                [
                    -1,
                    0,
                    1
                ],
                [
                    10,
                    20,
                    30
                ],
                [
                    2,
                    4,
                    6,
                    8
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5
                ],
                [
                    3,
                    2,
                    1
                ],
                [
                    100,
                    200,
                    300
                ]
            ],
            "outputs": [
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        1,
                        3,
                        2
                    ],
                    [
                        2,
                        1,
                        3
                    ],
                    [
                        2,
                        3,
                        1
                    ],
                    [
                        3,
                        1,
                        2
                    ],
                    [
                        3,
                        2,
                        1
                    ]
                ],
                [
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        0
                    ]
                ],
                [
                    [
                        1
                    ]
                ],
                [
                    [
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        4,
                        5,
                        7,
                        6
                    ],
                    [
                        4,
                        6,
                        5,
                        7
                    ],
                    [
                        4,
                        6,
                        7,
                        5
                    ],
                    [
                        4,
                        7,
                        5,
                        6
                    ],
                    [
                        4,
                        7,
                        6,
                        5
                    ],
                    [
                        5,
                        4,
                        6,
                        7
                    ],
                    [
                        5,
                        4,
                        7,
                        6
                    ],
                    [
                        5,
                        6,
                        4,
                        7
                    ],
                    [
                        5,
                        6,
                        7,
                        4
                    ],
                    [
                        5,
                        7,
                        4,
                        6
                    ],
                    [
                        5,
                        7,
                        6,
                        4
                    ],
                    [
                        6,
                        4,
                        5,
                        7
                    ],
                    [
                        6,
                        4,
                        7,
                        5
                    ],
                    [
                        6,
                        5,
                        4,
                        7
                    ],
                    [
                        6,
                        5,
                        7,
                        4
                    ],
                    [
                        6,
                        7,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        5,
                        4
                    ],
                    [
                        7,
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        4,
                        6,
                        5
                    ],
                    [
                        7,
                        5,
                        4,
                        6
                    ],
                    [
                        7,
                        5,
                        6,
                        4
                    ],
                    [
                        7,
                        6,
                        4,
                        5
                    ],
                    [
                        7,
                        6,
                        5,
                        4
                    ]
                ],
                [
                    [
                        -1,
                        0,
                        1
                    ],
                    [
                        -1,
                        1,
                        0
                    ],
                    [
                        0,
                        -1,
                        1
                    ],
                    [
                        0,
                        1,
                        -1
                    ],
                    [
                        1,
                        -1,
                        0
                    ],
                    [
                        1,
                        0,
                        -1
                    ]
                ],
                [
                    [
                        10,
                        20,
                        30
                    ],
                    [
                        10,
                        30,
                        20
                    ],
                    [
                        20,
                        10,
                        30
                    ],
                    [
                        20,
                        30,
                        10
                    ],
                    [
                        30,
                        10,
                        20
                    ],
                    [
                        30,
                        20,
                        10
                    ]
                ],
                [
                    [
                        2,
                        4,
                        6,
                        8
                    ],
                    [
                        2,
                        4,
                        8,
                        6
                    ],
                    [
                        2,
                        6,
                        4,
                        8
                    ],
                    [
                        2,
                        6,
                        8,
                        4
                    ],
                    [
                        2,
                        8,
                        4,
                        6
                    ],
                    [
                        2,
                        8,
                        6,
                        4
                    ],
                    [
                        4,
                        2,
                        6,
                        8
                    ],
                    [
                        4,
                        2,
                        8,
                        6
                    ],
                    [
                        4,
                        6,
                        2,
                        8
                    ],
                    [
                        4,
                        6,
                        8,
                        2
                    ],
                    [
                        4,
                        8,
                        2,
                        6
                    ],
                    [
                        4,
                        8,
                        6,
                        2
                    ],
                    [
                        6,
                        2,
                        4,
                        8
                    ],
                    [
                        6,
                        2,
                        8,
                        4
                    ],
                    [
                        6,
                        4,
                        2,
                        8
                    ],
                    [
                        6,
                        4,
                        8,
                        2
                    ],
                    [
                        6,
                        8,
                        2,
                        4
                    ],
                    [
                        6,
                        8,
                        4,
                        2
                    ],
                    [
                        8,
                        2,
                        4,
                        6
                    ],
                    [
                        8,
                        2,
                        6,
                        4
                    ],
                    [
                        8,
                        4,
                        2,
                        6
                    ],
                    [
                        8,
                        4,
                        6,
                        2
                    ],
                    [
                        8,
                        6,
                        2,
                        4
                    ],
                    [
                        8,
                        6,
                        4,
                        2
                    ]
                ],
                [
                    [
                        9,
                        8,
                        7,
                        6,
                        5
                    ],
                    [
                        9,
                        8,
                        7,
                        5,
                        6
                    ],
                    [
                        9,
                        8,
                        6,
                        7,
                        5
                    ],
                    [
                        9,
                        8,
                        6,
                        5,
                        7
                    ],
                    [
                        9,
                        8,
                        5,
                        7,
                        6
                    ],
                    [
                        9,
                        8,
                        5,
                        6,
                        7
                    ],
                    [
                        9,
                        7,
                        8,
                        6,
                        5
                    ],
                    [
                        9,
                        7,
                        8,
                        5,
                        6
                    ],
                    [
                        9,
                        7,
                        6,
                        8,
                        5
                    ],
                    [
                        9,
                        7,
                        6,
                        5,
                        8
                    ],
                    [
                        9,
                        7,
                        5,
                        8,
                        6
                    ],
                    [
                        9,
                        7,
                        5,
                        6,
                        8
                    ],
                    [
                        9,
                        6,
                        8,
                        7,
                        5
                    ],
                    [
                        9,
                        6,
                        8,
                        5,
                        7
                    ],
                    [
                        9,
                        6,
                        7,
                        8,
                        5
                    ],
                    [
                        9,
                        6,
                        7,
                        5,
                        8
                    ],
                    [
                        9,
                        6,
                        5,
                        8,
                        7
                    ],
                    [
                        9,
                        6,
                        5,
                        7,
                        8
                    ],
                    [
                        9,
                        5,
                        8,
                        7,
                        6
                    ],
                    [
                        9,
                        5,
                        8,
                        6,
                        7
                    ],
                    [
                        9,
                        5,
                        7,
                        8,
                        6
                    ],
                    [
                        9,
                        5,
                        7,
                        6,
                        8
                    ],
                    [
                        9,
                        5,
                        6,
                        8,
                        7
                    ],
                    [
                        9,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        8,
                        9,
                        7,
                        6,
                        5
                    ],
                    [
                        8,
                        9,
                        7,
                        5,
                        6
                    ],
                    [
                        8,
                        9,
                        6,
                        7,
                        5
                    ],
                    [
                        8,
                        9,
                        6,
                        5,
                        7
                    ],
                    [
                        8,
                        9,
                        5,
                        7,
                        6
                    ],
                    [
                        8,
                        9,
                        5,
                        6,
                        7
                    ],
                    [
                        8,
                        7,
                        9,
                        6,
                        5
                    ],
                    [
                        8,
                        7,
                        9,
                        5,
                        6
                    ],
                    [
                        8,
                        7,
                        6,
                        9,
                        5
                    ],
                    [
                        8,
                        7,
                        6,
                        5,
                        9
                    ],
                    [
                        8,
                        7,
                        5,
                        9,
                        6
                    ],
                    [
                        8,
                        7,
                        5,
                        6,
                        9
                    ],
                    [
                        8,
                        6,
                        9,
                        7,
                        5
                    ],
                    [
                        8,
                        6,
                        9,
                        5,
                        7
                    ],
                    [
                        8,
                        6,
                        7,
                        9,
                        5
                    ],
                    [
                        8,
                        6,
                        7,
                        5,
                        9
                    ],
                    [
                        8,
                        6,
                        5,
                        9,
                        7
                    ],
                    [
                        8,
                        6,
                        5,
                        7,
                        9
                    ],
                    [
                        8,
                        5,
                        9,
                        7,
                        6
                    ],
                    [
                        8,
                        5,
                        9,
                        6,
                        7
                    ],
                    [
                        8,
                        5,
                        7,
                        9,
                        6
                    ],
                    [
                        8,
                        5,
                        7,
                        6,
                        9
                    ],
                    [
                        8,
                        5,
                        6,
                        9,
                        7
                    ],
                    [
                        8,
                        5,
                        6,
                        7,
                        9
                    ],
                    [
                        7,
                        9,
                        8,
                        6,
                        5
                    ],
                    [
                        7,
                        9,
                        8,
                        5,
                        6
                    ],
                    [
                        7,
                        9,
                        6,
                        8,
                        5
                    ],
                    [
                        7,
                        9,
                        6,
                        5,
                        8
                    ],
                    [
                        7,
                        9,
                        5,
                        8,
                        6
                    ],
                    [
                        7,
                        9,
                        5,
                        6,
                        8
                    ],
                    [
                        7,
                        8,
                        9,
                        6,
                        5
                    ],
                    [
                        7,
                        8,
                        9,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        6,
                        9,
                        5
                    ],
                    [
                        7,
                        8,
                        6,
                        5,
                        9
                    ],
                    [
                        7,
                        8,
                        5,
                        9,
                        6
                    ],
                    [
                        7,
                        8,
                        5,
                        6,
                        9
                    ],
                    [
                        7,
                        6,
                        9,
                        8,
                        5
                    ],
                    [
                        7,
                        6,
                        9,
                        5,
                        8
                    ],
                    [
                        7,
                        6,
                        8,
                        9,
                        5
                    ],
                    [
                        7,
                        6,
                        8,
                        5,
                        9
                    ],
                    [
                        7,
                        6,
                        5,
                        9,
                        8
                    ],
                    [
                        7,
                        6,
                        5,
                        8,
                        9
                    ],
                    [
                        7,
                        5,
                        9,
                        8,
                        6
                    ],
                    [
                        7,
                        5,
                        9,
                        6,
                        8
                    ],
                    [
                        7,
                        5,
                        8,
                        9,
                        6
                    ],
                    [
                        7,
                        5,
                        8,
                        6,
                        9
                    ],
                    [
                        7,
                        5,
                        6,
                        9,
                        8
                    ],
                    [
                        7,
                        5,
                        6,
                        8,
                        9
                    ],
                    [
                        6,
                        9,
                        8,
                        7,
                        5
                    ],
                    [
                        6,
                        9,
                        8,
                        5,
                        7
                    ],
                    [
                        6,
                        9,
                        7,
                        8,
                        5
                    ],
                    [
                        6,
                        9,
                        7,
                        5,
                        8
                    ],
                    [
                        6,
                        9,
                        5,
                        8,
                        7
                    ],
                    [
                        6,
                        9,
                        5,
                        7,
                        8
                    ],
                    [
                        6,
                        8,
                        9,
                        7,
                        5
                    ],
                    [
                        6,
                        8,
                        9,
                        5,
                        7
                    ],
                    [
                        6,
                        8,
                        7,
                        9,
                        5
                    ],
                    [
                        6,
                        8,
                        7,
                        5,
                        9
                    ],
                    [
                        6,
                        8,
                        5,
                        9,
                        7
                    ],
                    [
                        6,
                        8,
                        5,
                        7,
                        9
                    ],
                    [
                        6,
                        7,
                        9,
                        8,
                        5
                    ],
                    [
                        6,
                        7,
                        9,
                        5,
                        8
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        5,
                        9
                    ],
                    [
                        6,
                        7,
                        5,
                        9,
                        8
                    ],
                    [
                        6,
                        7,
                        5,
                        8,
                        9
                    ],
                    [
                        6,
                        5,
                        9,
                        8,
                        7
                    ],
                    [
                        6,
                        5,
                        9,
                        7,
                        8
                    ],
                    [
                        6,
                        5,
                        8,
                        9,
                        7
                    ],
                    [
                        6,
                        5,
                        8,
                        7,
                        9
                    ],
                    [
                        6,
                        5,
                        7,
                        9,
                        8
                    ],
                    [
                        6,
                        5,
                        7,
                        8,
                        9
                    ],
                    [
                        5,
                        9,
                        8,
                        7,
                        6
                    ],
                    [
                        5,
                        9,
                        8,
                        6,
                        7
                    ],
                    [
                        5,
                        9,
                        7,
                        8,
                        6
                    ],
                    [
                        5,
                        9,
                        7,
                        6,
                        8
                    ],
                    [
                        5,
                        9,
                        6,
                        8,
                        7
                    ],
                    [
                        5,
                        9,
                        6,
                        7,
                        8
                    ],
                    [
                        5,
                        8,
                        9,
                        7,
                        6
                    ],
                    [
                        5,
                        8,
                        9,
                        6,
                        7
                    ],
                    [
                        5,
                        8,
                        7,
                        9,
                        6
                    ],
                    [
                        5,
                        8,
                        7,
                        6,
                        9
                    ],
                    [
                        5,
                        8,
                        6,
                        9,
                        7
                    ],
                    [
                        5,
                        8,
                        6,
                        7,
                        9
                    ],
                    [
                        5,
                        7,
                        9,
                        8,
                        6
                    ],
                    [
                        5,
                        7,
                        9,
                        6,
                        8
                    ],
                    [
                        5,
                        7,
                        8,
                        9,
                        6
                    ],
                    [
                        5,
                        7,
                        8,
                        6,
                        9
                    ],
                    [
                        5,
                        7,
                        6,
                        9,
                        8
                    ],
                    [
                        5,
                        7,
                        6,
                        8,
                        9
                    ],
                    [
                        5,
                        6,
                        9,
                        8,
                        7
                    ],
                    [
                        5,
                        6,
                        9,
                        7,
                        8
                    ],
                    [
                        5,
                        6,
                        8,
                        9,
                        7
                    ],
                    [
                        5,
                        6,
                        8,
                        7,
                        9
                    ],
                    [
                        5,
                        6,
                        7,
                        9,
                        8
                    ],
                    [
                        5,
                        6,
                        7,
                        8,
                        9
                    ]
                ],
                [
                    [
                        3,
                        2,
                        1
                    ],
                    [
                        3,
                        1,
                        2
                    ],
                    [
                        2,
                        3,
                        1
                    ],
                    [
                        2,
                        1,
                        3
                    ],
                    [
                        1,
                        3,
                        2
                    ],
                    [
                        1,
                        2,
                        3
                    ]
                ],
                [
                    [
                        100,
                        200,
                        300
                    ],
                    [
                        100,
                        300,
                        200
                    ],
                    [
                        200,
                        100,
                        300
                    ],
                    [
                        200,
                        300,
                        100
                    ],
                    [
                        300,
                        100,
                        200
                    ],
                    [
                        300,
                        200,
                        100
                    ]
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nvoid helper(std::vector<int>& nums, int index, std::vector<std::vector<int>>& results) {\n    if (index == nums.size() - 1) {\n        results.push_back(nums);\n        return;\n    }\n\n    for (int i = index; i < nums.size(); i++) {\n        std::swap(nums[index], nums[i]);\n        helper(nums, index + 1, results);\n        std::swap(nums[index], nums[i]);\n    }\n}\n\nstd::vector<std::vector<int>> permute(std::vector<int>& nums) {\n    std::vector<std::vector<int>> results;\n    helper(nums, 0, results);\n    return results;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> permute(int[] nums) {\n    List<List<Integer>> results = new ArrayList<>();\n    helper(nums, 0, results);\n    return results;\n}\n\nprivate void helper(int[] nums, int index, List<List<Integer>> results) {\n    if (index == nums.length - 1) {\n        List<Integer> tempList = new ArrayList<>();\n        for (int n : nums) {\n            tempList.add(n);\n        }\n        results.add(tempList);\n        return;\n    }\n\n    for (int i = index; i < nums.length; i++) {\n        swap(nums, index, i);\n        helper(nums, index + 1, results);\n        swap(nums, index, i);\n    }\n}\n\nprivate void swap(int[] nums, int i, int j) {\n    int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n}\n",
            "python": "from typing import List\n\ndef permute(nums: List[int]) -> List[List[int]]:\n    def helper(index):\n        if index == len(nums) - 1:\n            results.append(nums[:])\n            return\n\n        for i in range(index, len(nums)):\n            nums[index], nums[i] = nums[i], nums[index]\n            helper(index + 1)\n            nums[index], nums[i] = nums[i], nums[index]\n\n    results = []\n    helper(0)\n    return results\n",
            "javascript": "function permute(nums) {\n  const results = [];\n  helper(nums, 0, results);\n  return results;\n}\n\nfunction helper(nums, index, results) {\n  if (index === nums.length - 1) {\n    results.push(nums.slice());\n    return;\n  }\n\n  for (let i = index; i < nums.length; i++) {\n    [nums[index], nums[i]] = [nums[i], nums[index]];\n    helper(nums, index + 1, results);\n    [nums[index], nums[i]] = [nums[i], nums[index]];\n  }\n}\n",
            "explanation": "The algorithm uses backtracking to generate all possible permutations. It works by swapping the elements in the input array in a recursive manner.\n\n1. The base case is when the index reaches the last element of the array; at this point, we append the current configuration to the \"results\" list.\n2. For each index, we iterate from `index` to the end of the array, performing the following steps:\n    a. Swap `index` and `i` elements.\n    b. Recursively call the helper function with `index + 1`.\n    c. Swap the elements back to their original positions.\n\nThis will generate all possible permutations, as it swaps elements in different positions while maintaining the original order in the input array. The termination condition for the recursion is the base case when we reach the end of the array. The complexity of this algorithm is O(N!), as there are N! permutations of an array of N elements."
        },
        "structure": {
            "c++": "#include <vector>\n\nvoid helper(std::vector<int>& nums, int index, std::vector<std::vector<int>>& results)  {\n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> permute(int[] nums)  {\n    // Your code here\n}\n",
            "python": "from typing import List\n    # Your code here\n\n",
            "javascript": "function permute(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nvoid helper(std::vector<int>& nums, int index, std::vector<std::vector<int>>& results) {\n    if (index == nums.size() - 1) {\n        results.push_back(nums);\n        return;\n    }\n\n    for (int i = index; i < nums.size(); i++) {\n        std::swap(nums[index], nums[i]);\n        helper(nums, index + 1, results);\n        std::swap(nums[index], nums[i]);\n    }\n}\n\nstd::vector<std::vector<int>> permute(std::vector<int>& nums) {\n    std::vector<std::vector<int>> results;\n    helper(nums, 0, results);\n    return results;\n}\n\nint main() {\n    std::vector<int> nums = $args;\n    std::vector<std::vector<int>> result = permute(nums);\n    for (const auto& res : result) {\n        for (const auto& num : res) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}",
            "java": "public List<List<Integer>> permute(int[] nums) {\n    List<List<Integer>> results = new ArrayList<>();\n    helper(nums, 0, results);\n    return results;\n}\n\nprivate void helper(int[] nums, int index, List<List<Integer>> results) {\n    if (index == nums.length - 1) {\n        List<Integer> tempList = new ArrayList<>();\n        for (int n : nums) {\n            tempList.add(n);\n        }\n        results.add(tempList);\n        return;\n    }\n\n    for (int i = index; i < nums.length; i++) {\n        swap(nums, index, i);\n        helper(nums, index + 1, results);\n        swap(nums, index, i);\n    }\n}\n\nprivate void swap(int[] nums, int i, int j) {\n    int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = [-1, 0, 1]\n    result = permute(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = permute(nums);\n    for (const res of result) {\n        console.log(res.join(' '));\n    }\n}\nmain();"
        },
        "Qid": "46",
        "languages verified": [
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d4164949b33b6c4e2b08d"
        },
        "title": "Unique Permutations with Duplicates",
        "description": "Given a collection of numbers, `nums`, that might contain duplicates, return all possible unique permutations in any order.",
        "example": "Example 1:\n\nInput: nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n\nExample 2:\n\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "level": "Medium",
        "tags": [
            "Array",
            "Backtracking"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    1,
                    2
                ],
                [
                    1,
                    2,
                    3
                ],
                [
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2
                ],
                [
                    1,
                    2,
                    2
                ],
                [
                    1,
                    1,
                    2,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4
                ],
                [
                    1,
                    1,
                    2,
                    2,
                    3,
                    3
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8
                ],
                [
                    1,
                    1,
                    2,
                    2,
                    3,
                    3,
                    4,
                    4,
                    5,
                    5
                ]
            ],
            "outputs": [
                [
                    [
                        1,
                        1,
                        2
                    ],
                    [
                        1,
                        2,
                        1
                    ],
                    [
                        2,
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        1,
                        3,
                        2
                    ],
                    [
                        2,
                        1,
                        3
                    ],
                    [
                        2,
                        3,
                        1
                    ],
                    [
                        3,
                        1,
                        2
                    ],
                    [
                        3,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1,
                        1
                    ]
                ],
                [
                    [
                        2,
                        2,
                        2
                    ]
                ],
                [
                    [
                        1,
                        2,
                        2
                    ],
                    [
                        2,
                        1,
                        2
                    ],
                    [
                        2,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1,
                        2,
                        2
                    ],
                    [
                        1,
                        2,
                        1,
                        2
                    ],
                    [
                        1,
                        2,
                        2,
                        1
                    ],
                    [
                        2,
                        1,
                        1,
                        2
                    ],
                    [
                        2,
                        1,
                        2,
                        1
                    ],
                    [
                        2,
                        2,
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        1,
                        2,
                        4,
                        3
                    ],
                    [
                        1,
                        3,
                        2,
                        4
                    ],
                    [
                        1,
                        3,
                        4,
                        2
                    ],
                    [
                        1,
                        4,
                        2,
                        3
                    ],
                    [
                        1,
                        4,
                        3,
                        2
                    ],
                    [
                        2,
                        1,
                        3,
                        4
                    ],
                    [
                        2,
                        1,
                        4,
                        3
                    ],
                    [
                        2,
                        3,
                        1,
                        4
                    ],
                    [
                        2,
                        3,
                        4,
                        1
                    ],
                    [
                        2,
                        4,
                        1,
                        3
                    ],
                    [
                        2,
                        4,
                        3,
                        1
                    ],
                    [
                        3,
                        1,
                        2,
                        4
                    ],
                    [
                        3,
                        1,
                        4,
                        2
                    ],
                    [
                        3,
                        2,
                        1,
                        4
                    ],
                    [
                        3,
                        2,
                        4,
                        1
                    ],
                    [
                        3,
                        4,
                        1,
                        2
                    ],
                    [
                        3,
                        4,
                        2,
                        1
                    ],
                    [
                        4,
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        1,
                        3,
                        2
                    ],
                    [
                        4,
                        2,
                        1,
                        3
                    ],
                    [
                        4,
                        2,
                        3,
                        1
                    ],
                    [
                        4,
                        3,
                        1,
                        2
                    ],
                    [
                        4,
                        3,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        8,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        7,
                        6,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        7,
                        8,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        8,
                        6,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        8,
                        7,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6,
                        5,
                        7,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6,
                        5,
                        8,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6,
                        7,
                        5,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6,
                        7,
                        8,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6,
                        8,
                        5,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6,
                        8,
                        7,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        7,
                        5,
                        6,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        7,
                        5,
                        8,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        7,
                        6,
                        5,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        7,
                        6,
                        8,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        7,
                        8,
                        5,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        7,
                        8,
                        6,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        8,
                        5,
                        6,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        8,
                        5,
                        7,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        8,
                        6,
                        5,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        8,
                        6,
                        7,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        8,
                        7,
                        5,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        8,
                        7,
                        6,
                        5
                    ]
                ],
                [
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ],
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ]
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\n\nvoid backtrack(std::vector<std::vector<int>>& result, std::vector<int>& nums, int start) {\n    if (start == nums.size()) {\n        result.push_back(nums);\n        return;\n    }\n    for (int i = start; i < nums.size(); i++) {\n        if (i > start && nums[i] == nums[start]) continue;\n        std::swap(nums[start], nums[i]);\n        backtrack(result, nums, start + 1);\n        std::swap(nums[start], nums[i]);\n    }\n}\n\nstd::vector<std::vector<int>> permuteUnique(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    std::vector<std::vector<int>> result;\n    backtrack(result, nums, 0);\n    return result;\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<List<Integer>> permuteUnique(int[] nums) {\n    Arrays.sort(nums);\n    List<List<Integer>> result = new ArrayList<>();\n    boolean[] visited = new boolean[nums.length];\n    backtrack(result, new ArrayList<>(), nums, visited);\n    return result;\n}\n\nprivate void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums, boolean[] visited) {\n    if (tempList.size() == nums.length) {\n        result.add(new ArrayList<>(tempList));\n    } else {\n        for (int i = 0; i < nums.length; i++) {\n            if (visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])) continue;\n            visited[i] = true;\n            tempList.add(nums[i]);\n            backtrack(result, tempList, nums, visited);\n            tempList.remove(tempList.size() - 1);\n            visited[i] = false;\n        }\n    }\n}\n\n",
            "python": "from typing import List\n\ndef permuteUnique(nums: List[int]) -> List[List[int]]:\n    def backtrack(start):\n        if start == len(nums):\n            result.append(nums[:])\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[start]:\n                continue\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start]\n\n    nums.sort()\n    result = []\n    backtrack(0)\n    return result\n\n",
            "javascript": "function permuteUnique(nums) {\n    nums.sort((a, b) => a - b);\n    const result = [];\n    const visited = new Array(nums.length).fill(false);\n\n    function backtrack(tempList) {\n        if (tempList.length === nums.length) {\n            result.push([...tempList]);\n            return;\n        }\n        for (let i = 0; i < nums.length; i++) {\n            if (visited[i] || (i > 0 && nums[i] === nums[i - 1] && !visited[i - 1])) continue;\n            visited[i] = true;\n            tempList.push(nums[i]);\n            backtrack(tempList);\n            tempList.pop();\n            visited[i] = false;\n        }\n    }\n\n    backtrack([]);\n    return result;\n}\n\n",
            "explanation": "We use backtracking to generate permutations. Firstly, we sort the `nums` array to make sure that duplicate numbers are located together. Then, for each recursive backtracking call, we swap the elements in the range `[start, len(nums) - 1]` with `nums[start]`, ignoring already-visited elements by using a `visited` array.\n\nWe also skip any element that is equal to the current `start` element to avoid duplicates. After generating a valid permutation by iterating through all indices, we append the current permutation to the result array. When backtracking, we maintain the original order of elements before moving to the next level.\n\nThe time complexity of this approach is O(n! * n) since there are n! available permutations and each permutation requires O(n) time to build the solution. The space complexity is O(n) to store the `visited` array and temporary lists."
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\n\nvoid backtrack(std::vector<std::vector<int>>& result, std::vector<int>& nums, int start)  {\n    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<List<Integer>> permuteUnique(int[] nums)  {\n    // Your code here\n}\n\n",
            "python": "from typing import List\n    # Your code here\n\n",
            "javascript": "function permuteUnique(nums)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nvoid backtrack(std::vector<std::vector<int>>& result, std::vector<int>& nums, int start) {\n    if (start == nums.size()) {\n        result.push_back(nums);\n        return;\n    }\n    for (int i = start; i < nums.size(); i++) {\n        if (i > start && nums[i] == nums[start]) continue;\n        std::swap(nums[start], nums[i]);\n        backtrack(result, nums, start + 1);\n        std::swap(nums[start], nums[i]);\n    }\n}\n\nstd::vector<std::vector<int>> permuteUnique(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    std::vector<std::vector<int>> result;\n    backtrack(result, nums, 0);\n    return result;\n}\n\nint main() {\n    std::vector<int> nums = $args;\n    std::vector<std::vector<int>> result = permuteUnique(nums);\n    for (const auto& res : result) {\n        for (const auto& num : res) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}",
            "java": "public List<List<Integer>> permuteUnique(int[] nums) {\n    Arrays.sort(nums);\n    List<List<Integer>> result = new ArrayList<>();\n    boolean[] visited = new boolean[nums.length];\n    backtrack(result, new ArrayList<>(), nums, visited);\n    return result;\n}\n\nprivate void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums, boolean[] visited) {\n    if (tempList.size() == nums.length) {\n        result.add(new ArrayList<>(tempList));\n    } else {\n        for (int i = 0; i < nums.length; i++) {\n            if (visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])) continue;\n            visited[i] = true;\n            tempList.add(nums[i]);\n            backtrack(result, tempList, nums, visited);\n            tempList.remove(tempList.size() - 1);\n            visited[i] = false;\n        }\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = permuteUnique(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = permuteUnique(nums);\n    for (const res of result) {\n        console.log(res.join(' '));\n    }\n}\nmain();"
        },
        "Qid": "47",
        "languages verified": [
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d41c5949b33b6c4e2b08e"
        },
        "title": "Rotate Image",
        "description": "You are given an `n x n` 2D `matrix` representing an image. Rotate the image by **90** degrees (clockwise) in-place.",
        "example": "Example:\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\n\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
        "level": "Medium",
        "tags": [
            "array",
            "matrix",
            "in-place"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9
                    ]
                ],
                [
                    [
                        5,
                        1,
                        9,
                        11
                    ],
                    [
                        2,
                        4,
                        8,
                        10
                    ],
                    [
                        13,
                        3,
                        6,
                        7
                    ],
                    [
                        15,
                        14,
                        12,
                        16
                    ]
                ],
                [
                    [
                        1
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16,
                        17,
                        18
                    ],
                    [
                        19,
                        20,
                        21,
                        22,
                        23,
                        24
                    ],
                    [
                        25,
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35,
                        36
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14
                    ],
                    [
                        15,
                        16,
                        17,
                        18,
                        19,
                        20,
                        21
                    ],
                    [
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28
                    ],
                    [
                        29,
                        30,
                        31,
                        32,
                        33,
                        34,
                        35
                    ],
                    [
                        36,
                        37,
                        38,
                        39,
                        40,
                        41,
                        42
                    ],
                    [
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15,
                        16
                    ],
                    [
                        17,
                        18,
                        19,
                        20,
                        21,
                        22,
                        23,
                        24
                    ],
                    [
                        25,
                        26,
                        27,
                        28,
                        29,
                        30,
                        31,
                        32
                    ],
                    [
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48
                    ],
                    [
                        49,
                        50,
                        51,
                        52,
                        53,
                        54,
                        55,
                        56
                    ],
                    [
                        57,
                        58,
                        59,
                        60,
                        61,
                        62,
                        63,
                        64
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        10,
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18
                    ],
                    [
                        19,
                        20,
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27
                    ],
                    [
                        28,
                        29,
                        30,
                        31,
                        32,
                        33,
                        34,
                        35,
                        36
                    ],
                    [
                        37,
                        38,
                        39,
                        40,
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50,
                        51,
                        52,
                        53,
                        54
                    ],
                    [
                        55,
                        56,
                        57,
                        58,
                        59,
                        60,
                        61,
                        62,
                        63
                    ],
                    [
                        64,
                        65,
                        66,
                        67,
                        68,
                        69,
                        70,
                        71,
                        72
                    ],
                    [
                        73,
                        74,
                        75,
                        76,
                        77,
                        78,
                        79,
                        80,
                        81
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65,
                        66,
                        67,
                        68,
                        69,
                        70
                    ],
                    [
                        71,
                        72,
                        73,
                        74,
                        75,
                        76,
                        77,
                        78,
                        79,
                        80
                    ],
                    [
                        81,
                        82,
                        83,
                        84,
                        85,
                        86,
                        87,
                        88,
                        89,
                        90
                    ],
                    [
                        91,
                        92,
                        93,
                        94,
                        95,
                        96,
                        97,
                        98,
                        99,
                        100
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20,
                        21,
                        22
                    ],
                    [
                        23,
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        30,
                        31,
                        32,
                        33
                    ],
                    [
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40,
                        41,
                        42,
                        43,
                        44
                    ],
                    [
                        45,
                        46,
                        47,
                        48,
                        49,
                        50,
                        51,
                        52,
                        53,
                        54,
                        55
                    ],
                    [
                        56,
                        57,
                        58,
                        59,
                        60,
                        61,
                        62,
                        63,
                        64,
                        65,
                        66
                    ],
                    [
                        67,
                        68,
                        69,
                        70,
                        71,
                        72,
                        73,
                        74,
                        75,
                        76,
                        77
                    ],
                    [
                        78,
                        79,
                        80,
                        81,
                        82,
                        83,
                        84,
                        85,
                        86,
                        87,
                        88
                    ],
                    [
                        89,
                        90,
                        91,
                        92,
                        93,
                        94,
                        95,
                        96,
                        97,
                        98,
                        99
                    ],
                    [
                        100,
                        101,
                        102,
                        103,
                        104,
                        105,
                        106,
                        107,
                        108,
                        109,
                        110
                    ],
                    [
                        111,
                        112,
                        113,
                        114,
                        115,
                        116,
                        117,
                        118,
                        119,
                        120,
                        121
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20,
                        21,
                        22,
                        23,
                        24
                    ],
                    [
                        25,
                        26,
                        27,
                        28,
                        29,
                        30,
                        31,
                        32,
                        33,
                        34,
                        35,
                        36
                    ],
                    [
                        37,
                        38,
                        39,
                        40,
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48
                    ],
                    [
                        49,
                        50,
                        51,
                        52,
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65,
                        66,
                        67,
                        68,
                        69,
                        70,
                        71,
                        72
                    ],
                    [
                        73,
                        74,
                        75,
                        76,
                        77,
                        78,
                        79,
                        80,
                        81,
                        82,
                        83,
                        84
                    ],
                    [
                        85,
                        86,
                        87,
                        88,
                        89,
                        90,
                        91,
                        92,
                        93,
                        94,
                        95,
                        96
                    ],
                    [
                        97,
                        98,
                        99,
                        100,
                        101,
                        102,
                        103,
                        104,
                        105,
                        106,
                        107,
                        108
                    ],
                    [
                        109,
                        110,
                        111,
                        112,
                        113,
                        114,
                        115,
                        116,
                        117,
                        118,
                        119,
                        120
                    ],
                    [
                        121,
                        122,
                        123,
                        124,
                        125,
                        126,
                        127,
                        128,
                        129,
                        130,
                        131,
                        132
                    ],
                    [
                        133,
                        134,
                        135,
                        136,
                        137,
                        138,
                        139,
                        140,
                        141,
                        142,
                        143,
                        144
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13
                    ],
                    [
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20,
                        21,
                        22,
                        23,
                        24,
                        25,
                        26
                    ],
                    [
                        27,
                        28,
                        29,
                        30,
                        31,
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39
                    ],
                    [
                        40,
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50,
                        51,
                        52
                    ],
                    [
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60,
                        61,
                        62,
                        63,
                        64,
                        65
                    ],
                    [
                        66,
                        67,
                        68,
                        69,
                        70,
                        71,
                        72,
                        73,
                        74,
                        75,
                        76,
                        77,
                        78
                    ],
                    [
                        79,
                        80,
                        81,
                        82,
                        83,
                        84,
                        85,
                        86,
                        87,
                        88,
                        89,
                        90,
                        91
                    ],
                    [
                        92,
                        93,
                        94,
                        95,
                        96,
                        97,
                        98,
                        99,
                        100,
                        101,
                        102,
                        103,
                        104
                    ],
                    [
                        105,
                        106,
                        107,
                        108,
                        109,
                        110,
                        111,
                        112,
                        113,
                        114,
                        115,
                        116,
                        117
                    ],
                    [
                        118,
                        119,
                        120,
                        121,
                        122,
                        123,
                        124,
                        125,
                        126,
                        127,
                        128,
                        129,
                        130
                    ],
                    [
                        131,
                        132,
                        133,
                        134,
                        135,
                        136,
                        137,
                        138,
                        139,
                        140,
                        141,
                        142,
                        143
                    ],
                    [
                        144,
                        145,
                        146,
                        147,
                        148,
                        149,
                        150,
                        151,
                        152,
                        153,
                        154,
                        155,
                        156
                    ],
                    [
                        157,
                        158,
                        159,
                        160,
                        161,
                        162,
                        163,
                        164,
                        165,
                        166,
                        167,
                        168,
                        169
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14
                    ],
                    [
                        15,
                        16,
                        17,
                        18,
                        19,
                        20,
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28
                    ],
                    [
                        29,
                        30,
                        31,
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40,
                        41,
                        42
                    ],
                    [
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50,
                        51,
                        52,
                        53,
                        54,
                        55,
                        56
                    ],
                    [
                        57,
                        58,
                        59,
                        60,
                        61,
                        62,
                        63,
                        64,
                        65,
                        66,
                        67,
                        68,
                        69,
                        70
                    ],
                    [
                        71,
                        72,
                        73,
                        74,
                        75,
                        76,
                        77,
                        78,
                        79,
                        80,
                        81,
                        82,
                        83,
                        84
                    ],
                    [
                        85,
                        86,
                        87,
                        88,
                        89,
                        90,
                        91,
                        92,
                        93,
                        94,
                        95,
                        96,
                        97,
                        98
                    ],
                    [
                        99,
                        100,
                        101,
                        102,
                        103,
                        104,
                        105,
                        106,
                        107,
                        108,
                        109,
                        110,
                        111,
                        112
                    ],
                    [
                        113,
                        114,
                        115,
                        116,
                        117,
                        118,
                        119,
                        120,
                        121,
                        122,
                        123,
                        124,
                        125,
                        126
                    ],
                    [
                        127,
                        128,
                        129,
                        130,
                        131,
                        132,
                        133,
                        134,
                        135,
                        136,
                        137,
                        138,
                        139,
                        140
                    ],
                    [
                        141,
                        142,
                        143,
                        144,
                        145,
                        146,
                        147,
                        148,
                        149,
                        150,
                        151,
                        152,
                        153,
                        154
                    ],
                    [
                        155,
                        156,
                        157,
                        158,
                        159,
                        160,
                        161,
                        162,
                        163,
                        164,
                        165,
                        166,
                        167,
                        168,
                        169
                    ],
                    [
                        170,
                        171,
                        172,
                        173,
                        174,
                        175,
                        176,
                        177,
                        178,
                        179,
                        180,
                        181,
                        182,
                        183
                    ],
                    [
                        184,
                        185,
                        186,
                        187,
                        188,
                        189,
                        190,
                        191,
                        192,
                        193,
                        194,
                        195,
                        196,
                        197
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20,
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40,
                        41,
                        42,
                        43,
                        44,
                        45
                    ],
                    [
                        46,
                        47,
                        48,
                        49,
                        50,
                        51,
                        52,
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65,
                        66,
                        67,
                        68,
                        69,
                        70,
                        71,
                        72,
                        73,
                        74,
                        75
                    ],
                    [
                        76,
                        77,
                        78,
                        79,
                        80,
                        81,
                        82,
                        83,
                        84,
                        85,
                        86,
                        87,
                        88,
                        89,
                        90
                    ],
                    [
                        91,
                        92,
                        93,
                        94,
                        95,
                        96,
                        97,
                        98,
                        99,
                        100,
                        101,
                        102,
                        103,
                        104,
                        105
                    ],
                    [
                        106,
                        107,
                        108,
                        109,
                        110,
                        111,
                        112,
                        113,
                        114,
                        115,
                        116,
                        117,
                        118,
                        119,
                        120
                    ],
                    [
                        121,
                        122,
                        123,
                        124,
                        125,
                        126,
                        127,
                        128,
                        129,
                        130,
                        131,
                        132,
                        133,
                        134,
                        135
                    ],
                    [
                        136,
                        137,
                        138,
                        139,
                        140,
                        141,
                        142,
                        143,
                        144,
                        145,
                        146,
                        147,
                        148,
                        149,
                        150
                    ],
                    [
                        151,
                        152,
                        153,
                        154,
                        155,
                        156,
                        157,
                        158,
                        159,
                        160,
                        161,
                        162,
                        163,
                        164,
                        165
                    ],
                    [
                        166,
                        167,
                        168,
                        169,
                        170,
                        171,
                        172,
                        173,
                        174,
                        175,
                        176,
                        177,
                        178,
                        179,
                        180
                    ],
                    [
                        181,
                        182,
                        183,
                        184,
                        185,
                        186,
                        187,
                        188,
                        189,
                        190,
                        191,
                        192,
                        193,
                        194,
                        195
                    ],
                    [
                        196,
                        197,
                        198,
                        199,
                        200,
                        201,
                        202,
                        203,
                        204,
                        205,
                        206,
                        207,
                        208,
                        209,
                        210
                    ],
                    [
                        211,
                        212,
                        213,
                        214,
                        215,
                        216,
                        217,
                        218,
                        219,
                        220,
                        221,
                        222,
                        223,
                        224,
                        225
                    ]
                ]
            ],
            "outputs": [
                "[[7,4,1],[8,5,2],[9,6,3]]",
                "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
                "[[1]]",
                "[[3,1],[4,2]]",
                "[[13,9,5,1],[14,10,6,2],[15,11,7,3],[16,12,8,4]]",
                "[[21,16,11,6,1],[22,17,12,7,2],[23,18,13,8,3],[24,19,14,9,4],[25,20,15,10,5]]",
                "[[31,25,19,13,7,1],[32,26,20,14,8,2],[33,27,21,15,9,3],[34,28,22,16,10,4],[35,29,23,17,11,5],[36,30,24,18,12,6]]",
                "[[49,42,35,28,21,14,7],[50,43,36,29,22,15,8],[51,44,37,30,23,16,9],[52,45,38,31,24,17,10],[53,46,39,32,25,18,11],[54,47,40,33,26,19,12],[55,48,41,34,27,20,13]]",
                "[[64,57,50,43,36,29,22,15],[65,58,51,44,37,30,23,16],[66,59,52,45,38,31,24,17],[67,60,53,46,39,32,25,18],[68,61,54,47,40,33,26,19],[69,62,55,48,41,34,27,20],[70,63,56,49,42,35,28,21],[71,64,57,50,43,36,29,22]]",
                "[[81,73,65,57,49,41,33,25,17,9],[82,74,66,58,50,42,34,26,18,10],[83,75,67,59,51,43,35,27,19,11],[84,76,68,60,52,44,36,28,20,12],[85,77,69,61,53,45,37,29,21,13],[86,78,70,62,54,46,38,30,22,14],[87,79,71,63,55,47,39,31,23,15],[88,80,72,64,56,48,40,32,24,16]]",
                "[[100,91,82,73,64,55,46,37,28,19,10],[101,92,83,74,65,56,47,38,29,20,11],[102,93,84,75,66,57,48,39,30,21,12],[103,94,85,76,67,58,49,40,31,22,13],[104,95,86,77,68,59,50,41,32,23,14],[105,96,87,78,69,60,51,42,33,24,15],[106,97,88,79,70,61,52,43,34,25,16],[107,98,89,80,71,62,53,44,35,26,17],[108,99,90,81,72,63,54,45,36,27,18],[109,100,91,82,73,64,55,46,37,28,19]]",
                "[[121,111,101,91,81,71,61,51,41,31,21,11],[122,112,102,92,82,72,62,52,42,32,22,12],[123,113,103,93,83,73,63,53,43,33,23,13],[124,114,104,94,84,74,64,54,44,34,24,14],[125,115,105,95,85,75,65,55,45,35,25,15],[126,116,106,96,86,76,66,56,46,36,26,16],[127,117,107,97,87,77,67,57,47,37,27,17],[128,118,108,98,88,78,68,58,48,38,28,18],[129,119,109,99,89,79,69,59,49,39,29,19],[130,120,110,100,90,80,70,60,50,40,30,20],[131,121,111,101,91,81,71,61,51,41,31,21]]",
                "[[144,133,122,111,100,89,78,67,56,45,34,23,12],[145,134,123,112,101,90,79,68,57,46,35,24,13],[146,135,124,113,102,91,80,69,58,47,36,25,14],[147,136,125,114,103,92,81,70,59,48,37,26,15],[148,137,126,115,104,93,82,71,60,49,38,27,16],[149,138,127,116,105,94,83,72,61,50,39,28,17],[150,139,128,117,106,95,84,73,62,51,40,29,18],[151,140,129,118,107,96,85,74,63,52,41,30,19],[152,141,130,119,108,97,86,75,64,53,42,31,20],[153,142,131,120,109,98,87,76,65,54,43,32,21],[154,143,132,121,110,99,88,77,66,55,44,33,22],[155,144,133,122,111,100,89,78,67,56,45,34,23]]",
                "[[169,157,145,133,121,109,97,85,73,61,49,37,25,13],[170,158,146,134,122,110,98,86,74,62,50,38,26,14],[171,159,147,135,123,111,99,87,75,63,51,39,27,15],[172,160,148,136,124,112,100,88,76,64,52,40,28,16],[173,161,149,137,125,113,101,89,77,65,53,41,29,17],[174,162,150,138,126,114,102,90,78,66,54,42,30,18],[175,163,151,139,127,115,103,91,79,67,55,43,31,19],[176,164,152,140,128,116,104,92,80,68,56,44,32,20],[177,165,153,141,129,117,105,93,81,69,57,45,33,21],[178,166,154,142,130,118,106,94,82,70,58,46,34,22],[179,167,155,143,131,119,107,95,83,71,59,47,35,23],[180,168,156,144,132,120,108,96,84,72,60,48,36,24],[181,169,157,145,133,121,109,97,85,73,61,49,37,25]]",
                "[[196,183,170,157,144,131,118,105,92,79,66,53,40,27,14],[197,184,171,158,145,132,119,106,93,80,67,54,41,28,15],[198,185,172,159,146,133,120,107,94,81,68,55,42,29,16],[199,186,173,160,147,134,121,108,95,82,69,56,43,30,17],[200,187,174,161,148,135,122,109,96,83,70,57,44,31,18],[201,188,175,162,149,136,123,110,97,84,71,58,45,32,19],[202,189,176,163,150,137,124,111,98,85,72,59,46,33,20],[203,190,177,164,151,138,125,112,99,86,73,60,47,34,21],[204,191,178,165,152,139,126,113,100,87,74,61,48,35,22],[205,192,179,166,153,140,127,114,101,88,75,62,49,36,23],[206,193,180,167,154,141,128,115,102,89,76,63,50,37,24],[207,194,181,168,155,142,129,116,103,90,77,64,51,38,25],[208,195,182,169,156,143,130,117,104,91,78,65,52,39,26]]",
                "[[225,210,195,180,165,150,135,120,105,90,75,60,45,30,15],[226,211,196,181,166,151,136,121,106,91,76,61,46,31,16],[227,212,197,182,167,152,137,122,107,92,77,62,47,32,17],[228,213,198,183,168,153,138,123,108,93,78,63,48,33,18],[229,214,199,184,169,154,139,124,109,94,79,64,49,34,19],[230,215,200,185,170,155,140,125,110,95,80,65,50,35,20],[231,216,201,186,171,156,141,126,111,96,81,66,51,36,21],[232,217,202,187,172,157,142,127,112,97,82,67,52,37,22],[233,218,203,188,173,158,143,128,113,98,83,68,53,38,23],[234,219,204,189,174,159,144,129,114,99,84,69,54,39,24],[235,220,205,190,175,160,145,130,115,100,85,70,55,40,25],[236,221,206,191,176,161,146,131,116,101,86,71,56,41,26],[237,222,207,192,177,162,147,132,117,102,87,72,57,42,27],[238,223,208,193,178,163,148,133,118,103,88,73,58,43,28],[239,224,209,194,179,164,149,134,119,104,89,74,59,44,29]]"
            ]
        },
        "sample_code": {
            "c++": "void rotate(vector<vector<int>>& matrix) {\n    int n = matrix.size();\n    for (int i = 0; i < n / 2; i++) {\n        for (int j = i; j < n - i - 1; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[n - j - 1][i];\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n            matrix[j][n - i - 1] = temp;\n        }\n    }\n}\n",
            "java": "public void rotate(int[][] matrix) {\n    int n = matrix.length;\n    for (int i = 0; i < n / 2; i++) {\n        for (int j = i; j < n - i - 1; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[n - j - 1][i];\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n            matrix[j][n - i - 1] = temp;\n        }\n    }\n}\n",
            "python": "def rotate(matrix):\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n",
            "javascript": "function rotate(matrix) {\n    let n = matrix.length;\n    for (let i = 0; i < Math.floor(n / 2); i++) {\n        for (let j = i; j < n - i - 1; j++) {\n            let temp = matrix[i][j];\n            matrix[i][j] = matrix[n - j - 1][i];\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n            matrix[j][n - i - 1] = temp;\n        }\n    }\n}\n",
            "explanation": "The algorithm iterates over each layer of the matrix gradually working inwards. For each element in the current layer, it performs a 4-way swap (moving elements from left -> top, bottom -> left, right -> bottom, and top -> right). This moves each element in the layer to its new position after rotation without using any additional memory. The algorithm proceeds with this strategy until it reaches the center of the matrix, ensuring that all elements are correctly rotated."
        },
        "structure": {
            "c++": "void rotate(vector<vector<int>>& matrix)  {\n    // Your code here\n}\n",
            "java": "public void rotate(int[][] matrix)  {\n    // Your code here\n}\n",
            "python": "def rotate(matrix):\n    # Your code here\n\n",
            "javascript": "function rotate(matrix)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid rotate(vector<vector<int>>& matrix) {\n    int n = matrix.size();\n    for (int i = 0; i < n / 2; i++) {\n        for (int j = i; j < n - i - 1; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[n - j - 1][i];\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n            matrix[j][n - i - 1] = temp;\n        }\n    }\n}\n\nint main() {\n    vector<vector<int>> matrix = $args;\n    rotate(matrix);\n    for (int i = 0; i < matrix.size(); i++) {\n        for (int j = 0; j < matrix[i].size(); j++) {\n            cout << matrix[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
            "java": "public void rotate(int[][] matrix) {\n    int n = matrix.length;\n    for (int i = 0; i < n / 2; i++) {\n        for (int j = i; j < n - i - 1; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[n - j - 1][i];\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n            matrix[j][n - i - 1] = temp;\n        }\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    matrix = $args\n    rotate(matrix)\n    print(matrix)",
            "javascript": "function main() {\n    let matrix = $args;\n    rotate(matrix);\n    console.log(matrix);\n}\n\nmain();"
        },
        "Qid": "48",
        "languages verified": [
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d4215949b33b6c4e2b08f"
        },
        "title": "Group Anagrams",
        "description": "Given an array of strings `strs`, group the anagrams together. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Return the groups of anagrams in any order.",
        "example": "Example:\n\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\nInput: strs = [\"\"]\nOutput: [[\"\"]]\n\nInput: strs = [\"a\"]\nOutput: [[\"a\"]]",
        "level": "Easy",
        "tags": [
            "Array",
            "String",
            "Sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    "eat",
                    "tea",
                    "tan",
                    "ate",
                    "nat",
                    "bat"
                ],
                [
                    ""
                ],
                [
                    "a"
                ],
                [
                    "abc",
                    "cba",
                    "bca",
                    "def",
                    "fed",
                    "edf"
                ],
                [
                    "cat",
                    "dog",
                    "tac",
                    "god",
                    "act"
                ],
                [
                    "abcd",
                    "dcba",
                    "efgh",
                    "hgfe",
                    "ijkl",
                    "lkji"
                ],
                [
                    "abcd",
                    "dcba",
                    "efgh",
                    "hgfe",
                    "ijkl",
                    "lkji",
                    "mnop",
                    "opnm"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz",
                    "cba",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz",
                    "cba",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx",
                    "bac",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz",
                    "cba",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx",
                    "bac",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx",
                    "cab",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz",
                    "cba",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx",
                    "bac",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx",
                    "cab",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz",
                    "bca",
                    "edf",
                    "hgi",
                    "klj",
                    "mon",
                    "prq",
                    "sut",
                    "xwv",
                    "yzz"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz",
                    "cba",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx",
                    "bac",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx",
                    "cab",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz",
                    "bca",
                    "edf",
                    "hgi",
                    "klj",
                    "mon",
                    "prq",
                    "sut",
                    "xwv",
                    "yzz",
                    "acb",
                    "dfe",
                    "gih",
                    "jlk",
                    "omn",
                    "qpr",
                    "tsu",
                    "vxw",
                    "zyx"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz",
                    "cba",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx",
                    "bac",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx",
                    "cab",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz",
                    "bca",
                    "edf",
                    "hgi",
                    "klj",
                    "mon",
                    "prq",
                    "sut",
                    "xwv",
                    "yzz",
                    "acb",
                    "dfe",
                    "gih",
                    "jlk",
                    "omn",
                    "qpr",
                    "tsu",
                    "vxw",
                    "zyx",
                    "bca",
                    "edf",
                    "hgi",
                    "klj",
                    "mon",
                    "prq",
                    "sut",
                    "xwv",
                    "yzz"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz",
                    "cba",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx",
                    "bac",
                    "fed",
                    "ihg",
                    "lkj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx",
                    "cab",
                    "def",
                    "ghi",
                    "jkl",
                    "mno",
                    "pqr",
                    "stu",
                    "vwx",
                    "yz",
                    "bca",
                    "edf",
                    "hgi",
                    "klj",
                    "mon",
                    "prq",
                    "sut",
                    "xwv",
                    "yzz",
                    "acb",
                    "dfe",
                    "gih",
                    "jlk",
                    "omn",
                    "qpr",
                    "tsu",
                    "vxw",
                    "zyx",
                    "bca",
                    "edf",
                    "hgi",
                    "klj",
                    "mon",
                    "prq",
                    "sut",
                    "xwv",
                    "yzz",
                    "cba",
                    "fed",
                    "ihg",
                    "klj",
                    "onm",
                    "qrp",
                    "uts",
                    "xwv",
                    "zyx"
                ]
            ],
            "outputs": [
                "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
                "[[\"\"]]",
                "[[\"a\"]]",
                "[[\"abc\",\"cba\",\"bca\"],[\"def\",\"fed\",\"edf\"]]",
                "[[\"cat\",\"tac\",\"act\"],[\"dog\",\"god\"]]",
                "[[\"abcd\",\"dcba\"],[\"efgh\",\"hgfe\"],[\"ijkl\",\"lkji\"]]",
                "[[\"abcd\",\"dcba\"],[\"efgh\",\"hgfe\"],[\"ijkl\",\"lkji\"],[\"mnop\",\"opnm\"]]",
                "[[\"abc\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"]]",
                "[[\"abc\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"],[\"cba\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"]]",
                "[[\"abc\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"],[\"cba\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"],[\"bac\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"]]",
                "[[\"abc\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"],[\"cba\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"],[\"bac\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"],[\"cab\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"]]",
                "[[\"abc\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"],[\"cba\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"],[\"bac\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"],[\"cab\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"],[\"bca\"],[\"edf\"],[\"hgi\"],[\"klj\"],[\"mon\"],[\"prq\"],[\"sut\"],[\"xwv\"],[\"yzz\"]]",
                "[[\"abc\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"],[\"cba\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"],[\"bac\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"],[\"cab\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"],[\"bca\"],[\"edf\"],[\"hgi\"],[\"klj\"],[\"mon\"],[\"prq\"],[\"sut\"],[\"xwv\"],[\"yzz\"],[\"acb\"],[\"dfe\"],[\"gih\"],[\"jlk\"],[\"omn\"],[\"qpr\"],[\"tsu\"],[\"vxw\"],[\"zyx\"]]",
                "[[\"abc\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"],[\"cba\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"],[\"bac\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"],[\"cab\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"],[\"bca\"],[\"edf\"],[\"hgi\"],[\"klj\"],[\"mon\"],[\"prq\"],[\"sut\"],[\"xwv\"],[\"yzz\"],[\"acb\"],[\"dfe\"],[\"gih\"],[\"jlk\"],[\"omn\"],[\"qpr\"],[\"tsu\"],[\"vxw\"],[\"zyx\"],[\"bca\"],[\"edf\"],[\"hgi\"],[\"klj\"],[\"mon\"],[\"prq\"],[\"sut\"],[\"xwv\"],[\"yzz\"]]",
                "[[\"abc\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"],[\"cba\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"],[\"bac\"],[\"fed\"],[\"ihg\"],[\"lkj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"],[\"cab\"],[\"def\"],[\"ghi\"],[\"jkl\"],[\"mno\"],[\"pqr\"],[\"stu\"],[\"vwx\"],[\"yz\"],[\"bca\"],[\"edf\"],[\"hgi\"],[\"klj\"],[\"mon\"],[\"prq\"],[\"sut\"],[\"xwv\"],[\"yzz\"],[\"acb\"],[\"dfe\"],[\"gih\"],[\"jlk\"],[\"omn\"],[\"qpr\"],[\"tsu\"],[\"vxw\"],[\"zyx\"],[\"bca\"],[\"edf\"],[\"hgi\"],[\"klj\"],[\"mon\"],[\"prq\"],[\"sut\"],[\"xwv\"],[\"yzz\"],[\"cba\"],[\"fed\"],[\"ihg\"],[\"klj\"],[\"onm\"],[\"qrp\"],[\"uts\"],[\"xwv\"],[\"zyx\"]]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nstd::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) {\n    std::map<std::string, std::vector<std::string>> anagramMap;\n\n    for (std::string str : strs) {\n        std::string key = str;\n        std::sort(key.begin(), key.end());\n        anagramMap[key].push_back(str);\n    }\n\n    std::vector<std::vector<std::string>> result;\n    for (auto &entry : anagramMap) {\n        result.push_back(entry.second);\n    }\n\n    return result;\n}\n",
            "java": "import java.util.*;\n\npublic List<List<String>> groupAnagrams(String[] strs) {\n    Map<String, List<String>> anagramMap = new HashMap<>();\n\n    for (String str : strs) {\n        char[] keyChars = str.toCharArray();\n        Arrays.sort(keyChars);\n        String key = new String(keyChars);\n\n        anagramMap.putIfAbsent(key, new ArrayList<>());\n        anagramMap.get(key).add(str);\n    }\n\n    return new ArrayList<>(anagramMap.values());\n}\n",
            "python": "from collections import defaultdict\n\ndef group_anagrams(strs):\n    anagram_map = defaultdict(list)\n\n    for s in strs:\n        key = ''.join(sorted(s))\n        anagram_map[key].append(s)\n\n    return list(anagram_map.values())\n",
            "javascript": "function groupAnagrams(strs) {\n    const anagramMap = new Map();\n\n    for (const str of strs) {\n        const key = str.split('').sort().join('');\n\n        if (!anagramMap.has(key)) {\n            anagramMap.set(key, []);\n        }\n        anagramMap.get(key).push(str);\n    }\n\n    return Array.from(anagramMap.values());\n}\n",
            "explanation": "The algorithm iterates through the input array of strings. For each string, create a sorted version of the string as key, and store the original strings as values. Use a data structure like a map or dictionary to store the grouped anagrams in these key-value pairs. The keys will represent the different anagrams, while the values will be lists of the original strings that fit the anagram. Finally, extract the values (lists of anagrams) from the map or dictionary and return them. This works because anagrams will produce the same sorted strings as keys."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nstd::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs)  {\n    // Your code here\n}\n",
            "java": "import java.util.*;\n\npublic List<List<String>> groupAnagrams(String[] strs)  {\n    // Your code here\n}\n",
            "python": "from collections import defaultdict\n    # Your code here\n\n",
            "javascript": "function groupAnagrams(strs)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nstd::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) {\n    std::map<std::string, std::vector<std::string>> anagramMap;\n\n    for (std::string str : strs) {\n        std::string key = str;\n        std::sort(key.begin(), key.end());\n        anagramMap[key].push_back(str);\n    }\n\n    std::vector<std::vector<std::string>> result;\n    for (auto &entry : anagramMap) {\n        result.push_back(entry.second);\n    }\n\n    return result;\n}\n\nint main() {\n    std::vector<std::string> strs = $args;\n    std::vector<std::vector<std::string>> result = groupAnagrams(strs);\n\n    for (const auto& group : result) {\n        for (const auto& str : group) {\n            std::cout << str << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}",
            "java": "public List<List<String>> groupAnagrams(String[] strs) {\n    Map<String, List<String>> anagramMap = new HashMap<>();\n\n    for (String str : strs) {\n        char[] keyChars = str.toCharArray();\n        Arrays.sort(keyChars);\n        String key = new String(keyChars);\n\n        anagramMap.putIfAbsent(key, new ArrayList<>());\n        anagramMap.get(key).add(str);\n    }\n\n    return new ArrayList<>(anagramMap.values());\n}",
            "python": "if __name__ == \"__main__\":\n    strs = $args\n    result = group_anagrams(strs)\n    print(result)",
            "javascript": "function main() {\n    let strs = $args;\n    let result = groupAnagrams(strs);\n\n    for (const group of result) {\n        console.log(group.join(' '));\n    }\n}\n\nmain();"
        },
        "Qid": "49",
        "languages verified": [
            "python"
        ]
    },
    {
        "_id": {
            "$oid": "661d44ba949b33b6c4e2b090"
        },
        "title": "Power Function",
        "description": "Write a function `power(x, n)` that calculates `x` raised to the power `n` (i.e., `x^n`). Implement the function using the given description.",
        "example": "Example:\n\nInput: x = 2.00000, n = 10\nOutput: 1024.00000\n\nInput: x = 2.10000, n = 3\nOutput: 9.26100\n\nInput: x = 2.00000, n = -2\nOutput: 0.25000\nExplanation: 2^-2 = 1/2^2 = 1/4 = 0.25",
        "level": "Medium",
        "tags": [
            "math",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    10
                ],
                [
                    2.1,
                    3
                ],
                [
                    2,
                    -2
                ],
                [
                    0.5,
                    0
                ],
                [
                    10,
                    5
                ],
                [
                    3,
                    4
                ],
                [
                    1.5,
                    7
                ],
                [
                    4,
                    -3
                ],
                [
                    0,
                    10
                ],
                [
                    1,
                    100
                ],
                [
                    -2,
                    5
                ],
                [
                    -3,
                    3
                ],
                [
                    -1.5,
                    6
                ],
                [
                    -4,
                    -2
                ],
                [
                    0.5,
                    -3
                ],
                [
                    1,
                    0
                ],
                [
                    2,
                    1
                ],
                [
                    3,
                    0
                ],
                [
                    4,
                    1
                ],
                [
                    5,
                    2
                ]
            ],
            "outputs": [
                1024,
                9.261,
                0.25,
                1,
                100000,
                81,
                133.875,
                -0.015625,
                0,
                1,
                -32,
                -27,
                64.5,
                0.0625,
                8,
                1,
                2,
                1,
                4,
                25
            ]
        },
        "sample_code": {
            "c++": "double myPow(double x, int n) {\n    if (n == 0) return 1;\n    if (n < 0) {\n        x = 1 / x;\n        n = -n;\n    }\n    double result = 1;\n    double currentProduct = x;\n    for (long long i = n; i; i /= 2) {\n        if ((i % 2) == 1) {\n            result = result * currentProduct;\n        }\n        currentProduct = currentProduct * currentProduct;\n    }\n    return result;\n}\n",
            "java": "double myPow(double x, int n) {\n    if (n == 0) return 1;\n    if (n < 0) {\n        x = 1 / x;\n        n = -n;\n    }\n    double result = 1;\n    double currentProduct = x;\n    for (long i = n; i > 0; i /= 2) {\n        if ((i % 2) == 1) {\n            result *= currentProduct;\n        }\n        currentProduct *= currentProduct;\n    }\n    return result;\n}\n",
            "python": "def myPow(x: float, n: int) -> float:\n    if n == 0:\n        return 1\n    if n < 0:\n        x = 1 / x\n        n = -n\n    result = 1\n    currentProduct = x\n    i = n\n    while i:\n        if i % 2 == 1:\n            result *= currentProduct\n        currentProduct *= currentProduct\n        i //= 2\n    return result\n",
            "javascript": "function myPow(x, n) {\n    if (n === 0) return 1;\n    if (n < 0) {\n        x = 1 / x;\n        n = -n;\n    }\n    let result = 1;\n    let currentProduct = x;\n    for (let i = n; i > 0; i = Math.floor(i / 2)) {\n        if (i % 2 === 1) {\n            result *= currentProduct;\n        }\n        currentProduct *= currentProduct;\n    }\n    return result;\n}\n",
            "explanation": "The algorithm uses the binary exponentiation technique, which is a faster method of calculating x^n compared to the naive approach. It relies on the process of repeatedly multiplying the current product by itself and updating it after each iteration. The loop iterates through the bits of the exponent n, from the least significant to the most significant. If the current bit of n is 1, the result is multiplied by the current product. At the end of the loop, the current product is updated by squaring it. This process continues until all bits of the exponent have been processed.\n\nThe time complexity of the algorithm is O(log(n)) because the loop iterates through the bits of n, and the number of bits in n is proportional to the logarithm of n. The space complexity is O(1), as the space used by the temporary variables does not depend on the size of n."
        },
        "structure": {
            "c++": "double myPow(double x, int n)  {\n    // Your code here\n}\n",
            "java": "double myPow(double x, int n)  {\n    // Your code here\n}\n",
            "python": "def myPow(x: float, n: int) -> float:\n    # Your code here\n\n",
            "javascript": "function myPow(x, n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\ndouble myPow(double x, int n) {\n    if (n == 0) return 1;\n    if (n < 0) {\n        x = 1 / x;\n        n = -n;\n    }\n    double result = 1;\n    double currentProduct = x;\n    for (long long i = n; i; i /= 2) {\n        if ((i % 2) == 1) {\n            result = result * currentProduct;\n        }\n        currentProduct = currentProduct * currentProduct;\n    }\n    return result;\n}\n\nint main() {\n    double x = $args;\n    int n = $args;\n    double result = myPow(x, n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    double x = $args[0];\n    int n = $args[1];\n    double result = myPow(x, n);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    x = inputs[0]\n    n = inputs[1]\n    result = myPow(x, n)\n    print(result)",
            "javascript": "function main() {\n    let input = $args;\n    const x = input[0];\n    const n = input[1];\n    let result = myPow(x, n);\n    console.log(result);\n}\n\nmain();"
        },
        "Qid": "50",
        "languages verified": [
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d45f8949b33b6c4e2b091"
        },
        "title": "N-Queens Puzzle",
        "description": "The N-Queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the N-Queens puzzle. Each solution contains a distinct board configuration of the N-Queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.",
        "example": "Example:\n\nInput: n = 4\nOutput: [['.Q..', '...Q', 'Q...', '..Q.'], ['..Q.', 'Q...', '...Q', '.Q..']]\nExplanation: There exist two distinct solutions to the 4-Queens puzzle as shown above.",
        "level": "Medium",
        "tags": [
            "backtracking",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                4,
                1,
                2,
                3,
                5
            ],
            "outputs": [
                [
                    [
                        ".Q..",
                        "...Q",
                        "Q...",
                        "..Q."
                    ],
                    [
                        "..Q.",
                        "Q...",
                        "...Q",
                        ".Q.."
                    ]
                ],
                [
                    [
                        "Q"
                    ]
                ],
                [],
                [],
                []
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n\nbool isSafe(const std::vector<std::string>& board, int row, int col, int n) {\n    for (int i = 0; i < col; ++i) {\n        if (board[row][i] == 'Q') return false;\n    }\n    for (int i = row, j = col; i >= 0 && j >= 0; --i, --j) {\n        if (board[i][j] == 'Q') return false;\n    }\n    for (int i = row, j = col; i < n && j >= 0; ++i, --j) {\n        if (board[i][j] == 'Q') return false;\n    }\n    return true;\n}\n\nvoid solve(std::vector<std::vector<std::string>>& result, std::vector<std::string>& board, int n, int col) {\n    if (col == n) {\n        result.push_back(board);\n        return;\n    }\n    for (int row = 0; row < n; ++row) {\n        if (isSafe(board, row, col, n)) {\n            board[row][col] = 'Q';\n            solve(result, board, n, col + 1);\n            board[row][col] = '.';\n        }\n    }\n}\n\nstd::vector<std::vector<std::string>> solveNQueens(int n) {\n    std::vector<std::vector<std::string>> result;\n    std::vector<std::string> board(n, std::string(n, '.'));\n    solve(result, board, n, 0);\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<String>> solveNQueens(int n) {\n    List<List<String>> result = new ArrayList<>();\n    solve(result, new ArrayList<>(), n, 0);\n    return result;\n}\n\nprivate void solve(List<List<String>> result, List<Integer> current, int n, int col) {\n    if (col == n) {\n        result.add(generateBoard(current, n));\n        return;\n    }\n    for (int row = 0; row < n; row++) {\n        if(isSafe(current, row, col)) {\n            current.add(row);\n            solve(result, current, n, col + 1);\n            current.remove(col);\n        }\n    }\n}\n\nprivate boolean isSafe(List<Integer> current, int row, int col) {\n    for (int i = 0; i < col; i++) {\n        int prevRow = current.get(i);\n        if (prevRow == row || (Math.abs(col - i) == Math.abs(row - prevRow))) {\n            return false;\n        }\n    }\n    return true;\n}\n\nprivate List<String> generateBoard(List<Integer> current, int n) {\n    List<String> board = new ArrayList<>();\n    for (int row : current) {\n        StringBuilder sb = new StringBuilder();\n        for (int col = 0; col < n; col++)\n            sb.append((col == row) ? \"Q\" : \".\");\n        board.add(sb.toString());\n    }\n    return board;\n}\n",
            "python": "def solveNQueens(n):\n    def isSafe(board, row, col):\n        for i in range(col):\n            if board[row][i] == 'Q': return False\n        i, j = row, col\n        while i >= 0 and j >= 0:\n            if board[i][j] == 'Q': return False\n            i, j = i - 1, j - 1\n        i, j = row, col\n        while i < n and j >= 0:\n            if board[i][j] == 'Q': return False\n            i, j = i + 1, j - 1\n        return True\n\n    def solve(result, board, n, col):\n        if col == n:\n            result.append(board.copy())\n            return\n        for row in range(n):\n            if isSafe(board, row, col):\n                board[row] = board[row][:col] + 'Q' + board[row][col + 1:]\n                solve(result, board, n, col + 1)\n                board[row] = board[row][:col] + '.' + board[row][col + 1:]\n\n    result, board = [], ['.' * n for _ in range(n)]\n    solve(result, board, n, 0)\n    return result\n",
            "javascript": "function solveNQueens(n) {\n  function isSafe(board, row, col) {\n    for (let i = 0; i < col; i++)\n      if (board[row][i] == 'Q') return false;\n    for (let i = row, j = col; i >= 0 && j >= 0; i--, j--)\n      if (board[i][j] == 'Q') return false;\n    for (let i = row, j = col; i < n && j >= 0; i++, j--)\n      if (board[i][j] == 'Q') return false;\n    return true;\n  }\n\n  function solve(result, board, n, col) {\n    if (col == n) {\n      result.push(board.map(row => row.join('')));\n      return;\n    }\n    for (let row = 0; row < n; row++) {\n      if (isSafe(board, row, col)) {\n        board[row][col] = 'Q';\n        solve(result, board, n, col + 1);\n        board[row][col] = '.';\n      }\n    }\n  }\n\n  const result = [];\n  const board = Array.from({ length: n }, () => Array(n).fill('.'));\n  solve(result, board, n, 0);\n  return result;\n}\n",
            "explanation": "The algorithm uses the backtracking approach to solve the N-Queens puzzle. The idea is to place queens one by one in different columns, starting from the leftmost column. When placing a queen, check if that position is safe from all previously placed queens in terms of the horizontal, diagonal, and anti-diagonal directions. If the selected position is safe, move on to the next column and try to place another queen there. If no safe positions are found in the current column, then go back to the previous column and move the queen to another safe position. Repeat this process until all queens are placed in a valid configuration or all possible arrangements have been tried. During the process, whenever we successfully place `n` queens on the board, add that configuration to our result list. Finally, return the list of all unique solutions found."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n\nbool isSafe(const std::vector<std::string>& board, int row, int col, int n)  {\n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<String>> solveNQueens(int n)  {\n    // Your code here\n}\n",
            "python": "def solveNQueens(n):\n    # Your code here\n\n",
            "javascript": "function solveNQueens(n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "std::vector<std::vector<std::string>> solveNQueens(int n) {\n    std::vector<std::vector<std::string>> result;\n    std::vector<std::string> board(n, std::string(n, '.'));\n    solve(result, board, n, 0);\n    return result;\n}",
            "java": "public List<List<String>> solveNQueens(int n) {\n    List<List<String>> result = new ArrayList<>();\n    solve(result, new ArrayList<>(), n, 0);\n    return result;\n}\n\nprivate void solve(List<List<String>> result, List<Integer> current, int n, int col) {\n    if (col == n) {\n        result.add(generateBoard(current, n));\n        return;\n    }\n    for (int row = 0; row < n; row++) {\n        if(isSafe(current, row, col)) {\n            current.add(row);\n            solve(result, current, n, col + 1);\n            current.remove(col);\n        }\n    }\n}\n\nprivate boolean isSafe(List<Integer> current, int row, int col) {\n    for (int i = 0; i < col; i++) {\n        int prevRow = current.get(i);\n        if (prevRow == row || (Math.abs(col - i) == Math.abs(row - prevRow))) {\n            return false;\n        }\n    }\n    return true;\n}\n\nprivate List<String> generateBoard(List<Integer> current, int n) {\n    List<String> board = new ArrayList<>();\n    for (int row : current) {\n        StringBuilder sb = new StringBuilder();\n        for (int col = 0; col < n; col++)\n            sb.append((col == row) ? \"Q\" : \".\");\n        board.add(sb.toString());\n    }\n    return board;\n}",
            "python": "if __name__ == \"__main__\":\n    input=$args\n    result = solveNQueens(input)\n    print(result)",
            "javascript": "function main() {\n    let input = $args;\n    let result = solveNQueens(input);\n    console.log(result);\n}\n\nmain();"
        },
        "Qid": "51",
        "languages verified": [
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d4714949b33b6c4e2b092"
        },
        "title": "Spiral Matrix",
        "description": "Given an `m x n` matrix, return all elements of the matrix in spiral order.",
        "example": "Example 1:\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]\n\nExample 2:\n\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]",
        "level": "Medium",
        "tags": [
            "array",
            "matrix",
            "spiral"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9
                    ],
                    [
                        10,
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        3
                    ],
                    [
                        4
                    ],
                    [
                        5
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        30
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65,
                        66,
                        67,
                        68,
                        69,
                        70
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65,
                        66,
                        67,
                        68,
                        69,
                        70
                    ],
                    [
                        71,
                        72,
                        73,
                        74,
                        75,
                        76,
                        77,
                        78,
                        79,
                        80
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65,
                        66,
                        67,
                        68,
                        69,
                        70
                    ],
                    [
                        71,
                        72,
                        73,
                        74,
                        75,
                        76,
                        77,
                        78,
                        79,
                        80
                    ],
                    [
                        81,
                        82,
                        83,
                        84,
                        85,
                        86,
                        87,
                        88,
                        89,
                        90
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                        27,
                        28,
                        29,
                        30
                    ],
                    [
                        31,
                        32,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        39,
                        40
                    ],
                    [
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50
                    ],
                    [
                        51,
                        52,
                        53,
                        54,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60
                    ],
                    [
                        61,
                        62,
                        63,
                        64,
                        65,
                        66,
                        67,
                        68,
                        69,
                        70
                    ],
                    [
                        71,
                        72,
                        73,
                        74,
                        75,
                        76,
                        77,
                        78,
                        79,
                        80
                    ],
                    [
                        81,
                        82,
                        83,
                        84,
                        85,
                        86,
                        87,
                        88,
                        89,
                        90
                    ],
                    [
                        91,
                        92,
                        93,
                        94,
                        95,
                        96,
                        97,
                        98,
                        99,
                        100
                    ]
                ]
            ],
            "outputs": [
                [
                    1,
                    2,
                    3,
                    6,
                    9,
                    8,
                    7,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    8,
                    12,
                    11,
                    10,
                    9,
                    5,
                    6,
                    7
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    10,
                    15,
                    20,
                    19,
                    18,
                    17,
                    16,
                    11,
                    6,
                    7,
                    8,
                    9,
                    14,
                    13,
                    12
                ],
                [
                    1,
                    2,
                    3,
                    6,
                    9,
                    12,
                    11,
                    10,
                    7,
                    4,
                    5,
                    8
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    4,
                    6,
                    8,
                    10,
                    9,
                    7,
                    5,
                    3
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    10,
                    15,
                    14,
                    13,
                    12,
                    11,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    30,
                    29,
                    28,
                    27,
                    26,
                    25,
                    24,
                    23,
                    22,
                    21
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    30,
                    40,
                    39,
                    38,
                    37,
                    36,
                    35,
                    34,
                    33,
                    32,
                    31,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    30,
                    40,
                    50,
                    49,
                    48,
                    47,
                    46,
                    45,
                    44,
                    43,
                    42,
                    41,
                    31,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    39,
                    38,
                    37,
                    36,
                    35,
                    34,
                    33,
                    32
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    30,
                    40,
                    50,
                    60,
                    59,
                    58,
                    57,
                    56,
                    55,
                    54,
                    53,
                    52,
                    51,
                    41,
                    31,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    39,
                    49,
                    48,
                    47,
                    46,
                    45,
                    44,
                    43,
                    42,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    69,
                    68,
                    67,
                    66,
                    65,
                    64,
                    63,
                    62,
                    61,
                    51,
                    41,
                    31,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    39,
                    49,
                    59,
                    58,
                    57,
                    56,
                    55,
                    54,
                    53,
                    52,
                    42,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    48,
                    47,
                    46,
                    45,
                    44,
                    43
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    79,
                    78,
                    77,
                    76,
                    75,
                    74,
                    73,
                    72,
                    71,
                    61,
                    51,
                    41,
                    31,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    39,
                    49,
                    59,
                    69,
                    68,
                    67,
                    66,
                    65,
                    64,
                    63,
                    62,
                    52,
                    42,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    48,
                    58,
                    57,
                    56,
                    55,
                    54,
                    53,
                    43,
                    44,
                    45,
                    46,
                    47
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    89,
                    88,
                    87,
                    86,
                    85,
                    84,
                    83,
                    82,
                    81,
                    71,
                    61,
                    51,
                    41,
                    31,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    39,
                    49,
                    59,
                    69,
                    79,
                    78,
                    77,
                    76,
                    75,
                    74,
                    73,
                    72,
                    62,
                    52,
                    42,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    48,
                    58,
                    68,
                    67,
                    66,
                    65,
                    64,
                    63,
                    53,
                    43,
                    44,
                    45,
                    46,
                    47,
                    57,
                    56,
                    55,
                    54
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100,
                    99,
                    98,
                    97,
                    96,
                    95,
                    94,
                    93,
                    92,
                    91,
                    81,
                    71,
                    61,
                    51,
                    41,
                    31,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    39,
                    49,
                    59,
                    69,
                    79,
                    89,
                    88,
                    87,
                    86,
                    85,
                    84,
                    83,
                    82,
                    72,
                    62,
                    52,
                    42,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    48,
                    58,
                    68,
                    78,
                    77,
                    76,
                    75,
                    74,
                    73,
                    63,
                    53,
                    43,
                    44,
                    45,
                    46,
                    47,
                    57,
                    67,
                    66,
                    65,
                    64,
                    54,
                    55,
                    56
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\n    vector<int> result;\n    if (matrix.empty()) return result;\n    int m = matrix.size(), n = matrix[0].size();\n    int rowStart = 0, colStart = 0, rowEnd = m - 1, colEnd = n - 1;\n\n    while (rowStart <= rowEnd && colStart <= colEnd) {\n        for (int i = colStart; i <= colEnd; ++i) {\n            result.push_back(matrix[rowStart][i]);\n        }\n        rowStart++;\n        for (int i = rowStart; i <= rowEnd; ++i) {\n            result.push_back(matrix[i][colEnd]);\n        }\n        colEnd--;\n        if (rowStart <= rowEnd) {\n            for (int i = colEnd; i >= colStart; --i) {\n                result.push_back(matrix[rowEnd][i]);\n            }\n        }\n        rowEnd--;\n        if (colStart <= colEnd) {\n            for (int i = rowEnd; i >= rowStart; --i) {\n                result.push_back(matrix[i][colStart]);\n            }\n        }\n        colStart++;\n    }\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> spiralOrder(int[][] matrix) {\n    List<Integer> result = new ArrayList<>();\n    if (matrix == null || matrix.length == 0) return result;\n    int m = matrix.length, n = matrix[0].length;\n    int rowStart = 0, colStart = 0, rowEnd = m - 1, colEnd = n - 1;\n\n    while (rowStart <= rowEnd && colStart <= colEnd) {\n        for (int i = colStart; i <= colEnd; i++) {\n            result.add(matrix[rowStart][i]);\n        }\n        rowStart++;\n        for (int i = rowStart; i <= rowEnd; i++) {\n            result.add(matrix[i][colEnd]);\n        }\n        colEnd--;\n        if (rowStart <= rowEnd) {\n            for (int i = colEnd; i >= colStart; i--) {\n                result.add(matrix[rowEnd][i]);\n            }\n        }\n        rowEnd--;\n        if (colStart <= colEnd) {\n            for (int i = rowEnd; i >= rowStart; i--) {\n                result.add(matrix[i][colStart]);\n            }\n        }\n        colStart++;\n    }\n    return result;\n}\n",
            "python": "def spiralOrder(matrix):\n    result = []\n    if not matrix: return result\n    m, n = len(matrix), len(matrix[0])\n    rowStart, colStart, rowEnd, colEnd = 0, 0, m - 1, n - 1\n\n    while rowStart <= rowEnd and colStart <= colEnd:\n        for i in range(colStart, colEnd + 1): \n            result.append(matrix[rowStart][i])\n        rowStart += 1\n        \n        for i in range(rowStart, rowEnd + 1): \n            result.append(matrix[i][colEnd]) \n        colEnd -= 1\n        \n        if rowStart <= rowEnd:\n            for i in range(colEnd, colStart - 1, -1): \n                result.append(matrix[rowEnd][i]) \n        rowEnd -= 1\n        \n        if colStart <= colEnd:\n            for i in range(rowEnd, rowStart - 1, -1): \n                result.append(matrix[i][colStart]) \n        colStart += 1\n        \n    return result\n",
            "javascript": "function spiralOrder(matrix) {\n    const result = [];\n    if (!matrix.length) return result;\n    let m = matrix.length, n = matrix[0].length;\n    let rowStart = 0, colStart = 0, rowEnd = m - 1, colEnd = n - 1;\n\n    while (rowStart <= rowEnd && colStart <= colEnd) {\n        for (let i = colStart; i <= colEnd; i++) {\n            result.push(matrix[rowStart][i]);\n        }\n        rowStart++;\n        for (let i = rowStart; i <= rowEnd; i++) {\n            result.push(matrix[i][colEnd]);\n        }\n        colEnd--;\n        if (rowStart <= rowEnd) {\n            for (let i = colEnd; i >= colStart; i--) {\n                result.push(matrix[rowEnd][i]);\n            }\n        }\n        rowEnd--;\n        if (colStart <= colEnd) {\n            for (let i = rowEnd; i >= rowStart; i--) {\n                result.push(matrix[i][colStart]);\n            }\n        }\n        colStart++;\n    }\n    return result;\n}\n",
            "explanation": "The algorithm iterates over the matrix in a spiral order. Initialize the indices to keep track of the matrix boundaries. The algorithm goes from left to right, from top to bottom, from right to left, and then from bottom to top. With each iteration, update the matrix boundaries. The process continues until the row and column boundaries cross each other."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> spiralOrder(vector<vector<int>>& matrix)  {\n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> spiralOrder(int[][] matrix)  {\n    // Your code here\n}\n",
            "python": "def spiralOrder(matrix):\n    # Your code here\n\n",
            "javascript": "function spiralOrder(matrix)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nint main() {\n    vector<vector<int>> matrix = $args;\n    vector<int> result = spiralOrder(matrix);\n    for (int i = 0; i < result.size(); ++i) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "java": "public List<Integer> spiralOrder(int[][] matrix) {\n    List<Integer> result = new ArrayList<>();\n    if (matrix == null || matrix.length == 0) return result;\n    int m = matrix.length, n = matrix[0].length;\n    int rowStart = 0, colStart = 0, rowEnd = m - 1, colEnd = n - 1;\n\n    while (rowStart <= rowEnd && colStart <= colEnd) {\n        for (int i = colStart; i <= colEnd; i++) {\n            result.add(matrix[rowStart][i]);\n        }\n        rowStart++;\n        for (int i = rowStart; i <= rowEnd; i++) {\n            result.add(matrix[i][colEnd]);\n        }\n        colEnd--;\n        if (rowStart <= rowEnd) {\n            for (int i = colEnd; i >= colStart; i--) {\n                result.add(matrix[rowEnd][i]);\n            }\n        }\n        rowEnd--;\n        if (colStart <= colEnd) {\n            for (int i = rowEnd; i >= rowStart; i--) {\n                result.add(matrix[i][colStart]);\n            }\n        }\n        colStart++;\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    matrix = $args\n    result = spiralOrder(matrix)\n    print(result)",
            "javascript": "function main() {\n    const matrix = [[1], [2], [3], [4], [5]];\n    const result = spiralOrder(matrix);\n    console.log(result);\n}\nmain();"
        },
        "Qid": "54",
        "languages verified": [
            "python"
        ]
    },
    {
        "_id": {
            "$oid": "661d474b949b33b6c4e2b093"
        },
        "title": "Merge Overlapping Intervals",
        "description": "Given an array of intervals where each interval is represented as [start, end], merge all overlapping intervals and return an array of non-overlapping intervals that cover all the intervals in the input.",
        "example": "Example 1:\n\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\nExample 2:\n\nInput: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.",
        "level": "Medium",
        "tags": [
            "Array",
            "Sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        8,
                        10
                    ],
                    [
                        15,
                        18
                    ]
                ],
                [
                    [
                        1,
                        4
                    ],
                    [
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        3,
                        8
                    ],
                    [
                        4,
                        7
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        6
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        3
                    ],
                    [
                        4,
                        6
                    ],
                    [
                        7,
                        9
                    ],
                    [
                        10,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        6
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        5,
                        7
                    ],
                    [
                        6,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ]
                ]
            ],
            "outputs": [
                "[[1,6],[8,10],[15,18]]",
                "[[1,5]]",
                "[[1,2],[3,4],[5,6],[7,8]]",
                "[[1,10]]",
                "[[1,6],[7,8]]",
                "[[1,3],[4,6],[7,9],[10,12]]",
                "[[1,5]]",
                "[[1,2],[3,4],[5,6],[7,8],[9,10]]",
                "[[1,6],[7,8],[9,10]]",
                "[[1,4],[5,8]]",
                "[[1,6]]",
                "[[1,7]]",
                "[[1,8]]",
                "[[1,9]]",
                "[[1,10]]",
                "[[1,11]]",
                "[[1,12]]",
                "[[1,13]]",
                "[[1,14]]",
                "[[1,15]]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> merge(std::vector<std::vector<int>>& intervals) {\n    if (intervals.empty()) return {};\n\n    std::sort(intervals.begin(), intervals.end());\n    std::vector<std::vector<int>> result;\n    result.push_back(intervals[0]);\n\n    for (int i = 1; i < intervals.size(); i++) {\n        if (result.back()[1] >= intervals[i][0]) {\n            result.back()[1] = std::max(result.back()[1], intervals[i][1]);\n        } else {\n            result.push_back(intervals[i]);\n        }\n    }\n\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<int[]> merge(int[][] intervals) {\n    if (intervals.length == 0) return new ArrayList<>();\n\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n    List<int[]> result = new ArrayList<>();\n    result.add(intervals[0]);\n\n    for (int i = 1; i < intervals.length; i++) {\n        if (result.get(result.size() - 1)[1] >= intervals[i][0]) {\n            result.get(result.size() - 1)[1] = Math.max(result.get(result.size() - 1)[1], intervals[i][1]);\n        } else {\n            result.add(intervals[i]);\n        }\n    }\n\n    return result;\n}\n",
            "python": "def merge(intervals):\n    if not intervals:\n        return []\n\n    intervals.sort()\n    result = [intervals[0]]\n\n    for i in range(1, len(intervals)):\n        if result[-1][1] >= intervals[i][0]:\n            result[-1][1] = max(result[-1][1], intervals[i][1])\n        else:\n            result.append(intervals[i])\n\n    return result\n",
            "javascript": "function merge(intervals) {\n    if (intervals.length === 0) return [];\n\n    intervals.sort((a, b) => a[0] - b[0]);\n    const result = [intervals[0]];\n\n    for (let i = 1; i < intervals.length; i++) {\n        if (result[result.length - 1][1] >= intervals[i][0]) {\n            result[result.length - 1][1] = Math.max(result[result.length - 1][1], intervals[i][1]);\n        } else {\n            result.push(intervals[i]);\n        }\n    }\n\n    return result;\n}\n",
            "explanation": "The algorithm first sorts the intervals based on their start time. Then, it initializes an empty list `result` to store the merged intervals, and adds the first interval to `result`. Next, it iterates through the remaining intervals, comparing the end time of the last interval in `result` to the start time of the current interval. If they overlap (i.e., the end time of the last interval in `result` is greater than or equal to the start time of the current interval), then the end time of the last interval in `result` is updated to the maximum of its own end time and the end time of the current interval. Otherwise, the current interval is added to `result`. The process continues until all intervals have been processed, and `result` contains the merged, non-overlapping intervals covering the input intervals."
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> merge(std::vector<std::vector<int>>& intervals)  {\n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<int[]> merge(int[][] intervals)  {\n    // Your code here\n}\n",
            "python": "def merge(intervals):\n    # Your code here\n\n",
            "javascript": "function merge(intervals)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nint main() {\n    std::vector<std::vector<int>> intervals = $args;\n    std::vector<std::vector<int>> result = merge(intervals);\n\n    for (const auto& interval : result) {\n        std::cout << '[' << interval[0] << ',' << interval[1] << ']';\n    }\n\n    return 0;\n}",
            "java": "public List<int[]> merge(int[][] intervals) {\n    if (intervals.length == 0) return new ArrayList<>();\n\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n    List<int[]> result = new ArrayList<>();\n    result.add(intervals[0]);\n\n    for (int i = 1; i < intervals.length; i++) {\n        if (result.get(result.size() - 1)[1] >= intervals[i][0]) {\n            result.get(result.size() - 1)[1] = Math.max(result.get(result.size() - 1)[1], intervals[i][1]);\n        } else {\n            result.add(intervals[i]);\n        }\n    }\n\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    intervals = $args\n    result = merge(intervals)\n    print(result",
            "javascript": ""
        },
        "Qid": "56",
        "languages verified": [
            "python"
        ]
    },
    {
        "_id": {
            "$oid": "661d48a6949b33b6c4e2b094"
        },
        "title": "Length of Last Word",
        "description": "Given a string `s` consisting of words and spaces, return the length of the last word in the string. A word is a maximal substring consisting of non-space characters only.",
        "example": "Example 1:\n\nInput: s = \"Hello World \"\nOutput: 5\nExplanation: The last word is \"World \" with length 5.",
        "level": "Easy",
        "tags": [
            "string",
            "parsing"
        ],
        "test_cases": {
            "inputs": [
                "\"Hello World \"",
                "\"   fly me   to   the moon   \"",
                "\"luffy is still joyboy \"",
                "\"This is a test\"",
                "\"Coding is fun\"",
                "\"  Hello  \"",
                "\"  Hello World\"",
                "\"Hello World\"",
                "\"Hello\"",
                "\"\"",
                "\"   \"",
                "\"a\"",
                "\"a b\"",
                "\"a b c\"",
                "\"a b c d\"",
                "\"a b c d e\"",
                "\"a b c d e f\"",
                "\"a b c d e f g\"",
                "\"a b c d e f g h\"",
                "\"a b c d e f g h i\""
            ],
            "outputs": [
                5,
                4,
                6,
                4,
                3,
                5,
                5,
                5,
                5,
                0,
                0,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1
            ]
        },
        "sample_code": {
            "c++": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint lengthOfLastWord(string s) {\n    int length = 0;\n    int tail = s.length() - 1;\n    while (tail >= 0 && s[tail] == ' ') tail--;\n    while (tail >= 0 && s[tail] != ' ') {\n        length++;\n        tail--;\n    }\n    return length;\n}",
            "java": "public static int lengthOfLastWord(String s) {\n    int length = 0;\n    int tail = s.length() - 1;\n    while (tail >= 0 && s.charAt(tail) == ' ') tail--;\n    while (tail >= 0 && s.charAt(tail) != ' ') {\n        length++;\n        tail--;\n    }\n    return length;\n}\n",
            "python": "def length_of_last_word(s: str) -> int:\n    length = 0\n    tail = len(s) - 1\n    while tail >= 0 and s[tail] == ' ':\n        tail -= 1\n    while tail >= 0 and s[tail] != ' ':\n        length += 1\n        tail -= 1\n    return length\n",
            "javascript": "function lengthOfLastWord(s) {\n    let length = 0;\n    let tail = s.length - 1;\n    while (tail >= 0 && s[tail] === ' ') tail--;\n    while (tail >= 0 && s[tail] !== ' ') {\n        length++;\n        tail--;\n    }\n    return length;\n}\n",
            "explanation": "The algorithm for finding the length of the last word in a string containing multiple words separated by spaces is as follows:\n\n1. Initialize variables for the length of the last word and the tail (i.e., the end) of the input string.\n2. Traverse the string in reverse order to find the start of the last word by checking if a character is a space. Skip all spaces found.\n3. Continue traversing the string in reverse order and record the length of the last word until a space is encountered or the start of the string is reached.\n4. Return the length of the last word.\n\nThis algorithm is implemented in each of the given programming languages (C++, Java, Python, and JavaScript) with the appropriate syntax and variable initialization. The functions are named `lengthOfLastWord` for C++, Java, and JavaScript, and `length_of_last_word` for Python."
        },
        "structure": {
            "c++": "int lengthOfLastWord(string s) {\n    // Your code here\n}\n",
            "java": "public int lengthOfLastWord(String s) {\n    // Your code here\n}\n",
            "python": "def length_of_last_word(s: str) -> int:\n    # Your code here\n\n",
            "javascript": "function lengthOfLastWord(s) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    string s = $args;\n    int result = lengthOfLastWord(s);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = length_of_last_word(s)\n    print(result)",
            "java": "public static void main(String[] args){\n    String input = $args;\n    int result = lengthOfLastWord(input);\n    System.out.println(result);\n}",
            "javascript": "const input = $args;\nconst result = lengthOfLastWord(input);\nconsole.log(result);"
        },
        "Qid": "58",
        "languages verified": [
            "python",
            "javascript",
            "c++",
            "java"
        ]
    },
    {
        "_id": {
            "$oid": "661d4a1d949b33b6c4e2b095"
        },
        "title": "Permutation Sequence",
        "description": "Given a set of numbers from 1 to n, the set contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get a sequence. Given n and k, return the kth permutation sequence.",
        "example": "For example, given n = 3 and k = 3, the set of permutations is [\"123\", \"132\", \"213\", \"231\", \"312\", \"321\"]. The 3rd permutation is \"213\", so the output would be \"213\".",
        "level": "Medium",
        "tags": [
            "Math",
            "Backtracking"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    3
                ],
                [
                    4,
                    9
                ],
                [
                    3,
                    1
                ],
                [
                    5,
                    24
                ],
                [
                    6,
                    720
                ],
                [
                    9,
                    362880
                ],
                [
                    9,
                    362879
                ]
            ],
            "outputs": [
                "213",
                "2314",
                "123",
                "54321",
                "654321",
                "987654321",
                "987654312"
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <vector>\n\nstd::string getPermutation(int n, int k) {\n    std::vector<int> factorials(n, 1);\n    std::vector<char> nums(n, '1');\n    std::string result;\n    int index;\n\n    for (int i = 1; i <= n; ++i) {\n        nums[i - 1] += i - 1;\n        factorials[i - 1] *= i;\n    }\n\n    k--;\n\n    for (int i = n; i >= 1; --i) {\n        index = k / factorials[i - 1];\n        k %= factorials[i - 1];\n        result.push_back(nums[index]);\n        nums.erase(nums.begin() + index);\n    }\n\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic String getPermutation(int n, int k) {\n    List<Integer> nums = new ArrayList<>();\n    int[] factorials = new int[n];\n    StringBuilder sb = new StringBuilder();\n    int index;\n\n    factorials[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        nums.add(i);\n        factorials[i - 1] = i * factorials[i - 1];\n    }\n\n    k--;\n\n    for (int i = n; i >= 1; --i) {\n        index = k / factorials[i - 1];\n        k %= factorials[i - 1];\n        sb.append(nums.get(index));\n        nums.remove(index);\n    }\n\n    return sb.toString();\n}\n",
            "python": "def getPermutation(n, k):\n    factorials = [1]\n    nums = list(range(1, n + 1))\n    result = []\n\n    for i in range(1, n):\n        factorials.append(factorials[-1] * i)\n\n    k -= 1\n\n    for i in range(n, 0, -1):\n        index = k // factorials[i - 1]\n        k %= factorials[i - 1]\n        result.append(str(nums.pop(index)))\n\n    return ''.join(result)\n",
            "javascript": "function getPermutation(n, k) {\n    const factorials = [1];\n    const nums = [...Array(n)].map((_, i) => i + 1);\n    let result = '';\n\n    for (let i = 1; i < n; i++) {\n        factorials[i] = factorials[i - 1] * i;\n    }\n\n    k--;\n\n    for (let i = n; i >= 1; i--) {\n        const index = Math.floor(k / factorials[i - 1]);\n        k %= factorials[i - 1];\n        result += nums[index];\n        nums.splice(index, 1);\n    }\n\n    return result;\n}\n",
            "explanation": "The algorithm uses factorials and a list of available numbers to construct the kth permutation. \n\nFirst, we precompute the factorials up to n using a loop.\n\nNext, we initialize an array or list of available numbers, from 1 to n.\n\nThen, we iterate from n down to 1, calculating the index of the current number in the available list to be included in the resulting permutation. We can calculate it as follows: `index = (k - 1) // factorials[i - 1]`. \n\nAfter, we update the value of k to: `k %= factorials[i - 1]`.\n\nAt each step, we append or concatenate the chosen number to the result and remove it from the list of available numbers.\n\nFinally, we return the result as a string."
        },
        "structure": {
            "c++": "#include <string>\n#include <vector>\n\nstd::string getPermutation(int n, int k)  {\n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic String getPermutation(int n, int k)  {\n    // Your code here\n}\n",
            "python": "def getPermutation(n, k):\n    # Your code here\n\n",
            "javascript": "function getPermutation(n, k)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <string>\n\nint main() {\n    int n = $args[0];\n    int k = $args[1];\n    std::string result = getPermutation(n, k);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public String getPermutation(int n, int k) {\n    List<Integer> nums = new ArrayList<>();\n    int[] factorials = new int[n];\n    StringBuilder sb = new StringBuilder();\n    int index;\n\n    factorials[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        nums.add(i);\n        factorials[i - 1] = i * factorials[i - 1];\n    }\n\n    k--;\n\n    for (int i = n; i >= 1; --i) {\n        index = k / factorials[i - 1];\n        k %= factorials[i - 1];\n        sb.append(nums.get(index));\n        nums.remove(index);\n    }\n\n    return sb.toString();\n}",
            "python": "if __name__ == \"__main__\":\n    input=$args\n    n = input[0]\n    k = input[1]\n    result = getPermutation(n, k)\n    print(result)",
            "javascript": "const input = $args;\nconst n = input[0];\nconst k = input[1];\nconst result = getPermutation(n, k);\nconsole.log(result);"
        },
        "Qid": "60",
        "languages verified": [
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d4ac5949b33b6c4e2b096"
        },
        "title": "Valid Number",
        "description": "Given a string `s`, determine if it is a valid number. A valid number can be split into components in a specific order: a decimal number or an integer, followed by an optional 'e' or 'E' followed by an integer. A decimal number can have an optional sign character ('+' or '-'), followed by one of the following formats: one or more digits followed by a dot '.', one or more digits followed by a dot '.' and one or more digits, or a dot '.' followed by one or more digits. An integer can have an optional sign character followed by one or more digits. Return true if the given string is a valid number, otherwise return false.",
        "example": "Example:\n\nInput: \"0 \"\nOutput: true\n\nInput: \"e \"\nOutput: false\n\nInput: \". \"\nOutput: false\n\nExplanation:\n\nIn the first example, the string \"0 \" is a valid number as it is an integer.\n\nIn the second example, the string \"e \" is not a valid number as it does not have any components.\n\nIn the third example, the string \". \" is not a valid number as it does not have any components.",
        "level": "Medium",
        "tags": [
            "string",
            "parsing"
        ],
        "test_cases": {
            "inputs": [
                "\"2\"",
                "\"0089\"",
                "\"-0.1\"",
                "\"+3.14\"",
                "\"4.\"",
                "\"-.9\"",
                "\"2e10\"",
                "\"-90E3\"",
                "\"3e+7\"",
                "\"+6e-1\"",
                "\"53.5e93\"",
                "\"-123.456e789\"",
                "\"abc\"",
                "\"1a\"",
                "\"1e\"",
                "\"e3\"",
                "\"99e2.5\"",
                "\"--6\"",
                "\"-+3\"",
                "\"95a54e53\""
            ],
            "outputs": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "#include <regex>\n#include <string>\n\nbool isNumber(const std::string& s) {\n    std::regex pattern(\"^[-+]?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(e[-+]?[0-9]+)?$\");\n    return std::regex_match(s, pattern);\n}\n\n",
            "java": " public static boolean isNumber(String s) {\n        String pattern = \"^[-+]?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(e[-+]?[0-9]+)?$\";\n        return Pattern.matches(pattern, s);\n    }\n\n\n",
            "python": "import re\n\ndef is_number(s: str) -> bool:\n    pattern = re.compile(r'^[-+]?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(e[-+]?[0-9]+)?$')\n    return bool(pattern.match(s))\n\n",
            "javascript": "function isNumber(s) {\n    const pattern = /^[-+]?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(e[-+]?[0-9]+)?$/;\n    return pattern.test(s);\n}\n\n",
            "explanation": "The algorithm utilizes regular expressions to match the input string against a pattern that defines a valid number. The regular expression in this case has the following meaning:\n\n1. `^`: Start of the string\n2. `[-+]?`: An optional sign, either `+` or `-`\n3. `(`: Start of a group that can be an integer or a decimal\n4. `(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))`: Here, a valid number can either have digits before and after the decimal point or only after the decimal point (or only before the decimal point with an optional decimal delimiter).\n5. `)`: End of the group\n6. `(e[-+]?[0-9]+)?`: An optional scientific notation part, which consists of the letter 'e', followed by an optional sign and at least one digit\n7. `$`: End of the string\n\nThe regex pattern is constructed to cover all cases according to the problem's description. The function then uses each language's regex library to match the input string against this pattern, returning `true` if the input string matches and `false` otherwise."
        },
        "structure": {
            "c++": "#include <regex>\n#include <string>\n\nbool isNumber(const std::string& s) {\n    // Your code here\n}\n\n",
            "java": "public class Solution {\n    // Your code here\n}\n\n",
            "python": "import re\n    # Your code here\n\n",
            "javascript": "function isNumber(s) {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <regex>\n#include <string>\n#include <iostream>\n\nint main() {\n    std::string s = $args;\n    bool result = isNumber(s);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "java": "public static void main(String[] args){\n    String input = $args;\n    boolean result = isNumber(input);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = is_number(s)\n    print(result)",
            "javascript": "const input = $args;\nconst result = isNumber(input);\nconsole.log(result);"
        },
        "Qid": "65",
        "languages verified": [
            "python",
            "javascript",
            "c++"
        ]
    },
    {
        "_id": {
            "$oid": "661d4b72949b33b6c4e2b097"
        },
        "title": "Square Root Rounded Down",
        "description": "Given a non-negative integer `x`, you need to find the square root of `x` rounded down to the nearest integer. The returned integer should be non-negative. You must not use any built-in exponent function or operator.",
        "example": "Example:\n\nInput: x = 4\nOutput: 2\nExplanation: The square root of 4 is 2, so we return 2.",
        "level": "Easy",
        "tags": [
            "Math",
            "Binary Search"
        ],
        "test_cases": {
            "inputs": [
                0,
                1,
                2,
                3,
                4,
                8,
                9,
                16,
                25,
                36,
                49,
                64,
                81,
                100,
                121,
                144,
                169,
                196,
                225,
                256
            ],
            "outputs": [
                0,
                1,
                1,
                1,
                2,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16
            ]
        },
        "sample_code": {
            "c++": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint mySqrt(int x) {\n    if (x == 0 || x == 1) return x;\n    int start = 1, end = x, ans;\n    while (start <= end) {\n        int mid = (start + end) / 2;\n        if (mid * mid == x) return mid;\n        if (mid * mid < x) {\n            start = mid + 1;\n            ans = mid;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}\n",
            "java": "public static int mySqrt(int x) {\n    if (x == 0 || x == 1) return x;\n    int start = 1, end = x, ans = 0;\n    while (start <= end) {\n        int mid = (start + end) / 2;\n        if (mid * mid == x) return mid;\n        if (mid <= x / mid) {\n            start = mid + 1;\n            ans = mid;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}\n",
            "python": "def mySqrt(x):\n    if x == 0 or x == 1:\n        return x\n    start, end, ans = 1, x, 0\n    while start <= end:\n        mid = (start + end) // 2\n        if mid * mid == x:\n            return mid\n        if mid * mid < x:\n            start = mid + 1\n            ans = mid\n        else:\n            end = mid - 1\n    return ans\n",
            "javascript": "function mySqrt(x) {\n    if (x === 0 || x === 1) return x;\n    let start = 1, end = x, ans;\n    while (start <= end) {\n        let mid = Math.floor((start + end) / 2);\n        if (mid * mid === x) return mid;\n        if (mid * mid < x) {\n            start = mid + 1;\n            ans = mid;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}\n\n",
            "explanation": "The algorithm uses a binary search approach to find the integer square root of the given number `x`. It starts with the smallest possible answer (1) and the largest possible answer (x), updating the \"start\" and \"end\" positions based on whether the current midpoint squared is smaller or larger than x. The integer square root of the number is found when `mid * mid == x`, or when the closest integer (under or equal to x) value has been located. The binary search approach keeps the time complexity at O(log(x)), making it an efficient solution."
        },
        "structure": {
            "c++": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint mySqrt(int x) {\n    // Your code here\n}\n",
            "java": "public static int mySqrt(int x) {\n    // Your code here\n}\n",
            "python": "def mySqrt(x):\n    # Your code here\n\n",
            "javascript": "function mySqrt(x) {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int x = $args;\n    int result = mySqrt(x);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args){\n    int input = $args;\n    int result = mySqrt(input);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    x = $args\n    result = mySqrt(x)\n    print(result)",
            "javascript": "const x = $args;\nconst result = mySqrt(x);\nconsole.log(result);"
        },
        "Qid": "69",
        "languages verified": [
            "python",
            "javascript",
            "c++"
        ]
    },
    {
        "_id": {
            "$oid": "661d54fc949b33b6c4e2b098"
        },
        "title": "Simplified Canonical Path",
        "description": "Given an absolute path to a file or directory in a Unix-style file system, convert it to the simplified canonical path. In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names. The canonical path should have the following format: \n\n- The path starts with a single slash '/'. \n- Any two directories are separated by a single slash '/'. \n- The path does not end with a trailing '/'. \n- The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..').",
        "example": "Example:\n\nInput: path = \"/home/\"\nOutput: \"/home\"\nExplanation: Note that there is no trailing slash after the last directory name.",
        "level": "Medium",
        "tags": [
            "string",
            "parsing"
        ],
        "test_cases": {
            "inputs": [
                "\"/home/\"",
                "\"/../\"",
                "\"/home//foo/\"",
                "\"/a/./b/../../c/\"",
                "\"/a//b////c/d//././/..\"",
                "\"/a/../../b/../c//.//\"",
                "\"/a//b////c/d//././/..\"",
                "\"/a/../../b/../c//.//\"",
                "\"/a/./b/./c/./d/\"",
                "\"/a/../../../../../..\"",
                "\"/a/./b/./c/./d/\"",
                "\"/a/../../../../../..\"",
                "\"/a/./b/./c/./d/\"",
                "\"/a/../../../../../..\"",
                "\"/a/./b/./c/./d/\"",
                "\"/a/../../../../../..\"",
                "\"/a/./b/./c/./d/\"",
                "\"/a/../../../../../..\"",
                "\"/a/./b/./c/./d/\"",
                "\"/a/../../../../../..\""
            ],
            "outputs": [
                "\"/home\"",
                "\"/\"",
                "\"/home/foo\"",
                "\"/c\"",
                "\"/a/b/c\"",
                "\"/c\"",
                "\"/a/b/c\"",
                "\"/c\"",
                "\"/a/b/c/d\"",
                "\"/\"",
                "\"/a/b/c/d\"",
                "\"/\"",
                "\"/a/b/c/d\"",
                "\"/\"",
                "\"/a/b/c/d\"",
                "\"/\"",
                "\"/a/b/c/d\"",
                "\"/\"",
                "\"/a/b/c/d\"",
                "\"/\""
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <vector>\n#include <sstream>\n\nstd::string simplifyPath(std::string path) {\n    std::vector<std::string> stack;\n    std::istringstream ss{path};\n    std::string part;\n\n    while (std::getline(ss, part, '/')) {\n        if (part.empty() || part == \".\") continue;\n        if (part == \"..\") {\n            if (!stack.empty()) stack.pop_back();\n        } else {\n            stack.push_back(part);\n        }\n    }\n\n    std::string canonicalPath;\n    for (const auto &piece : stack) {\n        canonicalPath += '/' + piece;\n    }\n    return stack.empty() ? \"/\" : canonicalPath;\n}\n",
            "java": "public static String simplifyPath(String path) {\n    String[] parts = path.split(\"/\");\n    LinkedList<String> stack = new LinkedList<>();\n\n    for (String part : parts) {\n        if (part.isEmpty() || part.equals(\".\")) continue;\n        if (part.equals(\"..\")) {\n            if (!stack.isEmpty()) stack.removeLast();\n        } else {\n            stack.addLast(part);\n        }\n    }\n\n    StringBuilder canonicalPath = new StringBuilder();\n    for (String piece : stack) {\n        canonicalPath.append('/').append(piece);\n    }\n    return stack.isEmpty() ? \"/\" : canonicalPath.toString();\n}\n",
            "python": "def simplifyPath(path: str) -> str:\n    stack = []\n    parts = path.split(\"/\")\n\n    for part in parts:\n        if not part or part == \".\":\n            continue\n        if part == \"..\":\n            if stack:\n                stack.pop()\n        else:\n            stack.append(part)\n\n    return \"/\" + \"/\".join(stack)\n",
            "javascript": "function simplifyPath(path) {\n    let stack = [];\n    let parts = path.split(\"/\");\n\n    for (let part of parts) {\n        if (!part || part === \".\") continue;\n        if (part === \"..\") {\n            if (stack.length) stack.pop();\n        } else {\n            stack.push(part);\n        }\n    }\n\n    return \"/\" + stack.join(\"/\");\n}\n",
            "explanation": "The algorithm uses a stack to keep track of the directory hierarchy. It starts by splitting the input string by '/', iterating over each part, and processing them according to the following rules:\n1. If the part is empty or \".\", skip it.\n2. If the part is \"..\", pop off the top element of the stack (if it's non-empty).\n3. Otherwise, push the part onto the stack.\n\nAfter processing all parts, concatenate the elements in the stack separated by '/' and return the canonical path.\n\nThe implementations are very similar across the four languages, with differences stemming primarily from the syntax and conventions of each language."
        },
        "structure": {
            "c++": "#include <string>\n#include <vector>\n#include <sstream>\n\nstd::string simplifyPath(std::string path) {\n    // Your code here\n}\n",
            "java": "public static String simplifyPath(String path) {\n    // Your code here\n}\n",
            "python": "def simplifyPath(path: str) -> str:\n    # Your code here\n\n",
            "javascript": "function simplifyPath(path) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n\nint main() {\n    std::string path = $args;\n    std::string result = simplifyPath(path);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    path = $args\n    result = simplifyPath(path)\n    print(result)",
            "javascript": "const path = $args;\nconst result = simplifyPath(path);\nconsole.log(result);",
            "java": "public static void main(String[] args){\n    String input = $args;\n    String result = simplifyPath(input);\n    System.out.println(result);\n}"
        },
        "Qid": "71",
        "languages verified": [
            "python",
            "javascript",
            "c++",
            "java"
        ]
    },
    {
        "_id": {
            "$oid": "661d5537949b33b6c4e2b099"
        },
        "title": "Minimum Edit Distance",
        "description": "Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`. You have the following three operations permitted on a word: Insert a character, Delete a character, Replace a character.",
        "example": "Example:\n\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: horse -> rorse (replace 'h' with 'r'), rorse -> rose (remove 'r'), rose -> ros (remove 'e')",
        "level": "Medium",
        "tags": [
            "Dynamic Programming",
            "String"
        ],
        "test_cases": {
            "inputs": [
                [
                    "horse",
                    "ros"
                ],
                [
                    "intention",
                    "execution"
                ],
                [
                    "kitten",
                    "sitting"
                ],
                [
                    "abc",
                    "def"
                ],
                [
                    "abcdef",
                    "abcdef"
                ],
                [
                    "abcdef",
                    "fedcba"
                ],
                [
                    "abcdef",
                    "abc"
                ],
                [
                    "abc",
                    "abcdef"
                ],
                [
                    "",
                    ""
                ],
                [
                    "abc",
                    ""
                ],
                [
                    "",
                    "abc"
                ],
                [
                    "a",
                    "a"
                ],
                [
                    "a",
                    "b"
                ],
                [
                    "a",
                    ""
                ],
                [
                    "",
                    "a"
                ],
                [
                    "abcdefghijklmnopqrstuvwxyz",
                    "abcdefghijklmnopqrstuvwxyz"
                ],
                [
                    "abcdefghijklmnopqrstuvwxyz",
                    "zyxwvutsrqponmlkjihgfedcba"
                ],
                [
                    "abcdefghijklmnopqrstuvwxyz",
                    "abc"
                ],
                [
                    "abc",
                    "abcdefghijklmnopqrstuvwxyz"
                ],
                [
                    "abc",
                    "cba"
                ]
            ],
            "outputs": [
                3,
                5,
                3,
                3,
                0,
                6,
                3,
                3,
                0,
                3,
                3,
                0,
                1,
                1,
                1,
                0,
                0,
                23,
                23,
                23,
                2
            ]
        },
        "sample_code": {
            "c++": "int minDistance(string word1, string word2) {\n    int m = word1.size();\n    int n = word2.size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    \n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0) {\n                dp[i][j] = j;\n            } else if (j == 0) {\n                dp[i][j] = i;\n            } else if (word1[i - 1] == word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n",
            "java": "public int minDistance(String word1, String word2) {\n    int m = word1.length();\n    int n = word2.length();\n    int[][] dp = new int[m + 1][n + 1];\n    \n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0) {\n                dp[i][j] = j;\n            } else if (j == 0) {\n                dp[i][j] = i;\n            } else if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n",
            "python": "def minDistance(word1: str, word2: str) -> int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n    \n    return dp[m][n]\n",
            "javascript": "function minDistance(word1, word2) {\n    const m = word1.length;\n    const n = word2.length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    \n    for (let i = 0; i <= m; i++) {\n        for (let j = 0; j <= n; j++) {\n            if (i === 0) {\n                dp[i][j] = j;\n            } else if (j === 0) {\n                dp[i][j] = i;\n            } else if (word1[i - 1] === word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n",
            "explanation": "The algorithm used is dynamic programming. We create a 2D table dp with dimensions (m+1) x (n+1), where m is the length of word1 and n is the length of word2. Each cell dp[i][j] represents the minimum number of operations required to convert word1[0...i-1] to word2[0...j-1].\n\nFor each cell, we have the following conditions:\n1. If either i or j is 0, it means one of the strings is empty, so the minimum number of operations needed is the length of the non-empty string (i or j).\n2. If the current characters of the two strings are equal (word1[i-1] == word2[j-1]), we don't have to do anything, so dp[i][j] = dp[i-1][j-1].\n3. If the current characters are different, we take the minimum of the following and add 1:\n    a. dp[i-1][j]: Delete operation\n    b. dp[i][j-1]: Insert operation\n    c. dp[i-1][j-1]: Replace operation\n\nAfter filling the table, the minimum number of operations will be at dp[m][n]."
        },
        "structure": {
            "c++": "int minDistance(string word1, string word2)  {\n    // Your code here\n}\n",
            "java": "public int minDistance(String word1, String word2)  {\n    // Your code here\n}\n",
            "python": "def minDistance(word1: str, word2: str) -> int:\n    # Your code here\n\n",
            "javascript": "function minDistance(word1, word2)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int minDistance(string word1, string word2) {\n    int m = word1.size();\n    int n = word2.size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    \n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0) {\n                dp[i][j] = j;\n            } else if (j == 0) {\n                dp[i][j] = i;\n            } else if (word1[i - 1] == word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}",
            "java": "public int minDistance(String word1, String word2) {\n    int m = word1.length();\n    int n = word2.length();\n    int[][] dp = new int[m + 1][n + 1];\n    \n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0) {\n                dp[i][j] = j;\n            } else if (j == 0) {\n                dp[i][j] = i;\n            } else if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    word1 = inputs[0]\n    word2 = inputs[1]\n    result = minDistance(word1, word2)\n    print(result)",
            "javascript": "const inputs = $args;\nconst word1 = inputs[0];\nconst word2 = inputs[1];\nconst result = minDistance(word1, word2);\nconsole.log(result);"
        },
        "Qid": "72",
        "languages verified": [
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d55a3949b33b6c4e2b09a"
        },
        "title": "Sort Colors",
        "description": "Given an array `nums` with `n` objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively. You must solve this problem without using the library's sort function.",
        "example": "Example:\n\nInput: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]\n\nInput: nums = [2,0,1]\nOutput: [0,1,2]",
        "level": "Medium",
        "tags": [
            "Array",
            "Two Pointers",
            "Sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    0,
                    2,
                    1,
                    1,
                    0
                ],
                [
                    2,
                    0,
                    1
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    0,
                    1,
                    2
                ],
                [
                    2,
                    1,
                    0
                ],
                [
                    1,
                    0,
                    2
                ],
                [
                    0,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    0
                ],
                [
                    2,
                    0,
                    1,
                    0,
                    2,
                    1
                ],
                [
                    1,
                    0,
                    2,
                    0,
                    1,
                    2
                ],
                [
                    2,
                    1,
                    0,
                    1,
                    2,
                    0
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                [
                    2,
                    2,
                    1,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    1,
                    0,
                    0,
                    2,
                    2
                ],
                [
                    0,
                    1,
                    2,
                    2,
                    1,
                    0
                ],
                [
                    2,
                    1,
                    0,
                    0,
                    1,
                    2
                ],
                [
                    1,
                    2,
                    0,
                    0,
                    2,
                    1
                ],
                [
                    0,
                    2,
                    1,
                    1,
                    0,
                    2
                ]
            ],
            "outputs": [
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                [
                    0,
                    1,
                    2
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    0,
                    1,
                    2
                ],
                [
                    0,
                    1,
                    2
                ],
                [
                    0,
                    1,
                    2
                ],
                [
                    0,
                    1,
                    2
                ],
                [
                    0,
                    1,
                    2
                ],
                [
                    0,
                    0,
                    0,
                    1,
                    1,
                    2
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2
                ]
            ]
        },
        "sample_code": {
            "c++": "void sortColors(vector<int>& nums) {\n    int red = 0, white = 0, blue = nums.size() - 1;\n    while (white <= blue) {\n        if (nums[white] == 0) {\n            swap(nums[red++], nums[white++]);\n        } else if (nums[white] == 1) {\n            white++;\n        } else {\n            swap(nums[white], nums[blue--]);\n        }\n    }\n}\n",
            "java": "public void sortColors(int[] nums) {\n    int red = 0, white = 0, blue = nums.length - 1;\n    while (white <= blue) {\n        if (nums[white] == 0) {\n            int temp = nums[red];\n            nums[red++] = nums[white];\n            nums[white++] = temp;\n        } else if (nums[white] == 1) {\n            white++;\n        } else {\n            int temp = nums[white];\n            nums[white] = nums[blue];\n            nums[blue--] = temp;\n        }\n    }\n}\n",
            "python": "def sortColors(nums: list[int]) -> None:\n    red, white, blue = 0, 0, len(nums) - 1\n    while white <= blue:\n        if nums[white] == 0:\n            nums[red], nums[white] = nums[white], nums[red]\n            red += 1\n            white += 1\n        elif nums[white] == 1:\n            white += 1\n        else:\n            nums[white], nums[blue] = nums[blue], nums[white]\n            blue -= 1\n",
            "javascript": "function sortColors(nums) {\n    let red = 0, white = 0, blue = nums.length - 1;\n    while (white <= blue) {\n        if (nums[white] === 0) {\n            [nums[red], nums[white]] = [nums[white], nums[red]];\n            red++;\n            white++;\n        } else if (nums[white] === 1) {\n            white++;\n        } else {\n            [nums[white], nums[blue]] = [nums[blue], nums[white]];\n            blue--;\n        }\n    }\n}\n",
            "explanation": "The algorithm can be explained using three pointers: `red`, `white`, and `blue`. `red` is responsible for tracking the position where the next 0 should be moved to, starting from the beginning of the array. Likewise, `blue` is responsible for tracking the position where the next 2 should be swapped to, starting from the end of the array. `white` is responsible for iterating through the array.\n\nWhile `white` is less than or equal to `blue`, check the current `nums[white]` value. If it is 0, swap it with the value at index `red`, and increment both `red` and `white`. If it is 1, simply increment `white`. If it is 2, swap the value at index `white` with the value at index `blue`, and decrement `blue` without incrementing `white` since the newly swapped value at index `white` might be 0 or 2.\n\nThis will sort the colors in the required order with a linear-time complexity, as we only go through the array once with the `white` pointer. Also, it sorts the colors in-place without the need for additional storage."
        },
        "structure": {
            "c++": "void sortColors(vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "public void sortColors(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def sortColors(nums: List[int]) -> None:\n    # Your code here\n\n",
            "javascript": "function sortColors(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "void sortColors(vector<int>& nums) {\n    int red = 0, white = 0, blue = nums.size() - 1;\n    while (white <= blue) {\n        if (nums[white] == 0) {\n            swap(nums[red++], nums[white++]);\n        } else if (nums[white] == 1) {\n            white++;\n        } else {\n            swap(nums[white], nums[blue--]);\n        }\n    }\n}",
            "java": "public void sortColors(int[] nums) {\n    int red = 0, white = 0, blue = nums.length - 1;\n    while (white <= blue) {\n        if (nums[white] == 0) {\n            int temp = nums[red];\n            nums[red++] = nums[white];\n            nums[white++] = temp;\n        } else if (nums[white] == 1) {\n            white++;\n        } else {\n            int temp = nums[white];\n            nums[white] = nums[blue];\n            nums[blue--] = temp;\n        }\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    sortColors(nums)\n    print(nums)",
            "javascript": "const nums = $args;\nsortColors(nums);\nconsole.log(nums);"
        },
        "Qid": "75",
        "languages verified": [
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d55d7949b33b6c4e2b09b"
        },
        "title": "Minimum Window Substring",
        "description": "Given two strings `s` and `t` of lengths `m` and `n` respectively, find the minimum window substring of `s` that contains all the characters from `t`. If there is no such substring, return an empty string.",
        "example": "Example 1:\n\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n\nExample 2:\n\nInput: s = \"a\", t = \"a\"\nOutput: \"a\"\nExplanation: The entire string s is the minimum window.\n\nExample 3:\n\nInput: s = \"a\", t = \"aa\"\nOutput: \"\"\nExplanation: Both 'a's from t must be included in the window. Since the largest window of s only has one 'a', return empty string.",
        "level": "Medium",
        "tags": [
            "string",
            "sliding window",
            "two pointers"
        ],
        "test_cases": {
            "inputs": [
                [
                    "ADOBECODEBANC",
                    "ABC"
                ],
                [
                    "a",
                    "a"
                ],
                [
                    "a",
                    "aa"
                ],
                [
                    "ab",
                    "a"
                ],
                [
                    "ab",
                    "b"
                ],
                [
                    "abc",
                    "ab"
                ],
                [
                    "abc",
                    "ac"
                ],
                [
                    "abc",
                    "abc"
                ],
                [
                    "abc",
                    "abcd"
                ],
                [
                    "aabbcc",
                    "abc"
                ],
                [
                    "aabbcc",
                    "abcc"
                ],
                [
                    "aabbcc",
                    "aabbcc"
                ],
                [
                    "aabbcc",
                    "aabbccd"
                ],
                [
                    "aabbcc",
                    "aabbccdd"
                ],
                [
                    "aabbcc",
                    "aabbccdde"
                ],
                [
                    "aabbcc",
                    "aabbccddeeff"
                ],
                [
                    "aabbcc",
                    "aabbccddeeffg"
                ],
                [
                    "aabbcc",
                    "aabbccddeeffgg"
                ],
                [
                    "aabbcc",
                    "aabbccddeeffggh"
                ],
                [
                    "aabbcc",
                    "aabbccddeeffgghi"
                ]
            ],
            "outputs": [
                "BANC",
                "a",
                "",
                "a",
                "b",
                "ab",
                "abc",
                "abc",
                "",
                "aabbcc",
                "abcc",
                "aabbcc",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <unordered_map>\n\nstd::string min_window(std::string s, std::string t) {\n    std::unordered_map<char, int> need, window;\n    for (char c : t) need[c]++;\n    \n    int left = 0, right = 0;\n    int valid = 0;\n    int start = 0, length = INT_MAX;\n\n    while (right < s.length()) {\n        char c = s[right];\n        right++;\n        if (need.count(c)) {\n            window[c]++;\n            if (window[c] <= need[c]) valid++;\n        }\n\n        while (valid == t.length()) {\n            if (right - left < length) {\n                start = left;\n                length = right - left;\n            }\n\n            char d = s[left];\n            left++;\n            if (need.count(d)) {\n                if (window[d] <= need[d]) valid--;\n                window[d]--;\n            }\n        }\n    }\n    return length == INT_MAX ? \"\" : s.substr(start, length);\n}\n\n",
            "java": "import java.util.HashMap;\n\npublic String minWindow(String s, String t) {\n    HashMap<Character, Integer> need = new HashMap<>();\n    HashMap<Character, Integer> window = new HashMap<>();\n    for (char c : t.toCharArray()) need.put(c, need.getOrDefault(c, 0) + 1);\n    \n    int left = 0, right = 0;\n    int valid = 0;\n    int start = 0, length = Integer.MAX_VALUE;\n\n    while (right < s.length()) {\n        char c = s.charAt(right);\n        right++;\n        if (need.containsKey(c)) {\n            window.put(c, window.getOrDefault(c, 0) + 1);\n            if (window.get(c) <= need.get(c)) valid++;\n        }\n\n        while (valid == t.length()) {\n            if (right - left < length) {\n                start = left;\n                length = right - left;\n            }\n\n            char d = s.charAt(left);\n            left++;\n            if (need.containsKey(d)) {\n                if (window.get(d) <= need.get(d)) valid--;\n                window.put(d, window.get(d) - 1);\n            }\n        }\n    }\n    return length == Integer.MAX_VALUE ? \"\" : s.substring(start, start + length);\n}\n\n",
            "python": "from collections import Counter\n\ndef min_window(s, t):\n    need = Counter(t)\n    window = {}\n    \n    left = 0\n    right = 0\n    valid = 0\n    start = 0\n    length = float('inf')\n\n    while right < len(s):\n        c = s[right]\n        right += 1\n        if c in need:\n            window[c] = window.get(c, 0) + 1\n            if window[c] <= need[c]:\n                valid += 1\n\n        while valid == len(t):\n            if right - left < length:\n                start = left\n                length = right - left\n\n            d = s[left]\n            left += 1\n            if d in need:\n                if window[d] <= need[d]:\n                    valid -= 1\n                window[d] -= 1\n\n    return \"\" if length == float('inf') else s[start : start + length]\n\n",
            "javascript": "function minWindow(s, t) {\n    const need = new Map();\n    const window = new Map();\n\n    for (const c of t) {\n        need.set(c, (need.get(c) || 0) + 1);\n    }\n    \n    let left = 0, right = 0;\n    let valid = 0;\n    let start = 0, length = Infinity;\n\n    while (right < s.length) {\n        const c = s[right];\n        right++;\n        if (need.has(c)) {\n            window.set(c, (window.get(c) || 0) + 1);\n            if (window.get(c) <= need.get(c)) valid++;\n        }\n\n        while (valid === t.length) {\n            if (right - left < length) {\n                start = left;\n                length = right - left;\n            }\n\n            const d = s[left];\n            left++;\n            if (need.has(d)) {\n                if (window.get(d) <= need.get(d)) valid--;\n                window.set(d, window.get(d) - 1);\n            }\n        }\n    }\n    return length === Infinity ? \"\" : s.substring(start, start + length);\n}\n\n",
            "explanation": "The algorithm uses a sliding window approach to find the minimum window substring. We use two pointers, `left` and `right`, to represent the current window. \n\n1. Initialize an unordered_map or dictionary for `need` to store characters and their counts in `t`, and another for `window` to store characters and their counts in the current window.\n2. Initialize `left` and `right` pointers, `valid` counter for keeping track of characters satisfying the criteria, and `start` and `length` for holding the answer substring information.\n3. Iterate through the string `s` using the `right` pointer, and:\n    - If the current character exists in the `need` map, update the count of the character in the `window` map, and increment `valid` if the count in the window is less than or equal to the count in need.\n4. Check the validity by comparing `valid` with the length of `t`.\n    - If valid, update the answer substring's `start` and `length` if the current window's length is less than the current minimum.\n    - Then, increment the `left` pointer to slide the window until the current character count in the window goes below the count in `need`. Update the `valid` counter accordingly.\n5. Return the answer substring, or empty string if no window was found."
        },
        "structure": {
            "c++": "#include <string>\n#include <unordered_map>\n\nstd::string min_window(std::string s, std::string t)  {\n    // Your code here\n}\n\n",
            "java": "import java.util.HashMap;\n\npublic String minWindow(String s, String t)  {\n    // Your code here\n}\n\n",
            "python": "from collections import Counter\n    # Your code here\n\n",
            "javascript": "function minWindow(s, t)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <unordered_map>\n\nint main() {\n    std::string s = $args;\n    std::string t = $args;\n    std::string result = min_window(s, t);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public String minWindow(String s, String t) {\n    HashMap<Character, Integer> need = new HashMap<>();\n    HashMap<Character, Integer> window = new HashMap<>();\n    for (char c : t.toCharArray()) need.put(c, need.getOrDefault(c, 0) + 1);\n    \n    int left = 0, right = 0;\n    int valid = 0;\n    int start = 0, length = Integer.MAX_VALUE;\n\n    while (right < s.length()) {\n        char c = s.charAt(right);\n        right++;\n        if (need.containsKey(c)) {\n            window.put(c, window.getOrDefault(c, 0) + 1);\n            if (window.get(c) <= need.get(c)) valid++;\n        }\n\n        while (valid == t.length()) {\n            if (right - left < length) {\n                start = left;\n                length = right - left;\n            }\n\n            char d = s.charAt(left);\n            left++;\n            if (need.containsKey(d)) {\n                if (window.get(d) <= need.get(d)) valid--;\n                window.put(d, window.get(d) - 1);\n            }\n        }\n    }\n    return length == Integer.MAX_VALUE ? \"\" : s.substring(start, start + length);\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    s = inputs[0]\n    t = inputs[1]\n    result = min_window(s, t)\n    print(result)",
            "javascript": "const inputs = $args;\nconst s = inputs[0];\nconst t = inputs[1];\nconst result = minWindow(s, t);\nconsole.log(result);"
        },
        "Qid": "76",
        "languages verified": [
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d562b949b33b6c4e2b09c"
        },
        "title": "Combinations of K Numbers",
        "description": "Given two integers `n` and `k`, return all possible combinations of `k` numbers chosen from the range `[1, n]`. You may return the answer in any order.",
        "example": "Example:\n\nInput: n = 4, k = 2\nOutput: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nExplanation: There are 4 choose 2 = 6 total combinations. Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.",
        "level": "Medium",
        "tags": [
            "Array",
            "Backtracking"
        ],
        "test_cases": {
            "inputs": [
                [
                    4,
                    2
                ],
                [
                    1,
                    1
                ],
                [
                    5,
                    3
                ],
                [
                    10,
                    4
                ],
                [
                    3,
                    2
                ],
                [
                    8,
                    1
                ],
                [
                    20,
                    5
                ],
                [
                    2,
                    2
                ],
                [
                    6,
                    4
                ],
                [
                    15,
                    3
                ],
                [
                    7,
                    1
                ],
                [
                    12,
                    2
                ],
                [
                    18,
                    6
                ],
                [
                    9,
                    3
                ],
                [
                    11,
                    1
                ],
                [
                    14,
                    4
                ],
                [
                    19,
                    2
                ],
                [
                    13,
                    5
                ],
                [
                    16,
                    3
                ],
                [
                    17,
                    1
                ]
            ],
            "outputs": [
                [
                    [
                        1,
                        2
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        3,
                        4
                    ]
                ],
                [
                    [
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        1,
                        2,
                        4
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        1,
                        3,
                        4
                    ],
                    [
                        1,
                        3,
                        5
                    ],
                    [
                        1,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4
                    ],
                    [
                        2,
                        3,
                        5
                    ],
                    [
                        2,
                        4,
                        5
                    ],
                    [
                        3,
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        1,
                        2,
                        3,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        6
                    ],
                    [
                        1,
                        2,
                        4,
                        5
                    ],
                    [
                        1,
                        2,
                        4,
                        6
                    ],
                    [
                        1,
                        2,
                        5,
                        6
                    ],
                    [
                        1,
                        3,
                        4,
                        5
                    ],
                    [
                        1,
                        3,
                        4,
                        6
                    ],
                    [
                        1,
                        3,
                        5,
                        6
                    ],
                    [
                        1,
                        4,
                        5,
                        6
                    ],
                    [
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4,
                        6
                    ],
                    [
                        2,
                        3,
                        5,
                        6
                    ],
                    [
                        2,
                        4,
                        5,
                        6
                    ],
                    [
                        3,
                        4,
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        3
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        3
                    ],
                    [
                        4
                    ],
                    [
                        5
                    ],
                    [
                        6
                    ],
                    [
                        7
                    ],
                    [
                        8
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        6,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        6,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        6,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        7,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        7,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        8,
                        9
                    ],
                    [
                        1,
                        2,
                        4,
                        5,
                        6
                    ],
                    [
                        1,
                        2,
                        4,
                        5,
                        7
                    ],
                    [
                        1,
                        2,
                        4,
                        5,
                        8
                    ],
                    [
                        1,
                        2,
                        4,
                        5,
                        9
                    ],
                    [
                        1,
                        2,
                        4,
                        6,
                        7
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        1,
                        3
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        1,
                        2,
                        3,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        10
                    ],
                    [
                        1,
                        2,
                        4,
                        5
                    ],
                    [
                        1,
                        2,
                        4,
                        6
                    ],
                    [
                        1,
                        2,
                        4,
                        7
                    ],
                    [
                        1,
                        2,
                        4,
                        8
                    ],
                    [
                        1,
                        2,
                        4,
                        9
                    ],
                    [
                        1,
                        2,
                        4,
                        10
                    ],
                    [
                        1,
                        2,
                        5,
                        6
                    ],
                    [
                        1,
                        2,
                        5,
                        7
                    ],
                    [
                        1,
                        2,
                        5,
                        8
                    ],
                    [
                        1,
                        2,
                        5,
                        9
                    ],
                    [
                        1,
                        2,
                        5,
                        10
                    ],
                    [
                        1,
                        2,
                        6,
                        7
                    ],
                    [
                        1,
                        2,
                        6,
                        8
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        3
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        1,
                        5
                    ],
                    [
                        1,
                        6
                    ],
                    [
                        1,
                        7
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        3,
                        5
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        4,
                        6
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        5,
                        7
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        6,
                        8
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        7,
                        9
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        8,
                        10
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        9,
                        11
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        10,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        7,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        7,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        7,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        8,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        8,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        9,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        6,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        6,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        6,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        6,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        7,
                        8
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        2
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        1,
                        2,
                        3,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        11
                    ],
                    [
                        1,
                        2,
                        3,
                        12
                    ],
                    [
                        1,
                        2,
                        3,
                        13
                    ],
                    [
                        1,
                        2,
                        3,
                        14
                    ],
                    [
                        1,
                        2,
                        3,
                        15
                    ],
                    [
                        1,
                        2,
                        3,
                        16
                    ],
                    [
                        1,
                        2,
                        3,
                        17
                    ],
                    [
                        1,
                        2,
                        3,
                        18
                    ],
                    [
                        1,
                        2,
                        3,
                        19
                    ],
                    [
                        1,
                        2,
                        3,
                        20
                    ],
                    [
                        1,
                        2,
                        4,
                        5
                    ],
                    [
                        1,
                        2,
                        4,
                        6
                    ],
                    [
                        1,
                        2,
                        4,
                        7
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        3
                    ],
                    [
                        4
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        11
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        12
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        13
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        14
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        15
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        16
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        17
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        18
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        19
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        20
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        5,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        1,
                        5
                    ],
                    [
                        1,
                        6
                    ],
                    [
                        1,
                        7
                    ],
                    [
                        1,
                        8
                    ],
                    [
                        1,
                        9
                    ],
                    [
                        1,
                        10
                    ],
                    [
                        1,
                        11
                    ],
                    [
                        1,
                        12
                    ],
                    [
                        1,
                        13
                    ],
                    [
                        1,
                        14
                    ],
                    [
                        1,
                        15
                    ],
                    [
                        1,
                        16
                    ],
                    [
                        1,
                        17
                    ],
                    [
                        1,
                        18
                    ],
                    [
                        1,
                        19
                    ],
                    [
                        1,
                        20
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        11
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        12
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        13
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        14
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        15
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        16
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        17
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        18
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        19
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        20
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        7,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        7,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        7,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        7,
                        11
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        7,
                        12
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        7,
                        13
                    ]
                ]
            ],
            "input_data_type": [
                "array"
            ],
            "output_data_type": [
                "array"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nvoid backtrack(int n, int k, int start, std::vector<int>& current, std::vector<std::vector<int>>& result) {\n    if (current.size() == k) {\n        result.push_back(current);\n        return;\n    }\n\n    for (int i = start; i <= n; ++i) {\n        current.push_back(i);\n        backtrack(n, k, i + 1, current, result);\n        current.pop_back();\n    }\n}\n\nstd::vector<std::vector<int>> combine(int n, int k) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> current;\n    backtrack(n, k, 1, current, result);\n    return result;\n}\n",
            "java": "public static List<List<Integer>> combine(int n, int k) {\n    List<List<Integer>> result = new ArrayList<>();\n    backtrack(n, k, 1, new ArrayList<>(), result);\n    return result;\n}\n\nprivate static void backtrack(int n, int k, int start, List<Integer> current, List<List<Integer>> result) {\n    if (current.size() == k) {\n        result.add(new ArrayList<>(current));\n        return;\n    }\n\n    for (int i = start; i <= n; i++) {\n        current.add(i);\n        backtrack(n, k, i + 1, current, result);\n        current.remove(current.size() - 1);\n    }\n}\n",
            "python": "from typing import List\n\ndef combine(n: int, k: int) -> List[List[int]]:\n    def backtrack(start, current_combination):\n        if len(current_combination) == k:\n            result.append(current_combination[:])\n\n        for i in range(start, n + 1):\n            current_combination.append(i)\n            backtrack(i + 1, current_combination)\n            current_combination.pop()\n\n    result = []\n    backtrack(1, [])\n    return result\n",
            "javascript": "function combine(n, k) {\n    const result = [];\n    backtrack(n, k, 1, [], result);\n    return result;\n}\n\nfunction backtrack(n, k, start, current, result) {\n    if (current.length === k) {\n        result.push([...current]);\n        return;\n    }\n\n    for (let i = start; i <= n; i++) {\n        current.push(i);\n        backtrack(n, k, i + 1, current, result);\n        current.pop();\n    }\n}\n",
            "explanation": "The algorithm uses a backtracking approach to generate all possible combinations of k numbers out of the range [1, n]. We create a helper function called `backtrack` that recursively generates combinations. In this helper function, we have a base case where if the size of the current combination is equal to k, we add it to the result. Otherwise, we iterate through the numbers from the start index to n, add the current number to the current combination, and make a recursive call with an incremented start index. After the call, we \"undo\" the decision by removing the number from the current combination (backtracking).\n\nThe main function initializes an empty result list, calls the `backtrack` function with a start index of 1 and an empty current combination list, and then returns the result list."
        },
        "structure": {
            "c++": "#include <vector>\n\nvoid backtrack(int n, int k, int start, std::vector<int>& current, std::vector<std::vector<int>>& result) {\n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> combine(int n, int k) {\n    // Your code here\n}\n",
            "python": "from typing import List\n    # Your code here\n\n",
            "javascript": "function combine(n, k) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nint main() {\n    int n = $args1;\n    int k = $args2;\n    std::vector<std::vector<int>> result = combine(n, k);\n    for (const auto& combination : result) {\n        for (const auto& num : combination) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n        int n = $args1; // Example value for n\n        int k = $args2; // Example value for k\n        List<List<Integer>> result = combine(n, k);\n        System.out.println(result);\n    }",
            "python": "if __name__ == \"__main__\":\n    inputs = [4, 2]\n    n = inputs[0]\n    k = inputs[1]\n    result = combine(n, k)\n    print(result)",
            "javascript": "function main() {\n    const inputs = [4, 2]\n    const n = inputs[0];\n    const k = inputs[1];\n    const result = combine(n, k);\n    console.log(result);\n}\nmain();"
        },
        "Qid": "77",
        "languages verified": [
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d574e949b33b6c4e2b09e"
        },
        "title": "Word Search",
        "description": "Given an `m x n` grid of characters `board` and a string `word`, determine if `word` exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
        "example": "Given a board = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], and a word = 'ABCCED', the function should return true, as the word 'ABCCED' can be formed by starting at cell (0,0) and moving right, down, down, left, and up.\n\nGiven a board = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], and a word = 'SEE', the function should return true, as the word 'SEE' can be formed by starting at cell (0,1) and moving right, down, and down.\n\nGiven a board = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], and a word = 'ABCB', the function should return false, as it is not possible to form the word 'ABCB' in the grid.",
        "level": "Medium",
        "tags": [
            "Array",
            "Backtracking"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCCED"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "SEE"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCB"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCD"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ASAD"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABFCE"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDAS"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASF"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFS"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSF"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSFS"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSFSC"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSFSCS"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSFSCSA"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSFSCSAS"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSFSCSASF"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSFSCSASFS"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSFSCSASFSF"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSFSCSASFSFS"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSFSCSASFSFSC"
                ],
                [
                    [
                        [
                            "A",
                            "B",
                            "C",
                            "E"
                        ],
                        [
                            "S",
                            "F",
                            "C",
                            "S"
                        ],
                        [
                            "A",
                            "D",
                            "E",
                            "E"
                        ]
                    ],
                    "ABCESEEDASFSFSCSASFSFSCS"
                ]
            ],
            "outputs": [
                true,
                true,
                false,
                false,
                false,
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "bool exist(vector<vector<char>>& board, string word) {\n    int m = board.size();\n    int n = board[0].size();\n    \n    function<bool(int, int, int)> dfs = [&](int i, int j, int k) {\n        if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] != word[k])\n            return false;\n        if (k == word.length() - 1)\n            return true;\n        \n        char temp = board[i][j];\n        board[i][j] = '/';\n        bool res = dfs(i + 1, j, k + 1) || dfs(i - 1, j, k + 1) || dfs(i, j + 1, k + 1) || dfs(i, j - 1, k + 1);\n        board[i][j] = temp;\n        return res;\n    };\n    \n    for (int i = 0; i < m; i++)\n        for (int j = 0; j < n; j++)\n            if (dfs(i, j, 0))\n                return true;\n    return false;\n}\n\n",
            "java": "public boolean exist(char[][] board, String word) {\n    int m = board.length;\n    int n = board[0].length;\n\n    boolean[][] visited = new boolean[m][n];\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dfs(board, i, j, 0, word, visited)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean dfs(char[][] board, int i, int j, int k, String word, boolean[][] visited) {\n    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != word.charAt(k) || visited[i][j]) {\n        return false;\n    }\n\n    if (k == word.length() - 1) {\n        return true;\n    }\n\n    visited[i][j] = true;\n    boolean result = dfs(board, i + 1, j, k + 1, word, visited)\n            || dfs(board, i - 1, j, k + 1, word, visited)\n            || dfs(board, i, j + 1, k + 1, word, visited)\n            || dfs(board, i, j - 1, k + 1, word, visited);\n    visited[i][j] = false;\n\n    return result;\n}\n\n",
            "python": "def exist(board, word):\n    m, n = len(board), len(board[0])\n\n    def dfs(i, j, k):\n        if not 0 <= i < m or not 0 <= j < n or board[i][j] != word[k]:\n            return False\n        if k == len(word) - 1:\n            return True\n\n        tmp, board[i][j] = board[i][j], '/'\n        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n        board[i][j] = tmp\n        return res\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n    return False\n\n",
            "javascript": "function exist(board, word) {\n    const m = board.length;\n    const n = board[0].length;\n\n    function dfs(i, j, k) {\n        if (i < 0 || i === m || j < 0 || j === n || board[i][j] !== word[k])\n            return false;\n        if (k === word.length - 1)\n            return true;\n        \n        const temp = board[i][j];\n        board[i][j] = '/';\n        const res = dfs(i + 1, j, k +1) || dfs(i - 1, j, k + 1) || dfs(i, j + 1, k + 1) || dfs(i, j - 1, k + 1);\n        board[i][j] = temp;\n        return res;\n    }\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (dfs(i, j, 0))\n                return true;\n        }\n    }\n    return false;\n}\n\n",
            "explanation": "For each of the implementation above, we use a Depth-First Search (DFS) based algorithm to traverse the grid board. The DFS function takes the current cell index i and j and the index of the character in the input word that we are looking for (k).\n\nThe base cases are:\n- If the cell indexes i or j are out of boundaries, or the board[i][j] character does not match word[k], return false.\n- If k (current character index) is equal to word.length - 1, we find the word in the grid, so return true.\n\nFor each cell, we run the DFS function with the given input parameters. If DFS returns true (found the word), the whole function will return true."
        },
        "structure": {
            "c++": "bool exist(vector<vector<char>>& board, string word)  {\n    // Your code here\n}\n\n",
            "java": "public boolean exist(char[][] board, String word)  {\n    // Your code here\n}\n\n",
            "python": "def exist(board, word):\n    # Your code here\n\n",
            "javascript": "function exist(board, word)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "bool exist(vector<vector<char>>& board, string word) {\n    int m = board.size();\n    int n = board[0].size();\n    \n    function<bool(int, int, int)> dfs = [&](int i, int j, int k) {\n        if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] != word[k])\n            return false;\n        if (k == word.length() - 1)\n            return true;\n        \n        char temp = board[i][j];\n        board[i][j] = '/';\n        bool res = dfs(i + 1, j, k + 1) || dfs(i - 1, j, k + 1) || dfs(i, j + 1, k + 1) || dfs(i, j - 1, k + 1);\n        board[i][j] = temp;\n        return res;\n    };\n    \n    for (int i = 0; i < m; i++)\n        for (int j = 0; j < n; j++)\n            if (dfs(i, j, 0))\n                return true;\n    return false;\n}",
            "java": "public boolean exist(char[][] board, String word) {\n    int m = board.length;\n    int n = board[0].length;\n\n    boolean[][] visited = new boolean[m][n];\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dfs(board, i, j, 0, word, visited)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean dfs(char[][] board, int i, int j, int k, String word, boolean[][] visited) {\n    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != word.charAt(k) || visited[i][j]) {\n        return false;\n    }\n\n    if (k == word.length() - 1) {\n        return true;\n    }\n\n    visited[i][j] = true;\n    boolean result = dfs(board, i + 1, j, k + 1, word, visited)\n            || dfs(board, i - 1, j, k + 1, word, visited)\n            || dfs(board, i, j + 1, k + 1, word, visited)\n            || dfs(board, i, j - 1, k + 1, word, visited);\n    visited[i][j] = false;\n\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    board = inputs[0]\n    word = inputs[1]\n    result = exist(board, word)\n    print(result)",
            "javascript": "function main() {\n    const inputs = $args\n    const board = inputs[0];\n    const word = inputs[1];\n    const result = exist(board, word);\n    console.log(result);\n}\nmain();"
        },
        "Qid": "79",
        "languages verified": [
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d5777949b33b6c4e2b09f"
        },
        "title": "Largest Rectangle in Histogram",
        "description": "Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, write a function that returns the area of the largest rectangle in the histogram.",
        "example": "Example:\n\nInput: heights = [2,1,5,6,2,3]\nOutput: 10\nExplanation: The above is a histogram where the width of each bar is 1. The largest rectangle is shown in the red area, which has an area of 10 units.",
        "level": "Medium",
        "tags": [
            "array",
            "stack",
            "histogram"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    1,
                    5,
                    6,
                    2,
                    3
                ],
                [
                    2,
                    4
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ]
            ],
            "outputs": [
                "10",
                "4",
                "9",
                "9",
                "5",
                "15",
                "30",
                "30",
                "10",
                "30"
            ]
        },
        "sample_code": {
            "c++": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nint largestRectangleArea(vector<int>& heights) {\n    heights.push_back(0); // Append a height of 0 to handle the case when all heights are in increasing order\n    stack<int> s;\n    int max_area = 0;\n    \n    for (int i = 0; i < heights.size(); i++) {\n        while (!s.empty() && heights[s.top()] > heights[i]) {\n            int height = heights[s.top()];\n            s.pop();\n            int width = s.empty() ? i : i - s.top() - 1; // Calculate the width correctly\n            max_area = max(max_area, height * width);\n        }\n        s.push(i);\n    }\n    \n    return max_area;\n}\n",
            "java": "public static int largestRectangleArea(int[] heights) {\n    Stack<Integer> stack = new Stack<>();\n    int max_area = 0;\n    for (int i = 0; i <= heights.length; i++) {\n        int height = (i == heights.length) ? 0 : heights[i];\n        while (!stack.isEmpty() && heights[stack.peek()] > height) {\n            int h = heights[stack.pop()];\n            int w = stack.isEmpty() ? i : i - stack.peek() - 1;\n            max_area = Math.max(max_area, h * w);\n        }\n        stack.push(i);\n    }\n    return max_area;\n}\n",
            "python": "def largestRectangleArea(heights):\n    stack = []\n    max_area = 0\n    for i, h in enumerate(heights + [0]):\n        while stack and heights[stack[-1]] > h:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        stack.append(i)\n    return max_area\n",
            "javascript": "function largestRectangleArea(heights) {\n    let stack = [];\n    let max_area = 0;\n    heights.push(0);\n    for (let i = 0; i < heights.length; i++) {\n        while (stack.length > 0 && heights[stack[stack.length - 1]] > heights[i]) {\n            let height = heights[stack.pop()];\n            let width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;\n            max_area = Math.max(max_area, height * width);\n        }\n        stack.push(i);\n    }\n    return max_area;\n}\n",
            "explanation": "The algorithm utilizes a stack to keep track of the indices of the heights array. It starts iterating through the array, appending a zero at the end to ensure the last bar is considered. When a higher bar is found, it is pushed onto the stack, and if a lower bar is found, it calculates the area of the bar under the current top of the stack considering the width between the current bar and the next lowest bar in the stack, storing the highest area found.\n\nThis algorithm has a time complexity of O(n) as it iterates through the heights only once, resulting in optimal performance."
        },
        "structure": {
            "c++": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\nint largestRectangleArea(vector<int>& heights)  {\n    // Your code here\n}\n",
            "java": "public int largestRectangleArea(int[] heights)  {\n    // Your code here\n}\n",
            "python": "def largestRectangleArea(heights):\n    # Your code here\n\n",
            "javascript": "function largestRectangleArea(heights)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> heights = $args;\n    int result = largestRectangleArea(heights);\n    std::cout <<\"$sprouts@pankaj\"<<result<<\"$sprouts@pankaj\";\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    int[] heights = $args;\n    int result = largestRectangleArea(heights);\n    System.out.println(\"$sprouts@pankaj\"+result+\"$sprouts@pankaj\");\n   }",
            "python": "if __name__ == \"__main__\":\n    heights = $args\n    result = largestRectangleArea(heights)\n    print(\"$sprouts@pankaj\",result,\"$sprouts@pankaj\"\n)",
            "javascript": "function main() {\n    const heights = $args;\n    const result = largestRectangleArea(heights);\n    console.log(\"$sprouts@pankaj\",result,\"$sprouts@pankaj\"\n);\n}\nmain();"
        },
        "Qid": "84",
        "languages verified": [
            "python",
            "javascript",
            "c++"
        ]
    },
    {
        "_id": {
            "$oid": "661d6653949b33b6c4e2b0a0"
        },
        "title": "Subset Power Set",
        "description": "Given an integer array `nums` of **unique** elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.",
        "example": "Example 1:\n\nInput: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\nExample 2:\n\nInput: nums = [0]\nOutput: [[],[0]]",
        "level": "Medium",
        "tags": [
            "Array",
            "Backtracking"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3
                ],
                [
                    0
                ],
                [
                    4,
                    5,
                    6
                ],
                [
                    -1,
                    0,
                    1
                ],
                [
                    10,
                    20,
                    30,
                    40
                ],
                [
                    7,
                    8,
                    9,
                    10,
                    11
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10,
                    12
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9,
                    11,
                    13
                ],
                [
                    2,
                    3,
                    5,
                    7,
                    11,
                    13,
                    17,
                    19
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    32,
                    64,
                    128,
                    256
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    5,
                    10,
                    15,
                    20,
                    25,
                    30,
                    35,
                    40,
                    45,
                    50
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50
                ]
            ],
            "outputs": [
                [
                    [],
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        3
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        1,
                        2,
                        3
                    ]
                ],
                [
                    [],
                    [
                        0
                    ]
                ],
                [
                    [],
                    [
                        4
                    ],
                    [
                        5
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        6
                    ],
                    [
                        4,
                        6
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        4,
                        5,
                        6
                    ]
                ],
                [
                    [],
                    [
                        -1
                    ],
                    [
                        0
                    ],
                    [
                        -1,
                        0
                    ],
                    [
                        1
                    ],
                    [
                        -1,
                        1
                    ],
                    [
                        0,
                        1
                    ],
                    [
                        -1,
                        0,
                        1
                    ]
                ],
                [
                    [],
                    [
                        10
                    ],
                    [
                        20
                    ],
                    [
                        10,
                        20
                    ],
                    [
                        30
                    ],
                    [
                        10,
                        30
                    ],
                    [
                        20,
                        30
                    ],
                    [
                        10,
                        20,
                        30
                    ],
                    [
                        40
                    ],
                    [
                        10,
                        40
                    ],
                    [
                        20,
                        40
                    ],
                    [
                        10,
                        20,
                        40
                    ],
                    [
                        30,
                        40
                    ],
                    [
                        10,
                        30,
                        40
                    ],
                    [
                        20,
                        30,
                        40
                    ],
                    [
                        10,
                        20,
                        30,
                        40
                    ]
                ],
                [
                    [],
                    [
                        7
                    ],
                    [
                        8
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        9
                    ],
                    [
                        7,
                        9
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        7,
                        8,
                        9
                    ],
                    [
                        10
                    ],
                    [
                        7,
                        10
                    ],
                    [
                        8,
                        10
                    ],
                    [
                        7,
                        8,
                        10
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        7,
                        9,
                        10
                    ],
                    [
                        8,
                        9,
                        10
                    ],
                    [
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11
                    ],
                    [
                        7,
                        11
                    ],
                    [
                        8,
                        11
                    ],
                    [
                        7,
                        8,
                        11
                    ],
                    [
                        9,
                        11
                    ],
                    [
                        7,
                        9,
                        11
                    ],
                    [
                        8,
                        9,
                        11
                    ],
                    [
                        7,
                        8,
                        9,
                        11
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        7,
                        10,
                        11
                    ],
                    [
                        8,
                        10,
                        11
                    ],
                    [
                        7,
                        8,
                        10,
                        11
                    ],
                    [
                        9,
                        10,
                        11
                    ],
                    [
                        7,
                        9,
                        10,
                        11
                    ],
                    [
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11
                    ]
                ],
                [
                    [],
                    [
                        2
                    ],
                    [
                        4
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        6
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        4,
                        6
                    ],
                    [
                        2,
                        4,
                        6
                    ],
                    [
                        8
                    ],
                    [
                        2,
                        8
                    ],
                    [
                        4,
                        8
                    ],
                    [
                        2,
                        4,
                        8
                    ],
                    [
                        6,
                        8
                    ],
                    [
                        2,
                        6,
                        8
                    ],
                    [
                        4,
                        6,
                        8
                    ],
                    [
                        2,
                        4,
                        6,
                        8
                    ],
                    [
                        10
                    ],
                    [
                        2,
                        10
                    ],
                    [
                        4,
                        10
                    ],
                    [
                        2,
                        4,
                        10
                    ],
                    [
                        6,
                        10
                    ],
                    [
                        2,
                        6,
                        10
                    ],
                    [
                        4,
                        6,
                        10
                    ],
                    [
                        2,
                        4,
                        6,
                        10
                    ],
                    [
                        8,
                        10
                    ],
                    [
                        2,
                        8,
                        10
                    ],
                    [
                        4,
                        8,
                        10
                    ],
                    [
                        2,
                        4,
                        8,
                        10
                    ],
                    [
                        6,
                        8,
                        10
                    ],
                    [
                        2,
                        6,
                        8,
                        10
                    ],
                    [
                        4,
                        6,
                        8,
                        10
                    ],
                    [
                        2,
                        4,
                        6,
                        8,
                        10
                    ],
                    [
                        12
                    ],
                    [
                        2,
                        12
                    ],
                    [
                        4,
                        12
                    ],
                    [
                        2,
                        4,
                        12
                    ],
                    [
                        6,
                        12
                    ],
                    [
                        2,
                        6,
                        12
                    ],
                    [
                        4,
                        6,
                        12
                    ],
                    [
                        2,
                        4,
                        6,
                        12
                    ],
                    [
                        8,
                        12
                    ],
                    [
                        2,
                        8,
                        12
                    ],
                    [
                        4,
                        8,
                        12
                    ],
                    [
                        2,
                        4,
                        8,
                        12
                    ],
                    [
                        6,
                        8,
                        12
                    ],
                    [
                        2,
                        6,
                        8,
                        12
                    ],
                    [
                        4,
                        6,
                        8,
                        12
                    ],
                    [
                        2,
                        4,
                        6,
                        8,
                        12
                    ]
                ],
                [
                    [],
                    [
                        1
                    ],
                    [
                        3
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        5
                    ],
                    [
                        1,
                        5
                    ],
                    [
                        3,
                        5
                    ],
                    [
                        1,
                        3,
                        5
                    ],
                    [
                        7
                    ],
                    [
                        1,
                        7
                    ],
                    [
                        3,
                        7
                    ],
                    [
                        1,
                        3,
                        7
                    ],
                    [
                        5,
                        7
                    ],
                    [
                        1,
                        5,
                        7
                    ],
                    [
                        3,
                        5,
                        7
                    ],
                    [
                        1,
                        3,
                        5,
                        7
                    ],
                    [
                        9
                    ],
                    [
                        1,
                        9
                    ],
                    [
                        3,
                        9
                    ],
                    [
                        1,
                        3,
                        9
                    ],
                    [
                        5,
                        9
                    ],
                    [
                        1,
                        5,
                        9
                    ],
                    [
                        3,
                        5,
                        9
                    ],
                    [
                        1,
                        3,
                        5,
                        9
                    ],
                    [
                        11
                    ],
                    [
                        1,
                        11
                    ],
                    [
                        3,
                        11
                    ],
                    [
                        1,
                        3,
                        11
                    ],
                    [
                        5,
                        11
                    ],
                    [
                        1,
                        5,
                        11
                    ],
                    [
                        3,
                        5,
                        11
                    ],
                    [
                        1,
                        3,
                        5,
                        11
                    ],
                    [
                        13
                    ],
                    [
                        1,
                        13
                    ],
                    [
                        3,
                        13
                    ],
                    [
                        1,
                        3,
                        13
                    ],
                    [
                        5,
                        13
                    ],
                    [
                        1,
                        5,
                        13
                    ],
                    [
                        3,
                        5,
                        13
                    ],
                    [
                        1,
                        3,
                        5,
                        13
                    ],
                    [
                        15
                    ],
                    [
                        1,
                        15
                    ],
                    [
                        3,
                        15
                    ],
                    [
                        1,
                        3,
                        15
                    ],
                    [
                        5,
                        15
                    ],
                    [
                        1,
                        5,
                        15
                    ],
                    [
                        3,
                        5,
                        15
                    ],
                    [
                        1,
                        3,
                        5,
                        15
                    ]
                ],
                [
                    [],
                    [
                        2
                    ],
                    [
                        3
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        5
                    ],
                    [
                        2,
                        5
                    ],
                    [
                        3,
                        5
                    ],
                    [
                        2,
                        3,
                        5
                    ],
                    [
                        7
                    ],
                    [
                        2,
                        7
                    ],
                    [
                        3,
                        7
                    ],
                    [
                        2,
                        3,
                        7
                    ],
                    [
                        5,
                        7
                    ],
                    [
                        2,
                        5,
                        7
                    ],
                    [
                        3,
                        5,
                        7
                    ],
                    [
                        2,
                        3,
                        5,
                        7
                    ],
                    [
                        11
                    ],
                    [
                        2,
                        11
                    ],
                    [
                        3,
                        11
                    ],
                    [
                        2,
                        3,
                        11
                    ],
                    [
                        5,
                        11
                    ],
                    [
                        2,
                        5,
                        11
                    ],
                    [
                        3,
                        5,
                        11
                    ],
                    [
                        2,
                        3,
                        5,
                        11
                    ],
                    [
                        13
                    ],
                    [
                        2,
                        13
                    ],
                    [
                        3,
                        13
                    ],
                    [
                        2,
                        3,
                        13
                    ],
                    [
                        5,
                        13
                    ],
                    [
                        2,
                        5,
                        13
                    ],
                    [
                        3,
                        5,
                        13
                    ],
                    [
                        2,
                        3,
                        5,
                        13
                    ],
                    [
                        17
                    ],
                    [
                        2,
                        17
                    ],
                    [
                        3,
                        17
                    ],
                    [
                        2,
                        3,
                        17
                    ],
                    [
                        5,
                        17
                    ],
                    [
                        2,
                        5,
                        17
                    ],
                    [
                        3,
                        5,
                        17
                    ],
                    [
                        2,
                        3,
                        5,
                        17
                    ],
                    [
                        19
                    ],
                    [
                        2,
                        19
                    ],
                    [
                        3,
                        19
                    ],
                    [
                        2,
                        3,
                        19
                    ],
                    [
                        5,
                        19
                    ],
                    [
                        2,
                        5,
                        19
                    ],
                    [
                        3,
                        5,
                        19
                    ],
                    [
                        2,
                        3,
                        5,
                        19
                    ]
                ],
                [
                    [],
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        4
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        1,
                        2,
                        4
                    ],
                    [
                        8
                    ],
                    [
                        1,
                        8
                    ],
                    [
                        2,
                        8
                    ],
                    [
                        1,
                        2,
                        8
                    ],
                    [
                        4,
                        8
                    ],
                    [
                        1,
                        4,
                        8
                    ],
                    [
                        2,
                        4,
                        8
                    ],
                    [
                        1,
                        2,
                        4,
                        8
                    ],
                    [
                        16
                    ],
                    [
                        1,
                        16
                    ],
                    [
                        2,
                        16
                    ],
                    [
                        1,
                        2,
                        16
                    ],
                    [
                        4,
                        16
                    ],
                    [
                        1,
                        4,
                        16
                    ],
                    [
                        2,
                        4,
                        16
                    ],
                    [
                        1,
                        2,
                        4,
                        16
                    ],
                    [
                        32
                    ],
                    [
                        1,
                        32
                    ],
                    [
                        2,
                        32
                    ],
                    [
                        1,
                        2,
                        32
                    ],
                    [
                        4,
                        32
                    ],
                    [
                        1,
                        4,
                        32
                    ],
                    [
                        2,
                        4,
                        32
                    ],
                    [
                        1,
                        2,
                        4,
                        32
                    ],
                    [
                        64
                    ],
                    [
                        1,
                        64
                    ],
                    [
                        2,
                        64
                    ],
                    [
                        1,
                        2,
                        64
                    ],
                    [
                        4,
                        64
                    ],
                    [
                        1,
                        4,
                        64
                    ],
                    [
                        2,
                        4,
                        64
                    ],
                    [
                        1,
                        2,
                        4,
                        64
                    ],
                    [
                        128
                    ],
                    [
                        1,
                        128
                    ],
                    [
                        2,
                        128
                    ],
                    [
                        1,
                        2,
                        128
                    ],
                    [
                        4,
                        128
                    ],
                    [
                        1,
                        4,
                        128
                    ],
                    [
                        2,
                        4,
                        128
                    ],
                    [
                        1,
                        2,
                        4,
                        128
                    ],
                    [
                        256
                    ],
                    [
                        1,
                        256
                    ],
                    [
                        2,
                        256
                    ],
                    [
                        1,
                        2,
                        256
                    ],
                    [
                        4,
                        256
                    ],
                    [
                        1,
                        4,
                        256
                    ],
                    [
                        2,
                        4,
                        256
                    ],
                    [
                        1,
                        2,
                        4,
                        256
                    ]
                ],
                [
                    [],
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        3
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        1,
                        2,
                        4
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        1,
                        3,
                        4
                    ],
                    [
                        2,
                        3,
                        4
                    ],
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5
                    ],
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        3,
                        5
                    ],
                    [
                        1,
                        3,
                        5
                    ],
                    [
                        2,
                        3,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        5
                    ],
                    [
                        6
                    ],
                    [
                        1,
                        6
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        1,
                        2,
                        6
                    ],
                    [
                        3,
                        6
                    ],
                    [
                        1,
                        3,
                        6
                    ],
                    [
                        2,
                        3,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        6
                    ],
                    [
                        7
                    ],
                    [
                        1,
                        7
                    ],
                    [
                        2,
                        7
                    ],
                    [
                        1,
                        2,
                        7
                    ],
                    [
                        3,
                        7
                    ],
                    [
                        1,
                        3,
                        7
                    ],
                    [
                        2,
                        3,
                        7
                    ],
                    [
                        1,
                        2,
                        3,
                        7
                    ],
                    [
                        8
                    ],
                    [
                        1,
                        8
                    ],
                    [
                        2,
                        8
                    ],
                    [
                        1,
                        2,
                        8
                    ],
                    [
                        3,
                        8
                    ],
                    [
                        1,
                        3,
                        8
                    ],
                    [
                        2,
                        3,
                        8
                    ],
                    [
                        1,
                        2,
                        3,
                        8
                    ],
                    [
                        9
                    ],
                    [
                        1,
                        9
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        1,
                        2,
                        9
                    ],
                    [
                        3,
                        9
                    ],
                    [
                        1,
                        3,
                        9
                    ],
                    [
                        2,
                        3,
                        9
                    ],
                    [
                        1,
                        2,
                        3,
                        9
                    ],
                    [
                        10
                    ],
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        10
                    ],
                    [
                        1,
                        2,
                        10
                    ],
                    [
                        3,
                        10
                    ],
                    [
                        1,
                        3,
                        10
                    ],
                    [
                        2,
                        3,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        10
                    ]
                ],
                [
                    [],
                    [
                        5
                    ],
                    [
                        10
                    ],
                    [
                        5,
                        10
                    ],
                    [
                        15
                    ],
                    [
                        5,
                        15
                    ],
                    [
                        10,
                        15
                    ],
                    [
                        5,
                        10,
                        15
                    ],
                    [
                        20
                    ],
                    [
                        5,
                        20
                    ],
                    [
                        10,
                        20
                    ],
                    [
                        5,
                        10,
                        20
                    ],
                    [
                        15,
                        20
                    ],
                    [
                        5,
                        15,
                        20
                    ],
                    [
                        10,
                        15,
                        20
                    ],
                    [
                        5,
                        10,
                        15,
                        20
                    ],
                    [
                        25
                    ],
                    [
                        5,
                        25
                    ],
                    [
                        10,
                        25
                    ],
                    [
                        5,
                        10,
                        25
                    ],
                    [
                        15,
                        25
                    ],
                    [
                        5,
                        15,
                        25
                    ],
                    [
                        10,
                        15,
                        25
                    ],
                    [
                        5,
                        10,
                        15,
                        25
                    ],
                    [
                        30
                    ],
                    [
                        5,
                        30
                    ],
                    [
                        10,
                        30
                    ],
                    [
                        5,
                        10,
                        30
                    ],
                    [
                        15,
                        30
                    ],
                    [
                        5,
                        15,
                        30
                    ],
                    [
                        10,
                        15,
                        30
                    ],
                    [
                        5,
                        10,
                        15,
                        30
                    ],
                    [
                        35
                    ],
                    [
                        5,
                        35
                    ],
                    [
                        10,
                        35
                    ],
                    [
                        5,
                        10,
                        35
                    ],
                    [
                        15,
                        35
                    ],
                    [
                        5,
                        15,
                        35
                    ],
                    [
                        10,
                        15,
                        35
                    ],
                    [
                        5,
                        10,
                        15,
                        35
                    ],
                    [
                        40
                    ],
                    [
                        5,
                        40
                    ],
                    [
                        10,
                        40
                    ],
                    [
                        5,
                        10,
                        40
                    ],
                    [
                        15,
                        40
                    ],
                    [
                        5,
                        15,
                        40
                    ],
                    [
                        10,
                        15,
                        40
                    ],
                    [
                        5,
                        10,
                        15,
                        40
                    ],
                    [
                        45
                    ],
                    [
                        5,
                        45
                    ],
                    [
                        10,
                        45
                    ],
                    [
                        5,
                        10,
                        45
                    ],
                    [
                        15,
                        45
                    ],
                    [
                        5,
                        15,
                        45
                    ],
                    [
                        10,
                        15,
                        45
                    ],
                    [
                        5,
                        10,
                        15,
                        45
                    ],
                    [
                        50
                    ],
                    [
                        5,
                        50
                    ],
                    [
                        10,
                        50
                    ],
                    [
                        5,
                        10,
                        50
                    ],
                    [
                        15,
                        50
                    ],
                    [
                        5,
                        15,
                        50
                    ],
                    [
                        10,
                        15,
                        50
                    ],
                    [
                        5,
                        10,
                        15,
                        50
                    ]
                ],
                [
                    [],
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        3
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        1,
                        2,
                        4
                    ],
                    [
                        5
                    ],
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        6
                    ],
                    [
                        1,
                        6
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        1,
                        2,
                        6
                    ],
                    [
                        7
                    ],
                    [
                        1,
                        7
                    ],
                    [
                        2,
                        7
                    ],
                    [
                        1,
                        2,
                        7
                    ],
                    [
                        8
                    ],
                    [
                        1,
                        8
                    ],
                    [
                        2,
                        8
                    ],
                    [
                        1,
                        2,
                        8
                    ],
                    [
                        9
                    ],
                    [
                        1,
                        9
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        1,
                        2,
                        9
                    ],
                    [
                        10
                    ],
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        10
                    ],
                    [
                        1,
                        2,
                        10
                    ],
                    [
                        11
                    ],
                    [
                        1,
                        11
                    ],
                    [
                        2,
                        11
                    ],
                    [
                        1,
                        2,
                        11
                    ],
                    [
                        12
                    ],
                    [
                        1,
                        12
                    ],
                    [
                        2,
                        12
                    ],
                    [
                        1,
                        2,
                        12
                    ],
                    [
                        13
                    ],
                    [
                        1,
                        13
                    ],
                    [
                        2,
                        13
                    ],
                    [
                        1,
                        2,
                        13
                    ],
                    [
                        14
                    ],
                    [
                        1,
                        14
                    ],
                    [
                        2,
                        14
                    ],
                    [
                        1,
                        2,
                        14
                    ],
                    [
                        15
                    ],
                    [
                        1,
                        15
                    ],
                    [
                        2,
                        15
                    ],
                    [
                        1,
                        2,
                        15
                    ]
                ],
                [
                    [],
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        3
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        1,
                        2,
                        4
                    ],
                    [
                        5
                    ],
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        6
                    ],
                    [
                        1,
                        6
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        1,
                        2,
                        6
                    ],
                    [
                        7
                    ],
                    [
                        1,
                        7
                    ],
                    [
                        2,
                        7
                    ],
                    [
                        1,
                        2,
                        7
                    ],
                    [
                        8
                    ],
                    [
                        1,
                        8
                    ],
                    [
                        2,
                        8
                    ],
                    [
                        1,
                        2,
                        8
                    ],
                    [
                        9
                    ],
                    [
                        1,
                        9
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        1,
                        2,
                        9
                    ],
                    [
                        10
                    ],
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        10
                    ],
                    [
                        1,
                        2,
                        10
                    ],
                    [
                        11
                    ],
                    [
                        1,
                        11
                    ],
                    [
                        2,
                        11
                    ],
                    [
                        1,
                        2,
                        11
                    ],
                    [
                        12
                    ],
                    [
                        1,
                        12
                    ],
                    [
                        2,
                        12
                    ],
                    [
                        1,
                        2,
                        12
                    ],
                    [
                        13
                    ],
                    [
                        1,
                        13
                    ],
                    [
                        2,
                        13
                    ],
                    [
                        1,
                        2,
                        13
                    ],
                    [
                        14
                    ],
                    [
                        1,
                        14
                    ],
                    [
                        2,
                        14
                    ],
                    [
                        1,
                        2,
                        14
                    ],
                    [
                        15
                    ],
                    [
                        1,
                        15
                    ],
                    [
                        2,
                        15
                    ],
                    [
                        1,
                        2,
                        15
                    ],
                    [
                        16
                    ],
                    [
                        1,
                        16
                    ],
                    [
                        2,
                        16
                    ],
                    [
                        1,
                        2,
                        16
                    ],
                    [
                        17
                    ],
                    [
                        1,
                        17
                    ],
                    [
                        2,
                        17
                    ],
                    [
                        1,
                        2,
                        17
                    ],
                    [
                        18
                    ],
                    [
                        1,
                        18
                    ],
                    [
                        2,
                        18
                    ],
                    [
                        1,
                        2,
                        18
                    ],
                    [
                        19
                    ],
                    [
                        1,
                        19
                    ],
                    [
                        2,
                        19
                    ],
                    [
                        1,
                        2,
                        19
                    ],
                    [
                        20
                    ],
                    [
                        1,
                        20
                    ],
                    [
                        2,
                        20
                    ],
                    [
                        1,
                        2,
                        20
                    ]
                ],
                [
                    [],
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        3
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        1,
                        2,
                        4
                    ],
                    [
                        5
                    ],
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        6
                    ],
                    [
                        1,
                        6
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        1,
                        2,
                        6
                    ],
                    [
                        7
                    ],
                    [
                        1,
                        7
                    ],
                    [
                        2,
                        7
                    ],
                    [
                        1,
                        2,
                        7
                    ],
                    [
                        8
                    ],
                    [
                        1,
                        8
                    ],
                    [
                        2,
                        8
                    ],
                    [
                        1,
                        2,
                        8
                    ],
                    [
                        9
                    ],
                    [
                        1,
                        9
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        1,
                        2,
                        9
                    ],
                    [
                        10
                    ],
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        10
                    ],
                    [
                        1,
                        2,
                        10
                    ],
                    [
                        11
                    ],
                    [
                        1,
                        11
                    ],
                    [
                        2,
                        11
                    ],
                    [
                        1,
                        2,
                        11
                    ],
                    [
                        12
                    ],
                    [
                        1,
                        12
                    ],
                    [
                        2,
                        12
                    ],
                    [
                        1,
                        2,
                        12
                    ],
                    [
                        13
                    ],
                    [
                        1,
                        13
                    ],
                    [
                        2,
                        13
                    ],
                    [
                        1,
                        2,
                        13
                    ],
                    [
                        14
                    ],
                    [
                        1,
                        14
                    ],
                    [
                        2,
                        14
                    ],
                    [
                        1,
                        2,
                        14
                    ],
                    [
                        15
                    ],
                    [
                        1,
                        15
                    ],
                    [
                        2,
                        15
                    ],
                    [
                        1,
                        2,
                        15
                    ],
                    [
                        16
                    ],
                    [
                        1,
                        16
                    ],
                    [
                        2,
                        16
                    ],
                    [
                        1,
                        2,
                        16
                    ],
                    [
                        17
                    ],
                    [
                        1,
                        17
                    ],
                    [
                        2,
                        17
                    ],
                    [
                        1,
                        2,
                        17
                    ],
                    [
                        18
                    ],
                    [
                        1,
                        18
                    ],
                    [
                        2,
                        18
                    ],
                    [
                        1,
                        2,
                        18
                    ],
                    [
                        19
                    ],
                    [
                        1,
                        19
                    ],
                    [
                        2,
                        19
                    ],
                    [
                        1,
                        2,
                        19
                    ],
                    [
                        20
                    ],
                    [
                        1,
                        20
                    ],
                    [
                        2,
                        20
                    ],
                    [
                        1,
                        2,
                        20
                    ],
                    [
                        21
                    ],
                    [
                        1,
                        21
                    ],
                    [
                        2,
                        21
                    ],
                    [
                        1,
                        2,
                        21
                    ],
                    [
                        22
                    ],
                    [
                        1,
                        22
                    ],
                    [
                        2,
                        22
                    ],
                    [
                        1,
                        2,
                        22
                    ],
                    [
                        23
                    ],
                    [
                        1,
                        23
                    ],
                    [
                        2,
                        23
                    ],
                    [
                        1,
                        2,
                        23
                    ],
                    [
                        24
                    ],
                    [
                        1,
                        24
                    ],
                    [
                        2,
                        24
                    ],
                    [
                        1,
                        2,
                        24
                    ],
                    [
                        25
                    ],
                    [
                        1,
                        25
                    ],
                    [
                        2,
                        25
                    ],
                    [
                        1,
                        2,
                        25
                    ]
                ],
                [
                    [],
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        3
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        1,
                        2,
                        4
                    ],
                    [
                        5
                    ],
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        6
                    ],
                    [
                        1,
                        6
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        1,
                        2,
                        6
                    ],
                    [
                        7
                    ],
                    [
                        1,
                        7
                    ],
                    [
                        2,
                        7
                    ],
                    [
                        1,
                        2,
                        7
                    ],
                    [
                        8
                    ],
                    [
                        1,
                        8
                    ],
                    [
                        2,
                        8
                    ],
                    [
                        1,
                        2,
                        8
                    ],
                    [
                        9
                    ],
                    [
                        1,
                        9
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        1,
                        2,
                        9
                    ],
                    [
                        10
                    ],
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        10
                    ],
                    [
                        1,
                        2,
                        10
                    ],
                    [
                        11
                    ],
                    [
                        1,
                        11
                    ],
                    [
                        2,
                        11
                    ],
                    [
                        1,
                        2,
                        11
                    ],
                    [
                        12
                    ],
                    [
                        1,
                        12
                    ],
                    [
                        2,
                        12
                    ],
                    [
                        1,
                        2,
                        12
                    ],
                    [
                        13
                    ],
                    [
                        1,
                        13
                    ],
                    [
                        2,
                        13
                    ],
                    [
                        1,
                        2,
                        13
                    ],
                    [
                        14
                    ],
                    [
                        1,
                        14
                    ],
                    [
                        2,
                        14
                    ],
                    [
                        1,
                        2,
                        14
                    ],
                    [
                        15
                    ],
                    [
                        1,
                        15
                    ],
                    [
                        2,
                        15
                    ],
                    [
                        1,
                        2,
                        15
                    ],
                    [
                        16
                    ],
                    [
                        1,
                        16
                    ],
                    [
                        2,
                        16
                    ],
                    [
                        1,
                        2,
                        16
                    ],
                    [
                        17
                    ],
                    [
                        1,
                        17
                    ],
                    [
                        2,
                        17
                    ],
                    [
                        1,
                        2,
                        17
                    ],
                    [
                        18
                    ],
                    [
                        1,
                        18
                    ],
                    [
                        2,
                        18
                    ],
                    [
                        1,
                        2,
                        18
                    ],
                    [
                        19
                    ],
                    [
                        1,
                        19
                    ],
                    [
                        2,
                        19
                    ],
                    [
                        1,
                        2,
                        19
                    ],
                    [
                        20
                    ],
                    [
                        1,
                        20
                    ],
                    [
                        2,
                        20
                    ],
                    [
                        1,
                        2,
                        20
                    ],
                    [
                        21
                    ],
                    [
                        1,
                        21
                    ],
                    [
                        2,
                        21
                    ],
                    [
                        1,
                        2,
                        21
                    ],
                    [
                        22
                    ],
                    [
                        1,
                        22
                    ],
                    [
                        2,
                        22
                    ],
                    [
                        1,
                        2,
                        22
                    ],
                    [
                        23
                    ],
                    [
                        1,
                        23
                    ],
                    [
                        2,
                        23
                    ],
                    [
                        1,
                        2,
                        23
                    ],
                    [
                        24
                    ],
                    [
                        1,
                        24
                    ],
                    [
                        2,
                        24
                    ],
                    [
                        1,
                        2,
                        24
                    ],
                    [
                        25
                    ],
                    [
                        1,
                        25
                    ],
                    [
                        2,
                        25
                    ],
                    [
                        1,
                        2,
                        25
                    ],
                    [
                        26
                    ],
                    [
                        1,
                        26
                    ],
                    [
                        2,
                        26
                    ],
                    [
                        1,
                        2,
                        26
                    ],
                    [
                        27
                    ],
                    [
                        1,
                        27
                    ],
                    [
                        2,
                        27
                    ],
                    [
                        1,
                        2,
                        27
                    ],
                    [
                        28
                    ],
                    [
                        1,
                        28
                    ],
                    [
                        2,
                        28
                    ],
                    [
                        1,
                        2,
                        28
                    ],
                    [
                        29
                    ],
                    [
                        1,
                        29
                    ],
                    [
                        2,
                        29
                    ],
                    [
                        1,
                        2,
                        29
                    ],
                    [
                        30
                    ],
                    [
                        1,
                        30
                    ],
                    [
                        2,
                        30
                    ],
                    [
                        1,
                        2,
                        30
                    ]
                ],
                [
                    [],
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        3
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        1,
                        2,
                        4
                    ],
                    [
                        5
                    ],
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        6
                    ],
                    [
                        1,
                        6
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        1,
                        2,
                        6
                    ],
                    [
                        7
                    ],
                    [
                        1,
                        7
                    ],
                    [
                        2,
                        7
                    ],
                    [
                        1,
                        2,
                        7
                    ],
                    [
                        8
                    ],
                    [
                        1,
                        8
                    ],
                    [
                        2,
                        8
                    ],
                    [
                        1,
                        2,
                        8
                    ],
                    [
                        9
                    ],
                    [
                        1,
                        9
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        1,
                        2,
                        9
                    ],
                    [
                        10
                    ],
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        10
                    ],
                    [
                        1,
                        2,
                        10
                    ],
                    [
                        11
                    ],
                    [
                        1,
                        11
                    ],
                    [
                        2,
                        11
                    ],
                    [
                        1,
                        2,
                        11
                    ],
                    [
                        12
                    ],
                    [
                        1,
                        12
                    ],
                    [
                        2,
                        12
                    ],
                    [
                        1,
                        2,
                        12
                    ],
                    [
                        13
                    ],
                    [
                        1,
                        13
                    ],
                    [
                        2,
                        13
                    ],
                    [
                        1,
                        2,
                        13
                    ],
                    [
                        14
                    ],
                    [
                        1,
                        14
                    ],
                    [
                        2,
                        14
                    ],
                    [
                        1,
                        2,
                        14
                    ],
                    [
                        15
                    ],
                    [
                        1,
                        15
                    ],
                    [
                        2,
                        15
                    ],
                    [
                        1,
                        2,
                        15
                    ],
                    [
                        16
                    ],
                    [
                        1,
                        16
                    ],
                    [
                        2,
                        16
                    ],
                    [
                        1,
                        2,
                        16
                    ],
                    [
                        17
                    ],
                    [
                        1,
                        17
                    ],
                    [
                        2,
                        17
                    ],
                    [
                        1,
                        2,
                        17
                    ],
                    [
                        18
                    ],
                    [
                        1,
                        18
                    ],
                    [
                        2,
                        18
                    ],
                    [
                        1,
                        2,
                        18
                    ],
                    [
                        19
                    ],
                    [
                        1,
                        19
                    ],
                    [
                        2,
                        19
                    ],
                    [
                        1,
                        2,
                        19
                    ],
                    [
                        20
                    ],
                    [
                        1,
                        20
                    ],
                    [
                        2,
                        20
                    ],
                    [
                        1,
                        2,
                        20
                    ],
                    [
                        21
                    ],
                    [
                        1,
                        21
                    ],
                    [
                        2,
                        21
                    ],
                    [
                        1,
                        2,
                        21
                    ],
                    [
                        22
                    ],
                    [
                        1,
                        22
                    ],
                    [
                        2,
                        22
                    ],
                    [
                        1,
                        2,
                        22
                    ],
                    [
                        23
                    ],
                    [
                        1,
                        23
                    ],
                    [
                        2,
                        23
                    ],
                    [
                        1,
                        2,
                        23
                    ],
                    [
                        24
                    ],
                    [
                        1,
                        24
                    ],
                    [
                        2,
                        24
                    ],
                    [
                        1,
                        2,
                        24
                    ],
                    [
                        25
                    ],
                    [
                        1,
                        25
                    ],
                    [
                        2,
                        25
                    ],
                    [
                        1,
                        2,
                        25
                    ],
                    [
                        26
                    ],
                    [
                        1,
                        26
                    ],
                    [
                        2,
                        26
                    ],
                    [
                        1,
                        2,
                        26
                    ],
                    [
                        27
                    ],
                    [
                        1,
                        27
                    ],
                    [
                        2,
                        27
                    ],
                    [
                        1,
                        2,
                        27
                    ],
                    [
                        28
                    ],
                    [
                        1,
                        28
                    ],
                    [
                        2,
                        28
                    ],
                    [
                        1,
                        2,
                        28
                    ],
                    [
                        29
                    ],
                    [
                        1,
                        29
                    ],
                    [
                        2,
                        29
                    ],
                    [
                        1,
                        2,
                        29
                    ],
                    [
                        30
                    ],
                    [
                        1,
                        30
                    ],
                    [
                        2,
                        30
                    ],
                    [
                        1,
                        2,
                        30
                    ],
                    [
                        31
                    ],
                    [
                        1,
                        31
                    ],
                    [
                        2,
                        31
                    ],
                    [
                        1,
                        2,
                        31
                    ],
                    [
                        32
                    ],
                    [
                        1,
                        32
                    ],
                    [
                        2,
                        32
                    ],
                    [
                        1,
                        2,
                        32
                    ],
                    [
                        33
                    ],
                    [
                        1,
                        33
                    ],
                    [
                        2,
                        33
                    ],
                    [
                        1,
                        2,
                        33
                    ],
                    [
                        34
                    ],
                    [
                        1,
                        34
                    ],
                    [
                        2,
                        34
                    ],
                    [
                        1,
                        2,
                        34
                    ],
                    [
                        35
                    ],
                    [
                        1,
                        35
                    ],
                    [
                        2,
                        35
                    ],
                    [
                        1,
                        2,
                        35
                    ],
                    [
                        36
                    ],
                    [
                        1,
                        36
                    ],
                    [
                        2,
                        36
                    ],
                    [
                        1,
                        2,
                        36
                    ],
                    [
                        37
                    ],
                    [
                        1,
                        37
                    ],
                    [
                        2,
                        37
                    ],
                    [
                        1,
                        2,
                        37
                    ],
                    [
                        38
                    ],
                    [
                        1,
                        38
                    ],
                    [
                        2,
                        38
                    ],
                    [
                        1,
                        2,
                        38
                    ],
                    [
                        39
                    ],
                    [
                        1,
                        39
                    ],
                    [
                        2,
                        39
                    ],
                    [
                        1,
                        2,
                        39
                    ],
                    [
                        40
                    ],
                    [
                        1,
                        40
                    ],
                    [
                        2,
                        40
                    ],
                    [
                        1,
                        2,
                        40
                    ]
                ],
                [
                    [],
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        3
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        1,
                        2,
                        4
                    ],
                    [
                        5
                    ],
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        6
                    ],
                    [
                        1,
                        6
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        1,
                        2,
                        6
                    ],
                    [
                        7
                    ],
                    [
                        1,
                        7
                    ],
                    [
                        2,
                        7
                    ],
                    [
                        1,
                        2,
                        7
                    ],
                    [
                        8
                    ],
                    [
                        1,
                        8
                    ],
                    [
                        2,
                        8
                    ],
                    [
                        1,
                        2,
                        8
                    ],
                    [
                        9
                    ],
                    [
                        1,
                        9
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        1,
                        2,
                        9
                    ],
                    [
                        10
                    ],
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        10
                    ],
                    [
                        1,
                        2,
                        10
                    ],
                    [
                        11
                    ],
                    [
                        1,
                        11
                    ],
                    [
                        2,
                        11
                    ],
                    [
                        1,
                        2,
                        11
                    ],
                    [
                        12
                    ],
                    [
                        1,
                        12
                    ],
                    [
                        2,
                        12
                    ],
                    [
                        1,
                        2,
                        12
                    ],
                    [
                        13
                    ],
                    [
                        1,
                        13
                    ],
                    [
                        2,
                        13
                    ],
                    [
                        1,
                        2,
                        13
                    ],
                    [
                        14
                    ],
                    [
                        1,
                        14
                    ],
                    [
                        2,
                        14
                    ],
                    [
                        1,
                        2,
                        14
                    ],
                    [
                        15
                    ],
                    [
                        1,
                        15
                    ],
                    [
                        2,
                        15
                    ],
                    [
                        1,
                        2,
                        15
                    ],
                    [
                        16
                    ],
                    [
                        1,
                        16
                    ],
                    [
                        2,
                        16
                    ],
                    [
                        1,
                        2,
                        16
                    ],
                    [
                        17
                    ],
                    [
                        1,
                        17
                    ],
                    [
                        2,
                        17
                    ],
                    [
                        1,
                        2,
                        17
                    ],
                    [
                        18
                    ],
                    [
                        1,
                        18
                    ],
                    [
                        2,
                        18
                    ],
                    [
                        1,
                        2,
                        18
                    ],
                    [
                        19
                    ],
                    [
                        1,
                        19
                    ],
                    [
                        2,
                        19
                    ],
                    [
                        1,
                        2,
                        19
                    ],
                    [
                        20
                    ],
                    [
                        1,
                        20
                    ],
                    [
                        2,
                        20
                    ],
                    [
                        1,
                        2,
                        20
                    ],
                    [
                        21
                    ],
                    [
                        1,
                        21
                    ],
                    [
                        2,
                        21
                    ],
                    [
                        1,
                        2,
                        21
                    ],
                    [
                        22
                    ],
                    [
                        1,
                        22
                    ],
                    [
                        2,
                        22
                    ],
                    [
                        1,
                        2,
                        22
                    ],
                    [
                        23
                    ],
                    [
                        1,
                        23
                    ],
                    [
                        2,
                        23
                    ],
                    [
                        1,
                        2,
                        23
                    ],
                    [
                        24
                    ],
                    [
                        1,
                        24
                    ],
                    [
                        2,
                        24
                    ],
                    [
                        1,
                        2,
                        24
                    ],
                    [
                        25
                    ],
                    [
                        1,
                        25
                    ],
                    [
                        2,
                        25
                    ],
                    [
                        1,
                        2,
                        25
                    ],
                    [
                        26
                    ],
                    [
                        1,
                        26
                    ],
                    [
                        2,
                        26
                    ],
                    [
                        1,
                        2,
                        26
                    ],
                    [
                        27
                    ],
                    [
                        1,
                        27
                    ],
                    [
                        2,
                        27
                    ],
                    [
                        1,
                        2,
                        27
                    ],
                    [
                        28
                    ],
                    [
                        1,
                        28
                    ],
                    [
                        2,
                        28
                    ],
                    [
                        1,
                        2,
                        28
                    ],
                    [
                        29
                    ],
                    [
                        1,
                        29
                    ],
                    [
                        2,
                        29
                    ],
                    [
                        1,
                        2,
                        29
                    ],
                    [
                        30
                    ],
                    [
                        1,
                        30
                    ],
                    [
                        2,
                        30
                    ],
                    [
                        1,
                        2,
                        30
                    ],
                    [
                        31
                    ],
                    [
                        1,
                        31
                    ],
                    [
                        2,
                        31
                    ],
                    [
                        1,
                        2,
                        31
                    ],
                    [
                        32
                    ],
                    [
                        1,
                        32
                    ],
                    [
                        2,
                        32
                    ],
                    [
                        1,
                        2,
                        32
                    ],
                    [
                        33
                    ],
                    [
                        1,
                        33
                    ],
                    [
                        2,
                        33
                    ],
                    [
                        1,
                        2,
                        33
                    ],
                    [
                        34
                    ],
                    [
                        1,
                        34
                    ],
                    [
                        2,
                        34
                    ],
                    [
                        1,
                        2,
                        34
                    ],
                    [
                        35
                    ],
                    [
                        1,
                        35
                    ],
                    [
                        2,
                        35
                    ],
                    [
                        1,
                        2,
                        35
                    ],
                    [
                        36
                    ],
                    [
                        1,
                        36
                    ],
                    [
                        2,
                        36
                    ],
                    [
                        1,
                        2,
                        36
                    ],
                    [
                        37
                    ],
                    [
                        1,
                        37
                    ],
                    [
                        2,
                        37
                    ],
                    [
                        1,
                        2,
                        37
                    ],
                    [
                        38
                    ],
                    [
                        1,
                        38
                    ],
                    [
                        2,
                        38
                    ],
                    [
                        1,
                        2,
                        38
                    ],
                    [
                        39
                    ],
                    [
                        1,
                        39
                    ],
                    [
                        2,
                        39
                    ],
                    [
                        1,
                        2,
                        39
                    ],
                    [
                        40
                    ],
                    [
                        1,
                        40
                    ],
                    [
                        2,
                        40
                    ],
                    [
                        1,
                        2,
                        40
                    ],
                    [
                        41
                    ],
                    [
                        1,
                        41
                    ],
                    [
                        2,
                        41
                    ],
                    [
                        1,
                        2,
                        41
                    ],
                    [
                        42
                    ],
                    [
                        1,
                        42
                    ],
                    [
                        2,
                        42
                    ],
                    [
                        1,
                        2,
                        42
                    ],
                    [
                        43
                    ],
                    [
                        1,
                        43
                    ],
                    [
                        2,
                        43
                    ],
                    [
                        1,
                        2,
                        43
                    ],
                    [
                        44
                    ],
                    [
                        1,
                        44
                    ],
                    [
                        2,
                        44
                    ],
                    [
                        1,
                        2,
                        44
                    ],
                    [
                        45
                    ],
                    [
                        1,
                        45
                    ],
                    [
                        2,
                        45
                    ],
                    [
                        1,
                        2,
                        45
                    ],
                    [
                        46
                    ],
                    [
                        1,
                        46
                    ],
                    [
                        2,
                        46
                    ],
                    [
                        1,
                        2,
                        46
                    ],
                    [
                        47
                    ],
                    [
                        1,
                        47
                    ],
                    [
                        2,
                        47
                    ],
                    [
                        1,
                        2,
                        47
                    ],
                    [
                        48
                    ],
                    [
                        1,
                        48
                    ],
                    [
                        2,
                        48
                    ],
                    [
                        1,
                        2,
                        48
                    ],
                    [
                        49
                    ],
                    [
                        1,
                        49
                    ],
                    [
                        2,
                        49
                    ],
                    [
                        1,
                        2,
                        49
                    ],
                    [
                        50
                    ],
                    [
                        1,
                        50
                    ],
                    [
                        2,
                        50
                    ],
                    [
                        1,
                        2,
                        50
                    ]
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nstd::vector<std::vector<int>> subsets(std::vector<int>& nums) {\n    std::vector<std::vector<int>> result;\n    int n = nums.size();\n    int num_subsets = 1 << n;\n\n    for (int i = 0; i < num_subsets; ++i) {\n        std::vector<int> subset;\n        for (int j = 0; j < n; ++j) {\n            if (i & (1 << j)) {\n                subset.push_back(nums[j]);\n            }\n        }\n        result.push_back(subset);\n    }\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    int n = nums.length;\n    int num_subsets = 1 << n;\n\n    for (int i = 0; i < num_subsets; ++i) {\n        List<Integer> subset = new ArrayList<>();\n        for (int j = 0; j < n; ++j) {\n            if ((i & (1 << j)) != 0) {\n                subset.add(nums[j]);\n            }\n        }\n        result.add(subset);\n    }\n    return result;\n}\n",
            "python": "def subsets(nums):\n    n = len(nums)\n    num_subsets = 1 << n\n    result = []\n\n    for i in range(num_subsets):\n        subset = []\n        for j in range(n):\n            if i & (1 << j):\n                subset.append(nums[j])\n        result.append(subset)\n    return result\n",
            "javascript": "function subsets(nums) {\n    let result = [];\n    let n = nums.length;\n    let num_subsets = 1 << n;\n\n    for (let i = 0; i < num_subsets; ++i) {\n        let subset = [];\n        for (let j = 0; j < n; ++j) {\n            if (i & (1 << j)) {\n                subset.push(nums[j]);\n            }\n        }\n        result.push(subset);\n    }\n    return result;\n}\n",
            "explanation": "1. Calculate the number of subsets in the power set (2^n) using bit manipulation.\n2. Loop through all numbers from 0 to 2^n - 1.\n3. For each number, loop through its bits, and if the bit is set (1), include the corresponding element from the input array in the current subset.\n4. Add the current subset to the result list.\n5. After the loops finish, return the result list containing all subsets."
        },
        "structure": {
            "c++": "#include <vector>\n\nstd::vector<std::vector<int>> subsets(std::vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> subsets(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def subsets(nums):\n    # Your code here\n\n",
            "javascript": "function subsets(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nstd::vector<std::vector<int>> subsets(std::vector<int>& nums);\n\nint main() {\n    std::vector<int> nums = $args;\n    std::vector<std::vector<int>> result = subsets(nums);\n\n    for (const auto& subset : result) {\n        std::cout << '[';\n        for (int i = 0; i < subset.size(); ++i) {\n            std::cout << subset[i];\n            if (i != subset.size() - 1) {\n                std::cout << ',';\n            }\n        }\n        std::cout << ']';\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n",
            "java": "public List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    int n = nums.length;\n    int num_subsets = 1 << n;\n\n    for (int i = 0; i < num_subsets; ++i) {\n        List<Integer> subset = new ArrayList<>();\n        for (int j = 0; j < n; ++j) {\n            if ((i & (1 << j)) != 0) {\n                subset.add(nums[j]);\n            }\n        }\n        result.add(subset);\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = subsets(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = subsets(nums);\n    console.log(result);\n}"
        },
        "Qid": "78",
        "languages verified": [
            "python"
        ]
    },
    {
        "_id": {
            "$oid": "661d67e5949b33b6c4e2b0a1"
        },
        "title": "Merge Sorted Arrays",
        "description": "You are given two integer arrays `nums1` and `nums2`, sorted in **non-decreasing order**, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively. Merge `nums1` and `nums2` into a single array sorted in **non-decreasing order**. The final sorted array should not be returned by the function, but instead be _stored inside the array_ `nums1`. To accommodate this, `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to `0` and should be ignored. `nums2` has a length of `n`.",
        "example": "Example:\n\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\nOutput: [1,2,2,3,5,6]\nExplanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.",
        "level": "Easy",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        2,
                        5,
                        6
                    ],
                    3
                ],
                [
                    [
                        1
                    ],
                    1,
                    [],
                    0
                ],
                [
                    [
                        0
                    ],
                    0,
                    [
                        1
                    ],
                    1
                ],
                [
                    [
                        1,
                        3,
                        5,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        2,
                        4,
                        6
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    6,
                    [],
                    0
                ],
                [
                    [],
                    0,
                    [
                        1,
                        2,
                        3
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    3,
                    [
                        7,
                        8,
                        9
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        4,
                        5,
                        6
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        0,
                        0,
                        0
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        1,
                        2,
                        3
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        0,
                        0,
                        1
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        0,
                        1,
                        2
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        0,
                        1,
                        3
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        0,
                        2,
                        3
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        1,
                        2,
                        4
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        1,
                        3,
                        4
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        2,
                        3,
                        4
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        0,
                        0,
                        0
                    ],
                    3,
                    [
                        2,
                        2,
                        2,
                        2,
                        2
                    ],
                    5
                ]
            ],
            "outputs": [
                [
                    1,
                    2,
                    2,
                    3,
                    5,
                    6
                ],
                [
                    1
                ],
                [
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6
                ],
                [
                    1,
                    2,
                    3
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6
                ],
                [
                    1,
                    2,
                    3
                ],
                [
                    1,
                    1,
                    2,
                    2,
                    3,
                    3
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2,
                    3,
                    3
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2,
                    3,
                    3
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2,
                    3,
                    3
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2,
                    3,
                    3
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2,
                    3,
                    4
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2,
                    3,
                    4
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    2,
                    2,
                    3,
                    4
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    2,
                    3
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    1,
                    1,
                    1,
                    1,
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    1,
                    1,
                    1,
                    1,
                    2,
                    2,
                    2,
                    2,
                    2
                ]
            ]
        },
        "sample_code": {
            "c++": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n    int i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j])\n            nums1[k--] = nums1[i--];\n        else\n            nums1[k--] = nums2[j--];\n    }\n    while (j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n}\n",
            "java": "public void merge(int[] nums1, int m, int[] nums2, int n) {\n    int i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j])\n            nums1[k--] = nums1[i--];\n        else\n            nums1[k--] = nums2[j--];\n    }\n    while (j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n}\n",
            "python": "def merge(nums1, m, nums2, n):\n    i, j, k = m - 1, n - 1, m + n - 1\n    while i >= 0 and j >= 0:\n        if nums1[i] > nums2[j]:\n            nums1[k] = nums1[i]\n            i -= 1\n        else:\n            nums1[k] = nums2[j]\n            j -= 1\n        k -= 1\n    while j >= 0:\n        nums1[k] = nums2[j]\n        k -= 1\n        j -= 1\n",
            "javascript": "function merge(nums1, m, nums2, n) {\n    let i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j])\n            nums1[k--] = nums1[i--];\n        else\n            nums1[k--] = nums2[j--];\n    }\n    while (j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n}\n",
            "explanation": "We use a two-pointer approach to merge nums1 and nums2 in reverse order. Initialize three pointers i, j, and k pointing to the last elements of nums1, nums2, and the merged nums1 array respectively.\n\nIterate in a while loop until i and j are both less than 0. Compare the values of nums1[i] and nums2[j]. If nums1[i] is greater, assign nums1[i] at position k in nums1, decrement i and k. Otherwise, assign nums2[j] at position k in nums1, and decrement j and k. This process continues for all elements in nums2.\n\nAfter the loop, if there are still elements remaining in nums2 (j >= 0), copy the remaining elements of nums2 to nums1. In this way, we merge nums1 and nums2 in non-decreasing order."
        },
        "structure": {
            "c++": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n)  {\n    // Your code here\n}\n",
            "java": "public void merge(int[] nums1, int m, int[] nums2, int n)  {\n    // Your code here\n}\n",
            "python": "def merge(nums1, m, nums2, n):\n    # Your code here\n\n",
            "javascript": "function merge(nums1, m, nums2, n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n    int i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j])\n            nums1[k--] = nums1[i--];\n        else\n            nums1[k--] = nums2[j--];\n    }\n    while (j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n}\n\nint main() {\n    vector<int> nums1 = $args;\n    int m = nums1.size();\n    vector<int> nums2;\n    int n = nums2.size();\n    merge(nums1, m, nums2, n);\n    for (int i = 0; i < m + n; i++) {\n        cout << nums1[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    nums1 = inputs[0]\n    m = inputs[1]\n    nums2 = inputs[2]\n    n = inputs[3]\n    merge(nums1, m, nums2, n)\n    print(nums1)",
            "javascript": "function main() {\n    input=$args\n    const nums1 = input[0];\n    const m = nums1.length;\n    const nums2 = input[1];\n    const n = nums2.length;\n    merge(nums1, m, nums2, n);\n    console.log(nums1);\n}\nmain();",
            "java": ""
        },
        "Qid": "88",
        "languages verified": [
            "python"
        ]
    },
    {
        "_id": {
            "$oid": "661d685d949b33b6c4e2b0a2"
        },
        "title": "Decode Message",
        "description": "A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:\n\n'A' ->  \"1 \"\n'B' ->  \"2 \"\n...\n'Z' ->  \"26 \"\n\nTo **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106 \"` can be mapped into:\n\n*   `\"AAJF \"` with the grouping `(1 1 10 6)`\n*   `\"KJF \"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06 \"` cannot be mapped into `'F'` since `\"6 \"` is different from `\"06 \"`.\n\nGiven a string `s` containing only digits, return the **number** of ways to **decode** it.\n",
        "example": "Example:\n\nInput: s =  \"12 \"\nOutput: 2\nExplanation:  \"12 \" could be decoded as  \"AB \" (1 2) or  \"L \" (12).\n\nInput: s =  \"226 \"\nOutput: 3\nExplanation:  \"226 \" could be decoded as  \"BZ \" (2 26),  \"VF \" (22 6), or  \"BBF \" (2 2 6).\n\nInput: s =  \"06 \"\nOutput: 0\nExplanation:  \"06 \" cannot be mapped to  \"F \" because of the leading zero ( \"6 \" is different from  \"06 \").",
        "level": "Medium",
        "tags": [
            "String",
            "Dynamic Programming"
        ],
        "test_cases": {
            "inputs": [
                "12 ",
                "226 ",
                "11106 ",
                "1234567890",
                "1111111111",
                "1010101010",
                "2222222222",
                "9999999999",
                "12345678901234567890",
                "11111111111111111111",
                "10101010101010101010",
                "22222222222222222222",
                "99999999999999999999",
                "123456789012345678901234567890",
                "111111111111111111111111111111",
                "101010101010101010101010101010",
                "222222222222222222222222222222",
                "999999999999999999999999999999",
                "1234567890123456789012345678901234567890"
            ],
            "outputs": [
                2,
                3,
                4,
                89,
                89,
                89,
                89,
                89,
                10946,
                10946,
                10946,
                10946,
                10946,
                17711,
                17711,
                17711,
                17711,
                17711,
                28657
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nint numDecodings(std::string s) {\n    int n = s.size();\n    std::vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n    dp[1] = s[0] != '0' ? 1 : 0;\n\n    for (int i = 2; i <= n; ++i) {\n        int oneDigit = stoi(s.substr(i - 1, 1));\n        int twoDigits = stoi(s.substr(i - 2, 2));\n\n        if (oneDigit >= 1)\n            dp[i] += dp[i - 1];\n        if (twoDigits >= 10 && twoDigits <= 26)\n            dp[i] += dp[i - 2];\n    }\n    return dp[n];\n}\n\n",
            "java": "public static int numDecodings(String s) {\n    int n = s.length();\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = s.charAt(0) != '0' ? 1 : 0;\n\n    for (int i = 2; i <= n; i++) {\n        int oneDigit = Integer.parseInt(s.substring(i - 1, i));\n        int twoDigits = Integer.parseInt(s.substring(i - 2, i));\n\n        if (oneDigit >= 1)\n            dp[i] += dp[i - 1];\n        if (twoDigits >= 10 && twoDigits <= 26)\n            dp[i] += dp[i - 2];\n    }\n    return dp[n];\n}\n\n",
            "python": "def numDecodings(s: str) -> int:\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1 if s[0] != '0' else 0\n\n    for i in range(2, n + 1):\n        one_digit = int(s[i - 1:i])\n        two_digits = int(s[i - 2:i])\n\n        if one_digit >= 1:\n            dp[i] += dp[i - 1]\n        if two_digits >= 10 and two_digits <= 26:\n            dp[i] += dp[i - 2]\n    return dp[n]\n\n",
            "javascript": "var numDecodings = function(s) {\n    const n = s.length;\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = s[0] !== '0' ? 1 : 0;\n\n    for (let i = 2; i <= n; i++) {\n        const oneDigit = parseInt(s.slice(i - 1, i), 10);\n        const twoDigits = parseInt(s.slice(i - 2, i), 10);\n\n        if (oneDigit >= 1)\n            dp[i] += dp[i - 1];\n        if (twoDigits >= 10 && twoDigits <= 26)\n            dp[i] += dp[i - 2];\n    }\n    return dp[n];\n};\n\n",
            "explanation": "We use dynamic programming (DP) to solve this problem. The `dp` array is of size `n+1`, where `n` is the length of the input string `s`. `dp[i]` stores the number of ways to decode the substring `s[0:i]`.\n\nInitialize `dp[0]` to 1 because there is always one way to decode an empty string.\n\nFor each character in the string `s`, consider its corresponding one-digit and two-digits representations. If the one-digit representation is valid (>=1), we can increment `dp[i]` by `dp[i-1]`, which means one more way to decode the string by using the one-digit representation of the current character. If the two-digits representation is valid (>=10 and <=26), we can increment `dp[i]` by `dp[i-2]`, meaning one way to decode the string by using the two-digits representation of the current character.\n\nAfter we finished iterating through the string `s`, `dp[n]` will store the number of ways to decode the entire string."
        },
        "structure": {
            "c++": "#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nint numDecodings(std::string s) {\n    // Your code here\n}\n\n",
            "java": "public int numDecodings(String s) {\n    // Your code here\n}\n\n",
            "python": "def numDecodings(s: str) -> int:\n    # Your code here\n\n",
            "javascript": "var numDecodings = function(s) {\n    // Your code here\n};\n\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    string s = $args;\n    int result = numDecodings(s);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = numDecodings(s)\n    print(result)",
            "java": "public static void main(String[] args) {\n    String s = $args;\n    int result = numDecodings(s);\n    System.out.println(result);\n}\n",
            "javascript": "function main() {\n    const s = $args;\n    const result = numDecodings(s);\n    console.log(result);\n}\nmain();"
        },
        "Qid": "91",
        "languages verified": [
            "python",
            "javascript",
            "c++",
            "java"
        ]
    },
    {
        "_id": {
            "$oid": "661d6b79949b33b6c4e2b0a3"
        },
        "title": "Interleaving Strings",
        "description": "Given strings `s1`, `s2`, and `s3`, find whether `s3` is formed by an **interleaving** of `s1` and `s2`. An **interleaving** of two strings `s` and `t` is a configuration where `s` and `t` are divided into `n` and `m` substrings respectively, such that: `s = s1 + s2 + ... + sn`, `t = t1 + t2 + ... + tm`, and `|n - m| <= 1`. The **interleaving** is `s1 + t1 + s2 + t2 + s3 + t3 + ...` or `t1 + s1 + t2 + s2 + t3 + s3 + ...`. Determine if `s3` can be obtained by interleaving `s1` and `s2`.",
        "example": "Given s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\", the function should return true. One way to obtain s3 is by splitting s1 into s1 = \"aa\" + \"bc\" + \"c\" and s2 into s2 = \"dbbc\" + \"a\". Interleaving the two splits, we get \"aa\" + \"dbbc\" + \"bc\" + \"a\" + \"c\" = \"aadbbcbcac\". Since s3 can be obtained by interleaving s1 and s2, the function should return true.",
        "level": "Medium",
        "tags": [
            "string",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    "aabcc",
                    "dbbca",
                    "aadbbcbcac"
                ],
                [
                    "aabcc",
                    "dbbca",
                    "aadbbbaccc"
                ],
                [
                    "",
                    "",
                    ""
                ],
                [
                    "abc",
                    "def",
                    "abcdef"
                ],
                [
                    "abc",
                    "def",
                    "abdecf"
                ],
                [
                    "abc",
                    "def",
                    "abcfed"
                ],
                [
                    "abc",
                    "def",
                    "abcfedg"
                ],
                [
                    "abc",
                    "def",
                    "abcfedgh"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghi"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghij"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghijk"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghijkl"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghijklm"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghijklmn"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghijklmno"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghijklmnop"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghijklmnopq"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghijklmnopqr"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghijklmnopqrs"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghijklmnopqrst"
                ],
                [
                    "abc",
                    "def",
                    "abcfedghijklmnopqrstu"
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "bool isInterleave(string s1, string s2, string s3) {\n    int m = s1.length(), n = s2.length();\n    if (m + n != s3.length()) return false;\n\n    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\n    dp[0][0] = true;\n    for (int i = 1; i <= m; i++)\n        dp[i][0] = dp[i - 1][0] && s1[i - 1] == s3[i - 1];\n    for (int j = 1; j <= n; j++)\n        dp[0][j] = dp[0][j - 1] && s2[j - 1] == s3[j - 1];\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) ||\n                       (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\n        }\n    }\n\n    return dp[m][n];\n}\n",
            "java": "public boolean isInterleave(String s1, String s2, String s3) {\n    int m = s1.length(), n = s2.length();\n    if (m + n != s3.length()) return false;\n\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n    for (int i = 1; i <= m; i++)\n        dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1);\n    for (int j = 1; j <= n; j++)\n        dp[0][j] = dp[0][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) ||\n                       (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\n        }\n    }\n\n    return dp[m][n];\n}\n",
            "python": "def isInterleave(s1, s2, s3):\n    m, n = len(s1), len(s2)\n    if m + n != len(s3):\n        return False\n\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    for i in range(1, m + 1):\n        dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or \\\n                       (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]\n",
            "javascript": "function isInterleave(s1, s2, s3) {\n    let m = s1.length, n = s2.length;\n    if (m + n !== s3.length) return false;\n\n    let dp = new Array(m + 1).fill(null).map(() => new Array(n + 1).fill(false));\n    dp[0][0] = true;\n    for (let i = 1; i <= m; i++)\n        dp[i][0] = dp[i - 1][0] && s1[i - 1] === s3[i - 1];\n    for (let j = 1; j <= n; j++)\n        dp[0][j] = dp[0][j - 1] && s2[j - 1] === s3[j - 1];\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            dp[i][j] = (dp[i - 1][j] && s1[i - 1] === s3[i + j - 1]) ||\n                       (dp[i][j - 1] && s2[j - 1] === s3[i + j - 1]);\n        }\n    }\n\n    return dp[m][n];\n}\n",
            "explanation": "We use a dynamic programming approach (2D DP) to solve this problem. The algorithm checks whether the s3[position] is equal to s1 or s2 in the same dp[position]. If so, we take the value of the previous dp[i-1] or dp[j-1] accordingly if the characters match. For the base case, we start with initializing dp[0][0] to true since two empty strings can form an empty s3.\n\nAt the end of the iterations, the last element in the dp matrix (i.e. dp[m][n]) will represent whether s3 can be formed by an interleaving of s1 and s2."
        },
        "structure": {
            "c++": "bool isInterleave(string s1, string s2, string s3)  {\n    // Your code here\n}\n",
            "java": "public boolean isInterleave(String s1, String s2, String s3)  {\n    // Your code here\n}\n",
            "python": "def isInterleave(s1, s2, s3):\n    # Your code here\n\n",
            "javascript": "function isInterleave(s1, s2, s3)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "bool isInterleave(string s1, string s2, string s3) {\n    int m = s1.length(), n = s2.length();\n    if (m + n != s3.length()) return false;\n\n    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\n    dp[0][0] = true;\n    for (int i = 1; i <= m; i++)\n        dp[i][0] = dp[i - 1][0] && s1[i - 1] == s3[i - 1];\n    for (int j = 1; j <= n; j++)\n        dp[0][j] = dp[0][j - 1] && s2[j - 1] == s3[j - 1];\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) ||\n                       (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\n        }\n    }\n\n    return dp[m][n];\n}",
            "java": "public boolean isInterleave(String s1, String s2, String s3) {\n    int m = s1.length(), n = s2.length();\n    if (m + n != s3.length()) return false;\n\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n    for (int i = 1; i <= m; i++)\n        dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1);\n    for (int j = 1; j <= n; j++)\n        dp[0][j] = dp[0][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) ||\n                       (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\n        }\n    }\n\n    return dp[m][n];\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=['aabcc', 'dbbca', 'aadbbcbcac']\n    s1 = inputs[0]\n    s2 = inputs[1]\n    s3 = inputs[2]\n    result = isInterleave(s1, s2, s3)\n    print(result)",
            "javascript": "function main() {\n    input=$args\n    const s1 = input[0];\n    const s2 = input[1];\n    const s3 = input[2];\n    const result = isInterleave(s1, s2, s3);\n    console.log(result);\n}\nmain();"
        },
        "Qid": "97",
        "languages verified": [
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d6e27949b33b6c4e2b0a4"
        },
        "title": "Distinct Subsequences",
        "description": "Given two strings `s` and `t`, return the number of distinct subsequences of `s` which equals `t`. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. The test cases are generated so that the answer fits on a 32-bit signed integer.",
        "example": "Example:\n\nInput: s = \"rabbbit\", t = \"rabbit\"\nOutput: 3\nExplanation: There are 3 ways you can generate \"rabbit\" from s:\n1. \"rabb\" + \"it\"\n2. \"ra\" + \"bbit\"\n3. \"rab\" + \"bit\"",
        "level": "Medium",
        "tags": [
            "dynamic programming",
            "string"
        ],
        "test_cases": {
            "inputs": [
                [
                    "\"rabbbit\"",
                    "\"rabbit\""
                ],
                [
                    "\"babgbag\"",
                    "\"bag\""
                ],
                [
                    "\"abcde\"",
                    "\"ace\""
                ],
                [
                    "\"abcde\"",
                    "\"abcde\""
                ],
                [
                    "\"fgh\"",
                    "\"abcde\""
                ],
                [
                    "\"abcde\"",
                    "\"abcde\""
                ],
                [
                    "\"abcde\"",
                    "\"abcde\""
                ],
                [
                    "\"abcde\"",
                    "\"abcde\""
                ],
                [
                    "\"abcde\"",
                    "\"abcde\""
                ],
                [
                    "\"abcde\"",
                    "\"abcde\""
                ]
            ],
            "outputs": [
                3,
                5,
                0,
                1,
                0,
                1,
                1,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "int numDistinct(string s, string t) {\n    int m = s.size(), n = t.size();\n    vector<vector<unsigned int>> dp(m + 1, vector<unsigned int>(n + 1, 0));\n\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s[i - 1] == t[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n",
            "java": "public int numDistinct(String s, String t) {\n    int m = s.length(), n = t.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n",
            "python": "def numDistinct(s: str, t: str) -> int:\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[m][n]\n",
            "javascript": "function numDistinct(s, t) {\n    const m = s.length, n = t.length;\n    const dp = Array.from({length: m + 1}, () => Array(n + 1).fill(0));\n\n    for (let i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (s[i - 1] === t[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n",
            "explanation": "The algorithm uses dynamic programming to count the number of distinct subsequences. The main idea is to create a 2D table `dp` where `dp[i][j]` represents the number of distinct subsequences of the first `i` characters in string `s` that equal the first `j` characters in string `t`. \n\nThe algorithm initializes the first row of the table since there are no subsequences of an empty string. Then, it iterates through each character in both strings, comparing for equality. If the characters are equal, the value of `dp[i][j]` is updated to `dp[i - 1][j - 1] + dp[i - 1][j]`. If the characters are not equal, the value of `dp[i][j]` is updated to `dp[i - 1][j]`. After filling the 2D table, the value at `dp[m][n]` represents the total number of distinct subsequences of `s` that equal `t`."
        },
        "structure": {
            "c++": "int numDistinct(string s, string t)  {\n    // Your code here\n}\n",
            "java": "public int numDistinct(String s, String t)  {\n    // Your code here\n}\n",
            "python": "def numDistinct(s: str, t: str) -> int:\n    # Your code here\n\n",
            "javascript": "function numDistinct(s, t)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int numDistinct(string s, string t) {\n    int m = s.size(), n = t.size();\n    vector<vector<unsigned int>> dp(m + 1, vector<unsigned int>(n + 1, 0));\n\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s[i - 1] == t[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}",
            "java": "public int numDistinct(String s, String t) {\n    int m = s.length(), n = t.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    s = inputs[0]\n    t = inputs[1]\n    result = numDistinct(s, t)\n    print(result)",
            "javascript": "function main() {\n    input=$args\n    const s = input[0];\n    const t = input[1];\n    const result = numDistinct(s, t);\n    console.log(result);\n}\nmain();"
        },
        "Qid": "115",
        "languages verified": [
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d6eae949b33b6c4e2b0a5"
        },
        "title": "Minimum Path Sum in Triangle",
        "description": "Given a `triangle` array, find the minimum path sum from top to bottom. For each step, you may move to an adjacent number of the row below. More formally, if you are on index `i` on the current row, you may move to either index `i` or index `i + 1` on the next row.",
        "example": "Example 1:\n\nInput: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\nOutput: 11\nExplanation: The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11.\n\nExample 2:\n\nInput: triangle = [[-10]]\nOutput: -10\nExplanation: The triangle has only one element, so the minimum path sum is -10.",
        "level": "Medium",
        "tags": [
            "dynamic programming",
            "triangle",
            "minimum path sum"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        6,
                        5,
                        7
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ]
                ],
                [
                    [
                        -10
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ]
                ],
                [
                    [
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14
                    ],
                    [
                        15,
                        16,
                        17,
                        18,
                        19
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14
                    ],
                    [
                        15,
                        16,
                        17,
                        18,
                        19
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ],
                    [
                        -40,
                        -41,
                        -42,
                        -43,
                        -44,
                        -45,
                        -46,
                        -47,
                        -48,
                        -49
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ],
                    [
                        -40,
                        -41,
                        -42,
                        -43,
                        -44,
                        -45,
                        -46,
                        -47,
                        -48,
                        -49
                    ],
                    [
                        -50,
                        -51,
                        -52,
                        -53,
                        -54,
                        -55,
                        -56,
                        -57,
                        -58,
                        -59,
                        -60
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ],
                    [
                        -40,
                        -41,
                        -42,
                        -43,
                        -44,
                        -45,
                        -46,
                        -47,
                        -48,
                        -49
                    ],
                    [
                        -50,
                        -51,
                        -52,
                        -53,
                        -54,
                        -55,
                        -56,
                        -57,
                        -58,
                        -59,
                        -60
                    ],
                    [
                        -61,
                        -62,
                        -63,
                        -64,
                        -65,
                        -66,
                        -67,
                        -68,
                        -69,
                        -70,
                        -71,
                        -72
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ],
                    [
                        -40,
                        -41,
                        -42,
                        -43,
                        -44,
                        -45,
                        -46,
                        -47,
                        -48,
                        -49
                    ],
                    [
                        -50,
                        -51,
                        -52,
                        -53,
                        -54,
                        -55,
                        -56,
                        -57,
                        -58,
                        -59,
                        -60
                    ],
                    [
                        -61,
                        -62,
                        -63,
                        -64,
                        -65,
                        -66,
                        -67,
                        -68,
                        -69,
                        -70,
                        -71,
                        -72
                    ],
                    [
                        -73,
                        -74,
                        -75,
                        -76,
                        -77,
                        -78,
                        -79,
                        -80,
                        -81,
                        -82,
                        -83,
                        -84,
                        -85
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ],
                    [
                        -40,
                        -41,
                        -42,
                        -43,
                        -44,
                        -45,
                        -46,
                        -47,
                        -48,
                        -49
                    ],
                    [
                        -50,
                        -51,
                        -52,
                        -53,
                        -54,
                        -55,
                        -56,
                        -57,
                        -58,
                        -59,
                        -60
                    ],
                    [
                        -61,
                        -62,
                        -63,
                        -64,
                        -65,
                        -66,
                        -67,
                        -68,
                        -69,
                        -70,
                        -71,
                        -72
                    ],
                    [
                        -73,
                        -74,
                        -75,
                        -76,
                        -77,
                        -78,
                        -79,
                        -80,
                        -81,
                        -82,
                        -83,
                        -84,
                        -85
                    ],
                    [
                        -86,
                        -87,
                        -88,
                        -89,
                        -90,
                        -91,
                        -92,
                        -93,
                        -94,
                        -95,
                        -96,
                        -97,
                        -98,
                        -99
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ],
                    [
                        -40,
                        -41,
                        -42,
                        -43,
                        -44,
                        -45,
                        -46,
                        -47,
                        -48,
                        -49
                    ],
                    [
                        -50,
                        -51,
                        -52,
                        -53,
                        -54,
                        -55,
                        -56,
                        -57,
                        -58,
                        -59,
                        -60
                    ],
                    [
                        -61,
                        -62,
                        -63,
                        -64,
                        -65,
                        -66,
                        -67,
                        -68,
                        -69,
                        -70,
                        -71,
                        -72
                    ],
                    [
                        -73,
                        -74,
                        -75,
                        -76,
                        -77,
                        -78,
                        -79,
                        -80,
                        -81,
                        -82,
                        -83,
                        -84,
                        -85
                    ],
                    [
                        -86,
                        -87,
                        -88,
                        -89,
                        -90,
                        -91,
                        -92,
                        -93,
                        -94,
                        -95,
                        -96,
                        -97,
                        -98,
                        -99
                    ],
                    [
                        -100,
                        -101,
                        -102,
                        -103,
                        -104,
                        -105,
                        -106,
                        -107,
                        -108,
                        -109,
                        -110,
                        -111,
                        -112,
                        -113,
                        -114
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ],
                    [
                        -40,
                        -41,
                        -42,
                        -43,
                        -44,
                        -45,
                        -46,
                        -47,
                        -48,
                        -49
                    ],
                    [
                        -50,
                        -51,
                        -52,
                        -53,
                        -54,
                        -55,
                        -56,
                        -57,
                        -58,
                        -59,
                        -60
                    ],
                    [
                        -61,
                        -62,
                        -63,
                        -64,
                        -65,
                        -66,
                        -67,
                        -68,
                        -69,
                        -70,
                        -71,
                        -72
                    ],
                    [
                        -73,
                        -74,
                        -75,
                        -76,
                        -77,
                        -78,
                        -79,
                        -80,
                        -81,
                        -82,
                        -83,
                        -84,
                        -85
                    ],
                    [
                        -86,
                        -87,
                        -88,
                        -89,
                        -90,
                        -91,
                        -92,
                        -93,
                        -94,
                        -95,
                        -96,
                        -97,
                        -98,
                        -99
                    ],
                    [
                        -100,
                        -101,
                        -102,
                        -103,
                        -104,
                        -105,
                        -106,
                        -107,
                        -108,
                        -109,
                        -110,
                        -111,
                        -112,
                        -113,
                        -114
                    ],
                    [
                        -115,
                        -116,
                        -117,
                        -118,
                        -119,
                        -120,
                        -121,
                        -122,
                        -123,
                        -124,
                        -125,
                        -126,
                        -127,
                        -128,
                        -129,
                        -130
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ],
                    [
                        -40,
                        -41,
                        -42,
                        -43,
                        -44,
                        -45,
                        -46,
                        -47,
                        -48,
                        -49
                    ],
                    [
                        -50,
                        -51,
                        -52,
                        -53,
                        -54,
                        -55,
                        -56,
                        -57,
                        -58,
                        -59,
                        -60
                    ],
                    [
                        -61,
                        -62,
                        -63,
                        -64,
                        -65,
                        -66,
                        -67,
                        -68,
                        -69,
                        -70,
                        -71,
                        -72
                    ],
                    [
                        -73,
                        -74,
                        -75,
                        -76,
                        -77,
                        -78,
                        -79,
                        -80,
                        -81,
                        -82,
                        -83,
                        -84,
                        -85
                    ],
                    [
                        -86,
                        -87,
                        -88,
                        -89,
                        -90,
                        -91,
                        -92,
                        -93,
                        -94,
                        -95,
                        -96,
                        -97,
                        -98,
                        -99
                    ],
                    [
                        -100,
                        -101,
                        -102,
                        -103,
                        -104,
                        -105,
                        -106,
                        -107,
                        -108,
                        -109,
                        -110,
                        -111,
                        -112,
                        -113,
                        -114
                    ],
                    [
                        -115,
                        -116,
                        -117,
                        -118,
                        -119,
                        -120,
                        -121,
                        -122,
                        -123,
                        -124,
                        -125,
                        -126,
                        -127,
                        -128,
                        -129,
                        -130
                    ],
                    [
                        -131,
                        -132,
                        -133,
                        -134,
                        -135,
                        -136,
                        -137,
                        -138,
                        -139,
                        -140,
                        -141,
                        -142,
                        -143,
                        -144,
                        -145,
                        -146,
                        -147
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ],
                    [
                        -40,
                        -41,
                        -42,
                        -43,
                        -44,
                        -45,
                        -46,
                        -47,
                        -48,
                        -49
                    ],
                    [
                        -50,
                        -51,
                        -52,
                        -53,
                        -54,
                        -55,
                        -56,
                        -57,
                        -58,
                        -59,
                        -60
                    ],
                    [
                        -61,
                        -62,
                        -63,
                        -64,
                        -65,
                        -66,
                        -67,
                        -68,
                        -69,
                        -70,
                        -71,
                        -72
                    ],
                    [
                        -73,
                        -74,
                        -75,
                        -76,
                        -77,
                        -78,
                        -79,
                        -80,
                        -81,
                        -82,
                        -83,
                        -84,
                        -85
                    ],
                    [
                        -86,
                        -87,
                        -88,
                        -89,
                        -90,
                        -91,
                        -92,
                        -93,
                        -94,
                        -95,
                        -96,
                        -97,
                        -98,
                        -99
                    ],
                    [
                        -100,
                        -101,
                        -102,
                        -103,
                        -104,
                        -105,
                        -106,
                        -107,
                        -108,
                        -109,
                        -110,
                        -111,
                        -112,
                        -113,
                        -114
                    ],
                    [
                        -115,
                        -116,
                        -117,
                        -118,
                        -119,
                        -120,
                        -121,
                        -122,
                        -123,
                        -124,
                        -125,
                        -126,
                        -127,
                        -128,
                        -129,
                        -130
                    ],
                    [
                        -131,
                        -132,
                        -133,
                        -134,
                        -135,
                        -136,
                        -137,
                        -138,
                        -139,
                        -140,
                        -141,
                        -142,
                        -143,
                        -144,
                        -145,
                        -146,
                        -147
                    ],
                    [
                        -148,
                        -149,
                        -150,
                        -151,
                        -152,
                        -153,
                        -154,
                        -155,
                        -156,
                        -157,
                        -158,
                        -159,
                        -160,
                        -161,
                        -162,
                        -163,
                        -164,
                        -165
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ],
                    [
                        -40,
                        -41,
                        -42,
                        -43,
                        -44,
                        -45,
                        -46,
                        -47,
                        -48,
                        -49
                    ],
                    [
                        -50,
                        -51,
                        -52,
                        -53,
                        -54,
                        -55,
                        -56,
                        -57,
                        -58,
                        -59,
                        -60
                    ],
                    [
                        -61,
                        -62,
                        -63,
                        -64,
                        -65,
                        -66,
                        -67,
                        -68,
                        -69,
                        -70,
                        -71,
                        -72
                    ],
                    [
                        -73,
                        -74,
                        -75,
                        -76,
                        -77,
                        -78,
                        -79,
                        -80,
                        -81,
                        -82,
                        -83,
                        -84,
                        -85
                    ],
                    [
                        -86,
                        -87,
                        -88,
                        -89,
                        -90,
                        -91,
                        -92,
                        -93,
                        -94,
                        -95,
                        -96,
                        -97,
                        -98,
                        -99
                    ],
                    [
                        -100,
                        -101,
                        -102,
                        -103,
                        -104,
                        -105,
                        -106,
                        -107,
                        -108,
                        -109,
                        -110,
                        -111,
                        -112,
                        -113,
                        -114
                    ],
                    [
                        -115,
                        -116,
                        -117,
                        -118,
                        -119,
                        -120,
                        -121,
                        -122,
                        -123,
                        -124,
                        -125,
                        -126,
                        -127,
                        -128,
                        -129,
                        -130
                    ],
                    [
                        -131,
                        -132,
                        -133,
                        -134,
                        -135,
                        -136,
                        -137,
                        -138,
                        -139,
                        -140,
                        -141,
                        -142,
                        -143,
                        -144,
                        -145,
                        -146,
                        -147
                    ],
                    [
                        -148,
                        -149,
                        -150,
                        -151,
                        -152,
                        -153,
                        -154,
                        -155,
                        -156,
                        -157,
                        -158,
                        -159,
                        -160,
                        -161,
                        -162,
                        -163,
                        -164,
                        -165
                    ],
                    [
                        -166,
                        -167,
                        -168,
                        -169,
                        -170,
                        -171,
                        -172,
                        -173,
                        -174,
                        -175,
                        -176,
                        -177,
                        -178,
                        -179,
                        -180,
                        -181,
                        -182,
                        -183
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        -2,
                        3
                    ],
                    [
                        1,
                        -1,
                        -3
                    ],
                    [
                        4,
                        1,
                        8,
                        3
                    ],
                    [
                        -5,
                        -6,
                        -7,
                        -8,
                        -9
                    ],
                    [
                        -10,
                        -11,
                        -12,
                        -13,
                        -14,
                        -15
                    ],
                    [
                        -16,
                        -17,
                        -18,
                        -19,
                        -20,
                        -21,
                        -22
                    ],
                    [
                        -23,
                        -24,
                        -25,
                        -26,
                        -27,
                        -28,
                        -29,
                        -30
                    ],
                    [
                        -31,
                        -32,
                        -33,
                        -34,
                        -35,
                        -36,
                        -37,
                        -38,
                        -39
                    ],
                    [
                        -40,
                        -41,
                        -42,
                        -43,
                        -44,
                        -45,
                        -46,
                        -47,
                        -48,
                        -49
                    ],
                    [
                        -50,
                        -51,
                        -52,
                        -53,
                        -54,
                        -55,
                        -56,
                        -57,
                        -58,
                        -59,
                        -60
                    ],
                    [
                        -61,
                        -62,
                        -63,
                        -64,
                        -65,
                        -66,
                        -67,
                        -68,
                        -69,
                        -70,
                        -71,
                        -72
                    ],
                    [
                        -73,
                        -74,
                        -75,
                        -76,
                        -77,
                        -78,
                        -79,
                        -80,
                        -81,
                        -82,
                        -83,
                        -84,
                        -85
                    ],
                    [
                        -86,
                        -87,
                        -88,
                        -89,
                        -90,
                        -91,
                        -92,
                        -93,
                        -94,
                        -95,
                        -96,
                        -97,
                        -98,
                        -99
                    ],
                    [
                        -100,
                        -101,
                        -102,
                        -103,
                        -104,
                        -105,
                        -106,
                        -107,
                        -108,
                        -109,
                        -110,
                        -111,
                        -112,
                        -113,
                        -114
                    ],
                    [
                        -115,
                        -116,
                        -117,
                        -118,
                        -119,
                        -120,
                        -121,
                        -122,
                        -123,
                        -124,
                        -125,
                        -126,
                        -127,
                        -128,
                        -129,
                        -130
                    ],
                    [
                        -131,
                        -132,
                        -133,
                        -134,
                        -135,
                        -136,
                        -137,
                        -138,
                        -139,
                        -140,
                        -141,
                        -142,
                        -143,
                        -144,
                        -145,
                        -146,
                        -147
                    ],
                    [
                        -148,
                        -149,
                        -150,
                        -151,
                        -152,
                        -153,
                        -154,
                        -155,
                        -156,
                        -157,
                        -158,
                        -159,
                        -160,
                        -161,
                        -162,
                        -163,
                        -164,
                        -165
                    ],
                    [
                        -166,
                        -167,
                        -168,
                        -169,
                        -170,
                        -171,
                        -172,
                        -173,
                        -174,
                        -175,
                        -176,
                        -177,
                        -178,
                        -179,
                        -180,
                        -181,
                        -182,
                        -183
                    ],
                    [
                        -184,
                        -185,
                        -186,
                        -187,
                        -188,
                        -189,
                        -190,
                        -191,
                        -192,
                        -193,
                        -194,
                        -195,
                        -196,
                        -197,
                        -198,
                        -199,
                        -200,
                        -201
                    ]
                ]
            ],
            "outputs": [
                "11",
                "-10",
                "15",
                "-1",
                "55",
                "56",
                "-15",
                "-25",
                "-35",
                "-45",
                "-55",
                "-66",
                "-78",
                "-91",
                "-105",
                "-120",
                "-136",
                "-153",
                "-171",
                "-190"
            ]
        },
        "sample_code": {
            "c++": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\nint minimumTotal(vector<vector<int>>& triangle) {\n    for (int row = triangle.size() - 2; row >= 0; row--) {\n        for (int col = 0; col < triangle[row].size(); col++) {\n            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1]);\n        }\n    }\n    return triangle[0][0];\n}\n",
            "java": "public static int minimumTotal(List<List<Integer>> triangle) {\n    for (int row = triangle.size() - 2; row >= 0; row--) {\n        for (int col = 0; col < triangle.get(row).size(); col++) {\n            int minSum = Math.min(triangle.get(row + 1).get(col), triangle.get(row + 1).get(col + 1));\n            triangle.get(row).set(col, triangle.get(row).get(col) + minSum);\n        }\n    }\n    return triangle.get(0).get(0);\n}\n",
            "python": "def minimumTotal(triangle):\n    for row in range(len(triangle) - 2, -1, -1):\n        for col in range(len(triangle[row])):\n            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])\n    return triangle[0][0]\n",
            "javascript": "function minimumTotal(triangle) {\n    for (let row = triangle.length - 2; row >= 0; row--) {\n        for (let col = 0; col < triangle[row].length; col++) {\n            triangle[row][col] += Math.min(triangle[row + 1][col], triangle[row + 1][col + 1]);\n        }\n    }\n    return triangle[0][0];\n}\n",
            "explanation": "The algorithm starts from the second last row of the triangle, moving bottom-up. For each number in the current row, we add the minimum adjacent number in the row below it. This is done for all numbers in the current row. Then, we move to the row above and repeat the process. This way, we are calculating the minimum path sum for each number in the triangle until we reach the top. Finally, the minimum path sum from top to bottom can be found in the top-most number (triangle[0][0]) after these operations are complete."
        },
        "structure": {
            "c++": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\nint minimumTotal(vector<vector<int>>& triangle)  {\n    // Your code here\n}\n",
            "java": "public static int minimumTotal(List<List<Integer>> triangle)  {\n    // Your code here\n}\n",
            "python": "def minimumTotal(triangle):\n    # Your code here\n\n",
            "javascript": "function minimumTotal(triangle)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<vector<int>> triangle =$args;\n    int result = minimumTotal(triangle);\n    std::cout <<\"$sprouts@pankaj\"<<result<<\"$sprouts@pankaj\";\n    return 0;\n}",
            "java": "public static void main() {\nList<List<Integer>> triangle = {{1}, {2, 3}, {4, 5, 6}, {7, 8, 9, 10}};\nint result = minimumTotal(triangle);\nSystem.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    triangle = $args\n    result = minimumTotal(triangle)\n    print(\"$sprouts@pankaj\",result,\"$sprouts@pankaj\")",
            "javascript": "function main() {\n    const triangle = $args;\n    const result = minimumTotal(triangle);\n    console.log(\"$sprouts@pankaj\",result,\"$sprouts@pankaj\"\n);\n}\nmain();"
        },
        "Qid": "120",
        "languages verified": [
            "c++",
            "python",
            "javascript"
        ]
    },
    {
        "_id": {
            "$oid": "661d6f26949b33b6c4e2b0a6"
        },
        "title": "Maximize Stock Profit",
        "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day. You want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
        "example": "Example:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.",
        "level": "Easy",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    7,
                    1,
                    5,
                    3,
                    6,
                    4
                ],
                [
                    7,
                    6,
                    4,
                    3,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ]
            ],
            "outputs": [
                5,
                0,
                4,
                0,
                0,
                9,
                0,
                4,
                4,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16
            ]
        },
        "sample_code": {
            "c++": "int maxProfit(vector<int>& prices) {\n    int minPrice = INT_MAX;\n    int maxProfit = 0;\n    for (int price : prices) {\n        minPrice = min(minPrice, price);\n        maxProfit = max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}\n",
            "java": "public int maxProfit(int[] prices) {\n    int minPrice = Integer.MAX_VALUE;\n    int maxProfit = 0;\n    for (int price : prices) {\n        minPrice = Math.min(minPrice, price);\n        maxProfit = Math.max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}\n",
            "python": "def maxProfit(prices):\n    minPrice = float('inf')\n    maxProfit = 0\n    for price in prices:\n        minPrice = min(minPrice, price)\n        maxProfit = max(maxProfit, price - minPrice)\n    return maxProfit\n",
            "javascript": "function maxProfit(prices) {\n    let minPrice = Number.MAX_VALUE;\n    let maxProfit = 0;\n    for (const price of prices) {\n        minPrice = Math.min(minPrice, price);\n        maxProfit = Math.max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}\n",
            "explanation": "The algorithm iterates through the input array of prices. We maintain two variables: `minPrice` to track the minimum price encountered up to the current day, and `maxProfit` to track maximum achievable profit. \n\nFor each day, we update:\n1. `minPrice` by comparing its value with the current day's stock price.\n2. `maxProfit` by comparing its value with the difference between the current day's stock price and the minimum stock price encountered so far.\n\nAt the end of the iteration, the algorithm returns the value stored in `maxProfit`, which is the maximum possible profit that can be achieved."
        },
        "structure": {
            "c++": "int maxProfit(vector<int>& prices)  {\n    // Your code here\n}\n",
            "java": "public int maxProfit(int[] prices)  {\n    // Your code here\n}\n",
            "python": "def maxProfit(prices):\n    # Your code here\n\n",
            "javascript": "function maxProfit(prices)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> prices = $args;\n    int result = maxProfit(prices);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    prices = $args\n    result = maxProfit(prices)\n    print(result)",
            "java": "",
            "javascript": ""
        },
        "Qid": "121"
    },
    {
        "_id": {
            "$oid": "661d6f8f949b33b6c4e2b0a7"
        },
        "title": "Maximum Profit from Stock Prices",
        "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day. Find the maximum profit you can achieve by buying and selling stocks. You may complete at most two transactions, but you cannot engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
        "example": "Example:\n\nInput: prices = [3,3,5,0,0,3,1,4]\nOutput: 6\nExplanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    3,
                    5,
                    0,
                    0,
                    3,
                    1,
                    4
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    7,
                    6,
                    4,
                    3,
                    1
                ],
                [
                    1,
                    2,
                    4,
                    2,
                    5,
                    7,
                    2,
                    4
                ],
                [
                    2,
                    4,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ]
            ],
            "outputs": [
                6,
                4,
                0,
                9,
                3,
                9,
                0,
                0,
                18,
                18
            ]
        },
        "sample_code": {
            "c++": "int maxProfit(vector<int>& prices) {\n    int buy1 = INT_MAX, buy2 = INT_MAX;\n    int profit1 = 0, profit2 = 0;\n    \n    for (int price : prices) {\n        buy1 = min(buy1, price);\n        profit1 = max(profit1, price - buy1);\n        buy2 = min(buy2, price - profit1);\n        profit2 = max(profit2, price - buy2);\n    }\n    \n    return profit2;\n}\n",
            "java": "public int maxProfit(int[] prices) {\n    int buy1 = Integer.MAX_VALUE, buy2 = Integer.MAX_VALUE;\n    int profit1 = 0, profit2 = 0;\n    \n    for (int price : prices) {\n        buy1 = Math.min(buy1, price);\n        profit1 = Math.max(profit1, price - buy1);\n        buy2 = Math.min(buy2, price - profit1);\n        profit2 = Math.max(profit2, price - buy2);\n    }\n    \n    return profit2;\n}\n",
            "python": "def maxProfit(prices):\n    buy1, buy2 = float(\"inf\"), float(\"inf\")\n    profit1, profit2 = 0, 0\n\n    for price in prices:\n        buy1 = min(buy1, price)\n        profit1 = max(profit1, price - buy1)\n        buy2 = min(buy2, price - profit1)\n        profit2 = max(profit2, price - buy2)\n\n    return profit2\n",
            "javascript": "function maxProfit(prices) {\n    let buy1 = Infinity, buy2 = Infinity;\n    let profit1 = 0, profit2 = 0;\n\n    for (let price of prices) {\n        buy1 = Math.min(buy1, price);\n        profit1 = Math.max(profit1, price - buy1);\n        buy2 = Math.min(buy2, price - profit1);\n        profit2 = Math.max(profit2, price - buy2);\n    }\n\n    return profit2;\n}\n",
            "explanation": "1. Initialize variables buy1 and buy2 to track the minimum prices, and profit1 and profit2 to track the maximum profits.\n2. Iterate through prices array.\n3. Update buy1 to the minimum of buy1 and the current price.\n4. Update profit1 to the maximum of profit1 and the current price - buy1.\n5. Update buy2 to the minimum of buy2 and the current price - profit1.\n6. Update profit2 to the maximum of profit2 and the current price - buy2.\n7. Return profit2. This is the profit from two transactions."
        },
        "structure": {
            "c++": "int maxProfit(vector<int>& prices)  {\n    // Your code here\n}\n",
            "java": "public int maxProfit(int[] prices)  {\n    // Your code here\n}\n",
            "python": "def maxProfit(prices):\n    # Your code here\n\n",
            "javascript": "function maxProfit(prices)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> prices = $args;\n    int result = maxProfit(prices);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int maxProfit(int[] prices) {\n    int buy1 = Integer.MAX_VALUE, buy2 = Integer.MAX_VALUE;\n    int profit1 = 0, profit2 = 0;\n    \n    for (int price : prices) {\n        buy1 = Math.min(buy1, price);\n        profit1 = Math.max(profit1, price - buy1);\n        buy2 = Math.min(buy2, price - profit1);\n        profit2 = Math.max(profit2, price - buy2);\n    }\n    \n    return profit2;\n}",
            "python": "if __name__ == \"__main__\":\n    prices = $args\n    result = maxProfit(prices)\n    print(result)",
            "javascript": ""
        },
        "Qid": "123"
    },
    {
        "_id": {
            "$oid": "661d6fbe949b33b6c4e2b0a8"
        },
        "title": "Palindrome Check",
        "description": "Given a string `s`, determine if it is a palindrome after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters. Return `true` if it is a palindrome, and `false` otherwise.",
        "example": "Example 1:\n\nInput: s = \"A man, a plan, a canal: Panama\"\nOutput: true\nExplanation: \"amanaplanacanalpanama\" is a palindrome.\n\nExample 2:\n\nInput: s = \"race a car\"\nOutput: false\nExplanation: \"raceacar\" is not a palindrome.",
        "level": "Easy",
        "tags": [
            "string",
            "palindrome"
        ],
        "test_cases": {
            "inputs": [
                "\"A man, a plan, a canal: Panama\"",
                "\"race a car\"",
                "\"\"",
                "\"No lemon, no melon\"",
                "\"Was it a car or a cat I saw?\"",
                "\"Step on no pets\"",
                "\"Eva, can I see bees in a cave?\"",
                "\"Mr. Owl ate my metal worm\"",
                "\"Madam, in Eden, I'm Adam\"",
                "\"Never odd or even\"",
                "\"Able was I ere I saw Elba\"",
                "\"A Toyota's a Toyota\"",
                "\"A nut for a jar of tuna\"",
                "\"Are we not pure? \"No sir!\" Panama's moody Noriega brags. \"It is garbage!\" Irony dooms a man; a prisoner up to new era.\"\"",
                "\"Go hang a salami I'm a lasagna hog\"",
                "\"Red roses run no risk, sir, on Nurse's order\"",
                "\"Ma is a nun, as I am\"",
                "\"Evil is a name of a foeman, as I live\"",
                "\"A man, a plan, a cat, a ham, a yak, a yam, a hat, a canal-Panama!\"",
                "\"Able, was I saw Elba\"",
                "\"A man, a plan, a canal, Panama\"",
                "\"A man, a plan, a canal, Panama!\"",
                "\"A man, a plan, a canal, Panama.\""
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "#include <cctype>\n#include <algorithm>\n#include <iostream>\n\nbool isPalindrome(std::string s) {\n    s.erase(std::remove_if(s.begin(), s.end(), [](char c) { return !std::isalnum(c); }), s.end());\n    std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n    int left = 0, right = s.size() - 1;\n    while (left < right) {\n        if (s[left++] != s[right--]) return false;\n    }\n    return true;\n}\n",
            "java": "public static boolean isPalindrome(String s) {\n        StringBuilder cleaned = new StringBuilder();\n        // Remove non-alphanumeric characters and convert to lowercase\n        for (char c : s.toCharArray()) {\n            if (Character.isLetterOrDigit(c)) {\n                cleaned.append(Character.toLowerCase(c));\n            }\n        }\n        \n        int left = 0;\n        int right = cleaned.length() - 1;\n        \n        // Check for palindrome\n        while (left < right) {\n            if (cleaned.charAt(left++) != cleaned.charAt(right--)) {\n                return false;\n            }\n        }\n        return true;\n    }",
            "python": "def isPalindrome(s: str) -> bool:\n    cleaned = \"\".join(c.lower() for c in s if c.isalnum())\n    left, right = 0, len(cleaned) - 1\n    while left < right:\n        if cleaned[left] != cleaned[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n",
            "javascript": "function isPalindrome(s) {\n    const cleaned = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n    let left = 0, right = cleaned.length - 1;\n    while (left < right) {\n        if (cleaned[left++] !== cleaned[right--]) return false;\n    }\n    return true;\n}\n",
            "explanation": "1. Clean the given string by removing non-alphanumeric characters and converting uppercase letters to lowercase.\n2. Initialize two pointers: `left` pointing to the beginning of the cleaned string and `right` pointing to the end.\n3. Iterate through the cleaning string, comparing the characters at the `left` and `right` pointers. If they are not equal, return `false` as it's not a palindrome.\n4. If the loop completes, it means the input string is a palindrome, so return `true`."
        },
        "structure": {
            "c++": "#include <cctype>\n#include <algorithm>\n#include <iostream>\nbool isPalindrome(std::string s) {\n    // Your code here\n}\n",
            "java": "public boolean isPalindrome(String s) {\n    // Your code here\n}\n",
            "python": "def isPalindrome(s: str) -> bool:\n    # Your code here\n\n",
            "javascript": "function isPalindrome(s) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <cctype>\n#include <algorithm>\n#include <iostream>\n\nint main() {\n    std::string s = $args;\n    bool result = isPalindrome(s);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n        String s = $args;\n        boolean result = isPalindrome(s);\n        System.out.println(result); // Expected output: true\n    }",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = isPalindrome(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = isPalindrome(s);\n    console.log(result);\n}\nmain();"
        },
        "Qid": "125",
        "languages verified": [
            "javascript",
            "python",
            "c++",
            "java"
        ]
    },
    {
        "_id": {
            "$oid": "661d705b949b33b6c4e2b0a9"
        },
        "title": "Shortest Transformation Sequences",
        "description": "Given a transformation sequence from a start word to an end word using a dictionary of words, find all the shortest transformation sequences. A transformation sequence is a sequence of words where each adjacent pair of words differs by a single letter, and each word is in the given dictionary. Return the sequences as a list of words.",
        "example": "Example:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nOutput: [[\"hit\", \"hot\", \"dot\", \"dog\", \"cog\"], [\"hit\", \"hot\", \"lot\", \"log\", \"cog\"]]\nExplanation: There are 2 shortest transformation sequences: \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\" and \"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\".",
        "level": "Medium",
        "tags": [
            "graph",
            "breadth-first search",
            "backtracking"
        ],
        "test_cases": {
            "inputs": [
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log"
                    ]
                ],
                [
                    "a",
                    "c",
                    [
                        "a",
                        "b",
                        "c"
                    ]
                ],
                [
                    "red",
                    "tax",
                    [
                        "ted",
                        "tex",
                        "red",
                        "tax",
                        "tad",
                        "den",
                        "rex",
                        "pee"
                    ]
                ],
                [
                    "hot",
                    "dog",
                    [
                        "hot",
                        "dog"
                    ]
                ]
            ],
            "outputs": [
                [
                    [
                        "hit",
                        "hot",
                        "dot",
                        "dog",
                        "cog"
                    ],
                    [
                        "hit",
                        "hot",
                        "lot",
                        "log",
                        "cog"
                    ]
                ],
                [],
                [
                    [
                        "a",
                        "c"
                    ]
                ],
                [
                    [
                        "red",
                        "ted",
                        "tad",
                        "tax"
                    ],
                    [
                        "red",
                        "rex",
                        "tex",
                        "tax"
                    ]
                ],
                []
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n\nstd::vector<std::vector<std::string>> findLadders(std::string beginWord, std::string endWord, std::vector<std::string>& wordList) {\n    std::unordered_set<std::string> dict(wordList.begin(), wordList.end());\n    if (dict.find(endWord) == dict.end()) {\n        return {};\n    }\n    std::unordered_map<std::string, std::vector<std::string>> adjacent;\n    std::unordered_map<std::string, int> distance;\n    \n    auto neighbors = [&](const std::string& word) {\n        std::vector<std::string> result;\n        std::string temp = word;\n        for (char& ch : temp) {\n            char original = ch;\n            for (int i = 'a'; i <= 'z'; ++i) {\n                ch = i;\n                if (dict.count(temp) && temp != word) {\n                    result.push_back(temp);\n                }\n            }\n            ch = original;\n        }\n        return result;\n    };\n    \n    std::queue<std::string> q;\n    q.push(beginWord);\n    distance[beginWord] = 0;\n    \n    while (!q.empty()) {\n        std::string current = q.front();\n        q.pop();\n        if (current == endWord) {\n            break;\n        }\n        for (const std::string& neighbor : neighbors(current)) {\n            if (!distance.count(neighbor)) {\n                distance[neighbor] = distance[current] + 1;\n                q.push(neighbor);\n            }\n            if (distance[neighbor] == distance[current] + 1) {\n                adjacent[current].push_back(neighbor);\n            }\n        }\n    }\n    \n    std::vector<std::vector<std::string>> result;\n    std::vector<std::string> path = {beginWord};\n    std::function<void(const std::string&)> backtrack = [&](const std::string& word) {\n        if (word == endWord) {\n            result.push_back(path);\n            return;\n        }\n        for (const std::string& next : adjacent[word]) {\n            path.push_back(next);\n            backtrack(next);\n            path.pop_back();\n        }\n    };\n    \n    backtrack(beginWord);\n    return result;\n}\n\n",
            "java": "import java.util.*;\n\npublic List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n    Set<String> dict = new HashSet<>(wordList);\n    if (!dict.contains(endWord)) {\n        return Collections.emptyList();\n    }\n\n    Map<String, List<String>> adjacent = new HashMap<>();\n    Map<String, Integer> distance = new HashMap<>();\n    Queue<String> queue = new LinkedList<>();\n    queue.offer(beginWord);\n    distance.put(beginWord, 0);\n\n    while (!queue.isEmpty()) {\n        String current = queue.poll();\n        if (current.equals(endWord)) {\n            break;\n        }\n        for (String neighbor : neighbors(current)) {\n            if (!dict.contains(neighbor)) {\n                continue;\n            }\n            if (!distance.containsKey(neighbor)) {\n                distance.put(neighbor, distance.get(current) + 1);\n                queue.offer(neighbor);\n            }\n            if (distance.get(neighbor).equals(distance.get(current) + 1)) {\n                adjacent.computeIfAbsent(current, k -> new ArrayList<>()).add(neighbor);\n            }\n        }\n    }\n\n    List<List<String>> result = new ArrayList<>();\n    List<String> path = new ArrayList<>();\n    path.add(beginWord);\n    backtrack(beginWord, endWord, path, adjacent, result);\n    return result;\n}\n\nprivate void backtrack(String current, String endWord, List<String> path, Map<String, List<String>> adjacent, List<List<String>> result) {\n    if (current.equals(endWord)) {\n        result.add(new ArrayList<>(path));\n        return;\n    }\n    for (String next : adjacent.getOrDefault(current, Collections.emptyList())) {\n        path.add(next);\n        backtrack(next, endWord, path, adjacent, result);\n        path.remove(path.size() - 1);\n    }\n}\n\nprivate List<String> neighbors(String word) {\n    List<String> result = new ArrayList<>();\n    char[] chars = word.toCharArray();\n    for (int i = 0; i < chars.length; i++) {\n        char original = chars[i];\n        for (char j = 'a'; j <= 'z'; j++) {\n            if (j == original) {\n                continue;\n            }\n            chars[i] = j;\n            result.add(new String(chars));\n        }\n        chars[i] = original;\n    }\n    return result;\n}\n\n",
            "python": "from collections import defaultdict, deque\n\ndef findLadders(beginWord, endWord, wordList):\n    wordList = set(wordList)\n    if endWord not in wordList:\n        return []\n\n    adjacent = defaultdict(list)\n    distance = defaultdict(int)\n    queue = deque([beginWord])\n    distance[beginWord] = 0\n    \n    def neighbors(word):\n        for i in range(len(word)):\n            for j in range(ord('a'), ord('z') + 1):\n                yield word[:i] + chr(j) + word[i + 1:]\n                \n    while queue:\n        current = queue.popleft()\n        if current == endWord:\n            break\n        for neighbor in neighbors(current):\n            if neighbor not in wordList:\n                continue\n            if neighbor not in distance:\n                distance[neighbor] = distance[current] + 1\n                queue.append(neighbor)\n            if distance[neighbor] == distance[current] + 1:\n                adjacent[current].append(neighbor)\n\n    result = []\n    path = [beginWord]\n\n    def backtrack(word):\n        if word == endWord:\n            result.append(path[:])\n        else:\n            for next_word in adjacent[word]:\n                path.append(next_word)\n                backtrack(next_word)\n                path.pop()\n                \n    backtrack(beginWord)\n    return result\n\n",
            "javascript": "function findLadders(beginWord, endWord, wordList) {\n    const dict = new Set(wordList);\n    if (!dict.has(endWord)) {\n        return [];\n    }\n\n    const adjacent = new Map();\n    const distance = new Map();\n    const queue = [beginWord];\n    distance.set(beginWord, 0);\n    \n    function neighbors(word) {\n        const result = [];\n        for (let i = 0; i < word.length; i++) {\n            for (let j = 'a'.charCodeAt(0); j <= 'z'.charCodeAt(0); j++) {\n                const next = word.slice(0, i) + String.fromCharCode(j) + word.slice(i + 1);\n                if (next !== word) {\n                    result.push(next);\n                }\n            }\n        }\n        return result;\n    }\n    \n    while (queue.length > 0) {\n        const current = queue.shift();\n        if (current === endWord) {\n            break;\n        }\n        for (const neighbor of neighbors(current)) {\n            if (!dict.has(neighbor)) {\n                continue;\n            }\n            if (!distance.has(neighbor)) {\n                distance.set(neighbor, distance.get(current) + 1);\n                queue.push(neighbor);\n            }\n            if (distance.get(neighbor) === distance.get(current) + 1) {\n                if (!adjacent.has(current)) {\n                    adjacent.set(current, []);\n                }\n                adjacent.get(current).push(neighbor);\n            }\n        }\n    }\n\n    const result = [];\n    const path = [beginWord];\n\n    function backtrack(word) {\n        if (word === endWord) {\n            result.push([...path]);\n            return;\n        }\n        for (const next of (adjacent.get(word) || [])) {\n            path.push(next);\n            backtrack(next);\n            path.pop();\n        }\n    }\n    \n    backtrack(beginWord);\n    return result;\n}\n\n",
            "explanation": "1. Create a dictionary set, adjacent map, distance map, and a queue to store words.\n2. Initialize the queue with the beginWord and set its distance to 0.\n3. Define a neighbors function that returns all possible words by changing one character of the given word.\n4. Run a BFS from the beginWord, updating the distances and adjacent maps.\n5. The BFS stops when it reaches the endWord or finishes visiting all reachable words.\n6. Define a backtrack function to search through the explored adjacent map to construct the transformation paths.\n7. Call the backtrack function with the beginWord, and return the result list, which contains the shortest transformations."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n\nstd::vector<std::vector<std::string>> findLadders(std::string beginWord, std::string endWord, std::vector<std::string>& wordList)  {\n    // Your code here\n}\n\n",
            "java": "import java.util.*;\n\npublic List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList)  {\n    // Your code here\n}\n\n",
            "python": "from collections import defaultdict, deque\n    # Your code here\n\n",
            "javascript": "function findLadders(beginWord, endWord, wordList)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "std::vector<std::vector<std::string>> findLadders(std::string beginWord, std::string endWord, std::vector<std::string>& wordList) {\n    std::unordered_set<std::string> dict(wordList.begin(), wordList.end());\n    if (dict.find(endWord) == dict.end()) {\n        return {};\n    }\n    std::unordered_map<std::string, std::vector<std::string>> adjacent;\n    std::unordered_map<std::string, int> distance;\n    \n    auto neighbors = [&](const std::string& word) {\n        std::vector<std::string> result;\n        std::string temp = word;\n        for (char& ch : temp) {\n            char original = ch;\n            for (int i = 'a'; i <= 'z'; ++i) {\n                ch = i;\n                if (dict.count(temp) && temp != word) {\n                    result.push_back(temp);\n                }\n            }\n            ch = original;\n        }\n        return result;\n    };\n    \n    std::queue<std::string> q;\n    q.push(beginWord);\n    distance[beginWord] = 0;\n    \n    while (!q.empty()) {\n        std::string current = q.front();\n        q.pop();\n        if (current == endWord) {\n            break;\n        }\n        for (const std::string& neighbor : neighbors(current)) {\n            if (!distance.count(neighbor)) {\n                distance[neighbor] = distance[current] + 1;\n                q.push(neighbor);\n            }\n            if (distance[neighbor] == distance[current] + 1) {\n                adjacent[current].push_back(neighbor);\n            }\n        }\n    }\n    \n    std::vector<std::vector<std::string>> result;\n    std::vector<std::string> path = {beginWord};\n    std::function<void(const std::string&)> backtrack = [&](const std::string& word) {\n        if (word == endWord) {\n            result.push_back(path);\n            return;\n        }\n        for (const std::string& next : adjacent[word]) {\n            path.push_back(next);\n            backtrack(next);\n            path.pop_back();\n        }\n    };\n    \n    backtrack(beginWord);\n    return result;\n}",
            "java": "public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n    Set<String> dict = new HashSet<>(wordList);\n    if (!dict.contains(endWord)) {\n        return Collections.emptyList();\n    }\n\n    Map<String, List<String>> adjacent = new HashMap<>();\n    Map<String, Integer> distance = new HashMap<>();\n    Queue<String> queue = new LinkedList<>();\n    queue.offer(beginWord);\n    distance.put(beginWord, 0);\n\n    while (!queue.isEmpty()) {\n        String current = queue.poll();\n        if (current.equals(endWord)) {\n            break;\n        }\n        for (String neighbor : neighbors(current)) {\n            if (!dict.contains(neighbor)) {\n                continue;\n            }\n            if (!distance.containsKey(neighbor)) {\n                distance.put(neighbor, distance.get(current) + 1);\n                queue.offer(neighbor);\n            }\n            if (distance.get(neighbor).equals(distance.get(current) + 1)) {\n                adjacent.computeIfAbsent(current, k -> new ArrayList<>()).add(neighbor);\n            }\n        }\n    }\n\n    List<List<String>> result = new ArrayList<>();\n    List<String> path = new ArrayList<>();\n    path.add(beginWord);\n    backtrack(beginWord, endWord, path, adjacent, result);\n    return result;\n}\n\nprivate void backtrack(String current, String endWord, List<String> path, Map<String, List<String>> adjacent, List<List<String>> result) {\n    if (current.equals(endWord)) {\n        result.add(new ArrayList<>(path));\n        return;\n    }\n    for (String next : adjacent.getOrDefault(current, Collections.emptyList())) {\n        path.add(next);\n        backtrack(next, endWord, path, adjacent, result);\n        path.remove(path.size() - 1);\n    }\n}\n\nprivate List<String> neighbors(String word) {\n    List<String> result = new ArrayList<>();\n    char[] chars = word.toCharArray();\n    for (int i = 0; i < chars.length; i++) {\n        char original = chars[i];\n        for (char j = 'a'; j <= 'z'; j++) {\n            if (j == original) {\n                continue;\n            }\n            chars[i] = j;\n            result.add(new String(chars));\n        }\n        chars[i] = original;\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    beginWord = inputs[0]\n    endWord = inputs[1]\n    wordList = inputs[2]\n    result = findLadders(beginWord, endWord, wordList)\n    print(result)",
            "javascript": "function findLadders(beginWord, endWord, wordList) {\n    const dict = new Set(wordList);\n    if (!dict.has(endWord)) {\n        return [];\n    }\n\n    const adjacent = new Map();\n    const distance = new Map();\n    const queue = [beginWord];\n    distance.set(beginWord, 0);\n    \n    function neighbors(word) {\n        const result = [];\n        for (let i = 0; i < word.length; i++) {\n            for (let j = 'a'.charCodeAt(0); j <= 'z'.charCodeAt(0); j++) {\n                const next = word.slice(0, i) + String.fromCharCode(j) + word.slice(i + 1);\n                if (next !== word) {\n                    result.push(next);\n                }\n            }\n        }\n        return result;\n    }\n    \n    while (queue.length > 0) {\n        const current = queue.shift();\n        if (current === endWord) {\n            break;\n        }\n        for (const neighbor of neighbors(current)) {\n            if (!dict.has(neighbor)) {\n                continue;\n            }\n            if (!distance.has(neighbor)) {\n                distance.set(neighbor, distance.get(current) + 1);\n                queue.push(neighbor);\n            }\n            if (distance.get(neighbor) === distance.get(current) + 1) {\n                if (!adjacent.has(current)) {\n                    adjacent.set(current, []);\n                }\n                adjacent.get(current).push(neighbor);\n            }\n        }\n    }\n\n    const result = [];\n    const path = [beginWord];\n\n    function backtrack(word) {\n        if (word === endWord) {\n            result.push([...path]);\n            return;\n        }\n        for (const next of (adjacent.get(word) || [])) {\n            path.push(next);\n            backtrack(next);\n            path.pop();\n        }\n    }\n    \n    backtrack(beginWord);\n    return result;\n}"
        },
        "Qid": "126"
    },
    {
        "_id": {
            "$oid": "661d70ab949b33b6c4e2b0aa"
        },
        "title": "Shortest Transformation Sequence",
        "description": "Given a transformation sequence from a start word to an end word using a dictionary of words, find the shortest transformation sequence. A transformation sequence is a sequence of words where each adjacent pair of words differs by a single letter. The start word does not need to be in the dictionary, but all other words in the sequence must be in the dictionary. Return the number of words in the shortest transformation sequence, or 0 if no such sequence exists.",
        "example": "Example:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nOutput: 5\nExplanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", which is 5 words long.",
        "level": "Medium",
        "tags": [
            "graph",
            "breadth-first search",
            "word ladder"
        ],
        "test_cases": {
            "inputs": [
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log"
                    ]
                ],
                [
                    "a",
                    "c",
                    [
                        "a",
                        "b",
                        "c"
                    ]
                ],
                [
                    "red",
                    "tax",
                    [
                        "ted",
                        "tex",
                        "red",
                        "tax",
                        "tad",
                        "den",
                        "rex",
                        "pee"
                    ]
                ],
                [
                    "hot",
                    "dog",
                    [
                        "hot",
                        "dog"
                    ]
                ],
                [
                    "a",
                    "z",
                    [
                        "a",
                        "b",
                        "c",
                        "d",
                        "e",
                        "f",
                        "g",
                        "h",
                        "i",
                        "j",
                        "k",
                        "l",
                        "m",
                        "n",
                        "o",
                        "p",
                        "q",
                        "r",
                        "s",
                        "t",
                        "u",
                        "v",
                        "w",
                        "x",
                        "y",
                        "z"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog",
                        "hag"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog",
                        "hag",
                        "hug"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog",
                        "hag",
                        "hug",
                        "hut"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog",
                        "hag",
                        "hug",
                        "hut",
                        "cut"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog",
                        "hag",
                        "hug",
                        "hut",
                        "cut",
                        "cup"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog",
                        "hag",
                        "hug",
                        "hut",
                        "cut",
                        "cup",
                        "cop"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog",
                        "hag",
                        "hug",
                        "hut",
                        "cut",
                        "cup",
                        "cop",
                        "cap"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog",
                        "hag",
                        "hug",
                        "hut",
                        "cut",
                        "cup",
                        "cop",
                        "cap",
                        "cab"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog",
                        "hag",
                        "hug",
                        "hut",
                        "cut",
                        "cup",
                        "cop",
                        "cap",
                        "cab",
                        "cab"
                    ]
                ],
                [
                    "hit",
                    "cog",
                    [
                        "hot",
                        "dot",
                        "dog",
                        "lot",
                        "log",
                        "cog",
                        "hat",
                        "cat",
                        "cot",
                        "hog",
                        "hag",
                        "hug",
                        "hut",
                        "cut",
                        "cup",
                        "cop",
                        "cap",
                        "cab",
                        "cab",
                        "cog"
                    ]
                ]
            ],
            "outputs": [
                5,
                0,
                2,
                3,
                0,
                26,
                5,
                4,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n\nint ladderLength(std::string beginWord, std::string endWord, std::vector<std::string>& wordList) {\n    std::unordered_set<std::string> dict(wordList.begin(), wordList.end());\n    if (!dict.count(endWord)) return 0;\n\n    std::queue<std::string> q;\n    q.push(beginWord);\n    int steps = 1;\n\n    while (!q.empty()) {\n        int size = q.size();\n        for (int i = 0; i < size; ++i) {\n            std::string currentWord = q.front();\n            q.pop();\n            if (currentWord == endWord) return steps;\n\n            for (char& c : currentWord) {\n                char originalChar = c;\n                for (int j = 0; j < 26; ++j) {\n                    c = 'a' + j;\n                    if (dict.count(currentWord)) {\n                        q.push(currentWord);\n                        dict.erase(currentWord);\n                    }\n                }\n                c = originalChar;\n            }\n        }\n        ++steps;\n    }\n    return 0;\n}\n",
            "java": "import java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Set;\n\npublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\n    Set<String> dict = new HashSet<>(wordList);\n    if (!dict.contains(endWord)) return 0;\n\n    Queue<String> q = new LinkedList<>();\n    q.offer(beginWord);\n    int steps = 1;\n\n    while (!q.isEmpty()) {\n        int size = q.size();\n        for (int i = 0; i < size; ++i) {\n            String currentWord = q.poll();\n            if (currentWord.equals(endWord)) return steps;\n\n            char[] charArray = currentWord.toCharArray();\n            for (int j = 0; j < charArray.length; ++j) {\n                char originalChar = charArray[j];\n                for (int k = 0; k < 26; ++k) {\n                    charArray[j] = (char) ('a' + k);\n                    String newWord = new String(charArray);\n                    if (dict.remove(newWord)) {\n                        q.offer(newWord);\n                    }\n                }\n                charArray[j] = originalChar;\n            }\n        }\n        ++steps;\n    }\n    return 0;\n}\n",
            "python": "from collections import deque\n\ndef ladderLength(beginWord, endWord, wordList):\n    word_set = set(wordList)\n    if endWord not in word_set:\n        return 0\n\n    q = deque([beginWord])\n    steps = 1\n\n    while q:\n        size = len(q)\n        current_level = set()\n        \n        for _ in range(size):\n            current_word = q.popleft()\n            if current_word == endWord:\n                return steps\n\n            word_chars = list(current_word)\n            for i in range(len(word_chars)):\n                original_char = word_chars[i]\n                for j in range(26):\n                    word_chars[i] = chr(ord('a') + j)\n                    new_word = ''.join(word_chars)\n                    if new_word in word_set:\n                        q.append(new_word)\n                        current_level.add(new_word)\n                        \n                word_chars[i] = original_char\n        \n        word_set -= current_level\n        steps += 1\n        \n    return 0\n",
            "javascript": "function ladderLength(beginWord, endWord, wordList) {\n    const wordSet = new Set(wordList);\n    if (!wordSet.has(endWord)) return 0;\n\n    const q = [beginWord];\n    let steps = 1;\n\n    while (q.length > 0) {\n        const size = q.length;\n        const currentLevel = new Set();\n\n        for (let i = 0; i < size; ++i) {\n            const currentWord = q.shift();\n            if (currentWord === endWord) return steps;\n\n            const wordChars = currentWord.split('');\n            for (let j = 0; j < wordChars.length; ++j) {\n                const originalChar = wordChars[j];\n                for (let k = 0; k < 26; ++k) {\n                    wordChars[j] = String.fromCharCode('a'.charCodeAt(0) + k);\n                    const newWord = wordChars.join('');\n                    if (wordSet.has(newWord)) {\n                        q.push(newWord);\n                        currentLevel.add(newWord);\n                    }\n                }\n                wordChars[j] = originalChar;\n            }\n        }\n        steps++;\n        for (const word of currentLevel) {\n            wordSet.delete(word);\n        }\n    }\n    return 0;\n}\n",
            "explanation": "In this problem, we use a breadth-first search (BFS) algorithm to find the shortest transformation sequence from `beginWord` to `endWord`:\n\n1. Create an unordered set `dict` or `word_set` with all the words from `wordList` for fast look-up, and check if it contains the `endWord`.\n2. Create a queue for BFS, initialize it with `beginWord`, and initialize `steps` variable to 1.\n3. Repeat the following steps while the queue is not empty:\n   a) For each level of BFS, store the current level size, and create an empty set for `current_level` (only in Python & JavaScript).\n   b) Iterate for each word in the current BFS level:\n      - Dequeue the next `currentWord`, and check for `endWord`; if found return the current `steps` value.\n      - Iterate through each character of the `currentWord`; for every character, replace it with 26 possible lowercase alphabets.\n        - If the new word is in the `dict` or `word_set`, enqueue it in the queue, and remove it. In Python and JavaScript, also add it to the `current_level` set.\n      - Revert the character back to the original character.\n   c) Increment the `steps` value by 1, and in Python/javascript, update the `word_set` by removing words present in `current_level`.\n4. If the queue is empty and no sequence is found, return 0."
        },
        "structure": {
            "c++": "#include <string>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n\nint ladderLength(std::string beginWord, std::string endWord, std::vector<std::string>& wordList)  {\n    // Your code here\n}\n",
            "java": "import java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Set;\n\npublic int ladderLength(String beginWord, String endWord, List<String> wordList)  {\n    // Your code here\n}\n",
            "python": "from collections import deque\n    # Your code here\n\n",
            "javascript": "function ladderLength(beginWord, endWord, wordList)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n\nint main() {\n    std::string beginWord = $args;\n    std::string endWord = $args;\n    std::vector<std::string> wordList = $args;\n    int result = ladderLength(beginWord, endWord, wordList);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n    Set<String> dict = new HashSet<>(wordList);\n    if (!dict.contains(endWord)) return 0;\n\n    Queue<String> q = new LinkedList<>();\n    q.offer(beginWord);\n    int steps = 1;\n\n    while (!q.isEmpty()) {\n        int size = q.size();\n        for (int i = 0; i < size; ++i) {\n            String currentWord = q.poll();\n            if (currentWord.equals(endWord)) return steps;\n\n            char[] charArray = currentWord.toCharArray();\n            for (int j = 0; j < charArray.length; ++j) {\n                char originalChar = charArray[j];\n                for (int k = 0; k < 26; ++k) {\n                    charArray[j] = (char) ('a' + k);\n                    String newWord = new String(charArray);\n                    if (dict.remove(newWord)) {\n                        q.offer(newWord);\n                    }\n                }\n                charArray[j] = originalChar;\n            }\n        }\n        ++steps;\n    }\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    beginWord = inputs[0]\n    endWord = inputs[1]\n    wordList = inputs[2]\n    result = ladderLength(beginWord, endWord, wordList)\n    print(result)",
            "javascript": "function ladderLength(beginWord, endWord, wordList) {\n    const wordSet = new Set(wordList);\n    if (!wordSet.has(endWord)) return 0;\n\n    const q = [beginWord];\n    let steps = 1;\n\n    while (q.length > 0) {\n        const size = q.length;\n        const currentLevel = new Set();\n\n        for (let i = 0; i < size; ++i) {\n            const currentWord = q.shift();\n            if (currentWord === endWord) return steps;\n\n            const wordChars = currentWord.split('');\n            for (let j = 0; j < wordChars.length; ++j) {\n                const originalChar = wordChars[j];\n                for (let k = 0; k < 26; ++k) {\n                    wordChars[j] = String.fromCharCode('a'.charCodeAt(0) + k);\n                    const newWord = wordChars.join('');\n                    if (wordSet.has(newWord)) {\n                        q.push(newWord);\n                        currentLevel.add(newWord);\n                    }\n                }\n                wordChars[j] = originalChar;\n            }\n        }\n        steps++;\n        for (const word of currentLevel) {\n            wordSet.delete(word);\n        }\n    }\n    return 0;\n}"
        },
        "Qid": "127"
    },
    {
        "_id": {
            "$oid": "661d70cb949b33b6c4e2b0ab"
        },
        "title": "Longest Consecutive Sequence",
        "description": "Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in `O(n)` time.",
        "example": "Example:\n\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore, its length is 4.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    100,
                    4,
                    200,
                    1,
                    3,
                    2
                ],
                [
                    0,
                    3,
                    7,
                    2,
                    5,
                    8,
                    4,
                    6,
                    0,
                    1
                ],
                [],
                [
                    1
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9,
                    2,
                    4,
                    6,
                    8,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15
                ],
                [
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90
                ],
                [
                    90,
                    80,
                    70,
                    60,
                    50,
                    40,
                    30,
                    20,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    100,
                    200,
                    300,
                    400,
                    500,
                    600,
                    700,
                    800,
                    900
                ],
                [
                    900,
                    800,
                    700,
                    600,
                    500,
                    400,
                    300,
                    200,
                    100,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    100,
                    200,
                    300,
                    400,
                    500,
                    600,
                    700,
                    800,
                    900,
                    1000
                ],
                [
                    1000,
                    900,
                    800,
                    700,
                    600,
                    500,
                    400,
                    300,
                    200,
                    100,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    100,
                    200,
                    300,
                    400,
                    500,
                    600,
                    700,
                    800,
                    900,
                    1000,
                    10000
                ],
                [
                    10000,
                    1000,
                    900,
                    800,
                    700,
                    600,
                    500,
                    400,
                    300,
                    200,
                    100,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ]
            ],
            "outputs": [
                4,
                9,
                0,
                1,
                1,
                1,
                9,
                1,
                10,
                10,
                15,
                10,
                6,
                10,
                19,
                19,
                20,
                20,
                21,
                21
            ]
        },
        "sample_code": {
            "c++": "int longestConsecutive(vector<int>& nums) {\n    unordered_set<int> elements(nums.begin(), nums.end());\n    int longestSeq = 0;\n    \n    for (int num : nums) {\n        if (elements.find(num - 1) == elements.end()) {\n            int currentNum = num;\n            int currentSeq = 1;\n            \n            while (elements.find(currentNum + 1) != elements.end()) {\n                currentNum += 1;\n                currentSeq += 1;\n            }\n            \n            longestSeq = max(longestSeq, currentSeq);\n        }\n    }\n    return longestSeq;\n}\n",
            "java": "public int longestConsecutive(int[] nums) {\n    Set<Integer> elements = new HashSet<>();\n    for (int num : nums) {\n        elements.add(num);\n    }\n    \n    int longestSeq = 0;\n    \n    for (int num : nums) {\n        if (!elements.contains(num - 1)) {\n            int currentNum = num;\n            int currentSeq = 1;\n            \n            while (elements.contains(currentNum + 1)) {\n                currentNum++;\n                currentSeq++;\n            }\n            \n            longestSeq = Math.max(longestSeq, currentSeq);\n        }\n    }\n    return longestSeq;\n}\n",
            "python": "def longest_consecutive(nums):\n    elements = set(nums)\n    longest_seq = 0\n\n    for num in nums:\n        if num - 1 not in elements:\n            current_num = num\n            current_seq = 1\n            \n            while current_num + 1 in elements:\n                current_num += 1\n                current_seq += 1\n\n            longest_seq = max(longest_seq, current_seq)\n    \n    return longest_seq\n",
            "javascript": "function longestConsecutive(nums) {\n    const elements = new Set(nums);\n    let longestSeq = 0;\n\n    for (const num of nums) {\n        if (!elements.has(num - 1)) {\n            let currentNum = num;\n            let currentSeq = 1;\n\n            while (elements.has(currentNum + 1)) {\n                currentNum++;\n                currentSeq++;\n            }\n\n            longestSeq = Math.max(longestSeq, currentSeq);\n        }\n    }\n\n    return longestSeq;\n}\n\n",
            "explanation": "The algorithm first creates a set (or hash set) with the given array of integers called `elements`. The set will allow us to have a fast O(1) lookup on our next step.\nNow we iterate through the original array of numbers, and for each number, we check if `(number - 1)` is not in the `elements` set. If it's not in the set, it means we can start counting a new consecutive sequence.\nNext, we create two variables, `currentNum` and `currentSeq`, and initialize them with the current number and 1, respectively.\nWe then use a while loop to check if the next number (`currentNum + 1`) is in the `elements` set. If it is, we increment both `currentNum` and `currentSeq`. This process will continue, finding consecutive elements in the set, until no more consecutive elements are found.\nFinally, to get the length of the longest consecutive sequence, we update the `longestSeq` variable by choosing the maximum value between itself and `currentSeq`. This will keep track of the longest consecutive sequence found so far.\nThe process continues until all numbers in the original array have been checked, and at the end, `longestSeq` will store the answer - the length of the longest consecutive elements sequence."
        },
        "structure": {
            "c++": "int longestConsecutive(vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "public int longestConsecutive(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def longest_consecutive(nums):\n    # Your code here\n\n",
            "javascript": "function longestConsecutive(nums)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int longestConsecutive(vector<int>& nums) {\n    unordered_set<int> elements(nums.begin(), nums.end());\n    int longestSeq = 0;\n    \n    for (int num : nums) {\n        if (elements.find(num - 1) == elements.end()) {\n            int currentNum = num;\n            int currentSeq = 1;\n            \n            while (elements.find(currentNum + 1) != elements.end()) {\n                currentNum += 1;\n                currentSeq += 1;\n            }\n            \n            longestSeq = max(longestSeq, currentSeq);\n        }\n    }\n    return longestSeq;\n}",
            "java": "public int longestConsecutive(int[] nums) {\n    Set<Integer> elements = new HashSet<>();\n    for (int num : nums) {\n        elements.add(num);\n    }\n    \n    int longestSeq = 0;\n    \n    for (int num : nums) {\n        if (!elements.contains(num - 1)) {\n            int currentNum = num;\n            int currentSeq = 1;\n            \n            while (elements.contains(currentNum + 1)) {\n                currentNum++;\n                currentSeq++;\n            }\n            \n            longestSeq = Math.max(longestSeq, currentSeq);\n        }\n    }\n    return longestSeq;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = longest_consecutive(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = longestConsecutive(nums);\n    console.log(result);\n}"
        },
        "Qid": "128"
    },
    {
        "_id": {
            "$oid": "661d72da949b33b6c4e2b0ac"
        },
        "title": "Palindrome Partitioning",
        "description": "Given a string `s`, partition `s` such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of `s`.",
        "example": "Example 1:\n\nInput: s = \"aab\"\nOutput: [['a','a','b'],['aa','b']]\n\nExample 2:\n\nInput: s = \"a\"\nOutput: [['a']]\n",
        "level": "Medium",
        "tags": [
            "string",
            "backtracking"
        ],
        "test_cases": {
            "inputs": [
                "\"aab\"",
                "\"a\"",
                "\"racecar\"",
                "\"level\"",
                "\"madam\"",
                "\"abcba\"",
                "\"abba\"",
                "\"aabbaa\"",
                "\"aaaaa\"",
                "\"ababab\"",
                "\"abcd\"",
                "\"aaaaaabaaaaa\"",
                "\"aabbaabb\"",
                "\"aabb\"",
                "\"aabbaa\"",
                "\"aabbcc\"",
                "\"abcde\"",
                "\"aaaaaaa\"",
                "\"aabbaabbcc\"",
                "\"aabbccddeeffgg\""
            ],
            "outputs": [
                [
                    [
                        "a",
                        "a",
                        "b"
                    ],
                    [
                        "aa",
                        "b"
                    ]
                ],
                [
                    [
                        "a"
                    ]
                ],
                [
                    [
                        "r",
                        "a",
                        "c",
                        "e",
                        "c",
                        "a",
                        "r"
                    ]
                ],
                [
                    [
                        "l",
                        "e",
                        "v",
                        "e",
                        "l"
                    ]
                ],
                [
                    [
                        "m",
                        "a",
                        "d",
                        "a",
                        "m"
                    ]
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "b",
                        "a"
                    ]
                ],
                [
                    [
                        "a",
                        "b",
                        "b",
                        "a"
                    ]
                ],
                [
                    [
                        "a",
                        "a",
                        "b",
                        "b",
                        "a",
                        "a"
                    ]
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ]
                ],
                [
                    [
                        "a",
                        "b",
                        "a",
                        "b",
                        "a",
                        "b"
                    ]
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d"
                    ]
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a",
                        "b",
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ]
                ],
                [
                    [
                        "a",
                        "a",
                        "b",
                        "b",
                        "a",
                        "a",
                        "b",
                        "b"
                    ]
                ],
                [
                    [
                        "a",
                        "a",
                        "b",
                        "b",
                        "a",
                        "a"
                    ]
                ],
                [
                    [
                        "a",
                        "a",
                        "b",
                        "b",
                        "a",
                        "a"
                    ]
                ],
                [
                    [
                        "a",
                        "a",
                        "b",
                        "b",
                        "c",
                        "c"
                    ]
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d",
                        "e"
                    ]
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ]
                ],
                [
                    [
                        "a",
                        "a",
                        "b",
                        "b",
                        "a",
                        "a",
                        "b",
                        "b",
                        "c",
                        "c"
                    ]
                ],
                [
                    [
                        "a",
                        "a",
                        "b",
                        "b",
                        "c",
                        "c",
                        "d",
                        "d",
                        "e",
                        "e",
                        "f",
                        "f",
                        "g",
                        "g"
                    ]
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n\nbool isPalindrome(const std::string& s, int start, int end) {\n    while (start < end) {\n        if (s[start++] != s[end--]) return false;\n    }\n    return true;\n}\n\nvoid dfs(const std::string& s, int start, std::vector<std::vector<std::string>>& results, std::vector<std::string> current) {\n    if (start == s.length()) {\n        results.push_back(current);\n        return;\n    }\n    \n    for (int end = start; end < s.length(); ++end) {\n        if (isPalindrome(s, start, end)) {\n            current.push_back(s.substr(start, end - start + 1));\n            dfs(s, end + 1, results, current);\n            current.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<std::string>> partition(std::string s) {\n    std::vector<std::vector<std::string>> results;\n    std::vector<std::string> current;\n    dfs(s, 0, results, current);\n    return results;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    private boolean isPalindrome(String s, int start, int end) {\n        while (start < end) {\n            if (s.charAt(start++) != s.charAt(end--)) return false;\n        }\n        return true;\n    }\n\n    private void dfs(String s, int start, List<List<String>> results, List<String> current) {\n        if (start == s.length()) {\n            results.add(new ArrayList<>(current));\n            return;\n        }\n        \n        for (int end = start; end < s.length(); end++) {\n            if (isPalindrome(s, start, end)) {\n                current.add(s.substring(start, end + 1));\n                dfs(s, end + 1, results, current);\n                current.remove(current.size() - 1);\n            }\n        }\n    }\n\n    public List<List<String>> partition(String s) {\n        List<List<String>> results = new ArrayList<>();\n        List<String> current = new ArrayList<>();\n        dfs(s, 0, results, current);\n        return results;\n    }\n}\n",
            "python": "def isPalindrome(s, start, end):\n    while start < end:\n        if s[start] != s[end]:\n            return False\n        start += 1\n        end -= 1\n    return True\n\ndef dfs(s, start, results, current):\n    if start == len(s):\n        results.append(current[:])\n        return\n    \n    for end in range(start, len(s)):\n        if isPalindrome(s, start, end):\n            current.append(s[start:end+1])\n            dfs(s, end + 1, results, current)\n            current.pop()\n\ndef partition(s):\n    results = []\n    dfs(s, 0, results, [])\n    return results\n",
            "javascript": "function isPalindrome(s, start, end) {\n    while (start < end) {\n        if (s[start++] !== s[end--]) return false;\n    }\n    return true;\n}\n\nfunction dfs(s, start, results, current) {\n    if (start === s.length) {\n        results.push([...current]);\n        return;\n    }\n    \n    for (let end = start; end < s.length; end++) {\n        if (isPalindrome(s, start, end)) {\n            current.push(s.slice(start, end + 1));\n            dfs(s, end + 1, results, current);\n            current.pop();\n        }\n    }\n}\n\nfunction partition(s) {\n    let results = [];\n    dfs(s, 0, results, []);\n    return results;\n}\n",
            "explanation": "The algorithm is based on depth-first search (DFS). It starts by iterating over substrings at each position and checks if the substring is a palindrome. If it is a palindrome, it adds the substring to the current list and does a depth-first search at the next position. When the search reaches the end of the string, it adds the current list to the results list. After searching at a given position, it backtracks to the previous position and continues to search for palindromes. The overall time complexity is O(N * 2^N) where N is the length of the string."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n\nbool isPalindrome(const std::string& s, int start, int end)  {\n    // Your code here\n}\n",
            "java": "i {mport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution \n    // Your code here\n}\n",
            "python": "def isPalindrome(s, start, end):\n    # Your code here\n\n",
            "javascript": "function isPalindrome(s, start, end)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <iostream>\n\nbool isPalindrome(const std::string& s, int start, int end) {\n    while (start < end) {\n        if (s[start++] != s[end--]) return false;\n    }\n    return true;\n}\n\nvoid dfs(const std::string& s, int start, std::vector<std::vector<std::string>>& results, std::vector<std::string> current) {\n    if (start == s.length()) {\n        results.push_back(current);\n        return;\n    }\n    \n    for (int end = start; end < s.length(); ++end) {\n        if (isPalindrome(s, start, end)) {\n            current.push_back(s.substr(start, end - start + 1));\n            dfs(s, end + 1, results, current);\n            current.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<std::string>> partition(std::string s) {\n    std::vector<std::vector<std::string>> results;\n    std::vector<std::string> current;\n    dfs(s, 0, results, current);\n    return results;\n}\n\nint main() {\n    std::string s = $args;\n    std::vector<std::vector<std::string>> result = partition(s);\n    for (const auto& vec : result) {\n        for (const auto& str : vec) {\n            std::cout << str << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}",
            "java": "public List<List<String>> partition(String s)",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = partition(s)\n    print(result)",
            "javascript": "function partition(s) {\n    let results = [];\n    dfs(s, 0, results, []);\n    return results;\n}"
        },
        "Qid": "131"
    },
    {
        "_id": {
            "$oid": "661d73d9949b33b6c4e2b0ad"
        },
        "title": "Minimum Number of Candies",
        "description": "There are `n` children standing in a line. Each child is assigned a rating value given in the integer array `ratings`. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. Return the minimum number of candies you need to have to distribute the candies to the children.",
        "example": "Example:\n\nInput: ratings = [1,0,2]\nOutput: 5\nExplanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n\nInput: ratings = [1,2,2]\nOutput: 4\nExplanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively. The third child gets 1 candy because it satisfies the above two conditions.",
        "level": "Medium",
        "tags": [
            "array",
            "greedy"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    0,
                    2
                ],
                [
                    1,
                    2,
                    2
                ],
                [
                    4,
                    2,
                    3,
                    4,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    1,
                    2,
                    3,
                    4,
                    5,
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1,
                    5,
                    4,
                    3,
                    2,
                    1,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1,
                    1,
                    2,
                    3,
                    4,
                    5
                ]
            ],
            "outputs": [
                5,
                4,
                9,
                5,
                15,
                15,
                16,
                9,
                15,
                25,
                15,
                25,
                20,
                20,
                30,
                30,
                10,
                15,
                15,
                25
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nint minCandies(vector<int>& ratings) {\n    int n = ratings.size();\n    vector<int> candies(n, 1);\n\n    for(int i = 1; i < n; i++) {\n        if(ratings[i] > ratings[i-1]) candies[i] = candies[i-1] + 1;\n    }\n    for(int i = n - 2; i >= 0; i--) {\n        if(ratings[i] > ratings[i+1]) candies[i] = max(candies[i], candies[i+1] + 1);\n    }\n\n    int sum = 0;\n    for(int candy : candies) sum += candy;\n\n    return sum;\n}\n",
            "java": "public int minCandies(int[] ratings) {\n    int n = ratings.length;\n    int[] candies = new int[n];\n    for (int i = 0; i < n; i++) candies[i] = 1;\n\n    for (int i = 1; i < n; i++) {\n        if (ratings[i] > ratings[i - 1]) candies[i] = candies[i - 1] + 1;\n    }\n    for (int i = n - 2; i >= 0; i--) {\n        if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n    }\n\n    int sum = 0;\n    for (int candy : candies) sum += candy;\n\n    return sum;\n}\n",
            "python": "def min_candies(ratings):\n    n = len(ratings)\n    candies = [1] * n\n\n    for i in range(1, n):\n        if ratings[i] > ratings[i - 1]:\n            candies[i] = candies[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n        if ratings[i] > ratings[i + 1]:\n            candies[i] = max(candies[i], candies[i + 1] + 1)\n\n    return sum(candies)\n",
            "javascript": "function minCandies(ratings) {\n    const n = ratings.length;\n    const candies = Array(n).fill(1);\n\n    for (let i = 1; i < n; i++) {\n        if (ratings[i] > ratings[i - 1]) candies[i] = candies[i - 1] + 1;\n    }\n    for (let i = n - 2; i >= 0; i--) {\n        if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n    }\n\n    return candies.reduce((a, b) => a + b, 0);\n}\n",
            "explanation": "The algorithm takes the following steps to find the minimum number of candies needed to be distributed among the children:\n1. Initialize an array or vector 'candies' with the same length as ratings and set all its elements to 1 as every child will have at least 1 candy.\n2. Iterate through the ratings array from the second child to the last child. If the rating of the current child is more than the rating of the previous child, update the candies for the current child as candies of the previous child plus 1.\n3. Now iterate through the ratings array from the second last child to the first child. If the rating of the current child is more than the rating of the next child, update the candies for the current child as maximum between the candies the child already holds and candies of the next child plus 1.\n4. Compute the sum of candies in the candies array or vector.\n5. Return the total number of candies needed.\n\nThis algorithm ensures that we give the proper number of candies to the children based on both their neighbors while also minimizing the total candies used."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nint minCandies(vector<int>& ratings)  {\n    // Your code here\n}\n",
            "java": "public int minCandies(int[] ratings)  {\n    // Your code here\n}\n",
            "python": "def min_candies(ratings):\n    # Your code here\n\n",
            "javascript": "function minCandies(ratings)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nint main() {\n    vector<int> ratings = $args;\n    int result = minCandies(ratings);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int minCandies(int[] ratings) {\n    int n = ratings.length;\n    int[] candies = new int[n];\n    for (int i = 0; i < n; i++) candies[i] = 1;\n\n    for (int i = 1; i < n; i++) {\n        if (ratings[i] > ratings[i - 1]) candies[i] = candies[i - 1] + 1;\n    }\n    for (int i = n - 2; i >= 0; i--) {\n        if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n    }\n\n    int sum = 0;\n    for (int candy : candies) sum += candy;\n\n    return sum;\n}",
            "python": "if __name__ == \"__main__\":\n    ratings = $args\n    result = min_candies(ratings)\n    print(result)",
            "javascript": ""
        },
        "Qid": "135"
    },
    {
        "_id": {
            "$oid": "661d74cb949b33b6c4e2b0ae"
        },
        "title": "String Segmentation",
        "description": "Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation.",
        "example": "Example:\n\nInput: s = \"leetcode \", wordDict = [ \"leet \", \"code \"]\nOutput: true\nExplanation: Return true because \"leetcode \" can be segmented as \"leet code \".",
        "level": "Medium",
        "tags": [
            "dynamic programming",
            "string"
        ],
        "test_cases": {
            "inputs": [
                [
                    "leetcode ",
                    [
                        "leet ",
                        "code "
                    ]
                ],
                [
                    "applepenapple ",
                    [
                        "apple ",
                        "pen "
                    ]
                ],
                [
                    "catsandog ",
                    [
                        "cats ",
                        "dog ",
                        "sand ",
                        "and ",
                        "cat "
                    ]
                ],
                [
                    "programming ",
                    [
                        "program ",
                        "programming "
                    ]
                ],
                [
                    "algorithm ",
                    [
                        "algo ",
                        "rithm "
                    ]
                ],
                [
                    "hello ",
                    [
                        "hell ",
                        "hello "
                    ]
                ],
                [
                    "world ",
                    [
                        "world ",
                        "hello "
                    ]
                ],
                [
                    "leetcode ",
                    [
                        "leet ",
                        "code ",
                        "leet "
                    ]
                ],
                [
                    "applepenapple ",
                    [
                        "apple ",
                        "pen ",
                        "apple "
                    ]
                ],
                [
                    "catsandog ",
                    [
                        "cats ",
                        "dog ",
                        "sand ",
                        "and ",
                        "cat ",
                        "sand "
                    ]
                ],
                [
                    "programming ",
                    [
                        "program ",
                        "programming ",
                        "program "
                    ]
                ],
                [
                    "algorithm ",
                    [
                        "algo ",
                        "rithm ",
                        "algo "
                    ]
                ],
                [
                    "hello ",
                    [
                        "hell ",
                        "hello ",
                        "hell "
                    ]
                ],
                [
                    "world ",
                    [
                        "world ",
                        "hello ",
                        "world "
                    ]
                ],
                [
                    "leetcode ",
                    [
                        "leet ",
                        "code ",
                        "leet ",
                        "code "
                    ]
                ],
                [
                    "applepenapple ",
                    [
                        "apple ",
                        "pen ",
                        "apple ",
                        "pen "
                    ]
                ],
                [
                    "catsandog ",
                    [
                        "cats ",
                        "dog ",
                        "sand ",
                        "and ",
                        "cat ",
                        "sand ",
                        "dog "
                    ]
                ],
                [
                    "programming ",
                    [
                        "program ",
                        "programming ",
                        "program ",
                        "programming "
                    ]
                ],
                [
                    "algorithm ",
                    [
                        "algo ",
                        "rithm ",
                        "algo ",
                        "rithm "
                    ]
                ],
                [
                    "hello ",
                    [
                        "hell ",
                        "hello ",
                        "hell ",
                        "hello "
                    ]
                ],
                [
                    "world ",
                    [
                        "world ",
                        "hello ",
                        "world ",
                        "hello "
                    ]
                ]
            ],
            "outputs": [
                true,
                true,
                false,
                true,
                true,
                true,
                false,
                true,
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                false,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_set>\n\nbool wordBreak(std::string s, std::vector<std::string>& wordDict) {\n    std::unordered_set<std::string> dict(wordDict.begin(), wordDict.end());\n    std::vector<bool> dp(s.size() + 1, false);\n    dp[0] = true;\n    for (size_t i = 1; i <= s.size(); ++i) {\n        for (size_t j = 0; j < i; ++j) {\n            if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[s.size()];\n}\n\n",
            "java": "import java.util.List;\nimport java.util.Set;\nimport java.util.HashSet;\n\npublic boolean wordBreak(String s, List<String> wordDict) {\n    Set<String> dict = new HashSet<>(wordDict);\n    boolean[] dp = new boolean[s.length() + 1];\n    dp[0] = true;\n    for (int i = 1; i <= s.length(); i++) {\n        for (int j = 0; j < i; j++) {\n            if (dp[j] && dict.contains(s.substring(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[s.length()];\n}\n\n",
            "python": "def word_break(s, word_dict):\n    word_set = set(word_dict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    return dp[len(s)]\n\n",
            "javascript": "function wordBreak(s, wordDict) {\n    const dict = new Set(wordDict);\n    const dp = Array(s.length + 1).fill(false);\n    dp[0] = true;\n    for (let i = 1; i <= s.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (dp[j] && dict.has(s.slice(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[s.length];\n}\n\n",
            "explanation": "The algorithm uses dynamic programming to solve the problem. The dp array is created with the size of the input string s plus 1. dp[i] is true if there exists a segmentation of the first i characters of the string s into words from the dictionary. The algorithm initializes dp[0] as true since an empty string can be segmented.\n\nFor each character in the input string s, the algorithm checks all substrings ending at this character. If the substring s[j:i] is in the dictionary (or wordDict for Java and C++) and dp[j] is true, set dp[i] to true and break from the inner loop.\n\nAt the end of the algorithm, dp[s.size()] (or dp[s.length()] for Java and JavaScript, or dp[len(s)] in Python) contains the result for the entire input string s. If this value is true, the input string can be segmented into a sequence of one or more dictionary words, otherwise it cannot."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_set>\n\nbool wordBreak(std::string s, std::vector<std::string>& wordDict)  {\n    // Your code here\n}\n\n",
            "java": "import java.util.List;\nimport java.util.Set;\nimport java.util.HashSet;\n\npublic boolean wordBreak(String s, List<String> wordDict)  {\n    // Your code here\n}\n\n",
            "python": "def word_break(s, word_dict):\n    # Your code here\n\n",
            "javascript": "function wordBreak(s, wordDict)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_set>\n#include <iostream>\n\nbool wordBreak(std::string s, std::vector<std::string>& wordDict) {\n    std::unordered_set<std::string> dict(wordDict.begin(), wordDict.end());\n    std::vector<bool> dp(s.size() + 1, false);\n    dp[0] = true;\n    for (size_t i = 1; i <= s.size(); ++i) {\n        for (size_t j = 0; j < i; ++j) {\n            if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[s.size()];\n}\n\nint main() {\n    std::string s = $args;\n    std::vector<std::string> wordDict = {\"leet\", \"code\"};\n    bool result = wordBreak(s, wordDict);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}\n",
            "java": "public boolean wordBreak(String s, List<String> wordDict) {\n    Set<String> dict = new HashSet<>(wordDict);\n    boolean[] dp = new boolean[s.length() + 1];\n    dp[0] = true;\n    for (int i = 1; i <= s.length(); i++) {\n        for (int j = 0; j < i; j++) {\n            if (dp[j] && dict.contains(s.substring(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[s.length()];\n}",
            "python": "if __name__ == \"__main__\":\n    inputs =$args\n    s=inputs[0]\n    word_dict = inputs[1]\n    result = word_break(s, word_dict)\n    print(result)\n",
            "javascript": ""
        },
        "Qid": "139"
    },
    {
        "_id": {
            "$oid": "661d778a949b33b6c4e2b0af"
        },
        "title": "Maximum Points on a Line",
        "description": "Given an array of points where each point is represented as [x, y] coordinates on the X-Y plane, find the maximum number of points that lie on the same straight line.",
        "example": "Example 1:\n\nInput: points = [[1,1],[2,2],[3,3]]\nOutput: 3\n\nExplanation: All three points lie on the same line.\n\nExample 2:\n\nInput: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4\n\nExplanation: The maximum number of points that lie on the same line is 4.\n\n",
        "level": "Medium",
        "tags": [
            "Math",
            "Geometry",
            "Hash Table"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        3,
                        2
                    ],
                    [
                        5,
                        3
                    ],
                    [
                        4,
                        1
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        1,
                        4
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        0,
                        0
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ],
                    [
                        26,
                        26
                    ],
                    [
                        27,
                        27
                    ],
                    [
                        28,
                        28
                    ],
                    [
                        29,
                        29
                    ],
                    [
                        30,
                        30
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ],
                    [
                        26,
                        26
                    ],
                    [
                        27,
                        27
                    ],
                    [
                        28,
                        28
                    ],
                    [
                        29,
                        29
                    ],
                    [
                        30,
                        30
                    ],
                    [
                        31,
                        31
                    ],
                    [
                        32,
                        32
                    ],
                    [
                        33,
                        33
                    ],
                    [
                        34,
                        34
                    ],
                    [
                        35,
                        35
                    ],
                    [
                        36,
                        36
                    ],
                    [
                        37,
                        37
                    ],
                    [
                        38,
                        38
                    ],
                    [
                        39,
                        39
                    ],
                    [
                        40,
                        40
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ],
                    [
                        26,
                        26
                    ],
                    [
                        27,
                        27
                    ],
                    [
                        28,
                        28
                    ],
                    [
                        29,
                        29
                    ],
                    [
                        30,
                        30
                    ],
                    [
                        31,
                        31
                    ],
                    [
                        32,
                        32
                    ],
                    [
                        33,
                        33
                    ],
                    [
                        34,
                        34
                    ],
                    [
                        35,
                        35
                    ],
                    [
                        36,
                        36
                    ],
                    [
                        37,
                        37
                    ],
                    [
                        38,
                        38
                    ],
                    [
                        39,
                        39
                    ],
                    [
                        40,
                        40
                    ],
                    [
                        41,
                        41
                    ],
                    [
                        42,
                        42
                    ],
                    [
                        43,
                        43
                    ],
                    [
                        44,
                        44
                    ],
                    [
                        45,
                        45
                    ],
                    [
                        46,
                        46
                    ],
                    [
                        47,
                        47
                    ],
                    [
                        48,
                        48
                    ],
                    [
                        49,
                        49
                    ],
                    [
                        50,
                        50
                    ]
                ]
            ],
            "outputs": [
                "3",
                "4",
                "3",
                "5",
                "10",
                "15",
                "20",
                "25",
                "30",
                "35"
            ]
        },
        "sample_code": {
            "c++": "#include <unordered_map>\n\nint maxPoints(vector<vector<int>>& points) {\n    int n = points.size();\n    if (n <= 2) return n;\n    int max_count = 0;\n\n    for (int i = 0; i < n; i++) {\n        std::unordered_map<string, int> slope_map;\n        int duplicates = 0, local_max = 0;\n\n        for (int j = i + 1; j < n; j++) {\n            int deltaX = points[j][0] - points[i][0];\n            int deltaY = points[j][1] - points[i][1];\n\n            if (deltaX == 0 && deltaY == 0) {\n                duplicates++;\n                continue;\n            }\n\n            int gcd = std::gcd(deltaX, deltaY);\n            deltaX /= gcd;\n            deltaY /= gcd;\n\n            string key = to_string(deltaX) + \"_\" + to_string(deltaY);\n            slope_map[key]++;\n            local_max = max(local_max, slope_map[key]);\n        }\n        max_count = max(max_count, local_max + duplicates + 1);\n    }\n\n    return max_count;\n}\n\n",
            "java": "import java.util.HashMap;\n\npublic int maxPoints(int[][] points) {\n    int n = points.length;\n    if (n <= 2) return n;\n    int maxCount = 0;\n\n    for (int i = 0; i < n-1; i++) {\n        HashMap<String, Integer> slopeMap = new HashMap<>();\n        int duplicates = 0, localMax = 0;\n\n        for (int j = i+1; j < n; j++) {\n            int deltaX = points[j][0] - points[i][0];\n            int deltaY = points[j][1] - points[i][1];\n\n            if (deltaX == 0 && deltaY == 0) {\n                duplicates++;\n                continue;\n            }\n\n            int gcd = gcd(deltaX, deltaY);\n            deltaX /= gcd;\n            deltaY /= gcd;\n\n            String key = deltaX + \"_\" + deltaY;\n            slopeMap.put(key, slopeMap.getOrDefault(key, 0) + 1);\n            localMax = Math.max(localMax, slopeMap.get(key));\n        }\n        maxCount = Math.max(maxCount, localMax + duplicates + 1);\n    }\n\n    return maxCount;\n}\n\nprivate int gcd(int a, int b) {\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\n",
            "python": "from math import gcd\nfrom collections import defaultdict\n\ndef maxPoints(points):\n    n = len(points)\n    if n <= 2:\n        return n\n\n    max_count = 0\n\n    for i in range(n):\n        slope_map = defaultdict(int)\n        duplicates = 0\n        local_max = 0\n\n        for j in range(i+1, n):\n            deltaX = points[j][0] - points[i][0]\n            deltaY = points[j][1] - points[i][1]\n\n            if deltaX == 0 and deltaY == 0:\n                duplicates += 1\n                continue\n\n            g = gcd(deltaX, deltaY)\n            deltaX = deltaX // g\n            deltaY = deltaY // g\n\n            key = f\"{deltaX}_{deltaY}\"\n            slope_map[key] += 1\n            local_max = max(local_max, slope_map[key])\n\n        max_count = max(max_count, local_max + duplicates + 1)\n\n    return max_count\n\n",
            "javascript": "function maxPoints(points) {\n    const n = points.length;\n    if (n <= 2) return n;\n\n    let maxCount = 0;\n\n    for (let i = 0; i < n; i++) {\n        const slopeMap = new Map();\n        let duplicates = 0, localMax = 0;\n\n        for (let j = i + 1; j < n; j++) {\n            let deltaX = points[j][0] - points[i][0];\n            let deltaY = points[j][1] - points[i][1];\n\n            if (deltaX === 0 && deltaY === 0) {\n                duplicates++;\n                continue;\n            }\n\n            const gcdVal = gcd(deltaX, deltaY);\n            deltaX /= gcdVal;\n            deltaY /= gcdVal;\n\n            const key = `${deltaX}_${deltaY}`;\n            slopeMap.set(key, (slopeMap.get(key) || 0) + 1);\n            localMax = Math.max(localMax, slopeMap.get(key));\n        }\n        maxCount = Math.max(maxCount, localMax + duplicates + 1);\n    }\n\n    return maxCount;\n}\n\nfunction gcd(a, b) {\n    if (b === 0) return a;\n    return gcd(b, a % b);\n}\n\n",
            "explanation": "- Loop through all pairs of points.\n- Calculate the slope of the line determined by the two points `(deltaX / deltaY)`, as well as the number of duplicates of the same point.\n- Count the occurrences of each unique slope (i.e., the lines that go through the same two points), using a hashmap.\n- For each point, find the highest number of slopes and add the duplicates and itself to the count.\n- Find the maximum count of all points, which is the answer."
        },
        "structure": {
            "c++": "#include <unordered_map>\n\nint maxPoints(vector<vector<int>>& points)  {\n    // Your code here\n}\n\n",
            "java": "import java.util.HashMap;\n\npublic int maxPoints(int[][] points)  {\n    // Your code here\n}\n\n",
            "python": "from math import gcd\n    # Your code here\n\n",
            "javascript": "function maxPoints(points)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <unordered_map>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nint maxPoints(vector<vector<int>>& points) {\n    int n = points.size();\n    if (n <= 2) return n;\n    int max_count = 0;\n\n    for (int i = 0; i < n; i++) {\n        std::unordered_map<string, int> slope_map;\n        int duplicates = 0, local_max = 0;\n\n        for (int j = i + 1; j < n; j++) {\n            int deltaX = points[j][0] - points[i][0];\n            int deltaY = points[j][1] - points[i][1];\n\n            if (deltaX == 0 && deltaY == 0) {\n                duplicates++;\n                continue;\n            }\n\n            int gcd = std::gcd(deltaX, deltaY);\n            deltaX /= gcd;\n            deltaY /= gcd;\n\n            string key = to_string(deltaX) + \"_\" + to_string(deltaY);\n            slope_map[key]++;\n            local_max = max(local_max, slope_map[key]);\n        }\n        max_count = max(max_count, local_max + duplicates + 1);\n    }\n\n    return max_count;\n}\n\nint main() {\n    vector<vector<int>> points = $args;\n    int result = maxPoints(points);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int maxPoints(int[][] points) {\n    int n = points.length;\n    if (n <= 2) return n;\n    int maxCount = 0;\n\n    for (int i = 0; i < n-1; i++) {\n        HashMap<String, Integer> slopeMap = new HashMap<>();\n        int duplicates = 0, localMax = 0;\n\n        for (int j = i+1; j < n; j++) {\n            int deltaX = points[j][0] - points[i][0];\n            int deltaY = points[j][1] - points[i][1];\n\n            if (deltaX == 0 && deltaY == 0) {\n                duplicates++;\n                continue;\n            }\n\n            int gcd = gcd(deltaX, deltaY);\n            deltaX /= gcd;\n            deltaY /= gcd;\n\n            String key = deltaX + \"_\" + deltaY;\n            slopeMap.put(key, slopeMap.getOrDefault(key, 0) + 1);\n            localMax = Math.max(localMax, slopeMap.get(key));\n        }\n        maxCount = Math.max(maxCount, localMax + duplicates + 1);\n    }\n\n    return maxCount;\n}",
            "python": "if __name__ == \"__main__\":\n    points = $args\n    result = maxPoints(points)\n    print(result)",
            "javascript": "function main() {\n    const points = $args;\n    const result = maxPoints(points);\n    console.log(result);\n}"
        },
        "Qid": "149"
    },
    {
        "_id": {
            "$oid": "661d7800949b33b6c4e2b0b0"
        },
        "title": "Evaluate Reverse Polish Notation",
        "description": "You are given an array of strings `tokens` that represents an arithmetic expression in a Reverse Polish Notation. Evaluate the expression and return an integer that represents the value of the expression. The valid operators are '+', '-', '*', and '/'. Each operand may be an integer or another expression. The division between two integers always truncates toward zero. There will not be any division by zero. The input represents a valid arithmetic expression in a reverse polish notation. The answer and all the intermediate calculations can be represented in a 32-bit integer.",
        "example": "Example:\n\nInput: tokens = [\"2\", \"1\", \"+\", \"3\", \"*\"]\nOutput: 9\nExplanation: ((2 + 1) * 3) = 9",
        "level": "Medium",
        "tags": [
            "Stack",
            "Math"
        ],
        "test_cases": {
            "inputs": [
                [
                    "2",
                    "1",
                    "+",
                    "3",
                    "*"
                ],
                [
                    "4",
                    "13",
                    "5",
                    "/",
                    "+"
                ],
                [
                    "10",
                    "6",
                    "9",
                    "3",
                    "+",
                    "-11",
                    "*",
                    "/",
                    "*",
                    "17",
                    "+",
                    "5",
                    "+"
                ],
                [
                    "5",
                    "2",
                    "*",
                    "10",
                    "3",
                    "/",
                    "+",
                    "4",
                    "-"
                ],
                [
                    "3",
                    "4",
                    "+",
                    "2",
                    "*",
                    "1",
                    "+"
                ],
                [
                    "4",
                    "2",
                    "5",
                    "*",
                    "+",
                    "1",
                    "3",
                    "2",
                    "*",
                    "+",
                    "/"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-"
                ],
                [
                    "4",
                    "13",
                    "5",
                    "/",
                    "+",
                    "2",
                    "3",
                    "*",
                    "-"
                ],
                [
                    "10",
                    "6",
                    "9",
                    "3",
                    "+",
                    "-11",
                    "*",
                    "/",
                    "*",
                    "17",
                    "+",
                    "5",
                    "+",
                    "2",
                    "3",
                    "*",
                    "-"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-",
                    "10",
                    "11",
                    "*",
                    "+"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-",
                    "10",
                    "11",
                    "*",
                    "+",
                    "12",
                    "13",
                    "*",
                    "-"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-",
                    "10",
                    "11",
                    "*",
                    "+",
                    "12",
                    "13",
                    "*",
                    "-",
                    "14",
                    "15",
                    "*",
                    "+"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-",
                    "10",
                    "11",
                    "*",
                    "+",
                    "12",
                    "13",
                    "*",
                    "-",
                    "14",
                    "15",
                    "*",
                    "+",
                    "16",
                    "17",
                    "*",
                    "-"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-",
                    "10",
                    "11",
                    "*",
                    "+",
                    "12",
                    "13",
                    "*",
                    "-",
                    "14",
                    "15",
                    "*",
                    "+",
                    "16",
                    "17",
                    "*",
                    "-",
                    "18",
                    "19",
                    "*",
                    "+"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-",
                    "10",
                    "11",
                    "*",
                    "+",
                    "12",
                    "13",
                    "*",
                    "-",
                    "14",
                    "15",
                    "*",
                    "+",
                    "16",
                    "17",
                    "*",
                    "-",
                    "18",
                    "19",
                    "*",
                    "+",
                    "20",
                    "21",
                    "*",
                    "-"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-",
                    "10",
                    "11",
                    "*",
                    "+",
                    "12",
                    "13",
                    "*",
                    "-",
                    "14",
                    "15",
                    "*",
                    "+",
                    "16",
                    "17",
                    "*",
                    "-",
                    "18",
                    "19",
                    "*",
                    "+",
                    "20",
                    "21",
                    "*",
                    "-",
                    "22",
                    "23",
                    "*",
                    "+"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-",
                    "10",
                    "11",
                    "*",
                    "+",
                    "12",
                    "13",
                    "*",
                    "-",
                    "14",
                    "15",
                    "*",
                    "+",
                    "16",
                    "17",
                    "*",
                    "-",
                    "18",
                    "19",
                    "*",
                    "+",
                    "20",
                    "21",
                    "*",
                    "-",
                    "22",
                    "23",
                    "*",
                    "+",
                    "24",
                    "25",
                    "*",
                    "-"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-",
                    "10",
                    "11",
                    "*",
                    "+",
                    "12",
                    "13",
                    "*",
                    "-",
                    "14",
                    "15",
                    "*",
                    "+",
                    "16",
                    "17",
                    "*",
                    "-",
                    "18",
                    "19",
                    "*",
                    "+",
                    "20",
                    "21",
                    "*",
                    "-",
                    "22",
                    "23",
                    "*",
                    "+",
                    "24",
                    "25",
                    "*",
                    "-",
                    "26",
                    "27",
                    "*",
                    "+"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-",
                    "10",
                    "11",
                    "*",
                    "+",
                    "12",
                    "13",
                    "*",
                    "-",
                    "14",
                    "15",
                    "*",
                    "+",
                    "16",
                    "17",
                    "*",
                    "-",
                    "18",
                    "19",
                    "*",
                    "+",
                    "20",
                    "21",
                    "*",
                    "-",
                    "22",
                    "23",
                    "*",
                    "+",
                    "24",
                    "25",
                    "*",
                    "-",
                    "26",
                    "27",
                    "*",
                    "+",
                    "28",
                    "29",
                    "*",
                    "-"
                ],
                [
                    "2",
                    "3",
                    "+",
                    "4",
                    "*",
                    "5",
                    "-",
                    "6",
                    "7",
                    "*",
                    "+",
                    "8",
                    "9",
                    "*",
                    "-",
                    "10",
                    "11",
                    "*",
                    "+",
                    "12",
                    "13",
                    "*",
                    "-",
                    "14",
                    "15",
                    "*",
                    "+",
                    "16",
                    "17",
                    "*",
                    "-",
                    "18",
                    "19",
                    "*",
                    "+",
                    "20",
                    "21",
                    "*",
                    "-",
                    "22",
                    "23",
                    "*",
                    "+",
                    "24",
                    "25",
                    "*",
                    "-",
                    "26",
                    "27",
                    "*",
                    "+",
                    "28",
                    "29",
                    "*",
                    "-",
                    "30",
                    "31",
                    "*",
                    "+"
                ]
            ],
            "outputs": [
                9,
                6,
                22,
                17,
                15,
                6,
                15,
                -12,
                -10,
                16,
                7,
                -1,
                11,
                0,
                16,
                -9,
                7,
                -2,
                13,
                -17
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <stack>\n\nint evalRPN(vector<string>& tokens) {\n    stack<int> s;\n    for (const string& token : tokens) {\n        if(token == \"+\" || token == \"-\" || token == \"*\" || token == \"/\") {\n            int b = s.top(); s.pop();\n            int a = s.top(); s.pop();\n            if (token == \"+\") s.push(a + b);\n            else if (token == \"-\") s.push(a - b);\n            else if (token == \"*\") s.push(a * b);\n            else s.push(a / b);\n        } else {\n            s.push(stoi(token));\n        }\n    }\n    return s.top();\n}\n",
            "java": "import java.util.Stack;\n\npublic int evalRPN(String[] tokens) {\n    Stack<Integer> stack = new Stack<>();\n    for (String token : tokens) {\n        if (token.equals(\"+\") || token.equals(\"-\") || token.equals(\"*\") || token.equals(\"/\")) {\n            int b = stack.pop();\n            int a = stack.pop();\n            if (token.equals(\"+\")) stack.push(a + b);\n            else if (token.equals(\"-\")) stack.push(a - b);\n            else if (token.equals(\"*\")) stack.push(a * b);\n            else stack.push(a / b);\n        } else {\n            stack.push(Integer.parseInt(token));\n        }\n    }\n    return stack.pop();\n}\n",
            "python": "def evalRPN(tokens):\n    stack = []\n    for token in tokens:\n        if token in {\"+\", \"-\", \"*\", \"/\"}:\n            b = stack.pop()\n            a = stack.pop()\n            if token == \"+\":\n                stack.append(a + b)\n            elif token == \"-\":\n                stack.append(a - b)\n            elif token == \"*\":\n                stack.append(a * b)\n            else:\n                stack.append(int(a / b))\n        else:\n            stack.append(int(token))\n    return stack[-1]\n",
            "javascript": "function evalRPN(tokens) {\n    const stack = [];\n    for (const token of tokens) {\n        if (token === \"+\" || token === \"-\" || token === \"*\" || token === \"/\") {\n            const b = stack.pop();\n            const a = stack.pop();\n            if (token === \"+\") stack.push(a + b);\n            else if (token === \"-\") stack.push(a - b);\n            else if (token === \"*\") stack.push(a * b);\n            else stack.push(Math.trunc(a / b));\n        } else {\n            stack.push(parseInt(token));\n        }\n    }\n    return stack.pop();\n}\n",
            "explanation": "The algorithm for evaluating the Reverse Polish Notation (RPN) expression is based on the stack data structure. Iterate through the given tokens array, and for each token:\n\n1. If the token is an operator (+, -, *, /), pop the top two elements from the stack, apply the operation, and push the result back onto the stack.\n2. If the token is a number, push it onto the stack.\n\nAfter the loop, the top element on the stack is the final result of the evaluated RPN expression.\n\nNote that in Python and JavaScript, we need to make sure the division result is truncated toward zero using `int(a / b)` and `Math.trunc(a / b)` respectively."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <stack>\n\nint evalRPN(vector<string>& tokens)  {\n    // Your code here\n}\n",
            "java": "import java.util.Stack;\n\npublic int evalRPN(String[] tokens)  {\n    // Your code here\n}\n",
            "python": "def evalRPN(tokens):\n    # Your code here\n\n",
            "javascript": "function evalRPN(tokens)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <stack>\n#include <iostream>\n\nint main() {\n    vector<string> tokens = $args;\n    int result = evalRPN(tokens);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    tokens = $args\n    result = evalRPN(tokens)\n    print(result)",
            "java": "",
            "javascript": ""
        },
        "Qid": "150"
    },
    {
        "_id": {
            "$oid": "661d781e949b33b6c4e2b0b1"
        },
        "title": "Reverse Words in a String",
        "description": "Given an input string `s`, reverse the order of the words. A word is defined as a sequence of non-space characters. The words in `s` will be separated by at least one space. Return a string of the words in reverse order concatenated by a single space. Note that `s` may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.",
        "example": "Example:\n\nInput: s = \"the sky is blue \"\nOutput: \"blue is sky the\"\n\nInput: s = \"  hello world   \"\nOutput: \"world hello\"\nExplanation: Your reversed string should not contain leading or trailing spaces.\n\nInput: s = \"a good   example \"\nOutput: \"example good a\"\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string.",
        "level": "Easy",
        "tags": [
            "string"
        ],
        "test_cases": {
            "inputs": [
                "\"the sky is blue \"",
                "\"  hello world   \"",
                "\"a good   example \"",
                "\"coding is fun\"",
                "\"  reverse words  \"",
                "\"  multiple   spaces  \"",
                "\"  single word  \"",
                "\"  \"",
                "\"a\"",
                "\"a b c d e f g h i j k l m n o p q r s t u v w x y z\"",
                "\"  a b c d e f g h i j k l m n o p q r s t u v w x y z  \""
            ],
            "outputs": [
                "\"blue is sky the\"",
                "\"world hello\"",
                "\"example good a\"",
                "\"fun is coding\"",
                "\"words reverse\"",
                "\"spaces multiple\"",
                "\"word single\"",
                "\"\"",
                "\"a\"",
                "\"z y x w v u t s r q p o n m l k j i h g f e d c b a\"",
                "\"z y x w v u t s r q p o n m l k j i h g f e d c b a\""
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n#include<iostream>\nstd::string reverseWords(std::string s) {\n    std::stringstream ss(s);\n    std::vector<std::string> words;\n    std::string temp;\n\n    while (ss >> temp) {\n        words.push_back(temp);\n    }\n\n    std::reverse(words.begin(), words.end());\n\n    std::string result;\n    for (size_t i = 0; i < words.size(); ++i) {\n        result += words[i] + (i < words.size() - 1 ? \" \" : \"\");\n    }\n\n    return result;\n}\n",
            "java": "public static String reverseWords(String s) {\n        String[] words = s.trim().split(\"\\\\s+\");\n        Collections.reverse(Arrays.asList(words));\n        return String.join(\" \", words);\n    }\n",
            "python": "def reverseWords(s):\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)\n",
            "javascript": "function reverseWords(s) {\n    return s.trim().split(/\\s+/).reverse().join(' ');\n}\n",
            "explanation": "The algorithm to reverse the order of the words is as follows:\n\n1. First, split the input string using spaces. In C++, we use `stringstream` and a while loop to read words, while in Java and JavaScript, we use `split` with regex to split the string based on one or more spaces. In Python, we can simply use `split()` since it splits on whitespace by default and ignores leading and trailing spaces.\n\n2. Reverse the array of words. In C++, we use the `reverse` function from the `algorithm` library. In Java, we can use `Collections.reverse()` method. In Python, we use list `reverse()` method. In JavaScript, we use the `reverse()` method on the array.\n\n3. Join the reversed array of words into a single string with a space delimiter. In C++, we concatenate words with a space but avoid adding an extra space at the end. In Java, we use `String.join()`, in Python, use `join()` on the delimiter string, and in JavaScript, use `join()` on the array."
        },
        "structure": {
            "c++": "#include <string>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nstd::string reverseWords(std::string s) {\n    // Your code here\n}\n",
            "java": "import java.util.*;\n\npublic String reverseWords(String s) {\n    // Your code here\n}\n",
            "python": "def reverseWords(s):\n    # Your code here\n\n",
            "javascript": "function reverseWords(s) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    std::string s = $args;\n    std::string result = reverseWords(s);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    String s = $args;\n    String result = reverseWords(s);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = reverseWords(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = reverseWords(s);\n    console.log(result);\n}\nmain();"
        },
        "Qid": "151",
        "languages verified": [
            "java",
            "c++",
            "javascript",
            "python"
        ]
    },
    {
        "_id": {
            "$oid": "661d7864949b33b6c4e2b0b2"
        },
        "title": "Largest Subarray Product",
        "description": "Given an integer array `nums`, find a subarray that has the largest product, and return the product. The task is to find the maximum product of a subarray in the given array.",
        "example": "Example:\n\nInput: nums = [2,3,-2,4]\nOutput: 6\nExplanation: The subarray [2,3] has the largest product 6.\n\nInput: nums = [-2,0,-1]\nOutput: 0\nExplanation: The result cannot be 2, because the subarray [-2,-1] is not a valid subarray.",
        "level": "Medium",
        "tags": [
            "array",
            "subarray",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    3,
                    -2,
                    4
                ],
                [
                    -2,
                    0,
                    -1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1,
                    -1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1,
                    -1,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0,
                    1,
                    -1,
                    0
                ]
            ],
            "outputs": [
                6,
                0,
                120,
                120,
                0,
                120,
                120,
                120,
                120,
                120,
                120,
                120,
                120,
                120,
                120,
                120,
                120,
                120,
                120,
                120
            ]
        },
        "sample_code": {
            "c++": "int maxProduct(vector<int>& nums) {\n    int max_so_far = nums[0];\n    int min_so_far = nums[0];\n    int result = nums[0];\n    \n    for (int i = 1; i < nums.size(); i++) {\n        if (nums[i] < 0)\n            swap(max_so_far, min_so_far);\n        \n        max_so_far = max(nums[i], max_so_far * nums[i]);\n        min_so_far = min(nums[i], min_so_far * nums[i]);\n        result = max(result, max_so_far);\n    }\n    return result;\n}\n\n",
            "java": "public int maxProduct(int[] nums) {\n    int max_so_far = nums[0];\n    int min_so_far = nums[0];\n    int result = nums[0];\n    \n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] < 0) {\n            int temp = max_so_far;\n            max_so_far = min_so_far;\n            min_so_far = temp;\n        }\n        \n        max_so_far = Math.max(nums[i], max_so_far * nums[i]);\n        min_so_far = Math.min(nums[i], min_so_far * nums[i]);\n        result = Math.max(result, max_so_far);\n    }\n    return result;\n}\n\n",
            "python": "def maxProduct(nums):\n    max_so_far = min_so_far = result = nums[0]\n    \n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_so_far, min_so_far = min_so_far, max_so_far\n        \n        max_so_far = max(nums[i], max_so_far * nums[i])\n        min_so_far = min(nums[i], min_so_far * nums[i])\n        result = max(result, max_so_far)\n    \n    return result\n\n",
            "javascript": "function maxProduct(nums) {\n    let max_so_far = nums[0];\n    let min_so_far = nums[0];\n    let result = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] < 0) {\n            [max_so_far, min_so_far] = [min_so_far, max_so_far];\n        }\n        \n        max_so_far = Math.max(nums[i], max_so_far * nums[i]);\n        min_so_far = Math.min(nums[i], min_so_far * nums[i]);\n        result = Math.max(result, max_so_far);\n    }\n    return result;\n}\n\n",
            "explanation": "The algorithm maintains the maximum and minimum product subarray ending at the current position. For each position, it checks if the current element is negative. If it is, it swaps the maximum and minimum product subarray, since multiplying by a negative number reverses their order.\n\nAfter the swap, it calculates the maximum and minimum product subarray ending at the current position by considering the current element and the product of the maximum and minimum product subarray ending at the previous position, multiplied by the current element. It updates the result as the maximum of the result and the maximum product subarray ending at the current position.\n\nThis process continues for all elements of the array, and the result is returned."
        },
        "structure": {
            "c++": "int maxProduct(vector<int>& nums)  {\n    // Your code here\n}\n\n",
            "java": "public int maxProduct(int[] nums)  {\n    // Your code here\n}\n\n",
            "python": "def maxProduct(nums):\n    # Your code here\n\n",
            "javascript": "function maxProduct(nums)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int maxProduct(vector<int>& nums) {\n    int max_so_far = nums[0];\n    int min_so_far = nums[0];\n    int result = nums[0];\n    \n    for (int i = 1; i < nums.size(); i++) {\n        if (nums[i] < 0)\n            swap(max_so_far, min_so_far);\n        \n        max_so_far = max(nums[i], max_so_far * nums[i]);\n        min_so_far = min(nums[i], min_so_far * nums[i]);\n        result = max(result, max_so_far);\n    }\n    return result;\n}",
            "java": "public int maxProduct(int[] nums) {\n    int max_so_far = nums[0];\n    int min_so_far = nums[0];\n    int result = nums[0];\n    \n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] < 0) {\n            int temp = max_so_far;\n            max_so_far = min_so_far;\n            min_so_far = temp;\n        }\n        \n        max_so_far = Math.max(nums[i], max_so_far * nums[i]);\n        min_so_far = Math.min(nums[i], min_so_far * nums[i]);\n        result = Math.max(result, max_so_far);\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = maxProduct(nums)\n    print(result)",
            "javascript": ""
        },
        "Qid": "152"
    },
    {
        "_id": {
            "$oid": "661d7875949b33b6c4e2b0b3"
        },
        "title": "Minimum Element in Rotated Sorted Array",
        "description": "Given a sorted rotated array `nums` of unique elements, find the minimum element in the array. The array is rotated between `1` and `n` times. Implement an algorithm that runs in `O(log n)` time complexity.",
        "example": "Example:\n\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.",
        "level": "Medium",
        "tags": [
            "Array",
            "Binary Search"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    4,
                    5,
                    1,
                    2
                ],
                [
                    4,
                    5,
                    6,
                    7,
                    0,
                    1,
                    2
                ],
                [
                    11,
                    13,
                    15,
                    17
                ],
                [
                    1
                ],
                [
                    2,
                    1
                ],
                [
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4
                ],
                [
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3
                ],
                [
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4
                ],
                [
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1
                ],
                [
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6
                ],
                [
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2
                ],
                [
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1
                ]
            ],
            "outputs": [
                1,
                0,
                11,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1
            ]
        },
        "sample_code": {
            "c++": "```c++\nint findMin(vector<int>& nums) {\n    int left = 0, right = nums.size() - 1;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n}\n",
            "java": "public int findMin(int[] nums) {\n    int left = 0, right = nums.length - 1;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n}\n",
            "python": "def find_min(nums):\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        mid = left + (right - left) // 2\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n    return nums[left]\n",
            "javascript": "function findMin(nums) {\n    let left = 0, right = nums.length - 1;\n\n    while (left < right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n}\n",
            "explanation": "The algorithm uses a binary search approach to find the minimum element in the sorted rotated array. Initially, pointers `left` and `right` are set to the start and end of the array. The midpoint `mid` is calculated as the average of `left` and `right`. The main idea is that whenever `nums[mid]` is greater than `nums[right]`, the minimum element must be in the right half of the array; otherwise, we search in the left half. This ensures that the algorithm runs in O(log n) time, as the search space is reduced by half each iteration. When `left` and `right` meet, the minimum element is found at `left`."
        },
        "structure": {
            "c++": "```c++\nint findMin(vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "public int findMin(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def find_min(nums):\n    # Your code here\n\n",
            "javascript": "function findMin(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> nums = $args;\n    int result = findMin(nums);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int findMin(int[] nums) {\n    int left = 0, right = nums.length - 1;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = find_min(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = findMin(nums);\n    console.log(result);\n}"
        },
        "Qid": "153"
    },
    {
        "_id": {
            "$oid": "661d7889949b33b6c4e2b0b4"
        },
        "title": "Longest Substring with At Most Two Distinct Characters",
        "description": "Given a string `s`, find the length of the longest substring that contains at most two distinct characters.",
        "example": "Example:\n\nInput: s = \"eceba\"\nOutput: 3\nExplanation: The longest substring with at most two distinct characters is \"ece\" with a length of 3.",
        "level": "Medium",
        "tags": [
            "string",
            "sliding window",
            "hashmap"
        ],
        "test_cases": {
            "inputs": [
                "\"eceba\"",
                "\"ccaabbb\"",
                "\"abcabcabc\"",
                "\"aabbbccdd\"",
                "\"aaaaaa\"",
                "\"abababab\"",
                "\"\"",
                "\"a\"",
                "\"aa\"",
                "\"aaa\"",
                "\"aaaa\"",
                "\"aaaaa\"",
                "\"aaaaaa\"",
                "\"aaaaaaa\"",
                "\"aaaaaaaa\"",
                "\"aaaaaaaaa\"",
                "\"aaaaaaaaaa\"",
                "\"aaaaaaaaaaa\"",
                "\"aaaaaaaaaaaa\"",
                "\"aaaaaaaaaaaaa\"",
                "\"aaaaaaaaaaaaaa\""
            ],
            "outputs": [
                "3",
                "5",
                "9",
                "6",
                "6",
                "8",
                "0",
                "1",
                "2",
                "3",
                "4",
                "5",
                "6",
                "7",
                "8",
                "9",
                "10",
                "11",
                "12",
                "13"
            ]
        },
        "sample_code": {
            "c++": "#include <iostream>\n#include <unordered_map>\n#include <string>\n#include <algorithm> // for std::max\n\nint lengthOfLongestSubstringTwoDistinct(const std::string& s) {\n    int l = 0, r = 0, max_len = 0;\n    std::unordered_map<char, int> char_count;\n\n    while (r < s.length()) {\n        // Add the current character to the count\n        char_count[s[r]]++;\n\n        // Check if there are more than two distinct characters\n        while (char_count.size() > 2) {\n            char_count[s[l]]--;\n            if (char_count[s[l]] == 0) {\n                char_count.erase(s[l]);\n            }\n            l++;\n        }\n\n        // Calculate the length of the current window and update max_len\n        max_len = std::max(max_len, r - l + 1);\n        r++;\n    }\n\n    return max_len;\n}\n\n",
            "java": "public static int lengthOfLongestSubstringTwoDistinct(String s) {\n    int l = 0, r = 0, max_len = 0, cur_len = 0;\n    HashMap<Character, Integer> char_count = new HashMap<>();\n\n    while (r < s.length()) {\n        char_count.put(s.charAt(r), char_count.getOrDefault(s.charAt(r), 0) + 1);\n        if (char_count.size() <= 2) {\n            cur_len++;\n        } else {\n            while (char_count.size() > 2 && l <= r) {\n                char_count.put(s.charAt(l), char_count.get(s.charAt(l)) - 1);\n                if (char_count.get(s.charAt(l)) == 0) {\n                    char_count.remove(s.charAt(l));\n                }\n                l++;\n                cur_len--;\n            }\n            cur_len++;\n        }\n        max_len = Math.max(max_len, cur_len);\n        r++;\n    }\n    return max_len;\n}\n",
            "python": "def lengthOfLongestSubstringTwoDistinct(s: str) -> int:\n    l, r, max_len, cur_len = 0, 0, 0, 0\n    char_count = {}\n\n    while r < len(s):\n        if s[r] in char_count:\n            char_count[s[r]] += 1\n        else:\n            char_count[s[r]] = 1\n        if len(char_count) <= 2:\n            cur_len += 1\n        else:\n            while len(char_count) > 2 and l <= r:\n                char_count[s[l]] -= 1\n                if char_count[s[l]] == 0:\n                    del char_count[s[l]]\n                l += 1\n                cur_len -= 1\n            cur_len += 1\n        max_len = max(max_len, cur_len)\n        r += 1\n    return max_len\n",
            "javascript": "function lengthOfLongestSubstringTwoDistinct(s) {\n    let l = 0, r = 0, max_len = 0, cur_len = 0;\n    const char_count = new Map();\n\n    while (r < s.length) {\n        char_count.set(s[r], (char_count.get(s[r]) || 0) + 1);\n        if (char_count.size <= 2) {\n            cur_len++;\n        } else {\n            while (char_count.size > 2 && l <= r) {\n                char_count.set(s[l], char_count.get(s[l]) - 1);\n                if (char_count.get(s[l]) === 0) {\n                    char_count.delete(s[l]);\n                }\n                l++;\n                cur_len--;\n            }\n            cur_len++;\n        }\n        max_len = Math.max(max_len, cur_len);\n        r++;\n    }\n    return max_len;\n}\n",
            "explanation": "The algorithm implements a sliding window approach. We maintain two pointers `l` and `r` representing the left and right ends of the current substring. We also maintain a hash map `char_count` to store the counts of distinct characters in the current substring.\n\nWe iterate through the string with pointer `r`. For each character, we increment its count in the hash map. If we have two or fewer distinct characters in the current substring, we update the current length `cur_len`. If we have more than two distinct characters, we move the pointer `l` to the right, decrementing the count of the character at `l` in the hash map, and removing it if its count becomes zero. We update `cur_len` accordingly in the process.\n\nAt each step, we update the maximum length `max_len` with the maximum of `max_len` and `cur_len`. We return `max_len` at the end."
        },
        "structure": {
            "c++": "int lengthOfLongestSubstringTwoDistinct(string s) {\n    // Your code here\n}\n",
            "java": "public int lengthOfLongestSubstringTwoDistinct(String s) {\n    // Your code here\n}\n",
            "python": "def lengthOfLongestSubstringTwoDistinct(s: str) -> int:\n    # Your code here\n\n",
            "javascript": "function lengthOfLongestSubstringTwoDistinct(s) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main(){\n    std::string s =  $args;\n    int result = lengthOfLongestSubstringTwoDistinct(s);\n    std::cout<<result<<std::endl;\n}",
            "java": "public static  void main(String[] args){\n    String s = $args;\n    int result = lengthOfLongestSubstringTwoDistinct(s);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = lengthOfLongestSubstringTwoDistinct(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = lengthOfLongestSubstringTwoDistinct(s);\n    console.log(result);\n}\nmain();"
        },
        "Qid": "159",
        "languages verified": [
            "java",
            "c++",
            "javascript",
            "python"
        ]
    },
    {
        "_id": {
            "$oid": "661d798f949b33b6c4e2b0b5"
        },
        "title": "One Edit Distance",
        "description": "Given two strings `s` and `t`, return `true` if they are both one edit distance apart, otherwise return `false`. A string `s` is said to be one distance apart from a string `t` if you can:\n\n- Insert **exactly one** character into `s` to get `t`.\n- Delete **exactly one** character from `s` to get `t`.\n- Replace **exactly one** character of `s` with **a different character** to get `t`.",
        "example": "Example:\n\nInput: s = \"ab\", t = \"acb\"\nOutput: true\nExplanation: We can insert 'c' into s to get t.",
        "level": "Easy",
        "tags": [
            "string",
            "editing"
        ],
        "test_cases": {
            "inputs": [
                [
                    "ab",
                    "acb"
                ],
                [
                    "",
                    ""
                ],
                [
                    "abc",
                    "ab"
                ],
                [
                    "abc",
                    "abcd"
                ],
                [
                    "abc",
                    "abdc"
                ],
                [
                    "abc",
                    "ac"
                ],
                [
                    "abc",
                    "bc"
                ],
                [
                    "abc",
                    "abec"
                ],
                [
                    "abc",
                    "abf"
                ],
                [
                    "abc",
                    "abg"
                ],
                [
                    "abc",
                    "abhc"
                ],
                [
                    "abc",
                    "abij"
                ],
                [
                    "abc",
                    "abjk"
                ],
                [
                    "abc",
                    "abkl"
                ],
                [
                    "abc",
                    "ablm"
                ],
                [
                    "abc",
                    "abmn"
                ],
                [
                    "abc",
                    "abno"
                ],
                [
                    "abc",
                    "abop"
                ],
                [
                    "abc",
                    "abpq"
                ],
                [
                    "abc",
                    "abqr"
                ]
            ],
            "outputs": [
                true,
                false,
                false,
                false,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "bool isOneEditDistance(string s, string t) {\n    int m = s.length(), n = t.length();\n    if (m > n) {\n        return isOneEditDistance(t, s);\n    }\n    if (n - m > 1) {\n        return false;\n    }\n    bool flag = false;\n    for (int i = 0; i < m; ++i) {\n      if (s[i] != t[i]) {\n          if (m < n) {\n              return s.substr(i) == t.substr(i + 1);\n          } else {\n              return s.substr(i + 1) == t.substr(i + 1);\n          }\n      }\n    }\n    return m + 1 == n;\n}\n",
            "java": "public boolean isOneEditDistance(String s, String t) {\n    int m = s.length();\n    int n = t.length();\n    if (m > n) {\n        return isOneEditDistance(t, s);\n    }\n    if (n - m > 1) {\n        return false;\n    }\n    for (int i = 0; i < m; ++i) {\n        if (s.charAt(i) != t.charAt(i)) {\n            if (m < n) {\n                return s.substring(i).equals(t.substring(i + 1));\n            } else {\n                return s.substring(i + 1).equals(t.substring(i + 1));\n            }\n        }\n    }\n    return m + 1 == n;\n}\n",
            "python": "def isOneEditDistance(s: str, t: str) -> bool:\n    m, n = len(s), len(t)\n    if m > n:\n        return isOneEditDistance(t, s)\n    if n - m > 1:\n        return False\n    for i in range(m):\n        if s[i] != t[i]:\n            return s[i + (m < n):] == t[i + 1:]\n    return m + 1 == n\n\n",
            "javascript": "function isOneEditDistance(s, t) {\n    let m = s.length, n = t.length;\n    if (m > n) {\n        return isOneEditDistance(t, s);\n    }\n    if (n - m > 1) {\n        return false;\n    }\n    for (let i = 0; i < m; ++i) {\n        if (s[i] !== t[i]) {\n            if (m < n) {\n                return s.slice(i) === t.slice(i + 1);\n            } else {\n                return s.slice(i + 1) === t.slice(i + 1);\n            }\n        }\n    }\n    return m + 1 === n;\n}\n\n",
            "explanation": "The algorithm first checks if the length of string `s` is greater than the length of string `t`. If true, it swaps the two strings and continues the checks. Next, the algorithm checks if the length difference between the strings is greater than 1, returning `false` if so since it's not possible to meet the one edit distance criteria in that case.\n\nThe algorithm iterates through the characters of the two strings. If it encounters a mismatched character it checks if the insertion or deletion of a character can yield the other string, and if not, it checks if the replacement of the mismatched character in string `s` can yield string `t`. If it iterates through both strings without finding a mismatch, it returns `true` if the length difference of the strings is 1 to ensure only one character has been inserted. Otherwise, it returns `false`."
        },
        "structure": {
            "c++": "bool isOneEditDistance(string s, string t)  {\n    // Your code here\n}\n",
            "java": "public boolean isOneEditDistance(String s, String t)  {\n    // Your code here\n}\n",
            "python": "def isOneEditDistance(s: str, t: str) -> bool:\n    # Your code here\n\n",
            "javascript": "function isOneEditDistance(s, t)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "bool isOneEditDistance(string s, string t) {\n    int m = s.length(), n = t.length();\n    if (m > n) {\n        return isOneEditDistance(t, s);\n    }\n    if (n - m > 1) {\n        return false;\n    }\n    bool flag = false;\n    for (int i = 0; i < m; ++i) {\n      if (s[i] != t[i]) {\n          if (m < n) {\n              return s.substr(i) == t.substr(i + 1);\n          } else {\n              return s.substr(i + 1) == t.substr(i + 1);\n          }\n      }\n    }\n    return m + 1 == n;\n}\n\nint main() {\n    string s = $args;\n    string t = $args;\n    bool result = isOneEditDistance(s, t);\n    cout << boolalpha << result << endl;\n    return 0;\n}",
            "java": "public boolean isOneEditDistance(String s, String t) {\n    int m = s.length();\n    int n = t.length();\n    if (m > n) {\n        return isOneEditDistance(t, s);\n    }\n    if (n - m > 1) {\n        return false;\n    }\n    for (int i = 0; i < m; ++i) {\n        if (s.charAt(i) != t.charAt(i)) {\n            if (m < n) {\n                return s.substring(i).equals(t.substring(i + 1));\n            } else {\n                return s.substring(i + 1).equals(t.substring(i + 1));\n            }\n        }\n    }\n    return m + 1 == n;\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args[0]\n    t = $args[1]\n    result = isOneEditDistance(s, t)\n    print(result)",
            "javascript": "function main() {\n    const s = $args[0];\n    const t = $args[1];\n    const result = isOneEditDistance(s, t);\n    console.log(result);\n}"
        },
        "Qid": "161"
    },
    {
        "_id": {
            "$oid": "661d79b1949b33b6c4e2b0b6"
        },
        "title": "Peak Element",
        "description": "A peak element is an element that is strictly greater than its neighbors. Given a 0-indexed integer array nums, find a peak element and return its index. If the array contains multiple peaks, return the index to any of the peaks. You may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array. Write an algorithm that runs in O(log n) time.",
        "example": "Example 1:\n\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.\n\nExample 2:\n\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.",
        "level": "Medium",
        "tags": [
            "Array",
            "Binary Search"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3,
                    1
                ],
                [
                    1,
                    2,
                    1,
                    3,
                    5,
                    6,
                    4
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1
                ],
                [
                    1,
                    3,
                    2,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    10
                ]
            ],
            "outputs": [
                2,
                5,
                4,
                0,
                0,
                1,
                8,
                0,
                8,
                9
            ]
        },
        "sample_code": {
            "c++": "int findPeakElement(vector<int>& nums) {\n    int left = 0, right = nums.size() - 1;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < nums[mid + 1]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n",
            "java": "public int findPeakElement(int[] nums) {\n    int left = 0, right = nums.length - 1;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < nums[mid + 1]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n",
            "python": "def findPeakElement(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = left + (right - left) // 2\n        if nums[mid] < nums[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n",
            "javascript": "function findPeakElement(nums) {\n    let left = 0, right = nums.length - 1;\n    while (left < right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] < nums[mid + 1]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n",
            "explanation": "For this problem, we can use the binary search. Instead of comparing the mid-element to the target value, we compare it with its neighbors. Based on the comparison, we adjust the left and right pointers accordingly:\n\n1. Initialize left and right pointer, `left = 0` and `right = nums.length - 1`.\n2. While `left < right`, do the following:\n   a. Calculate the mid index, `mid = left + (right - left) // 2`.\n   b. If `nums[mid] < nums[mid + 1]`, move the left pointer to `mid + 1`.\n   c. Else, move the right pointer to the `mid`.\n3. When `left >= right`, the peak index is found, so return `left`.\n\nSince we use a binary search, the algorithm runs in O(log n) time."
        },
        "structure": {
            "c++": "int findPeakElement(vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "public int findPeakElement(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def findPeakElement(nums):\n    # Your code here\n\n",
            "javascript": "function findPeakElement(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> nums = $args;\n    int result = findPeakElement(nums);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \\\"__main__\\\":\\n    nums = $args\\n    result = findPeakElement(nums)\\n    print(result)",
            "java": "",
            "javascript": ""
        },
        "Qid": "162"
    },
    {
        "_id": {
            "$oid": "661d7a43949b33b6c4e2b0b7"
        },
        "title": "Maximum Successive Difference",
        "description": "Given an integer array `nums`, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0. You must write an algorithm that runs in linear time and uses linear extra space.",
        "example": "Example:\n\nInput: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    6,
                    9,
                    1
                ],
                [
                    10
                ],
                [
                    5,
                    5,
                    5,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    100,
                    200,
                    300,
                    400,
                    500
                ],
                [
                    1,
                    100,
                    1000,
                    10000
                ],
                [
                    5,
                    10,
                    15,
                    20,
                    25,
                    30,
                    35,
                    40,
                    45,
                    50
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10,
                    12,
                    14,
                    16,
                    18,
                    20
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9,
                    11,
                    13,
                    15,
                    17,
                    19
                ]
            ],
            "outputs": [
                3,
                0,
                0,
                1,
                1,
                100,
                900,
                5,
                2,
                2
            ]
        },
        "sample_code": {
            "c++": "int maximumGap(vector<int>& nums) {\n    if (nums.size() < 2) return 0;\n    \n    int min_val = *min_element(nums.begin(), nums.end());\n    int max_val = *max_element(nums.begin(), nums.end());\n    int len = nums.size();\n    int bucket_size = max(1, (max_val - min_val) / (len - 1));\n    int bucket_num = (max_val - min_val) / bucket_size + 1;\n    vector<pair<int, int>> buckets(bucket_num, {INT_MAX, INT_MIN});\n\n    for (int num : nums) {\n        int idx = (num - min_val) / bucket_size;\n        buckets[idx].first = min(buckets[idx].first, num);\n        buckets[idx].second = max(buckets[idx].second, num);\n    }\n\n    int max_gap = 0, prev_max = min_val;\n    for (auto& bucket : buckets) {\n        if (bucket.first == INT_MAX) continue;\n        max_gap = max(max_gap, bucket.first - prev_max);\n        prev_max = bucket.second;\n    }\n    return max_gap;\n}\n",
            "java": "public int maximumGap(int[] nums) {\n    if (nums.length < 2) return 0;\n\n    int min_val = Arrays.stream(nums).min().getAsInt();\n    int max_val = Arrays.stream(nums).max().getAsInt();\n    int len = nums.length;\n    int bucket_size = Math.max(1, (max_val - min_val) / (len - 1));\n    int bucket_num = (max_val - min_val) / bucket_size + 1;\n    int[][] buckets = new int[bucket_num][2];\n    for (int i = 0; i < bucket_num; i++) {\n        buckets[i] = new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE};\n    }\n\n    for (int num : nums) {\n        int idx = (num - min_val) / bucket_size;\n        buckets[idx][0] = Math.min(buckets[idx][0], num);\n        buckets[idx][1] = Math.max(buckets[idx][1], num);\n    }\n\n    int max_gap = 0, prev_max = min_val;\n    for (int[] bucket : buckets) {\n        if (bucket[0] == Integer.MAX_VALUE) continue;\n        max_gap = Math.max(max_gap, bucket[0] - prev_max);\n        prev_max = bucket[1];\n    }\n    return max_gap;\n}\n",
            "python": "def maximumGap(nums):\n    if len(nums) < 2:\n        return 0\n\n    min_val = min(nums)\n    max_val = max(nums)\n    length = len(nums)\n    bucket_size = max(1, (max_val - min_val) // (length - 1))\n    bucket_num = (max_val - min_val) // bucket_size + 1\n    buckets = [[float(\"inf\"), float(\"-inf\")] for _ in range(bucket_num)]\n\n    for num in nums:\n        idx = (num - min_val) // bucket_size\n        buckets[idx][0] = min(buckets[idx][0], num)\n        buckets[idx][1] = max(buckets[idx][1], num)\n\n    max_gap = 0\n    prev_max = min_val\n    for bucket in buckets:\n        if bucket[0] == float(\"inf\"):\n            continue\n        max_gap = max(max_gap, bucket[0] - prev_max)\n        prev_max = bucket[1]\n    return max_gap\n",
            "javascript": "function maximumGap(nums) {\n    if (nums.length < 2) return 0;\n\n    let min_val = Math.min(...nums);\n    let max_val = Math.max(...nums);\n    let len = nums.length;\n    let bucket_size = Math.max(1, Math.floor((max_val - min_val) / (len - 1)));\n    let bucket_num = Math.floor((max_val - min_val) / bucket_size) + 1;\n    let buckets = Array.from({ length: bucket_num }, () => [Infinity, -Infinity]);\n\n    for (let num of nums) {\n        let idx = Math.floor((num - min_val) / bucket_size);\n        buckets[idx][0] = Math.min(buckets[idx][0], num);\n        buckets[idx][1] = Math.max(buckets[idx][1], num);\n    }\n\n    let max_gap = 0, prev_max = min_val;\n    for (let bucket of buckets) {\n        if (bucket[0] === Infinity) continue;\n        max_gap = Math.max(max_gap, bucket[0] - prev_max);\n        prev_max = bucket[1];\n    }\n    return max_gap;\n}\n",
            "explanation": "The algorithm first finds the minimum and maximum values of the input array `nums`. Then it calculates the ideal bucket size by dividing the difference between the maximum and minimum values by the length of the array minus one. The algorithm then initializes an array of buckets, where each bucket contains the minimum and maximum values of its elements.\n\nNext, the algorithm updates the minimum and maximum values for each bucket appropriately by iterating through the input array. Finally, the algorithm calculates the maximum gap by finding the difference between the minimum value of the current bucket and the maximum value of the previous non-empty bucket, and updating the maximum gap value accordingly.\n\nThis algorithm runs in linear time, because it iterates through the input array once to fill the buckets, and then it iterates through the buckets once to compute the maximum gap. It also uses linear extra space, as the number of buckets is proportional to the length of the input array."
        },
        "structure": {
            "c++": "int maximumGap(vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "public int maximumGap(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def maximumGap(nums):\n    # Your code here\n\n",
            "javascript": "function maximumGap(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int maximumGap(vector<int>& nums) {\n    if (nums.size() < 2) return 0;\n    \n    int min_val = *min_element(nums.begin(), nums.end());\n    int max_val = *max_element(nums.begin(), nums.end());\n    int len = nums.size();\n    int bucket_size = max(1, (max_val - min_val) / (len - 1));\n    int bucket_num = (max_val - min_val) / bucket_size + 1;\n    vector<pair<int, int>> buckets(bucket_num, {INT_MAX, INT_MIN});\n\n    for (int num : nums) {\n        int idx = (num - min_val) / bucket_size;\n        buckets[idx].first = min(buckets[idx].first, num);\n        buckets[idx].second = max(buckets[idx].second, num);\n    }\n\n    int max_gap = 0, prev_max = min_val;\n    for (auto& bucket : buckets) {\n        if (bucket.first == INT_MAX) continue;\n        max_gap = max(max_gap, bucket.first - prev_max);\n        prev_max = bucket.second;\n    }\n    return max_gap;\n}",
            "java": "public int maximumGap(int[] nums) {\n    if (nums.length < 2) return 0;\n\n    int min_val = Arrays.stream(nums).min().getAsInt();\n    int max_val = Arrays.stream(nums).max().getAsInt();\n    int len = nums.length;\n    int bucket_size = Math.max(1, (max_val - min_val) / (len - 1));\n    int bucket_num = (max_val - min_val) / bucket_size + 1;\n    int[][] buckets = new int[bucket_num][2];\n    for (int i = 0; i < bucket_num; i++) {\n        buckets[i] = new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE};\n    }\n\n    for (int num : nums) {\n        int idx = (num - min_val) / bucket_size;\n        buckets[idx][0] = Math.min(buckets[idx][0], num);\n        buckets[idx][1] = Math.max(buckets[idx][1], num);\n    }\n\n    int max_gap = 0, prev_max = min_val;\n    for (int[] bucket : buckets) {\n        if (bucket[0] == Integer.MAX_VALUE) continue;\n        max_gap = Math.max(max_gap, bucket[0] - prev_max);\n        prev_max = bucket[1];\n    }\n    return max_gap;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = maximumGap(nums)\n    print(result)",
            "javascript": "function maximumGap(nums) {\n    if (nums.length < 2) return 0;\n\n    let min_val = Math.min(...nums);\n    let max_val = Math.max(...nums);\n    let len = nums.length;\n    let bucket_size = Math.max(1, Math.floor((max_val - min_val) / (len - 1)));\n    let bucket_num = Math.floor((max_val - min_val) / bucket_size) + 1;\n    let buckets = Array.from({ length: bucket_num }, () => [Infinity, -Infinity]);\n\n    for (let num of nums) {\n        let idx = Math.floor((num - min_val) / bucket_size);\n        buckets[idx][0] = Math.min(buckets[idx][0], num);\n        buckets[idx][1] = Math.max(buckets[idx][1], num);\n    }\n\n    let max_gap = 0, prev_max = min_val;\n    for (let bucket of buckets) {\n        if (bucket[0] === Infinity) continue;\n        max_gap = Math.max(max_gap, bucket[0] - prev_max);\n        prev_max = bucket[1];\n    }\n    return max_gap;\n}"
        },
        "Qid": "164"
    },
    {
        "_id": {
            "$oid": "661d7ba6949b33b6c4e2b0b8"
        },
        "title": "Fraction to String",
        "description": "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. If multiple answers are possible, return any of them. It is guaranteed that the length of the answer string is less than 104 for all the given inputs.",
        "example": "Example:\n\nInput: numerator = 1, denominator = 2\nOutput: \"0.5\"\n\nInput: numerator = 2, denominator = 1\nOutput: \"2\"\n\nInput: numerator = 4, denominator = 333\nOutput: \"0.(012)\"",
        "level": "Medium",
        "tags": [
            "Math",
            "String"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2
                ],
                [
                    2,
                    1
                ],
                [
                    4,
                    333
                ],
                [
                    0,
                    1
                ],
                [
                    1,
                    3
                ],
                [
                    5,
                    2
                ],
                [
                    10,
                    7
                ],
                [
                    22,
                    7
                ],
                [
                    1,
                    9
                ],
                [
                    3,
                    8
                ],
                [
                    7,
                    11
                ],
                [
                    17,
                    19
                ],
                [
                    123,
                    456
                ],
                [
                    987,
                    654
                ],
                [
                    1000,
                    3
                ],
                [
                    9999,
                    10000
                ],
                [
                    123456,
                    789
                ],
                [
                    987654,
                    321
                ],
                [
                    111111,
                    999999
                ]
            ],
            "outputs": [
                "0.5",
                "2",
                "0.(012)",
                "0",
                "0.(3)",
                "2.5",
                "1.(428571)",
                "3.(142857)",
                "0.(1)",
                "0.375",
                "0.(63)",
                "0.(894736842105263157)",
                "0.(270833333333333333)",
                "0.(270833333333333333)",
                "333.(333333333333333333)",
                "3333.(333333333333333333)",
                "156.(25)",
                "307.(692307692307692307)",
                "0.(111111)",
                "0.(111111)"
            ]
        },
        "sample_code": {
            "c++": "#include <unordered_map>\nstd::string fractionToDecimal(int numerator, int denominator) {\n    if (numerator == 0) return \"0\";\n    std::string res;\n    if ((numerator > 0) ^ (denominator > 0)) res += '-';\n    long num = std::abs((long)numerator), den = std::abs((long)denominator);\n    res += std::to_string(num / den);\n    num %= den;\n    if (num == 0) return res;\n    res += '.';\n    std::unordered_map<int, int> map;\n    while (num) {\n        if (map.find(num) != map.end()) {\n            res.insert(map[num], \"(\");\n            res += \")\";\n            break;\n        }\n        map[num] = res.size();\n        num *= 10;\n        res += std::to_string(num / den);\n        num %= den;\n    }\n    return res;\n}\n\n",
            "java": "import java.util.HashMap;\n\npublic String fractionToDecimal(int numerator, int denominator) {\n    if (numerator == 0) return \"0\";\n    StringBuilder res = new StringBuilder();\n    if ((numerator > 0) ^ (denominator > 0)) res.append('-');\n    long num = Math.abs((long)numerator), den = Math.abs((long)denominator);\n    res.append(num / den);\n    num %= den;\n    if (num == 0) return res.toString();\n    res.append('.');\n    HashMap<Long, Integer> map = new HashMap<>();\n    while (num != 0) {\n        if (map.containsKey(num)) {\n            res.insert(map.get(num), \"(\");\n            res.append(\")\");\n            break;\n        }\n        map.put(num, res.length());\n        num *= 10;\n        res.append(num / den);\n        num %= den;\n    }\n    return res.toString();\n}\n\n",
            "python": "def fraction_to_string(numerator, denominator):\n    if numerator == 0:\n        return \"0\"\n    res = []\n    if (numerator > 0) ^ (denominator > 0):\n        res.append(\"-\")\n    num = abs(numerator)\n    den = abs(denominator)\n    res.append(str(num // den))\n    num %= den\n    if num == 0:\n        return \"\".join(res)\n    res.append(\".\")\n    map = {}\n    while num:\n        if num in map:\n            res.insert(map[num], \"(\")\n            res.append(\")\")\n            break\n        map[num] = len(res)\n        num *= 10\n        res.append(str(num // den))\n        num %= den\n    return \"\".join(res)\n\n",
            "javascript": "function fractionToDecimal(numerator, denominator) {\n    if (numerator === 0) return \"0\";\n    let res = \"\";\n    if ((numerator > 0) ^ (denominator > 0)) res += '-';\n    let num = Math.abs(numerator), den = Math.abs(denominator);\n    res += Math.floor(num / den);\n    num %= den;\n    if (num === 0) return res;\n    res += '.';\n    let map = new Map();\n    while (num) {\n        if (map.has(num)) {\n            res = res.slice(0, map.get(num)) + \"(\" + res.slice(map.get(num)) + \")\";\n            break;\n        }\n        map.set(num, res.length);\n        num *= 10;\n        res += Math.floor(num / den);\n        num %= den;\n    }\n    return res;\n}\n\n",
            "explanation": "The algorithm follows the steps:\n1. If numerator is 0, the result is 0.\n2. Add the sign to the result string if necessary, and make both numerator and denominator positive.\n3. Calculate integer part using integer division and add it to the result string.\n4. Calculate the remainder of the division.\n5. If the remainder is 0, return the result. Otherwise, add a dot to the result string.\n6. Use a hash map to store remainder positions. Iterate while the remainder is not 0.\n   - If the remainder is in the map, add parentheses around the repeating part and break the loop.\n   - Update the hash map with the current remainder and its position in the result string.\n   - Multiply the remainder by 10, add the new integer part to the result string, and update the remainder.\n7. Return the result string."
        },
        "structure": {
            "c++": "#include <unordered_map>\nstd::string fractionToDecimal(int numerator, int denominator)  {\n    // Your code here\n}\n\n",
            "java": "import java.util.HashMap;\n\npublic String fractionToDecimal(int numerator, int denominator)  {\n    // Your code here\n}\n\n",
            "python": "def fraction_to_string(numerator, denominator):\n    # Your code here\n\n",
            "javascript": "function fractionToDecimal(numerator, denominator)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <unordered_map>\nstd::string fractionToDecimal(int numerator, int denominator) {\n    if (numerator == 0) return \"0\";\n    std::string res;\n    if ((numerator > 0) ^ (denominator > 0)) res += '-';\n    long num = std::abs((long)numerator), den = std::abs((long)denominator);\n    res += std::to_string(num / den);\n    num %= den;\n    if (num == 0) return res;\n    res += '.';\n    std::unordered_map<int, int> map;\n    while (num) {\n        if (map.find(num) != map.end()) {\n            res.insert(map[num], \"(\");\n            res += \")\";\n            break;\n        }\n        map[num] = res.size();\n        num *= 10;\n        res += std::to_string(num / den);\n        num %= den;\n    }\n    return res;\n}\n\nint main() {\n    int numerator = $args;\n    int denominator = $args;\n    std::string result = fractionToDecimal(numerator, denominator);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public String fractionToDecimal(int numerator, int denominator) {\n    if (numerator == 0) return \"0\";\n    StringBuilder res = new StringBuilder();\n    if ((numerator > 0) ^ (denominator > 0)) res.append('-');\n    long num = Math.abs((long)numerator), den = Math.abs((long)denominator);\n    res.append(num / den);\n    num %= den;\n    if (num == 0) return res.toString();\n    res.append('.');\n    HashMap<Long, Integer> map = new HashMap<>();\n    while (num != 0) {\n        if (map.containsKey(num)) {\n            res.insert(map.get(num), \"(\");\n            res.append(\")\");\n            break;\n        }\n        map.put(num, res.length());\n        num *= 10;\n        res.append(num / den);\n        num %= den;\n    }\n    return res.toString();\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    numerator = inputs[0]\n    denominator = inputs[1]\n    result = fraction_to_string(numerator, denominator)\n    print(result)",
            "javascript": ""
        },
        "Qid": "166"
    },
    {
        "_id": {
            "$oid": "661d7bde949b33b6c4e2b0b9"
        },
        "title": "Excel Sheet Column Title",
        "description": "Given an integer `columnNumber`, return its corresponding column title as it appears in an Excel sheet. The column title is represented by a string of uppercase English letters. Each letter corresponds to a column number, where A is 1, B is 2, ..., Z is 26, AA is 27, AB is 28, and so on.",
        "example": "For example, if the columnNumber is 1, the corresponding column title is 'A'.\n\n**Input:**\ncolumnNumber = 1\n**Output:**\n'A'\n\nIf the columnNumber is 28, the corresponding column title is 'AB'.\n\n**Input:**\ncolumnNumber = 28\n**Output:**\n'AB'\n\nIf the columnNumber is 701, the corresponding column title is 'ZY'.\n\n**Input:**\ncolumnNumber = 701\n**Output:**\n'ZY'",
        "level": "Easy",
        "tags": [
            "Math",
            "String"
        ],
        "test_cases": {
            "inputs": [
                1,
                28,
                701,
                52,
                100,
                26,
                27,
                1000,
                10000,
                123456,
                987654,
                231,
                456,
                789,
                999,
                100000,
                999999,
                1234567,
                9876543,
                23123123
            ],
            "outputs": [
                "A",
                "AB",
                "ZY",
                "AZ",
                "CV",
                "Z",
                "AA",
                "ALL",
                "NTP",
                "AICCC",
                "HJHJH",
                "HJ",
                "RM",
                "AD",
                "ALLL",
                "CFD",
                "HJHJHJ",
                "LJHJHJ",
                "HJHJHJH",
                "HJHJHJHJ"
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n\nstd::string convertToTitle(int columnNumber) {\n    std::string result = \"\";\n    while (columnNumber) {\n        columnNumber--;\n        result = (char)(columnNumber % 26 + 'A') + result;\n        columnNumber /= 26;\n    }\n    return result;\n}\n\n",
            "java": "public static String convertToTitle(int columnNumber) {\n    StringBuilder result = new StringBuilder();\n    while (columnNumber > 0) {\n        columnNumber--;\n        result.insert(0, (char) ('A' + columnNumber % 26));\n        columnNumber /= 26;\n    }\n    return result.toString();\n}\n\n",
            "python": "def convert_to_title(columnNumber: int) -> str:\n    result = \"\"\n    while columnNumber:\n        columnNumber -= 1\n        result = chr(columnNumber % 26 + ord('A')) + result\n        columnNumber //= 26\n    return result\n\n",
            "javascript": "function convertToTitle(columnNumber) {\n    let result = \"\";\n    while (columnNumber) {\n        columnNumber--;\n        result = String.fromCharCode(columnNumber % 26 + 'A'.charCodeAt(0)) + result;\n        columnNumber = Math.floor(columnNumber / 26);\n    }\n    return result;\n}\n\n",
            "explanation": "The algorithm converts an integer `columnNumber` to its corresponding column title as it appears in an Excel sheet. It does so by treating the Excel sheet column headers as a Base-26 number system where the numbers are represented by the characters from A-Z.\n\n1. We start by initializing an empty string called `result` that will store the final column title.\n2. In a while loop, we continue until the `columnNumber` is greater than 0.\n3. We subtract 1 from `columnNumber`, as the base representation starts from A (1).\n4. The remainder of `columnNumber` divided by 26 is the index of the character in the A-Z range, which is added to the `result` string.\n5. `columnNumber` is then divided by 26 and the loop continues until `columnNumber` is 0.\n6. Once the loop is finished, the `result` string is returned as the corresponding column title."
        },
        "structure": {
            "c++": "#include <string>\n\nstd::string convertToTitle(int columnNumber) {\n    // Your code here\n}\n\n",
            "java": "public String convertToTitle(int columnNumber) {\n    // Your code here\n}\n\n",
            "python": "def convert_to_title(columnNumber: int) -> str:\n    # Your code here\n\n",
            "javascript": "function convertToTitle(columnNumber) {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int columnNumber = $args;\n    std::string result = convertToTitle(columnNumber);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    int columnNumber = $args;\n    String result = convertToTitle(columnNumber);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    column_number = $args\n    result = convert_to_title(column_number)\n    print(result)",
            "javascript": "function main() {\n    const columnNumber= $args;\n    const result = convertToTitle(columnNumber);\n    console.log(result);\n}\nmain();"
        },
        "Qid": "168",
        "languages verified": [
            "java",
            "c++",
            "javascript",
            "python"
        ]
    },
    {
        "_id": {
            "$oid": "661d7c2e949b33b6c4e2b0ba"
        },
        "title": "Excel Sheet Column Number",
        "description": "Given a string `columnTitle` that represents the column title as appears in an Excel sheet, return its corresponding column number. Each column title consists of uppercase English letters, where 'A' represents 1, 'B' represents 2, and so on. The column titles can also have multiple letters, such as 'AA' representing 27 and 'AB' representing 28.",
        "example": "For example, if the column title is 'AB', the corresponding column number is 28.\n\n**Input:** columnTitle = 'AB'\n**Output:** 28",
        "level": "Easy",
        "tags": [
            "Math",
            "String"
        ],
        "test_cases": {
            "inputs": [
                "'A'",
                "'B'",
                "'C'",
                "'Z'",
                "'AA'",
                "'AB'",
                "'ZY'",
                "'FXSHRXW'"
            ],
            "outputs": [
                1,
                2,
                3,
                26,
                27,
                28,
                701,
                2147483647
            ]
        },
        "sample_code": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint titleToNumber(string columnTitle) {\n    int result = 0;\n    for (char c : columnTitle) {\n        result = result * 26 + (c - 'A' + 1);\n    }\n    return result;\n}\n",
            "java": "public static int titleToNumber(String columnTitle) {\n        int result = 0;\n        for (char c : columnTitle.toCharArray()) {\n            result = result * 26 + (c - 'A' + 1);\n        }\n        return result;\n    }\n",
            "python": "def title_to_number(column_title: str) -> int:\n    result = 0\n    for c in column_title:\n        result = result * 26 + (ord(c) - ord('A') + 1)\n    return result\n",
            "javascript": "function titleToNumber(columnTitle) {\n    let result = 0;\n    for (let c of columnTitle) {\n        result = result * 26 + (c.charCodeAt(0) - 'A'.charCodeAt(0) + 1);\n    }\n    return result;\n}\n",
            "explanation": "The algorithm iterates through the given `columnTitle` string and computes the corresponding column number by treating the string like a base-26 number representation, where 'A' represents the digit 1 and 'Z' represents the digit 26. To convert each character to its corresponding numeric value, we subtract the ASCII value of 'A' and add 1. In each iteration, the current result is multiplied by 26 and the numeric value of the current character is added to the result. Finally, the accumulated result is returned as the column number."
        },
        "structure": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint titleToNumber(string columnTitle) {\n    // Your code here\n}\n",
            "java": "public int titleToNumber(String columnTitle) {\n    // Your code here\n}\n",
            "python": "def title_to_number(column_title: str) -> int:\n    # Your code here\n\n",
            "javascript": "function titleToNumber(columnTitle) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    string columnTitle = $args;\n    int result = titleToNumber(columnTitle);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n        String columnTitle = $args;\n        int result = titleToNumber(columnTitle);\n        System.out.println(result);\n}\n",
            "python": "if __name__ == \"__main__\":\n    column_title = $args\n    result = title_to_number(column_title)\n    print(result)",
            "javascript": "function main() {\n    const columnTitle = $args;\n    const result = titleToNumber(columnTitle);\n    console.log(result);\n}\nmain();"
        },
        "Qid": "171",
        "languages verified": [
            "java",
            "c++",
            "javascript",
            "python"
        ]
    },
    {
        "_id": {
            "$oid": "661d7c71949b33b6c4e2b0bb"
        },
        "title": "Knight's Minimum Initial Health",
        "description": "The demons have captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.\n\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\n\nSome of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).\n\nTo reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.\n\nReturn the knight's minimum initial health so that he can rescue the princess.\n\nNote that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.",
        "example": "Example:\n\nInput: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]\nOutput: 7\nExplanation: The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.",
        "level": "Medium",
        "tags": [
            "dynamic programming",
            "grid",
            "optimization"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        -5
                    ]
                ],
                [
                    [
                        0
                    ]
                ],
                [
                    [
                        -1,
                        -2,
                        -3
                    ],
                    [
                        -4,
                        -5,
                        -6
                    ],
                    [
                        -7,
                        -8,
                        -9
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9
                    ]
                ],
                [
                    [
                        -1000,
                        0,
                        0,
                        0
                    ],
                    [
                        -1000,
                        0,
                        0,
                        0
                    ],
                    [
                        -1000,
                        0,
                        0,
                        0
                    ],
                    [
                        -1000,
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1000,
                        0,
                        0,
                        0
                    ],
                    [
                        1000,
                        0,
                        0,
                        0
                    ],
                    [
                        1000,
                        0,
                        0,
                        0
                    ],
                    [
                        1000,
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        -1000,
                        -1000,
                        -1000,
                        -1000
                    ],
                    [
                        -1000,
                        -1000,
                        -1000,
                        -1000
                    ],
                    [
                        -1000,
                        -1000,
                        -1000,
                        -1000
                    ],
                    [
                        -1000,
                        -1000,
                        -1000,
                        -1000
                    ]
                ],
                [
                    [
                        1000,
                        1000,
                        1000,
                        1000
                    ],
                    [
                        1000,
                        1000,
                        1000,
                        1000
                    ],
                    [
                        1000,
                        1000,
                        1000,
                        1000
                    ],
                    [
                        1000,
                        1000,
                        1000,
                        1000
                    ]
                ],
                [
                    [
                        -2,
                        0,
                        0,
                        0
                    ],
                    [
                        -5,
                        -10,
                        1,
                        0
                    ],
                    [
                        10,
                        30,
                        -5,
                        0
                    ]
                ],
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        5
                    ]
                ],
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        0
                    ]
                ],
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        -1
                    ]
                ],
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        -1000
                    ]
                ],
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        1000
                    ]
                ],
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        -1000
                    ]
                ],
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        1000
                    ]
                ],
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        -1000
                    ]
                ],
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        1000
                    ]
                ],
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        -1000
                    ]
                ],
                [
                    [
                        -2,
                        -3,
                        3
                    ],
                    [
                        -5,
                        -10,
                        1
                    ],
                    [
                        10,
                        30,
                        1000
                    ]
                ]
            ],
            "outputs": [
                7,
                1,
                6,
                1,
                1001,
                1,
                1001,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1
            ]
        },
        "sample_code": {
            "c++": "#include<vector>\nusing namespace std;\n\nint calculateMinimumHP(vector<vector<int>>& dungeon) {\n    int m = dungeon.size(), n = dungeon[0].size();\n    vector<vector<int>> dp(m, vector<int>(n));\n\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if(i == m-1 && j == n-1){\n                dp[i][j] = min(0, dungeon[i][j]);\n            }\n            else if (i == m - 1) {\n                dp[i][j] = min(0, dp[i][j + 1] + dungeon[i][j]);\n            }\n            else if (j == n - 1) {\n                dp[i][j] = min(0, dp[i + 1][j] + dungeon[i][j]);\n            }\n            else {\n                dp[i][j] = min(0, max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n            }\n        }\n    }\n\n    return abs(dp[0][0]) + 1;\n}\n",
            "java": "public int calculateMinimumHP(int[][] dungeon) {\n    int m = dungeon.length, n = dungeon[0].length;\n    int[][] dp = new int[m][n];\n\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if(i == m-1 && j == n-1)\n                dp[i][j] = Math.min(0, dungeon[i][j]);\n            else if (i == m - 1)\n                dp[i][j] = Math.min(0, dp[i][j + 1] + dungeon[i][j]);\n            else if (j == n - 1)\n                dp[i][j] = Math.min(0, dp[i + 1][j] + dungeon[i][j]);\n            else\n                dp[i][j] = Math.min(0, Math.max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n        }\n    }\n\n    return Math.abs(dp[0][0]) + 1;\n}\n",
            "python": "def calculateMinimumHP(dungeon):\n    m, n = len(dungeon), len(dungeon[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if i == m - 1 and j == n - 1:\n                dp[i][j] = min(0, dungeon[i][j])\n            elif i == m - 1:\n                dp[i][j] = min(0, dp[i][j + 1] + dungeon[i][j])\n            elif j == n - 1:\n                dp[i][j] = min(0, dp[i + 1][j] + dungeon[i][j])\n            else:\n                dp[i][j] = min(0, max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j])\n\n    return abs(dp[0][0]) + 1\n",
            "javascript": "function calculateMinimumHP(dungeon) {\n    const m = dungeon.length, n = dungeon[0].length;\n    const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));\n\n    for (let i = m - 1; i >= 0; i--) {\n        for (let j = n - 1; j >= 0; j--) {\n            if (i === m - 1 && j === n - 1)\n                dp[i][j] = Math.min(0, dungeon[i][j]);\n            else if (i === m - 1)\n                dp[i][j] = Math.min(0, dp[i][j + 1] + dungeon[i][j]);\n            else if (j === n - 1)\n                dp[i][j] = Math.min(0, dp[i + 1][j] + dungeon[i][j]);\n            else\n                dp[i][j] = Math.min(0, Math.max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n        }\n    }\n\n    return Math.abs(dp[0][0]) + 1;\n}\n",
            "explanation": "The algorithm uses dynamic programming to find the minimum health needed in a bottom-up manner by starting from the bottom-right corner of the dungeon to the top-left corner. We create a \"dp\" table with the same size as the dungeon and fill it initially with zeros. Then we iterate over each cell in the dungeon from the bottom-right to the top-left. For each cell, we consider the right and down adjacent cells (if they exist) and calculate the minimum health required to move forward. We update the \"dp\" table with these values. The minimum of the health required to move right or down, plus the current cell dungeon value, is then stored in the current cell in the \"dp\" table. Finally, we return the absolute value of the top-left cell of \"dp\" table plus one (for the initial health point). This gives us the minimum initial health needed to get to the princess."
        },
        "structure": {
            "c++": "#include<vector>\nusing namespace std;\n\nint calculateMinimumHP(vector<vector<int>>& dungeon)  {\n    // Your code here\n}\n",
            "java": "public int calculateMinimumHP(int[][] dungeon)  {\n    // Your code here\n}\n",
            "python": "def calculateMinimumHP(dungeon):\n    # Your code here\n\n",
            "javascript": "function calculateMinimumHP(dungeon)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include<vector>\nusing namespace std;\n\nint main() {\n    vector<vector<int>> dungeon = $args;\n    int result = calculateMinimumHP(dungeon);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    dungeon = $args\n    result = calculateMinimumHP(dungeon)\n    print(result)",
            "java": "",
            "javascript": ""
        },
        "Qid": "174"
    },
    {
        "_id": {
            "$oid": "661d7c9e949b33b6c4e2b0bc"
        },
        "title": "Largest Number Formation",
        "description": "Given a list of non-negative integers `nums`, arrange them in such a way that they form the largest number and return it as a string.",
        "example": "For example, given the list `nums = [10, 2]`, the largest number that can be formed is `210`. Therefore, the output would be the string `\"210\"`.\n\nIn another example, given the list `nums = [3, 30, 34, 5, 9]`, the largest number that can be formed is `9534330`. Therefore, the output would be the string `\"9534330\"`.",
        "level": "Medium",
        "tags": [
            "sorting",
            "string"
        ],
        "test_cases": {
            "inputs": [
                [
                    10,
                    2
                ],
                [
                    3,
                    30,
                    34,
                    5,
                    9
                ],
                [
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    9,
                    99,
                    999,
                    9999
                ],
                [
                    100,
                    200,
                    300,
                    400
                ],
                [
                    5,
                    50,
                    500,
                    5000
                ],
                [
                    12,
                    121
                ],
                [
                    21,
                    212
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    0
                ]
            ],
            "outputs": [
                "210",
                "9534330",
                "0",
                "54321",
                "999999999",
                "400300200100",
                "55005000500",
                "12112",
                "21221",
                "9876543210",
                "9876543210"
            ]
        },
        "sample_code": {
            "c++": "#include <algorithm>\n#include <string>\n#include <vector>\n\nbool compare(std::string a, std::string b) {\n    return a+b > b+a;\n}\n\nstd::string largestNumber(std::vector<int>& nums) {\n    std::vector<std::string> asStrs;\n    for (int num : nums) asStrs.push_back(std::to_string(num));\n    std::sort(asStrs.begin(), asStrs.end(), compare);\n    std::string res;\n    for (std::string s: asStrs) res += s;\n    return res[0] == '0' ? \"0\" : res;\n}\n",
            "java": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Solution {\n    public String largestNumber(int[] nums) {\n        String[] strNums = new String[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            strNums[i] = String.valueOf(nums[i]);\n        }\n        Arrays.sort(strNums, (a, b) -> (b + a).compareTo(a + b));\n        if (strNums[0].equals(\"0\")) {\n            return \"0\";\n        }\n        StringBuilder sb = new StringBuilder();\n        for (String str : strNums) sb.append(str);\n        return sb.toString();\n    }\n}\n",
            "python": "from functools import cmp_to_key\n\ndef largestNumber(nums):\n    def comparator(a, b):\n        return -1 if a + b > b + a else int(a + b < b + a)\n\n    nums_as_str = list(map(str, nums))\n    nums_as_str.sort(key=cmp_to_key(comparator))\n    return '0' if nums_as_str[0] == \"0\" else \"\".join(nums_as_str)\n",
            "javascript": "function largestNumber(nums) {\n    const numsAsStrings = nums.map(String);\n    numsAsStrings.sort((a, b) => (b + a).localeCompare(a + b));\n    return numsAsStrings[0] === '0' ? '0' : numsAsStrings.join('');\n}\n",
            "explanation": "1. Convert all integers to strings.\n2. Sort the strings using a custom comparator. The comparator shall compare concatenation of two strings in reverse order, i.e., a+b and b+a. Compare a+b and b+a, if a+b is larger, it means a should be before b, else b should before a.\n3. Join sorted strings to form the answer. If the first string is '0', return '0' as that means all elements are '0' (as strings are sorted)."
        },
        "structure": {
            "c++": "#include <algorithm>\n#include <string>\n#include <vector>\n\nbool compare(std::string a, std::string b)  {\n    // Your code here\n}\n",
            "java": "i {mport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Solution \n    // Your code here\n}\n",
            "python": "from functools import cmp_to_key\n    # Your code here\n\n",
            "javascript": "function largestNumber(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <algorithm>\n#include <string>\n#include <vector>\n#include <iostream>\n\nbool compare(std::string a, std::string b) {\n    return a+b > b+a;\n}\n\nstd::string largestNumber(std::vector<int>& nums) {\n    std::vector<std::string> asStrs;\n    for (int num : nums) asStrs.push_back(std::to_string(num));\n    std::sort(asStrs.begin(), asStrs.end(), compare);\n    std::string res;\n    for (std::string s: asStrs) res += s;\n    return res[0] == '0' ? \"0\" : res;\n}\n\nint main() {\n    std::vector<int> nums = $args;\n    std::string result = largestNumber(nums);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public String largestNumber(int[] nums) {\n        String[] strNums = new String[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            strNums[i] = String.valueOf(nums[i]);\n        }\n        Arrays.sort(strNums, (a, b) -> (b + a).compareTo(a + b));\n        if (strNums[0].equals(\"0\")) {\n            return \"0\";\n        }\n        StringBuilder sb = new StringBuilder();\n        for (String str : strNums) sb.append(str);\n        return sb.toString();\n    }",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = largestNumber(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = largestNumber(nums);\n    console.log(result);\n}"
        },
        "Qid": "179"
    },
    {
        "_id": {
            "$oid": "661d7ce6949b33b6c4e2b0bd"
        },
        "title": "Maximum Profit with at most k Transactions",
        "description": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `k`. Find the maximum profit you can achieve. You may complete at most `k` transactions: i.e. you may buy at most `k` times and sell at most `k` times. Note that you may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
        "example": "Example:\n\nInput: k = 2, prices = [2,4,1]\nOutput: 2\nExplanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    [
                        2,
                        4,
                        1
                    ]
                ],
                [
                    2,
                    [
                        3,
                        2,
                        6,
                        5,
                        0,
                        3
                    ]
                ],
                [
                    1,
                    [
                        7,
                        1,
                        5,
                        3,
                        6,
                        4
                    ]
                ],
                [
                    3,
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ]
                ],
                [
                    0,
                    [
                        7,
                        6,
                        4,
                        3,
                        1
                    ]
                ],
                [
                    5,
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ]
                ],
                [
                    2,
                    [
                        1,
                        2,
                        4,
                        2,
                        5,
                        7,
                        2,
                        4,
                        9,
                        0
                    ]
                ],
                [
                    3,
                    [
                        3,
                        3,
                        5,
                        0,
                        0,
                        3,
                        1,
                        4
                    ]
                ],
                [
                    1,
                    [
                        1
                    ]
                ],
                [
                    0,
                    [
                        1
                    ]
                ],
                [
                    2,
                    [
                        1,
                        2
                    ]
                ],
                [
                    2,
                    [
                        2,
                        1
                    ]
                ],
                [
                    2,
                    [
                        1,
                        2,
                        4,
                        2,
                        5,
                        7,
                        2,
                        4,
                        9,
                        0
                    ]
                ],
                [
                    3,
                    [
                        3,
                        3,
                        5,
                        0,
                        0,
                        3,
                        1,
                        4
                    ]
                ],
                [
                    1,
                    [
                        1
                    ]
                ],
                [
                    0,
                    [
                        1
                    ]
                ],
                [
                    2,
                    [
                        1,
                        2
                    ]
                ],
                [
                    2,
                    [
                        2,
                        1
                    ]
                ],
                [
                    2,
                    [
                        1,
                        2,
                        4,
                        2,
                        5,
                        7,
                        2,
                        4,
                        9,
                        0
                    ]
                ],
                [
                    3,
                    [
                        3,
                        3,
                        5,
                        0,
                        0,
                        3,
                        1,
                        4
                    ]
                ]
            ],
            "outputs": [
                2,
                7,
                5,
                4,
                0,
                4,
                13,
                6,
                0,
                0,
                1,
                0,
                13,
                6,
                0,
                0,
                1,
                0,
                13,
                6
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\nint maxProfit(int k, std::vector<int>& prices) {\n    int n = prices.size();\n    if (k > n / 2) {\n        int max_profit = 0;\n        for (int i = 1; i < n; ++i)\n            max_profit += std::max(prices[i] - prices[i - 1], 0);\n        return max_profit;  \n    }\n\n    std::vector<std::vector<int>> dp(k + 1, std::vector<int>(n, 0));\n    for (int i = 1; i <= k; ++i) {\n        int max_diff = -prices[0];\n        for (int j = 1; j < n; ++j) {\n            dp[i][j] = std::max(dp[i][j - 1], prices[j] + max_diff);\n            max_diff = std::max(max_diff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}\n",
            "java": "public int maxProfit(int k, int[] prices) {\n    int n = prices.length;\n    if (k > n / 2) {\n        int maxProfit = 0;\n        for (int i = 1; i < n; ++i)\n            maxProfit += Math.max(prices[i] - prices[i - 1], 0);\n        return maxProfit;  \n    }\n\n    int[][] dp = new int[k + 1][n];\n    for (int i = 1; i <= k; ++i) {\n        int maxDiff = -prices[0];\n        for (int j = 1; j < n; ++j) {\n            dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n            maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}\n",
            "python": "def maxProfit(k, prices):\n    n = len(prices)\n    if k > n // 2:\n        return sum(max(prices[i] - prices[i - 1], 0) for i in range(1, n))\n\n    dp = [[0] * n for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - prices[j])\n    return dp[k][n - 1]\n",
            "javascript": "function maxProfit(k, prices) {\n    let n = prices.length;\n    if (k > n / 2) {\n        let maxProfit = 0;\n        for (let i = 1; i < n; ++i)\n            maxProfit += Math.max(prices[i] - prices[i - 1], 0);\n        return maxProfit;  \n    }\n\n    let dp = new Array(k + 1).fill(null).map(() => new Array(n).fill(0));\n    for (let i = 1; i <= k; ++i) {\n        let maxDiff = -prices[0];\n        for (let j = 1; j < n; ++j) {\n            dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n            maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}\n",
            "explanation": "The algorithm uses dynamic programming to build a table `dp` where `dp[i][j]` represents the maximum profit after completing `i` transactions up to day `j`. Initialize `dp` with all zeros, since no initial transactions will result in 0 profit.\n\nFirst, handle the case where `k > n / 2`. If allowed transactions (`k`) are more than half of the available days (`n`), you can simply trade daily by only considering positive profits.\n\nNow, use two nested loops to fill the `dp` table. The outer loop iterates over the allowed transactions (1 to k), and the inner loop iterates over the days (1 to n-1). Inside the inner loop, find the maximum difference between the current day's price and previous days' prices minus the maximum profit after completing one less transaction at previous days (i.e., `prices[j] + dp[i-1][j'] - prices[j']` for all j' < j). This will keep track of the most profitable second transaction after buying a stock at the highest possible profit for the first transaction.\n\nFinally, return the value in the bottom-right corner of the `dp` table (i.e., `dp[k][n-1]`), which provides the maximum profit after completing the allowed number of transactions."
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\nint maxProfit(int k, std::vector<int>& prices)  {\n    // Your code here\n}\n",
            "java": "public int maxProfit(int k, int[] prices)  {\n    // Your code here\n}\n",
            "python": "def maxProfit(k, prices):\n    # Your code here\n\n",
            "javascript": "function maxProfit(k, prices)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <algorithm>\n\nint main() {\n    int k = $args;\n    std::vector<int> prices = {1, 2, 3, 4, 5};\n    int result = maxProfit(k, prices);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int maxProfit(int k, int[] prices) {\n    int n = prices.length;\n    if (k > n / 2) {\n        int maxProfit = 0;\n        for (int i = 1; i < n; ++i)\n            maxProfit += Math.max(prices[i] - prices[i - 1], 0);\n        return maxProfit;  \n    }\n\n    int[][] dp = new int[k + 1][n];\n    for (int i = 1; i <= k; ++i) {\n        int maxDiff = -prices[0];\n        for (int j = 1; j < n; ++j) {\n            dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n            maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    k = inputs[0]\n    prices = inputs[1]\n    result = maxProfit(k, prices)\n    print(result)",
            "javascript": "function maxProfit(k, prices) {\n    let n = prices.length;\n    if (k > n / 2) {\n        let maxProfit = 0;\n        for (let i = 1; i < n; ++i)\n            maxProfit += Math.max(prices[i] - prices[i - 1], 0);\n        return maxProfit;  \n    }\n\n    let dp = new Array(k + 1).fill(null).map(() => new Array(n).fill(0));\n    for (let i = 1; i <= k; ++i) {\n        let maxDiff = -prices[0];\n        for (let j = 1; j < n; ++j) {\n            dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n            maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}"
        },
        "Qid": "188"
    },
    {
        "_id": {
            "$oid": "661d7d9f949b33b6c4e2b0be"
        },
        "title": "Reverse Bits",
        "description": "Write a function that takes a 32-bit unsigned integer as input and returns the integer obtained by reversing its bits.",
        "example": "For example, if the input is 00000010100101000001111010011100, the output should be 964176192. The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so the reversed bits should be 00111001011110000010100101000000, which is equal to 964176192.",
        "level": "Easy",
        "tags": [
            "Bit Manipulation"
        ],
        "test_cases": {
            "inputs": [
                "00000010100101000001111010011100",
                "11111111111111111111111111111101",
                "00000000000000000000000000000000",
                "11111111111111111111111111111111",
                "10000000000000000000000000000000",
                "01010101010101010101010101010101",
                "00110011001100110011001100110011",
                "00001111000011110000111100001111",
                "11110000111100001111000011110000",
                "10101010101010101010101010101010",
                "11001100110011001100110011001100",
                "00000000000000000000000000000001",
                "11111111111111111111111111111110",
                "10000000000000000000000000000001",
                "01010101010101010101010101010100",
                "00110011001100110011001100110010",
                "00001111000011110000111100001110",
                "11110000111100001111000011110001",
                "10101010101010101010101010101001",
                "11001100110011001100110011001101"
            ],
            "outputs": [
                964176192,
                {
                    "$numberLong": "3221225471"
                },
                0,
                {
                    "$numberLong": "4294967295"
                },
                -2147483648,
                1431655765,
                858993459,
                {
                    "$numberLong": "4026531840"
                },
                {
                    "$numberLong": "4026531840"
                },
                {
                    "$numberLong": "2863311530"
                },
                {
                    "$numberLong": "3221225472"
                },
                -2147483647,
                -1073741825,
                -2147483647,
                {
                    "$numberLong": "2863311536"
                },
                1431655764,
                402653184,
                {
                    "$numberLong": "3221225472"
                },
                {
                    "$numberLong": "2863311529"
                },
                -1073741823
            ]
        },
        "sample_code": {
            "c++": "unsigned int reverseBits(unsigned int n) {\n    unsigned int res = 0;\n    for (int i = 0; i < 32; ++i) {\n        res <<= 1;\n        res |= n & 1;\n        n >>= 1;\n    }\n    return res;\n}\n",
            "java": "public int reverseBits(int n) {\n    int res = 0;\n    for (int i = 0; i < 32; ++i) {\n        res <<= 1;\n        res |= n & 1;\n        n >>= 1;\n    }\n    return res;\n}\n",
            "python": "def reverse_bits(n: str) -> int:\n    res = 0\n    for _ in range(32):\n        res <<= 1\n        res |= n & 1\n        n >>= 1\n    return res\n",
            "javascript": "function reverseBits(n) {\n    let res = 0;\n    for (let i = 0; i < 32; ++i) {\n        res <<= 1;\n        res |= n & 1;\n        n >>= 1;\n    }\n    return res >>> 0;\n}\n",
            "explanation": "The algorithm iterates through all 32 bits of the given unsigned 32-bit integer, and for each bit, it shifts the result variable `res` one position to the left, and then performs a bitwise OR with the given number `n` ANDed with 1. This operation adds the least significant bit of `n` to the most significant bit of `res`. Then, the given number `n` is shifted one position to the right. The process is repeated for all 32 bits, and in each step, the result variable `res` accumulates the reversed bits of the input number."
        },
        "structure": {
            "c++": "unsigned int reverseBits(unsigned int n)  {\n    // Your code here\n}\n",
            "java": "public int reverseBits(int n)  {\n    // Your code here\n}\n",
            "python": "def reverse_bits(n: str) -> int:\n    # Your code here\n\n",
            "javascript": "function reverseBits(n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nunsigned int reverseBits(unsigned int n) {\n    unsigned int res = 0;\n    for (int i = 0; i < 32; ++i) {\n        res <<= 1;\n        res |= n & 1;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    unsigned int n = $args;\n    unsigned int result = reverseBits(n);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = reverse_bits(n)\n    print(result)",
            "java": "",
            "javascript": ""
        },
        "Qid": "190"
    },
    {
        "_id": {
            "$oid": "661d7e2c949b33b6c4e2b0bf"
        },
        "title": "House Robber",
        "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
        "example": "Example:\n\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.",
        "level": "Medium",
        "tags": [
            "Dynamic Programming",
            "Array"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3,
                    1
                ],
                [
                    2,
                    7,
                    9,
                    3,
                    1
                ],
                [
                    2,
                    1,
                    1,
                    2
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    5,
                    10,
                    15,
                    20,
                    25
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9,
                    2,
                    4,
                    6,
                    8,
                    10
                ],
                [
                    10,
                    8,
                    6,
                    4,
                    2,
                    9,
                    7,
                    5,
                    3,
                    1
                ],
                [
                    1
                ],
                [
                    10
                ],
                [
                    0
                ],
                [
                    1,
                    2
                ],
                [
                    2,
                    1
                ],
                [
                    1,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    0
                ],
                [
                    1,
                    0,
                    0,
                    1
                ],
                [
                    0,
                    1,
                    1,
                    0
                ],
                [
                    1,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0,
                    1,
                    0
                ]
            ],
            "outputs": [
                4,
                12,
                4,
                3,
                40,
                0,
                30,
                30,
                30,
                30,
                1,
                10,
                0,
                2,
                2,
                2,
                1,
                2,
                2,
                5
            ]
        },
        "sample_code": {
            "c++": "int rob(vector<int>& nums) {\n    int prev1 = 0, prev2 = 0;\n    for (const auto& num : nums) {\n        int tmp = prev1;\n        prev1 = max(prev2 + num, prev1);\n        prev2 = tmp;\n    }\n    return prev1;\n}\n",
            "java": "public int rob(int[] nums) {\n    int prev1 = 0, prev2 = 0;\n    for (int num : nums) {\n        int temp = prev1;\n        prev1 = Math.max(prev2 + num, prev1);\n        prev2 = temp;\n    }\n    return prev1;\n}\n",
            "python": "def rob(nums):\n    prev1, prev2 = 0, 0\n    for num in nums:\n        prev1, prev2 = max(prev2 + num, prev1), prev1\n    return prev1\n",
            "javascript": "function rob(nums) {\n    let prev1 = 0, prev2 = 0;\n    for (let num of nums) {\n        let temp = prev1;\n        prev1 = Math.max(prev2 + num, prev1);\n        prev2 = temp;\n    }\n    return prev1;\n}\n",
            "explanation": "We use dynamic programming, maintaining two variables `prev1` and `prev2`. `prev1` represents the maximum amount of money that can be robbed up to the current house, and `prev2` represents the maximum amount of money that can be robbed up to the house before the current house (because we cannot rob two adjacent houses). \n\nAt each house, we calculate the updated maximum amount of money that can be robbed up to the current house. This can be either the sum of the current house's money and the maximum amount of money that can be robbed up to the house before the current house (which is stored in `prev2`) or the maximum amount of money that can be robbed up to the previous house (which is stored in `prev1`). We pick the greater one and update `prev1` accordingly. At the same time, we update `prev2` by setting it to the old `prev1` value.\n\nBy the end of the loop, `prev1` will represent the maximum amount of money that can be robbed without alerting the police, which we return."
        },
        "structure": {
            "c++": "int rob(vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "public int rob(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def rob(nums):\n    # Your code here\n\n",
            "javascript": "function rob(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> nums = $args;\n    int result = rob(nums);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int rob(int[] nums) {\n    int prev1 = 0, prev2 = 0;\n    for (int num : nums) {\n        int temp = prev1;\n        prev1 = Math.max(prev2 + num, prev1);\n        prev2 = temp;\n    }\n    return prev1;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = rob(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = rob(nums);\n    console.log(result);\n}"
        },
        "Qid": "198"
    },
    {
        "_id": {
            "$oid": "661d7e51949b33b6c4e2b0c0"
        },
        "title": "Number of Islands",
        "description": "Given an `m x n` 2D binary grid `grid` which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
        "example": "Example:\n\nInput: grid = [\n  [\"1\", \"1\", \"1\", \"1\", \"0\"],\n  [\"1\", \"1\", \"0\", \"1\", \"0\"],\n  [\"1\", \"1\", \"0\", \"0\", \"0\"],\n  [\"0\", \"0\", \"0\", \"0\", \"0\"]\n]\nOutput: 1\n\nInput: grid = [\n  [\"1\", \"1\", \"0\", \"0\", \"0\"],\n  [\"1\", \"1\", \"0\", \"0\", \"0\"],\n  [\"0\", \"0\", \"1\", \"0\", \"0\"],\n  [\"0\", \"0\", \"0\", \"1\", \"1\"]\n]\nOutput: 3",
        "level": "Medium",
        "tags": [
            "Array",
            "Graph",
            "DFS",
            "BFS"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "1",
                        "1",
                        "1",
                        "1",
                        "0"
                    ],
                    [
                        "1",
                        "1",
                        "0",
                        "1",
                        "0"
                    ],
                    [
                        "1",
                        "1",
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "0",
                        "0",
                        "0",
                        "0",
                        "0"
                    ]
                ],
                [
                    [
                        "1",
                        "1",
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "1",
                        "1",
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "0",
                        "0",
                        "1",
                        "0",
                        "0"
                    ],
                    [
                        "0",
                        "0",
                        "0",
                        "1",
                        "1"
                    ]
                ],
                [
                    [
                        "1",
                        "0",
                        "1",
                        "0",
                        "1"
                    ],
                    [
                        "0",
                        "1",
                        "0",
                        "1",
                        "0"
                    ],
                    [
                        "1",
                        "0",
                        "1",
                        "0",
                        "1"
                    ],
                    [
                        "0",
                        "1",
                        "0",
                        "1",
                        "0"
                    ]
                ],
                [
                    [
                        "1",
                        "1",
                        "1",
                        "1",
                        "1"
                    ],
                    [
                        "1",
                        "1",
                        "1",
                        "1",
                        "1"
                    ],
                    [
                        "1",
                        "1",
                        "1",
                        "1",
                        "1"
                    ],
                    [
                        "1",
                        "1",
                        "1",
                        "1",
                        "1"
                    ]
                ],
                [
                    [
                        "0",
                        "0",
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "0",
                        "0",
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "0",
                        "0",
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "0",
                        "0",
                        "0",
                        "0",
                        "0"
                    ]
                ]
            ],
            "outputs": [
                1,
                3,
                8,
                1,
                0
            ]
        },
        "sample_code": {
            "c++": "void dfs(vector<vector<char>>& grid, int i, int j) {\n    if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == '0')\n        return;\n\n    grid[i][j] = '0';\n    dfs(grid, i + 1, j);\n    dfs(grid, i - 1, j);\n    dfs(grid, i, j + 1);\n    dfs(grid, i, j - 1);\n}\n\nint numIslands(vector<vector<char>>& grid) {\n    int count = 0;\n    for(int i = 0; i < grid.size(); i++) {\n        for(int j = 0; j < grid[0].size(); j++) {\n            if(grid[i][j] == '1') {\n                count++;\n                dfs(grid, i, j);\n            }\n        }\n    }\n    return count;\n}\n",
            "java": "class Solution {\n    private void dfs(char[][] grid, int i, int j) {\n        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == '0')\n            return;\n\n        grid[i][j] = '0';\n        dfs(grid, i + 1, j);\n        dfs(grid, i - 1, j);\n        dfs(grid, i, j + 1);\n        dfs(grid, i, j - 1);\n    }\n\n    public int numIslands(char[][] grid) {\n        int count = 0;\n        for(int i = 0; i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length; j++) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return count;\n    }\n}\n",
            "python": "def dfs(grid, i, j):\n    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':\n        return\n\n    grid[i][j] = '0'\n    dfs(grid, i + 1, j)\n    dfs(grid, i - 1, j)\n    dfs(grid, i, j + 1)\n    dfs(grid, i, j - 1)\n\ndef numIslands(grid):\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(grid, i, j)\n    return count\n",
            "javascript": "function dfs(grid, i, j) {\n    if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0')\n        return;\n\n    grid[i][j] = '0';\n    dfs(grid, i + 1, j);\n    dfs(grid, i - 1, j);\n    dfs(grid, i, j + 1);\n    dfs(grid, i, j - 1);\n}\n\nfunction numIslands(grid) {\n    let count = 0;\n    for(let i = 0; i < grid.length; i++) {\n        for(let j = 0; j < grid[0].length; j++) {\n            if(grid[i][j] === '1') {\n                count++;\n                dfs(grid, i, j);\n            }\n        }\n    }\n    return count;\n}\n",
            "explanation": "The base algorithm is depth-first search (DFS). The idea is to loop through the entire grid and for each cell with a value of '1', increment the island count by 1 and run the DFS algorithm starting on this cell. During the DFS traversal, we modify the grid by setting the visited cells containing '1' to '0', which will avoid visiting the same land cell again. The DFS traversal stops when the boundaries of the grid are reached or a '0' cell is hit. The DFS runs recursively on the neighboring cells (up, down, left, and right) of the current cell.\n\nThe time complexity of this algorithm is O(m * n) since we may have to visit every cell in the worst case, where m and n are the row and column dimensions of the grid."
        },
        "structure": {
            "c++": "void dfs(vector<vector<char>>& grid, int i, int j)  {\n    // Your code here\n}\n",
            "java": "c {lass Solution \n    // Your code here\n}\n",
            "python": "def dfs(grid, i, j):\n    # Your code here\n\n",
            "javascript": "function dfs(grid, i, j)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "void dfs(vector<vector<char>>& grid, int i, int j) {\n    if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == '0')\n        return;\n\n    grid[i][j] = '0';\n    dfs(grid, i + 1, j);\n    dfs(grid, i - 1, j);\n    dfs(grid, i, j + 1);\n    dfs(grid, i, j - 1);\n}\n\nint numIslands(vector<vector<char>>& grid) {\n    int count = 0;\n    for(int i = 0; i < grid.size(); i++) {\n        for(int j = 0; j < grid[0].size(); j++) {\n            if(grid[i][j] == '1') {\n                count++;\n                dfs(grid, i, j);\n            }\n        }\n    }\n    return count;\n}",
            "java": "public int numIslands(char[][] grid) {\n        int count = 0;\n        for(int i = 0; i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length; j++) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return count;\n    }",
            "python": "if __name__ == \"__main__\":\n    grid = $args\n    result = numIslands(grid)\n    print(result)",
            "javascript": "function main() {\n    const grid = $args;\n    const result = numIslands(grid);\n    console.log(result);\n}"
        },
        "Qid": "200"
    },
    {
        "_id": {
            "$oid": "661d7e89949b33b6c4e2b0c1"
        },
        "title": "Happy Number",
        "description": "Write a function to determine if a number `n` is a happy number. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy.",
        "example": "Example 1:\n\nInput: n = 19\nOutput: true\nExplanation: 1^2 + 9^2 = 82, 8^2 + 2^2 = 68, 6^2 + 8^2 = 100, 1^2 + 0^2 + 0^2 = 1\n\nExample 2:\n\nInput: n = 2\nOutput: false",
        "level": "Easy",
        "tags": [
            "Math",
            "Recursion"
        ],
        "test_cases": {
            "inputs": [
                19,
                2,
                7,
                10,
                13,
                20,
                23,
                28,
                31,
                32,
                44,
                49,
                68,
                70,
                79,
                82,
                86,
                91,
                94,
                97
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                true,
                false,
                true,
                true,
                false,
                false,
                false,
                true,
                true,
                false,
                true,
                true,
                false,
                false,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "#include <iostream>\n#include <unordered_set>\n\nint getNext(int n) {\n    int sum = 0;\n    while (n > 0) {\n        int digit = n % 10;\n        sum += digit * digit;\n        n /= 10;\n    }\n    return sum;\n}\n\nbool isHappy(int n) {\n    std::unordered_set<int> seen;\n    while (n != 1 && seen.find(n) == seen.end()) {\n        seen.insert(n);\n        n = getNext(n);\n    }\n    return n == 1;\n}",
            "java": "public static int getNext(int n) {\n    int sum = 0;\n    while (n > 0) {\n        int digit = n % 10;\n        sum += digit * digit;\n        n /= 10;\n    }\n    return sum;\n}\n\npublic static boolean isHappy(int n) {\n    int slow = n, fast = getNext(n);\n    while (fast != 1 && slow != fast) {\n        slow = getNext(slow);\n        fast = getNext(getNext(fast));\n    }\n    return fast == 1;\n}\n",
            "python": "def get_next(n):\n    sum = 0\n    while n > 0:\n        digit = n % 10\n        sum += digit * digit\n        n //= 10\n    return sum\n\ndef is_happy(n):\n    slow, fast = n, get_next(n)\n    while fast != 1 and slow != fast:\n        slow = get_next(slow)\n        fast = get_next(get_next(fast))\n    return fast == 1\n",
            "javascript": "function getNext(n) {\n    let sum = 0;\n    while (n > 0) {\n        let digit = n % 10;\n        sum += digit * digit;\n        n = Math.floor(n / 10);\n    }\n    return sum;\n}\n\nfunction isHappy(n) {\n    let slow = n, fast = getNext(n);\n    while (fast !== 1 && slow !== fast) {\n        slow = getNext(slow);\n        fast = getNext(getNext(fast));\n    }\n    return fast === 1;\n}",
            "explanation": "The algorithm to determine if a number is happy repeatedly performs the sum of the squares of its digits. We can use the slow and fast pointer method (also called the Floyd's cycle-finding algorithm). In this method, we have two pointers (`slow` and `fast`), both initially pointing to the input number `n`. In each iteration, the `slow` pointer moves to the next number in the sequence (by calling `getNext()`) while the `fast` pointer moves to the next of next number in the sequence. If at any point, we find that the `fast` pointer becomes 1, it implies that the number is a happy number. If the `slow` and `fast` pointers become equal and it is not 1, it implies that there is a cycle and the number is not a happy number.\n\n`getNext(n)` function calculates the next number in the sequence by summing the squares of the digits of the current number `n`. This function is called in the main `isHappy(n)` function for updating `slow` and `fast` pointers."
        },
        "structure": {
            "c++": "#include <iostream>\n#include <unordered_set>\n\nint getNext(int n) {\n    // Your code here\n}\n",
            "java": "public int getNext(int n) {\n    // Your code here\n}\n",
            "python": "def get_next(n):\n    # Your code here\n\n",
            "javascript": "function getNext(n) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    bool result = isHappy(n);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "java": "public static void main(String[] args){\n    int n = $args;\n    boolean result = isHappy(n);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = is_happy(n)\n    print(result)",
            "javascript": "function main() {\n    const number = $args; // Replace 'grid' with 'number' to make the context clear\n    const result = isHappy(number); // Call the correct function\n    console.log(result); // Output should be true if the number is happy\n}\n\nmain();"
        },
        "Qid": "202",
        "languages verified": [
            "c++",
            "java",
            "javascript",
            "python"
        ]
    },
    {
        "_id": {
            "$oid": "661d7eca949b33b6c4e2b0c2"
        },
        "title": "Count Prime Numbers",
        "description": "Given an integer `n`, return the number of prime numbers that are strictly less than `n`.",
        "example": "Example 1:\n\nInput: n = 10\nOutput: 4\nExplanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.",
        "level": "Easy",
        "tags": [
            "Math",
            "Prime Numbers"
        ],
        "test_cases": {
            "inputs": [
                10,
                0,
                1,
                20,
                100,
                1000,
                10000,
                100000,
                1000000,
                5000000
            ],
            "outputs": [
                4,
                0,
                0,
                8,
                25,
                168,
                1229,
                9592,
                78498,
                348513
            ]
        },
        "sample_code": {
            "c++": "int countPrimes(int n) {\n    if (n <= 2) return 0;\n    vector<bool> isPrime(n, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i * i < n; ++i) {\n        if (isPrime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    return count(isPrime.begin(), isPrime.end(), true);\n}\n",
            "java": "public int countPrimes(int n) {\n    if (n <= 2) return 0;\n    boolean[] isPrime = new boolean[n];\n    Arrays.fill(isPrime, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i * i < n; i++) {\n        if (isPrime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    int count = 0;\n    for (boolean prime : isPrime) {\n        if (prime) count++;\n    }\n    return count;\n}\n",
            "python": "def countPrimes(n: int) -> int:\n    if n <= 2:\n        return 0\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    return sum(is_prime)\n",
            "javascript": "function countPrimes(n) {\n    if (n <= 2) return 0;\n    const isPrime = Array(n).fill(true);\n    isPrime[0] = isPrime[1] = false;\n    for (let i = 2; i * i < n; i++) {\n        if (isPrime[i]) {\n            for (let j = i * i; j < n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    return isPrime.filter(prime => prime).length;\n}\n",
            "explanation": "1. Initialize an array of booleans with value `true` and named `isPrime` to keep track of prime numbers from 0 to `n`.\n2. Set `isPrime[0]` and `isPrime[1]` to `false` since 0 and 1 are not prime numbers.\n3. Loop through numbers from 2 to the square root of `n`, and for each `i` that is still marked `true` in the `isPrime` array, loop through all its multiples starting from `i*i` (skipping `i` itself) and mark them as `false` because they won't be prime since they are divisible by `i`.\n4. Count all `true` values remaining in the `isPrime` array which indicates the count of prime numbers less than `n`."
        },
        "structure": {
            "c++": "int countPrimes(int n)  {\n    // Your code here\n}\n",
            "java": "public int countPrimes(int n)  {\n    // Your code here\n}\n",
            "python": "def countPrimes(n: int) -> int:\n    # Your code here\n\n",
            "javascript": "function countPrimes(n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = countPrimes(n);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = countPrimes(n)\n    print(result)",
            "java": "",
            "javascript": ""
        },
        "Qid": "204"
    },
    {
        "_id": {
            "$oid": "661d7f01949b33b6c4e2b0c3"
        },
        "title": "Isomorphic Strings",
        "description": "Given two strings `s` and `t`, determine if they are isomorphic. Two strings `s` and `t` are isomorphic if the characters in `s` can be replaced to get `t`. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.",
        "example": "Example:\n\nInput: s = \"egg\", t = \"add\"\nOutput: true\n\nExplanation: The characters 'e' and 'a' can be replaced with 'a'. The characters 'g' and 'd' can be replaced with 'd'. Therefore, the strings 'egg' and 'add' are isomorphic.\n\nInput: s = \"foo\", t = \"bar\"\nOutput: false\n\nExplanation: The characters 'f' and 'b' cannot be replaced with the same character. Therefore, the strings 'foo' and 'bar' are not isomorphic.",
        "level": "Easy",
        "tags": [
            "String",
            "Hash Table"
        ],
        "test_cases": {
            "inputs": [
                [
                    "egg",
                    "add"
                ],
                [
                    "foo",
                    "bar"
                ],
                [
                    "paper",
                    "title"
                ],
                [
                    "ab",
                    "aa"
                ],
                [
                    "ab",
                    "cd"
                ],
                [
                    "abcd",
                    "efgh"
                ],
                [
                    "abcd",
                    "aabb"
                ],
                [
                    "abcd",
                    "abcd"
                ],
                [
                    "abcd",
                    "abcc"
                ],
                [
                    "abcd",
                    "abca"
                ],
                [
                    "abcd",
                    "abcb"
                ],
                [
                    "abcd",
                    "abcc"
                ],
                [
                    "abcd",
                    "abca"
                ],
                [
                    "abcd",
                    "abcb"
                ],
                [
                    "abcd",
                    "abcc"
                ],
                [
                    "abcd",
                    "abca"
                ],
                [
                    "abcd",
                    "abcb"
                ],
                [
                    "abcd",
                    "abcc"
                ],
                [
                    "abcd",
                    "abca"
                ],
                [
                    "abcd",
                    "abcb"
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                false,
                true,
                true,
                false,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "#include <unordered_map>\n\nbool isIsomorphic(std::string s, std::string t) {\n    std::unordered_map<char, char> map1, map2;\n    for (size_t i = 0; i < s.size(); ++i) {\n        if (map1.find(s[i]) == map1.end()) {\n            map1[s[i]] = t[i];\n        }\n        if (map2.find(t[i]) == map2.end()) {\n            map2[t[i]] = s[i];\n        }\n        if (map1[s[i]] != t[i] || map2[t[i]] != s[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n",
            "java": "import java.util.HashMap;\n\npublic boolean isIsomorphic(String s, String t) {\n    HashMap<Character, Character> map1 = new HashMap<>();\n    HashMap<Character, Character> map2 = new HashMap<>();\n    \n    for (int i = 0; i < s.length(); i++) {\n        char sChar = s.charAt(i);\n        char tChar = t.charAt(i);\n        \n        if (!map1.containsKey(sChar)) {\n            map1.put(sChar, tChar);\n        }\n        if (!map2.containsKey(tChar)) {\n            map2.put(tChar, sChar);\n        }\n        \n        if (map1.get(sChar) != tChar || map2.get(tChar) != sChar) {\n           return false;\n        }\n    }\n    return true;\n}\n",
            "python": "def is_isomorphic(s: str, t: str) -> bool:\n    map1, map2 = {}, {}\n    for char_s, char_t in zip(s, t):\n        if char_s not in map1:\n            map1[char_s] = char_t\n        if char_t not in map2:\n            map2[char_t] = char_s\n        if map1[char_s] != char_t or map2[char_t] != char_s:\n            return False\n    return True\n",
            "javascript": "function isIsomorphic(s, t) {\n    let map1 = new Map();\n    let map2 = new Map();\n    for (let i = 0; i < s.length; i++) {\n        let sChar = s[i];\n        let tChar = t[i];\n\n        if (!map1.has(sChar)) {\n            map1.set(sChar, tChar);\n        }\n        if (!map2.has(tChar)) {\n            map2.set(tChar, sChar);\n        }\n\n        if (map1.get(sChar) !== tChar || map2.get(tChar) !== sChar) {\n            return false;\n        }\n    }\n    return true;\n}\n",
            "explanation": "- Create two maps (or hash_maps) to store the mappings for characters in `s` to `t` and characters in `t` to `s`.\n- Iterate through the characters of `s` and `t`.\n- If the current character of `s` is not a key in the first map, add it with the corresponding character of `t` as the value.\n- If the current character of `t` is not a key in the second map, add it with the corresponding character of `s` as the value.\n- If the maps have inconsistent mappings, return false (they are not isomorphic).\n- If the loop is over without finding inconsistent mappings, return true (the strings are isomorphic)."
        },
        "structure": {
            "c++": "#include <unordered_map>\n\nbool isIsomorphic(std::string s, std::string t)  {\n    // Your code here\n}\n",
            "java": "import java.util.HashMap;\n\npublic boolean isIsomorphic(String s, String t)  {\n    // Your code here\n}\n",
            "python": "def is_isomorphic(s: str, t: str) -> bool:\n    # Your code here\n\n",
            "javascript": "function isIsomorphic(s, t)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <unordered_map>\n#include <iostream>\n\nbool isIsomorphic(std::string s, std::string t);\n\nint main() {\n    std::string s = $args;\n    std::string t = $args;\n    bool result = isIsomorphic(s, t);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}\n\nbool isIsomorphic(std::string s, std::string t) {\n    std::unordered_map<char, char> map1, map2;\n    for (size_t i = 0; i < s.size(); ++i) {\n        if (map1.find(s[i]) == map1.end()) {\n            map1[s[i]] = t[i];\n        }\n        if (map2.find(t[i]) == map2.end()) {\n            map2[t[i]] = s[i];\n        }\n        if (map1[s[i]] != t[i] || map2[t[i]] != s[i]) {\n            return false;\n        }\n    }\n    return true;\n}",
            "java": "public boolean isIsomorphic(String s, String t) {\n    HashMap<Character, Character> map1 = new HashMap<>();\n    HashMap<Character, Character> map2 = new HashMap<>();\n    \n    for (int i = 0; i < s.length(); i++) {\n        char sChar = s.charAt(i);\n        char tChar = t.charAt(i);\n        \n        if (!map1.containsKey(sChar)) {\n            map1.put(sChar, tChar);\n        }\n        if (!map2.containsKey(tChar)) {\n            map2.put(tChar, sChar);\n        }\n        \n        if (map1.get(sChar) != tChar || map2.get(tChar) != sChar) {\n           return false;\n        }\n    }\n    return true;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    s = inputs[0]\n    t = inputs[1]\n    result = is_isomorphic(s, t)\n    print(result)",
            "javascript": "function isIsomorphic(s, t) {\n    let map1 = new Map();\n    let map2 = new Map();\n    for (let i = 0; i < s.length; i++) {\n        let sChar = s[i];\n        let tChar = t[i];\n\n        if (!map1.has(sChar)) {\n            map1.set(sChar, tChar);\n        }\n        if (!map2.has(tChar)) {\n            map2.set(tChar, sChar);\n        }\n\n        if (map1.get(sChar) !== tChar || map2.get(tChar) !== sChar) {\n            return false;\n        }\n    }\n    return true;\n}"
        },
        "Qid": "205"
    },
    {
        "_id": {
            "$oid": "661dac64949b33b6c4e2b0c4"
        },
        "title": "Course Prerequisites",
        "description": "You are given a total of `numCourses` courses labeled from `0` to `numCourses - 1`. The prerequisites for each course are given in the form of an array `prerequisites`, where `prerequisites[i] = [ai, bi]` indicates that course `bi` must be taken before course `ai`. Determine if it is possible to finish all the courses.",
        "example": "For example, given `numCourses = 2` and `prerequisites = [[1,0]]`, you can finish all the courses. To take course 1, you need to have finished course 0. Therefore, the output would be `true`.\n\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: true\n\nGiven `numCourses = 2` and `prerequisites = [[1,0],[0,1]]`, it is impossible to finish all the courses. To take course 1, you need to have finished course 0, and to take course 0, you need to have finished course 1. Therefore, the output would be `false`.\n\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\nOutput: false",
        "level": "Medium",
        "tags": [
            "Graphs",
            "Topological Sort"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    [
                        [
                            1,
                            0
                        ]
                    ]
                ],
                [
                    2,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            0,
                            1
                        ]
                    ]
                ],
                [
                    3,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ]
                    ]
                ],
                [
                    4,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ]
                    ]
                ],
                [
                    4,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            0,
                            3
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            0,
                            4
                        ]
                    ]
                ],
                [
                    6,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ]
                    ]
                ],
                [
                    6,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            0,
                            5
                        ]
                    ]
                ],
                [
                    7,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            6,
                            5
                        ]
                    ]
                ],
                [
                    7,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            6,
                            5
                        ],
                        [
                            0,
                            6
                        ]
                    ]
                ],
                [
                    8,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            6,
                            5
                        ],
                        [
                            7,
                            6
                        ]
                    ]
                ],
                [
                    8,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            6,
                            5
                        ],
                        [
                            7,
                            6
                        ],
                        [
                            0,
                            7
                        ]
                    ]
                ],
                [
                    9,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            6,
                            5
                        ],
                        [
                            7,
                            6
                        ],
                        [
                            8,
                            7
                        ]
                    ]
                ],
                [
                    9,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            6,
                            5
                        ],
                        [
                            7,
                            6
                        ],
                        [
                            8,
                            7
                        ],
                        [
                            0,
                            8
                        ]
                    ]
                ],
                [
                    10,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            6,
                            5
                        ],
                        [
                            7,
                            6
                        ],
                        [
                            8,
                            7
                        ],
                        [
                            9,
                            8
                        ]
                    ]
                ],
                [
                    10,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            6,
                            5
                        ],
                        [
                            7,
                            6
                        ],
                        [
                            8,
                            7
                        ],
                        [
                            9,
                            8
                        ],
                        [
                            0,
                            9
                        ]
                    ]
                ],
                [
                    2000,
                    []
                ],
                [
                    2000,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            6,
                            5
                        ],
                        [
                            7,
                            6
                        ],
                        [
                            8,
                            7
                        ],
                        [
                            9,
                            8
                        ],
                        [
                            0,
                            9
                        ]
                    ]
                ],
                [
                    2000,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            6,
                            5
                        ],
                        [
                            7,
                            6
                        ],
                        [
                            8,
                            7
                        ],
                        [
                            9,
                            8
                        ],
                        [
                            0,
                            9
                        ],
                        [
                            10,
                            11
                        ],
                        [
                            11,
                            12
                        ],
                        [
                            12,
                            13
                        ],
                        [
                            13,
                            14
                        ],
                        [
                            14,
                            15
                        ],
                        [
                            15,
                            16
                        ],
                        [
                            16,
                            17
                        ],
                        [
                            17,
                            18
                        ],
                        [
                            18,
                            19
                        ],
                        [
                            19,
                            20
                        ]
                    ]
                ],
                [
                    2000,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            5,
                            4
                        ],
                        [
                            6,
                            5
                        ],
                        [
                            7,
                            6
                        ],
                        [
                            8,
                            7
                        ],
                        [
                            9,
                            8
                        ],
                        [
                            0,
                            9
                        ],
                        [
                            10,
                            11
                        ],
                        [
                            11,
                            12
                        ],
                        [
                            12,
                            13
                        ],
                        [
                            13,
                            14
                        ],
                        [
                            14,
                            15
                        ],
                        [
                            15,
                            16
                        ],
                        [
                            16,
                            17
                        ],
                        [
                            17,
                            18
                        ],
                        [
                            18,
                            19
                        ],
                        [
                            19,
                            20
                        ],
                        [
                            20,
                            21
                        ],
                        [
                            21,
                            22
                        ],
                        [
                            22,
                            23
                        ],
                        [
                            23,
                            24
                        ],
                        [
                            24,
                            25
                        ],
                        [
                            25,
                            26
                        ],
                        [
                            26,
                            27
                        ],
                        [
                            27,
                            28
                        ],
                        [
                            28,
                            29
                        ],
                        [
                            29,
                            30
                        ]
                    ]
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                true,
                false
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <queue>\n\nbool canFinish(int numCourses, std::vector<std::vector<int>>& prerequisites) {\n    std::vector<std::vector<int>> adj(numCourses);\n    std::vector<int> inDegree(numCourses, 0);\n    \n    for (auto& p : prerequisites) {\n        adj[p[1]].push_back(p[0]);\n        inDegree[p[0]]++;\n    }\n    \n    std::queue<int> q;\n    for (int i = 0; i < numCourses; i++) {\n        if (inDegree[i] == 0) q.push(i);\n    }\n    \n    while (!q.empty()) {\n        int currCourse = q.front();\n        q.pop();\n        numCourses--;\n        \n        for (int nextCourse : adj[currCourse]) {\n            inDegree[nextCourse]--;\n            if (inDegree[nextCourse] == 0) q.push(nextCourse);\n        }\n    }\n    \n    return numCourses == 0;\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic boolean canFinish(int numCourses, int[][] prerequisites) {\n    List<List<Integer>> adj = new ArrayList<>(numCourses);\n    int[] inDegree = new int[numCourses];\n    \n    for (int i = 0; i < numCourses; i++)\n        adj.add(new ArrayList<>());\n    \n    for (int[] p : prerequisites) {\n        adj.get(p[1]).add(p[0]);\n        inDegree[p[0]]++;\n    }\n    \n    Queue<Integer> q = new LinkedList<>();\n    for (int i = 0; i < numCourses; i++) {\n        if (inDegree[i] == 0) q.add(i);\n    }\n    \n    while (!q.isEmpty()) {\n        int currCourse = q.poll();\n        numCourses--;\n        \n        for (int nextCourse : adj.get(currCourse)) {\n            inDegree[nextCourse]--;\n            if (inDegree[nextCourse] == 0) q.add(nextCourse);\n        }\n    }\n    \n    return numCourses == 0;\n}\n\n",
            "python": "from collections import defaultdict, deque\n\ndef canFinish(numCourses, prerequisites):\n    adj = defaultdict(list)\n    inDegree = [0] * numCourses\n    \n    for a, b in prerequisites:\n        adj[b].append(a)\n        inDegree[a] += 1\n    \n    q = deque([i for i in range(numCourses) if inDegree[i]==0])\n    \n    while q:\n        currCourse = q.popleft()\n        numCourses -= 1\n        \n        for nextCourse in adj[currCourse]:\n            inDegree[nextCourse] -= 1\n            if inDegree[nextCourse] == 0:\n                q.append(nextCourse)\n    \n    return numCourses == 0\n\n",
            "javascript": "function canFinish(numCourses, prerequisites) {\n    let adj = Array.from(Array(numCourses), () => []);\n    let inDegree = Array(numCourses).fill(0);\n    \n    for (let [a, b] of prerequisites) {\n        adj[b].push(a);\n        inDegree[a]++;\n    }\n    \n    let q = [];\n    for (let i = 0; i < numCourses; i++) {\n        if (inDegree[i] === 0) q.push(i);\n    }\n    \n    while (q.length) {\n        const currCourse = q.shift();\n        numCourses--;\n        \n        for (let nextCourse of adj[currCourse]) {\n            inDegree[nextCourse]--;\n            if (inDegree[nextCourse] === 0) q.push(nextCourse);\n        }\n    }\n    \n    return numCourses === 0;\n}\n\n",
            "explanation": "The algorithm uses the topological sorting approach utilizing Kahn's Algorithm to solve this problem. We maintain an adjacency list to represent the graph and a list of in-degrees for each vertex (course) Mark the vertices with in-degree 0 and add them to a queue (these are starter courses). Then, we process each node (course) in the queue, decrease in-degrees of their neighbors (courses they unlock). If the in-degree of any neighbor becomes 0, add it to the queue. In the end, if we have processed all courses, return true; otherwise, return false if any course is not processed."
        },
        "structure": {
            "c++": "#include <vector>\n#include <queue>\n\nbool canFinish(int numCourses, std::vector<std::vector<int>>& prerequisites)  {\n    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic boolean canFinish(int numCourses, int[][] prerequisites)  {\n    // Your code here\n}\n\n",
            "python": "from collections import defaultdict, deque\n    # Your code here\n\n",
            "javascript": "function canFinish(numCourses, prerequisites)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <queue>\n#include <iostream>\n\nint main() {\n    int numCourses = $args;\n    std::vector<std::vector<int>> prerequisites;\n    bool result = canFinish(numCourses, prerequisites);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}\n",
            "java": "public boolean canFinish(int numCourses, int[][] prerequisites) {\n    List<List<Integer>> adj = new ArrayList<>(numCourses);\n    int[] inDegree = new int[numCourses];\n    \n    for (int i = 0; i < numCourses; i++)\n        adj.add(new ArrayList<>());\n    \n    for (int[] p : prerequisites) {\n        adj.get(p[1]).add(p[0]);\n        inDegree[p[0]]++;\n    }\n    \n    Queue<Integer> q = new LinkedList<>();\n    for (int i = 0; i < numCourses; i++) {\n        if (inDegree[i] == 0) q.add(i);\n    }\n    \n    while (!q.isEmpty()) {\n        int currCourse = q.poll();\n        numCourses--;\n        \n        for (int nextCourse : adj.get(currCourse)) {\n            inDegree[nextCourse]--;\n            if (inDegree[nextCourse] == 0) q.add(nextCourse);\n        }\n    }\n    \n    return numCourses == 0;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    numCourses = inputs[0]\n    prerequisites = inputs[1]\n    result = canFinish(numCourses, prerequisites)\n    print(result)",
            "javascript": "function main() {\n    const numCourses = $args[0];\n    const prerequisites = $args[1];\n    const result = canFinish(numCourses, prerequisites);\n    console.log(result);\n}"
        },
        "Qid": "207"
    },
    {
        "_id": {
            "$oid": "661dacd7949b33b6c4e2b0c5"
        },
        "title": "Minimal Length of Subarray",
        "description": "Given an array of positive integers `nums` and a positive integer `target`, find the minimal length of a subarray whose sum is greater than or equal to the target. If there is no such subarray, return 0 instead.",
        "example": "Example:\n\nInput: target = 7, nums = [2,3,1,2,4,3]\nOutput: 2\nExplanation: The subarray [4,3] has the minimal length under the problem constraint.",
        "level": "Medium",
        "tags": [
            "array",
            "sliding window"
        ],
        "test_cases": {
            "inputs": [
                [
                    7,
                    [
                        2,
                        3,
                        1,
                        2,
                        4,
                        3
                    ]
                ],
                [
                    4,
                    [
                        1,
                        4,
                        4
                    ]
                ],
                [
                    11,
                    [
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1
                    ]
                ],
                [
                    5,
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ]
                ],
                [
                    10,
                    [
                        5,
                        5,
                        5,
                        5,
                        5
                    ]
                ],
                [
                    3,
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ]
                ],
                [
                    8,
                    [
                        2,
                        2,
                        2,
                        2,
                        2,
                        2,
                        2,
                        2
                    ]
                ],
                [
                    6,
                    [
                        1,
                        2,
                        3
                    ]
                ],
                [
                    9,
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9
                    ]
                ],
                [
                    15,
                    [
                        10,
                        5,
                        3,
                        2,
                        1
                    ]
                ]
            ],
            "outputs": [
                2,
                1,
                0,
                1,
                1,
                0,
                1,
                1,
                1,
                1
            ]
        },
        "sample_code": {
            "c++": "#include <climits>\nint minSubArrayLen(int target, vector<int>& nums) {\n    int left = 0, cur_sum = 0, min_len = INT_MAX;\n    for (int right = 0; right < nums.size(); right++) {\n        cur_sum += nums[right];\n        while (cur_sum >= target) {\n            min_len = min(min_len, right - left + 1);\n            cur_sum -= nums[left++];\n        }\n    }\n    return min_len == INT_MAX ? 0 : min_len;\n}\n",
            "java": "public int minSubArrayLen(int target, int[] nums) {\n    int left = 0, cur_sum = 0, min_len = Integer.MAX_VALUE;\n    for (int right = 0; right < nums.length; right++) {\n        cur_sum += nums[right];\n        while (cur_sum >= target) {\n            min_len = Math.min(min_len, right - left + 1);\n            cur_sum -= nums[left++];\n        }\n    }\n    return min_len == Integer.MAX_VALUE ? 0 : min_len;\n}\n",
            "python": "def minSubArrayLen(target: int, nums: list[int]) -> int:\n    left, cur_sum, min_len = 0, 0, float('inf')\n    for right in range(len(nums)):\n        cur_sum += nums[right]\n        while cur_sum >= target:\n            min_len = min(min_len, right - left + 1)\n            cur_sum -= nums[left]\n            left += 1\n    return min_len if min_len != float('inf') else 0\n",
            "javascript": "function minSubArrayLen(target, nums) {\n    let left = 0, cur_sum = 0, min_len = Number.MAX_VALUE;\n    for (let right = 0; right < nums.length; right++) {\n        cur_sum += nums[right];\n        while (cur_sum >= target) {\n            min_len = Math.min(min_len, right - left + 1);\n            cur_sum -= nums[left++];\n        }\n    }\n    return min_len === Number.MAX_VALUE ? 0 : min_len;\n}\n\n",
            "explanation": "The algorithm initializes pointers left and right, sum cur_sum, and minimum length min_len. The right pointer traverses nums. During traversal, update cur_sum by adding nums[right]. Then check if cur_sum is greater than or equal to target. If so, update min_len by comparing min_len and the length of the current subarray (right - left + 1). Then update cur_sum by subtracting nums[left] and increment the left pointer. Continue this process until the end of nums is reached. If min_len is still at its max value at the end, return 0. Otherwise, return min_len.\n\nThis algorithm uses a sliding window technique to iterate through the array while maintaining subarray sums greater than or equal to the target."
        },
        "structure": {
            "c++": "#include <climits>\nint minSubArrayLen(int target, vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "public int minSubArrayLen(int target, int[] nums)  {\n    // Your code here\n}\n",
            "python": "def minSubArrayLen(target: int, nums: List[int]) -> int:\n    # Your code here\n\n",
            "javascript": "function minSubArrayLen(target, nums)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <climits>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nint minSubArrayLen(int target, vector<int>& nums) {\n    int left = 0, cur_sum = 0, min_len = INT_MAX;\n    for (int right = 0; right < nums.size(); right++) {\n        cur_sum += nums[right];\n        while (cur_sum >= target) {\n            min_len = min(min_len, right - left + 1);\n            cur_sum -= nums[left++];\n        }\n    }\n    return min_len == INT_MAX ? 0 : min_len;\n}\n\nint main() {\n    int target = $args;\n    vector<int> nums = {1, 4, 4};\n    int result = minSubArrayLen(target, nums);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int minSubArrayLen(int target, int[] nums) {\n    int left = 0, cur_sum = 0, min_len = Integer.MAX_VALUE;\n    for (int right = 0; right < nums.length; right++) {\n        cur_sum += nums[right];\n        while (cur_sum >= target) {\n            min_len = Math.min(min_len, right - left + 1);\n            cur_sum -= nums[left++];\n        }\n    }\n    return min_len == Integer.MAX_VALUE ? 0 : min_len;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    target = inputs[0]\n    nums = inputs[1]\n    result = minSubArrayLen(target, nums)\n    print(result)",
            "javascript": ""
        },
        "Qid": "209"
    },
    {
        "_id": {
            "$oid": "661dad88949b33b6c4e2b0c6"
        },
        "title": "Word Search II",
        "description": "Given an `m x n` board of characters and a list of strings `words`, return all words on the board. Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.",
        "example": "Example 1:\n\nInput: board = [['o', 'a', 'a', 'n'], ['e', 't', 'a', 'e'], ['i', 'h', 'k', 'r'], ['i', 'f', 'l', 'v']], words = ['oath', 'pea', 'eat', 'rain']\nOutput: ['eat', 'oath']\n\nExample 2:\n\nInput: board = [['a', 'b'], ['c', 'd']], words = ['abcb']\nOutput: []",
        "level": "Medium",
        "tags": [
            "Array",
            "Backtracking",
            "Trie"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        [
                            "o",
                            "a",
                            "a",
                            "n"
                        ],
                        [
                            "e",
                            "t",
                            "a",
                            "e"
                        ],
                        [
                            "i",
                            "h",
                            "k",
                            "r"
                        ],
                        [
                            "i",
                            "f",
                            "l",
                            "v"
                        ]
                    ],
                    [
                        "oath",
                        "pea",
                        "eat",
                        "rain"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b"
                        ],
                        [
                            "c",
                            "d"
                        ]
                    ],
                    [
                        "abcb"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "abc",
                        "def",
                        "ghi"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "ab",
                        "de",
                        "gh"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "ab",
                        "cd",
                        "ef",
                        "gh",
                        "ij"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jkl"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jkl",
                        "mno"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jkl",
                        "mno",
                        "pqr"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jkl",
                        "mno",
                        "pqr",
                        "stu"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jkl",
                        "mno",
                        "pqr",
                        "stu",
                        "vwx"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jkl",
                        "mno",
                        "pqr",
                        "stu",
                        "vwx",
                        "yz"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "cba",
                        "fed",
                        "ihg"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "cba",
                        "fed",
                        "ihg",
                        "lkj"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "cba",
                        "fed",
                        "ihg",
                        "lkj",
                        "onm"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "cba",
                        "fed",
                        "ihg",
                        "lkj",
                        "onm",
                        "qrp"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "cba",
                        "fed",
                        "ihg",
                        "lkj",
                        "onm",
                        "qrp",
                        "tsu"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "cba",
                        "fed",
                        "ihg",
                        "lkj",
                        "onm",
                        "qrp",
                        "tsu",
                        "wvx"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "cba",
                        "fed",
                        "ihg",
                        "lkj",
                        "onm",
                        "qrp",
                        "tsu",
                        "wvx",
                        "zyx"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jkl",
                        "mno",
                        "pqr",
                        "stu",
                        "vwx",
                        "yz",
                        "cba",
                        "fed",
                        "ihg",
                        "lkj",
                        "onm",
                        "qrp",
                        "tsu",
                        "wvx",
                        "zyx"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "xyz",
                        "wvu",
                        "tsr",
                        "pon",
                        "mlk",
                        "ihg",
                        "fed",
                        "cba"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "xyz",
                        "wvu",
                        "tsr",
                        "pon",
                        "mlk",
                        "ihg",
                        "fed",
                        "cba",
                        "zyx",
                        "wvu",
                        "tsr",
                        "pon",
                        "mlk",
                        "ihg",
                        "fed",
                        "cba"
                    ]
                ],
                [
                    [
                        [
                            "a",
                            "b",
                            "c"
                        ],
                        [
                            "d",
                            "e",
                            "f"
                        ],
                        [
                            "g",
                            "h",
                            "i"
                        ]
                    ],
                    [
                        "abc",
                        "def",
                        "ghi",
                        "jkl",
                        "mno",
                        "pqr",
                        "stu",
                        "vwx",
                        "yz",
                        "cba",
                        "fed",
                        "ihg",
                        "lkj",
                        "onm",
                        "qrp",
                        "tsu",
                        "wvx",
                        "zyx",
                        "xyz",
                        "wvu",
                        "tsr",
                        "pon",
                        "mlk",
                        "ihg",
                        "fed",
                        "cba"
                    ]
                ]
            ],
            "outputs": [
                "['eat', 'oath']",
                "[]",
                "['abc', 'def', 'ghi']",
                "['ab', 'de', 'gh']",
                "['ab', 'cd', 'ef', 'gh', 'ij']",
                "['abc', 'def', 'ghi', 'jkl']",
                "['abc', 'def', 'ghi', 'jkl', 'mno']",
                "['abc', 'def', 'ghi', 'jkl', 'mno', 'pqr']",
                "['abc', 'def', 'ghi', 'jkl', 'mno', 'pqr', 'stu']",
                "['abc', 'def', 'ghi', 'jkl', 'mno', 'pqr', 'stu', 'vwx']",
                "['abc', 'def', 'ghi', 'jkl', 'mno', 'pqr', 'stu', 'vwx', 'yz']",
                "['cba', 'fed', 'ihg']",
                "['cba', 'fed', 'ihg', 'lkj']",
                "['cba', 'fed', 'ihg', 'lkj', 'onm']",
                "['cba', 'fed', 'ihg', 'lkj', 'onm', 'qrp']",
                "['cba', 'fed', 'ihg', 'lkj', 'onm', 'qrp', 'tsu']",
                "['cba', 'fed', 'ihg', 'lkj', 'onm', 'qrp', 'tsu', 'wvx']",
                "['cba', 'fed', 'ihg', 'lkj', 'onm', 'qrp', 'tsu', 'wvx', 'zyx']",
                "['abc', 'def', 'ghi', 'jkl', 'mno', 'pqr', 'stu', 'vwx', 'yz', 'cba', 'fed', 'ihg', 'lkj', 'onm', 'qrp', 'tsu', 'wvx', 'zyx']",
                "['xyz', 'wvu', 'tsr', 'pon', 'mlk', 'ihg', 'fed', 'cba']",
                "['xyz', 'wvu', 'tsr', 'pon', 'mlk', 'ihg', 'fed', 'cba', 'zyx', 'wvu', 'tsr', 'pon', 'mlk', 'ihg', 'fed', 'cba']",
                "['abc', 'def', 'ghi', 'jkl', 'mno', 'pqr', 'stu', 'vwx', 'yz', 'cba', 'fed', 'ihg', 'lkj', 'onm', 'qrp', 'tsu', 'wvx', 'zyx', 'xyz', 'wvu', 'tsr', 'pon', 'mlk', 'ihg', 'fed', 'cba']"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n\nvoid dfs(const std::vector<std::vector<char>>& board, const std::string& word, int index, int i, int j, std::vector<std::vector<bool>>& visited, bool& found){\n    if (index == word.length()) {\n        found = true;\n        return;\n    }\n    if (i < 0 || j < 0 || i >= board.size() || j >= board[0].size() || visited[i][j] || board[i][j] != word[index]){\n        return;\n    }\n    visited[i][j] = true;\n    dfs(board, word, index + 1, i - 1, j, visited, found);\n    dfs(board, word, index + 1, i + 1, j, visited, found);\n    dfs(board, word, index + 1, i, j - 1, visited, found);\n    dfs(board, word, index + 1, i, j + 1, visited, found);\n    visited[i][j] = false;\n}\n\nstd::vector<std::string> findWords(std::vector<std::vector<char>>& board, std::vector<std::string>& words) {\n    std::vector<std::string> result;\n    for (const auto& word : words) {\n        bool found = false;\n        std::vector<std::vector<bool>> visited(board.size(), std::vector<bool>(board[0].size(), false));\n        for (int i = 0; i < board.size() && !found; ++i) {\n            for (int j = 0; j < board[0].size() && !found; ++j) {\n                dfs(board, word, 0, i, j, visited, found);\n            }\n        }\n        if (found) {\n            result.push_back(word);\n        }\n    }\n    return result;\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> findWords(char[][] board, String[] words) {\n    List<String> result = new ArrayList<>();\n    for (String word : words) {\n        if (exist(board, word)) {\n            result.add(word);\n        }\n    }\n    return result;\n}\n\nprivate boolean exist(char[][] board, String word) {\n    int m = board.length;\n    int n = board[0].length;\n    boolean[][] visited = new boolean[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dfs(board, word, 0, i, j, visited)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean dfs(char[][] board, String word, int index, int i, int j, boolean[][] visited) {\n    if (index == word.length()) {\n        return true;\n    }\n    if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j] || board[i][j] != word.charAt(index)) {\n        return false;\n    }\n    visited[i][j] = true;\n    boolean found =\n            dfs(board, word, index + 1, i - 1, j, visited) ||\n            dfs(board, word, index + 1, i + 1, j, visited) ||\n            dfs(board, word, index + 1, i, j - 1, visited) ||\n            dfs(board, word, index + 1, i, j + 1, visited);\n    visited[i][j] = false;\n    return found;\n}\n\n",
            "python": "def findWords(board, words):\n    def dfs(board, word, index, i, j, visited):\n        if index == len(word):\n            return True\n        if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or visited[i][j] or board[i][j] != word[index]:\n            return False\n        visited[i][j] = True\n        found = dfs(board, word, index + 1, i - 1, j, visited) or \\\n                dfs(board, word, index + 1, i + 1, j, visited) or \\\n                dfs(board, word, index + 1, i, j - 1, visited) or \\\n                dfs(board, word, index + 1, i, j + 1, visited)\n        visited[i][j] = False\n        return found\n\n    res = []\n    for word in words:\n        if any(dfs(board, word, 0, i, j, [[False] * len(board[0]) for _ in range(len(board))])\n               for i in range(len(board)) for j in range(len(board[0]))):\n            res.append(word)\n    return res\n\n",
            "javascript": "function findWords(board, words) {\n    function dfs(board, word, index, i, j, visited) {\n        if (index === word.length) {\n            return true;\n        }\n        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j] || board[i][j] !== word.charAt(index)) {\n            return false;\n        }\n        visited[i][j] = true;\n        const found = dfs(board, word, index + 1, i - 1, j, visited) ||\n                      dfs(board, word, index + 1, i + 1, j, visited) ||\n                      dfs(board, word, index + 1, i, j - 1, visited) ||\n                      dfs(board, word, index + 1, i, j + 1, visited);\n        visited[i][j] = false;\n        return found;\n    }\n\n    const res = [];\n    for (const word of words) {\n        let found = false;\n        for (let i = 0; i < board.length && !found; i++) {\n            for (let j = 0; j < board[0].length && !found; j++) {\n                if (dfs(board, word, 0, i, j, Array.from({ length: board.length }, () => Array(board[0].length).fill(false)))) {\n                    found = true;\n                }\n            }\n        }\n        if (found) {\n            res.push(word);\n        }\n    }\n    return res;\n}\n\n",
            "explanation": "The algorithm uses Depth First Search (DFS) to search for each word in the board. For each word, we iterate through all the cells in the board and start the DFS search if the current cell matches the word's first letter. During the DFS search, we mark the cell as visited and only continue the search if the next cell we are going to move to is not yet visited, in the allowed board bounds, and it matches the next character of the word. If we reached the end of the word, then we know that this word is found in the board.\n\nFor each programming language, we implemented the `findWords` function that takes the `board` and the `words` as an input and returns a list of found words. The core algorithm is the same, but the language-specific syntax and constructs are used accordingly."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n\nvoid dfs(const std::vector<std::vector<char>>& board, const std::string& word, int index, int i, int j, std::vector<std::vector<bool>>& visited, bool& found)\n {    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> findWords(char[][] board, String[] words)  {\n    // Your code here\n}\n\n",
            "python": "def findWords(board, words):\n    # Your code here\n\n",
            "javascript": "function findWords(board, words)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "std::vector<std::string> findWords(std::vector<std::vector<char>>& board, std::vector<std::string>& words) {\n    std::vector<std::string> result;\n    for (const auto& word : words) {\n        bool found = false;\n        std::vector<std::vector<bool>> visited(board.size(), std::vector<bool>(board[0].size(), false));\n        for (int i = 0; i < board.size() && !found; ++i) {\n            for (int j = 0; j < board[0].size() && !found; ++j) {\n                dfs(board, word, 0, i, j, visited, found);\n            }\n        }\n        if (found) {\n            result.push_back(word);\n        }\n    }\n    return result;\n}\n",
            "java": "public List<String> findWords(char[][] board, String[] words) {\n    List<String> result = new ArrayList<>();\n    for (String word : words) {\n        if (exist(board, word)) {\n            result.add(word);\n        }\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    board = inputs[0]\n    words = inputs[1]\n    result = findWords(board, words)\n    print(result)",
            "javascript": "function findWords(board, words) {\n    function dfs(board, word, index, i, j, visited) {\n        if (index === word.length) {\n            return true;\n        }\n        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j] || board[i][j] !== word.charAt(index)) {\n            return false;\n        }\n        visited[i][j] = true;\n        const found = dfs(board, word, index + 1, i - 1, j, visited) ||\n                      dfs(board, word, index + 1, i + 1, j, visited) ||\n                      dfs(board, word, index + 1, i, j - 1, visited) ||\n                      dfs(board, word, index + 1, i, j + 1, visited);\n        visited[i][j] = false;\n        return found;\n    }\n\n    const res = [];\n    for (const word of words) {\n        let found = false;\n        for (let i = 0; i < board.length && !found; i++) {\n            for (let j = 0; j < board[0].length && !found; j++) {\n                if (dfs(board, word, 0, i, j, Array.from({ length: board.length }, () => Array(board[0].length).fill(false)))) {\n                    found = true;\n                }\n            }\n        }\n        if (found) {\n            res.push(word);\n        }\n    }\n    return res;\n}"
        },
        "Qid": "212"
    },
    {
        "_id": {
            "$oid": "661dadb4949b33b6c4e2b0c7"
        },
        "title": "Shortest Palindrome",
        "description": "Given a string `s`, you can convert it to a palindrome by adding characters in front of it. Write a function that returns the shortest palindrome you can find by performing this transformation.",
        "example": "Example 1:\n\nInput: s = \"aacecaaa\"\nOutput: \"aaacecaaa\"\n\nExample 2:\n\nInput: s = \"abcd\"\nOutput: \"dcbabcd\"",
        "level": "Medium",
        "tags": [
            "string",
            "palindrome"
        ],
        "test_cases": {
            "inputs": [
                "\"aacecaaa\"",
                "\"abcd\"",
                "\"race\"",
                "\"level\"",
                "\"madam\"",
                "\"abc\"",
                "\"a\"",
                "\"\"",
                "\"aaaaa\"",
                "\"aabbaa\"",
                "\"abcdeedcba\"",
                "\"abcdefedcba\"",
                "\"aaaaaabaaaaa\"",
                "\"abcdeedcbaabcdeedcba\"",
                "\"abcdefghgfedcba\"",
                "\"aaaaaabaaaaaabaaaaa\"",
                "\"abcdeedcbaabcdeedcbaabcdeedcba\"",
                "\"abcdefghgfedcbaabcdefghgfedcba\"",
                "\"aaaaaabaaaaaabaaaaaabaaaaa\"",
                "\"abcdeedcbaabcdeedcbaabcdeedcbaabcdeedcba\""
            ],
            "outputs": [
                "\"aaacecaaa\"",
                "\"dcbabcd\"",
                "\"ecarace\"",
                "\"level\"",
                "\"madam\"",
                "\"cba\"",
                "\"a\"",
                "\"\"",
                "\"aaaaa\"",
                "\"aabbaa\"",
                "\"abcdeedcba\"",
                "\"abcdefedcba\"",
                "\"aaaaaabaaaaa\"",
                "\"abcdeedcbaabcdeedcba\"",
                "\"abcdefghgfedcba\"",
                "\"aaaaaabaaaaaabaaaaa\"",
                "\"abcdeedcbaabcdeedcbaabcdeedcba\"",
                "\"abcdefghgfedcbaabcdefghgfedcba\"",
                "\"aaaaaabaaaaaabaaaaaabaaaaa\"",
                "\"abcdeedcbaabcdeedcbaabcdeedcbaabcdeedcba\""
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n\nstd::string shortestPalindrome(std::string s) {\n    int n = s.size();\n    std::string rev_s = s;\n    std::reverse(rev_s.begin(), rev_s.end());\n    \n    for (int i = 0; i < n; ++i) {\n        if(s.substr(0, n - i) == rev_s.substr(i))\n            return rev_s.substr(0, i) + s;\n    }\n    return \"\";\n}\n\n",
            "java": "public String shortestPalindrome(String s) {\n    int n = s.length();\n    String rev_s = new StringBuilder(s).reverse().toString();\n    \n    for (int i = 0; i < n; ++i) {\n        if(s.substring(0, n - i).equals(rev_s.substring(i)))\n            return rev_s.substring(0, i) + s;\n    }\n    return \"\";\n}\n\n",
            "python": "def shortest_palindrome(s: str) -> str:\n    n = len(s)\n    rev_s = s[::-1]\n    \n    for i in range(n):\n        if s[:n - i] == rev_s[i:]:\n            return rev_s[:i] + s\n    return \"\"\n\n",
            "javascript": "function shortestPalindrome(s) {\n    let n = s.length;\n    let rev_s = s.split('').reverse().join('');\n    \n    for (let i = 0; i < n; ++i) {\n        if (s.slice(0, n - i) === rev_s.slice(i))\n            return rev_s.slice(0, i) + s;\n    }\n    return \"\";\n}\n\n",
            "explanation": "1. Take input string `s`.\n2. Get string `rev_s` by reversing the input string.\n3. Iterate through the characters in both strings.\n4. For each index `i`, compare the substring `[0, n - i)` of `s` and substring `[i, n)` of `rev_s`.\n5. If the substrings match, concatenate the non-matching substring of `rev_s` and the original input string `s`. This will result in the shortest palindromic string we can build.\n6. If not, continue with the next iteration.\n7. The function returns an empty string if an exception occurs."
        },
        "structure": {
            "c++": "#include <string>\n\nstd::string shortestPalindrome(std::string s)  {\n    // Your code here\n}\n\n",
            "java": "public String shortestPalindrome(String s)  {\n    // Your code here\n}\n\n",
            "python": "def shortest_palindrome(s: str) -> str:\n    # Your code here\n\n",
            "javascript": "function shortestPalindrome(s)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <iostream>\n\nstd::string shortestPalindrome(std::string s);\n\nint main() {\n    std::string s = $args;\n    std::string result = shortestPalindrome(s);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public String shortestPalindrome(String s) {\n    int n = s.length();\n    String rev_s = new StringBuilder(s).reverse().toString();\n    \n    for (int i = 0; i < n; ++i) {\n        if(s.substring(0, n - i).equals(rev_s.substring(i)))\n            return rev_s.substring(0, i) + s;\n    }\n    return \"\";\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = shortest_palindrome(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = shortestPalindrome(s);\n    console.log(result);\n}\n"
        },
        "Qid": "214"
    },
    {
        "_id": {
            "$oid": "661dae26949b33b6c4e2b0c8"
        },
        "title": "Valid Combinations",
        "description": "Given a positive integer `k` and a target sum `n`, find all valid combinations of `k` numbers that sum up to `n`. The numbers used must be in the range from 1 to 9, and each number can be used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.",
        "example": "Example:\n\nInput: k = 3, n = 7\nOutput: [[1,2,4]]\nExplanation: 1 + 2 + 4 = 7\n\nInput: k = 3, n = 9\nOutput: [[1,2,6],[1,3,5],[2,3,4]]\nExplanation: 1 + 2 + 6 = 9, 1 + 3 + 5 = 9, 2 + 3 + 4 = 9\n\nInput: k = 4, n = 1\nOutput: []\nExplanation: There are no valid combinations. Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combinations.",
        "level": "Medium",
        "tags": [
            "backtracking",
            "combinations"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    7
                ],
                [
                    3,
                    9
                ],
                [
                    4,
                    1
                ],
                [
                    2,
                    5
                ],
                [
                    5,
                    15
                ],
                [
                    6,
                    30
                ],
                [
                    7,
                    45
                ],
                [
                    8,
                    60
                ],
                [
                    9,
                    55
                ],
                [
                    3,
                    15
                ],
                [
                    4,
                    20
                ],
                [
                    5,
                    25
                ],
                [
                    6,
                    30
                ],
                [
                    7,
                    35
                ],
                [
                    8,
                    40
                ],
                [
                    9,
                    45
                ],
                [
                    3,
                    18
                ],
                [
                    4,
                    22
                ],
                [
                    5,
                    27
                ],
                [
                    6,
                    33
                ]
            ],
            "outputs": [
                [
                    [
                        1,
                        2,
                        4
                    ]
                ],
                [
                    [
                        1,
                        2,
                        6
                    ],
                    [
                        1,
                        3,
                        5
                    ],
                    [
                        2,
                        3,
                        4
                    ]
                ],
                [],
                [
                    [
                        2,
                        3
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        6,
                        9,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        17
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        24
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        5,
                        9
                    ]
                ],
                [
                    [
                        1,
                        4,
                        6,
                        4,
                        0,
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1,
                        5,
                        6,
                        4,
                        4,
                        0,
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1,
                        6,
                        7,
                        5,
                        4,
                        2,
                        0,
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1,
                        7,
                        8,
                        6,
                        5,
                        3,
                        2,
                        0,
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1,
                        8,
                        9,
                        7,
                        6,
                        4,
                        3,
                        1,
                        0,
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1,
                        9,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        2,
                        0,
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1,
                        6,
                        11
                    ]
                ],
                [
                    [
                        1,
                        7,
                        14,
                        0
                    ]
                ],
                [
                    [
                        1,
                        8,
                        16,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1,
                        9,
                        18,
                        0,
                        0,
                        0
                    ]
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nvoid helper(int k, int n, int current, std::vector<int>& current_comb, std::vector<std::vector<int>>& result) {\n    if (k == 0 && n == 0) {\n        result.push_back(current_comb);\n    } else if (k > 0 && n > 0) {\n        for (int i = current + 1; i <= 9; ++i) {\n            current_comb.push_back(i);\n            helper(k - 1, n - i, i, current_comb, result);\n            current_comb.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<int>> combinationSum3(int k, int n) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> current_comb;\n    helper(k, n, 0, current_comb, result);\n    return result;\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> combinationSum3(int k, int n) {\n    List<List<Integer>> result = new ArrayList<>();\n    helper(k, n, 0, new ArrayList<>(), result);\n    return result;\n}\n\nprivate void helper(int k, int n, int current, List<Integer> currentComb, List<List<Integer>> result) {\n    if (k == 0 && n == 0) {\n        result.add(new ArrayList<>(currentComb));\n    } else if (k > 0 && n > 0) {\n        for (int i = current + 1; i <= 9; i++) {\n            currentComb.add(i);\n            helper(k - 1, n - i, i, currentComb, result);\n            currentComb.remove(currentComb.size() - 1);\n        }\n    }\n}\n\n",
            "python": "def combinationSum3(k, n):\n    def helper(k, n, current, current_comb, result):\n        if k == 0 and n == 0:\n            result.append(list(current_comb))\n        elif k > 0 and n > 0:\n            for i in range(current + 1, 10):\n                current_comb.append(i)\n                helper(k - 1, n - i, i, current_comb, result)\n                current_comb.pop()\n\n    result = []\n    helper(k, n, 0, [], result)\n    return result\n\n",
            "javascript": "function combinationSum3(k, n) {\n  function helper(k, n, current, currentComb, result) {\n    if (k === 0 && n === 0) {\n      result.push([...currentComb]);\n    } else if (k > 0 && n > 0) {\n      for (let i = current + 1; i <= 9; i++) {\n        currentComb.push(i);\n        helper(k - 1, n - i, i, currentComb, result);\n        currentComb.pop();\n      }\n    }\n  }\n\n  const result = [];\n  helper(k, n, 0, [], result);\n  return result;\n}\n\n",
            "explanation": "The algorithm is based on a backtracking approach. We use a helper function which takes some parameters: `k` and `n` to limit the combinations, `current` which is the last considered element, `current_comb` which is the current combination being formed, and `result` which is the list of all valid combinations found so far.\n\nWe keep updating the current combination and decreasing `k` and `n` accordingly as we call the helper function recursively. When we have `k = 0` and `n = 0`, we know we have reached a valid combination and add it to our result list. To prevent revisiting the same combinations, we make sure that the numbers are considered in increasing order (thus, the current value being picked always starts at `current + 1`).\n\nWhen backtracking, we remove the last considered element from the current combination so that we can try another combination. Following this approach ensures that we visit every potential combination only once and store it if it is valid."
        },
        "structure": {
            "c++": "#include <vector>\n\nvoid helper(int k, int n, int current, std::vector<int>& current_comb, std::vector<std::vector<int>>& result)  {\n    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> combinationSum3(int k, int n)  {\n    // Your code here\n}\n\n",
            "python": "def combinationSum3(k, n):\n    # Your code here\n\n",
            "javascript": "function combinationSum3(k, n)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nvoid helper(int k, int n, int current, std::vector<int>& current_comb, std::vector<std::vector<int>>& result) {\n    if (k == 0 && n == 0) {\n        result.push_back(current_comb);\n    } else if (k > 0 && n > 0) {\n        for (int i = current + 1; i <= 9; ++i) {\n            current_comb.push_back(i);\n            helper(k - 1, n - i, i, current_comb, result);\n            current_comb.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<int>> combinationSum3(int k, int n) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> current_comb;\n    helper(k, n, 0, current_comb, result);\n    return result;\n}\n\nint main() {\n    int k = $args;\n    int n = $args;\n    std::vector<std::vector<int>> result = combinationSum3(k, n);\n    for (const auto& comb : result) {\n        for (const auto& num : comb) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}",
            "java": "public List<List<Integer>> combinationSum3(int k, int n) {\n    List<List<Integer>> result = new ArrayList<>();\n    helper(k, n, 0, new ArrayList<>(), result);\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    k = inputs[0]\n    n = inputs[1]\n    result = combinationSum3(k, n)\n    print(result)",
            "javascript": ""
        },
        "Qid": "216"
    },
    {
        "_id": {
            "$oid": "661dae42949b33b6c4e2b0c9"
        },
        "title": "Duplicate Integer Check",
        "description": "Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.",
        "example": "Example:\n\nInput: nums = [1,2,3,1]\nOutput: true\n\nExplanation: The value 1 appears twice in the array.\n\nInput: nums = [1,2,3,4]\nOutput: false\n\nExplanation: Every element in the array is distinct.",
        "level": "Easy",
        "tags": [
            "array",
            "hash table"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4
                ],
                [
                    1,
                    1,
                    1,
                    3,
                    3,
                    4,
                    3,
                    2,
                    4,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                false,
                false,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "bool containsDuplicate(vector<int>& nums) {\n    unordered_set<int> s;\n    for (int num : nums) {\n        if (s.find(num) != s.end()) {\n            return true;\n        }\n        s.insert(num);\n    }\n    return false;\n}\n\n",
            "java": "public boolean containsDuplicate(int[] nums) {\n    Set<Integer> set = new HashSet<Integer>();\n    for (int num : nums) {\n        if (!set.add(num)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n",
            "python": "def containsDuplicate(nums):\n    return len(nums) != len(set(nums))\n\n",
            "javascript": "function containsDuplicate(nums) {\n    const set = new Set();\n    for (const num of nums) {\n        if (set.has(num)) {\n            return true;\n        }\n        set.add(num);\n    }\n    return false;\n}\n\n",
            "explanation": "The algorithm starts by creating an empty set. Then it iterates through the input array. For each number in the array, it checks if the number is already in the set. If the number is in the set, it means there's a duplicate, so it returns true. If the number is not in the set, it adds the number to the set. If the function has not returned true after iterating through the entire array, it means that there are no duplicates, so it returns false.\n\nIn Python, we use the fact that sets don't allow duplicates, so we can directly compare the length of the original list with the length of the set created from the list. If they are not equal, it means there are duplicates in the list, and the function returns true. Otherwise, it returns false."
        },
        "structure": {
            "c++": "bool containsDuplicate(vector<int>& nums)  {\n    // Your code here\n}\n\n",
            "java": "public boolean containsDuplicate(int[] nums)  {\n    // Your code here\n}\n\n",
            "python": "def containsDuplicate(nums):\n    # Your code here\n\n",
            "javascript": "function containsDuplicate(nums)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "bool containsDuplicate(vector<int>& nums) {\n    unordered_set<int> s;\n    for (int num : nums) {\n        if (s.find(num) != s.end()) {\n            return true;\n        }\n        s.insert(num);\n    }\n    return false;\n}",
            "java": "public boolean containsDuplicate(int[] nums) {\n    Set<Integer> set = new HashSet<Integer>();\n    for (int num : nums) {\n        if (!set.add(num)) {\n            return true;\n        }\n    }\n    return false;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = containsDuplicate(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = containsDuplicate(nums);\n    console.log(result);\n}\n"
        },
        "Qid": "217"
    },
    {
        "_id": {
            "$oid": "661db327949b33b6c4e2b0ca"
        },
        "title": "Basic Calculator",
        "description": "Given a string `s` representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation. You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.",
        "example": "Example:\n\nInput: s = \"1 + 1\"\nOutput: 2\n\nInput: s = \"2-1 + 2\"\nOutput: 3\n\nInput: s = \"(1+(4+5+2)-3)+(6+8)\"\nOutput: 23",
        "level": "Medium",
        "tags": [
            "stack",
            "math"
        ],
        "test_cases": {
            "inputs": [
                "\"1 + 1\"",
                "\"2-1 + 2\"",
                "\"(1+(4+5+2)-3)+(6+8)\"",
                "\"10 - 5 + 3\"",
                "\"(2+3) - (4-1)\"",
                "\"(1+2) - (3+4) + (5-6)\"",
                "\"1 + 2 - 3 + 4 - 5 + 6\"",
                "\"10 - (5 + 3)\"",
                "\"(2+3) - (4-1) + (5-6)\"",
                "\"(1+2) - (3+4) + (5-6) + (7-8)\"",
                "\"1 + 2 - 3 + 4 - 5 + 6 - 7\"",
                "\"100 - 50 + 30\"",
                "\"(20+30) - (40-10)\"",
                "\"(10+20) - (30+40) + (50-60)\"",
                "\"1 + 2 - 3 + 4 - 5 + 6 - 7 + 8\"",
                "\"100 - (50 + 30)\"",
                "\"(20+30) - (40-10) + (50-60)\"",
                "\"(10+20) - (30+40) + (50-60) + (70-80)\"",
                "\"1 + 2 - 3 + 4 - 5 + 6 - 7 + 8 - 9\"",
                "\"100 - (50 + 30) + (20-10)\"",
                "\"(20+30) - (40-10) + (50-60) - (70-80)\"",
                "\"(10+20) - (30+40) + (50-60) + (70-80) - (90-100)\""
            ],
            "outputs": [
                2,
                3,
                23,
                8,
                2,
                -1,
                5,
                2,
                0,
                -1,
                0,
                80,
                20,
                -10,
                -1,
                20,
                -10,
                -20,
                -1,
                30,
                -20,
                -40
            ]
        },
        "sample_code": {
            "c++": "int calculate(string s) {\n    int result = 0, sign = 1, num = 0;\n    stack<int> st;\n    for (char c : s) {\n        if (isdigit(c)) {\n            num = num * 10 + (c - '0');\n        } else {\n            result += sign * num;\n            num = 0;\n            if (c == '+') {\n                sign = 1;\n            } else if (c == '-') {\n                sign = -1;\n            } else if (c == '(') {\n                st.push(result);\n                st.push(sign);\n                result = 0;\n                sign = 1;\n            } else if (c == ')') {\n                int prev_sign = st.top();\n                st.pop();\n                int prev_result = st.top();\n                st.pop();\n                result = prev_result + prev_sign * result;\n            }\n        }\n    }\n    result += sign * num;\n    return result;\n}\n",
            "java": "public int calculate(String s) {\n    int result = 0, sign = 1, num = 0;\n    Stack<Integer> st = new Stack<>();\n    for (char c : s.toCharArray()) {\n        if (Character.isDigit(c)) {\n            num = num * 10 + (c - '0');\n        } else {\n            result += sign * num;\n            num = 0;\n            if (c == '+') {\n                sign = 1;\n            } else if (c == '-') {\n                sign = -1;\n            } else if (c == '(') {\n                st.push(result);\n                st.push(sign);\n                result = 0;\n                sign = 1;\n            } else if (c == ')') {\n                int prev_sign = st.pop();\n                int prev_result = st.pop();\n                result = prev_result + prev_sign * result;\n            }\n        }\n    }\n    result += sign * num;\n    return result;\n}\n",
            "python": "def calculate(s: str) -> int:\n    result = 0\n    sign = 1\n    num = 0\n    st = []\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        else:\n            result += sign * num\n            num = 0\n            if c == '+':\n                sign = 1\n            elif c == '-':\n                sign = -1\n            elif c == '(':\n                st.append(result)\n                st.append(sign)\n                result = 0\n                sign = 1\n            elif c == ')':\n                prev_sign = st.pop()\n                prev_result = st.pop()\n                result = prev_result + prev_sign * result\n    result += sign * num\n    return result\n",
            "javascript": "function calculate(s) {\n    let result = 0, sign = 1, num = 0;\n    let st = [];\n    for (let c of s) {\n        if (/\\d/.test(c)) {\n            num = num * 10 + (c - '0');\n        } else {\n            result += sign * num;\n            num = 0;\n            if (c === '+') {\n                sign = 1;\n            } else if (c === '-') {\n                sign = -1;\n            } else if (c === '(') {\n                st.push(result);\n                st.push(sign);\n                result = 0;\n                sign = 1;\n            } else if (c === ')') {\n                let prev_sign = st.pop();\n                let prev_result = st.pop();\n                result = prev_result + prev_sign * result;\n            }\n        }\n    }\n    result += sign * num;\n    return result;\n}\n",
            "explanation": "The algorithm first initializes variables `result`, `sign`, and `num` along with a stack `st`. It iterates through each character of the given string, `s`. If a digit is encountered, we update `num`, otherwise, if an operator, `(` or `)` is found, we perform the appropriate operation and update the variables accordingly. For example, we store the current result and sign onto the stack when we encounter a `(` and calculate the result when we encounter a `)` and use the stack to track the values of previous results and signs. Finally, we return the final result after the iteration is complete."
        },
        "structure": {
            "c++": "int calculate(string s)  {\n    // Your code here\n}\n",
            "java": "public int calculate(String s)  {\n    // Your code here\n}\n",
            "python": "def calculate(s: str) -> int:\n    # Your code here\n\n",
            "javascript": "function calculate(s)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    string s = $args;\n    int result = calculate(s);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int calculate(String s) {\n    int result = 0, sign = 1, num = 0;\n    Stack<Integer> st = new Stack<>();\n    for (char c : s.toCharArray()) {\n        if (Character.isDigit(c)) {\n            num = num * 10 + (c - '0');\n        } else {\n            result += sign * num;\n            num = 0;\n            if (c == '+') {\n                sign = 1;\n            } else if (c == '-') {\n                sign = -1;\n            } else if (c == '(') {\n                st.push(result);\n                st.push(sign);\n                result = 0;\n                sign = 1;\n            } else if (c == ')') {\n                int prev_sign = st.pop();\n                int prev_result = st.pop();\n                result = prev_result + prev_sign * result;\n            }\n        }\n    }\n    result += sign * num;\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    s =$args\n    result = calculate(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = calculate(s);\n    console.log(result);\n}"
        },
        "Qid": "224"
    },
    {
        "_id": {
            "$oid": "661db60f949b33b6c4e2b0cb"
        },
        "title": "Smallest Sorted Ranges",
        "description": "You are given a sorted unique integer array `nums`. A range `[a,b]` is the set of all integers from `a` to `b` (inclusive). Return the smallest sorted list of ranges that cover all the numbers in the array exactly. Each range `[a,b]` in the list should be output as: 'a->b' if `a != b` or 'a' if `a == b`.",
        "example": "Example:\n\nInput: nums = [0,1,2,4,5,7]\nOutput: ['0->2', '4->5', '7']\nExplanation: The ranges are:\n[0,2] --> '0->2'\n[4,5] --> '4->5'\n[7,7] --> '7'",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    0,
                    1,
                    2,
                    4,
                    5,
                    7
                ],
                [
                    0,
                    2,
                    3,
                    4,
                    6,
                    8,
                    9
                ],
                [],
                [
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50
                ],
                [
                    100,
                    200,
                    300,
                    400,
                    500
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100
                ],
                [
                    100,
                    200,
                    300,
                    400,
                    500,
                    600,
                    700,
                    800,
                    900,
                    1000
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100,
                    110
                ],
                [
                    100,
                    200,
                    300,
                    400,
                    500,
                    600,
                    700,
                    800,
                    900,
                    1000,
                    1100
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9,
                    11,
                    13,
                    15,
                    17,
                    19
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10,
                    12,
                    14,
                    16,
                    18,
                    20
                ],
                [
                    0,
                    2,
                    4,
                    6,
                    8,
                    10,
                    12,
                    14,
                    16,
                    18,
                    20
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ]
            ],
            "outputs": [
                [
                    "0->2",
                    "4->5",
                    "7"
                ],
                [
                    "0",
                    "2->4",
                    "6",
                    "8->9"
                ],
                [],
                [
                    "1"
                ],
                [
                    "1->5"
                ],
                [
                    "10->50"
                ],
                [
                    "100->500"
                ],
                [
                    "1",
                    "3",
                    "5",
                    "7",
                    "9"
                ],
                [
                    "2->10"
                ],
                [
                    "0->9"
                ],
                [
                    "10->100"
                ],
                [
                    "100->1000"
                ],
                [
                    "1->10"
                ],
                [
                    "10->110"
                ],
                [
                    "100->1100"
                ],
                [
                    "1->19"
                ],
                [
                    "2->20"
                ],
                [
                    "0->20"
                ],
                [
                    "1->20"
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n\nstd::vector<std::string> find_ranges(std::vector<int>& nums) {\n    std::vector<std::string> result;\n    int n = nums.size();\n    if (n == 0) return result;\n\n    int start = nums[0];\n    for (int i = 1; i < n; ++i) {\n        if (nums[i] > nums[i-1] + 1) {\n            if (start == nums[i-1])\n                result.push_back(std::to_string(start));\n            else\n                result.push_back(std::to_string(start) + \"->\" + std::to_string(nums[i-1]));\n            start = nums[i];\n        }\n    }\n\n    if (start == nums[n-1])\n        result.push_back(std::to_string(start));\n    else\n        result.push_back(std::to_string(start) + \"->\" + std::to_string(nums[n-1]));\n\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> findRanges(int[] nums) {\n    List<String> result = new ArrayList<>();\n    int n = nums.length;\n    if (n == 0) return result;\n\n    int start = nums[0];\n    for (int i = 1; i < n; i++) {\n        if (nums[i] > nums[i-1] + 1) {\n            if (start == nums[i-1])\n                result.add(Integer.toString(start));\n            else\n                result.add(start + \"->\" + nums[i-1]);\n            start = nums[i];\n        }\n    }\n\n    if (start == nums[n-1])\n        result.add(Integer.toString(start));\n    else\n        result.add(start + \"->\" + nums[n-1]);\n\n    return result;\n}\n",
            "python": "from typing import List\n\ndef find_ranges(nums: List[int]) -> List[str]:\n    result = []\n    n = len(nums)\n    if n == 0: \n        return result\n\n    start = nums[0]\n    for i in range(1, n):\n        if nums[i] > nums[i-1] + 1:\n            if start == nums[i-1]:\n                result.append(str(start))\n            else:\n                result.append(str(start) + \"->\" + str(nums[i-1]))\n            start = nums[i]\n\n    if start == nums[n-1]:\n        result.append(str(start))\n    else:\n        result.append(str(start) + \"->\" + str(nums[n-1]))\n\n    return result\n",
            "javascript": "function findRanges(nums) {\n    const result = [];\n    const n = nums.length;\n    if (n === 0) return result;\n\n    let start = nums[0];\n    for (let i = 1; i < n; i++) {\n        if (nums[i] > nums[i - 1] + 1) {\n            if (start === nums[i - 1])\n                result.push(`${start}`);\n            else\n                result.push(`${start}->${nums[i - 1]}`);\n            start = nums[i];\n        }\n    }\n\n    if (start === nums[n - 1])\n        result.push(`${start}`);\n    else\n        result.push(`${start}->${nums[n - 1]}`);\n\n    return result;\n}\n",
            "explanation": "The algorithm involves iterating through the input array and using a variable named `start` to keep track of the beginning of the current range. For each element, we compare it with the previous element to check if they form a continuous range by verifying if the current element is greater than the previous element plus 1. If they don't form a continuous range, we know that the current range has ended and a new range starts at the current element. So, we add the current range to the result in the required format and update the start variable to the current element. This process continues until all elements are processed. Finally, we add the last range to the result in the required format.\n\nSince the input array is sorted and unique, this greedy approach ensures that we find the smallest sorted list of ranges that cover all the numbers in the array."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n\nstd::vector<std::string> find_ranges(std::vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> findRanges(int[] nums)  {\n    // Your code here\n}\n",
            "python": "from typing import List\n    # Your code here\n\n",
            "javascript": "function findRanges(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <iostream>\n\nint main() {\n    std::vector<int> nums = $args;\n    std::vector<std::string> result = find_ranges(nums);\n    for (const std::string& range : result) {\n        std::cout << range << std::endl;\n    }\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    result = find_ranges(inputs)\n    print(result)",
            "java": "",
            "javascript": ""
        },
        "Qid": "228"
    },
    {
        "_id": {
            "$oid": "661db641949b33b6c4e2b0cc"
        },
        "title": "Counting Digit 1",
        "description": "Given an integer `n`, count the total number of digit `1` appearing in all non-negative integers less than or equal to `n`.",
        "example": "Example:\n\nInput: n = 13\nOutput: 6\n\nExplanation: The digit 1 appears in the numbers 1, 10, 11, 12, and 13, so the total count is 6.",
        "level": "Easy",
        "tags": [
            "math",
            "counting",
            "digits"
        ],
        "test_cases": {
            "inputs": [
                13,
                0,
                1,
                9,
                10,
                11,
                99,
                100,
                101,
                999,
                1000,
                1001,
                9999,
                10000,
                10001,
                99999,
                100000,
                100001,
                999999,
                1000000
            ],
            "outputs": [
                6,
                0,
                1,
                1,
                2,
                4,
                20,
                21,
                23,
                300,
                400,
                401,
                4000,
                5000,
                5001,
                60000,
                70000,
                70001,
                800000,
                900000
            ]
        },
        "sample_code": {
            "c++": "int countDigitOne(int n) {\n    int count = 0;\n    for(long long i = 1; i <= n; i *= 10){\n        int divider = i * 10;\n        count += (n / divider) * i + min(max(n % divider - i + 1, 0LL), i);\n    }\n    return count;\n}\n",
            "java": "public int countDigitOne(int n) {\n    int count = 0;\n    for(long i = 1; i <= n; i *= 10){\n        long divider = i * 10;\n        count += (n / divider) * i + Math.min(Math.max(n % divider - i + 1, 0), i);\n    }\n    return count;\n}\n",
            "python": "def countDigitOne(n):\n    count = 0\n    i = 1\n    while i <= n:\n        divider = i * 10\n        count += (n // divider) * i + min(max(n % divider - i + 1, 0), i)\n        i *= 10\n    return count\n",
            "javascript": "function countDigitOne(n) {\n    let count = 0;\n    for(let i = 1; i <= n; i *= 10){\n        let divider = i * 10;\n        count += Math.floor(n / divider) * i + Math.min(Math.max(n % divider - i + 1, 0), i);\n    }\n    return count;\n}\n",
            "explanation": "1. The algorithm uses a loop that iterates from the digit 1 to the highest digit in the given number, starting with 1 and incrementing by multiplying by 10 each iteration (1, 10, 100...).\n2. On each iteration, the algorithm checks how many times 1's appear in the current digit:\n   a. Calculates the occurrences of digit 1 contributed by the higher digits (n / divider) * i.\n   b. Counts the remaining occurrences in the current digit using the formula min(max(n % divider - i + 1, 0), i).\n3. It sums up the occurrences for each digit in a variable called `count`.\n4. When the loop ends, all occurrences of digit 1 have been considered, and `count` has the final sum of all occurrences.\n\nThe algorithm runs in O(log10(n)) time complexity since the loop runs for however many digits there are in the input number."
        },
        "structure": {
            "c++": "int countDigitOne(int n)  {\n    // Your code here\n}\n",
            "java": "public int countDigitOne(int n)  {\n    // Your code here\n}\n",
            "python": "def countDigitOne(n):\n    # Your code here\n\n",
            "javascript": "function countDigitOne(n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = countDigitOne(n);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    input=$args\n    result = countDigitOne(input)\n    print(result)",
            "java": "",
            "javascript": ""
        },
        "Qid": "233"
    },
    {
        "_id": {
            "$oid": "661db70d949b33b6c4e2b0cd"
        },
        "title": "Expression Evaluation",
        "description": "Given a string `expression` of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.",
        "example": "Example 1:\n\nInput: expression = \"2-1-1\"\nOutput: [0,2]\nExplanation:\n((2-1)-1) = 0\n(2-(1-1)) = 2\n\nExample 2:\n\nInput: expression = \"2*3-4*5\"\nOutput: [-34,-14,-10,-10,10]\nExplanation:\n(2*(3-(4*5))) = -34\n((2*3)-(4*5)) = -14\n((2*(3-4))*5) = -10\n(2*((3-4)*5)) = -10\n(((2*3)-4)*5) = 10",
        "level": "Medium",
        "tags": [
            "Math",
            "Recursion",
            "Dynamic Programming"
        ],
        "test_cases": {
            "inputs": [
                "\"2-1-1\"",
                "\"2*3-4*5\"",
                "\"1+2+3+4+5\"",
                "\"1*2*3*4*5\"",
                "\"1+2*3-4+5\"",
                "\"1*2+3-4*5\"",
                "\"1+2*3-4*5+6\"",
                "\"1*2+3-4*5+6\"",
                "\"1+2*3-4*5+6-7\"",
                "\"1*2+3-4*5+6-7\"",
                "\"1+2*3-4*5+6-7+8\"",
                "\"1*2+3-4*5+6-7+8\"",
                "\"1+2*3-4*5+6-7+8-9\"",
                "\"1*2+3-4*5+6-7+8-9\"",
                "\"1+2*3-4*5+6-7+8-9+10\"",
                "\"1*2+3-4*5+6-7+8-9+10\"",
                "\"1+2*3-4*5+6-7+8-9+10-11\"",
                "\"1*2+3-4*5+6-7+8-9+10-11\"",
                "\"1+2*3-4*5+6-7+8-9+10-11+12\"",
                "\"1*2+3-4*5+6-7+8-9+10-11+12\""
            ],
            "outputs": [
                [
                    0,
                    2
                ],
                [
                    -34,
                    -14,
                    -10,
                    -10,
                    10
                ],
                [
                    15
                ],
                [
                    120
                ],
                [
                    6,
                    8,
                    10,
                    12,
                    16
                ],
                [
                    -14,
                    -10,
                    -2,
                    2,
                    6
                ],
                [
                    -7,
                    -1,
                    5,
                    11,
                    17
                ],
                [
                    -7,
                    -1,
                    5,
                    11,
                    17,
                    23
                ],
                [
                    -14,
                    -8,
                    0,
                    6,
                    12,
                    18,
                    24
                ],
                [
                    -14,
                    -8,
                    0,
                    6,
                    12,
                    18,
                    24,
                    32
                ],
                [
                    -21,
                    -15,
                    -7,
                    -1,
                    5,
                    11,
                    17,
                    23,
                    31
                ],
                [
                    -21,
                    -15,
                    -7,
                    -1,
                    5,
                    11,
                    17,
                    23,
                    31,
                    39
                ],
                [
                    -28,
                    -22,
                    -14,
                    -8,
                    0,
                    6,
                    12,
                    18,
                    24,
                    32,
                    40
                ],
                [
                    -28,
                    -22,
                    -14,
                    -8,
                    0,
                    6,
                    12,
                    18,
                    24,
                    32,
                    40,
                    50
                ],
                [
                    -36,
                    -30,
                    -22,
                    -16,
                    -8,
                    0,
                    6,
                    12,
                    18,
                    24,
                    32,
                    40,
                    50
                ],
                [
                    -36,
                    -30,
                    -22,
                    -16,
                    -8,
                    0,
                    6,
                    12,
                    18,
                    24,
                    32,
                    40,
                    50,
                    62
                ],
                [
                    -45,
                    -39,
                    -31,
                    -25,
                    -17,
                    -9,
                    -1,
                    5,
                    11,
                    17,
                    23,
                    31,
                    39,
                    49,
                    61
                ],
                [
                    -45,
                    -39,
                    -31,
                    -25,
                    -17,
                    -9,
                    -1,
                    5,
                    11,
                    17,
                    23,
                    31,
                    39,
                    49,
                    61,
                    75
                ],
                [
                    -55,
                    -49,
                    -41,
                    -35,
                    -27,
                    -19,
                    -11,
                    -3,
                    3,
                    9,
                    15,
                    23,
                    31,
                    41,
                    53,
                    67,
                    83
                ],
                [
                    -55,
                    -49,
                    -41,
                    -35,
                    -27,
                    -19,
                    -11,
                    -3,
                    3,
                    9,
                    15,
                    23,
                    31,
                    41,
                    53,
                    67,
                    83,
                    101
                ]
            ]
        },
        "sample_code": {
            "c++": "#include<vector>\n#include<string>\n\nusing namespace std;\n\nvector<int> diffWaysToCompute(string input) {\n    vector<int> result;\n    for (int i = 0; i < input.size(); i++) {\n        char c = input[i];\n        if (c == '+' || c == '-' || c == '*') {\n            auto left = diffWaysToCompute(input.substr(0, i));\n            auto right = diffWaysToCompute(input.substr(i + 1));\n            for (int l : left) {\n                for (int r : right) {\n                    if (c == '+') result.push_back(l + r);\n                    else if (c == '-') result.push_back(l - r);\n                    else if (c == '*') result.push_back(l * r);\n                }\n            }\n        }\n    }\n    if (result.empty()) result.push_back(stoi(input));\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> diffWaysToCompute(String input) {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 0; i < input.length(); i++) {\n        char c = input.charAt(i);\n        if (c == '+' || c == '-' || c == '*') {\n            List<Integer> left = diffWaysToCompute(input.substring(0, i));\n            List<Integer> right = diffWaysToCompute(input.substring(i + 1));\n            for (int l : left) {\n                for (int r : right) {\n                    if (c == '+') result.add(l + r);\n                    else if (c == '-') result.add(l - r);\n                    else if (c == '*') result.add(l * r);\n                }\n            }\n        }\n    }\n    if (result.isEmpty()) result.add(Integer.parseInt(input));\n    return result;\n}\n",
            "python": "def diffWaysToCompute(input: str):\n    result = []\n    for i in range(len(input)):\n        c = input[i]\n        if c == '+' or c == '-' or c == '*':\n            left = diffWaysToCompute(input[:i])\n            right = diffWaysToCompute(input[i + 1:])\n            for l in left:\n                for r in right:\n                    if c == '+': result.append(l + r)\n                    elif c == '-': result.append(l - r)\n                    elif c == '*': result.append(l * r)\n    if not result:\n        result.append(int(input))\n    return result\n",
            "javascript": "function diffWaysToCompute(input) {\n    const result = [];\n    for (let i = 0; i < input.length; i++) {\n        const c = input[i];\n        if (c === '+' || c === '-' || c === '*') {\n            const left = diffWaysToCompute(input.slice(0, i));\n            const right = diffWaysToCompute(input.slice(i + 1));\n            for (const l of left) {\n                for (const r of right) {\n                    if (c === '+') result.push(l + r);\n                    else if (c === '-') result.push(l - r);\n                    else if (c === '*') result.push(l * r);\n                }\n            }\n        }\n    }\n    if (result.length === 0) result.push(parseInt(input));\n    return result;\n}\n",
            "explanation": "The algorithm is a recursive divide-and-conquer approach. It starts by iterating through the `input` string and looks for operators (+, -, *). When an operator is found, the problem is divided into two sub-problems: left and right. These sub-problems are independently solved through recursively calling the `diffWaysToCompute` function with corresponding substrings. \n\nEach recursion returns a list of possible results for each sub-problem. For each operator, we combine these results by iterating through both lists and performing the corresponding operation (addition, subtraction, or multiplication).\n\nIf no operators are present in the input string, a base case is reached, and the current number in the input string is returned as the only result. The recursion ultimately produces a list of all possible results for the original expression by combining results from all sub-problems."
        },
        "structure": {
            "c++": "#include<vector>\n#include<string>\n\nusing namespace std;\n\nvector<int> diffWaysToCompute(string input)  {\n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> diffWaysToCompute(String input)  {\n    // Your code here\n}\n",
            "python": "def diffWaysToCompute(input: str):\n    # Your code here\n\n",
            "javascript": "function diffWaysToCompute(input)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include<vector>\n#include<string>\n#include<iostream>\n\nusing namespace std;\n\nvector<int> diffWaysToCompute(string input) {\n    vector<int> result;\n    for (int i = 0; i < input.size(); i++) {\n        char c = input[i];\n        if (c == '+' || c == '-' || c == '*') {\n            auto left = diffWaysToCompute(input.substr(0, i));\n            auto right = diffWaysToCompute(input.substr(i + 1));\n            for (int l : left) {\n                for (int r : right) {\n                    if (c == '+') result.push_back(l + r);\n                    else if (c == '-') result.push_back(l - r);\n                    else if (c == '*') result.push_back(l * r);\n                }\n            }\n        }\n    }\n    if (result.empty()) result.push_back(stoi(input));\n    return result;\n}\n\nint main() {\n    string input = $args;\n    vector<int> result = diffWaysToCompute(input);\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    input=$args\n    result = diffWaysToCompute(input)\n    print(result)",
            "java": "",
            "javascript": ""
        },
        "Qid": "241"
    },
    {
        "_id": {
            "$oid": "661db786949b33b6c4e2b0ce"
        },
        "title": "Shortest Distance Between Words",
        "description": "Given an array of strings `wordsDict` and two different strings that already exist in the array `word1` and `word2`, write a function `shortestDistance` to return the shortest distance between these two words in the list.",
        "example": "Example:\n\nInput: wordsDict = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"], word1 = \"coding\", word2 = \"practice\"\nOutput: 3\n\nExplanation: The shortest distance between \"coding\" and \"practice\" is 3, as they appear at indices 3 and 0 respectively.\n\nInput: wordsDict = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"], word1 = \"makes\", word2 = \"coding\"\nOutput: 1\n\nExplanation: The shortest distance between \"makes\" and \"coding\" is 1, as they appear at indices 1 and 3 respectively.",
        "level": "Easy",
        "tags": [
            "array",
            "string",
            "search"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "practice",
                        "makes",
                        "perfect",
                        "coding",
                        "makes"
                    ],
                    "coding",
                    "practice"
                ],
                [
                    [
                        "practice",
                        "makes",
                        "perfect",
                        "coding",
                        "makes"
                    ],
                    "makes",
                    "coding"
                ],
                [
                    [
                        "apple",
                        "banana",
                        "orange",
                        "apple",
                        "grape"
                    ],
                    "apple",
                    "grape"
                ],
                [
                    [
                        "hello",
                        "world",
                        "hello",
                        "hello",
                        "world"
                    ],
                    "hello",
                    "world"
                ],
                [
                    [
                        "cat",
                        "dog",
                        "cat",
                        "cat",
                        "dog"
                    ],
                    "dog",
                    "cat"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d",
                        "e"
                    ],
                    "a",
                    "e"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d",
                        "e"
                    ],
                    "b",
                    "d"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d",
                        "e"
                    ],
                    "c",
                    "c"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d",
                        "e"
                    ],
                    "d",
                    "d"
                ],
                [
                    [
                        "a",
                        "b",
                        "c",
                        "d",
                        "e"
                    ],
                    "e",
                    "a"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "a",
                    "a"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "a",
                    "b"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "b",
                    "b"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "b",
                    "c"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "c",
                    "d"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "d",
                    "e"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "e",
                    "e"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "e",
                    "f"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "f",
                    "f"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "f",
                    "g"
                ],
                [
                    [
                        "a",
                        "a",
                        "a",
                        "a",
                        "a"
                    ],
                    "g",
                    "h"
                ]
            ],
            "outputs": [
                3,
                1,
                1,
                1,
                2,
                4,
                2,
                0,
                0,
                4,
                1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <climits>\n\nint shortestDistance(std::vector<std::string> wordsDict, std::string word1, std::string word2) {\n    int idx1 = -1, idx2 = -1, minDistance = INT_MAX;\n    for (int i = 0; i < wordsDict.size(); i++) {\n        if (wordsDict[i] == word1) idx1 = i;\n        if (wordsDict[i] == word2) idx2 = i;\n        if (idx1 != -1 && idx2 != -1)\n            minDistance = std::min(minDistance, std::abs(idx1 - idx2));\n    }\n    return minDistance;\n}\n",
            "java": "public int shortestDistance(String[] wordsDict, String word1, String word2) {\n    int idx1 = -1, idx2 = -1, minDistance = Integer.MAX_VALUE;\n    for (int i = 0; i < wordsDict.length; i++) {\n        if (word1.equals(wordsDict[i])) idx1 = i;\n        if (word2.equals(wordsDict[i])) idx2 = i;\n        if (idx1 != -1 && idx2 != -1)\n            minDistance = Math.min(minDistance, Math.abs(idx1 - idx2));\n    }\n    return minDistance;\n}\n",
            "python": "def shortestDistance(wordsDict, word1, word2):\n    idx1, idx2, minDistance = -1, -1, float('inf')\n    for i, word in enumerate(wordsDict):\n        if word == word1:\n            idx1 = i\n        if word == word2:\n            idx2 = i\n        if idx1 != -1 and idx2 != -1:\n            minDistance = min(minDistance, abs(idx1 - idx2))\n    return minDistance\n",
            "javascript": "function shortestDistance(wordsDict, word1, word2) {\n    let idx1 = -1, idx2 = -1, minDistance = Number.MAX_VALUE;\n    for (let i = 0; i < wordsDict.length; i++) {\n        if (wordsDict[i] === word1) idx1 = i;\n        if (wordsDict[i] === word2) idx2 = i;\n        if (idx1 !== -1 && idx2 !== -1)\n            minDistance = Math.min(minDistance, Math.abs(idx1 - idx2));\n    }\n    return minDistance;\n}\n",
            "explanation": "The algorithm iterates through the `wordsDict` list and uses two variables `idx1` and `idx2` to store the indices of the occurrences of `word1` and `word2`. Initially, both indices are set to `-1`. In each iteration, if `word1` or `word2` is found, the corresponding index variable will be updated to store the current index.\n\nAfter each index update, we check if both indices are not `-1`. If both indices are valid, the difference between the indices is computed, and `minDistance` is updated with the minimum value between the previously-stored minimum distance and the new distance.\n\nFinally, the algorithm returns the value of `minDistance`, which represents the shortest distance between `word1` and `word2` in the `wordsDict` list."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <climits>\n\nint shortestDistance(std::vector<std::string> wordsDict, std::string word1, std::string word2)  {\n    // Your code here\n}\n",
            "java": "public int shortestDistance(String[] wordsDict, String word1, String word2)  {\n    // Your code here\n}\n",
            "python": "def shortestDistance(wordsDict, word1, word2):\n    # Your code here\n\n",
            "javascript": "function shortestDistance(wordsDict, word1, word2)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <climits>\n#include <iostream>\n\nint main() {\n    std::vector<std::string> wordsDict = $args;\n    std::string word1 = $args;\n    std::string word2 = $args;\n    int result = shortestDistance(wordsDict, word1, word2);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public int shortestDistance(String[] wordsDict, String word1, String word2) {\n    int idx1 = -1, idx2 = -1, minDistance = Integer.MAX_VALUE;\n    for (int i = 0; i < wordsDict.length; i++) {\n        if (word1.equals(wordsDict[i])) idx1 = i;\n        if (word2.equals(wordsDict[i])) idx2 = i;\n        if (idx1 != -1 && idx2 != -1)\n            minDistance = Math.min(minDistance, Math.abs(idx1 - idx2));\n    }\n    return minDistance;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    wordsDict = inputs[0]\n    word1 = inputs[1]\n    word2 = inputs[2]\n    result = shortestDistance(wordsDict, word1, word2)\n    print(result)",
            "javascript": "function shortestDistance(wordsDict, word1, word2) {\n    const result = shortestDistance(wordsDict, word1, word2);\n    console.log(result);\n}"
        },
        "Qid": "243"
    },
    {
        "_id": {
            "$oid": "661db8a9949b33b6c4e2b0cf"
        },
        "title": "Strobogrammatic Number",
        "description": "Given a string `num` which represents an integer, return `true` if `num` is a strobogrammatic number. A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).",
        "example": "Example 1:\n\nInput: num = \"69\"\nOutput: true\n\nExample 2:\n\nInput: num = \"88\"\nOutput: true\n\nExample 3:\n\nInput: num = \"962\"\nOutput: false",
        "level": "Easy",
        "tags": [
            "String",
            "Math"
        ],
        "test_cases": {
            "inputs": [
                "\"69\"",
                "\"88\"",
                "\"962\"",
                "\"0\"",
                "\"1\"",
                "\"11\"",
                "\"101\"",
                "\"121\"",
                "\"609\"",
                "\"808\"",
                "\"906\"",
                "\"1001\"",
                "\"1111\"",
                "\"1234\"",
                "\"6789\"",
                "\"10001\"",
                "\"11111\"",
                "\"12321\"",
                "\"67876\"",
                "\"90009\"",
                "\"91119\""
            ],
            "outputs": [
                true,
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                false,
                true,
                false,
                true,
                false,
                false,
                false,
                false,
                true,
                false,
                true,
                true,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "#include <unordered_map>\n#include <string>\n#include <iostream>\nbool isStrobogrammatic(const std::string& num) {\n    std::unordered_map<char, char> lookup {\n        {'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}\n    };\n\n    int left = 0;\n    int right = num.size() - 1;\n\n    while (left <= right) {\n        if (lookup.find(num[left]) == lookup.end() || lookup[num[left]] != num[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n\n    return true;\n}\n",
            "java": "public static boolean isStrobogrammatic(String num) {\n    HashMap<Character, Character> lookup = new HashMap<Character, Character>() {{\n        put('0', '0');\n        put('1', '1');\n        put('6', '9');\n        put('8', '8');\n        put('9', '6');\n    }};\n    int left = 0, right = num.length() - 1;\n    while(left <= right) {\n        if(!lookup.containsKey(num.charAt(left)) || lookup.get(num.charAt(left)) != num.charAt(right)) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n",
            "python": "def isStrobogrammatic(num: str) -> bool:\n    lookup = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}\n    left, right = 0, len(num) - 1\n    while left <= right:\n        if num[left] not in lookup or lookup[num[left]] != num[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n",
            "javascript": "function isStrobogrammatic(num) {\n    const lookup = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'};\n    let left = 0, right = num.length - 1;\n    while(left <= right) {\n        if(!(num[left] in lookup) || lookup[num[left]] !== num[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n",
            "explanation": "The algorithm uses a while loop and a dictionary (lookup) to check if the given string is strobogrammatic. The main idea is to iterate through the string with two pointers, `left` and `right`. The `left` pointer starts at the beginning of the string and `right` starts at the end.\n\nFor each step of the while loop:\n1. Check if the character at the `left` pointer is in the `lookup` dictionary, if not, return false.\n2. Check if the mapped (rotated) character of the character at the `left` pointer matches the character at the `right` pointer, if not, return false.\n3. Increment `left` pointer and decrement `right` pointer.\n\nIf the loop finishes iterating through the string without returning false, then return true as the string is strobogrammatic."
        },
        "structure": {
            "c++": "bool isStrobogrammatic(string num) {\n    // Your code here\n}\n",
            "java": "public boolean isStrobogrammatic(String num) {\n    // Your code here\n}\n",
            "python": "def isStrobogrammatic(num: str) -> bool:\n    # Your code here\n\n",
            "javascript": "function isStrobogrammatic(num)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    std::string num = $args;\n    bool result = isStrobogrammatic(num);\n    std::cout << std::boolalpha <<result << std::endl;\n}",
            "java": "public static void main(String[] args) {\n    String num = $args;\n    boolean result = isStrobogrammatic(num);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    num = $args\n    result = isStrobogrammatic(num)\n    print(result)",
            "javascript": "function main() {\n    const num = $args;\n    const result = isStrobogrammatic(num);\n    console.log(result);\n}\nmain();\n"
        },
        "Qid": "246",
        "languages verified": [
            "python",
            "javascript",
            "c++",
            "java"
        ]
    },
    {
        "_id": {
            "$oid": "661db9cb949b33b6c4e2b0d0"
        },
        "title": "Group Strings with Shifting Sequences",
        "description": "Given an array of strings, group all strings that belong to the same shifting sequence. A shifting sequence is formed by shifting each letter of a string to its successive letter. For example, 'abc' can be shifted to 'bcd'. We can keep shifting the string to form a sequence, such as 'abc' -> 'bcd' -> ... -> 'xyz'. Return the grouped strings in any order.",
        "example": "Example:\n\nInput: strings = [\"abc\",\"bcd\",\"acef\",\"xyz\",\"az\",\"ba\",\"a\",\"z\"]\nOutput: [['acef'],['a','z'],['abc','bcd','xyz'],['az','ba']]\n\nExplanation: The strings 'acef' have the same shifting sequence. The strings 'a' and 'z' have the same shifting sequence. The strings 'abc', 'bcd', and 'xyz' have the same shifting sequence. The strings 'az' and 'ba' have the same shifting sequence.",
        "level": "Medium",
        "tags": [
            "string",
            "array"
        ],
        "test_cases": {
            "inputs": [
                [
                    "abc",
                    "bcd",
                    "acef",
                    "xyz",
                    "az",
                    "ba",
                    "a",
                    "z"
                ],
                [
                    "a"
                ],
                [
                    "abc",
                    "def",
                    "ghi",
                    "jkl"
                ],
                [
                    "abc",
                    "bcd",
                    "cde",
                    "def"
                ],
                [
                    "abc",
                    "bcd",
                    "cde",
                    "def",
                    "efg",
                    "fgh"
                ]
            ],
            "outputs": [
                "[['acef'],['a','z'],['abc','bcd','xyz'],['az','ba']]",
                "[['a']]",
                "[['abc','def','ghi','jkl']]",
                "[['abc','bcd','cde','def']]",
                "[['abc','bcd','cde','def','efg','fgh']]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<std::vector<std::string>> groupStrings(std::vector<std::string>& strings) {\n    std::unordered_map<std::string, std::vector<std::string>> map;\n    \n    for (const auto& s : strings) {\n        std::string key;\n        for (char c : s) {\n            key += std::to_string((c - s[0] + 26) % 26) + \",\";\n        }\n        map[key].push_back(s);\n    }\n    \n    std::vector<std::vector<std::string>> result;\n    for (auto& kv : map) {\n        result.push_back(kv.second);\n    }\n    \n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<List<String>> groupStrings(String[] strings) {\n    Map<String, List<String>> map = new HashMap<>();\n\n    for (String s : strings) {\n        StringBuilder key = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            key.append((c - s.charAt(0) + 26) % 26).append(\",\");\n        }\n        String keyStr = key.toString();\n        map.putIfAbsent(keyStr, new ArrayList<>());\n        map.get(keyStr).add(s);\n    }\n\n    return new ArrayList<>(map.values());\n}\n",
            "python": "from collections import defaultdict\n\ndef groupStrings(strings):\n    groups = defaultdict(list)\n\n    for s in strings:\n        key = tuple((ord(c) - ord(s[0])) % 26 for c in s)\n        groups[key].append(s)\n\n    return list(groups.values())\n",
            "javascript": "function groupStrings(strings) {\n    const map = new Map();\n\n    for (const s of strings) {\n        let key = '';\n        for (const c of s) {\n            key += `${(c.charCodeAt(0) - s.charCodeAt(0) + 26) % 26},`;\n        }\n        if (!map.has(key)) {\n            map.set(key, []);\n        }\n        map.get(key).push(s);\n    }\n\n    return Array.from(map.values());\n}\n",
            "explanation": "The idea is to create a unique key for each group of strings, that depends on the relative distances between characters in a string. We iterate through the given strings and create the key for each string by taking the difference between the ASCII code of each character and that of the first character, modulo 26. We add these deltas as comma-separated elements and use them as the key in a map. Where a map is a hashmap in C++ and Java, defaultdict in Python, and Map in JavaScript. For each string, we append it to the list of strings corresponding to its group (key) in the map.\n\nAfter iterating through all the strings, we return the list of groups from the map.\n\nNote that the modulo operation and `<code>26</code>` come from the number of lowercase English letters which is 26. So, any shift greater than 25 will simply wrap around to the initial letters."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<std::vector<std::string>> groupStrings(std::vector<std::string>& strings)  {\n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<List<String>> groupStrings(String[] strings)  {\n    // Your code here\n}\n",
            "python": "from collections import defaultdict\n    # Your code here\n\n",
            "javascript": "function groupStrings(strings)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n\nint main() {\n    std::vector<std::string> strings = $args;\n    std::vector<std::vector<std::string>> result = groupStrings(strings);\n    \n    // Print the result\n    for (const auto& group : result) {\n        for (const auto& str : group) {\n            std::cout << str << \" \";\n        }\n        std::cout << std::endl;\n    }\n    \n    return 0;\n}\n",
            "python": "if __name__ == \"__main__\":\n    strings = $args\n    result = groupStrings(strings)\n    print(result)",
            "java": "",
            "javascript": ""
        },
        "Qid": "249"
    },
    {
        "_id": {
            "$oid": "661dba64949b33b6c4e2b0d1"
        },
        "title": "Meeting Time Intervals",
        "description": "Given an array of meeting time intervals represented as `intervals`, where `intervals[i] = [starti, endi]`, determine if a person could attend all meetings without any overlap.",
        "example": "For example, given the intervals = [[0,30],[5,10],[15,20]], the person cannot attend all meetings because there is an overlap between the second and third intervals. Therefore, the output would be false.\n\nIn another example, given the intervals = [[7,10],[2,4]], the person can attend all meetings without any overlap. Therefore, the output would be true.",
        "level": "Easy",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        0,
                        30
                    ],
                    [
                        5,
                        10
                    ],
                    [
                        15,
                        20
                    ]
                ],
                [
                    [
                        7,
                        10
                    ],
                    [
                        2,
                        4
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        6,
                        10
                    ],
                    [
                        11,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        3,
                        7
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ],
                    [
                        19,
                        20
                    ]
                ]
            ],
            "outputs": [
                false,
                true,
                true,
                true,
                false,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\n\nbool canAttendMeetings(std::vector<std::vector<int>>& intervals) {\n    std::sort(intervals.begin(), intervals.end());\n    \n    for (int i = 1; i < intervals.size(); ++i) {\n        if (intervals[i][0] < intervals[i - 1][1])\n            return false;\n    }\n    \n    return true;\n}\n",
            "java": "import java.util.Arrays;\n\npublic boolean canAttendMeetings(int[][] intervals) {\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n    \n    for (int i = 1; i < intervals.length; ++i) {\n        if (intervals[i][0] < intervals[i - 1][1])\n            return false;\n    }\n    \n    return true;\n}\n",
            "python": "def can_attend_meetings(intervals):\n    intervals.sort()\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i - 1][1]:\n            return False\n\n    return True\n",
            "javascript": "function canAttendMeetings(intervals) {\n    intervals.sort((a, b) => a[0] - b[0]);\n    \n    for (let i = 1; i < intervals.length; ++i) {\n        if (intervals[i][0] < intervals[i - 1][1])\n            return false;\n    }\n    \n    return true;\n}\n",
            "explanation": "1. Sort the meeting intervals by their start times.\n2. Iterate through the sorted intervals. \n3. Check if the start time of the current interval is less than the end time of the previous interval. If so, return false, as the person cannot attend both of these meetings.\n4. If all intervals pass the check, return true, as the person can attend all meetings."
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\n\nbool canAttendMeetings(std::vector<std::vector<int>>& intervals)  {\n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\n\npublic boolean canAttendMeetings(int[][] intervals)  {\n    // Your code here\n}\n",
            "python": "def can_attend_meetings(intervals):\n    # Your code here\n\n",
            "javascript": "function canAttendMeetings(intervals)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nint main() {\n    std::vector<std::vector<int>> intervals = $args;\n    bool result = canAttendMeetings(intervals);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    intervals = $args\n    result = can_attend_meetings(intervals)\n    print(result)",
            "java": "",
            "javascript": ""
        },
        "Qid": "252"
    },
    {
        "_id": {
            "$oid": "661dbaeb949b33b6c4e2b0d3"
        },
        "title": "Minimum Number of Conference Rooms",
        "description": "Given an array of meeting time intervals `intervals` where `intervals[i] = [starti, endi]`, you need to determine the minimum number of conference rooms required to schedule all the meetings.",
        "example": "For example, given the intervals = [[0,30],[5,10],[15,20]], the minimum number of conference rooms required is 2. The first meeting starts at time 0 and ends at time 30. The second meeting starts at time 5 and ends at time 10. The third meeting starts at time 15 and ends at time 20. Since all the meetings overlap, we need at least 2 conference rooms to schedule them.\n\nInput: [[7,10],[2,4]]\nOutput: 1\n\nIn this case, the first meeting starts at time 7 and ends at time 10. The second meeting starts at time 2 and ends at time 4. Since the meetings do not overlap, only 1 conference room is required.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        0,
                        30
                    ],
                    [
                        5,
                        10
                    ],
                    [
                        15,
                        20
                    ]
                ],
                [
                    [
                        7,
                        10
                    ],
                    [
                        2,
                        4
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        3,
                        7
                    ],
                    [
                        4,
                        8
                    ]
                ],
                [
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        3,
                        8
                    ],
                    [
                        4,
                        7
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        5,
                        7
                    ],
                    [
                        6,
                        8
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        6
                    ],
                    [
                        3,
                        7
                    ],
                    [
                        4,
                        8
                    ],
                    [
                        5,
                        9
                    ]
                ],
                [
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        3,
                        8
                    ],
                    [
                        4,
                        7
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ],
                    [
                        19,
                        20
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ],
                    [
                        19,
                        20
                    ],
                    [
                        20,
                        21
                    ]
                ]
            ],
            "outputs": [
                2,
                1,
                4,
                5,
                1,
                1,
                2,
                2,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <queue>\n#include <algorithm>\n\nint minMeetingRooms(std::vector<std::vector<int>>& intervals) {\n    if (intervals.empty()) return 0;\n\n    std::sort(intervals.begin(), intervals.end(),\n              [](const std::vector<int>& a, const std::vector<int>& b) { return a[0] < b[0]; });\n\n    std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;\n    min_heap.push(intervals[0][1]);\n\n    for (int i = 1; i < intervals.size(); i++) {\n        if (intervals[i][0] >= min_heap.top()) {\n            min_heap.pop();\n        }\n        min_heap.push(intervals[i][1]);\n    }\n\n    return min_heap.size();\n}\n",
            "java": "import java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic int minMeetingRooms(int[][] intervals) {\n    if (intervals == null || intervals.length == 0) return 0;\n    \n    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    \n    minHeap.add(intervals[0][1]);\n    for (int i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] >= minHeap.peek()) {\n            minHeap.poll();\n        }\n        minHeap.add(intervals[i][1]);\n    }\n    \n    return minHeap.size();\n}\n",
            "python": "import heapq\n\ndef minMeetingRooms(intervals):\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n\n    min_heap = [intervals[0][1]]\n    for start, end in intervals[1:]:\n        if start >= min_heap[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, end)\n\n    return len(min_heap)\n",
            "javascript": "function minMeetingRooms(intervals) {\n    if (intervals.length === 0) return 0;\n\n    intervals.sort((a, b) => a[0] - b[0]);\n    const minHeap = [intervals[0][1]];\n\n    for (let i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] >= minHeap[0]) {\n            minHeap.shift();\n        }\n        minHeap.push(intervals[i][1]);\n        minHeap.sort((a, b) => a - b);\n    }\n\n    return minHeap.length;\n}\n",
            "explanation": "1. Sort the intervals by their start times.\n2. Initialize a min-heap to store the end times of the intervals.\n3. Iterate through the sorted intervals.\n   - If the start time of the current interval is greater than or equal to the minimum end time in the heap, it means the meeting room is available, so remove the minimum end time.\n   - Add the end time of the current interval to the heap.\n4. The size of the heap represents the minimum number of meeting rooms required."
        },
        "structure": {
            "c++": "#include <vector>\n#include <queue>\n#include <algorithm>\n\nint minMeetingRooms(std::vector<std::vector<int>>& intervals)  {\n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic int minMeetingRooms(int[][] intervals)  {\n    // Your code here\n}\n",
            "python": "import heapq\n    # Your code here\n\n",
            "javascript": "function minMeetingRooms(intervals)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n\nint main() {\n    std::vector<std::vector<int>> intervals = $args;\n    int result = minMeetingRooms(intervals);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int minMeetingRooms(int[][] intervals) {\n    if (intervals == null || intervals.length == 0) return 0;\n    \n    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    \n    minHeap.add(intervals[0][1]);\n    for (int i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] >= minHeap.peek()) {\n            minHeap.poll();\n        }\n        minHeap.add(intervals[i][1]);\n    }\n    \n    return minHeap.size();\n}",
            "python": "if __name__ == \"__main__\":\n    intervals = $args\n    result = minMeetingRooms(intervals)\n    print(result)",
            "javascript": "function main() {\n    const intervals = $args;\n    const result = minMeetingRooms(intervals);\n    console.log(result);\n}"
        },
        "Qid": "253"
    },
    {
        "_id": {
            "$oid": "661dbb74949b33b6c4e2b0d4"
        },
        "title": "Factor Combinations",
        "description": "Given an integer n, return all possible combinations of its factors. Numbers can be regarded as the product of their factors. For example, 8 = 2 x 2 x 2 = 2 x 4. The factors should be in the range [2, n - 1].",
        "example": "Example 1:\n\nInput: n = 1\nOutput: []\n\nExample 2:\n\nInput: n = 12\nOutput: [[2,6],[3,4],[2,2,3]]\n\nExample 3:\n\nInput: n = 37\nOutput: []",
        "level": "Medium",
        "tags": [
            "math",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                1,
                12,
                37,
                8,
                16,
                24,
                100
            ],
            "outputs": [
                [],
                [
                    [
                        2,
                        6
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        2,
                        2,
                        3
                    ]
                ],
                [],
                [
                    [
                        2,
                        2,
                        2
                    ],
                    [
                        2,
                        4
                    ]
                ],
                [
                    [
                        2,
                        2,
                        2,
                        2
                    ],
                    [
                        2,
                        2,
                        4
                    ],
                    [
                        2,
                        8
                    ],
                    [
                        4,
                        4
                    ]
                ],
                [
                    [
                        2,
                        2,
                        2,
                        3
                    ],
                    [
                        2,
                        2,
                        6
                    ],
                    [
                        2,
                        3,
                        4
                    ],
                    [
                        4,
                        6
                    ]
                ],
                [
                    [
                        2,
                        2,
                        5,
                        5
                    ]
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nvoid helper(int n, int start, std::vector<int>& path, std::vector<std::vector<int>>& result) {\n    if (n == 1) {\n        if (path.size() > 1) {\n            result.push_back(path);\n        }\n        return;\n    }\n\n    for (int i = start; i <= n; ++i) {\n        if (n % i == 0) {\n            path.push_back(i);\n            helper(n / i, i, path, result);\n            path.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<int>> getFactors(int n) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> path;\n    helper(n, 2, path, result);\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> getFactors(int n) {\n    List<List<Integer>> result = new ArrayList<>();\n    helper(n, 2, new ArrayList<Integer>(), result);\n    return result;\n}\n\nprivate void helper(int n, int start, List<Integer> path, List<List<Integer>> result) {\n    if (n == 1) {\n        if (path.size() > 1) {\n            result.add(new ArrayList<>(path));\n        }\n        return;\n    }\n\n    for (int i = start; i <= n; i++) {\n        if (n % i == 0) {\n            path.add(i);\n            helper(n / i, i, path, result);\n            path.remove(path.size() - 1);\n        }\n    }\n}\n",
            "python": "def getFactors(n):\n    def helper(n, start, path, result):\n        if n == 1:\n            if len(path) > 1:\n                result.append(path[:])\n            return\n\n        for i in range(start, n + 1):\n            if n % i == 0:\n                path.append(i)\n                helper(n // i, i, path, result)\n                path.pop()\n\n    result = []\n    helper(n, 2, [], result)\n    return result\n",
            "javascript": "function getFactors(n) {\n    const result = [];\n    const helper = (n, start, path) => {\n        if (n === 1) {\n            if (path.length > 1) {\n                result.push([...path]);\n            }\n            return;\n        }\n\n        for (let i = start; i <= n; i++) {\n            if (n % i === 0) {\n                path.push(i);\n                helper(n / i, i, path);\n                path.pop();\n            }\n        }\n    };\n\n    helper(n, 2, []);\n    return result;\n}\n",
            "explanation": "We use a backtracking algorithm to find all possible combinations of factors. The algorithm starts with `n` and splits it into all possible factors in the range `[2, n]`. We keep track of the current path, which represents the factors found so far. When `n` equals 1, we check if the current path has more than one element. If it does, we add the current combination of factors to the result.\n\nTo avoid duplicates, we ensure that the next factor in the sequence is greater than or equal to the previous one by passing a \"start\" variable in the helper function. This ensures that we always explore factors in a non-decreasing order.\n\nAt each recursive step, we first check if the current value of `n` is divisible by the current factor (i.e., it has no remainder when divided). If it is, we update the path with the current factor and call the helper function with the updated value of `n` divided by the current factor. After the recursive call returns, we remove the last factor from the path to backtrack to the previous level and explore other factors. This continues until we've explored all factors for the given input `n`. The final result is a list of lists representing all possible combinations of factors."
        },
        "structure": {
            "c++": "#include <vector>\n\nvoid helper(int n, int start, std::vector<int>& path, std::vector<std::vector<int>>& result)  {\n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> getFactors(int n)  {\n    // Your code here\n}\n",
            "python": "def getFactors(n):\n    # Your code here\n\n",
            "javascript": "function getFactors(n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nvoid helper(int n, int start, std::vector<int>& path, std::vector<std::vector<int>>& result) {\n    if (n == 1) {\n        if (path.size() > 1) {\n            result.push_back(path);\n        }\n        return;\n    }\n\n    for (int i = start; i <= n; ++i) {\n        if (n % i == 0) {\n            path.push_back(i);\n            helper(n / i, i, path, result);\n            path.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<int>> getFactors(int n) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> path;\n    helper(n, 2, path, result);\n    return result;\n}\n\nint main() {\n    int n = $args;\n    std::vector<std::vector<int>> result = getFactors(n);\n    for (const auto& factors : result) {\n        for (const auto& factor : factors) {\n            std::cout << factor << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}",
            "java": "public List<List<Integer>> getFactors(int n) {\n    List<List<Integer>> result = new ArrayList<>();\n    helper(n, 2, new ArrayList<Integer>(), result);\n    return result;\n}\n\nprivate void helper(int n, int start, List<Integer> path, List<List<Integer>> result) {\n    if (n == 1) {\n        if (path.size() > 1) {\n            result.add(new ArrayList<>(path));\n        }\n        return;\n    }\n\n    for (int i = start; i <= n; i++) {\n        if (n % i == 0) {\n            path.add(i);\n            helper(n / i, i, path, result);\n            path.remove(path.size() - 1);\n        }\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = getFactors(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = getFactors(n);\n    console.log(result);\n}"
        },
        "Qid": "254"
    },
    {
        "_id": {
            "$oid": "661dbba3949b33b6c4e2b0d5"
        },
        "title": "Preorder Traversal of Binary Search Tree",
        "description": "Given an array of unique integers `preorder`, determine if it represents the correct preorder traversal sequence of a binary search tree. Return `true` if it is a valid preorder traversal sequence, and `false` otherwise.",
        "example": "Example 1:\n\nInput: preorder = [5,2,1,3,6]\nOutput: true\n\nExplanation: The given preorder sequence [5,2,1,3,6] can be represented by the following binary search tree:\n\n     5\n    / \\\n   2   6\n  / \\\n 1   3\n\nSince the binary search tree matches the preorder sequence, the output is true.\n\nExample 2:\n\nInput: preorder = [5,2,6,1,3]\nOutput: false\n\nExplanation: The given preorder sequence [5,2,6,1,3] cannot be represented by any binary search tree. Therefore, the output is false.",
        "level": "Medium",
        "tags": [
            "binary search tree",
            "preorder traversal",
            "tree traversal"
        ],
        "test_cases": {
            "inputs": [
                [
                    5,
                    2,
                    1,
                    3,
                    6
                ],
                [
                    5,
                    2,
                    6,
                    1,
                    3
                ],
                [
                    1
                ],
                [
                    2,
                    1
                ],
                [
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1,
                    6
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6
                ],
                [
                    5,
                    2,
                    1,
                    4,
                    3,
                    6
                ],
                [
                    5,
                    2,
                    1,
                    4,
                    6,
                    3
                ],
                [
                    5,
                    2,
                    1,
                    6,
                    4,
                    3
                ],
                [
                    5,
                    2,
                    6,
                    1,
                    4,
                    3
                ],
                [
                    5,
                    6,
                    2,
                    1,
                    4,
                    3
                ],
                [
                    5,
                    6,
                    2,
                    1,
                    3,
                    4
                ],
                [
                    5,
                    6,
                    2,
                    4,
                    1,
                    3
                ],
                [
                    5,
                    6,
                    2,
                    4,
                    3,
                    1
                ],
                [
                    5,
                    6,
                    4,
                    2,
                    1,
                    3
                ],
                [
                    5,
                    6,
                    4,
                    2,
                    3,
                    1
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                true,
                false,
                false,
                true,
                false,
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "bool isValidPreorder(vector<int>& preorder) {\n    stack<int> stk;\n    int lower_bound = INT_MIN;\n    for (int num : preorder) {\n        if (num < lower_bound) return false;\n        while (!stk.empty() && num > stk.top()) {\n            lower_bound = stk.top();\n            stk.pop();\n        }\n        stk.push(num);\n    }\n    return true;\n}\n",
            "java": "public boolean isValidPreorder(int[] preorder) {\n    Stack<Integer> stack = new Stack<>();\n    int lowerBound = Integer.MIN_VALUE;\n    for (int num : preorder) {\n        if (num < lowerBound) return false;\n        while (!stack.isEmpty() && num > stack.peek()) {\n            lowerBound = stack.pop();\n        }\n        stack.push(num);\n    }\n    return true;\n}\n",
            "python": "def isValidPreorder(preorder: list[int]) -> bool:\n    stack = []\n    lower_bound = float('-inf')\n    for num in preorder:\n        if num < lower_bound:\n            return False\n        while stack and num > stack[-1]:\n            lower_bound = stack.pop()\n        stack.append(num)\n    return True\n",
            "javascript": "var isValidPreorder = function(preorder) {\n    let stack = [];\n    let lowerBound = Number.MIN_SAFE_INTEGER;\n    for (let num of preorder) {\n        if (num < lowerBound) return false;\n        while (stack.length > 0 && num > stack[stack.length - 1]) {\n            lowerBound = stack.pop();\n        }\n        stack.push(num);\n    }\n    return true;\n};\n",
            "explanation": "The algorithm is mainly based on a stack. It processes each element in the given `preorder` array and uses the stack to keep track of nodes that are not yet part of a completed subtree.\n\nInitially, `lower_bound` is set to the minimum possible value.\n\nFor each number in the preorder array:\n\n1. If the number is less than lower_bound, it means the number is trying to be added as a right child but the value is less than the minimum possible value, hence breaks the binary search tree property. So return false.\n   \n2. If the number is greater than the top of the stack, it means the number is the right child of the last node encountered. So, we pop from the stack and set the lower_bound to the last popped value until the stack is empty or the number is smaller than the top of the stack.\n   \n3. Push the number onto the stack.\n\nIf no false case is encountered during the loop, return true as it is a valid preorder traversal sequence of a binary search tree."
        },
        "structure": {
            "c++": "bool isValidPreorder(vector<int>& preorder)  {\n    // Your code here\n}\n",
            "java": "public boolean isValidPreorder(int[] preorder)  {\n    // Your code here\n}\n",
            "python": "def isValidPreorder(preorder: List[int]) -> bool:\n    # Your code here\n\n",
            "javascript": "var isValidPreorder = function(preorder)  {\n    // Your code here\n};\n"
        },
        "call_functions": {
            "c++": "bool isValidPreorder(vector<int>& preorder) {\n    stack<int> stk;\n    int lower_bound = INT_MIN;\n    for (int num : preorder) {\n        if (num < lower_bound) return false;\n        while (!stk.empty() && num > stk.top()) {\n            lower_bound = stk.top();\n            stk.pop();\n        }\n        stk.push(num);\n    }\n    return true;\n}",
            "java": "public static void main(String[] args) {\n    int[] preorder = $args;\n    boolean result = isValidPreorder(preorder);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    preorder = $args\n    result = isValidPreorder(preorder)\n    print(result)",
            "javascript": "function main() {\n    const preorder = $args;\n    let stack = [];\n    let lowerBound = Number.MIN_SAFE_INTEGER;\n    for (let num of preorder) {\n        if (num < lowerBound) return false;\n        while (stack.length > 0 && num > stack[stack.length - 1]) {\n            lowerBound = stack.pop();\n        }\n        stack.push(num);\n    }\n    return true;\n}\n\nconst result = main();\nconsole.log(result);"
        },
        "Qid": "255"
    },
    {
        "_id": {
            "$oid": "661dbbe6949b33b6c4e2b0d6"
        },
        "title": "Sum of Digits",
        "description": "Given an integer `num`, repeatedly add all its digits until the result has only one digit, and return it.",
        "example": "Example:\n\nInput: num = 38\nOutput: 2\nExplanation: The process is\n38 --> 3 + 8 --> 11\n11 --> 1 + 1 --> 2\nSince 2 has only one digit, return it.",
        "level": "Easy",
        "tags": [
            "math",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                38,
                0,
                9,
                123,
                456,
                789,
                100,
                999,
                123456789
            ],
            "outputs": [
                2,
                0,
                9,
                6,
                6,
                6,
                1,
                9,
                9
            ]
        },
        "sample_code": {
            "c++": "#include <iostream>\n\nint addDigits(int num) {\n    // Special case for 0\n    if (num == 0) return 0;\n    return 1 + (num - 1) % 9;\n}\n",
            "java": "public static int addDigits(int num) {\n    return 1 + (num - 1) % 9;\n}\n",
            "python": "def addDigits(num: int) -> int:\n    return 1 + (num - 1) % 9\n",
            "javascript": "function addDigits(num) {\n    return 1 + (num - 1) % 9;\n}\n",
            "explanation": "The idea is to find the pattern for the single digit that will be the outcome of repeatedly summing up a number's digits. Observe that for numbers 1-9, the single digit outcome is the number itself. For numbers 10-18 (i.e., 1+0, 1+1, 1+2, ..., 1+8), the single digit outcome is 1-9 again. This pattern repeats.\n\nIn the given code, we return the value computed from the formula `1 + (num - 1) % 9`. The formula derives from the observation mentioned above. Here's the explanation:\n\n- Subtracting 1 shifts the sequence to range from 0 to 8 instead of 1 to 9.\n- Taking num modulo 9 reveals the repeating 0-8 pattern.\n- Adding 1 offsets the range back to 1-9.\n\nThis algorithm works for all positive integer numbers, and the result is the single digit number that is the outcome of repeatedly summing up the original number's digits."
        },
        "structure": {
            "c++": "#include <iostream>\nint addDigits(int num) {\n    // Your code here\n}\n",
            "java": "public int addDigits(int num) {\n    // Your code here\n}\n",
            "python": "def addDigits(num: int) -> int:\n    # Your code here\n\n",
            "javascript": "function addDigits(num) {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int num = $args;\n    int result = addDigits(num);\n    std::cout << result << std::endl; // Should output 6\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    num = $args\n    result = addDigits(num)\n    print(result)",
            "java": "public static void main(String[] args) {\n    int num = $args;\n    int result = addDigits(num);\n    System.out.println(result);\n}",
            "javascript": "function main() {\n    const num = $args;\n    const result = addDigits(num);\n    console.log(result);\n}\nmain();\n"
        },
        "Qid": "258",
        "languages verified": [
            "python",
            "javascript",
            "c++",
            "java"
        ]
    },
    {
        "_id": {
            "$oid": "661dbc7d949b33b6c4e2b0d7"
        },
        "title": "Find the Two Elements",
        "description": "Given an integer array `nums`, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order. Implement an algorithm that runs in linear runtime complexity and uses only constant extra space.",
        "example": "Example 1:\n\nInput: nums = [1,2,1,3,2,5]\nOutput: [3,5]\nExplanation: [5, 3] is also a valid answer.\n\nExample 2:\n\nInput: nums = [-1,0]\nOutput: [-1,0]\n\nExample 3:\n\nInput: nums = [0,1]\nOutput: [1,0]",
        "level": "Medium",
        "tags": [
            "array",
            "bit manipulation"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    1,
                    3,
                    2,
                    5
                ],
                [
                    -1,
                    0
                ],
                [
                    0,
                    1
                ],
                [
                    4,
                    2,
                    4,
                    6,
                    2,
                    1
                ],
                [
                    9,
                    9,
                    8,
                    8,
                    7,
                    7,
                    6,
                    6,
                    5,
                    5,
                    4,
                    4,
                    3,
                    3,
                    2,
                    2,
                    1,
                    0
                ],
                [
                    100,
                    200,
                    300,
                    400,
                    500,
                    600,
                    700,
                    800,
                    900,
                    1000,
                    200,
                    300,
                    400,
                    500,
                    600,
                    700,
                    800,
                    900,
                    1000
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100,
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100
                ],
                [
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    1,
                    1,
                    2,
                    2,
                    3,
                    3,
                    4,
                    4,
                    5,
                    5,
                    6,
                    6,
                    7,
                    7,
                    8,
                    8,
                    9,
                    9,
                    10,
                    10,
                    11,
                    11,
                    12,
                    12,
                    13,
                    13,
                    14,
                    14,
                    15,
                    15,
                    16,
                    16,
                    17,
                    17,
                    18,
                    18,
                    19,
                    19,
                    20,
                    20
                ],
                [
                    1000,
                    2000,
                    3000,
                    4000,
                    5000,
                    6000,
                    7000,
                    8000,
                    9000,
                    10000,
                    2000,
                    3000,
                    4000,
                    5000,
                    6000,
                    7000,
                    8000,
                    9000,
                    10000,
                    1000,
                    2000,
                    3000,
                    4000,
                    5000,
                    6000,
                    7000,
                    8000,
                    9000,
                    10000
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99,
                    100
                ]
            ],
            "outputs": [
                [
                    3,
                    5
                ],
                [
                    -1,
                    0
                ],
                [
                    1,
                    0
                ],
                [
                    6,
                    1
                ],
                [
                    0,
                    1
                ],
                [
                    100,
                    200
                ],
                [
                    30,
                    40
                ],
                [
                    18,
                    19
                ],
                [
                    16,
                    17
                ],
                [
                    7000,
                    8000
                ],
                [
                    62,
                    63
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> singleNumber(vector<int>& nums) {\n    int xor_all = 0;\n    for (int num : nums) {\n        xor_all ^= num;\n    }\n\n    int bit = xor_all & (-xor_all);\n    int n1 = 0;\n    int n2 = 0;\n    for (int num : nums) {\n        if (num & bit) {\n            n1 ^= num;\n        } else {\n            n2 ^= num;\n        }\n    }\n\n    return vector<int>{n1, n2};\n}\n",
            "java": "public int[] singleNumber(int[] nums) {\n    int xor_all = 0;\n    for (int num : nums) {\n        xor_all ^= num;\n    }\n\n    int bit = xor_all & -xor_all;\n    int n1 = 0;\n    int n2 = 0;\n    for (int num : nums) {\n        if ((num & bit) != 0) {\n            n1 ^= num;\n        } else {\n            n2 ^= num;\n        }\n    }\n\n    return new int[]{n1, n2};\n}\n",
            "python": "def singleNumber(nums):\n    xor_all = 0\n    for num in nums:\n        xor_all ^= num\n\n    bit = xor_all & -xor_all\n    n1 = 0\n    n2 = 0\n    for num in nums:\n        if num & bit:\n            n1 ^= num\n        else:\n            n2 ^= num\n\n    return n1, n2\n",
            "javascript": "function singleNumber(nums) {\n    let xor_all = 0;\n    for (const num of nums) {\n        xor_all ^= num;\n    }\n\n    const bit = xor_all & -xor_all;\n    let n1 = 0;\n    let n2 = 0;\n    for (const num of nums) {\n        if (num & bit) {\n            n1 ^= num;\n        } else {\n            n2 ^= num;\n        }\n    }\n\n    return [n1, n2];\n}\n",
            "explanation": "The algorithm uses XOR operation to find the two unique numbers. First, we XOR all numbers in the array (which cancels out the repeating numbers), and the result of this XOR operation is actually the XOR of the two unique numbers. Then, we find the rightmost bit that is set to 1 in this XOR result. This bit will be different for the two unique numbers.\n\nNext, we split the numbers into two groups: one group has that bit set, and the other group doesn't. XOR all numbers in both groups separately, and the result of the XOR operation for each group will be one of the unique numbers. This is because, within each group, the equal numbers will cancel themselves out, leaving the unique numbers as the result.\n\nThis algorithm has a linear runtime complexity (O(n)) and uses constant extra space, as required."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> singleNumber(vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "public int[] singleNumber(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def singleNumber(nums):\n    # Your code here\n\n",
            "javascript": "function singleNumber(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nint main() {\n    vector<int> nums = $args;\n    vector<int> result = singleNumber(nums);\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n",
            "java": "public int[] singleNumber(int[] nums) {\n    int xor_all = 0;\n    for (int num : nums) {\n        xor_all ^= num;\n    }\n\n    int bit = xor_all & -xor_all;\n    int n1 = 0;\n    int n2 = 0;\n    for (int num : nums) {\n        if ((num & bit) != 0) {\n            n1 ^= num;\n        } else {\n            n2 ^= num;\n        }\n    }\n\n    return new int[]{n1, n2};\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = singleNumber(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = singleNumber(nums);\n    console.log(result);\n}"
        },
        "Qid": "260"
    },
    {
        "_id": {
            "$oid": "661e8276555605d7c12757d5"
        },
        "title": "Valid Tree",
        "description": "Given a graph with `n` nodes labeled from `0` to `n - 1`, and a list of `edges` where `edges[i] = [ai, bi]` indicates an undirected edge between nodes `ai` and `bi`, determine if the edges form a valid tree.",
        "example": "Example 1:\n\nInput: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]\nOutput: true\n\nExplanation: The given graph has 5 nodes and the edges form a valid tree.\n\nExample 2:\n\nInput: n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]\nOutput: false\n\nExplanation: The given graph has 5 nodes but the edges do not form a valid tree.",
        "level": "Medium",
        "tags": [
            "Graph",
            "Tree",
            "DFS",
            "Union Find"
        ],
        "test_cases": {
            "inputs": [
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            1,
                            4
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            1,
                            4
                        ]
                    ]
                ],
                [
                    1,
                    []
                ],
                [
                    2,
                    [
                        [
                            0,
                            1
                        ]
                    ]
                ],
                [
                    3,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ]
                    ]
                ],
                [
                    3,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            0
                        ]
                    ]
                ],
                [
                    4,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ]
                    ]
                ],
                [
                    4,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            0
                        ]
                    ]
                ],
                [
                    4,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            1
                        ]
                    ]
                ],
                [
                    4,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            0,
                            2
                        ]
                    ]
                ],
                [
                    4,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            1,
                            3
                        ]
                    ]
                ],
                [
                    4,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            0,
                            3
                        ]
                    ]
                ],
                [
                    4,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            1,
                            0
                        ]
                    ]
                ],
                [
                    4,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ]
                    ]
                ],
                [
                    4,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            1
                        ],
                        [
                            3,
                            2
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            0
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            0,
                            2
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            1,
                            3
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            0,
                            3
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            1,
                            0
                        ]
                    ]
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                true,
                false,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nbool isTree(int n, std::vector<std::vector<int>>& edges) {\n    std::vector<std::vector<int>> neighbors(n);\n    for (const auto& edge : edges) {\n        neighbors[edge[0]].push_back(edge[1]);\n        neighbors[edge[1]].push_back(edge[0]);\n    }\n    std::vector<bool> visited(n, false);\n    if(hasCycle(neighbors, visited, -1, 0)) return false;\n    for (const auto& visit : visited)\n        if (!visit) return false;\n    return true;\n}\n\nbool hasCycle(const std::vector<std::vector<int>>& neighbors, std::vector<bool>& visited, int parent, int node) {\n    visited[node] = true;\n    for (const auto& neighbor : neighbors[node])\n        if ((neighbor != parent && visited[neighbor]) || (!visited[neighbor] && hasCycle(neighbors, visited, node, neighbor))) return true;\n    return false;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic boolean isTree(int n, int[][] edges) {\n    List<List<Integer>> neighbors = new ArrayList<>(n);\n    for (int i = 0; i < n; i++) neighbors.add(new ArrayList<>());\n    for (int[] edge : edges) {\n        neighbors.get(edge[0]).add(edge[1]);\n        neighbors.get(edge[1]).add(edge[0]);\n    }\n    boolean[] visited = new boolean[n];\n    if(hasCycle(neighbors, visited, -1, 0)) return false;\n    for (boolean visit : visited)\n        if (!visit) return false;\n    return true;\n}\n\nprivate boolean hasCycle(List<List<Integer>> neighbors, boolean[] visited, int parent, int node) {\n    visited[node] = true;\n    for (int neighbor : neighbors.get(node))\n        if ((neighbor != parent && visited[neighbor]) || (!visited[neighbor] && hasCycle(neighbors, visited, node, neighbor))) return true;\n    return false;\n}\n",
            "python": "from typing import List\n\ndef isTree(n: int, edges: List[List[int]]) -> bool:\n    neighbors = [[] for _ in range(n)]\n    for edge in edges:\n        neighbors[edge[0]].append(edge[1])\n        neighbors[edge[1]].append(edge[0])\n    visited = [False] * n\n    if hasCycle(neighbors, visited, -1, 0): return False\n    return all(visited)\n\ndef hasCycle(neighbors: List[List[int]], visited: List[bool], parent: int, node: int) -> bool:\n    visited[node] = True\n    for neighbor in neighbors[node]:\n        if (neighbor != parent and visited[neighbor]) or (not visited[neighbor] and hasCycle(neighbors, visited, node, neighbor)): return True\n    return False\n",
            "javascript": "function isTree(n, edges) {\n    const neighbors = Array.from({length: n}, () => []);\n    for (const edge of edges) {\n        neighbors[edge[0]].push(edge[1]);\n        neighbors[edge[1]].push(edge[0]);\n    }\n    const visited = Array(n).fill(false);\n    if(hasCycle(neighbors, visited, -1, 0)) return false;\n    for (const visit of visited)\n        if (!visit) return false;\n    return true;\n}\n\nfunction hasCycle(neighbors, visited, parent, node) {\n    visited[node] = true;\n    for (const neighbour of neighbors[node])\n        if ((neighbour !== parent && visited[neighbour]) || (!visited[neighbour] && hasCycle(neighbors, visited, node, neighbour))) return true;\n    return false;\n}\n",
            "explanation": "The algorithm uses depth-first search (DFS) to traverse the given graph. During traversal, it checks if there is a cycle (a node visited more than once). A valid tree should not have any cycles, and all nodes must be reachable.\n\n1. Create a list of neighbors for each node.\n2. Initialize a visited array to keep track of visited nodes.\n3. Call the 'hasCycle' function to perform DFS and also check the existence of a cycle.\n4. If a cycle exists, return false.\n5. If all nodes have not been visited, return false.\n6. If there is no cycle and all nodes have been visited, return true.\n\nThe 'hasCycle' function checks for the cycle recursively. When visiting a node, mark it as visited. For each neighbor of the current node, if the neighbor is not the parent and has been visited, return true as a cycle is found. If the neighbor is not visited, call the 'hasCycle' function recursively. If the recursion returns true, a cycle has been found. Else, return false as no cycle is found in the current neighbors."
        },
        "structure": {
            "c++": "#include <vector>\n\nbool isTree(int n, std::vector<std::vector<int>>& edges)  {\n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic boolean isTree(int n, int[][] edges)  {\n    // Your code here\n}\n",
            "python": "from typing import List\n    # Your code here\n\n",
            "javascript": "function isTree(n, edges)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nbool hasCycle(const std::vector<std::vector<int>>& neighbors, std::vector<bool>& visited, int parent, int node);\n\nbool isTree(int n, std::vector<std::vector<int>>& edges) {\n    std::vector<std::vector<int>> neighbors(n);\n    for (const auto& edge : edges) {\n        neighbors[edge[0]].push_back(edge[1]);\n        neighbors[edge[1]].push_back(edge[0]);\n    }\n    std::vector<bool> visited(n, false);\n    if(hasCycle(neighbors, visited, -1, 0)) return false;\n    for (const auto& visit : visited)\n        if (!visit) return false;\n    return true;\n}\n\nbool hasCycle(const std::vector<std::vector<int>>& neighbors, std::vector<bool>& visited, int parent, int node) {\n    visited[node] = true;\n    for (const auto& neighbor : neighbors[node])\n        if ((neighbor != parent && visited[neighbor]) || (!visited[neighbor] && hasCycle(neighbors, visited, node, neighbor))) return true;\n    return false;\n}\n\nint main() {\n    int n = $args;\n    std::vector<std::vector<int>> edges;\n    // Fill the edges vector with input values\n    bool result = isTree(n, edges);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "java": "public boolean isTree(int n, int[][] edges) {\n    List<List<Integer>> neighbors = new ArrayList<>(n);\n    for (int i = 0; i < n; i++) neighbors.add(new ArrayList<>());\n    for (int[] edge : edges) {\n        neighbors.get(edge[0]).add(edge[1]);\n        neighbors.get(edge[1]).add(edge[0]);\n    }\n    boolean[] visited = new boolean[n];\n    if(hasCycle(neighbors, visited, -1, 0)) return false;\n    for (boolean visit : visited)\n        if (!visit) return false;\n    return true;\n}\n\nprivate boolean hasCycle(List<List<Integer>> neighbors, boolean[] visited, int parent, int node) {\n    visited[node] = true;\n    for (int neighbor : neighbors.get(node))\n        if ((neighbor != parent && visited[neighbor]) || (!visited[neighbor] && hasCycle(neighbors, visited, node, neighbor))) return true;\n    return false;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    n = inputs[0]\n    edges = inputs[1]\n    result = isTree(n, edges)\n    print(result)",
            "javascript": "function main() {\n    const n = $args[0];\n    const edges = $args[1];\n    const result = isTree(n, edges);\n    console.log(result);\n}"
        },
        "Qid": "261"
    },
    {
        "_id": {
            "$oid": "661e82bc555605d7c12757d6"
        },
        "title": "Ugly Number",
        "description": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. Given an integer n, return the nth ugly number.",
        "example": "Example 1:\n\nInput: n = 10\nOutput: 12\nExplanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.\n\nExample 2:\n\nInput: n = 1\nOutput: 1\nExplanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.",
        "level": "Medium",
        "tags": [
            "Math",
            "Dynamic Programming"
        ],
        "test_cases": {
            "inputs": [
                1,
                5,
                10,
                15,
                20,
                25,
                30,
                50,
                100,
                150,
                200,
                500,
                1000,
                1500,
                1690
            ],
            "outputs": [
                1,
                5,
                12,
                24,
                36,
                45,
                60,
                150,
                384,
                675,
                960,
                51200000,
                51200000,
                51200000,
                2123366400
            ]
        },
        "sample_code": {
            "c++": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::min\n\nint nthUglyNumber(int n) {\n    std::vector<int> uglyNumbers(n);\n    uglyNumbers[0] = 1; // First ugly number is 1\n\n    int i2 = 0, i3 = 0, i5 = 0; // Indices for multiples of 2, 3, and 5\n\n    for (int i = 1; i < n; i++) {\n        int nextUgly = std::min({uglyNumbers[i2] * 2, uglyNumbers[i3] * 3, uglyNumbers[i5] * 5});\n        uglyNumbers[i] = nextUgly;\n\n        if (nextUgly == uglyNumbers[i2] * 2) i2++;\n        if (nextUgly == uglyNumbers[i3] * 3) i3++;\n        if (nextUgly == uglyNumbers[i5] * 5) i5++;\n    }\n\n    return uglyNumbers[n - 1]; // nth ugly number\n}\n\n",
            "java": "public static int nthUglyNumber(int n) {\n        int[] uglyNumbers = new int[n];\n        uglyNumbers[0] = 1; // The first ugly number is 1\n        int i2 = 0, i3 = 0, i5 = 0;\n\n        for (int i = 1; i < n; i++) {\n            uglyNumbers[i] = Math.min(Math.min(uglyNumbers[i2] * 2, uglyNumbers[i3] * 3), uglyNumbers[i5] * 5);\n            if (uglyNumbers[i] == uglyNumbers[i2] * 2) i2++;\n            if (uglyNumbers[i] == uglyNumbers[i3] * 3) i3++;\n            if (uglyNumbers[i] == uglyNumbers[i5] * 5) i5++;\n        }\n\n        return uglyNumbers[n - 1]; // nth ugly number\n    }\n\n",
            "python": "def nthUglyNumber(n: int) -> int:\n    ugly_numbers = [0] * n\n    ugly_numbers[0] = 1\n    i2, i3, i5 = 0, 0, 0\n\n    for i in range(1, n):\n        ugly_numbers[i] = min(ugly_numbers[i2] * 2, ugly_numbers[i3] * 3, ugly_numbers[i5] * 5)\n        if ugly_numbers[i] == ugly_numbers[i2] * 2: i2 += 1\n        if ugly_numbers[i] == ugly_numbers[i3] * 3: i3 += 1\n        if ugly_numbers[i] == ugly_numbers[i5] * 5: i5 += 1\n\n    return ugly_numbers[n - 1]\n\n\n",
            "javascript": "function nthUglyNumber(n) {\n    let uglyNumbers = new Array(n);\n    uglyNumbers[0] = 1;\n    let i2 = 0, i3 = 0, i5 = 0;\n\n    for (let i = 1; i < n; i++) {\n        uglyNumbers[i] = Math.min(Math.min(uglyNumbers[i2] * 2, uglyNumbers[i3] * 3), uglyNumbers[i5] * 5);\n        if (uglyNumbers[i] === uglyNumbers[i2] * 2) i2++;\n        if (uglyNumbers[i] === uglyNumbers[i3] * 3) i3++;\n        if (uglyNumbers[i] === uglyNumbers[i5] * 5) i5++;\n    }\n\n    return uglyNumbers[n - 1];\n}\n\n",
            "explanation": "1. Initialize an array of size n and set the first element to 1 (the first ugly number).\n2. Create three variables (i2, i3, and i5) to keep track of the current index of ugly numbers multiplied by 2, 3, and 5.\n3. Iterate through the array from index 1 to n-1, calculating the next ugly number as the minimum of (uglyNumbers[i2] * 2, uglyNumbers[i3] * 3, and uglyNumbers[i5] * 5).\n4. Update the indices (i2, i3, and i5) based on which ugly number was used in the minimum calculation.\n5. The last element of the array is the nth ugly number."
        },
        "structure": {
            "c++": "int nthUglyNumber(int n) {\n    // Your code here\n}\n\n",
            "java": "public int nthUglyNumber(int n) {\n    // Your code here\n}\n\n",
            "python": "def nthUglyNumber(n: int) -> int:\n    # Your code here\n\n",
            "javascript": "function nthUglyNumber(n) {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = nthUglyNumber(n);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = nthUglyNumber(n)\n    print(result)",
            "java": "public static void main(String[] args) {\n        int num = $args;\n        int result = nthUglyNumber(num); // Use nthUglyNumber instead of addDigits\n        System.out.println(result);\n    }",
            "javascript": "function main() {\n    const num = $args;\n    const result = nthUglyNumber(num);\n    console.log(result);\n}\nmain();\n"
        },
        "Qid": "264",
        "languages verified": [
            "python",
            "javascript",
            "c++",
            "java"
        ]
    },
    {
        "_id": {
            "$oid": "661e82f6555605d7c12757d7"
        },
        "title": "Palindrome Permutation",
        "description": "Given a string `s`, return `true` if a permutation of the string could form a palindrome and `false` otherwise.",
        "example": "Example:\n\nInput: s = \"aab\"\nOutput: true\n\nExplanation: The permutation \"aba\" can form a palindrome.\n\nInput: s = \"code\"\nOutput: false\n\nExplanation: No permutation of the string can form a palindrome.",
        "level": "Easy",
        "tags": [
            "string",
            "palindrome"
        ],
        "test_cases": {
            "inputs": [
                "\"aab\"",
                "\"code\"",
                "\"carerac\"",
                "\"abc\"",
                "\"a\"",
                "\"aa\"",
                "\"aabbaa\"",
                "\"aabba\"",
                "\"aabb\"",
                "\"aabbcc\"",
                "\"aabbccd\"",
                "\"aabbccdd\"",
                "\"aabbccdde\"",
                "\"aabbccddeeff\"",
                "\"aabbccddeeffgg\"",
                "\"aabbccddeeffgghh\"",
                "\"aabbccddeeffgghhi\"",
                "\"aabbccddeeffgghhii\"",
                "\"aabbccddeeffgghhiijj\"",
                "\"aabbccddeeffgghhiijjkk\""
            ],
            "outputs": [
                true,
                false,
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "#include <iostream>\n#include <unordered_map>\n#include <string>\n\n// Function to check if any permutation of the string can form a palindrome\nbool canPermutePalindrome(const std::string& s) {\n    std::unordered_map<char, int> count;\n    \n    // Count the frequency of each character in the string\n    for (char c : s) {\n        count[c]++;\n    }\n\n    int odd_count = 0;\n    \n    // Count the number of characters with odd frequencies\n    for (const auto& pair : count) {\n        if (pair.second % 2 != 0) {\n            odd_count++;\n        }\n    }\n\n    // A string can form a palindrome if it has at most one character with an odd frequency\n    return odd_count <= 1;\n}\n",
            "java": "public static boolean canPermutePalindrome(String s) {\n    HashMap<Character, Integer> count = new HashMap<>();\n    for(char c : s.toCharArray()) {\n        count.put(c, count.getOrDefault(c, 0) + 1);\n    }\n    int odd_count = 0;\n    for(int value : count.values()) {\n        if (value % 2 != 0) {\n            odd_count++;\n        }\n    }\n    return odd_count <= 1;\n}\n",
            "python": "def canPermutePalindrome(s: str) -> bool:\n    count = {}\n    for c in s:\n        if c in count:\n            count[c] += 1\n        else:\n            count[c] = 1\n    odd_count = 0\n    for value in count.values():\n        if value % 2:\n            odd_count += 1\n    return odd_count <= 1\n",
            "javascript": "function canPermutePalindrome(s) {\n    const count = {}\n    for (const c of s) {\n        if (c in count) {\n            count[c]++;\n        } else {\n            count[c] = 1;\n        }\n    }\n    let odd_count = 0;\n    for (const value of Object.values(count)) {\n        if (value % 2) {\n            odd_count++;\n        }\n    }\n    return odd_count <= 1;\n}\n\n",
            "explanation": "The algorithm counts the occurrences of each character in the string using a hash map (or dictionary for Python). Then, it iterates through the count values in the hash map and checks how many characters have odd occurrences. If the string can form a palindrome, there should be at most one character having an odd number of occurrences.\n\nThe logic is based on the fact that a string can form a palindrome if it meets the following condition: If the string length is even, there should be an even number of occurrences for each character. If the string length is odd, there should be only one character having odd occurrences and the rest should have even occurrences.\n\nThe algorithm simply returns true if the odd_count is less than or equal to 1, indicating the string can form a palindrome; otherwise, it returns false."
        },
        "structure": {
            "c++": "#include <iostream>\n#include <unordered_map>\n#include <string>\nbool canPermutePalindrome(string s) {\n    // Your code here\n}\n",
            "java": "public boolean canPermutePalindrome(String s) {\n    // Your code here\n}\n",
            "python": "def canPermutePalindrome(s: str) -> bool:\n    # Your code here\n\n",
            "javascript": "function canPermutePalindrome(s) {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    std::string s = $args;\n    bool result = canPermutePalindrome(s);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = canPermutePalindrome(s)\n    print(result)",
            "java": "public static void main(String[] args) {\n        String s = $args;\n        boolean result = canPermutePalindrome(s); // Use nthUglyNumber instead of addDigits\n        System.out.println(result);\n    }",
            "javascript": "function main() {\n    const s = $args;\n    const result = canPermutePalindrome(s);\n    console.log(result);\n}\nmain();\n"
        },
        "Qid": "266",
        "languages verified": [
            "python",
            "javascript",
            "c++",
            "java"
        ]
    },
    {
        "_id": {
            "$oid": "661e8331555605d7c12757d8"
        },
        "title": "Missing Number in Range",
        "description": "Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, find the only number in the range that is missing from the array.",
        "example": "Example:\n\nInput: nums = [3,0,1]\nOutput: 2\nExplanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.",
        "level": "Easy",
        "tags": [
            "array",
            "math"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    0,
                    1
                ],
                [
                    0,
                    1
                ],
                [
                    9,
                    6,
                    4,
                    2,
                    3,
                    5,
                    7,
                    0,
                    1
                ],
                [
                    1
                ],
                [
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    20
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19
                ]
            ],
            "outputs": [
                2,
                2,
                8,
                0,
                19,
                19,
                19
            ]
        },
        "sample_code": {
            "c++": "int missingNumber(vector<int>& nums) {\n    int n = nums.size();\n    int expected_sum = (n * (n + 1)) / 2;\n    int actual_sum = 0;\n    for (int num : nums) {\n        actual_sum += num;\n    }\n    return expected_sum - actual_sum;\n}\n",
            "java": "public int missingNumber(int[] nums) {\n    int n = nums.length;\n    int expectedSum = (n * (n + 1)) / 2;\n    int actualSum = 0;\n    for (int num : nums) {\n        actualSum += num;\n    }\n    return expectedSum - actualSum;\n}\n",
            "python": "def missingNumber(nums):\n    n = len(nums)\n    expected_sum = (n * (n + 1)) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum\n",
            "javascript": "function missingNumber(nums) {\n    const n = nums.length;\n    const expectedSum = (n * (n + 1)) / 2;\n    const actualSum = nums.reduce((acc, num) => acc + num, 0);\n    return expectedSum - actualSum;\n}\n",
            "explanation": "The algorithm calculates the expected sum of integers in the range [0, n] using the formula n * (n + 1) / 2. Then, it calculates the actual sum of the integers in the given array. Finally, it returns the difference between the expected sum and the actual sum, which represents the missing number in the range."
        },
        "structure": {
            "c++": "int missingNumber(vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "public int missingNumber(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def missingNumber(nums):\n    # Your code here\n\n",
            "javascript": "function missingNumber(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> nums = $args;\n    int result = missingNumber(nums);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    int[] nums = $args;\n    int result = missingNumber(nums);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = missingNumber(nums)\n    print(result)",
            "javascript": ""
        },
        "Qid": "268"
    },
    {
        "_id": {
            "$oid": "661e8351555605d7c12757d9"
        },
        "title": "Alien Language Order",
        "description": "You are given a list of strings `words` from an alien language's dictionary. The strings in `words` are sorted lexicographically by the rules of this new language. Your task is to determine the order of the unique letters in the alien language and return them in lexicographically increasing order. If there is no valid order, return an empty string.",
        "example": "For example, given the words = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"], the unique letters in the alien language are 'w', 'r', 't', 'e', 'f'. The correct order is 'wertf', so the output would be 'wertf'.",
        "level": "Medium",
        "tags": [
            "sorting",
            "strings"
        ],
        "test_cases": {
            "inputs": [
                [
                    "wrt",
                    "wrf",
                    "er",
                    "ett",
                    "rftt"
                ],
                [
                    "z",
                    "x"
                ],
                [
                    "z",
                    "x",
                    "z"
                ],
                [
                    "abc",
                    "def",
                    "ghi"
                ],
                [
                    "abc",
                    "bcd",
                    "cde"
                ],
                [
                    "abc",
                    "bcd",
                    "cde",
                    "def"
                ],
                [
                    "abc",
                    "bcd",
                    "cde",
                    "def",
                    "efg"
                ],
                [
                    "abc",
                    "bcd",
                    "cde",
                    "def",
                    "efg",
                    "fgh"
                ],
                [
                    "abc",
                    "bcd",
                    "cde",
                    "def",
                    "efg",
                    "fgh",
                    "ghi"
                ],
                [
                    "abc",
                    "bcd",
                    "cde",
                    "def",
                    "efg",
                    "fgh",
                    "ghi",
                    "hij"
                ],
                [
                    "abc",
                    "bcd",
                    "cde",
                    "def",
                    "efg",
                    "fgh",
                    "ghi",
                    "hij",
                    "ijk"
                ],
                [
                    "abc",
                    "bcd",
                    "cde",
                    "def",
                    "efg",
                    "fgh",
                    "ghi",
                    "hij",
                    "ijk",
                    "jkl"
                ],
                [
                    "abc",
                    "bcd",
                    "cde",
                    "def",
                    "efg",
                    "fgh",
                    "ghi",
                    "hij",
                    "ijk",
                    "jkl",
                    "klm"
                ],
                [
                    "abc",
                    "bcd",
                    "cde",
                    "def",
                    "efg",
                    "fgh",
                    "ghi",
                    "hij",
                    "ijk",
                    "jkl",
                    "klm",
                    "lmn"
                ],
                [
                    "abc",
                    "bcd",
                    "cde",
                    "def",
                    "efg",
                    "fgh",
                    "ghi",
                    "hij",
                    "ijk",
                    "jkl",
                    "klm",
                    "lmn",
                    "mno"
                ],
                [
                    "abc",
                    "bcd",
                    "cde",
                    "def",
                    "efg",
                    "fgh",
                    "ghi",
                    "hij",
                    "ijk",
                    "jkl",
                    "klm",
                    "lmn",
                    "mno",
                    "nop"
                ],
                [
                    "abc",
                    "bcd",
                    "cde",
                    "def",
                    "efg",
                    "fgh",
                    "ghi",
                    "hij",
                    "ijk",
                    "jkl",
                    "klm",
                    "lmn",
                    "mno",
                    "nop",
                    "opq"
                ],
                [
                    "abc",
                    "bcd",
                    "cde",
                    "def",
                    "efg",
                    "fgh",
                    "ghi",
                    "hij",
                    "ijk",
                    "jkl",
                    "klm",
                    "lmn",
                    "mno",
                    "nop",
                    "opq",
                    "pqr"
                ],
                [
                    "abc",
                    "bcd",
                    "cde",
                    "def",
                    "efg",
                    "fgh",
                    "ghi",
                    "hij",
                    "ijk",
                    "jkl",
                    "klm",
                    "lmn",
                    "mno",
                    "nop",
                    "opq",
                    "pqr",
                    "qrs"
                ],
                [
                    "abc",
                    "bcd",
                    "cde",
                    "def",
                    "efg",
                    "fgh",
                    "ghi",
                    "hij",
                    "ijk",
                    "jkl",
                    "klm",
                    "lmn",
                    "mno",
                    "nop",
                    "opq",
                    "pqr",
                    "qrs",
                    "rst"
                ]
            ],
            "outputs": [
                "wertf",
                "zx",
                " ",
                "abcdefghi",
                "abcde",
                "abcdef",
                "abcdefg",
                "abcdefgh",
                "abcdefghi",
                "abcdefghij",
                "abcdefghijk",
                "abcdefghijkl",
                "abcdefghijklm",
                "abcdefghijklmn",
                "abcdefghijklmno",
                "abcdefghijklmnop",
                "abcdefghijklmnopq",
                "abcdefghijklmnopqr",
                "abcdefghijklmnopqrs",
                "abcdefghijklmnopqrst"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n\nstd::string alienOrder(std::vector<std::string> &words) {\n    std::unordered_map<char, std::unordered_set<char>> graph;\n    std::unordered_map<char, int> inDegree;\n    \n    for (const std::string &word : words)\n        for (char c : word)\n            inDegree[c] = 0;\n    \n    for (int i = 0; i < words.size() - 1; i++) {\n        std::string word1 = words[i], word2 = words[i + 1];\n        \n        bool found = false;\n        for (int j = 0; j < std::min(word1.size(), word2.size()); j++) {\n            char c1 = word1[j], c2 = word2[j];\n            if (c1 != c2) {\n                if (!graph[c1].count(c2)) {\n                    graph[c1].insert(c2);\n                    inDegree[c2]++;\n                }\n                found = true;\n                break;\n            }\n        }\n        \n        if (!found && word1.size() > word2.size())\n            return \"\";\n    }\n\n    std::queue<char> q;\n    for (auto &[c, deg] : inDegree)\n        if (deg == 0)\n            q.push(c);\n    \n    std::string result;\n    while (!q.empty()) {\n        char c = q.front();\n        q.pop();\n        result += c;\n        \n        for (char neigh : graph[c]) {\n            inDegree[neigh]--;\n            if (inDegree[neigh] == 0)\n                q.push(neigh);\n        }\n    }\n    \n    if (result.size() < inDegree.size())\n        return \"\";\n    \n    return result;\n}\n",
            "java": "import java.util.*;\n\npublic String alienOrder(String[] words) {\n    Map<Character, Set<Character>> graph = new HashMap<>();\n    Map<Character, Integer> inDegree = new HashMap<>();\n    \n    for (String word : words) {\n        for (char c : word.toCharArray())\n            inDegree.put(c, 0);\n    }\n    \n    for (int i = 0; i < words.length - 1; i++) {\n        String word1 = words[i], word2 = words[i + 1];\n        \n        boolean found = false;\n        for (int j = 0; j < Math.min(word1.length(), word2.length()); j++) {\n            char c1 = word1.charAt(j), c2 = word2.charAt(j);\n            if (c1 != c2) {\n                graph.putIfAbsent(c1, new HashSet<>());\n                if (!graph.get(c1).contains(c2)) {\n                    graph.get(c1).add(c2);\n                    inDegree.put(c2, inDegree.get(c2) + 1);\n                }\n                found = true;\n                break;\n            }\n        }\n        \n        if (!found && word1.length() > word2.length())\n            return \"\";\n    }\n\n    Queue<Character> q = new LinkedList<>();\n    for (Map.Entry<Character, Integer> entry : inDegree.entrySet())\n        if (entry.getValue() == 0)\n            q.offer(entry.getKey());\n    \n    StringBuilder result = new StringBuilder();\n    while (!q.isEmpty()) {\n        char c = q.poll();\n        result.append(c);\n        \n        if (graph.containsKey(c)) {\n            for (char neigh : graph.get(c)) {\n                inDegree.put(neigh, inDegree.get(neigh) - 1);\n                if (inDegree.get(neigh) == 0)\n                    q.offer(neigh);\n            }\n        }\n    }\n    \n    if (result.length() < inDegree.size())\n        return \"\";\n    \n    return result.toString();\n}\n",
            "python": "from collections import deque, defaultdict, Counter\n\ndef alienOrder(words):\n    graph = defaultdict(set)\n    in_degree = Counter({c: 0 for word in words for c in word})\n    \n    for word1, word2 in zip(words, words[1:]):\n        found = False\n        for c1, c2 in zip(word1, word2):\n            if c1 != c2:\n                if c2 not in graph[c1]:\n                    graph[c1].add(c2)\n                    in_degree[c2] += 1\n                found = True\n                break\n        if not found and len(word1) > len(word2):\n            return \"\"\n    \n    q = deque([c for c in in_degree if in_degree[c] == 0])\n    result = []\n    while q:\n        c = q.popleft()\n        result.append(c)\n        \n        for neigh in graph[c]:\n            in_degree[neigh] -= 1\n            if in_degree[neigh] == 0:\n                q.append(neigh)\n                 \n    if len(result) < len(in_degree):\n        return \"\"\n    \n    return \"\".join(result)\n",
            "javascript": "function alienOrder(words) {\n    const graph = new Map();\n    const inDegree = new Map();\n    \n    for (const word of words)\n        for (const c of word)\n            inDegree.set(c, 0);\n    \n    for (let i = 0; i < words.length - 1; i++) {\n        const word1 = words[i], word2 = words[i + 1];\n        \n        let found = false;\n        for (let j = 0; j < Math.min(word1.length, word2.length); j++) {\n            const c1 = word1[j], c2 = word2[j];\n            if (c1 !== c2) {\n                if (!graph.has(c1)) graph.set(c1, new Set());\n                if (!graph.get(c1).has(c2)) {\n                    graph.get(c1).add(c2);\n                    inDegree.set(c2, inDegree.get(c2) + 1);\n                }\n                found = true;\n                break;\n            }\n        }\n        \n        if (!found && word1.length > word2.length)\n            return \"\";\n    }\n\n    const q = [];\n    for (const [c, deg] of inDegree.entries())\n        if (deg === 0)\n            q.push(c);\n    \n    let result = \"\";\n    while (q.length) {\n        const c = q.shift();\n        result += c;\n        \n        if (graph.has(c)) {\n            for (const neigh of graph.get(c)) {\n                inDegree.set(neigh, inDegree.get(neigh) - 1);\n                if (inDegree.get(neigh) === 0)\n                    q.push(neigh);\n            }\n        }\n    }\n    \n    if (result.length < inDegree.size)\n        return \"\";\n    \n    return result;\n}\n",
            "explanation": "The algorithm uses the topological sorting algorithm with an adjacency list to represent the directed graph. The directed graph's vertices represent each unique character from the words array, and a directed edge between two vertices indicates that the first character appears before the second character in the alien language's dictionary.\n\nIt first initializes an adjacency list `graph`, an in-degree HashMap `inDegree` to store the in-degree of each character, and fills the HashMap with the unique characters from the words array, setting the initial in-degree of each character to 0. Then, it iterates through adjacent word pairs from the `words` array and adjacent character pairs from those word pairs, checking if they form an edge in the graph (i.e., the characters are different). If an edge is found, it is added to the graph, and the in-degree of the second character in the pair is incremented. In case we traverse through equal characters and later find the second string is shorter, we return an empty string as this indicates an invalid order.\n\nTo find the lexicographical order, we can use the topological sorting algorithm. We initialize a queue to store the characters with an in-degree of 0 (i.e. they have no incoming edges) and perform the following steps until the queue is empty:\n\n1. Pop the front character from the queue and append it to the result string.\n2. Iterate over all the neighbors of the popped character in the graph.\n3. Decrement the in-degree of each neighbor.\n4. Check if the in-degree of the neighbor is 0; if it is, push the character onto the queue.\n\nFinally, if the length of the result string is less than the number of unique characters, return an empty string as it indicates there's no valid lexicographical order. Otherwise, return the result string."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n\nstd::string alienOrder(std::vector<std::string> &words)  {\n    // Your code here\n}\n",
            "java": "import java.util.*;\n\npublic String alienOrder(String[] words)  {\n    // Your code here\n}\n",
            "python": "from collections import deque, defaultdict, Counter\n    # Your code here\n\n",
            "javascript": "function alienOrder(words)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "std::string alienOrder(std::vector<std::string> &words) {\n    std::unordered_map<char, std::unordered_set<char>> graph;\n    std::unordered_map<char, int> inDegree;\n    \n    for (const std::string &word : words)\n        for (char c : word)\n            inDegree[c] = 0;\n    \n    for (int i = 0; i < words.size() - 1; i++) {\n        std::string word1 = words[i], word2 = words[i + 1];\n        \n        bool found = false;\n        for (int j = 0; j < std::min(word1.size(), word2.size()); j++) {\n            char c1 = word1[j], c2 = word2[j];\n            if (c1 != c2) {\n                if (!graph[c1].count(c2)) {\n                    graph[c1].insert(c2);\n                    inDegree[c2]++;\n                }\n                found = true;\n                break;\n            }\n        }\n        \n        if (!found && word1.size() > word2.size())\n            return \"\";\n    }\n\n    std::queue<char> q;\n    for (auto &[c, deg] : inDegree)\n        if (deg == 0)\n            q.push(c);\n    \n    std::string result;\n    while (!q.empty()) {\n        char c = q.front();\n        q.pop();\n        result += c;\n        \n        for (char neigh : graph[c]) {\n            inDegree[neigh]--;\n            if (inDegree[neigh] == 0)\n                q.push(neigh);\n        }\n    }\n    \n    if (result.size() < inDegree.size())\n        return \"\";\n    \n    return result;\n}",
            "java": "public String alienOrder(String[] words) {\n    Map<Character, Set<Character>> graph = new HashMap<>();\n    Map<Character, Integer> inDegree = new HashMap<>();\n    \n    for (String word : words) {\n        for (char c : word.toCharArray())\n            inDegree.put(c, 0);\n    }\n    \n    for (int i = 0; i < words.length - 1; i++) {\n        String word1 = words[i], word2 = words[i + 1];\n        \n        boolean found = false;\n        for (int j = 0; j < Math.min(word1.length(), word2.length()); j++) {\n            char c1 = word1.charAt(j), c2 = word2.charAt(j);\n            if (c1 != c2) {\n                graph.putIfAbsent(c1, new HashSet<>());\n                if (!graph.get(c1).contains(c2)) {\n                    graph.get(c1).add(c2);\n                    inDegree.put(c2, inDegree.get(c2) + 1);\n                }\n                found = true;\n                break;\n            }\n        }\n        \n        if (!found && word1.length() > word2.length())\n            return \"\";\n    }\n\n    Queue<Character> q = new LinkedList<>();\n    for (Map.Entry<Character, Integer> entry : inDegree.entrySet())\n        if (entry.getValue() == 0)\n            q.offer(entry.getKey());\n    \n    StringBuilder result = new StringBuilder();\n    while (!q.isEmpty()) {\n        char c = q.poll();\n        result.append(c);\n        \n        if (graph.containsKey(c)) {\n            for (char neigh : graph.get(c)) {\n                inDegree.put(neigh, inDegree.get(neigh) - 1);\n                if (inDegree.get(neigh) == 0)\n                    q.offer(neigh);\n            }\n        }\n    }\n    \n    if (result.length() < inDegree.size())\n        return \"\";\n    \n    return result.toString();\n}",
            "python": "if __name__ == \"__main__\":\n    words = $args\n    result = alienOrder(words)\n    print(result)",
            "javascript": "function alienOrder(words) {\n    const graph = new Map();\n    const inDegree = new Map();\n    \n    for (const word of words)\n        for (const c of word)\n            inDegree.set(c, 0);\n    \n    for (let i = 0; i < words.length - 1; i++) {\n        const word1 = words[i], word2 = words[i + 1];\n        \n        let found = false;\n        for (let j = 0; j < Math.min(word1.length, word2.length); j++) {\n            const c1 = word1[j], c2 = word2[j];\n            if (c1 !== c2) {\n                if (!graph.has(c1)) graph.set(c1, new Set());\n                if (!graph.get(c1).has(c2)) {\n                    graph.get(c1).add(c2);\n                    inDegree.set(c2, inDegree.get(c2) + 1);\n                }\n                found = true;\n                break;\n            }\n        }\n        \n        if (!found && word1.length > word2.length)\n            return \"\";\n    }\n\n    const q = [];\n    for (const [c, deg] of inDegree.entries())\n        if (deg === 0)\n            q.push(c);\n    \n    let result = \"\";\n    while (q.length) {\n        const c = q.shift();\n        result += c;\n        \n        if (graph.has(c)) {\n            for (const neigh of graph.get(c)) {\n                inDegree.set(neigh, inDegree.get(neigh) - 1);\n                if (inDegree.get(neigh) === 0)\n                    q.push(neigh);\n            }\n        }\n    }\n    \n    if (result.length < inDegree.size)\n        return \"\";\n    \n    return result;\n}"
        },
        "Qid": "269"
    },
    {
        "_id": {
            "$oid": "661e83af555605d7c12757da"
        },
        "title": "String List Encoding and Decoding",
        "description": "You are given a list of strings. Design an algorithm to encode the list of strings into a single string. The encoded string is then sent over the network and needs to be decoded back to the original list of strings. Machine 1 (sender) has the function `encode` which takes a vector of strings as input and returns the encoded string. Machine 2 (receiver) has the function `decode` which takes the encoded string as input and returns the original list of strings. Implement the `encode` and `decode` methods. You are not allowed to use any serialize methods such as `eval`.",
        "example": "Example:\n\nInput:\nstrs = [\"Hello\", \"World\"]\nOutput:\n[\"Hello\", \"World\"]\nExplanation:\nMachine 1:\nCodec encoder = new Codec();\nString encoded_string = encoder.encode(strs);\nMachine 1 ---encoded_string---> Machine 2\n\nMachine 2:\nCodec decoder = new Codec();\nvector<string> decoded_strs = decoder.decode(encoded_string);\n\nThe `decoded_strs` in Machine 2 should be the same as `strs` in Machine 1.",
        "level": "Medium",
        "tags": [
            "String",
            "Encoding",
            "Decoding"
        ],
        "test_cases": {
            "inputs": [
                [
                    "Hello",
                    "World"
                ],
                [
                    "",
                    ""
                ],
                [
                    "abc",
                    "def",
                    "ghi"
                ],
                [
                    "123",
                    "456",
                    "789"
                ],
                [
                    "This is a sentence.",
                    "Another sentence."
                ],
                [
                    "",
                    "Hello",
                    "",
                    "World",
                    ""
                ],
                [
                    "Hello World!",
                    "How are you?"
                ],
                [
                    "",
                    "",
                    "",
                    ""
                ],
                [
                    "abc",
                    "",
                    "def",
                    "",
                    "ghi"
                ],
                [
                    "123",
                    "",
                    "456",
                    "",
                    "789"
                ],
                [
                    "This is a sentence.",
                    "",
                    "Another sentence."
                ],
                [
                    "",
                    "",
                    "Hello",
                    "",
                    "",
                    "World",
                    "",
                    "",
                    ""
                ],
                [
                    "Hello World!",
                    "",
                    "How are you?"
                ],
                [
                    "",
                    "",
                    "",
                    "",
                    ""
                ]
            ],
            "outputs": [
                "[\"Hello\", \"World\"]",
                "[\"\", \"\"]",
                "[\"abc\", \"def\", \"ghi\"]",
                "[\"123\", \"456\", \"789\"]",
                "[\"This is a sentence.\", \"Another sentence.\"]",
                "[\"\", \"Hello\", \"\", \"World\", \"\"]",
                "[\"Hello World!\", \"How are you?\"]",
                "[\"\", \"\", \"\", \"\"]",
                "[\"abc\", \"\", \"def\", \"\", \"ghi\"]",
                "[\"123\", \"\", \"456\", \"\", \"789\"]",
                "[\"This is a sentence.\", \"\", \"Another sentence.\"]",
                "[\"\", \"\", \"Hello\", \"\", \"\", \"World\", \"\", \"\", \"\"]",
                "[\"Hello World!\", \"\", \"How are you?\"]",
                "[\"\", \"\", \"\", \"\", \"\"]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n\nstd::string encode(const std::vector<std::string>& strs) {\n    std::string encoded_string;\n    for (const auto& s : strs) {\n        encoded_string += std::to_string(s.length()) + \"#\" + s;\n    }\n    return encoded_string;\n}\n\nstd::vector<std::string> decode(const std::string& s) {\n    std::vector<std::string> strs;\n    int i = 0;\n    while (i < s.length()) {\n        int delimiter_pos = s.find('#', i);\n        int length = std::stoi(s.substr(i, delimiter_pos - i));\n        strs.push_back(s.substr(delimiter_pos + 1, length));\n        i = delimiter_pos + length + 1;\n    }\n    return strs;\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic String encode(List<String> strs) {\n    StringBuilder encodedString = new StringBuilder();\n    for (String s : strs) {\n        encodedString.append(s.length()).append('#').append(s);\n    }\n    return encodedString.toString();\n}\n\npublic List<String> decode(String s) {\n    List<String> strs = new ArrayList<>();\n    int i = 0;\n    while (i < s.length()) {\n        int delimiterPos = s.indexOf('#', i);\n        int length = Integer.parseInt(s.substring(i, delimiterPos));\n        strs.add(s.substring(delimiterPos + 1, delimiterPos + 1 + length));\n        i = delimiterPos + 1 + length;\n    }\n    return strs;\n}\n",
            "python": "def encode(strs):\n    encoded_string = \"\"\n    for s in strs:\n        encoded_string += str(len(s)) + \"#\" + s\n    return encoded_string\n\ndef decode(s):\n    strs = []\n    i = 0\n    while i < len(s):\n        delimiter_pos = s.find('#', i)\n        length = int(s[i:delimiter_pos])\n        strs.append(s[delimiter_pos + 1:delimiter_pos + 1 + length])\n        i = delimiter_pos + 1 + length\n    return strs\n\n",
            "javascript": "function encode(strs) {\n    let encodedString = \"\";\n    for (const s of strs) {\n        encodedString += s.length + \"#\" + s;\n    }\n    return encodedString;\n}\n\nfunction decode(s) {\n    let strs = [];\n    let i = 0;\n    while (i < s.length) {\n        const delimiterPos = s.indexOf('#', i);\n        const length = parseInt(s.slice(i, delimiterPos));\n        strs.push(s.slice(delimiterPos + 1, delimiterPos + 1 + length));\n        i = delimiterPos + 1 + length;\n    }\n    return strs;\n}\n\n",
            "explanation": "The algorithm concatenates each string with its length and a delimiter (in this case '#'). For example, [\"Hello \", \"World \"] would be encoded into \"6#Hello 6#World \" (6 is the length of both \"Hello \" and \"World \").\n\nWhen decoding, the receiving side searches for the delimiter and extracts the string's length just before each delimiter. It then uses that length to extract the original string extending from the position after the delimiter. It iterates over the received encoded string until all substrings have been extracted.\n\nThis algorithm works with any valid ASCII characters as it uses the length of the string in the encoding and decoding process."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n\nstd::string encode(const std::vector<std::string>& strs)  {\n    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic String encode(List<String> strs)  {\n    // Your code here\n}\n",
            "python": "def encode(strs):\n    # Your code here\n\n",
            "javascript": "function encode(strs)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n\nint main() {\n    std::vector<std::string> strs = $args;\n    std::string encoded_string = encode(strs);\n    std::cout << encoded_string << std::endl;\n\n    std::string decoded_string = decode(encoded_string);\n    for (const auto& s : decoded_string) {\n        std::cout << s << std::endl;\n    }\n\n    return 0;\n}",
            "java": "public String encode(List<String> strs) {\n    StringBuilder encodedString = new StringBuilder();\n    for (String s : strs) {\n        encodedString.append(s.length()).append('#').append(s);\n    }\n    return encodedString.toString();\n}\n\npublic List<String> decode(String s) {\n    List<String> strs = new ArrayList<>();\n    int i = 0;\n    while (i < s.length()) {\n        int delimiterPos = s.indexOf('#', i);\n        int length = Integer.parseInt(s.substring(i, delimiterPos));\n        strs.add(s.substring(delimiterPos + 1, delimiterPos + 1 + length));\n        i = delimiterPos + 1 + length;\n    }\n    return strs;\n}",
            "python": "if __name__ == \"__main__\":\n    strs = $args\n    encoded = encode(strs)\n    print(encoded)\n    decoded = decode(encoded)\n    print(decoded)",
            "javascript": "function main() {\n    const strs = $args;\n    const encodedString = encode(strs);\n    console.log(encodedString);\n\n    const decodedStrings = decode(encodedString);\n    console.log(decodedStrings);\n}"
        },
        "Qid": "271"
    },
    {
        "_id": {
            "$oid": "661e844a555605d7c12757db"
        },
        "title": "Generate All Combinations of Well-Formed Parentheses",
        "description": "Given `n` pairs of parentheses, write a function to generate all combinations of well-formed parentheses. A well-formed parentheses string is defined as a string consisting of opening and closing parentheses '(' and ')', where each opening parenthesis must have a corresponding closing parenthesis and the parentheses pairs must be properly nested. Implement a function `generateParentheses(n: int) -> List[str]` that will take an integer `n` as input and return a list of all possible well-formed parentheses combinations.",
        "example": "Example:\n\nInput: n = 3\nOutput: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n\nInput: n = 1\nOutput: [\"()\"]",
        "level": "Medium",
        "tags": [
            "Recursion",
            "Backtracking",
            "String"
        ],
        "test_cases": {
            "inputs": [
                3,
                1,
                2,
                4,
                0
            ],
            "outputs": [
                [
                    "((()))",
                    "(()())",
                    "(())()",
                    "()(())",
                    "()()()"
                ],
                [
                    "()"
                ],
                [
                    "(())",
                    "()()"
                ],
                [
                    "(((())))",
                    "((()()))",
                    "((())())",
                    "((()))()",
                    "(()(()))",
                    "(()()())",
                    "(()())()",
                    "(())(())",
                    "(())()()",
                    "()((()))",
                    "()(()())",
                    "()(())()",
                    "()()(())",
                    "()()()()"
                ],
                []
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n\nvoid generateParenthesisHelper(int open, int close, std::string current, std::vector<std::string>& result) {\n    if (open == 0 && close == 0) {\n        result.push_back(current);\n        return;\n    }\n    if (open > 0) {\n        generateParenthesisHelper(open - 1, close + 1, current + '(', result);\n    }\n    if (close > 0) {\n        generateParenthesisHelper(open, close - 1, current + ')', result);\n    }\n}\n\nstd::vector<std::string> generateParenthesis(int n) {\n    std::vector<std::string> result;\n    generateParenthesisHelper(n, 0, \"\", result);\n    return result;\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> generateParenthesis(int n) {\n    List<String> result = new ArrayList<>();\n    generateParenthesisHelper(n, 0, \"\", result);\n    return result;\n}\n\nprivate void generateParenthesisHelper(int open, int close, String current, List<String> result) {\n    if (open == 0 && close == 0) {\n        result.add(current);\n        return;\n    }\n    if (open > 0) {\n        generateParenthesisHelper(open - 1, close + 1, current + '(', result);\n    }\n    if (close > 0) {\n        generateParenthesisHelper(open, close - 1, current + ')', result);\n    }\n}\n\n",
            "python": "def generate_parenthesis(n):\n    def generate_parenthesis_helper(open, close, current):\n        if open == 0 and close == 0:\n            result.append(current)\n            return\n        if open > 0:\n            generate_parenthesis_helper(open - 1, close + 1, current + '(')\n        if close > 0:\n            generate_parenthesis_helper(open, close - 1, current + ')')\n\n    result = []\n    generate_parenthesis_helper(n, 0, '')\n    return result\n\n",
            "javascript": "function generateParenthesis(n) {\n    function generateParenthesisHelper(open, close, current, result) {\n        if (open === 0 && close === 0) {\n            result.push(current);\n            return;\n        }\n        if (open > 0) {\n            generateParenthesisHelper(open - 1, close + 1, current + '(', result);\n        }\n        if (close > 0) {\n            generateParenthesisHelper(open, close - 1, current + ')', result);\n        }\n    }\n\n    let result = [];\n    generateParenthesisHelper(n, 0, '', result);\n    return result;\n}\n\n",
            "explanation": "The algorithm uses a helper function called `generateParenthesisHelper` which receives four parameters: the number of open parentheses left to place, the number of close parentheses left to place, the current string that holds the generated parentheses so far, and the result list to store valid combinations.\n\nThe algorithm uses a depth-first search to construct valid combinations of parentheses. It starts with `n` open parentheses and increments the number of close parentheses as it places an open parenthesis. When the helper function has no open or close parentheses left to place, it means a valid combination is found, so it adds the combination to the result list.\n\nThe helper function recursively calls itself. If there are open parentheses left to place, it calls itself with one less open parenthesis and one more close parenthesis. If there are close parentheses left to place, it calls itself without changing the number of open parentheses and with one less close parenthesis. Finally, the current string in each case is updated with the placed open or close parenthesis."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n\nvoid generateParenthesisHelper(int open, int close, std::string current, std::vector<std::string>& result)  {\n    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> generateParenthesis(int n)  {\n    // Your code here\n}\n\n",
            "python": "def generate_parenthesis(n):\n    # Your code here\n\n",
            "javascript": "function generateParenthesis(n)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = generate_parenthesis(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = generateParenthesis(n);\n    console.log(result);\n}",
            "c++": "",
            "java": ""
        },
        "Qid": "22"
    },
    {
        "_id": {
            "$oid": "661e84fc555605d7c12757dc"
        },
        "title": "First Occurrence of Needle in Haystack",
        "description": "Given two strings `needle` and `haystack`, find the index of the first occurrence of `needle` in `haystack`. If `needle` is not part of `haystack`, return -1.",
        "example": "Example:\n\nInput: haystack = \"sadbutsad \", needle = \"sad \"\nOutput: 0\nExplanation: \"sad \" occurs at index 0 and 6. The first occurrence is at index 0, so we return 0.",
        "level": "Easy",
        "tags": [
            "string",
            "search"
        ],
        "test_cases": {
            "inputs": [
                [
                    "sadbutsad ",
                    "sad "
                ],
                [
                    "leetcode ",
                    "leeto "
                ],
                [
                    "hello world",
                    "world"
                ],
                [
                    "programming",
                    "gram"
                ],
                [
                    "abcdefg",
                    "xyz"
                ],
                [
                    "abcabcabc",
                    "abc"
                ],
                [
                    "abcde",
                    "f"
                ],
                [
                    "abcde",
                    ""
                ],
                [
                    "",
                    "abc"
                ],
                [
                    "",
                    ""
                ],
                [
                    "abc",
                    "abc"
                ],
                [
                    "abc",
                    "abcd"
                ],
                [
                    "abcd",
                    "abc"
                ],
                [
                    "abcd",
                    "efg"
                ],
                [
                    "abcdefg",
                    ""
                ],
                [
                    "",
                    "abcdefg"
                ],
                [
                    "abc",
                    "abcabcabc"
                ],
                [
                    "abcabcabc",
                    "abc"
                ],
                [
                    "abcabcabc",
                    "def"
                ],
                [
                    "abcabcabc",
                    "abcabcabc"
                ]
            ],
            "outputs": [
                0,
                -1,
                6,
                3,
                -1,
                0,
                -1,
                0,
                -1,
                0,
                0,
                -1,
                -1,
                0,
                -1,
                -1,
                0,
                -1,
                -1,
                0
            ]
        },
        "sample_code": {
            "c++": "int strStr(string haystack, string needle) {\n    if(needle.empty()) return 0;\n\n    size_t pos = haystack.find(needle);\n    if(pos != string::npos)\n        return pos;\n    return -1;\n}\n",
            "java": "public int strStr(String haystack, String needle) {\n    if (needle.isEmpty()) return 0;\n    \n    int index = haystack.indexOf(needle);\n    return index;\n}\n",
            "python": "def strStr(haystack: str, needle: str) -> int:\n    if not needle:\n        return 0\n    try:\n        index = haystack.index(needle)\n        return index\n    except ValueError:\n        return -1\n",
            "javascript": "function strStr(haystack, needle) {\n    if (needle === '') return 0;\n\n    let index = haystack.indexOf(needle);\n    return index;\n}\n",
            "explanation": "The algorithm searches for the first occurrence of the `needle` string in the `haystack` string. First, it checks if the `needle` is empty, and if it is, it returns 0. Otherwise, it uses the built-in `find`, `indexOf` or `index` functions provided by the corresponding language's string data type. These functions return the index of the first occurrence of the specified substring. If the substring is not found, they return specific values like string::npos for C++, -1 for Java, and raise a ValueError exception for Python. Depending on the returned value, the algorithm either returns the index of the first occurrence or -1, indicating that `needle` is not part of `haystack`."
        },
        "structure": {
            "c++": "int strStr(string haystack, string needle)  {\n    // Your code here\n}\n",
            "java": "public int strStr(String haystack, String needle)  {\n    // Your code here\n}\n",
            "python": "def strStr(haystack: str, needle: str) -> int:\n    # Your code here\n\n",
            "javascript": "function strStr(haystack, needle)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint strStr(string haystack, string needle) {\n    if(needle.empty()) return 0;\n\n    size_t pos = haystack.find(needle);\n    if(pos != string::npos)\n        return pos;\n    return -1;\n}\n\nint main() {\n    string haystack = $args;\n    string needle = $args;\n    int result = strStr(haystack, needle);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    String haystack = $args[0];\n    String needle = $args[1];\n    \n    int result = strStr(haystack, needle);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    haystack = inputs[0]\n    needle = inputs[1]\n    result = strStr(haystack, needle)\n    print(result)",
            "javascript": "function main() {\n    const haystack = $args[0];\n    const needle = $args[1];\n    const result = strStr(haystack, needle);\n    console.log(result);\n}"
        },
        "Qid": "28"
    },
    {
        "_id": {
            "$oid": "661e8592555605d7c12757df"
        },
        "title": "Unique Paths in a Grid",
        "description": "A robot is located at the top-left corner of an `m x n` grid. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid. Given the dimensions of the grid, return the number of possible unique paths that the robot can take to reach the bottom-right corner.",
        "example": "Example:\n\nInput: m = 3, n = 7\nOutput: 28\n\nExplanation: From the top-left corner, there are a total of 28 unique paths to reach the bottom-right corner.\n\nInput: m = 3, n = 2\nOutput: 3\nExplanation: From the top-left corner, there are a total of 3 unique paths to reach the bottom-right corner: Right -> Down -> Down, Down -> Down -> Right, Down -> Right -> Down",
        "level": "Medium",
        "tags": [
            "dynamic programming",
            "grid",
            "combinatorics"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    7
                ],
                [
                    3,
                    2
                ],
                [
                    1,
                    1
                ],
                [
                    2,
                    2
                ],
                [
                    5,
                    5
                ],
                [
                    10,
                    10
                ],
                [
                    100,
                    1
                ],
                [
                    1,
                    100
                ],
                [
                    50,
                    50
                ],
                [
                    2,
                    5
                ],
                [
                    5,
                    2
                ],
                [
                    4,
                    3
                ],
                [
                    3,
                    4
                ],
                [
                    6,
                    7
                ],
                [
                    7,
                    6
                ],
                [
                    8,
                    8
                ],
                [
                    9,
                    9
                ],
                [
                    10,
                    5
                ],
                [
                    5,
                    10
                ]
            ],
            "outputs": [
                28,
                3,
                1,
                2,
                70,
                48620,
                1,
                1,
                204190544,
                10,
                10,
                10,
                10,
                792,
                792,
                3432,
                48620,
                252,
                252
            ]
        },
        "sample_code": {
            "c++": "int uniquePaths(int m, int n) {\n    vector<vector<int>> dp(m, vector<int>(n, 1));\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    return dp[m - 1][n - 1];\n}\n",
            "java": "public int uniquePaths(int m, int n) {\n    int[][] dp = new int[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == 0 || j == 0) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n    return dp[m - 1][n - 1];\n}\n",
            "python": "def uniquePaths(m, n):\n    dp = [[1] * n for _ in range(m)]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[m - 1][n - 1]\n",
            "javascript": "function uniquePaths(m, n) {\n    const dp = Array.from({ length: m }, () => Array(n).fill(1));\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    return dp[m - 1][n - 1];\n}\n",
            "explanation": "The idea is to use dynamic programming to solve this problem. We create a 2D array `dp` with dimensions `m` x `n` to store the number of unique paths to reach each cell in the grid.\n\nInitially, we fill out the first row and first column of the `dp` array with 1 since there is only one way to reach any cell in the first row or first column: by moving either right along the first row or down along the first column.\n\nThen, for every other cell in the `dp` array, we can calculate the number of unique paths to that cell by summing the number of unique paths to the cell above it and to the cell to its left. We can do this because the robot can only move down or right, so the paths to the current cell must have come from those two directions.\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the number of unique paths the robot can take to reach the destination."
        },
        "structure": {
            "c++": "int uniquePaths(int m, int n)  {\n    // Your code here\n}\n",
            "java": "public int uniquePaths(int m, int n)  {\n    // Your code here\n}\n",
            "python": "def uniquePaths(m, n):\n    # Your code here\n\n",
            "javascript": "function uniquePaths(m, n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int m = $args;\n    int n = $args;\n    int result = uniquePaths(m, n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int uniquePaths(int m, int n) {\n    int[][] dp = new int[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == 0 || j == 0) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n    return dp[m - 1][n - 1];\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    m = inputs[0]\n    n = inputs[1]\n    result = uniquePaths(m, n)\n    print(result)",
            "javascript": "function main() {\n    const m = $args[0];\n    const n = $args[1];\n    const result = uniquePaths(m, n);\n    console.log(result);\n}"
        },
        "Qid": "62"
    },
    {
        "_id": {
            "$oid": "661e85a4555605d7c12757e0"
        },
        "title": "Minimum Path Sum",
        "description": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. You can only move either down or right at any point in time.",
        "example": "Example:\n\nInput: grid = [[1,3,1],[1,5,1],[4,2,1]]\nOutput: 7\nExplanation: Because the path 1 -> 3 -> 1 -> 1 -> 1 minimizes the sum.",
        "level": "Medium",
        "tags": [
            "dynamic programming",
            "grid",
            "path finding"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        3,
                        1
                    ],
                    [
                        1,
                        5,
                        1
                    ],
                    [
                        4,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ]
                ],
                [
                    [
                        1
                    ]
                ],
                [
                    [
                        0
                    ]
                ],
                [
                    [
                        1,
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        1,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        1,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        1,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        0,
                        1
                    ]
                ]
            ],
            "outputs": [
                7,
                12,
                30,
                9,
                0,
                55,
                110,
                1,
                0,
                4
            ]
        },
        "sample_code": {
            "c++": "int minPathSum(vector<vector<int>>& grid) {\n    int m = grid.size(), n = grid[0].size();\n        \n    for(int i = 1; i < m; i++)\n        grid[i][0] += grid[i - 1][0];\n        \n    for(int i = 1; i < n; i++)\n        grid[0][i] += grid[0][i - 1];\n        \n    for(int i = 1; i < m; i++){\n        for(int j = 1; j < n; j++){\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n    return grid[m - 1][n - 1];\n}\n",
            "java": "public int minPathSum(int[][] grid) {\n    int m = grid.length, n = grid[0].length;\n        \n    for(int i = 1; i < m; i++)\n        grid[i][0] += grid[i - 1][0];\n        \n    for(int i = 1; i < n; i++)\n        grid[0][i] += grid[0][i - 1];\n        \n    for(int i = 1; i < m; i++){\n        for(int j = 1; j < n; j++){\n            grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n    return grid[m - 1][n - 1];\n}\n",
            "python": "def minPathSum(grid):\n    m, n = len(grid), len(grid[0])\n\n    for i in range(1, m):\n        grid[i][0] += grid[i - 1][0]\n\n    for i in range(1, n):\n        grid[0][i] += grid[0][i - 1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n\n    return grid[m - 1][n - 1]\n",
            "javascript": "function minPathSum(grid) {\n    let m = grid.length, n = grid[0].length;\n        \n    for(let i = 1; i < m; i++)\n        grid[i][0] += grid[i - 1][0];\n        \n    for(let i = 1; i < n; i++)\n        grid[0][i] += grid[0][i - 1];\n        \n    for(let i = 1; i < m; i++){\n        for(let j = 1; j < n; j++){\n            grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n    return grid[m - 1][n - 1];\n}\n",
            "explanation": "The algorithm solves the problem through dynamic programming. It creates a table and fills it by the following rules:\n1. The first element of each row will be the sum of its previous row element and its current value.\n2. The first element of each column will be the sum of its previous column element and its current value.\n3. For all other elements, find the minimum path/components from its top (i-1,j) and left (i,j-1) neighbors, and then add its current value.\n\nAt the end of the loop, the bottom right cell contains the minimum path sum from the top left corner to the bottom right corner."
        },
        "structure": {
            "c++": "int minPathSum(vector<vector<int>>& grid)  {\n    // Your code here\n}\n",
            "java": "public int minPathSum(int[][] grid)  {\n    // Your code here\n}\n",
            "python": "def minPathSum(grid):\n    # Your code here\n\n",
            "javascript": "function minPathSum(grid)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int minPathSum(vector<vector<int>>& grid) {\n    int m = grid.size(), n = grid[0].size();\n    \n    for(int i = 1; i < m; i++)\n        grid[i][0] += grid[i - 1][0];\n        \n    for(int i = 1; i < n; i++)\n        grid[0][i] += grid[0][i - 1];\n        \n    for(int i = 1; i < m; i++){\n        for(int j = 1; j < n; j++){\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n    return grid[m - 1][n - 1];\n}",
            "java": "public int minPathSum(int[][] grid) {\n    int m = grid.length, n = grid[0].length;\n    \n    for(int i = 1; i < m; i++)\n        grid[i][0] += grid[i - 1][0];\n    \n    for(int i = 1; i < n; i++)\n        grid[0][i] += grid[0][i - 1];\n    \n    for(int i = 1; i < m; i++){\n        for(int j = 1; j < n; j++){\n            grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n    return grid[m - 1][n - 1];\n}",
            "python": "if __name__ == \"__main__\":\n    grid = $args\n    result = minPathSum(grid)\n    print(result)",
            "javascript": "function main() {\n    const grid = $args;\n    const result = minPathSum(grid);\n    console.log(result);\n}"
        },
        "Qid": "64"
    },
    {
        "_id": {
            "$oid": "661e85d3555605d7c12757e1"
        },
        "title": "Distinct Ways to Climb Stairs",
        "description": "You are climbing a staircase that takes `n` steps to reach the top. Each time, you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?",
        "example": "For example, if `n` is 2, there are two ways to climb to the top: 1 step + 1 step or 2 steps. Therefore, the output would be 2.\n\n",
        "level": "Easy",
        "tags": [
            "dynamic programming",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                2,
                3,
                4,
                5,
                6,
                10,
                15,
                20,
                25,
                30,
                35,
                40,
                45
            ],
            "outputs": [
                2,
                3,
                5,
                8,
                13,
                89,
                987,
                10946,
                121393,
                1346269,
                14930352,
                165580141,
                1836311903
            ]
        },
        "sample_code": {
            "c++": "int climbStairs(int n) {\n    if(n <= 2) return n;\n    int a = 1, b = 2, c;\n    for(int i = 3; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n\n",
            "java": "public int climbStairs(int n) {\n    if(n <= 2) return n;\n    int a = 1, b = 2, c;\n    for(int i = 3; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n\n",
            "python": "def climbStairs(n):\n    if n <= 2:\n        return n\n    a, b = 1, 2\n    for _ in range(3, n+1):\n        a, b = b, a + b\n    return b\n\n",
            "javascript": "function climbStairs(n) {\n    if(n <= 2) return n;\n    let a = 1, b = 2, c;\n    for(let i = 3; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n\n",
            "explanation": "This problem can be solved using dynamic programming. The number of ways to reach the top can be calculated by finding the sum of the ways to reach the previous two steps. We start with the base cases where `n` is 1 or 2, and then iteratively build up the solution. In each iteration, we update `a` and `b` with the new number of ways to reach steps `n-2` and `n-1` respectively, and keep calculating the number of ways to reach step `n` using `a + b`. This continues until we reach the top and return the final result."
        },
        "structure": {
            "c++": "int climbStairs(int n)  {\n    // Your code here\n}\n\n",
            "java": "public int climbStairs(int n)  {\n    // Your code here\n}\n\n",
            "python": "def climbStairs(n):\n    # Your code here\n\n",
            "javascript": "function climbStairs(n)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = climbStairs(n);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = climbStairs(n)\n    print(result)",
            "java": "",
            "javascript": ""
        },
        "Qid": "70"
    },
    {
        "_id": {
            "$oid": "661e88e8555605d7c12757e2"
        },
        "title": "Unique Binary Search Trees",
        "description": "Given an integer `n`, return the number of structurally unique binary search trees (BSTs) that have exactly `n` nodes with unique values from 1 to `n`.",
        "example": "Example 1:\n\nInput: n = 3\nOutput: 5\n\nExplanation: There are 5 unique BSTs that can be formed with 3 nodes.\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n\nExample 2:\n\nInput: n = 1\nOutput: 1",
        "level": "Medium",
        "tags": [
            "Binary Search Tree",
            "Dynamic Programming"
        ],
        "test_cases": {
            "inputs": [
                3,
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19
            ],
            "outputs": [
                5,
                1,
                2,
                14,
                42,
                132,
                429,
                1430,
                4862,
                16796,
                58786,
                208012,
                742900,
                2674440,
                9694845,
                35357670,
                129644790,
                477638700,
                1767263190
            ]
        },
        "sample_code": {
            "c++": "int numTrees(int n) {\n    vector<int> dp(n + 1, 0);\n    dp[0] = dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        for (int j = 0; j < i; j++) {\n            dp[i] += dp[j] * dp[i - j - 1];\n        }\n    }\n    return dp[n];\n}\n",
            "java": "public int numTrees(int n) {\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        for (int j = 0; j < i; j++) {\n            dp[i] += dp[j] * dp[i - j - 1];\n        }\n    }\n    return dp[n];\n}\n",
            "python": "def numTrees(n):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n    return dp[n]\n",
            "javascript": "function numTrees(n) {\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = 1;\n    for (let i = 2; i <= n; i++) {\n        for (let j = 0; j < i; j++) {\n            dp[i] += dp[j] * dp[i - j - 1];\n        }\n    }\n    return dp[n];\n}\n",
            "explanation": "The algorithm is based on dynamic programming. We create an array `dp` of length `n + 1`, with `dp[0]` and `dp[1]` equal to 1, which corresponds to the cases of 0 and 1 node respectively. Next, we iterate from 2 to `n`, and for each value `i`, we iterate from 0 to `i` and accumulate `dp[j] * dp[i - j - 1]` in `dp[i]`. This process represents the number of structurally unique BSTs for the left subtree and right subtree for each possible node arrangement of the BST. At the end, `dp[n]` represents the number of structurally unique BSTs with precisely n nodes."
        },
        "structure": {
            "c++": "int numTrees(int n)  {\n    // Your code here\n}\n",
            "java": "public int numTrees(int n)  {\n    // Your code here\n}\n",
            "python": "def numTrees(n):\n    # Your code here\n\n",
            "javascript": "function numTrees(n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = numTrees(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int numTrees(int n) {\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        for (int j = 0; j < i; j++) {\n            dp[i] += dp[j] * dp[i - j - 1];\n        }\n    }\n    return dp[n];\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = numTrees(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = numTrees(n);\n    console.log(result);\n}"
        },
        "Qid": "96"
    },
    {
        "_id": {
            "$oid": "661e8964555605d7c12757e3"
        },
        "title": "Pascal's Triangle Row",
        "description": "Given an integer `rowIndex`, return the `rowIndexth` (0-indexed) row of the Pascal's triangle. In Pascal's triangle, each number is the sum of the two numbers directly above it.",
        "example": "Example:\n\nInput: rowIndex = 3\nOutput: [1,3,3,1]\n\nExplanation: The 3rd row of Pascal's triangle is [1,3,3,1].\n\nInput: rowIndex = 0\nOutput: [1]\n\nExplanation: The 0th row of Pascal's triangle is [1].\n\nInput: rowIndex = 1\nOutput: [1,1]\n\nExplanation: The 1st row of Pascal's triangle is [1,1].",
        "level": "Easy",
        "tags": [
            "Array",
            "Math"
        ],
        "test_cases": {
            "inputs": [
                3,
                0,
                1,
                5,
                10
            ],
            "outputs": [
                [
                    1,
                    3,
                    3,
                    1
                ],
                [
                    1
                ],
                [
                    1,
                    1
                ],
                [
                    1,
                    5,
                    10,
                    10,
                    5,
                    1
                ],
                [
                    1,
                    10,
                    45,
                    120,
                    210,
                    252,
                    210,
                    120,
                    45,
                    10,
                    1
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> getRow(int rowIndex) {\n    vector<int> row(rowIndex + 1, 1);\n    for (int i = 1; i <= rowIndex; i++) {\n        for (int j = i - 1; j > 0; j--) {\n            row[j] += row[j - 1];\n        }\n    }\n    return row;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> getRow(int rowIndex) {\n    List<Integer> row = new ArrayList<>();\n    for (int i = 0; i <= rowIndex; i++) {\n        row.add(1);\n        for (int j = i - 1; j > 0; j--) {\n            row.set(j, row.get(j) + row.get(j - 1));\n        }\n    }\n    return row;\n}\n",
            "python": "def get_row(rowIndex):\n    row = [1] * (rowIndex + 1)\n    for i in range(1, rowIndex + 1):\n        for j in range(i - 1, 0, -1):\n            row[j] += row[j - 1]\n    return row\n",
            "javascript": "function getRow(rowIndex) {\n    const row = new Array(rowIndex + 1).fill(1);\n    for (let i = 1; i <= rowIndex; i++) {\n        for (let j = i - 1; j > 0; j--) {\n            row[j] += row[j - 1];\n        }\n    }\n    return row;\n}\n",
            "explanation": "The algorithm initializes the row with the given rowIndex size and fills it with 1s. Then, we iterate through the rowIndex and update each entry of the row using the sum of the two numbers directly above it (based on Pascal's triangle property), i.e., row[j] = row[j] + row[j-1]. We get the rowIndexth row of Pascal's triangle once the iterations are completed."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> getRow(int rowIndex)  {\n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> getRow(int rowIndex)  {\n    // Your code here\n}\n",
            "python": "def get_row(rowIndex):\n    # Your code here\n\n",
            "javascript": "function getRow(rowIndex)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nint main() {\n    int rowIndex = $args;\n    vector<int> result = getRow(rowIndex);\n    for (int i = 0; i < result.size(); i++) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "java": "public List<Integer> getRow(int rowIndex) {\n    List<Integer> row = new ArrayList<>();\n    for (int i = 0; i <= rowIndex; i++) {\n        row.add(1);\n        for (int j = i - 1; j > 0; j--) {\n            row.set(j, row.get(j) + row.get(j - 1));\n        }\n    }\n    return row;\n}",
            "python": "if __name__ == \"__main__\":\n    rowIndex = $args\n    result = get_row(rowIndex)\n    print(result)",
            "javascript": "function main() {\n    const rowIndex = $args;\n    const result = getRow(rowIndex);\n    console.log(result);\n}"
        },
        "Qid": "119"
    },
    {
        "_id": {
            "$oid": "661e8bf2555605d7c12757e4"
        },
        "title": "Two Sum II - Input array is sorted",
        "description": "Given a 1-indexed array of integers `numbers` that is already sorted in non-decreasing order, find two numbers such that they add up to a specific `target` number. Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 <= numbers.length`.\n\nReturn the indices of the two numbers, `index1` and `index2`, added by one as an integer array `[index1, index2]` of length 2.\n\nYour solution must use only constant extra space.",
        "example": "Example 1:\n\nInput: numbers = [2,7,11,15], target = 9\nOutput: [1,2]\nExplanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].\n\nExample 2:\n\nInput: numbers = [2,3,4], target = 6\nOutput: [1,3]\nExplanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3].\n\nExample 3:\n\nInput: numbers = [-1,0], target = -1\nOutput: [1,2]\nExplanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2].",
        "level": "Easy",
        "tags": [
            "Array",
            "Two Pointers"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        2,
                        7,
                        11,
                        15
                    ],
                    9
                ],
                [
                    [
                        2,
                        3,
                        4
                    ],
                    6
                ],
                [
                    [
                        -1,
                        0
                    ],
                    -1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    9
                ],
                [
                    [
                        -5,
                        -3,
                        0,
                        1,
                        3,
                        6,
                        9,
                        12,
                        15,
                        18
                    ],
                    9
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    17
                ],
                [
                    [
                        -10,
                        -5,
                        0,
                        5,
                        10,
                        15,
                        20,
                        25,
                        30,
                        35
                    ],
                    25
                ],
                [
                    [
                        1,
                        3,
                        5,
                        7,
                        9,
                        11,
                        13,
                        15,
                        17,
                        19
                    ],
                    20
                ],
                [
                    [
                        -1000,
                        -900,
                        -800,
                        -700,
                        -600,
                        -500,
                        -400,
                        -300,
                        -200,
                        -100
                    ],
                    -100
                ],
                [
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    0
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    2
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    11
                ],
                [
                    [
                        -10,
                        -5,
                        0,
                        5,
                        10,
                        15,
                        20,
                        25,
                        30,
                        35
                    ],
                    45
                ],
                [
                    [
                        1,
                        3,
                        5,
                        7,
                        9,
                        11,
                        13,
                        15,
                        17,
                        19
                    ],
                    18
                ],
                [
                    [
                        -1000,
                        -900,
                        -800,
                        -700,
                        -600,
                        -500,
                        -400,
                        -300,
                        -200,
                        -100
                    ],
                    -1000
                ],
                [
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ],
                    10
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    5
                ],
                [
                    [
                        -10,
                        -5,
                        0,
                        5,
                        10,
                        15,
                        20,
                        25,
                        30,
                        35
                    ],
                    0
                ],
                [
                    [
                        1,
                        3,
                        5,
                        7,
                        9,
                        11,
                        13,
                        15,
                        17,
                        19
                    ],
                    16
                ]
            ],
            "outputs": [
                [
                    1,
                    2
                ],
                [
                    1,
                    3
                ],
                [
                    1,
                    2
                ],
                [
                    4,
                    5
                ],
                [
                    2,
                    6
                ],
                [
                    7,
                    10
                ],
                [
                    4,
                    6
                ],
                [
                    8,
                    9
                ],
                [
                    9,
                    10
                ],
                [
                    1,
                    2
                ],
                [
                    1,
                    2
                ],
                [
                    10,
                    11
                ],
                [
                    5,
                    10
                ],
                [
                    8,
                    9
                ],
                [
                    1,
                    10
                ],
                [
                    1,
                    2
                ],
                [
                    1,
                    5
                ],
                [
                    1,
                    6
                ],
                [
                    1,
                    8
                ],
                [
                    3,
                    9
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> twoSum(vector<int>& numbers, int target) {\n    int left = 0, right = numbers.size() - 1;\n    while (left < right) {\n        int current_sum = numbers[left] + numbers[right];\n        if (current_sum == target) {\n            return {left + 1, right + 1};\n        } else if (current_sum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return {};\n}\n",
            "java": "public int[] twoSum(int[] numbers, int target) {\n    int left = 0, right = numbers.length - 1;\n    while (left < right) {\n        int current_sum = numbers[left] + numbers[right];\n        if (current_sum == target) {\n            return new int[]{left + 1, right + 1};\n        } else if (current_sum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return new int[]{};\n}\n",
            "python": "def twoSum(numbers, target):\n    left, right = 0, len(numbers) - 1\n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        if current_sum == target:\n            return [left + 1, right + 1]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n",
            "javascript": "function twoSum(numbers, target) {\n    let left = 0, right = numbers.length - 1;\n    while (left < right) {\n        let current_sum = numbers[left] + numbers[right];\n        if (current_sum === target) {\n            return [left + 1, right + 1];\n        } else if (current_sum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return [];\n}\n",
            "explanation": "The algorithm uses a two-pointer approach. Initialize two pointers, `left` and `right`, to the first and last elements of the sorted array. Then, iterate until `left < right`. In each iteration, calculate the sum of the elements pointed to by `left` and `right`. If the sum equals the target, return the indices of the two numbers (1-indexed). If the sum is less than the target, increment `left` to consider a larger number. If the sum is greater than the target, decrement `right` to consider a smaller number. Since the input is guaranteed to have a solution, the loop will always return a valid result. This algorithm has a constant space complexity as it does not use any additional data structures."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> twoSum(vector<int>& numbers, int target)  {\n    // Your code here\n}\n",
            "java": "public int[] twoSum(int[] numbers, int target)  {\n    // Your code here\n}\n",
            "python": "def twoSum(numbers, target):\n    # Your code here\n\n",
            "javascript": "function twoSum(numbers, target)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nint main() {\n    vector<int> numbers = $args;\n    int target = $args;\n    vector<int> result = twoSum(numbers, target);\n    for (int i : result) {\n        cout << i << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n",
            "java": "public int[] twoSum(int[] numbers, int target) {\n    int left = 0, right = numbers.length - 1;\n    while (left < right) {\n        int current_sum = numbers[left] + numbers[right];\n        if (current_sum == target) {\n            return new int[]{left + 1, right + 1};\n        } else if (current_sum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return new int[]{};\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    numbers = inputs[0]\n    target = inputs[1]\n    result = twoSum(numbers, target)\n    print(result)",
            "javascript": "function main() {\n    const numbers = $args[0];\n    const target = $args[1];\n    const result = twoSum(numbers, target);\n    console.log(result);\n}"
        },
        "Qid": "167"
    },
    {
        "_id": {
            "$oid": "661e8c10555605d7c12757e5"
        },
        "title": "Trailing Zeroes in Factorial",
        "description": "Given an integer `n`, return the number of trailing zeroes in `n!`. The factorial of a number `n` is the product of all positive integers less than or equal to `n`. For example, `5! = 5 * 4 * 3 * 2 * 1 = 120`. A trailing zero is a zero that appears at the end of a number. For example, `120` has one trailing zero. Your task is to implement a function `trailingZeroes(n: int) -> int` that calculates the number of trailing zeroes in `n!`.",
        "example": "Example:\n\nInput: n = 5\nOutput: 1\nExplanation: 5! = 120, which has one trailing zero.",
        "level": "Easy",
        "tags": [
            "Math",
            "Factorial",
            "Counting"
        ],
        "test_cases": {
            "inputs": [
                3,
                5,
                10,
                15,
                20,
                25,
                30,
                50,
                100,
                1000,
                5000,
                10000,
                100000
            ],
            "outputs": [
                0,
                1,
                2,
                3,
                4,
                6,
                7,
                12,
                24,
                249,
                1249,
                2499,
                24999
            ]
        },
        "sample_code": {
            "c++": "int trailingZeroes(int n) {\n    int count = 0;\n    while (n > 0) {\n        n /= 5;\n        count += n;\n    }\n    return count;\n}\n\n",
            "java": "public int trailingZeroes(int n) {\n    int count = 0;\n    while (n > 0) {\n        n = n / 5;\n        count += n;\n    }\n    return count;\n}\n\n",
            "python": "def trailing_zeroes(n: int) -> int:\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count\n\n",
            "javascript": "function trailingZeroes(n) {\n    let count = 0;\n    while (n > 0) {\n        n = Math.floor(n / 5);\n        count += n;\n    }\n    return count;\n}\n\n",
            "explanation": "The given problem requires us to calculate the number of trailing zeroes in n! (factorial of n). Trailing zeroes are formed by the product of 2 and 5. For example, 20! has 4 trailing zeroes as there are 4 instances of 2 * 5 (10, 20, 30, and 50). We know there are plenty of even factors in a factorial, so we just need to count how many times the factor 5 appears.\n\nThe algorithm we use here is dividing n by 5 iteratively until n becomes 0. In each step, we divide n by 5 and add the quotient to the count. Finally, we return the count as the result."
        },
        "structure": {
            "c++": "int trailingZeroes(int n)  {\n    // Your code here\n}\n\n",
            "java": "public int trailingZeroes(int n)  {\n    // Your code here\n}\n\n",
            "python": "def trailing_zeroes(n: int) -> int:\n    # Your code here\n\n",
            "javascript": "function trailingZeroes(n)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = trailingZeroes(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int trailingZeroes(int n) {\n    int count = 0;\n    while (n > 0) {\n        n = n / 5;\n        count += n;\n    }\n    return count;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = trailing_zeroes(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = trailingZeroes(n);\n    console.log(result);\n}\n"
        },
        "Qid": "172"
    },
    {
        "_id": {
            "$oid": "661e8c29555605d7c12757e6"
        },
        "title": "Reverse Words in Character Array",
        "description": "Given a character array `s`, reverse the order of the words. A word is defined as a sequence of non-space characters. The words in `s` will be separated by a single space. Your task is to solve the problem in-place, without allocating extra space.",
        "example": "Example:\n\nInput: s = [\"t\",\"h\",\"e\",\" \",\"s\",\"k\",\"y\",\" \",\"i\",\"s\",\" \",\"b\",\"l\",\"u\",\"e\"]\nOutput: [\"b\",\"l\",\"u\",\"e\",\" \",\"i\",\"s\",\" \",\"s\",\"k\",\"y\",\" \",\"t\",\"h\",\"e\"]\n\nExplanation: The words in the character array are \"the\", \"sky\", and \"is\". Reversing the order of the words gives us \"is\", \"sky\", and \"the\".",
        "level": "Medium",
        "tags": [
            "array",
            "string",
            "in-place"
        ],
        "test_cases": {
            "inputs": [
                [
                    "t",
                    "h",
                    "e",
                    " ",
                    "s",
                    "k",
                    "y",
                    " ",
                    "i",
                    "s",
                    " ",
                    "b",
                    "l",
                    "u",
                    "e"
                ],
                [
                    "a"
                ],
                [
                    "h",
                    "e",
                    "l",
                    "l",
                    "o",
                    " ",
                    "w",
                    "o",
                    "r",
                    "l",
                    "d"
                ],
                [
                    "c",
                    "o",
                    "d",
                    "i",
                    "n",
                    "g",
                    " ",
                    "i",
                    "s",
                    " ",
                    "f",
                    "u",
                    "n"
                ],
                [
                    "r",
                    "e",
                    "v",
                    "e",
                    "r",
                    "s",
                    "e",
                    " ",
                    "m",
                    "e"
                ],
                [
                    "p",
                    "r",
                    "o",
                    "g",
                    "r",
                    "a",
                    "m",
                    "m",
                    "i",
                    "n",
                    "g",
                    " ",
                    "i",
                    "s",
                    " ",
                    "a",
                    "w",
                    "e",
                    "s",
                    "o",
                    "m",
                    "e"
                ],
                [
                    "l",
                    "e",
                    "t",
                    "`",
                    "s",
                    " ",
                    "g",
                    "e",
                    "t",
                    " ",
                    "s",
                    "t",
                    "a",
                    "r",
                    "t",
                    "e",
                    "d"
                ],
                [
                    "t",
                    "h",
                    "i",
                    "s",
                    " ",
                    "i",
                    "s",
                    " ",
                    "a",
                    " ",
                    "t",
                    "e",
                    "s",
                    "t"
                ],
                [
                    "r",
                    "e",
                    "v",
                    "e",
                    "r",
                    "s",
                    "e",
                    " ",
                    "t",
                    "h",
                    "e",
                    " ",
                    "s",
                    "t",
                    "r",
                    "i",
                    "n",
                    "g"
                ],
                [
                    "h",
                    "a",
                    "p",
                    "p",
                    "y",
                    " ",
                    "c",
                    "o",
                    "d",
                    "i",
                    "n",
                    "g"
                ],
                [
                    "w",
                    "e",
                    "l",
                    "c",
                    "o",
                    "m",
                    "e",
                    " ",
                    "t",
                    "o",
                    " ",
                    "t",
                    "h",
                    "e",
                    " ",
                    "w",
                    "o",
                    "r",
                    "l",
                    "d"
                ],
                [
                    "p",
                    "r",
                    "a",
                    "c",
                    "t",
                    "i",
                    "c",
                    "e",
                    " ",
                    "m",
                    "a",
                    "k",
                    "e",
                    "s",
                    " ",
                    "p",
                    "e",
                    "r",
                    "f",
                    "e",
                    "c",
                    "t"
                ],
                [
                    "c",
                    "o",
                    "d",
                    "e",
                    " ",
                    "i",
                    "s",
                    " ",
                    "l",
                    "i",
                    "f",
                    "e"
                ],
                [
                    "l",
                    "e",
                    "a",
                    "r",
                    "n",
                    " ",
                    "f",
                    "r",
                    "o",
                    "m",
                    " ",
                    "m",
                    "i",
                    "s",
                    "t",
                    "a",
                    "k",
                    "e",
                    "s"
                ],
                [
                    "i",
                    "m",
                    "p",
                    "r",
                    "o",
                    "v",
                    "e",
                    " ",
                    "y",
                    "o",
                    "u",
                    "r",
                    " ",
                    "s",
                    "k",
                    "i",
                    "l",
                    "l",
                    "s"
                ],
                [
                    "s",
                    "u",
                    "c",
                    "c",
                    "e",
                    "s",
                    "s",
                    " ",
                    "c",
                    "o",
                    "m",
                    "e",
                    "s",
                    " ",
                    "f",
                    "r",
                    "o",
                    "m",
                    " ",
                    "h",
                    "a",
                    "r",
                    "d",
                    " ",
                    "w",
                    "o",
                    "r",
                    "k"
                ],
                [
                    "d",
                    "o",
                    "n",
                    "`",
                    "t",
                    " ",
                    "g",
                    "i",
                    "v",
                    "e",
                    " ",
                    "u",
                    "p"
                ],
                [
                    "n",
                    "e",
                    "v",
                    "e",
                    "r",
                    " ",
                    "s",
                    "t",
                    "o",
                    "p",
                    " ",
                    "l",
                    "e",
                    "a",
                    "r",
                    "n",
                    "i",
                    "n",
                    "g"
                ],
                [
                    "y",
                    "o",
                    "u",
                    " ",
                    "c",
                    "a",
                    "n",
                    " ",
                    "d",
                    "o",
                    " ",
                    "i",
                    "t"
                ],
                [
                    "b",
                    "e",
                    "l",
                    "i",
                    "e",
                    "v",
                    "e",
                    " ",
                    "i",
                    "n",
                    " ",
                    "y",
                    "o",
                    "u",
                    "r",
                    "s",
                    "e",
                    "l",
                    "f"
                ]
            ],
            "outputs": [
                "[\"b\",\"l\",\"u\",\"e\",\" \",\"i\",\"s\",\" \",\"s\",\"k\",\"y\",\" \",\"t\",\"h\",\"e\"]",
                "[\"a\"]",
                "[\"w\",\"o\",\"r\",\"l\",\"d\",\" \",\"h\",\"e\",\"l\",\"l\",\"o\"]",
                "[\"f\",\"u\",\"n\",\" \",\"i\",\"s\",\" \",\"c\",\"o\",\"d\",\"i\",\"n\",\"g\"]",
                "[\"m\",\"e\",\" \",\"r\",\"e\",\"v\",\"e\",\"r\",\"s\",\"e\"]",
                "[\"a\",\"w\",\"e\",\"s\",\"o\",\"m\",\"e\",\" \",\"i\",\"s\",\" \",\"p\",\"r\",\"o\",\"g\",\"r\",\"a\",\"m\",\"m\",\"i\",\"n\",\"g\"]",
                "[\"g\",\"e\",\"t\",\" \",\"s\",\"t\",\"a\",\"r\",\"t\",\"e\",\"d\",\" \",\"l\",\"e\",\"t\",\"`\",\"s\"]",
                "[\"t\",\"e\",\"s\",\"t\",\" \",\"a\",\" \",\"i\",\"s\",\" \",\"t\",\"h\",\"i\",\"s\"]",
                "[\"s\",\"t\",\"r\",\"i\",\"n\",\"g\",\" \",\"t\",\"h\",\"e\",\" \",\"r\",\"e\",\"v\",\"e\",\"r\",\"s\",\"e\"]",
                "[\"c\",\"o\",\"d\",\"i\",\"n\",\"g\",\" \",\"h\",\"a\",\"p\",\"p\",\"y\"]",
                "[\"w\",\"o\",\"r\",\"l\",\"d\",\" \",\"t\",\"h\",\"e\",\" \",\"o\",\"t\",\"o\",\"g\",\"e\",\"r\",\"w\",\"e\",\"l\"]",
                "[\"p\",\"e\",\"r\",\"f\",\"e\",\"c\",\"t\",\" \",\"m\",\"a\",\"k\",\"e\",\"s\",\" \",\"p\",\"r\",\"a\",\"c\",\"t\",\"i\",\"c\",\"e\"]",
                "[\"l\",\"i\",\"f\",\"e\",\" \",\"i\",\"s\",\" \",\"c\",\"o\",\"d\",\"e\"]",
                "[\"m\",\"i\",\"s\",\"t\",\"a\",\"k\",\"e\",\"s\",\" \",\"f\",\"r\",\"o\",\"m\",\" \",\"l\",\"e\",\"a\",\"r\",\"n\"]",
                "[\"s\",\"k\",\"i\",\"l\",\"l\",\"s\",\" \",\"y\",\"o\",\"u\",\"r\",\" \",\"e\",\"v\",\"e\",\"r\",\"p\",\"m\",\"i\"]",
                "[\"w\",\"o\",\"r\",\"k\",\" \",\"h\",\"a\",\"r\",\"d\",\" \",\"f\",\"r\",\"o\",\"m\",\" \",\"s\",\"e\",\"m\",\"o\",\"c\",\"s\",\"s\",\"u\",\"c\"]",
                "[\"u\",\"p\",\" \",\"e\",\"v\",\"i\",\"g\",\"n\",\"o\",\"d\"]",
                "[\"l\",\"e\",\"a\",\"r\",\"n\",\"i\",\"n\",\"g\",\" \",\"s\",\"t\",\"o\",\"p\",\" \",\"n\",\"e\",\"v\",\"e\",\"r\"]",
                "[\"i\",\"t\",\" \",\"o\",\"d\",\"n\",\"`\",\"t\",\" \",\"n\",\"o\",\"d\",\"`\",\"t\",\" \",\"a\",\"c\",\"n\",\"`\",\"t\"]",
                "[\"f\",\"l\",\"e\",\"s\",\"r\",\"u\",\"e\",\"b\",\"i\",\"l\",\"e\",\"v\",\"e\",\" \",\"n\",\"i\",\" \",\"r\",\"u\",\"o\",\"y\",\"s\",\"e\",\"l\",\"f\"]"
            ]
        },
        "sample_code": {
            "c++": "void reverseWords(vector<char>& s) {\n    reverse(s.begin(), s.end());\n    int start = 0, end;\n    while ((end = find(s.begin() + start, s.end(), ' ') - s.begin()) < s.size()) {\n        reverse(s.begin() + start, s.begin() + end);\n        start = end + 1;\n    }\n    reverse(s.begin() + start, s.end());\n}\n",
            "java": "public void reverseWords(char[] s) {\n    reverse(s, 0, s.length - 1);\n    int start = 0;\n    for (int i = 0; i <= s.length; i++) {\n        if (i == s.length || s[i] == ' ') {\n            reverse(s, start, i - 1);\n            start = i + 1;\n        }\n    }\n}\n\nprivate void reverse(char[] s, int start, int end) {\n    while (start < end) {\n        char temp = s[start];\n        s[start++] = s[end];\n        s[end--] = temp;\n    }\n}\n",
            "python": "def reverseWords(s: list) -> None:\n    def reverse(s, start, end):\n        while start < end:\n            s[start], s[end] = s[end], s[start]\n            start += 1\n            end -= 1\n\n    reverse(s, 0, len(s)-1)\n    start = 0\n    for i, char in enumerate(s + [' ']):\n        if char == ' ':\n            reverse(s, start, i - 1)\n            start = i + 1\n",
            "javascript": "function reverseWords(s) {\n    function reverse(s, start, end) {\n        while (start < end) {\n            [s[start], s[end]] = [s[end], s[start]];\n            start++;\n            end--;\n        }\n    }\n\n    reverse(s, 0, s.length - 1);\n    let start = 0;\n    for (let i = 0; i <= s.length; i++) {\n        if (i === s.length || s[i] === ' ') {\n            reverse(s, start, i - 1);\n            start = i + 1;\n        }\n    }\n}\n",
            "explanation": "1. Reverse the whole array.\n2. Traverse elements in the reversed array.\n3. If the current element is a space, reverse the sub-array from the start of the word to the last element before the space. Then, set start to the next element after space.\n4. If it's the end of the array, reverse the sub-array from the start of the array to the last element."
        },
        "structure": {
            "c++": "void reverseWords(vector<char>& s)  {\n    // Your code here\n}\n",
            "java": "public void reverseWords(char[] s)  {\n    // Your code here\n}\n",
            "python": "def reverseWords(s: list) -> None:\n    # Your code here\n\n",
            "javascript": "function reverseWords(s)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "void reverseWords(vector<char>& s) {\n    reverse(s.begin(), s.end());\n    int start = 0, end;\n    while ((end = find(s.begin() + start, s.end(), ' ') - s.begin()) < s.size()) {\n        reverse(s.begin() + start, s.begin() + end);\n        start = end + 1;\n    }\n    reverse(s.begin() + start, s.end());\n}",
            "java": "public void reverseWords(char[] s) {\n    reverse(s, 0, s.length - 1);\n    int start = 0;\n    for (int i = 0; i <= s.length; i++) {\n        if (i == s.length || s[i] == ' ') {\n            reverse(s, start, i - 1);\n            start = i + 1;\n        }\n    }\n}\n\nprivate void reverse(char[] s, int start, int end) {\n    while (start < end) {\n        char temp = s[start];\n        s[start++] = s[end];\n        s[end--] = temp;\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    reverseWords(s)\n    print(s)",
            "javascript": "function main() {\n    const s = $args;\n    reverseWords(s);\n    console.log(s);\n}"
        },
        "Qid": "186"
    },
    {
        "_id": {
            "$oid": "661e8c52555605d7c12757e7"
        },
        "title": "Bitwise AND of Numbers Range",
        "description": "Given two integers `left` and `right` that represent the range `[left, right]`, return the bitwise AND of all numbers in this range, inclusive.",
        "example": "Example:\n\nInput: left = 5, right = 7\nOutput: 4\n\nExplanation: The numbers in the range [5, 7] are 5, 6, and 7. The bitwise AND of these numbers is 4 (0100 in binary).",
        "level": "Medium",
        "tags": [
            "bit manipulation",
            "range",
            "inclusive"
        ],
        "test_cases": {
            "inputs": [
                [
                    5,
                    7
                ],
                [
                    0,
                    0
                ],
                [
                    1,
                    2147483647
                ],
                [
                    10,
                    15
                ],
                [
                    100,
                    100
                ],
                [
                    0,
                    1
                ],
                [
                    2,
                    2
                ],
                [
                    3,
                    3
                ],
                [
                    4,
                    4
                ],
                [
                    5,
                    5
                ],
                [
                    6,
                    6
                ],
                [
                    7,
                    7
                ],
                [
                    8,
                    8
                ],
                [
                    9,
                    9
                ],
                [
                    10,
                    10
                ],
                [
                    11,
                    11
                ],
                [
                    12,
                    12
                ],
                [
                    13,
                    13
                ],
                [
                    14,
                    14
                ],
                [
                    15,
                    15
                ]
            ],
            "outputs": [
                4,
                0,
                0,
                8,
                100,
                0,
                2,
                0,
                4,
                0,
                6,
                0,
                8,
                0,
                10,
                0,
                12,
                0,
                14,
                0
            ]
        },
        "sample_code": {
            "c++": "int rangeBitwiseAnd(int left, int right) {\n    int shift = 0;\n    while (left != right) {\n        left >>= 1;\n        right >>= 1;\n        ++shift;\n    }\n    return left << shift;\n}\n",
            "java": "public int rangeBitwiseAnd(int left, int right) {\n    int shift = 0;\n    while (left != right) {\n        left >>= 1;\n        right >>= 1;\n        shift++;\n    }\n    return left << shift;\n}\n",
            "python": "def range_bitwise_and(left: int, right: int) -> int:\n    shift = 0\n    while left != right:\n        left >>= 1\n        right >>= 1\n        shift += 1\n    return left << shift\n",
            "javascript": "function rangeBitwiseAnd(left, right) {\n    let shift = 0;\n    while (left != right) {\n        left >>= 1;\n        right >>= 1;\n        shift++;\n    }\n    return left << shift;\n}\n",
            "explanation": "The algorithm works by performing a bitwise right shift on both the left and right edge of the range until both numbers become equal. This is done because the common bits to the left of the different bits are the bits that will survive the AND operation for all numbers in the range.\n\nSince we right shifted x times, we perform a left shift x times on the equal numbers to restore the original position of the bits. As a result, we get the final bitwise AND of all the numbers in the range. This algorithm has a complexity of O(log N) due to the bitwise manipulation."
        },
        "structure": {
            "c++": "int rangeBitwiseAnd(int left, int right)  {\n    // Your code here\n}\n",
            "java": "public int rangeBitwiseAnd(int left, int right)  {\n    // Your code here\n}\n",
            "python": "def range_bitwise_and(left: int, right: int) -> int:\n    # Your code here\n\n",
            "javascript": "function rangeBitwiseAnd(left, right)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int left = $args;\n    int right = $args;\n    int result = rangeBitwiseAnd(left, right);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int rangeBitwiseAnd(int left, int right) {\n    int shift = 0;\n    while (left != right) {\n        left >>= 1;\n        right >>= 1;\n        shift++;\n    }\n    return left << shift;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    left = inputs[0]\n    right = inputs[1]\n    result = range_bitwise_and(left, right)\n    print(result)",
            "javascript": "function main() {\n    const left = $args[0];\n    const right = $args[1];\n    const result = rangeBitwiseAnd(left, right);\n    console.log(result);\n}"
        },
        "Qid": "201"
    },
    {
        "_id": {
            "$oid": "661e8c8d555605d7c12757e8"
        },
        "title": "Power of Two",
        "description": "Given an integer `n`, determine if it is a power of two. Return `true` if `n` is a power of two, otherwise return `false`. An integer `n` is a power of two if there exists an integer `x` such that `n == 2^x`.",
        "example": "Example 1:\n\nInput: n = 1\nOutput: true\nExplanation: 2^0 = 1\n\nExample 2:\n\nInput: n = 16\nOutput: true\nExplanation: 2^4 = 16\n\nExample 3:\n\nInput: n = 3\nOutput: false",
        "level": "Easy",
        "tags": [
            "Math",
            "Bit Manipulation"
        ],
        "test_cases": {
            "inputs": [
                1,
                16,
                3,
                0,
                2,
                8,
                10,
                32,
                100,
                1024,
                2048,
                4096,
                8192,
                16384,
                32768,
                65536,
                131072,
                262144,
                524288,
                1048576
            ],
            "outputs": [
                true,
                true,
                false,
                false,
                true,
                true,
                false,
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "bool isPowerOfTwo(int n) {\n    if (n <= 0) {\n        return false;\n    }\n    return (n & (n - 1)) == 0;\n}\n",
            "java": "boolean isPowerOfTwo(int n) {\n    if (n <= 0) {\n        return false;\n    }\n    return (n & (n - 1)) == 0;\n}\n",
            "python": "def is_power_of_two(n):\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0\n",
            "javascript": "function isPowerOfTwo(n) {\n    if (n <= 0) {\n        return false;\n    }\n    return (n & (n - 1)) == 0;\n}\n",
            "explanation": "The algorithm checks if the given integer n is a power of two. First, we check if n is a negative number or zero, in which case it cannot be a power of two, so we return false. \n\nIf n is positive, we can use bitwise manipulation to check if it's a power of two. A power of two in binary representation has only one bit set to 1 (e.g., 1: 001, 2: 010, 4: 100, 8: 1000). When we subtract 1 from a power of two, all the bits from the right of the set bit become 1 (e.g., 1-1: 000, 2-1: 001, 4-1: 011, 8-1: 0111). \n\nBy performing bitwise AND operation (n & (n-1)) between n and (n-1), we can check if there is only one bit set in n. If the result is 0, that means there is no overlapping bit between n and (n-1), indicating that n is a power of two; returning true. Otherwise, return false."
        },
        "structure": {
            "c++": "bool isPowerOfTwo(int n)  {\n    // Your code here\n}\n",
            "java": "boolean isPowerOfTwo(int n)  {\n    // Your code here\n}\n",
            "python": "def is_power_of_two(n):\n    # Your code here\n\n",
            "javascript": "function isPowerOfTwo(n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n = $args;\n    bool result = isPowerOfTwo(n);\n    cout << boolalpha << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    int n = $args;\n    boolean result = isPowerOfTwo(n);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = is_power_of_two(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = isPowerOfTwo(n);\n    console.log(result);\n}"
        },
        "Qid": "231"
    },
    {
        "_id": {
            "$oid": "661e8cb9555605d7c12757e9"
        },
        "title": "Search in Sorted Matrix",
        "description": "You are given an `m x n` matrix where each row and each column is sorted in ascending order. Write a function that efficiently searches for a target value in the matrix. If the target value is found, return true; otherwise, return false.",
        "example": "For example, consider the following matrix:\n\nmatrix = [[1, 4, 7, 11, 15],\n          [2, 5, 8, 12, 19],\n          [3, 6, 9, 16, 22],\n          [10, 13, 14, 17, 24],\n          [18, 21, 23, 26, 30]]\n\nIf we search for the target value 5, the function should return true. However, if we search for the target value 20, the function should return false.",
        "level": "Medium",
        "tags": [
            "matrix",
            "search",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        [
                            1,
                            4,
                            7,
                            11,
                            15
                        ],
                        [
                            2,
                            5,
                            8,
                            12,
                            19
                        ],
                        [
                            3,
                            6,
                            9,
                            16,
                            22
                        ],
                        [
                            10,
                            13,
                            14,
                            17,
                            24
                        ],
                        [
                            18,
                            21,
                            23,
                            26,
                            30
                        ]
                    ],
                    5
                ],
                [
                    [
                        [
                            1,
                            4,
                            7,
                            11,
                            15
                        ],
                        [
                            2,
                            5,
                            8,
                            12,
                            19
                        ],
                        [
                            3,
                            6,
                            9,
                            16,
                            22
                        ],
                        [
                            10,
                            13,
                            14,
                            17,
                            24
                        ],
                        [
                            18,
                            21,
                            23,
                            26,
                            30
                        ]
                    ],
                    20
                ],
                [
                    [
                        [
                            -5,
                            -4,
                            -3,
                            -2
                        ],
                        [
                            -3,
                            -2,
                            -1,
                            0
                        ],
                        [
                            -1,
                            0,
                            1,
                            2
                        ],
                        [
                            0,
                            1,
                            2,
                            3
                        ]
                    ],
                    -2
                ],
                [
                    [
                        [
                            -5,
                            -4,
                            -3,
                            -2
                        ],
                        [
                            -3,
                            -2,
                            -1,
                            0
                        ],
                        [
                            -1,
                            0,
                            1,
                            2
                        ],
                        [
                            0,
                            1,
                            2,
                            3
                        ]
                    ],
                    4
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10
                        ],
                        [
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            16,
                            17,
                            18,
                            19,
                            20
                        ]
                    ],
                    15
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10
                        ],
                        [
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            16,
                            17,
                            18,
                            19,
                            20
                        ]
                    ],
                    21
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10
                        ],
                        [
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            16,
                            17,
                            18,
                            19,
                            20
                        ]
                    ],
                    0
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10
                        ],
                        [
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            16,
                            17,
                            18,
                            19,
                            20
                        ]
                    ],
                    8
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10
                        ],
                        [
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            16,
                            17,
                            18,
                            19,
                            20
                        ]
                    ],
                    25
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10
                        ],
                        [
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            16,
                            17,
                            18,
                            19,
                            20
                        ]
                    ],
                    -1
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10
                        ],
                        [
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            16,
                            17,
                            18,
                            19,
                            20
                        ]
                    ],
                    6
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10
                        ],
                        [
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            16,
                            17,
                            18,
                            19,
                            20
                        ]
                    ],
                    11
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10
                        ],
                        [
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            16,
                            17,
                            18,
                            19,
                            20
                        ]
                    ],
                    16
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10
                        ],
                        [
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            16,
                            17,
                            18,
                            19,
                            20
                        ]
                    ],
                    1
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10
                        ],
                        [
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            16,
                            17,
                            18,
                            19,
                            20
                        ]
                    ],
                    18
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10
                        ],
                        [
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            16,
                            17,
                            18,
                            19,
                            20
                        ]
                    ],
                    3
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10
                        ],
                        [
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            16,
                            17,
                            18,
                            19,
                            20
                        ]
                    ],
                    13
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10
                        ],
                        [
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            16,
                            17,
                            18,
                            19,
                            20
                        ]
                    ],
                    19
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10
                        ],
                        [
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            16,
                            17,
                            18,
                            19,
                            20
                        ]
                    ],
                    2
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10
                        ],
                        [
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            16,
                            17,
                            18,
                            19,
                            20
                        ]
                    ],
                    7
                ],
                [
                    [
                        [
                            1,
                            2,
                            3,
                            4,
                            5
                        ],
                        [
                            6,
                            7,
                            8,
                            9,
                            10
                        ],
                        [
                            11,
                            12,
                            13,
                            14,
                            15
                        ],
                        [
                            16,
                            17,
                            18,
                            19,
                            20
                        ]
                    ],
                    12
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                false,
                true,
                false,
                false,
                true,
                false,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "bool searchMatrix(vector<vector<int>>& matrix, int target) {\n    int row = matrix.size() - 1, col = 0;\n    while (row >= 0 && col < matrix[0].size()) {\n        if (matrix[row][col] > target) {\n            row--;\n        } else if (matrix[row][col] < target) {\n            col++;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n",
            "java": "public boolean searchMatrix(int[][] matrix, int target) {\n    int row = matrix.length - 1, col = 0;\n    while (row >= 0 && col < matrix[0].length) {\n        if (matrix[row][col] > target) {\n            row--;\n        } else if (matrix[row][col] < target) {\n            col++;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n",
            "python": "def searchMatrix(matrix, target):\n    row, col = len(matrix) - 1, 0\n    while row >= 0 and col < len(matrix[0]):\n        if matrix[row][col] > target:\n            row -= 1\n        elif matrix[row][col] < target:\n            col += 1\n        else:\n            return True\n    return False\n",
            "javascript": "function searchMatrix(matrix, target) {\n    let row = matrix.length - 1, col = 0;\n    while(row >= 0 && col < matrix[0].length) {\n        if(matrix[row][col] > target) {\n            row--;\n        } else if(matrix[row][col] < target) {\n            col++;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n\n",
            "explanation": "The algorithm starts at the bottom-left corner of the matrix. Then it follows these rules:\n1. If the current value is bigger than the target, then move up in the matrix (because all values above will be smaller).\n2. If the current value is smaller than the target, then move to the right in the matrix (because all values to the right will be bigger).\n3. If the current value is equal to the target, return true.\n\nThis algorithm is efficient as it reduces the search space in every step by either eliminating a row or a column. At most, it will take m + n steps."
        },
        "structure": {
            "c++": "bool searchMatrix(vector<vector<int>>& matrix, int target)  {\n    // Your code here\n}\n",
            "java": "public boolean searchMatrix(int[][] matrix, int target)  {\n    // Your code here\n}\n",
            "python": "def searchMatrix(matrix, target):\n    # Your code here\n\n",
            "javascript": "function searchMatrix(matrix, target)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "bool searchMatrix(vector<vector<int>>& matrix, int target) {\n    int row = matrix.size() - 1, col = 0;\n    while (row >= 0 && col < matrix[0].size()) {\n        if (matrix[row][col] > target) {\n            row--;\n        } else if (matrix[row][col] < target) {\n            col++;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}",
            "java": "public boolean searchMatrix(int[][] matrix, int target) {\n    int row = matrix.length - 1, col = 0;\n    while (row >= 0 && col < matrix[0].length) {\n        if (matrix[row][col] > target) {\n            row--;\n        } else if (matrix[row][col] < target) {\n            col++;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    matrix = inputs[0]\n    target = inputs[1]\n    result = searchMatrix(matrix, target)\n    print(result)",
            "javascript": "function main() {\n    const matrix = $args[0];\n    const target = $args[1];\n    const result = searchMatrix(matrix, target);\n    console.log(result);\n}"
        },
        "Qid": "240"
    },
    {
        "_id": {
            "$oid": "661e8d48555605d7c12757ea"
        },
        "title": "Anagram Check",
        "description": "Given two strings `s` and `t`, determine if `t` is an anagram of `s`. An anagram is a word or phrase formed by rearranging the letters of another word or phrase, using all the original letters exactly once.",
        "example": "Example:\n\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\n\nExplanation: The word \"nagaram\" is an anagram of \"anagram\".\n\nInput: s = \"rat\", t = \"car\"\nOutput: false\n\nExplanation: The word \"car\" is not an anagram of \"rat\".",
        "level": "Easy",
        "tags": [
            "String",
            "Sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    "anagram",
                    "nagaram"
                ],
                [
                    "rat",
                    "car"
                ],
                [
                    "listen",
                    "silent"
                ],
                [
                    "hello",
                    "world"
                ],
                [
                    "abcde",
                    "edcba"
                ],
                [
                    "",
                    ""
                ],
                [
                    "a",
                    "a"
                ],
                [
                    "abcd",
                    "dcba"
                ],
                [
                    "anagram",
                    "nagarama"
                ],
                [
                    "rat",
                    "tar"
                ],
                [
                    "listen",
                    "silentt"
                ],
                [
                    "hello",
                    "hell"
                ],
                [
                    "abcde",
                    "edcbf"
                ],
                [
                    "a",
                    "b"
                ],
                [
                    "abcd",
                    "dcbb"
                ],
                [
                    "anagram",
                    "nagaramm"
                ],
                [
                    "rat",
                    "tarr"
                ],
                [
                    "listen",
                    "silenn"
                ],
                [
                    "hello",
                    "hella"
                ],
                [
                    "abcde",
                    "edcbg"
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                false,
                true,
                true,
                true,
                true,
                false,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "bool isAnagram(std::string s, std::string t) {\n    if(s.size() != t.size())\n        return false;\n    \n    std::unordered_map<char, int> counts;\n    for(char c : s)\n        counts[c]++;\n        \n    for(char c : t) {\n        if(counts[c] == 0)\n            return false;\n        counts[c]--;\n    }\n    \n    return true;\n}\n",
            "java": "public boolean isAnagram(String s, String t) {\n    if(s.length() != t.length())\n        return false;\n\n    int[] counts = new int[26];\n    for(char c : s.toCharArray())\n        counts[c - 'a']++;\n\n    for(char c : t.toCharArray()) {\n        if(counts[c - 'a'] == 0)\n            return false;\n        counts[c - 'a']--;\n    }\n\n    return true;\n}\n",
            "python": "def is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n\n    counts = {}\n    for c in s:\n        if c in counts:\n            counts[c] += 1\n        else:\n            counts[c] = 1\n\n    for c in t:\n        if c not in counts or counts[c] == 0:\n            return False\n        counts[c] -= 1\n\n    return True\n",
            "javascript": "function isAnagram(s, t) {\n    if (s.length !== t.length)\n        return false;\n\n    const counts = {};\n    for (let c of s)\n        counts[c] = (counts[c] || 0) + 1;\n\n    for (let c of t) {\n        if (counts[c] === 0 || !counts[c])\n            return false;\n        counts[c]--;\n    }\n\n    return true;\n}\n\n",
            "explanation": "The algorithm first checks if the two input strings have the same length. If they do not, it returns `false`, because an anagram of a string would have the same length as the original string.\n\nThen, the algorithm initializes a hash table to store the frequency of each character in the string `s`. It iterates through the string `s`, and for each character, it increments the corresponding frequency count in the hash table.\n\nIt then iterates through the string `t`. For each character in `t`, it checks if the frequency count of that character in the hash table is greater than 0. If it is not, that means the character either wasn't in the string `s`, or has been used up already, so the function returns `false`. Otherwise, it decrements the frequency count for the current character in the hash table.\n\nFinally, if the function has not yet returned `false`, that means that the two strings are anagrams and the function returns `true`."
        },
        "structure": {
            "c++": "bool isAnagram(std::string s, std::string t)  {\n    // Your code here\n}\n",
            "java": "public boolean isAnagram(String s, String t)  {\n    // Your code here\n}\n",
            "python": "def is_anagram(s, t):\n    # Your code here\n\n",
            "javascript": "function isAnagram(s, t)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "bool isAnagram(std::string s, std::string t) {\n    if(s.size() != t.size())\n        return false;\n    \n    std::unordered_map<char, int> counts;\n    for(char c : s)\n        counts[c]++;\n        \n    for(char c : t) {\n        if(counts[c] == 0)\n            return false;\n        counts[c]--;\n    }\n    \n    return true;\n}",
            "java": "public boolean isAnagram(String s, String t) {\n    if(s.length() != t.length())\n        return false;\n\n    int[] counts = new int[26];\n    for(char c : s.toCharArray())\n        counts[c - 'a']++;\n\n    for(char c : t.toCharArray()) {\n        if(counts[c - 'a'] == 0)\n            return false;\n        counts[c - 'a']--;\n    }\n\n    return true;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    s = inputs[0]\n    t = inputs[1]\n    result = is_anagram(s, t)\n    print(result)",
            "javascript": "function main() {\n    const s = $args[0];\n    const t = $args[1];\n    const result = isAnagram(s, t);\n    console.log(result);\n}"
        },
        "Qid": "242"
    },
    {
        "_id": {
            "$oid": "661e8d73555605d7c12757eb"
        },
        "title": "Researcher's H-Index",
        "description": "Given an array of integers `citations` where `citations[i]` is the number of citations a researcher received for their `ith` paper, you need to determine the researcher's h-index. The h-index is defined as the maximum value of `h` such that the researcher has published at least `h` papers that have each been cited at least `h` times.",
        "example": "For example, given the array `citations = [3,0,6,1,5]`, the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    0,
                    6,
                    1,
                    5
                ],
                [
                    1,
                    3,
                    1
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    20,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ]
            ],
            "outputs": [
                3,
                1,
                0,
                5,
                2,
                5,
                5,
                5,
                1,
                10,
                10
            ]
        },
        "sample_code": {
            "c++": "int hIndex(vector<int>& citations) {\n    sort(citations.begin(), citations.end(), greater<int>());\n    int h = 0;\n    for (int i = 0; i < citations.size(); ++i) {\n        if (citations[i] >= i + 1) {\n            h = i + 1;\n        } else {\n            break;\n        }\n    }\n    return h;\n}\n",
            "java": "public int hIndex(int[] citations) {\n    Arrays.sort(citations);\n    int h = 0;\n    for (int i = citations.length - 1; i >= 0; i--) {\n        int rank = citations.length - i;\n        if (citations[i] >= rank) {\n            h = rank;\n        } else {\n            break;\n        }\n    }\n    return h;\n}\n",
            "python": "def hIndex(citations: list[int]) -> int:\n    citations.sort(reverse=True)\n    h = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h = i + 1\n        else:\n            break\n    return h\n",
            "javascript": "function hIndex(citations) {\n    citations.sort((a, b) => b - a);\n    let h = 0;\n    for (let i = 0; i < citations.length; i++) {\n        if (citations[i] >= i + 1) {\n            h = i + 1;\n        } else {\n            break;\n        }\n    }\n    return h;\n}\n",
            "explanation": "1. First, we sort the citations array in descending order.\n2. Then, we iterate through the sorted array and compare each value with its index + 1 (zero-based index). If citations[i] is greater or equal to (i + 1), we update the h-index with the new value (i + 1). Otherwise, we break the loop since the maximum h-index is achieved.\n3. Finally, we return the h-index."
        },
        "structure": {
            "c++": "int hIndex(vector<int>& citations)  {\n    // Your code here\n}\n",
            "java": "public int hIndex(int[] citations)  {\n    // Your code here\n}\n",
            "python": "def hIndex(citations: List[int]) -> int:\n    # Your code here\n\n",
            "javascript": "function hIndex(citations)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> citations = $args;\n    int result = hIndex(citations);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int hIndex(int[] citations) {\n    Arrays.sort(citations);\n    int h = 0;\n    for (int i = citations.length - 1; i >= 0; i--) {\n        int rank = citations.length - i;\n        if (citations[i] >= rank) {\n            h = rank;\n        } else {\n            break;\n        }\n    }\n    return h;\n}",
            "python": "if __name__ == \"__main__\":\n    citations =$args\n    result = hIndex(citations)\n    print(result)",
            "javascript": "function main() {\n    const citations = $args;\n    const result = hIndex(citations);\n    console.log(result);\n}"
        },
        "Qid": "274"
    },
    {
        "_id": {
            "$oid": "661e8dac555605d7c12757ec"
        },
        "title": "Painting Fence",
        "description": "You are painting a fence of `n` posts with `k` different colors. You must paint the posts following these rules:\n\nEvery post must be painted **exactly one** color.\nThere **cannot** be three or more **consecutive** posts with the same color.\n\nGiven the two integers `n` and `k`, return the **number of ways** you can paint the fence.",
        "example": "Example:\n\nInput: n = 3, k = 2\nOutput: 6\nExplanation: All the possibilities are shown.\nNote that painting all the posts red or all the posts green is invalid because there cannot be three posts in a row with the same color.",
        "level": "Medium",
        "tags": [
            "dynamic programming",
            "combinatorics"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    2
                ],
                [
                    1,
                    1
                ],
                [
                    7,
                    2
                ],
                [
                    4,
                    3
                ],
                [
                    10,
                    4
                ],
                [
                    2,
                    5
                ],
                [
                    6,
                    1
                ],
                [
                    8,
                    8
                ],
                [
                    12,
                    6
                ],
                [
                    5,
                    10
                ],
                [
                    50,
                    3
                ],
                [
                    20,
                    4
                ],
                [
                    30,
                    5
                ],
                [
                    40,
                    6
                ],
                [
                    50,
                    7
                ],
                [
                    50,
                    10
                ],
                [
                    50,
                    20
                ],
                [
                    50,
                    50
                ],
                [
                    1,
                    105
                ],
                [
                    50,
                    105
                ]
            ],
            "outputs": [
                6,
                1,
                42,
                18,
                312,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "int numWays(int n, int k) {\n    if (n == 0) return 0;\n    if (n == 1) return k;\n    int same = k;\n    int different = k * (k - 1);\n    for (int i = 2; i < n; ++i) {\n        int temp = different;\n        different = (same + different) * (k - 1);\n        same = temp;\n    }\n    return same + different;\n}\n",
            "java": "public int numWays(int n, int k) {\n    if (n == 0) return 0;\n    if (n == 1) return k;\n    int same = k;\n    int different = k * (k - 1);\n    for (int i = 2; i < n; ++i) {\n        int temp = different;\n        different = (same + different) * (k - 1);\n        same = temp;\n    }\n    return same + different;\n}\n",
            "python": "def numWays(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    same = k\n    different = k * (k - 1)\n    for i in range(2, n):\n        temp = different\n        different = (same + different) * (k - 1)\n        same = temp\n    return same + different\n",
            "javascript": "function numWays(n, k) {\n    if (n === 0) return 0;\n    if (n === 1) return k;\n\n    let same = k;\n    let different = k * (k - 1);\n    for (let i = 2; i < n; ++i) {\n        const temp = different;\n        different = (same + different) * (k - 1);\n        same = temp;\n    }\n    return same + different;\n}\n\n",
            "explanation": "We start with two cases when n equals to 0 or 1.\nIf n equals 0, it means there are no posts, so the result will be 0.\nIf n equals 1, it means there is only one post and k colors to choose from, so the result will be k.\n\nAfter that, we create two variables: `same` and `different`. `same` stores the number of ways to color a fence at position i, such that the color of post i is the same as that of post i-1. `different` stores the number of ways to color the post at position i, such that the color of post i is different from that of post i-1.\n\nFor the first two posts, there are k ways to paint them the same color, and k*(k-1) ways to paint them different colors.\n\nThen we use a loop starting from the third post (i=2) to the last post (i=n-1).\nAt each iteration, we update `different` by adding the previous `same` and `different` values and multiply by (k-1). This is because for different colors, they can either come from previous same colors or different colors, hence the addition. And then we multiply it by (k-1) to consider all possible color combinations excluding the previous color. After that, we update `same` by the previous `different` value, because now we need to consider the current post having the same color as the previous post.\n\nFinally, we return the total number of ways which is the sum of `same` and `different`."
        },
        "structure": {
            "c++": "int numWays(int n, int k)  {\n    // Your code here\n}\n",
            "java": "public int numWays(int n, int k)  {\n    // Your code here\n}\n",
            "python": "def numWays(n, k):\n    # Your code here\n\n",
            "javascript": "function numWays(n, k)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int k = $args;\n    int result = numWays(n, k);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int callNumWays(int n, int k) {\n    int result = numWays(n, k);\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    n = inputs[0]\n    k = inputs[1]\n    result = numWays(n, k)\n    print(result)",
            "javascript": "function main() {\n    const n = $args[0];\n    const k = $args[1];\n    const result = numWays(n, k);\n    console.log(result);\n}"
        },
        "Qid": "276"
    },
    {
        "_id": {
            "$oid": "661e8e94555605d7c12757ed"
        },
        "title": "Least Number of Perfect Square Numbers",
        "description": "Given an integer `n`, find the least number of perfect square numbers that sum to `n`.",
        "example": "Example:\n\nInput: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.\n\nInput: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9.",
        "level": "Medium",
        "tags": [
            "dynamic programming",
            "math"
        ],
        "test_cases": {
            "inputs": [
                12,
                13,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ],
            "outputs": [
                3,
                2,
                1,
                2,
                3,
                1,
                2,
                3,
                4,
                2,
                1,
                2,
                3,
                2,
                3,
                1,
                2,
                2,
                3,
                2
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <limits>\n#include <cmath>\n\nint numSquares(int n) {\n    std::vector<int> dp(n + 1, std::numeric_limits<int>::max());\n    dp[0] = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j * j <= i; j++) {\n            dp[i] = std::min(dp[i], dp[i - j * j] + 1);\n        }\n    }\n    \n    return dp[n];\n}\n",
            "java": "public int numSquares(int n) {\n    int[] dp = new int[n + 1];\n    Arrays.fill(dp, Integer.MAX_VALUE);\n    dp[0] = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j * j <= i; j++) {\n            dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n        }\n    }\n    \n    return dp[n];\n}\n",
            "python": "def numSquares(n):\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n            j += 1\n            \n    return dp[n]\n",
            "javascript": "function numSquares(n) {\n    const dp = new Array(n + 1).fill(Infinity);\n    dp[0] = 0;\n\n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j * j <= i; j++) {\n            dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n        }\n    }\n\n    return dp[n];\n}\n",
            "explanation": "We use Dynamic Programming (DP) to solve this problem. We initialize a 1-dimensional DP array, `dp`, of size `n + 1`, where `n` is given in the problem statement. We set `dp[0]` to `0` because it takes zero square numbers to sum up to zero. We fill the rest of the DP array with a maximum or infinite value, depending on the language used.\n\nWe iterate through the DP array from index `1` to index `n`, inclusive. For each index `i`, we iterate through all perfect square numbers `j * j` smaller than or equal to `i` to find the least number of perfect square numbers that sum up to `i`. We update the `dp` array with the minimum value of the current value at `dp[i]` and `dp[i - j * j] + 1`.\n\nAfter completing the iterations, the value at `dp[n]` represents the least number of perfect squares that sum to `n`."
        },
        "structure": {
            "c++": "#include <vector>\n#include <limits>\n#include <cmath>\n\nint numSquares(int n)  {\n    // Your code here\n}\n",
            "java": "public int numSquares(int n)  {\n    // Your code here\n}\n",
            "python": "def numSquares(n):\n    # Your code here\n\n",
            "javascript": "function numSquares(n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <limits>\n#include <cmath>\n\nint main() {\n    int n = $args;\n    int result = numSquares(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int numSquares(int n) {\n    int[] dp = new int[n + 1];\n    Arrays.fill(dp, Integer.MAX_VALUE);\n    dp[0] = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j * j <= i; j++) {\n            dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n        }\n    }\n    \n    return dp[n];\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = numSquares(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = numSquares(n);\n    console.log(result);\n}"
        },
        "Qid": "279"
    },
    {
        "_id": {
            "$oid": "661e8ee9555605d7c12757ee"
        },
        "title": "Reorder Array",
        "description": "Given an integer array `nums`, reorder it such that `nums[0] <= nums[1] >= nums[2] <= nums[3]...`. You may assume the input array always has a valid answer.",
        "example": "Example:\n\nInput: nums = [3,5,2,1,6,4]\nOutput: [3,5,1,6,2,4]\nExplanation: [1,6,2,5,3,4] is also accepted.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    5,
                    2,
                    1,
                    6,
                    4
                ],
                [
                    6,
                    6,
                    5,
                    6,
                    3,
                    8
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60
                ],
                [
                    100,
                    200,
                    300,
                    400,
                    500,
                    600
                ],
                [
                    5,
                    10,
                    15,
                    20,
                    25,
                    30
                ],
                [
                    50,
                    40,
                    30,
                    20,
                    10,
                    5
                ],
                [
                    7,
                    7,
                    7,
                    7,
                    7,
                    7
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10,
                    12
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9,
                    11
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    3,
                    3,
                    3,
                    3,
                    3,
                    3
                ],
                [
                    4,
                    4,
                    4,
                    4,
                    4,
                    4
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    6,
                    6,
                    6,
                    6,
                    6,
                    6
                ],
                [
                    7,
                    7,
                    7,
                    7,
                    7,
                    7
                ],
                [
                    8,
                    8,
                    8,
                    8,
                    8,
                    8
                ]
            ],
            "outputs": [
                [
                    3,
                    5,
                    1,
                    6,
                    2,
                    4
                ],
                [
                    6,
                    6,
                    5,
                    6,
                    3,
                    8
                ],
                [
                    1,
                    3,
                    2,
                    5,
                    4,
                    6
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60
                ],
                [
                    100,
                    200,
                    300,
                    400,
                    500,
                    600
                ],
                [
                    5,
                    10,
                    15,
                    20,
                    25,
                    30
                ],
                [
                    50,
                    40,
                    30,
                    20,
                    10,
                    5
                ],
                [
                    7,
                    7,
                    7,
                    7,
                    7,
                    7
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10,
                    12
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9,
                    11
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    3,
                    3,
                    3,
                    3,
                    3,
                    3
                ],
                [
                    4,
                    4,
                    4,
                    4,
                    4,
                    4
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    6,
                    6,
                    6,
                    6,
                    6,
                    6
                ],
                [
                    7,
                    7,
                    7,
                    7,
                    7,
                    7
                ],
                [
                    8,
                    8,
                    8,
                    8,
                    8,
                    8
                ]
            ]
        },
        "sample_code": {
            "c++": "void wiggleSort(vector<int>& nums) {\n    for (int i = 1; i < nums.size(); i++) {\n        if (i%2 == 0 && nums[i] > nums[i-1] || i%2 == 1 && nums[i] < nums[i-1]) {\n            swap(nums[i], nums[i-1]);\n        }\n    }\n}\n",
            "java": "public void wiggleSort(int[] nums) {\n    for (int i = 1; i < nums.length; i++) {\n        if (i % 2 == 0 && nums[i] > nums[i-1] || i % 2 == 1 && nums[i] < nums[i-1]) {\n            int temp = nums[i];\n            nums[i] = nums[i-1];\n            nums[i-1] = temp;\n        }\n    }\n}\n",
            "python": "def wiggleSort(nums):\n    for i in range(1, len(nums)):\n        if (i % 2 == 0 and nums[i] > nums[i-1]) or (i % 2 == 1 and nums[i] < nums[i-1]):\n            nums[i], nums[i-1] = nums[i-1], nums[i]\n",
            "javascript": "function wiggleSort(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        if (i % 2 === 0 && nums[i] > nums[i-1] || i % 2 === 1 && nums[i] < nums[i-1]) {\n            [nums[i], nums[i-1]] = [nums[i-1], nums[i]];\n        }\n    }\n}\n",
            "explanation": "The algorithm iterates through the array from index 1 to the end. It checks whether the current element violates the wiggle condition. If the current index is even and the current element is greater than the previous element, or if the current index is odd and the current element is smaller than the previous element, it swaps the current and the previous element."
        },
        "structure": {
            "c++": "void wiggleSort(vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "public void wiggleSort(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def wiggleSort(nums):\n    # Your code here\n\n",
            "javascript": "function wiggleSort(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "void wiggleSort(vector<int>& nums) {\n    for (int i = 1; i < nums.size(); i++) {\n        if (i%2 == 0 && nums[i] > nums[i-1] || i%2 == 1 && nums[i] < nums[i-1]) {\n            swap(nums[i], nums[i-1]);\n        }\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    wiggleSort(nums)\n    print(nums)",
            "java": "",
            "javascript": ""
        },
        "Qid": "280"
    },
    {
        "_id": {
            "$oid": "661e8f45555605d7c12757f0"
        },
        "title": "Move Zeros to End",
        "description": "Given an integer array `nums`, move all `0`'s to the end of it while maintaining the relative order of the non-zero elements. You must do this in-place without making a copy of the array.",
        "example": "Example:\n\nInput: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]\n\nExplanation: After moving all the zeros to the end, the array becomes [1,3,12,0,0].",
        "level": "Easy",
        "tags": [
            "Array",
            "Two Pointers"
        ],
        "test_cases": {
            "inputs": [
                [
                    0,
                    1,
                    0,
                    3,
                    12
                ],
                [
                    0
                ],
                [
                    1,
                    0,
                    2,
                    0,
                    3
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    0,
                    0,
                    0,
                    1,
                    2
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    0,
                    0
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    0,
                    1,
                    0,
                    1,
                    0
                ],
                [
                    1,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    0,
                    0,
                    0
                ],
                [
                    0,
                    0,
                    0,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    0,
                    1,
                    0,
                    1,
                    0
                ],
                [
                    0,
                    1,
                    0,
                    1,
                    0,
                    1
                ]
            ],
            "outputs": [
                [
                    1,
                    3,
                    12,
                    0,
                    0
                ],
                [
                    0
                ],
                [
                    1,
                    2,
                    3,
                    0,
                    0
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    0,
                    0
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    1,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    0,
                    0,
                    0
                ],
                [
                    0,
                    0,
                    0,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    0,
                    1,
                    0,
                    1,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    0,
                    0,
                    0
                ]
            ]
        },
        "sample_code": {
            "c++": "void moveZeroes(vector<int>& nums) {\n    int index = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] != 0) {\n            nums[index++] = nums[i];\n        }\n    }\n    for (int i = index; i < nums.size(); i++) {\n        nums[i] = 0;\n    }\n}\n",
            "java": "public void moveZeroes(int[] nums) {\n    int index = 0;\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] != 0) {\n            nums[index++] = nums[i];\n        }\n    }\n    for (int i = index; i < nums.length; i++) {\n        nums[i] = 0;\n    }\n}\n",
            "python": "def moveZeroes(nums):\n    index = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[index] = nums[i]\n            index += 1\n    for i in range(index, len(nums)):\n        nums[i] = 0\n",
            "javascript": "function moveZeroes(nums) {\n    let index = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== 0) {\n            nums[index++] = nums[i];\n        }\n    }\n    for (let i = index; i < nums.length; i++) {\n        nums[i] = 0;\n    }\n}\n",
            "explanation": "In each language, the algorithm starts by initializing an `index` variable with the value of 0. Next, it loops through the input array `nums`. If the current element is not zero, it assigns the value of the current element to the position indicated by the `index` and then increments the `index`. After the first loop, all non-zero elements are placed before the zero elements in the array.\n\nFinally, in the second loop, it assigns the value of 0 to all remaining positions in the array from the current `index` to the end of the array.\n\nThis algorithm maintains the relative order of non-zero elements as they are moved to the left at the beginning of the array, and ensures that zeros are moved to the end of the array. The algorithm also modifies the given array in-place as required."
        },
        "structure": {
            "c++": "void moveZeroes(vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "public void moveZeroes(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def moveZeroes(nums):\n    # Your code here\n\n",
            "javascript": "function moveZeroes(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "void moveZeroes(vector<int>& nums) {\n    int index = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] != 0) {\n            nums[index++] = nums[i];\n        }\n    }\n    for (int i = index; i < nums.size(); i++) {\n        nums[i] = 0;\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    moveZeroes(nums)\n    print(nums)",
            "java": "",
            "javascript": ""
        },
        "Qid": "283"
    },
    {
        "_id": {
            "$oid": "661e8f5e555605d7c12757f1"
        },
        "title": "Find the Duplicate Number",
        "description": "Given an array of integers `nums` containing `n + 1` integers where each integer is in the range `[1, n]` inclusive. There is only one repeated number in `nums`, return this repeated number. You must solve the problem without modifying the array `nums` and using only constant extra space.",
        "example": "Example:\n\nInput: nums = [1,3,4,2,2]\nOutput: 2\n\nExplanation: The repeated number is 2.\n\nInput: nums = [3,1,3,4,2]\nOutput: 3\n\nExplanation: The repeated number is 3.",
        "level": "Easy",
        "tags": [
            "Array",
            "Two Pointers",
            "Binary Search"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    3,
                    4,
                    2,
                    2
                ],
                [
                    3,
                    1,
                    3,
                    4,
                    2
                ],
                [
                    1,
                    1,
                    2,
                    3,
                    4
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99,
                    100,
                    100
                ]
            ],
            "outputs": [
                "2",
                "3",
                "1",
                "2",
                "100"
            ]
        },
        "sample_code": {
            "c++": "int findDuplicate(vector<int>& nums) {\n    int slow = nums[0];\n    int fast = nums[0];\n\n    do {\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n    } while (slow != fast);\n\n    slow = nums[0];\n\n    while (slow != fast) {\n        slow = nums[slow];\n        fast = nums[fast];\n    }\n\n    return slow;\n}\n\n",
            "java": "public int findDuplicate(int[] nums) {\n    int slow = nums[0];\n    int fast = nums[0];\n\n    do {\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n    } while (slow != fast);\n\n    slow = nums[0];\n\n    while (slow != fast) {\n        slow = nums[slow];\n        fast = nums[fast];\n    }\n\n    return slow;\n}\n\n",
            "python": "def findDuplicate(nums):\n    slow = nums[0]\n    fast = nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n\n",
            "javascript": "function findDuplicate(nums) {\n    let slow = nums[0];\n    let fast = nums[0];\n\n    do {\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n    } while (slow !== fast);\n\n    slow = nums[0];\n\n    while (slow !== fast) {\n        slow = nums[slow];\n        fast = nums[fast];\n    }\n\n    return slow;\n}\n\n",
            "explanation": "The algorithm is based on Floyd's Tortoise and Hare (Cycle Detection) algorithm. We treat the given array as a linked list where the value at each index is treated as the pointer to the next node in the list.\n\n1. Initialize two pointers, `slow` and `fast`, both initially pointing to the first element of the array.\n2. Loop through the array, updating `slow` to point to the next element and `fast` to point to the element after the next element, until they meet.\n3. Reset `slow` to the first element of the array and keep `fast` at the meeting point.\n4. Loop through the array, updating `slow` and `fast` to point to the next element until they meet again. This meeting point is the duplicate number.\n\nThis algorithm has a time complexity of O(n) and a space complexity of O(1)."
        },
        "structure": {
            "c++": "int findDuplicate(vector<int>& nums)  {\n    // Your code here\n}\n\n",
            "java": "public int findDuplicate(int[] nums)  {\n    // Your code here\n}\n\n",
            "python": "def findDuplicate(nums):\n    # Your code here\n\n",
            "javascript": "function findDuplicate(nums)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int findDuplicate(vector<int>& nums) {\n    int slow = nums[0];\n    int fast = nums[0];\n\n    do {\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n    } while (slow != fast);\n\n    slow = nums[0];\n\n    while (slow != fast) {\n        slow = nums[slow];\n        fast = nums[fast];\n    }\n\n    return slow;\n}",
            "java": "public int findDuplicate(int[] nums) {\n    int slow = nums[0];\n    int fast = nums[0];\n\n    do {\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n    } while (slow != fast);\n\n    slow = nums[0];\n\n    while (slow != fast) {\n        slow = nums[slow];\n        fast = nums[fast];\n    }\n\n    return slow;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = findDuplicate(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = findDuplicate(nums);\n    console.log(result);\n}"
        },
        "Qid": "287"
    },
    {
        "_id": {
            "$oid": "661e8fc9555605d7c12757f2"
        },
        "title": "Pattern Matching",
        "description": "Given a pattern and a string, determine if the string follows the same pattern. Follow means a full match, such that there is a bijection between a letter in the pattern and a non-empty word in the string.",
        "example": "Example:\n\nInput: pattern = \"abba\", s = \"dog cat cat dog\"\nOutput: true\n\nExplanation: The pattern 'abba' matches the string 'dog cat cat dog' because 'a' corresponds to 'dog' and 'b' corresponds to 'cat'.\n\nInput: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\n\nExplanation: The pattern 'abba' does not match the string 'dog cat cat fish' because the last word in the string is 'fish' which does not correspond to any letter in the pattern.",
        "level": "Easy",
        "tags": [
            "String",
            "Pattern Matching"
        ],
        "test_cases": {
            "inputs": [
                [
                    "abba",
                    "dog cat cat dog"
                ],
                [
                    "abba",
                    "dog cat cat fish"
                ],
                [
                    "aaaa",
                    "dog cat cat dog"
                ],
                [
                    "abc",
                    "apple banana cherry"
                ],
                [
                    "aabb",
                    "apple apple banana banana"
                ],
                [
                    "abab",
                    "cat dog cat dog"
                ],
                [
                    "abba",
                    "dog dog dog dog"
                ],
                [
                    "abba",
                    "dog cat cat cat"
                ],
                [
                    "abba",
                    "dog cat cat cat dog"
                ],
                [
                    "abba",
                    "dog cat cat cat cat"
                ],
                [
                    "abba",
                    "dog cat cat cat cat dog"
                ],
                [
                    "abba",
                    "dog cat cat cat cat cat"
                ],
                [
                    "abba",
                    "dog cat cat cat cat cat dog"
                ],
                [
                    "abba",
                    "dog cat cat cat cat cat cat"
                ],
                [
                    "abba",
                    "dog cat cat cat cat cat cat dog"
                ],
                [
                    "abba",
                    "dog cat cat cat cat cat cat cat"
                ],
                [
                    "abba",
                    "dog cat cat cat cat cat cat cat dog"
                ],
                [
                    "abba",
                    "dog cat cat cat cat cat cat cat cat"
                ],
                [
                    "abba",
                    "dog cat cat cat cat cat cat cat cat dog"
                ],
                [
                    "abba",
                    "dog cat cat cat cat cat cat cat cat cat"
                ],
                [
                    "abba",
                    "dog cat cat cat cat cat cat cat cat cat dog"
                ]
            ],
            "outputs": [
                true,
                false,
                false,
                true,
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <unordered_map>\n#include <sstream>\nusing namespace std;\n\nbool wordPattern(string pattern, string s) {\n    unordered_map<char, string> char_map;\n    unordered_map<string, char> word_map;\n    stringstream ss(s);\n\n    int i = 0;\n    for (string word; ss >> word; ++i) {\n        if (i == pattern.size()) return false;\n        char c = pattern[i];\n        if (char_map.count(c) == 0 && word_map.count(word) == 0) {\n            char_map[c] = word;\n            word_map[word] = c;\n        } else {\n            if (char_map[c] != word || word_map[word] != c) return false;\n        }\n    }\n\n    return i == pattern.size();\n}\n\n",
            "java": "import java.util.HashMap;\nimport java.util.Map;\n\npublic boolean wordPattern(String pattern, String s) {\n    String[] words = s.split(\" \");\n    if (pattern.length() != words.length) return false;\n\n    Map<Character, String> charMap = new HashMap<>();\n    Map<String, Character> wordMap = new HashMap<>();\n\n    for (int i = 0; i < pattern.length(); i++) {\n        char c = pattern.charAt(i);\n        String word = words[i];\n        if (!charMap.containsKey(c) && !wordMap.containsKey(word)) {\n            charMap.put(c, word);\n            wordMap.put(word, c);\n        } else {\n            if (!word.equals(charMap.get(c)) || c != wordMap.get(word)) return false;\n        }\n    }\n\n    return true;\n}\n\n",
            "python": "def word_pattern(pattern, s):\n    words = s.split()\n    if len(pattern) != len(words):\n        return False\n\n    char_map, word_map = {}, {}\n    for c, word in zip(pattern, words):\n        if c not in char_map and word not in word_map:\n            char_map[c] = word\n            word_map[word] = c\n        else:\n            if char_map.get(c) != word or word_map.get(word) != c:\n                return False\n\n    return True\n\n",
            "javascript": "function wordPattern(pattern, s) {\n    const words = s.split(' ');\n    if (pattern.length !== words.length) return false;\n\n    const charMap = new Map();\n    const wordMap = new Map();\n\n    for (let i = 0; i < pattern.length; i++) {\n        const c = pattern[i];\n        const word = words[i];\n        if (!charMap.has(c) && !wordMap.has(word)) {\n            charMap.set(c, word);\n            wordMap.set(word, c);\n        } else {\n            if (charMap.get(c) !== word || wordMap.get(word) !== c) return false;\n        }\n    }\n\n    return true;\n}\n\n",
            "explanation": "1. First, split the string 's' into words array based on the space-delimited words.\n2. Check if the length of the pattern and words array is the same, otherwise return false.\n3. Create two maps (hash tables/dictionaries) - one for storing the mapping from a pattern character to a word, and the other for mapping from a word to a pattern character.\n4. Iterate through the pattern and the words array simultaneously using a loop.\n5. If a pattern character and word are not in the respective maps, save the corresponding mapping in both maps.\n6. If they exist, compare the mappings; if they differ, immediately return false.\n7. After the loop is completed, if there is no mismatch, return true."
        },
        "structure": {
            "c++": "#include <string>\n#include <unordered_map>\n#include <sstream>\nusing namespace std;\n\nbool wordPattern(string pattern, string s)  {\n    // Your code here\n}\n\n",
            "java": "import java.util.HashMap;\nimport java.util.Map;\n\npublic boolean wordPattern(String pattern, String s)  {\n    // Your code here\n}\n\n",
            "python": "def word_pattern(pattern, s):\n    # Your code here\n\n",
            "javascript": "function wordPattern(pattern, s)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <unordered_map>\n#include <sstream>\nusing namespace std;\n\nint main() {\n    string pattern = $args;\n    string s = $args;\n    bool result = wordPattern(pattern, s);\n    cout << boolalpha << result << endl;\n    return 0;\n}\n",
            "java": "public boolean wordPattern(String pattern, String s) {\n    String[] words = s.split(\" \");\n    if (pattern.length() != words.length) return false;\n\n    Map<Character, String> charMap = new HashMap<>();\n    Map<String, Character> wordMap = new HashMap<>();\n\n    for (int i = 0; i < pattern.length(); i++) {\n        char c = pattern.charAt(i);\n        String word = words[i];\n        if (!charMap.containsKey(c) && !wordMap.containsKey(word)) {\n            charMap.put(c, word);\n            wordMap.put(word, c);\n        } else {\n            if (!word.equals(charMap.get(c)) || c != wordMap.get(word)) return false;\n        }\n    }\n\n    return true;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    pattern = inputs[0]\n    s = inputs[1]\n    result = word_pattern(pattern, s)\n    print(result)",
            "javascript": "function main() {\n    const pattern = $args[0];\n    const s = $args[1];\n    const result = wordPattern(pattern, s);\n    console.log(result);\n}"
        },
        "Qid": "290"
    },
    {
        "_id": {
            "$oid": "661e9031555605d7c12757f3"
        },
        "title": "Nim Game",
        "description": "You are playing the Nim Game with your friend. Initially, there is a heap of stones on the table. You and your friend will alternate taking turns, and you go first. On each turn, the person whose turn it is will remove 1 to 3 stones from the heap. The one who removes the last stone is the winner. Given the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.",
        "example": "Example 1:\n\nInput: n = 4\nOutput: false\nExplanation: These are the possible outcomes:\n1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.\n2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.\n3. You remove 3 stones. Your friend removes the last stone. Your friend wins.\nIn all outcomes, your friend wins.\n\nExample 2:\n\nInput: n = 1\nOutput: true\n\nExample 3:\n\nInput: n = 2\nOutput: true",
        "level": "Easy",
        "tags": [
            "Math",
            "Game Theory"
        ],
        "test_cases": {
            "inputs": [
                4,
                1,
                2,
                5,
                10,
                15,
                20,
                25,
                30,
                100,
                1000,
                10000,
                12345,
                54321,
                99999,
                100000,
                231,
                230,
                229,
                228
            ],
            "outputs": [
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                false,
                false,
                false,
                true
            ]
        },
        "sample_code": {
            "c++": "bool canWinNim(int n) {\n    return n % 4 != 0;\n}\n",
            "java": "public boolean canWinNim(int n) {\n    return n % 4 != 0;\n}\n",
            "python": "def canWinNim(n):\n    return n % 4 != 0\n",
            "javascript": "function canWinNim(n) {\n    return n % 4 !== 0;\n}\n",
            "explanation": "In the Nim game, the optimal strategy is to make the other player take the last stone. The game is won by the player who can force the opponent to take the last stone. If the current number of stones is divisible by 4, the next player can always make the other player take the last stone. Therefore, whenever the current number of stones is divisible by 4, the player will lose. If the number of stones is not divisible by 4, the player can make the next player play with a number of stones divisible by 4, thus making the next player lose.\n\nIn the code, we simply check if the number of stones `n` is not divisible by 4 (`n % 4 != 0`), and if it is, then the player can win the game."
        },
        "structure": {
            "c++": "bool canWinNim(int n)  {\n    // Your code here\n}\n",
            "java": "public boolean canWinNim(int n)  {\n    // Your code here\n}\n",
            "python": "def canWinNim(n):\n    # Your code here\n\n",
            "javascript": "function canWinNim(n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n = $args;\n    bool result = canWinNim(n);\n    cout << boolalpha << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n        int n = $args;\n        boolean result = canWinNim(n);\n        System.out.println(result);\n    }",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = canWinNim(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = canWinNim(n);\n    console.log(result);\n}"
        },
        "Qid": "292"
    },
    {
        "_id": {
            "$oid": "661e9048555605d7c12757f4"
        },
        "title": "Flip Game",
        "description": "You are playing a Flip Game with your friend. You are given a string `currentState` that contains only `'+'` and `'-'`. You and your friend take turns to flip **two consecutive** `'++'` into `'--'`. The game ends when a person can no longer make a move, and therefore the other person will be the winner. Return all possible states of the string `currentState` after **one valid move**. If there is no valid move, return an empty list `[]`.",
        "example": "Example 1:\n\nInput: currentState =  \"++++ \"\nOutput: [\"--++ \", \"+--+ \", \"++-- \"]\n\nExample 2:\n\nInput: currentState =  \"+ \"\nOutput: []",
        "level": "Easy",
        "tags": [
            "string",
            "game"
        ],
        "test_cases": {
            "inputs": [
                "\"++++ \"",
                "\"+ \"",
                "\"--++ \"",
                "\"-+-+ \"",
                "\"++ \"",
                "\"- \"",
                "\"++-- \"",
                "\"--++-- \"",
                "\"++-+ \"",
                "\"-+- \"",
                "\"++- \"",
                "\"-+ \"",
                "\"-- \"",
                "\"-+-- \"",
                "\"+++- \"",
                "\"-+-++ \"",
                "\"++-+- \"",
                "\"-+-+- \"",
                "\"+++-+ \"",
                "\"-+-+- \""
            ],
            "outputs": [
                "[\"--++ \", \"+--+ \", \"++-- \"]",
                "[]",
                "[\"---- \"]",
                "[\"-+-- \", \"--+- \"]",
                "[\"-- \"]",
                "[]",
                "[\"--++-- \"]",
                "[\"++---- \", \"--++-- \"]",
                "[\"--+- \", \"-+-- \"]",
                "[\"-+-+ \", \"-+-- \"]",
                "[\"--+ \", \"-++ \"]",
                "[\"+- \", \"-+ \"]",
                "[]",
                "[\"-+---- \"]",
                "[\"+++- \", \"-+++ \"]",
                "[\"-+-++ \", \"-++-+ \"]",
                "[\"++-+- \", \"-++-- \"]",
                "[\"-+-+- \", \"-+-- \"]",
                "[\"+++-+ \", \"-++-+ \"]",
                "[\"-+-+- \", \"-+-- \"]"
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n\nstd::vector<std::string> generatePossibleNextMoves(std::string currentState) {\n    std::vector<std::string> result;\n    for (int i = 1; i < currentState.size(); ++i) {\n        if (currentState[i] == '+' && currentState[i - 1] == '+') {\n            currentState[i] = currentState[i - 1] = '-';\n            result.push_back(currentState);\n            currentState[i] = currentState[i - 1] = '+';\n        }\n    }\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> generatePossibleNextMoves(String currentState) {\n    List<String> result = new ArrayList<>();\n    for (int i = 1; i < currentState.length(); i++) {\n        if (currentState.charAt(i) == '+' && currentState.charAt(i - 1) == '+') {\n            result.add(currentState.substring(0, i - 1) + \"--\" + currentState.substring(i + 1));\n        }\n    }\n    return result;\n}\n",
            "python": "def generate_possible_next_moves(current_state):\n    result = []\n    for i in range(1, len(current_state)):\n        if current_state[i] == '+' and current_state[i - 1] == '+':\n            result.append(current_state[:i - 1] + '--' + current_state[i + 1:])\n    return result\n",
            "javascript": "function generatePossibleNextMoves(currentState) {\n    const result = [];\n    for (let i = 1; i < currentState.length; i++) {\n        if (currentState[i] === '+' && currentState[i - 1] === '+') {\n            result.push(currentState.slice(0, i - 1) + '--' + currentState.slice(i + 1));\n        }\n    }\n    return result;\n}\n",
            "explanation": "The algorithm iterates through the `currentState` string starting from the second character to check for two consecutive `'+'` characters. When it finds a pair, it flips them to `'-'` and adds the resulting string to the `result` list. After adding the result, it flips the characters back to `'+'` to continue searching for more pairs.\n\nIn Python and JavaScript, the string concatenation is done using slicing and concatenation, while in C++ and Java, the strings are first modified and then restored to their original state after adding the modified result. The final output is a list of all the possible next moves after one valid flip."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n\nstd::vector<std::string> generatePossibleNextMoves(std::string currentState)  {\n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> generatePossibleNextMoves(String currentState)  {\n    // Your code here\n}\n",
            "python": "def generate_possible_next_moves(current_state):\n    # Your code here\n\n",
            "javascript": "function generatePossibleNextMoves(currentState)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <iostream>\n\nint main() {\n    std::string currentState = $args;\n    std::vector<std::string> result = generatePossibleNextMoves(currentState);\n    for (const auto& str : result) {\n        std::cout << str << std::endl;\n    }\n    return 0;\n}",
            "java": "public List<String> generatePossibleNextMoves(String currentState) {\n    List<String> result = new ArrayList<>();\n    for (int i = 1; i < currentState.length(); i++) {\n        if (currentState.charAt(i) == '+' && currentState.charAt(i - 1) == '+') {\n            result.add(currentState.substring(0, i - 1) + \"--\" + currentState.substring(i + 1));\n        }\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    current_state = $args\n    result = generate_possible_next_moves(current_state)\n    print(result)",
            "javascript": "function main() {\n    const currentState = $args;\n    const result = generatePossibleNextMoves(currentState);\n    console.log(result);\n}"
        },
        "Qid": "293"
    },
    {
        "_id": {
            "$oid": "661e905f555605d7c12757f5"
        },
        "title": "Flip Game Winner",
        "description": "You are playing a Flip Game with your friend. You are given a string `currentState` that contains only `'+'` and `'-'`. You and your friend take turns to flip **two consecutive** `\"++\"` into `\"--\"`. The game ends when a person can no longer make a move, and therefore the other person will be the winner. Return `true` if the starting player can guarantee a win, and `false` otherwise.",
        "example": "Example:\n\nInput: currentState = \"++++\"\nOutput: true\nExplanation: The starting player can guarantee a win by flipping the middle `++` to become `+--+`.",
        "level": "Medium",
        "tags": [
            "String",
            "Game"
        ],
        "test_cases": {
            "inputs": [
                "\"++++\"",
                "\"+\"",
                "\"++\"",
                "\"--\"",
                "\"+-+-\"",
                "\"-+-+\"",
                "\"++-+\"",
                "\"-++-\"",
                "\"+++-\"",
                "\"-+++\"",
                "\"+++++\"",
                "\"-++++\"",
                "\"++-++\"",
                "\"--++--\"",
                "\"-+-+-+\"",
                "\"-+-+-++\"",
                "\"-+-+-+-\"",
                "\"-+-+-+-+\"",
                "\"-+-+-+-++\"",
                "\"-+-+-+-+++\"",
                "\"-+-+-+-++++\""
            ],
            "outputs": [
                true,
                false,
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "bool canWin(string currentState) {\n    for (int i = 0; i < currentState.size() - 1; ++i) {\n        if (currentState[i] == '+' && currentState[i + 1] == '+') {\n            currentState[i] = '-';\n            currentState[i + 1] = '-';\n            bool opponentWins = canWin(currentState);\n            currentState[i] = '+';\n            currentState[i + 1] = '+';\n            if (!opponentWins) return true;\n        }\n    }\n    return false;\n}\n",
            "java": "public boolean canWin(String currentState) {\n    for (int i = 0; i < currentState.length() - 1; ++i) {\n        if (currentState.charAt(i) == '+' && currentState.charAt(i + 1) == '+') {\n            String temp = currentState.substring(0, i) + \"--\" + currentState.substring(i + 2);\n            if (!canWin(temp)) return true;\n        }\n    }\n    return false;\n}\n",
            "python": "def canWin(currentState: str) -> bool:\n    for i in range(len(currentState) - 1):\n        if currentState[i] == '+' and currentState[i + 1] == '+':\n            temp = currentState[:i] + \"--\" + currentState[i + 2:]\n            if not canWin(temp):\n                return True\n    return False\n",
            "javascript": "function canWin(currentState) {\n    for (let i = 0; i < currentState.length - 1; ++i) {\n        if (currentState[i] === '+' && currentState[i + 1] === '+') {\n            let temp = currentState.slice(0, i) + \"--\" + currentState.slice(i + 2);\n            if (!canWin(temp)) return true;\n        }\n    }\n    return false;\n}\n",
            "explanation": "The algorithm uses a recursive approach to check for all possible game states starting from the given `currentState`. At each step, the code iterates through the string to find two consecutive '+' characters. If found, it flips the two consecutive '+' to '--' and calls the function recursively with this newState to check if the opponent wins or not. If the opponent doesn't win, the function returns true as it guarantees a win for the starting player. If no such situation occurs, the function returns false.\n\nThe runtime complexity of this algorithm is O(n * 2^n) where n is the length of the input string. The reason for this complexity is that, in the worst-case, we may have to explore every possible state of the game tree, and there are 2^n possible game states."
        },
        "structure": {
            "c++": "bool canWin(string currentState)  {\n    // Your code here\n}\n",
            "java": "public boolean canWin(String currentState)  {\n    // Your code here\n}\n",
            "python": "def canWin(currentState: str) -> bool:\n    # Your code here\n\n",
            "javascript": "function canWin(currentState)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "bool canWin(string currentState) {\n    for (int i = 0; i < currentState.size() - 1; ++i) {\n        if (currentState[i] == '+' && currentState[i + 1] == '+') {\n            currentState[i] = '-';\n            currentState[i + 1] = '-';\n            bool opponentWins = canWin(currentState);\n            currentState[i] = '+';\n            currentState[i + 1] = '+';\n            if (!opponentWins) return true;\n        }\n    }\n    return false;\n}",
            "java": "public boolean canWin(String currentState) {\n    for (int i = 0; i < currentState.length() - 1; ++i) {\n        if (currentState.charAt(i) == '+' && currentState.charAt(i + 1) == '+') {\n            String temp = currentState.substring(0, i) + \"--\" + currentState.substring(i + 2);\n            if (!canWin(temp)) return true;\n        }\n    }\n    return false;\n}",
            "python": "if __name__ == \"__main__\":\n    currentState = $args\n    result = canWin(currentState)\n    print(result)",
            "javascript": "function main() {\n    const currentState = $args;\n    const result = canWin(currentState);\n    console.log(result);\n}"
        },
        "Qid": "294"
    },
    {
        "_id": {
            "$oid": "661e90e1555605d7c12757f6"
        },
        "title": "Bulls and Cows Game",
        "description": "You are playing the Bulls and Cows game with your friend. You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info: the number of 'bulls', which are digits in the guess that are in the correct position, and the number of 'cows', which are digits in the guess that are in your secret number but are located in the wrong position. Given the secret number 'secret' and your friend's guess 'guess', write a function that returns the hint for your friend's guess.",
        "example": "For example, if the secret number is '1807' and your friend's guess is '7810', the function should return '1A3B' because there is 1 bull (the digit '1' in the correct position) and 3 cows (the digits '8', '0', and '7' are in the secret number but in the wrong position).\n\nInput:\nsecret = '1807'\nguess = '7810'\nOutput:\n'1A3B'",
        "level": "Medium",
        "tags": [
            "string",
            "game"
        ],
        "test_cases": {
            "inputs": [
                [
                    "1807",
                    "7810"
                ],
                [
                    "1123",
                    "0111"
                ],
                [
                    "1234",
                    "5678"
                ],
                [
                    "9876",
                    "6789"
                ],
                [
                    "1111",
                    "1111"
                ],
                [
                    "1234",
                    "4321"
                ],
                [
                    "5678",
                    "8765"
                ],
                [
                    "9999",
                    "9999"
                ],
                [
                    "0000",
                    "0000"
                ],
                [
                    "1234",
                    "5678"
                ],
                [
                    "1234",
                    "1234"
                ],
                [
                    "1234",
                    "4321"
                ],
                [
                    "5678",
                    "8765"
                ],
                [
                    "9999",
                    "9999"
                ],
                [
                    "0000",
                    "0000"
                ],
                [
                    "1234",
                    "5678"
                ],
                [
                    "1234",
                    "1234"
                ],
                [
                    "1234",
                    "4321"
                ],
                [
                    "5678",
                    "8765"
                ],
                [
                    "9999",
                    "9999"
                ]
            ],
            "outputs": [
                "'1A3B'",
                "'1A1B'",
                "'0A0B'",
                "'0A4B'",
                "'4A0B'",
                "'0A4B'",
                "'0A4B'",
                "'4A0B'",
                "'4A0B'",
                "'0A0B'",
                "'4A0B'",
                "'0A4B'",
                "'0A4B'",
                "'4A0B'",
                "'4A0B'",
                "'0A0B'",
                "'4A0B'",
                "'0A4B'",
                "'0A4B'",
                "'4A0B'"
            ]
        },
        "sample_code": {
            "c++": "std::string getHint(std::string secret, std::string guess) {\n    int bulls = 0, cows = 0;\n    std::vector<int> secret_count(10, 0);\n    std::vector<int> guess_count(10, 0);\n\n    for (size_t i = 0; i < secret.length(); i++) {\n        if (secret[i] == guess[i]) {\n            bulls++;\n        } else {\n            secret_count[secret[i] - '0']++;\n            guess_count[guess[i] - '0']++;\n        }\n    }\n\n    for (size_t i = 0; i < 10; i++) {\n        cows += std::min(secret_count[i], guess_count[i]);\n    }\n\n    return std::to_string(bulls) + \"A\" + std::to_string(cows) + \"B\";\n}\n\n",
            "java": "public String getHint(String secret, String guess) {\n    int bulls = 0, cows = 0;\n    int[] secretCount = new int[10];\n    int[] guessCount = new int[10];\n\n    for (int i = 0; i < secret.length(); i++) {\n        if (secret.charAt(i) == guess.charAt(i)) {\n            bulls++;\n        } else {\n            secretCount[secret.charAt(i) - '0']++;\n            guessCount[guess.charAt(i) - '0']++;\n        }\n    }\n\n    for (int i = 0; i < 10; i++) {\n        cows += Math.min(secretCount[i], guessCount[i]);\n    }\n\n    return bulls + \"A\" + cows + \"B\";\n}\n\n",
            "python": "def get_hint(secret: str, guess: str) -> str:\n    bulls = cows = 0\n    secret_count = [0] * 10\n    guess_count = [0] * 10\n\n    for i in range(len(secret)):\n        if secret[i] == guess[i]:\n            bulls += 1\n        else:\n            secret_count[int(secret[i])] += 1\n            guess_count[int(guess[i])] += 1\n   \n    for i in range(10):\n        cows += min(secret_count[i], guess_count[i])\n    \n    return f\"{bulls}A{cows}B\"\n\n",
            "javascript": "function getHint(secret, guess) {\n    let bulls = 0, cows = 0;\n    let secretCount = Array(10).fill(0);\n    let guessCount = Array(10).fill(0);\n\n    for (let i = 0; i < secret.length; i++) {\n        if (secret[i] === guess[i]) {\n            bulls++;\n        } else {\n            secretCount[parseInt(secret[i])]++;\n            guessCount[parseInt(guess[i])]++;\n        }\n    }\n\n    for (let i = 0; i < 10; i++) {\n        cows += Math.min(secretCount[i], guessCount[i]);\n    }\n\n    return `${bulls}A${cows}B`;\n}\n\n",
            "explanation": "The algorithm first initializes the counts for bulls and cows to be 0. We also create two arrays called secret_count and guess_count to store the count of each digit from '0' to '9' in the secret and guess strings.\n\nWe then loop through both the secret and the guess strings. For each position, if the digits are the same in both strings (i.e., secret[i] == guess[i]), we increase the bulls count. If not, we increment the corresponding count for the secret and guess digits.\n\nAfter iterating through the strings, we loop through the count arrays and add the minimum of the counts of each digit in secret_count and guess_count to the cows count.\n\nFinally, we return the result in the \"xAyB\" format by concatenating the values of bulls and cows."
        },
        "structure": {
            "c++": "std::string getHint(std::string secret, std::string guess)  {\n    // Your code here\n}\n\n",
            "java": "public String getHint(String secret, String guess)  {\n    // Your code here\n}\n\n",
            "python": "def get_hint(secret: str, guess: str) -> str:\n    # Your code here\n\n",
            "javascript": "function getHint(secret, guess)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "std::string getHint(std::string secret, std::string guess) {\n    int bulls = 0, cows = 0;\n    std::vector<int> secret_count(10, 0);\n    std::vector<int> guess_count(10, 0);\n\n    for (size_t i = 0; i < secret.length(); i++) {\n        if (secret[i] == guess[i]) {\n            bulls++;\n        } else {\n            secret_count[secret[i] - '0']++;\n            guess_count[guess[i] - '0']++;\n        }\n    }\n\n    for (size_t i = 0; i < 10; i++) {\n        cows += std::min(secret_count[i], guess_count[i]);\n    }\n\n    return std::to_string(bulls) + \"A\" + std::to_string(cows) + \"B\";\n}",
            "java": "public String getHint(String secret, String guess) {\n    int bulls = 0, cows = 0;\n    int[] secretCount = new int[10];\n    int[] guessCount = new int[10];\n\n    for (int i = 0; i < secret.length(); i++) {\n        if (secret.charAt(i) == guess.charAt(i)) {\n            bulls++;\n        } else {\n            secretCount[secret.charAt(i) - '0']++;\n            guessCount[guess.charAt(i) - '0']++;\n        }\n    }\n\n    for (int i = 0; i < 10; i++) {\n        cows += Math.min(secretCount[i], guessCount[i]);\n    }\n\n    return bulls + \"A\" + cows + \"B\";\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    secret = inputs[0]\n    guess = inputs[1]\n    result = get_hint(secret, guess)\n    print(result)",
            "javascript": "function getHint(secret, guess) {\n    let bulls = 0, cows = 0;\n    let secretCount = Array(10).fill(0);\n    let guessCount = Array(10).fill(0);\n\n    for (let i = 0; i < secret.length; i++) {\n        if (secret[i] === guess[i]) {\n            bulls++;\n        } else {\n            secretCount[parseInt(secret[i])]++;\n            guessCount[parseInt(guess[i])]++;\n        }\n    }\n\n    for (let i = 0; i < 10; i++) {\n        cows += Math.min(secretCount[i], guessCount[i]);\n    }\n\n    return `${bulls}A${cows}B`;\n}"
        },
        "Qid": "299"
    },
    {
        "_id": {
            "$oid": "661e9108555605d7c12757f7"
        },
        "title": "Longest Increasing Subsequence",
        "description": "Given an integer array `nums`, find the length of the longest strictly increasing subsequence.",
        "example": "Example 1:\n\nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    10,
                    9,
                    2,
                    5,
                    3,
                    7,
                    101,
                    18
                ],
                [
                    0,
                    1,
                    0,
                    3,
                    2,
                    3
                ],
                [
                    7,
                    7,
                    7,
                    7,
                    7,
                    7,
                    7
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    3,
                    2,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    1,
                    2,
                    3,
                    1,
                    2,
                    3
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ]
            ],
            "outputs": [
                4,
                4,
                1,
                5,
                1,
                4,
                3,
                10,
                1,
                10
            ]
        },
        "sample_code": {
            "c++": "int lengthOfLIS(vector<int>& nums) {\n    vector<int> dp(nums.size(), 1);\n    int max_length = 1;\n    for (int i = 1; i < nums.size(); i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n        max_length = max(max_length, dp[i]);\n    }\n    return max_length;\n}\n",
            "java": "public int lengthOfLIS(int[] nums) {\n    int[] dp = new int[nums.length];\n    int max_length = 1;\n    Arrays.fill(dp, 1);\n    for (int i = 1; i < nums.length; i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n        max_length = Math.max(max_length, dp[i]);\n    }\n    return max_length;\n}\n",
            "python": "def lengthOfLIS(nums):\n    dp = [1] * len(nums)\n    max_length = 1\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n        max_length = max(max_length, dp[i])\n    return max_length\n",
            "javascript": "function lengthOfLIS(nums) {\n    const dp = new Array(nums.length).fill(1);\n    let max_length = 1;\n    for (let i = 1; i < nums.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n        max_length = Math.max(max_length, dp[i]);\n    }\n    return max_length;\n}\n",
            "explanation": "The algorithm employs dynamic programming to solve the problem. The algorithm initializes an array `dp` of the same length as the input array `nums`, and initializes all its elements with the value 1, indicating that at least a single element can be part of the longest increasing subsequence.\n\nThen, it employs a nested loop to iterate over the input array from the second element onwards. In the inner loop, we compare each element from the 0th index to `i-1` with the current element at `i`. If the current element is greater than the previous element, we update the `dp[i]` value by taking the maximum of the current `dp[i]` value and the `dp[j]` value of the previous element + 1, which indicates the length of the increasing subsequence.\n\nFinally, we update the max_length variable after each outer loop by taking its maximum from the array `dp`. After completing the iterations, we return the length of the longest increasing subsequence."
        },
        "structure": {
            "c++": "int lengthOfLIS(vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "public int lengthOfLIS(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def lengthOfLIS(nums):\n    # Your code here\n\n",
            "javascript": "function lengthOfLIS(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int lengthOfLIS(vector<int>& nums) {\n    vector<int> dp(nums.size(), 1);\n    int max_length = 1;\n    for (int i = 1; i < nums.size(); i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n        max_length = max(max_length, dp[i]);\n    }\n    return max_length;\n}",
            "java": "public int lengthOfLIS(int[] nums) {\n    int[] dp = new int[nums.length];\n    int max_length = 1;\n    Arrays.fill(dp, 1);\n    for (int i = 1; i < nums.length; i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n        max_length = Math.max(max_length, dp[i]);\n    }\n    return max_length;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = lengthOfLIS(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = lengthOfLIS(nums);\n    console.log(result);\n}"
        },
        "Qid": "300"
    },
    {
        "_id": {
            "$oid": "661e9190555605d7c12757f8"
        },
        "title": "Additive Number",
        "description": "An additive number is a string whose digits can form an additive sequence. A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two. Given a string containing only digits, return true if it is an additive number or false otherwise. Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.",
        "example": "Example:\n\nInput: \"112358\"\nOutput: true\nExplanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8. 1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8",
        "level": "Medium",
        "tags": [
            "String",
            "Recursion"
        ],
        "test_cases": {
            "inputs": [
                "\"112358\"",
                "\"199100199\"",
                "\"123456789\"",
                "\"101\"",
                "\"111\"",
                "\"123\"",
                "\"100200300\"",
                "\"100100200\"",
                "\"100100200300\"",
                "\"100100200300500\"",
                "\"100100200300500800\"",
                "\"1001002003005008001300\"",
                "\"10010020030050080013002000\"",
                "\"100100200300500800130020003000\"",
                "\"1001002003005008001300200030005000\"",
                "\"10010020030050080013002000300050008000\"",
                "\"1001002003005008001300200030005000800013000\"",
                "\"10010020030050080013002000300050008000130002000\"",
                "\"100100200300500800130020003000500080001300020003000\"",
                "\"1001002003005008001300200030005000800013000200030005000\""
            ],
            "outputs": [
                true,
                true,
                false,
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "bool isAdditiveNumber(std::string num) {\n    for (int i = 1; i <= num.length() / 2; i++) {\n        for (int j = 1; j <= (num.length() - i) / 2; j++) {\n            if (check(num.substr(0, i), num.substr(i, j), num.substr(i + j))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool check(std::string num1, std::string num2, std::string remaining) {\n    if ((num1.size() > 1 && num1[0] == '0') || (num2.size() > 1 && num2[0] == '0')) {\n        return false;\n    }\n    std::string sum = add(num1, num2);\n    if (remaining == sum) {\n        return true;\n    }\n    if (remaining.substr(0, sum.size()) != sum) {\n        return false;\n    }\n    return check(num2, sum, remaining.substr(sum.size()));\n}\n\nstd::string add(std::string num1, std::string num2) {\n    int carry = 0;\n    std::string result;\n    for (int i = num1.size() - 1, j = num2.size() - 1;\n         i >= 0 || j >= 0 || carry > 0; i--, j--) {\n        int n1 = i >= 0 ? num1[i] - '0' : 0;\n        int n2 = j >= 0 ? num2[j] - '0' : 0;\n        int sum = n1 + n2 + carry;\n        carry = sum / 10;\n        result.push_back('0' + sum % 10);\n    }\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n",
            "java": "public boolean isAdditiveNumber(String num) {\n    for (int i = 1; i <= num.length() / 2; i++) {\n        for (int j = 1; j <= (num.length() - i) / 2; j++) {\n            if (check(num.substring(0, i), num.substring(i, i + j), num.substring(i + j))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean check(String num1, String num2, String remaining) {\n    if ((num1.length() > 1 && num1.charAt(0) == '0') || (num2.length() > 1 && num2.charAt(0) == '0')) {\n        return false;\n    }\n    String sum = add(num1, num2);\n    if (remaining.equals(sum)) {\n        return true;\n    }\n    if (!remaining.startsWith(sum)) {\n        return false;\n    }\n    return check(num2, sum, remaining.substring(sum.length()));\n}\n\nprivate String add(String num1, String num2) {\n    int carry = 0;\n    StringBuilder result = new StringBuilder();\n    for (int i = num1.length() - 1, j = num2.length() - 1;\n         i >= 0 || j >= 0 || carry > 0; i--, j--) {\n        int n1 = i >= 0 ? num1.charAt(i) - '0' : 0;\n        int n2 = j >= 0 ? num2.charAt(j) - '0' : 0;\n        int sum = n1 + n2 + carry;\n        carry = sum / 10;\n        result.append((char) ('0' + sum % 10));\n    }\n    return result.reverse().toString();\n}\n",
            "python": "def isAdditiveNumber(num):\n    for i in range(1, len(num) // 2 + 1):\n        for j in range(1, (len(num) - i) // 2 + 1):\n            if check(num[:i], num[i:i+j], num[i+j:]):\n                return True\n    return False\n\ndef check(num1, num2, remaining):\n    if (len(num1) > 1 and num1[0] == '0') or (len(num2) > 1 and num2[0] == '0'):\n        return False\n    _sum = add(num1, num2)\n    if remaining == _sum:\n        return True\n    if not remaining.startswith(_sum):\n        return False\n    return check(num2, _sum, remaining[len(_sum):])\n\ndef add(num1, num2):\n    carry, result = 0, []\n    i, j = len(num1) - 1, len(num2) - 1\n    while i >= 0 or j >= 0 or carry > 0:\n        n1 = int(num1[i]) if i >= 0 else 0\n        n2 = int(num2[j]) if j >= 0 else 0\n        _sum = n1 + n2 + carry\n        carry = _sum // 10\n        result.append(str(_sum % 10))\n        i, j = i - 1, j - 1\n    return ''.join(result[::-1])\n",
            "javascript": "function isAdditiveNumber(num) {\n    for (let i = 1; i <= num.length / 2; i++) {\n        for (let j = 1; j <= (num.length - i) / 2; j++) {\n            if (check(num.slice(0, i), num.slice(i, i + j), num.slice(i + j))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nfunction check(num1, num2, remaining) {\n    if ((num1.length > 1 && num1[0] === '0') || (num2.length > 1 && num2[0] === '0')) {\n        return false;\n    }\n    let sum = add(num1, num2);\n    if (remaining === sum) {\n        return true;\n    }\n    if (!remaining.startsWith(sum)) {\n        return false;\n    }\n    return check(num2, sum, remaining.slice(sum.length));\n}\n\nfunction add(num1, num2) {\n    let carry = 0;\n    let result = '';\n    for (let i = num1.length - 1, j = num2.length - 1;\n         i >= 0 || j >= 0 || carry > 0; i--, j--) {\n        let n1 = i >= 0 ? Number(num1[i]) : 0;\n        let n2 = j >= 0 ? Number(num2[j]) : 0;\n        let sum = n1 + n2 + carry;\n        carry = Math.floor(sum / 10);\n        result = (sum % 10).toString() + result;\n    }\n    return result;\n}\n",
            "explanation": "1. Iterate through all possible positions to split the string into two non-empty numbers num1 and num2.\n2. Check if num1 and num2 are valid, i.e., not having leading zeros for multiple digits numbers.\n3. Calculate the sum of num1 and num2.\n4. Check if the remaining part of the string starts with the sum. If not, return false.\n5. If the remaining string is exactly the sum, return true; otherwise, repeat the process with num2, sum, and the remaining string.\n6. If it's not possible to find a valid combination, return false."
        },
        "structure": {
            "c++": "bool isAdditiveNumber(std::string num)  {\n    // Your code here\n}\n",
            "java": "public boolean isAdditiveNumber(String num)  {\n    // Your code here\n}\n",
            "python": "def isAdditiveNumber(num):\n    # Your code here\n\n",
            "javascript": "function isAdditiveNumber(num)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "bool isAdditiveNumber(std::string num) {\n    for (int i = 1; i <= num.length() / 2; i++) {\n        for (int j = 1; j <= (num.length() - i) / 2; j++) {\n            if (check(num.substr(0, i), num.substr(i, j), num.substr(i + j))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool check(std::string num1, std::string num2, std::string remaining) {\n    if ((num1.size() > 1 && num1[0] == '0') || (num2.size() > 1 && num2[0] == '0')) {\n        return false;\n    }\n    std::string sum = add(num1, num2);\n    if (remaining == sum) {\n        return true;\n    }\n    if (remaining.substr(0, sum.size()) != sum) {\n        return false;\n    }\n    return check(num2, sum, remaining.substr(sum.size()));\n}\n\nstd::string add(std::string num1, std::string num2) {\n    int carry = 0;\n    std::string result;\n    for (int i = num1.size() - 1, j = num2.size() - 1;\n         i >= 0 || j >= 0 || carry > 0; i--, j--) {\n        int n1 = i >= 0 ? num1[i] - '0' : 0;\n        int n2 = j >= 0 ? num2[j] - '0' : 0;\n        int sum = n1 + n2 + carry;\n        carry = sum / 10;\n        result.push_back('0' + sum % 10);\n    }\n    std::reverse(result.begin(), result.end());\n    return result;\n}",
            "java": "public boolean isAdditiveNumber(String num) {\n    for (int i = 1; i <= num.length() / 2; i++) {\n        for (int j = 1; j <= (num.length() - i) / 2; j++) {\n            if (check(num.substring(0, i), num.substring(i, i + j), num.substring(i + j))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean check(String num1, String num2, String remaining) {\n    if ((num1.length() > 1 && num1.charAt(0) == '0') || (num2.length() > 1 && num2.charAt(0) == '0')) {\n        return false;\n    }\n    String sum = add(num1, num2);\n    if (remaining.equals(sum)) {\n        return true;\n    }\n    if (!remaining.startsWith(sum)) {\n        return false;\n    }\n    return check(num2, sum, remaining.substring(sum.length()));\n}\n\nprivate String add(String num1, String num2) {\n    int carry = 0;\n    StringBuilder result = new StringBuilder();\n    for (int i = num1.length() - 1, j = num2.length() - 1;\n         i >= 0 || j >= 0 || carry > 0; i--, j--) {\n        int n1 = i >= 0 ? num1.charAt(i) - '0' : 0;\n        int n2 = j >= 0 ? num2.charAt(j) - '0' : 0;\n        int sum = n1 + n2 + carry;\n        carry = sum / 10;\n        result.append((char) ('0' + sum % 10));\n    }\n    return result.reverse().toString();\n}",
            "python": "if __name__ == \"__main__\":\n    num = $args\n    result = isAdditiveNumber(num)\n    print(result)",
            "javascript": "function main() {\n    const num = $args;\n    const result = isAdditiveNumber(num);\n    console.log(result);\n}"
        },
        "Qid": "306"
    },
    {
        "_id": {
            "$oid": "661e9213555605d7c12757f9"
        },
        "title": "Minimum Height Trees",
        "description": "Given a tree with `n` nodes labelled from `0` to `n - 1`, and an array of `n - 1` edges where `edges[i] = [ai, bi]` indicates an undirected edge between nodes `ai` and `bi`, find all the root labels of the minimum height trees (MHTs). The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.",
        "example": "Example 1:\n\nInput: n = 4, edges = [[1,0],[1,2],[1,3]]\nOutput: [1]\nExplanation: The height of the tree is 1 when the root is the node with label 1, which is the only MHT.\n\nExample 2:\n\nInput: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]\nOutput: [3,4]\nExplanation: The heights of the trees are 2 when the root is the node with label 3, and 2 when the root is the node with label 4, which are the MHTs.",
        "level": "Medium",
        "tags": [
            "Graphs",
            "Trees",
            "BFS",
            "Topological Sort"
        ],
        "test_cases": {
            "inputs": [
                [
                    4,
                    [
                        [
                            1,
                            0
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            1,
                            3
                        ]
                    ]
                ],
                [
                    6,
                    [
                        [
                            3,
                            0
                        ],
                        [
                            3,
                            1
                        ],
                        [
                            3,
                            2
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            5,
                            4
                        ]
                    ]
                ],
                [
                    1,
                    []
                ],
                [
                    2,
                    [
                        [
                            0,
                            1
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            4
                        ]
                    ]
                ]
            ],
            "outputs": [
                [
                    1
                ],
                [
                    3,
                    4
                ],
                [
                    0
                ],
                [
                    0,
                    1
                ],
                [
                    2
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n    if (n == 1) return {0};\n\n    vector<int> degrees(n, 0);\n    vector<vector<int>> adjList(n);\n    for (const auto &edge : edges) {\n        adjList[edge[0]].push_back(edge[1]);\n        adjList[edge[1]].push_back(edge[0]);\n        degrees[edge[0]]++;\n        degrees[edge[1]]++;\n    }\n\n    queue<int> q;\n    for (int i = 0; i < n; ++i) {\n        if (degrees[i] == 1) q.push(i);\n    }\n\n    while (n > 2) {\n        int leaves_size = q.size();\n        n -= leaves_size;\n        for (int i = 0; i < leaves_size; i++) {\n            int leaf = q.front(); q.pop();\n            for (int neighbor : adjList[leaf]) {\n                if (--degrees[neighbor] == 1) q.push(neighbor);\n            }\n        }\n    }\n\n    vector<int> result;\n    while (!q.empty()) {\n        result.push_back(q.front());\n        q.pop();\n    }\n\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic List<Integer> findMinHeightTrees(int n, int[][] edges) {\n    if (n == 1) {\n        List<Integer> result = new ArrayList<>();\n        result.add(0);\n        return result;\n    }\n\n    int[] degrees = new int[n];\n    List<List<Integer>> adjList = new ArrayList<>(n);\n    for (int i = 0; i < n; i++) {\n        adjList.add(new ArrayList<>());\n    }\n\n    for (int[] edge : edges) {\n        adjList.get(edge[0]).add(edge[1]);\n        adjList.get(edge[1]).add(edge[0]);\n        degrees[edge[0]]++;\n        degrees[edge[1]]++;\n    }\n\n    Queue<Integer> queue = new LinkedList<>();\n    for (int i = 0; i < n; i++) {\n        if (degrees[i] == 1) queue.add(i);\n    }\n\n    while (n > 2) {\n        int leavesSize = queue.size();\n        n -= leavesSize;\n        for (int i = 0; i < leavesSize; i++) {\n            int leaf = queue.poll();\n            for (int neighbor : adjList.get(leaf)) {\n                if (--degrees[neighbor] == 1) queue.add(neighbor);\n            }\n        }\n    }\n\n    return new ArrayList<>(queue);\n}\n",
            "python": "from collections import deque\nfrom typing import List\n\ndef find_min_height_trees(n: int, edges: List[List[int]]) -> List[int]:\n    if n == 1:\n        return [0]\n\n    adj_list = [set() for _ in range(n)]\n    for a, b in edges:\n        adj_list[a].add(b)\n        adj_list[b].add(a)\n\n    leaves = deque(i for i in range(n) if len(adj_list[i]) == 1)\n\n    while n > 2:\n        leaves_size = len(leaves)\n        n -= leaves_size\n        for _ in range(leaves_size):\n            leaf = leaves.popleft()\n            for neighbor in adj_list[leaf]:\n                adj_list[neighbor].remove(leaf)\n                if len(adj_list[neighbor]) == 1:\n                    leaves.append(neighbor)\n\n    return list(leaves)\n",
            "javascript": "function findMinHeightTrees(n, edges) {\n  if (n === 1) return [0];\n\n  const adjList = Array.from({ length: n }, () => []);\n  const degrees = new Array(n).fill(0);\n\n  for (const [a, b] of edges) {\n    adjList[a].push(b);\n    adjList[b].push(a);\n    degrees[a]++;\n    degrees[b]++;\n  }\n\n  const queue = [];\n  for (let i = 0; i < n; i++) {\n    if (degrees[i] === 1) queue.push(i);\n  }\n\n  while (n > 2) {\n    const leavesSize = queue.length;\n    n -= leavesSize;\n    for (let i = 0; i < leavesSize; i++) {\n      const leaf = queue.shift();\n      for (const neighbor of adjList[leaf]) {\n        if (--degrees[neighbor] === 1) queue.push(neighbor);\n      }\n    }\n  }\n\n  return queue;\n}\n",
            "explanation": "1. Create an adjacency list from the given edges to represent the graph.\n2. Initialize a queue with all leaf nodes, i.e., nodes with only one edge (degree = 1).\n3. Start a loop that continues until there are only 1 or 2 nodes left, i.e., reduce the tree to minimum height:\n   a. Calculate the size of the current leaves (nodes to process).\n   b. Reduce the number of nodes left by the size of the current leaves.\n   c. For each leaf in the queue, remove its edges from the adjacency list and decrement the corresponding degrees.\n   d. If a neighbor's degree becomes 1 after removing the edges, add them to the queue (it becomes a new leaf for the next iteration).\n4. The remaining node(s) in the queue will be the root(s) of the MHT(s). Return them as a list."
        },
        "structure": {
            "c++": "#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<int> findMinHeightTrees(int n, vector<vector<int>>& edges)  {\n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic List<Integer> findMinHeightTrees(int n, int[][] edges)  {\n    // Your code here\n}\n",
            "python": "from collections import deque\n    # Your code here\n\n",
            "javascript": "function findMinHeightTrees(n, edges)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n    if (n == 1) return {0};\n\n    vector<int> degrees(n, 0);\n    vector<vector<int>> adjList(n);\n    for (const auto &edge : edges) {\n        adjList[edge[0]].push_back(edge[1]);\n        adjList[edge[1]].push_back(edge[0]);\n        degrees[edge[0]]++;\n        degrees[edge[1]]++;\n    }\n\n    queue<int> q;\n    for (int i = 0; i < n; ++i) {\n        if (degrees[i] == 1) q.push(i);\n    }\n\n    while (n > 2) {\n        int leaves_size = q.size();\n        n -= leaves_size;\n        for (int i = 0; i < leaves_size; i++) {\n            int leaf = q.front(); q.pop();\n            for (int neighbor : adjList[leaf]) {\n                if (--degrees[neighbor] == 1) q.push(neighbor);\n            }\n        }\n    }\n\n    vector<int> result;\n    while (!q.empty()) {\n        result.push_back(q.front());\n        q.pop();\n    }\n\n    return result;\n}",
            "java": "public List<Integer> findMinHeightTrees(int n, int[][] edges) {\n    if (n == 1) {\n        List<Integer> result = new ArrayList<>();\n        result.add(0);\n        return result;\n    }\n\n    int[] degrees = new int[n];\n    List<List<Integer>> adjList = new ArrayList<>(n);\n    for (int i = 0; i < n; i++) {\n        adjList.add(new ArrayList<>());\n    }\n\n    for (int[] edge : edges) {\n        adjList.get(edge[0]).add(edge[1]);\n        adjList.get(edge[1]).add(edge[0]);\n        degrees[edge[0]]++;\n        degrees[edge[1]]++;\n    }\n\n    Queue<Integer> queue = new LinkedList<>();\n    for (int i = 0; i < n; i++) {\n        if (degrees[i] == 1) queue.add(i);\n    }\n\n    while (n > 2) {\n        int leavesSize = queue.size();\n        n -= leavesSize;\n        for (int i = 0; i < leavesSize; i++) {\n            int leaf = queue.poll();\n            for (int neighbor : adjList.get(leaf)) {\n                if (--degrees[neighbor] == 1) queue.add(neighbor);\n            }\n        }\n    }\n\n    return new ArrayList<>(queue);\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    n = inputs[0]\n    edges = inputs[1]\n    result = find_min_height_trees(n, edges)\n    print(result)",
            "javascript": "function main() {\n  const n = $args;\n  const edges = $args;\n  const result = findMinHeightTrees(n, edges);\n  console.log(result);\n}"
        },
        "Qid": "310"
    },
    {
        "_id": {
            "$oid": "661e927a555605d7c12757fa"
        },
        "title": "Burst Balloons",
        "description": "You are given `n` balloons, indexed from `0` to `n - 1`. Each balloon is painted with a number on it represented by an array `nums`. You are asked to burst all the balloons.\n\nIf you burst the `ith` balloon, you will get `nums[i - 1] * nums[i] * nums[i + 1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array, then treat it as if there is a balloon with a `1` painted on it.\n\nReturn the maximum coins you can collect by bursting the balloons wisely.",
        "example": "Example:\n\nInput: nums = [3,1,5,8]\nOutput: 167\nExplanation:\nnums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []\ncoins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    1,
                    5,
                    8
                ],
                [
                    1,
                    5
                ],
                [
                    2,
                    4,
                    6,
                    8
                ],
                [
                    9,
                    2,
                    7,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    20,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ]
            ],
            "outputs": [
                167,
                10,
                240,
                504,
                2016,
                2016,
                225,
                9,
                0,
                8648640,
                8648640
            ]
        },
        "sample_code": {
            "c++": "int maxCoins(vector<int>& nums) {\n    int n = nums.size();\n    nums.insert(nums.begin(), 1);\n    nums.push_back(1);\n\n    vector<vector<int>> dp(n + 2, vector<int>(n + 2, 0));\n    for (int len = 1; len <= n; len++) {\n        for (int left = 1; left <= n - len + 1; left++) {\n            int right = left + len - 1;\n            for (int i = left; i <= right; i++) {\n                dp[left][right] = max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);\n            }\n        }\n    }\n\n    return dp[1][n];\n}\n",
            "java": "public int maxCoins(int[] nums) {\n    int n = nums.length;\n    int[] newNums = new int[n + 2];\n    newNums[0] = 1;\n    newNums[n + 1] = 1;\n    for (int i = 1; i <= n; i++) {\n        newNums[i] = nums[i - 1];\n    }\n\n    int[][] dp = new int[n + 2][n + 2];\n    for (int len = 1; len <= n; len++) {\n        for (int left = 1; left <= n - len + 1; left++) {\n            int right = left + len - 1;\n            for (int i = left; i <= right; i++) {\n                dp[left][right] = Math.max(dp[left][right], newNums[left - 1] * newNums[i] * newNums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);\n            }\n        }\n    }\n\n    return dp[1][n];\n}\n",
            "python": "def maxCoins(nums):\n    nums = [1] + nums + [1]\n    n = len(nums)\n    dp = [[0] * n for _ in range(n)]\n\n    for length in range(1, n - 1):\n        for left in range(1, n - length):\n            right = left + length - 1\n            for i in range(left, right + 1):\n                dp[left][right] = max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right])\n\n    return dp[1][n - 2]\n",
            "javascript": "function maxCoins(nums) {\n    nums.unshift(1);\n    nums.push(1);\n    const n = nums.length;\n\n    const dp = [];\n    for (let i = 0; i < n; i++) {\n        dp.push(new Array(n).fill(0));\n    }\n\n    for (let len = 1; len <= n - 2; len++) {\n        for (let left = 1; left <= n - len - 1; left++) {\n            const right = left + len - 1;\n            for (let i = left; i <= right; i++) {\n                dp[left][right] = Math.max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);\n            }\n        }\n    }\n\n    return dp[1][n - 2];\n}\n",
            "explanation": "This problem can be solved using dynamic programming. We define a 2D array `dp` where `dp[left][right]` represents the maximum coins we can get by bursting the balloons from index `left` to `right`. To fill `dp`, we iterate over all possible subarrays (by varying length) and calculate the optimal solution for each subarray by choosing the bursting order. For each subarray, we iterate over all balloons, bursting the `i`th balloon and taking the maximum value between the current `dp[left][right]` and the obtained coins by bursting the `i`th balloon + the coins obtained by bursting the balloons on the left of `i`th balloon + the coins obtained by bursting the balloons on the right of `i`th balloon. Finally, we return `dp[1][n - 2]` since we added dummy balloons with value 1 at the beginning and end."
        },
        "structure": {
            "c++": "int maxCoins(vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "public int maxCoins(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def maxCoins(nums):\n    # Your code here\n\n",
            "javascript": "function maxCoins(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int maxCoins(vector<int>& nums) {\n    int n = nums.size();\n    nums.insert(nums.begin(), 1);\n    nums.push_back(1);\n\n    vector<vector<int>> dp(n + 2, vector<int>(n + 2, 0));\n    for (int len = 1; len <= n; len++) {\n        for (int left = 1; left <= n - len + 1; left++) {\n            int right = left + len - 1;\n            for (int i = left; i <= right; i++) {\n                dp[left][right] = max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);\n            }\n        }\n    }\n\n    return dp[1][n];\n}",
            "java": "public int maxCoins(int[] nums) {\n    int n = nums.length;\n    int[] newNums = new int[n + 2];\n    newNums[0] = 1;\n    newNums[n + 1] = 1;\n    for (int i = 1; i <= n; i++) {\n        newNums[i] = nums[i - 1];\n    }\n\n    int[][] dp = new int[n + 2][n + 2];\n    for (int len = 1; len <= n; len++) {\n        for (int left = 1; left <= n - len + 1; left++) {\n            int right = left + len - 1;\n            for (int i = left; i <= right; i++) {\n                dp[left][right] = Math.max(dp[left][right], newNums[left - 1] * newNums[i] * newNums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);\n            }\n        }\n    }\n\n    return dp[1][n];\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = maxCoins(nums)\n    print(result)",
            "javascript": "function maxCoins(nums) {\n    nums.unshift(1);\n    nums.push(1);\n    const n = nums.length;\n\n    const dp = [];\n    for (let i = 0; i < n; i++) {\n        dp.push(new Array(n).fill(0));\n    }\n\n    for (let len = 1; len <= n - 2; len++) {\n        for (let left = 1; left <= n - len - 1; left++) {\n            const right = left + len - 1;\n            for (let i = left; i <= right; i++) {\n                dp[left][right] = Math.max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);\n            }\n        }\n    }\n\n    return dp[1][n - 2];\n}"
        },
        "Qid": "312"
    },
    {
        "_id": {
            "$oid": "661e92b0555605d7c12757fb"
        },
        "title": "Super Ugly Number",
        "description": "A super ugly number is a positive integer whose prime factors are in the array `primes`. Given an integer `n` and an array of integers `primes`, return the `nth` super ugly number. The `nth` super ugly number is guaranteed to fit in a 32-bit signed integer.",
        "example": "Example:\n\nInput: n = 12, primes = [2,7,13,19]\nOutput: 32\nExplanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].",
        "level": "Medium",
        "tags": [
            "Math",
            "Dynamic Programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    [
                        2,
                        3,
                        5
                    ]
                ],
                [
                    5,
                    [
                        2,
                        3,
                        5
                    ]
                ],
                [
                    10,
                    [
                        2,
                        3,
                        5
                    ]
                ],
                [
                    15,
                    [
                        2,
                        3,
                        5
                    ]
                ],
                [
                    20,
                    [
                        2,
                        3,
                        5
                    ]
                ],
                [
                    25,
                    [
                        2,
                        3,
                        5
                    ]
                ],
                [
                    30,
                    [
                        2,
                        3,
                        5
                    ]
                ],
                [
                    35,
                    [
                        2,
                        3,
                        5
                    ]
                ],
                [
                    40,
                    [
                        2,
                        3,
                        5
                    ]
                ],
                [
                    45,
                    [
                        2,
                        3,
                        5
                    ]
                ],
                [
                    50,
                    [
                        2,
                        3,
                        5
                    ]
                ],
                [
                    55,
                    [
                        2,
                        3,
                        5
                    ]
                ],
                [
                    60,
                    [
                        2,
                        3,
                        5
                    ]
                ],
                [
                    65,
                    [
                        2,
                        3,
                        5
                    ]
                ],
                [
                    70,
                    [
                        2,
                        3,
                        5
                    ]
                ],
                [
                    75,
                    [
                        2,
                        3,
                        5
                    ]
                ],
                [
                    80,
                    [
                        2,
                        3,
                        5
                    ]
                ],
                [
                    85,
                    [
                        2,
                        3,
                        5
                    ]
                ],
                [
                    90,
                    [
                        2,
                        3,
                        5
                    ]
                ]
            ],
            "outputs": [
                1,
                5,
                12,
                24,
                32,
                48,
                64,
                80,
                96,
                120,
                128,
                144,
                160,
                192,
                200,
                216,
                240,
                256,
                288,
                320
            ]
        },
        "sample_code": {
            "c++": "int nthSuperUglyNumber(int n, vector<int>& primes) {\n    vector<int> ugly(n);\n    ugly[0] = 1;\n    vector<int> indices(primes.size(), 0);\n    \n    for (int i = 1; i < n; i++) {\n        int min_val = INT_MAX;\n        \n        for (int j = 0; j < primes.size(); j++)\n            min_val = min(min_val, ugly[indices[j]] * primes[j]);\n        \n        ugly[i] = min_val;\n        \n        for (int j = 0; j < primes.size(); j++)\n            if (ugly[i] == ugly[indices[j]] * primes[j])\n                indices[j]++;\n    }\n    \n    return ugly.back();\n}\n",
            "java": "public int nthSuperUglyNumber(int n, int[] primes) {\n    int[] ugly = new int[n];\n    ugly[0] = 1;\n    int[] indices = new int[primes.length];\n\n    for (int i = 1; i < n; i++) {\n        int minVal = Integer.MAX_VALUE;\n\n        for (int j = 0; j < primes.length; j++)\n            minVal = Math.min(minVal, ugly[indices[j]] * primes[j]);\n\n        ugly[i] = minVal;\n\n        for (int j = 0; j < primes.length; j++)\n            if (ugly[i] == ugly[indices[j]] * primes[j])\n                indices[j]++;\n    }\n\n    return ugly[n - 1];\n}\n",
            "python": "def nthSuperUglyNumber(n, primes):\n    ugly = [0] * n\n    ugly[0] = 1\n    indices = [0] * len(primes)\n\n    for i in range(1, n):\n        min_val = float(\"inf\")\n\n        for j in range(len(primes)):\n            min_val = min(min_val, ugly[indices[j]] * primes[j])\n\n        ugly[i] = min_val\n\n        for j in range(len(primes)):\n            if ugly[i] == ugly[indices[j]] * primes[j]:\n                indices[j] += 1\n\n    return ugly[-1]\n",
            "javascript": "function nthSuperUglyNumber(n, primes) {\n    let ugly = new Array(n);\n    ugly[0] = 1;\n    let indices = new Array(primes.length).fill(0);\n\n    for (let i = 1; i < n; i++) {\n        let minVal = Number.MAX_SAFE_INTEGER;\n\n        for (let j = 0; j < primes.length; j++)\n            minVal = Math.min(minVal, ugly[indices[j]] * primes[j]);\n\n        ugly[i] = minVal;\n\n        for (let j = 0; j < primes.length; j++)\n            if (ugly[i] == ugly[indices[j]] * primes[j])\n                indices[j]++;\n    }\n\n    return ugly[n - 1];\n}\n",
            "explanation": "The algorithm uses dynamic programming to find the nth super ugly number. We first create an `ugly` array of size `n`, where `ugly[i]` will store the (i+1)th super ugly number. We initialize `ugly[0]` as 1, since 1 is always a super ugly number.\n\nMaintain an `indices` array of size `primes.length`, initialized with zeros. Each element `indices[j]` represents the index of the next super ugly number to multiply by `primes[j]`.\n\nFor each `i` from 1 to n, we calculate `ugly[i]` as the minimum of `ugly[indices[j]] * primes[j]` for all `j`. Then we increment the index `indices[j]` for which the condition `ugly[i] == ugly[indices[j]] * primes[j]` holds.\n\nFinally, we return the last element of the `ugly` array, which is the nth super ugly number."
        },
        "structure": {
            "c++": "int nthSuperUglyNumber(int n, vector<int>& primes)  {\n    // Your code here\n}\n",
            "java": "public int nthSuperUglyNumber(int n, int[] primes)  {\n    // Your code here\n}\n",
            "python": "def nthSuperUglyNumber(n, primes):\n    # Your code here\n\n",
            "javascript": "function nthSuperUglyNumber(n, primes)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    vector<int> primes = {2, 3, 5};\n    int result = nthSuperUglyNumber(n, primes);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int nthSuperUglyNumber(int n, int[] primes) {\n    int[] ugly = new int[n];\n    ugly[0] = 1;\n    int[] indices = new int[primes.length];\n\n    for (int i = 1; i < n; i++) {\n        int minVal = Integer.MAX_VALUE;\n\n        for (int j = 0; j < primes.length; j++)\n            minVal = Math.min(minVal, ugly[indices[j]] * primes[j]);\n\n        ugly[i] = minVal;\n\n        for (int j = 0; j < primes.length; j++)\n            if (ugly[i] == ugly[indices[j]] * primes[j])\n                indices[j]++;\n    }\n\n    return ugly[n - 1];\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    n = inputs[0]\n    primes = inputs[1]\n    result = nthSuperUglyNumber(n, primes)\n    print(result)",
            "javascript": "function nthSuperUglyNumber(n, primes) {\n    let ugly = new Array(n);\n    ugly[0] = 1;\n    let indices = new Array(primes.length).fill(0);\n\n    for (let i = 1; i < n; i++) {\n        let minVal = Number.MAX_SAFE_INTEGER;\n\n        for (let j = 0; j < primes.length; j++)\n            minVal = Math.min(minVal, ugly[indices[j]] * primes[j]);\n\n        ugly[i] = minVal;\n\n        for (let j = 0; j < primes.length; j++)\n            if (ugly[i] == ugly[indices[j]] * primes[j])\n                indices[j]++;\n    }\n\n    return ugly[n - 1];\n}"
        },
        "Qid": "313"
    },
    {
        "_id": {
            "$oid": "661e936a555605d7c12757fc"
        },
        "title": "Smallest Subsequence of Distinct Characters",
        "description": "Given a string `s`, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.",
        "example": "Example:\n\nInput: s = \"bcabc\"\nOutput: \"abc\"\n\nInput: s = \"cbacdcbc\"\nOutput: \"acdb\"",
        "level": "Medium",
        "tags": [
            "string",
            "greedy"
        ],
        "test_cases": {
            "inputs": [
                "\"bcabc\"",
                "\"cbacdcbc\"",
                "\"leetcode\"",
                "\"aabbbccc\"",
                "\"abcde\"",
                "\"aaaaa\"",
                "\"zyxwvu\"",
                "\"dcba\"",
                "\"hello\"",
                "\"world\"",
                "\"programming\"",
                "\"coding\"",
                "\"algorithm\"",
                "\"leetcode\"",
                "\"python\"",
                "\"java\"",
                "\"javascript\"",
                "\"ruby\"",
                "\"c++\"",
                "\"html\"",
                "\"css\""
            ],
            "outputs": [
                "\"abc\"",
                "\"acdb\"",
                "\"code\"",
                "\"abc\"",
                "\"abcde\"",
                "\"a\"",
                "\"yxwvu\"",
                "\"abcd\"",
                "\"helo\"",
                "\"dlr\"",
                "\"agm\"",
                "\"cdi\"",
                "\"ahilortm\"",
                "\"ceodpy\"",
                "\"ajpv\"",
                "\"acijrstv\"",
                "\"bry\"",
                "\"c++\"",
                "\"ch\"",
                "\"css\""
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nstring removeDuplicateLetters(string s) {\n    vector<int> count(256, 0);\n    vector<bool> visited(256, false);\n    stack<char> st;\n    \n    for (char ch : s) {\n        count[ch]++;\n    }\n    \n    for (char ch : s) {\n        count[ch]--;\n        if (visited[ch]) continue;\n        while (!st.empty() && ch < st.top() && count[st.top()] > 0) {\n            visited[st.top()] = false;\n            st.pop();\n        }\n        st.push(ch);\n        visited[ch] = true;\n    }\n    \n    string result = \"\";\n    while (!st.empty()) {\n        result = st.top() + result;\n        st.pop();\n    }\n    return result;\n}\n",
            "java": "import java.util.*;\n\npublic class Solution {\n    public String removeDuplicateLetters(String s) {\n        int[] count = new int[256];\n        boolean[] visited = new boolean[256];\n        Stack<Character> st = new Stack<>();\n        \n        for (char ch : s.toCharArray()) {\n            count[ch]++;\n        }\n        \n        for (char ch : s.toCharArray()) {\n            count[ch]--;\n            if (visited[ch]) continue;\n            while (!st.isEmpty() && ch < st.peek() && count[st.peek()] > 0) {\n                visited[st.pop()] = false;\n            }\n            st.push(ch);\n            visited[ch] = true;\n        }\n        \n        StringBuilder result = new StringBuilder();\n        while (!st.empty()) {\n            result.append(st.pop());\n        }\n        return result.reverse().toString();\n    }\n}\n",
            "python": "def removeDuplicateLetters(s):\n    count = [0] * 256\n    visited = [False] * 256\n    st = []\n\n    for ch in s:\n        count[ord(ch)] += 1\n\n    for ch in s:\n        count[ord(ch)] -= 1\n        if visited[ord(ch)]:\n            continue\n        while st and ch < st[-1] and count[ord(st[-1])] > 0:\n            visited[ord(st.pop())] = False\n        st.append(ch)\n        visited[ord(ch)] = True\n\n    return \"\".join(st)   \n",
            "javascript": "function removeDuplicateLetters(s) {\n    let count = new Array(256).fill(0);\n    let visited = new Array(256).fill(false);\n    let st = [];\n    \n    for (let ch of s) {\n        count[ch.charCodeAt(0)]++;\n    }\n    \n    for (let ch of s) {\n        count[ch.charCodeAt(0)]--;\n        if (visited[ch.charCodeAt(0)]) continue;\n        while (st.length > 0 && ch < st[st.length - 1] && count[st[st.length - 1].charCodeAt(0)] > 0) {\n            visited[st.pop().charCodeAt(0)] = false;\n        }\n        st.push(ch);\n        visited[ch.charCodeAt(0)] = true;\n    }\n\n    return st.join(\"\");\n}\n",
            "explanation": "1. Initialize count and visited arrays. We will use count to track the occurrences of each character in the string and visited to mark if a character has been pushed into the result.\n2. Iterate through the string, count the occurrences of each character.\n3. Iterate through the string again, decrease the count of the current character.\n4. If the current character is visited, continue.\n5. While the stack is not empty, the current character is smaller than the top character on stack, and the count of the top character is greater than 0, set the visited of the top character to false and pop the character from the stack.\n6. Push the current character onto the stack, and set visited to true.\n7. Build the result string from the stack.\n8. Return the result string."
        },
        "structure": {
            "c++": "#include <string>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nstring removeDuplicateLetters(string s)  {\n    // Your code here\n}\n",
            "java": "i {mport java.util.*;\n\npublic class Solution \n    // Your code here\n}\n",
            "python": "def removeDuplicateLetters(s):\n    # Your code here\n\n",
            "javascript": "function removeDuplicateLetters(s)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nstring removeDuplicateLetters(string s) {\n    vector<int> count(256, 0);\n    vector<bool> visited(256, false);\n    stack<char> st;\n    \n    for (char ch : s) {\n        count[ch]++;\n    }\n    \n    for (char ch : s) {\n        count[ch]--;\n        if (visited[ch]) continue;\n        while (!st.empty() && ch < st.top() && count[st.top()] > 0) {\n            visited[st.top()] = false;\n            st.pop();\n        }\n        st.push(ch);\n        visited[ch] = true;\n    }\n    \n    string result = \"\";\n    while (!st.empty()) {\n        result = st.top() + result;\n        st.pop();\n    }\n    return result;\n}\n\nint main() {\n    string s = $args;\n    string result = removeDuplicateLetters(s);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public String removeDuplicateLetters(String s) {\n        int[] count = new int[256];\n        boolean[] visited = new boolean[256];\n        Stack<Character> st = new Stack<>();\n        \n        for (char ch : s.toCharArray()) {\n            count[ch]++;\n        }\n        \n        for (char ch : s.toCharArray()) {\n            count[ch]--;\n            if (visited[ch]) continue;\n            while (!st.isEmpty() && ch < st.peek() && count[st.peek()] > 0) {\n                visited[st.pop()] = false;\n            }\n            st.push(ch);\n            visited[ch] = true;\n        }\n        \n        StringBuilder result = new StringBuilder();\n        while (!st.empty()) {\n            result.append(st.pop());\n        }\n        return result.reverse().toString();\n    }",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = removeDuplicateLetters(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = removeDuplicateLetters(s);\n    console.log(result);\n}"
        },
        "Qid": "316"
    },
    {
        "_id": {
            "$oid": "661e9562555605d7c12757fd"
        },
        "title": "Bulb Switcher",
        "description": "There are `n` bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the `ith` round, you toggle every `i` bulb. For the `nth` round, you only toggle the last bulb. Return the number of bulbs that are on after `n` rounds.",
        "example": "Example:\n\nInput: n = 3\nOutput: 1\nExplanation: At first, the three bulbs are [off, off, off]. After the first round, the three bulbs are [on, on, on]. After the second round, the three bulbs are [on, off, on]. After the third round, the three bulbs are [on, off, off]. So you should return 1 because there is only one bulb is on.",
        "level": "Easy",
        "tags": [
            "math",
            "number theory"
        ],
        "test_cases": {
            "inputs": [
                0,
                1,
                2,
                3,
                5,
                10,
                100
            ],
            "outputs": [
                0,
                1,
                1,
                1,
                2,
                3,
                10
            ]
        },
        "sample_code": {
            "c++": "int bulbSwitch(int n) {\n    return sqrt(n);\n}\n",
            "java": "public int bulbSwitch(int n) {\n    return (int)Math.sqrt(n);\n}\n",
            "python": "def bulbSwitch(n):\n    return int(n**0.5)\n",
            "javascript": "function bulbSwitch(n) {\n    return Math.floor(Math.sqrt(n));\n}\n",
            "explanation": "Initially, all the bulbs are off. When a bulb is toggled odd number of times, it remains on; otherwise, it remains off. So, we need to figure out how many bulbs have an odd number of toggles after N rounds.\n\nA bulb has a toggle every time one of its divisors is encountered during the rounds. For example, bulb 6 will have toggles during round 1, round 2, round 3, and round 6. Its divisors are 1, 2, 3, and 6. In general, numbers have an even number of divisors. However, square numbers have an odd number of divisors, because their square root divisor gets counted only once. For example, for number 9, there are divisors 1, 3, and 9, and the square root divisor 3 is counted only once.\n\nSince only square numbers have an odd number of divisors (and therefore odd number of toggles), we only need to count the number of square numbers less than or equal to n. In order to do this, we can simply take the square root of n and round it down to the nearest integer, as the function does in each language."
        },
        "structure": {
            "c++": "int bulbSwitch(int n)  {\n    // Your code here\n}\n",
            "java": "public int bulbSwitch(int n)  {\n    // Your code here\n}\n",
            "python": "def bulbSwitch(n):\n    # Your code here\n\n",
            "javascript": "function bulbSwitch(n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = bulbSwitch(n);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = bulbSwitch(n)\n    print(result)",
            "java": "",
            "javascript": ""
        },
        "Qid": "319"
    },
    {
        "_id": {
            "$oid": "661e9869555605d7c12757fe"
        },
        "title": "Maximum Number from Two Arrays",
        "description": "You are given two integer arrays `nums1` and `nums2` of lengths `m` and `n` respectively. `nums1` and `nums2` represent the digits of two numbers. You are also given an integer `k`. Create the maximum number of length `k <= m + n` from digits of the two numbers. The relative order of the digits from the same array must be preserved. Return an array of the `k` digits representing the answer.",
        "example": "Example:\n\nInput: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5\nOutput: [9,8,6,5,3]\n\nExplanation: The maximum number of length 5 that can be created from the digits of nums1 and nums2 is [9,8,6,5,3].",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        3,
                        4,
                        6,
                        5
                    ],
                    [
                        9,
                        1,
                        2,
                        5,
                        8,
                        3
                    ],
                    5
                ],
                [
                    [
                        6,
                        7
                    ],
                    [
                        6,
                        0,
                        4
                    ],
                    5
                ],
                [
                    [
                        3,
                        9
                    ],
                    [
                        8,
                        9
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9
                    ],
                    9
                ],
                [
                    [
                        0,
                        0,
                        0,
                        0
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    5
                ],
                [
                    [
                        9,
                        8,
                        7,
                        6,
                        5
                    ],
                    [
                        4,
                        3,
                        2,
                        1
                    ],
                    8
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        5,
                        4,
                        3,
                        2,
                        1
                    ],
                    10
                ],
                [
                    [
                        9,
                        9,
                        9,
                        9,
                        9
                    ],
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9
                    ],
                    1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9
                    ],
                    0
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9
                    ],
                    6
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9
                    ],
                    7
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9
                    ],
                    8
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9
                    ],
                    9
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9
                    ],
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9
                    ],
                    11
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9
                    ],
                    12
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9
                    ],
                    13
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9
                    ],
                    14
                ]
            ],
            "outputs": [
                [
                    9,
                    8,
                    6,
                    5,
                    3
                ],
                [
                    6,
                    7,
                    6,
                    0,
                    4
                ],
                [
                    9,
                    8,
                    9
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    1
                ],
                [
                    9,
                    9,
                    9,
                    9,
                    9,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    5,
                    4,
                    3
                ],
                [
                    9
                ],
                [],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    1
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    1,
                    1
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ]
            ]
        },
        "sample_code": {
            "c++": "\r\n```cpp\r\n#include <vector>\r\n#include <algorithm>\r\n\r\nstd::vector<int> maxNumber(std::vector<int>& nums1, std::vector<int>& nums2, int k) {\r\n    int m = nums1.size(), n = nums2.size();\r\n    std::vector<int> ans(k, 0);\r\n    for (int i = std::max(0, k - n); i <= k && i <= m; ++i) {\r\n        std::vector<int> candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);\r\n        if (greater(candidate, 0, ans, 0)) ans = candidate;\r\n    }\r\n    return ans;\r\n}\r\n\r\nstd::vector<int> maxArray(std::vector<int>& nums, int k) {\r\n    int n = nums.size();\r\n    std::vector<int> ans(k, 0);\r\n    for (int i = 0, j = 0; i < n; ++i) {\r\n        while (n - i > k - j && j > 0 && ans[j - 1] < nums[i]) j--;\r\n        if (j < k) ans[j++] = nums[i];\r\n    }\r\n    return ans;\r\n}\r\n\r\nstd::vector<int> merge(std::vector<int>& nums1, std::vector<int>& nums2, int k) {\r\n    std::vector<int> ans(k, 0);\r\n    for (int i = 0, j = 0, r = 0; r < k; ++r)\r\n        ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\r\n    return ans;\r\n}\r\n\r\nbool greater(std::vector<int>& nums1, int i, std::vector<int>& nums2, int j) {\r\n    while (i < nums1.size() && j < nums2.size() && nums1[i] == nums2[j]) {\r\n        i++;\r\n        j++;\r\n    }\r\n    return j == nums2.size() || (i < nums1.size() && nums1[i] > nums2[j]);\r\n}\r\n```\r\n\r\n",
            "java": "\r\n```java\r\npublic int[] maxNumber(int[] nums1, int[] nums2, int k) {\r\n    int[] ans = new int[k];\r\n    int m = nums1.length, n = nums2.length;\r\n    \r\n    for (int i = Math.max(0, k - n); i <= k && i <= m; i++) {\r\n        int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);\r\n        if (greater(candidate, 0, ans, 0)) ans = candidate;\r\n    }\r\n    return ans;\r\n}\r\n\r\nprivate int[] maxArray(int[] nums, int k) {\r\n    int n = nums.length;\r\n    int[] ans = new int[k];\r\n    for (int i = 0, j = 0; i < n; i++) {\r\n        while (n - i > k - j && j > 0 && ans[j - 1] < nums[i]) j--;\r\n        if (j < k) ans[j++] = nums[i];\r\n    }\r\n    return ans;\r\n}\r\n\r\nprivate int[] merge(int[] nums1, int[] nums2, int k) {\r\n    int[] ans = new int[k];\r\n    for (int i = 0, j = 0, r = 0; r < k; r++)\r\n        ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\r\n    return ans;\r\n}\r\n\r\nprivate boolean greater(int[] nums1, int i, int[] nums2, int j) {\r\n    while (i < nums1.length && j < nums2.length && nums1[i] == nums2[j]) {\r\n        i++;\r\n        j++;\r\n    }\r\n    return j == nums2.length || (i < nums1.length && nums1[i] > nums2[j]);\r\n}\r\n```\r\n\r\n",
            "javascript": "\r\n```python\r\ndef maxNumber(nums1, nums2, k):\r\n    def maxArray(nums, k):\r\n        ans = []\r\n        for i, num in enumerate(nums):\r\n            while len(ans) + len(nums) - i > k and ans and ans[-1] < num:\r\n                ans.pop()\r\n            if len(ans) < k:\r\n                ans.append(num)\r\n        return ans\r\n\r\n    def merge(nums1, nums2):\r\n        return [max(nums1, nums2).pop(0) for _ in nums1 + nums2]\r\n\r\n    return max(merge(maxArray(nums1, i), maxArray(nums2, k - i))\r\n               for i in range(k + 1)\r\n               if i <= len(nums1) and k - i <= len(nums2))\r\n```\r\n\r\n",
            "python": "def maxNumber(nums1, nums2, k):\n    def maxArray(nums, k):\n        ans = []\n        for i in range(len(nums)):\n            while len(nums) - i > k - len(ans) and ans and ans[-1] < nums[i]:\n                ans.pop()\n            if len(ans) < k:\n                ans.append(nums[i])\n        return ans\n\n    def merge(nums1, nums2):\n        ans = []\n        i, j = 0, 0\n        while i < len(nums1) or j < len(nums2):\n            if (nums1[i:] >= nums2[j:]) if nums1[i:] else False:\n                ans.append(nums1[i])\n                i += 1\n            else:\n                ans.append(nums2[j])\n                j += 1\n        return ans\n\n    result = []\n    for i in range(max(0, k - len(nums2)), min(k, len(nums1)) + 1):\n        candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i))\n        if candidate > result:\n            result = candidate\n\n    return result\n",
            "explanation": "\r\nThe algorithm works by first finding the maximum subsequence of the required length from each input array while retaining their relative order. It then iterates through all possible combinations of subsequences of the two arrays (nums1 and nums2) with lengths summing to k, and merges them while preserving their element's relative order. During the merge, the algorithm always selects the maximum elements from the two arrays, giving preference to the first array if both elements are equal. Finally, the maximum array of length k is returned. \r"
        },
        "structure": {
            "c++": "\r\n```cpp\r\n#include <vector>\r\n#include <algorithm>\r\n\r\nstd::vector<int> maxNumber(std::vector<int>& nums1, std::vector<int>& nums2, int k)  {\n    // Your code here\n}\r\n```\r\n\r\n",
            "java": "\r\n```java\r\npublic int[] maxNumber(int[] nums1, int[] nums2, int k)  {\n    // Your code here\n}\r\n```\r\n\r\n",
            "javascript": "\r\n```python\r\ndef maxNumber(nums1, nums2, k): {\r\n    def maxArray(nums, k):\r\n        ans = []\r\n        for i, num in enumerate(nums):\r\n            while len(ans) + len(nums) - i > k and ans and ans[-1] < num:\r\n                ans.pop()\r\n            if len(ans) < k:\r\n                ans.append(num)\r\n        return ans\r\n\r\n    def merge(nums1, nums2):\r\n        return [max(nums1, nums2).pop(0) for _ in nums1 + nums2]\r\n\r\n    return max(merge(maxArray(nums1, i), maxArray(nums2, k - i))\r\n               for i in range(k + 1)\r\n               if i <= len(nums1) and k - i <= len(nums2))\r\n```\r\n\r\n    // Your code here\n\n",
            "python": "\r\n    # Your code here\n\n"
        },
        "call_functions": {
            "c++": "std::vector<int> maxNumber(std::vector<int>& nums1, std::vector<int>& nums2, int k) {\n    int m = nums1.size(), n = nums2.size();\n    std::vector<int> ans(k, 0);\n    for (int i = std::max(0, k - n); i <= k && i <= m; ++i) {\n        std::vector<int> candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);\n        if (greater(candidate, 0, ans, 0)) ans = candidate;\n    }\n    return ans;\n}\n\nstd::vector<int> maxArray(std::vector<int>& nums, int k) {\n    int n = nums.size();\n    std::vector<int> ans(k, 0);\n    for (int i = 0, j = 0; i < n; ++i) {\n        while (n - i > k - j && j > 0 && ans[j - 1] < nums[i]) j--;\n        if (j < k) ans[j++] = nums[i];\n    }\n    return ans;\n}\n\nstd::vector<int> merge(std::vector<int>& nums1, std::vector<int>& nums2, int k) {\n    std::vector<int> ans(k, 0);\n    for (int i = 0, j = 0, r = 0; r < k; ++r)\n        ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\n    return ans;\n}\n\nbool greater(std::vector<int>& nums1, int i, std::vector<int>& nums2, int j) {\n    while (i < nums1.size() && j < nums2.size() && nums1[i] == nums2[j]) {\n        i++;\n        j++;\n    }\n    return j == nums2.size() || (i < nums1.size() && nums1[i] > nums2[j]);\n}",
            "java": "public int[] maxNumber(int[] nums1, int[] nums2, int k) {\n    int[] ans = new int[k];\n    int m = nums1.length, n = nums2.length;\n    \n    for (int i = Math.max(0, k - n); i <= k && i <= m; i++) {\n        int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);\n        if (greater(candidate, 0, ans, 0)) ans = candidate;\n    }\n    return ans;\n}\n\nprivate int[] maxArray(int[] nums, int k) {\n    int n = nums.length;\n    int[] ans = new int[k];\n    for (int i = 0, j = 0; i < n; i++) {\n        while (n - i > k - j && j > 0 && ans[j - 1] < nums[i]) j--;\n        if (j < k) ans[j++] = nums[i];\n    }\n    return ans;\n}\n\nprivate int[] merge(int[] nums1, int[] nums2, int k) {\n    int[] ans = new int[k];\n    for (int i = 0, j = 0, r = 0; r < k; r++)\n        ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\n    return ans;\n}\n\nprivate boolean greater(int[] nums1, int i, int[] nums2, int j) {\n    while (i < nums1.length && j < nums2.length && nums1[i] == nums2[j]) {\n        i++;\n        j++;\n    }\n    return j == nums2.length || (i < nums1.length && nums1[i] > nums2[j]);\n}",
            "javascript": "def main():\n    nums1 = $args[0]\n    nums2 = $args[1]\n    k = $args[2]\n    \n    def maxArray(nums, k):\n        ans = []\n        for i, num in enumerate(nums):\n            while len(ans) + len(nums) - i > k and ans and ans[-1] < num:\n                ans.pop()\n            if len(ans) < k:\n                ans.append(num)\n        return ans\n\n    def merge(nums1, nums2):\n        return [max(nums1, nums2).pop(0) for _ in nums1 + nums2]\n\n    result = max(merge(maxArray(nums1, i), maxArray(nums2, k - i))\n               for i in range(k + 1)\n               if i <= len(nums1) and k - i <= len(nums2))\n    print(result)\n\nmain()",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    nums1 = inputs[0]\n    nums2 = inputs[1]\n    k = inputs[2]\n    result = maxNumber(nums1, nums2, k)\n    print(result)"
        },
        "Qid": "321"
    },
    {
        "_id": {
            "$oid": "661e996c555605d7c12757ff"
        },
        "title": "Number of Connected Components in a Graph",
        "description": "You have a graph of `n` nodes. You are given an integer `n` and an array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between `ai` and `bi` in the graph. Your task is to return the number of connected components in the graph.",
        "example": "Example:\n\nInput: n = 5, edges = [[0,1],[1,2],[3,4]]\nOutput: 2\n\nExplanation: In this example, there are two connected components: [0, 1, 2] and [3, 4].\n\nInput: n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]\nOutput: 1\n\nExplanation: In this example, all nodes are connected and form a single connected component.",
        "level": "Medium",
        "tags": [
            "Graph",
            "Connected Components"
        ],
        "test_cases": {
            "inputs": [
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            4
                        ]
                    ]
                ],
                [
                    3,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ]
                    ]
                ],
                [
                    4,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            2,
                            3
                        ]
                    ]
                ],
                [
                    6,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            5
                        ]
                    ]
                ],
                [
                    7,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            5
                        ],
                        [
                            5,
                            6
                        ]
                    ]
                ],
                [
                    8,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            5
                        ],
                        [
                            5,
                            6
                        ],
                        [
                            6,
                            7
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            0
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            1
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            2
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            3
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            1,
                            3
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            1,
                            4
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            2,
                            4
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            3,
                            4
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            0,
                            2
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            0,
                            3
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            0,
                            4
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            0,
                            1
                        ]
                    ]
                ],
                [
                    5,
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            4,
                            0
                        ],
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            2
                        ]
                    ]
                ]
            ],
            "outputs": [
                2,
                1,
                1,
                2,
                2,
                2,
                2,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nint countComponents(int n, std::vector<std::vector<int>>& edges) {\n    std::vector<std::vector<int>> adjList(n);\n    for (const auto& edge : edges) {\n        adjList[edge[0]].push_back(edge[1]);\n        adjList[edge[1]].push_back(edge[0]);\n    }\n    \n    std::vector<bool> visited(n, false);\n    int connectedComponents = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            std::function<void(int)> dfs = [&](int node) {\n                visited[node] = true;\n                for (int neighbor : adjList[node]) {\n                    if (!visited[neighbor]) {\n                        dfs(neighbor);\n                    }\n                }\n            };\n            dfs(i);\n            connectedComponents++;\n        }\n    }\n    return connectedComponents;\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic int countComponents(int n, int[][] edges) {\n    List<List<Integer>> adjList = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        adjList.add(new ArrayList<>());\n    }\n    for (int[] edge : edges) {\n        adjList.get(edge[0]).add(edge[1]);\n        adjList.get(edge[1]).add(edge[0]);\n    }\n\n    boolean[] visited = new boolean[n];\n    int connectedComponents = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(i, visited, adjList);\n            connectedComponents++;\n        }\n    }\n    return connectedComponents;\n}\n\nvoid dfs(int node, boolean[] visited, List<List<Integer>> adjList) {\n    visited[node] = true;\n    for (int neighbor : adjList.get(node)) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, visited, adjList);\n        }\n    }\n}\n\n",
            "python": "def countComponents(n, edges):\n    adj_list = [[] for _ in range(n)]\n    for edge in edges:\n        adj_list[edge[0]].append(edge[1])\n        adj_list[edge[1]].append(edge[0])\n\n    visited = [False] * n\n    connected_components = 0\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            connected_components += 1\n\n    return connected_components\n\n",
            "javascript": "function countComponents(n, edges) {\n    const adjList = new Array(n).fill(0).map(() => []);\n    for (const edge of edges) {\n        adjList[edge[0]].push(edge[1]);\n        adjList[edge[1]].push(edge[0]);\n    }\n\n    const visited = new Array(n).fill(false);\n    let connectedComponents = 0;\n\n    function dfs(node) {\n        visited[node] = true;\n        for (const neighbor of adjList[node]) {\n            if (!visited[neighbor]) {\n                dfs(neighbor);\n            }\n        }\n    }\n\n    for (let i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(i);\n            connectedComponents++;\n        }\n    }\n    return connectedComponents;\n}\n\n",
            "explanation": "The algorithm used to solve this problem is the standard Depth First Search (DFS) on an undirected graph. The number of connected components is incremented each time a new unvisited node is found. The algorithm performs the following steps:\n\n1. Create an adjacency list representation of the graph.\n2. Initialize a visited array to mark visited nodes.\n3. Initialize a count variable for connected components.\n4. Iterate over all the nodes in the graph:\n   a. If a node is not visited, perform DFS on the node and increment the count of connected components.\n   b. In DFS, mark the node as visited and recursively perform DFS on its adjacent nodes if they have not been visited.\n5. Return the count of connected components."
        },
        "structure": {
            "c++": "#include <vector>\n\nint countComponents(int n, std::vector<std::vector<int>>& edges)  {\n    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic int countComponents(int n, int[][] edges)  {\n    // Your code here\n}\n\n",
            "python": "def countComponents(n, edges):\n    # Your code here\n\n",
            "javascript": "function countComponents(n, edges)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nint main() {\n    int n = $args;\n    std::vector<std::vector<int>> edges = { {0, 1}, {1, 2}, {3, 4} }; // Example input\n    int result = countComponents(n, edges);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public int countComponents(int n, int[][] edges) {\n    List<List<Integer>> adjList = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        adjList.add(new ArrayList<>());\n    }\n    for (int[] edge : edges) {\n        adjList.get(edge[0]).add(edge[1]);\n        adjList.get(edge[1]).add(edge[0]);\n    }\n\n    boolean[] visited = new boolean[n];\n    int connectedComponents = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(i, visited, adjList);\n            connectedComponents++;\n        }\n    }\n    return connectedComponents;\n}\n\nvoid dfs(int node, boolean[] visited, List<List<Integer>> adjList) {\n    visited[node] = true;\n    for (int neighbor : adjList.get(node)) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, visited, adjList);\n        }\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    n = inputs[0]\n    edges = inputs[1]\n    result = countComponents(n, edges)\n    print(result)",
            "javascript": "function main() {\n    const n = $args[0];\n    const edges = $args[1];\n    const result = countComponents(n, edges);\n    console.log(result);\n}"
        },
        "Qid": "323"
    },
    {
        "_id": {
            "$oid": "661e999d555605d7c1275800"
        },
        "title": "Power of Three",
        "description": "Given an integer `n`, determine if it is a power of three. Return `true` if `n` is a power of three, otherwise return `false`.",
        "example": "Example 1:\n\nInput: n = 27\nOutput: true\nExplanation: 27 = 3^3\n\nExample 2:\n\nInput: n = 0\nOutput: false\nExplanation: 0 is not a power of three\n\nExample 3:\n\nInput: n = -1\nOutput: false\nExplanation: -1 is not a power of three",
        "level": "Easy",
        "tags": [
            "math",
            "number theory"
        ],
        "test_cases": {
            "inputs": [
                27,
                0,
                -1,
                1,
                9,
                45,
                81,
                243,
                729,
                19683,
                59049,
                177147,
                531441,
                1594323,
                4782969,
                14348907,
                43046721,
                129140163,
                387420489,
                1162261467
            ],
            "outputs": [
                true,
                false,
                false,
                true,
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "bool isPowerOfThree(int n) {\n    if (n < 1) {\n        return false;\n    }\n    \n    while (n % 3 == 0) {\n        n /= 3;\n    }\n    \n    return n == 1;\n}\n",
            "java": "public boolean isPowerOfThree(int n) {\n    if (n < 1) {\n        return false;\n    }\n    \n    while (n % 3 == 0) {\n        n /= 3;\n    }\n    \n    return n == 1;\n}\n",
            "python": "def is_power_of_three(n: int) -> bool:\n    if n < 1:\n        return False\n    \n    while n % 3 == 0:\n        n //= 3\n    \n    return n == 1\n",
            "javascript": "function isPowerOfThree(n) {\n    if (n < 1) {\n        return false;\n    }\n    \n    while (n % 3 === 0) {\n        n /= 3;\n    }\n    \n    return n === 1;\n}\n",
            "explanation": "The solution checks if the given number, n, is a power of three as follows:\n\n1. If n is less than 1, return false because powers of 3 are positive integers.\n2. Use a while loop, and keep dividing n by 3 while n is divisible by 3 without a remainder.\n3. After the loop, check if n is equal to 1. If n is 1, it means the original n was a power of 3; otherwise, it was not a power of 3. Return the result accordingly."
        },
        "structure": {
            "c++": "bool isPowerOfThree(int n)  {\n    // Your code here\n}\n",
            "java": "public boolean isPowerOfThree(int n)  {\n    // Your code here\n}\n",
            "python": "def is_power_of_three(n: int) -> bool:\n    # Your code here\n\n",
            "javascript": "function isPowerOfThree(n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n = $args;\n    bool result = isPowerOfThree(n);\n    cout << boolalpha << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    int n = $args;\n    boolean result = isPowerOfThree(n);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = is_power_of_three(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = isPowerOfThree(n);\n    console.log(result);\n}"
        },
        "Qid": "326"
    },
    {
        "_id": {
            "$oid": "661e99cc555605d7c1275801"
        },
        "title": "Range Sum Count",
        "description": "Given an integer array `nums` and two integers `lower` and `upper`, return the number of range sums that lie in `[lower, upper]` inclusive.\n\nRange sum `S(i, j)` is defined as the sum of the elements in `nums` between indices `i` and `j` inclusive, where `i <= j`.",
        "example": "Example:\n\nInput: nums = [-2,5,-1], lower = -2, upper = 2\nOutput: 3\nExplanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.",
        "level": "Medium",
        "tags": [
            "array",
            "prefix sum",
            "binary search"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        -2,
                        5,
                        -1
                    ],
                    -2,
                    2
                ],
                [
                    [
                        0
                    ],
                    0,
                    0
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    5,
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    0,
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    -10,
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    -10,
                    -5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    15,
                    20
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    0,
                    0
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    6,
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    -10,
                    -5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    -10,
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    0,
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    5,
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    -10,
                    -5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    -10,
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    0,
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    5,
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    -10,
                    -5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    -10,
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    0,
                    10
                ]
            ],
            "outputs": [
                3,
                1,
                0,
                15,
                15,
                0,
                0,
                0,
                0,
                0,
                15,
                15,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "int countRangeSum(vector<int>& nums, int lower, int upper) {\n    int n = nums.size();\n    vector<long> sums(n + 1, 0);\n    for (int i = 0; i < n; ++i)\n        sums[i + 1] = sums[i] + nums[i];\n\n    function<int(int, int)> mergeSort = [&](int start, int end) {\n        if (start == end)\n            return 0;\n        int mid = start + (end - start) / 2;\n        int count = mergeSort(start, mid) + mergeSort(mid + 1, end);\n\n        int j = mid + 1, k = mid + 1;\n        for (int i = start; i <= mid; ++i) {\n            while (j <= end && sums[j] - sums[i] < lower) ++j;\n            while (k <= end && sums[k] - sums[i] <= upper) ++k;\n            count += k - j;\n        }\n\n        inplace_merge(sums.begin() + start, sums.begin() + mid + 1, sums.begin() + end + 1);\n        return count;\n    };\n\n    return mergeSort(0, n);\n}\n",
            "java": "public int countRangeSum(int[] nums, int lower, int upper) {\n    long[] sums = new long[nums.length + 1];\n    for (int i = 0; i < nums.length; ++i)\n        sums[i + 1] = sums[i] + nums[i];\n\n    return countWhileMergeSort(sums, lower, upper, 0, nums.length);\n}\n\nprivate int countWhileMergeSort(long[] sums, int lower, int upper, int start, int end) {\n    if (start >= end)\n        return 0;\n\n    int mid = start + (end - start) / 2;\n    int count = countWhileMergeSort(sums, lower, upper, start, mid) + countWhileMergeSort(sums, lower, upper, mid + 1, end);\n\n    int j = mid + 1, k = mid + 1;\n    for (int i = start; i <= mid; ++i) {\n        while (j <= end && sums[j] - sums[i] < lower) ++j;\n        while (k <= end && sums[k] - sums[i] <= upper) ++k;\n        count += k - j;\n    }\n\n    Arrays.sort(sums, start, end + 1);\n    return count;\n}\n",
            "python": "def countRangeSum(nums, lower, upper):\n    sums = [0] * (len(nums) + 1)\n    for i in range(len(nums)):\n        sums[i + 1] = sums[i] + nums[i]\n\n    def mergeSort(start, end):\n        if start == end:\n            return 0\n        mid = start + (end - start) // 2\n        count = mergeSort(start, mid) + mergeSort(mid + 1, end)\n\n        j, k = mid + 1, mid + 1\n        for i in range(start, mid + 1):\n            while j <= end and sums[j] - sums[i] < lower: j += 1\n            while k <= end and sums[k] - sums[i] <= upper: k += 1\n            count += k - j\n\n        sums[start:end + 1] = sorted(sums[start:end + 1])\n        return count\n\n    return mergeSort(0, len(nums))\n",
            "javascript": "function countRangeSum(nums, lower, upper) {\n    let sums = new Array(nums.length + 1).fill(0);\n    for (let i = 0; i < nums.length; ++i)\n        sums[i + 1] = sums[i] + nums[i];\n\n    function mergeSort(start, end) {\n        if (start === end)\n            return 0;\n        let mid = start + Math.floor((end - start) / 2);\n        let count = mergeSort(start, mid) + mergeSort(mid + 1, end);\n\n        let j = mid + 1, k = mid + 1;\n        for (let i = start; i <= mid; ++i) {\n            while (j <= end && sums[j] - sums[i] < lower) ++j;\n            while (k <= end && sums[k] - sums[i] <= upper) ++k;\n            count += k - j;\n        }\n\n        let sortedPart = sums.slice(start, end + 1).sort((a, b) => a - b);\n        for (let i = start; i <= end; ++i) {\n            sums[i] = sortedPart[i - start];\n        }\n\n        return count;\n    };\n\n    return mergeSort(0, nums.length);\n}\n\n",
            "explanation": "The algorithm is based on the divide-and-conquer strategy. First, we calculate the cumulative sums of the input array. Then, we apply a modified merge-sort function to count the number of range sums that lie in the [lower, upper] interval.\n\nDuring the merge-sort, for each subarray from index i to mid, we find the first `j` and the first `k` that meet the following conditions:\n- `sums[j] - sums[i] >= lower`, and\n- `sums[k] - sums[i] > upper`.\n\nThe number of range sums in this subarray that lie in the [lower, upper] interval is `k - j`. We add this count to the result.\n\nFinally, we merge the sorted partitions of the subarray.\n\nThis process is repeated recursively for all subarrays until only one element remains. At the end, the function should return the total count of range sums that lie in the [lower, upper] interval."
        },
        "structure": {
            "c++": "int countRangeSum(vector<int>& nums, int lower, int upper)  {\n    // Your code here\n}\n",
            "java": "public int countRangeSum(int[] nums, int lower, int upper)  {\n    // Your code here\n}\n",
            "python": "def countRangeSum(nums, lower, upper):\n    # Your code here\n\n",
            "javascript": "function countRangeSum(nums, lower, upper)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int countRangeSum(vector<int>& nums, int lower, int upper) {\n    int n = nums.size();\n    vector<long> sums(n + 1, 0);\n    for (int i = 0; i < n; ++i)\n        sums[i + 1] = sums[i] + nums[i];\n\n    function<int(int, int)> mergeSort = [&](int start, int end) {\n        if (start == end)\n            return 0;\n        int mid = start + (end - start) / 2;\n        int count = mergeSort(start, mid) + mergeSort(mid + 1, end);\n\n        int j = mid + 1, k = mid + 1;\n        for (int i = start; i <= mid; ++i) {\n            while (j <= end && sums[j] - sums[i] < lower) ++j;\n            while (k <= end && sums[k] - sums[i] <= upper) ++k;\n            count += k - j;\n        }\n\n        inplace_merge(sums.begin() + start, sums.begin() + mid + 1, sums.begin() + end + 1);\n        return count;\n    };\n\n    return mergeSort(0, n);\n}",
            "java": "public int countRangeSum(int[] nums, int lower, int upper) {\n    long[] sums = new long[nums.length + 1];\n    for (int i = 0; i < nums.length; ++i)\n        sums[i + 1] = sums[i] + nums[i];\n\n    return countWhileMergeSort(sums, lower, upper, 0, nums.length);\n}\n\nprivate int countWhileMergeSort(long[] sums, int lower, int upper, int start, int end) {\n    if (start >= end)\n        return 0;\n\n    int mid = start + (end - start) / 2;\n    int count = countWhileMergeSort(sums, lower, upper, start, mid) + countWhileMergeSort(sums, lower, upper, mid + 1, end);\n\n    int j = mid + 1, k = mid + 1;\n    for (int i = start; i <= mid; ++i) {\n        while (j <= end && sums[j] - sums[i] < lower) ++j;\n        while (k <= end && sums[k] - sums[i] <= upper) ++k;\n        count += k - j;\n    }\n\n    Arrays.sort(sums, start, end + 1);\n    return count;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    nums = inputs[0]\n    lower = inputs[1]\n    upper = inputs[2]\n    result = countRangeSum(nums, lower, upper)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args[0];\n    const lower = $args[1];\n    const upper = $args[2];\n    const result = countRangeSum(nums, lower, upper);\n    console.log(result);\n}"
        },
        "Qid": "327"
    },
    {
        "_id": {
            "$oid": "661e9a0d555605d7c1275802"
        },
        "title": "Longest Increasing Path in a Matrix",
        "description": "Given an `m x n` integers matrix, return the length of the longest increasing path in the matrix. From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).",
        "example": "Example:\n\nInput: matrix = [[9,9,4],[6,6,8],[2,1,1]]\nOutput: 4\nExplanation: The longest increasing path is [1, 2, 6, 9].",
        "level": "Medium",
        "tags": [
            "matrix",
            "dynamic programming",
            "graph"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        9,
                        9,
                        4
                    ],
                    [
                        6,
                        6,
                        8
                    ],
                    [
                        2,
                        1,
                        1
                    ]
                ],
                [
                    [
                        3,
                        4,
                        5
                    ],
                    [
                        3,
                        2,
                        6
                    ],
                    [
                        2,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ]
                ],
                [
                    [
                        5,
                        4,
                        3,
                        2
                    ],
                    [
                        6,
                        7,
                        8,
                        1
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9
                    ]
                ],
                [
                    [
                        9,
                        8,
                        7
                    ],
                    [
                        6,
                        5,
                        4
                    ],
                    [
                        3,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        15,
                        14,
                        13,
                        12,
                        11
                    ],
                    [
                        10,
                        9,
                        8,
                        7,
                        6
                    ],
                    [
                        5,
                        4,
                        3,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        10,
                        9
                    ],
                    [
                        8,
                        7
                    ],
                    [
                        6,
                        5
                    ],
                    [
                        4,
                        3
                    ],
                    [
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        3,
                        5,
                        7,
                        9
                    ],
                    [
                        2,
                        4,
                        6,
                        8,
                        10
                    ]
                ],
                [
                    [
                        10,
                        8,
                        6,
                        4,
                        2
                    ],
                    [
                        9,
                        7,
                        5,
                        3,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    [
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1
                    ],
                    [
                        2
                    ],
                    [
                        3
                    ],
                    [
                        4
                    ],
                    [
                        5
                    ],
                    [
                        6
                    ],
                    [
                        7
                    ],
                    [
                        8
                    ],
                    [
                        9
                    ],
                    [
                        10
                    ]
                ],
                [
                    [
                        10
                    ],
                    [
                        9
                    ],
                    [
                        8
                    ],
                    [
                        7
                    ],
                    [
                        6
                    ],
                    [
                        5
                    ],
                    [
                        4
                    ],
                    [
                        3
                    ],
                    [
                        2
                    ],
                    [
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ]
                ],
                [
                    [
                        20,
                        19,
                        18,
                        17,
                        16,
                        15,
                        14,
                        13,
                        12,
                        11
                    ],
                    [
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        20,
                        19,
                        18,
                        17,
                        16,
                        15,
                        14,
                        13,
                        12,
                        11
                    ]
                ],
                [
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1
                    ]
                ]
            ],
            "outputs": [
                4,
                4,
                1,
                12,
                3,
                8,
                9,
                15,
                15,
                10,
                10,
                2,
                2,
                10,
                10,
                1,
                1,
                20,
                20,
                20,
                20
            ]
        },
        "sample_code": {
            "c++": "int dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint dfs(vector<vector<int>>& matrix, vector<vector<int>>& memo, int i, int j) {\n    if (memo[i][j] != 0) return memo[i][j];\n    \n    int max_len = 0;\n    for (int k = 0; k < 4; ++k) {\n        int ni = i + dx[k], nj = j + dy[k];\n        if (ni >= 0 && ni < matrix.size() && nj >= 0 && nj < matrix[0].size() && matrix[ni][nj] > matrix[i][j]) {\n            max_len = max(max_len, dfs(matrix, memo, ni, nj));\n        }\n    }\n    \n    memo[i][j] = max_len + 1;\n    return memo[i][j];\n}\n\nint longestIncreasingPath(vector<vector<int>>& matrix) {\n    int m = matrix.size(), n = matrix[0].size();\n    \n    vector<vector<int>> memo(m, vector<int>(n, 0));\n    \n    int ans = 0;\n    for (int i = 0; i < m; ++i)\n        for (int j = 0; j < n; ++j)\n            ans = max(ans, dfs(matrix, memo, i, j));\n    \n    return ans;\n}\n\n",
            "java": "int[] dx = {0, 0, 1, -1};\nint[] dy = {1, -1, 0, 0};\n\npublic int dfs(int[][] matrix, int[][] memo, int i, int j) {\n    if (memo[i][j] != 0) return memo[i][j];\n    \n    int max_len = 0;\n    for (int k = 0; k < 4; ++k) {\n        int ni = i + dx[k], nj = j + dy[k];\n        if (ni >= 0 && ni < matrix.length && nj >= 0 && nj < matrix[0].length && matrix[ni][nj] > matrix[i][j]) {\n            max_len = Math.max(max_len, dfs(matrix, memo, ni, nj));\n        }\n    }\n    \n    memo[i][j] = max_len + 1;\n    return memo[i][j];\n}\n\npublic int longestIncreasingPath(int[][] matrix) {\n    int m = matrix.length, n = matrix[0].length;\n    \n    int[][] memo = new int[m][n];\n    \n    int ans = 0;\n    for (int i = 0; i < m; ++i)\n        for (int j = 0; j < n; ++j)\n            ans = Math.max(ans, dfs(matrix, memo, i, j));\n    \n    return ans;\n}\n\n",
            "python": "dx = (0, 0, 1, -1)\ndy = (1, -1, 0, 0)\n\ndef dfs(matrix, memo, i, j):\n    if memo[i][j] != 0:\n        return memo[i][j]\n    \n    max_len = 0\n    for k in range(4):\n        ni, nj = i + dx[k], j + dy[k]\n        if (0 <= ni < len(matrix) and 0 <= nj < len(matrix[0]) and matrix[ni][nj] > matrix[i][j]):\n            max_len = max(max_len, dfs(matrix, memo, ni, nj))\n    \n    memo[i][j] = max_len + 1\n    return memo[i][j]\n\ndef longest_increasing_path(matrix):\n    m, n = len(matrix), len(matrix[0])\n    \n    memo = [[0] * n for _ in range(m)]\n    \n    ans = 0\n    for i in range(m):\n        for j in range(n):\n            ans = max(ans, dfs(matrix, memo, i, j))\n    \n    return ans\n\n",
            "javascript": "const dx = [0, 0, 1, -1];\nconst dy = [1, -1, 0, 0];\n\nfunction dfs(matrix, memo, i, j) {\n    if (memo[i][j] !== 0) return memo[i][j];\n    \n    let max_len = 0;\n    for (let k = 0; k < 4; ++k) {\n        const ni = i + dx[k], nj = j + dy[k];\n        if (ni >= 0 && ni < matrix.length && nj >= 0 && nj < matrix[0].length && matrix[ni][nj] > matrix[i][j]) {\n            max_len = Math.max(max_len, dfs(matrix, memo, ni, nj));\n        }\n    }\n    \n    memo[i][j] = max_len + 1;\n    return memo[i][j];\n}\n\nfunction longestIncreasingPath(matrix) {\n    const m = matrix.length, n = matrix[0].length;\n    \n    const memo = Array.from({length: m}, () => Array.from({length: n}, () => 0));\n    \n    let ans = 0;\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            ans = Math.max(ans, dfs(matrix, memo, i, j));\n        }\n    }\n    \n    return ans;\n}\n\n",
            "explanation": "We use a depth-first search (DFS) to explore the grid. The basic idea is to start from each cell and move in the four directions allowed (left, right, up, and down). We can only move to a neighboring cell if the value in that cell is greater than the current cell (increasing path).\n\nWe use memoization to store the longest increasing path starting from each cell to avoid redundant calculations. For each cell `(i, j)`, we call the DFS function and compute the longest increasing path starting from that cell by exploring the neighboring cells in all four directions.\n\nFinally, we return the longest increasing path found in the grid.\n\nThe time complexity of this algorithm is O(m * n) as we visit each cell once, where m is the number of rows and n is the number of columns in the given matrix."
        },
        "structure": {
            "c++": "i {nt dx[] = \n    // Your code here\n}\n\n",
            "java": "i {nt[] dx = \n    // Your code here\n}\n\n",
            "python": "dx = (0, 0, 1, -1)\n    # Your code here\n\n",
            "javascript": "const dx = [0, 0, 1, -1];\nconst dy = [1, -1, 0, 0];\n\nfunction dfs(matrix, memo, i, j)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int longestIncreasingPath(vector<vector<int>>& matrix) {\n    int m = matrix.size(), n = matrix[0].size();\n    \n    vector<vector<int>> memo(m, vector<int>(n, 0));\n    \n    int ans = 0;\n    for (int i = 0; i < m; ++i)\n        for (int j = 0; j < n; ++j)\n            ans = max(ans, dfs(matrix, memo, i, j));\n    \n    return ans;\n}",
            "java": "public int longestIncreasingPath(int[][] matrix) {\n    int m = matrix.length, n = matrix[0].length;\n    \n    int[][] memo = new int[m][n];\n    \n    int ans = 0;\n    for (int i = 0; i < m; ++i)\n        for (int j = 0; j < n; ++j)\n            ans = Math.max(ans, dfs(matrix, memo, i, j));\n    \n    return ans;\n}",
            "python": "if __name__ == \"__main__\":\n    matrix = $args\n    result = longest_increasing_path(matrix)\n    print(result)",
            "javascript": "function longestIncreasingPath(matrix) {\n    const m = matrix.length, n = matrix[0].length;\n    \n    const memo = Array.from({length: m}, () => Array.from({length: n}, () => 0));\n    \n    let ans = 0;\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            ans = Math.max(ans, dfs(matrix, memo, i, j));\n        }\n    }\n    \n    return ans;\n}"
        },
        "Qid": "329"
    },
    {
        "_id": {
            "$oid": "661ea478555605d7c1275803"
        },
        "title": "Reconstruct Itinerary",
        "description": "You are given a list of airline tickets where each ticket is represented as a pair of departure and arrival airports. Your task is to reconstruct the itinerary in order and return it. The itinerary must start with 'JFK' and should have the smallest lexical order when read as a single string.",
        "example": "Example 1:\n\nInput: tickets = [['MUC', 'LHR'], ['JFK', 'MUC'], ['SFO', 'SJC'], ['LHR', 'SFO']]\nOutput: ['JFK', 'MUC', 'LHR', 'SFO', 'SJC']\n\nExample 2:\n\nInput: tickets = [['JFK', 'SFO'], ['JFK', 'ATL'], ['SFO', 'ATL'], ['ATL', 'JFK'], ['ATL', 'SFO']]\nOutput: ['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO']\nExplanation: Another possible reconstruction is ['JFK', 'SFO', 'ATL', 'JFK', 'ATL', 'SFO'] but it is larger in lexical order.",
        "level": "Medium",
        "tags": [
            "graph",
            "depth-first search",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "MUC",
                        "LHR"
                    ],
                    [
                        "JFK",
                        "MUC"
                    ],
                    [
                        "SFO",
                        "SJC"
                    ],
                    [
                        "LHR",
                        "SFO"
                    ]
                ],
                [
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "JFK",
                        "ATL"
                    ],
                    [
                        "SFO",
                        "ATL"
                    ],
                    [
                        "ATL",
                        "JFK"
                    ],
                    [
                        "ATL",
                        "SFO"
                    ]
                ],
                [
                    [
                        "JFK",
                        "LGA"
                    ],
                    [
                        "LGA",
                        "LGB"
                    ],
                    [
                        "LGB",
                        "JFK"
                    ]
                ],
                [
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ]
                ],
                [
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ]
                ],
                [
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ]
                ],
                [
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ]
                ],
                [
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ]
                ],
                [
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ]
                ],
                [
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ]
                ],
                [
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ],
                    [
                        "SFO",
                        "JFK"
                    ],
                    [
                        "JFK",
                        "SFO"
                    ]
                ]
            ],
            "outputs": [
                [
                    "JFK",
                    "MUC",
                    "LHR",
                    "SFO",
                    "SJC"
                ],
                [
                    "JFK",
                    "ATL",
                    "JFK",
                    "SFO",
                    "ATL",
                    "SFO"
                ],
                [
                    "JFK",
                    "LGA",
                    "LGB",
                    "JFK"
                ],
                [
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO",
                    "JFK"
                ],
                [
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO"
                ],
                [
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO",
                    "JFK"
                ],
                [
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO"
                ],
                [
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO",
                    "JFK"
                ],
                [
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO"
                ],
                [
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO",
                    "JFK"
                ],
                [
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO",
                    "JFK",
                    "SFO"
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n#include <set>\n\nusing namespace std;\n\nvector<string> findItinerary(vector<vector<string>>& tickets) {\n    unordered_map<string, multiset<string>> flights;\n    vector<string> itinerary;\n    \n    for (const auto& ticket : tickets)\n        flights[ticket[0]].insert(ticket[1]);\n    \n    stack<string> dfs;\n    dfs.push(\"JFK\");\n    \n    while (!dfs.empty()) {\n        string next_airport = dfs.top();\n        if (flights[next_airport].empty()) {\n            itinerary.push_back(next_airport);\n            dfs.pop();\n        } else {\n            dfs.push(*flights[next_airport].begin());\n            flights[next_airport].erase(flights[next_airport].begin());\n        }\n    }\n    \n    reverse(itinerary.begin(), itinerary.end());\n    return itinerary;\n}\n",
            "java": "import java.util.*;\n\nclass Solution {\n    public List<String> findItinerary(List<List<String>> tickets) {\n        HashMap<String, PriorityQueue<String>> flights = new HashMap<>();\n        LinkedList<String> itinerary = new LinkedList<>();\n        \n        for (List<String> ticket : tickets) {\n            flights.putIfAbsent(ticket.get(0), new PriorityQueue<>());\n            flights.get(ticket.get(0)).offer(ticket.get(1));\n        }\n        \n        Stack<String> dfs = new Stack<>();\n        dfs.push(\"JFK\");\n        \n        while (!dfs.isEmpty()) {\n            String nextAirport = dfs.peek();\n            if (flights.get(nextAirport) == null || flights.get(nextAirport).isEmpty()) {\n                itinerary.addFirst(dfs.pop());\n            } else {\n                dfs.push(flights.get(nextAirport).poll());\n            }\n        }\n        \n        return itinerary;\n    }\n}\n",
            "python": "from collections import defaultdict\n\ndef findItinerary(tickets):\n    flights = defaultdict(list)\n    itinerary = []\n\n    for ticket in tickets:\n        flights[ticket[0]].append(ticket[1])\n        flights[ticket[0]].sort(reverse=True)\n\n    def dfs(airport):\n        while flights[airport]:\n            dfs(flights[airport].pop())\n        itinerary.append(airport)\n\n    dfs(\"JFK\")\n    \n    return itinerary[::-1]\n",
            "javascript": "function findItinerary(tickets) {\n    const flights = {};\n    const itinerary = [];\n\n    for (const ticket of tickets) {\n        if (!flights[ticket[0]]) {\n            flights[ticket[0]] = [];\n        }\n        flights[ticket[0]].push(ticket[1]);\n        flights[ticket[0]].sort((a, b) => b.localeCompare(a));\n    }\n\n    function dfs(airport) {\n        while (flights[airport] && flights[airport].length > 0) {\n            dfs(flights[airport].pop());\n        }\n        itinerary.push(airport);\n    }\n\n    dfs(\"JFK\");\n    \n    return itinerary.reverse();\n}\n",
            "explanation": "1. Create a data structure to store our itinerary as well as the flights to be taken.\n2. Iterate over the given list of airline tickets and create a mapping of departure airports to possible arrival airports in sorted order.\n3. Implement a depth-first search (DFS) helper function to traverse through the airports following the mentioned constraints.\n4. Start the DFS traversal with the departure airport \"JFK.\"\n5. After the traversal is complete, reverse the reconstructed itinerary and return it as the result."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n#include <set>\n\nusing namespace std;\n\nvector<string> findItinerary(vector<vector<string>>& tickets)  {\n    // Your code here\n}\n",
            "java": "i {mport java.util.*;\n\nclass Solution \n    // Your code here\n}\n",
            "python": "from collections import defaultdict\n    # Your code here\n\n",
            "javascript": "function findItinerary(tickets)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <unordered_map>\n#include <set>\n\nusing namespace std;\n\nint main() {\n    vector<vector<string>> tickets = $args;\n    vector<string> result = findItinerary(tickets);\n    \n    for (const auto& airport : result) {\n        cout << airport << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}",
            "java": "public List<String> findItinerary(List<List<String>> tickets)",
            "python": "if __name__ == \"__main__\":\n    tickets = $args\n    result = findItinerary(tickets)\n    print(result)",
            "javascript": "function main() {\n    const tickets = $args;\n    const result = findItinerary(tickets);\n    console.log(result);\n}"
        },
        "Qid": "332"
    },
    {
        "_id": {
            "$oid": "661ea4bf555605d7c1275804"
        },
        "title": "Triplet Indices",
        "description": "Given an integer array `nums`, return `true` if there exists a triple of indices `(i, j, k)` such that `i < j < k` and `nums[i] < nums[j] < nums[k]`. If no such indices exist, return `false`.",
        "example": "Example 1:\n\nInput: nums = [1,2,3,4,5]\nOutput: true\nExplanation: Any triplet where i < j < k is valid.\n\nExample 2:\n\nInput: nums = [5,4,3,2,1]\nOutput: false\nExplanation: No triplet exists.\n\nExample 3:\n\nInput: nums = [2,1,5,0,4,6]\nOutput: true\nExplanation: The triplet (3, 4, 5) is valid because nums[3] == 0 < nums[4] == 4 < nums[5] == 6.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    2,
                    1,
                    5,
                    0,
                    4,
                    6
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    3,
                    2,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    1,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    9,
                    8
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    5,
                    4,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    6,
                    5,
                    7,
                    8,
                    9
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    7,
                    6,
                    8,
                    9
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    8,
                    7,
                    9
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    9,
                    8
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false
            ]
        },
        "sample_code": {
            "c++": "bool findTriplets(vector<int>& nums) {\n    int first = INT_MAX, second = INT_MAX;\n\n    for (int num : nums) {\n        if (num <= first) {\n            first = num;\n        } else if (num <= second) {\n            second = num;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n",
            "java": "public boolean findTriplets(int[] nums) {\n    int first = Integer.MAX_VALUE;\n    int second = Integer.MAX_VALUE;\n\n    for (int num : nums) {\n        if (num <= first) {\n            first = num;\n        } else if (num <= second) {\n            second = num;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n",
            "python": "from typing import List\ndef findTriplets(nums: List[int]) -> bool:\n    first = float('inf')\n    second = float('inf')\n\n    for num in nums:\n        if num <= first:\n            first = num\n        elif num <= second:\n            second = num\n        else:\n            return True\n    return False\n",
            "javascript": "function findTriplets(nums) {\n    let first = Number.MAX_VALUE;\n    let second = Number.MAX_VALUE;\n\n    for (let num of nums) {\n        if (num <= first) {\n            first = num;\n        } else if (num <= second) {\n            second = num;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n",
            "explanation": "We use a greedy algorithm here. We keep track of two variables: `first` and `second`. `first` is initialized to the maximum integer value supported by the language. Similarly, `second` is initialized to the max integer value.\n\nWe iterate through the given array `nums`. If the current value is less than or equal to `first`, then we update `first` to be the current value. This helps us find the smallest value in the array. If the current value is not less than `first` but is less than or equal to `second`, we update `second` to be the current value. This helps us find the second smallest value, whose position is strictly greater than the position of `first`.\n\nNow, during iteration, if we find any value that is greater than `second`, then we return `true`, as we have found three indices such that they satisfy the given condition.\n\nIf we iterate through the entire array and don't find a value that is greater than `second`, we return `false`. This means that we couldn't find a triplet satisfying the given condition.\n\nThis greedy algorithm runs in O(n) time complexity, as we iterate through the array once."
        },
        "structure": {
            "c++": "bool findTriplets(vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "public boolean findTriplets(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def findTriplets(nums: List[int]) -> bool:\n    # Your code here\n\n",
            "javascript": "function findTriplets(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "bool findTriplets(vector<int>& nums) {\n    int first = INT_MAX, second = INT_MAX;\n\n    for (int num : nums) {\n        if (num <= first) {\n            first = num;\n        } else if (num <= second) {\n            second = num;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}",
            "java": "public boolean findTriplets(int[] nums) {\n    int first = Integer.MAX_VALUE;\n    int second = Integer.MAX_VALUE;\n\n    for (int num : nums) {\n        if (num <= first) {\n            first = num;\n        } else if (num <= second) {\n            second = num;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}",
            "python": "if __name__ == \"__main__\":\n    nums =$args\n    result = findTriplets(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = findTriplets(nums);\n    console.log(result);\n}"
        },
        "Qid": "334"
    },
    {
        "_id": {
            "$oid": "661ea512555605d7c1275805"
        },
        "title": "Palindrome Pairs",
        "description": "Given a 0-indexed array of unique strings `words`, find all pairs of indices (i, j) such that words[i] + words[j] is a palindrome. Return an array of all the palindrome pairs.",
        "example": "Example 1:\n\nInput: words = [\"abcd\", \"dcba\", \"lls\", \"s\", \"sssll\"]\nOutput: [[0,1],[1,0],[3,2],[2,4]]\nExplanation: The palindromes are [\"abcddcba\", \"dcbaabcd\", \"slls\", \"llssssll\"]\n\nExample 2:\n\nInput: words = [\"bat\", \"tab\", \"cat\"]\nOutput: [[0,1],[1,0]]\nExplanation: The palindromes are [\"battab\", \"tabbat\"]\n\nExample 3:\n\nInput: words = [\"a\", \"\"]\nOutput: [[0,1],[1,0]]\nExplanation: The palindromes are [\"a\", \"a\"]",
        "level": "Medium",
        "tags": [
            "Array",
            "String"
        ],
        "test_cases": {
            "inputs": [
                [
                    "abcd",
                    "dcba",
                    "lls",
                    "s",
                    "sssll"
                ],
                [
                    "bat",
                    "tab",
                    "cat"
                ],
                [
                    "a",
                    ""
                ],
                [
                    "race",
                    "car",
                    "dad",
                    "add"
                ],
                [
                    "abc",
                    "cba",
                    "def",
                    "fed"
                ],
                [
                    "hello",
                    "world",
                    "madam",
                    "racecar"
                ],
                [
                    "",
                    "a",
                    "b",
                    "c"
                ],
                [
                    "abc",
                    "cba",
                    "def",
                    "fed",
                    "a",
                    "aa",
                    "aaa"
                ],
                [
                    "abcd",
                    "dcba",
                    "lls",
                    "s",
                    "sssll",
                    "a",
                    "aa",
                    "aaa"
                ],
                [
                    "abcd",
                    "dcba",
                    "lls",
                    "s",
                    "sssll",
                    "a",
                    "aa",
                    "aaa",
                    "racecar"
                ]
            ],
            "outputs": [
                [
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        3,
                        2
                    ],
                    [
                        2,
                        4
                    ]
                ],
                [
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        0
                    ]
                ],
                [
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        0
                    ]
                ],
                [
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        2
                    ]
                ],
                [
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        0
                    ]
                ],
                [
                    [
                        0,
                        3
                    ],
                    [
                        1,
                        2
                    ]
                ],
                [
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        2
                    ]
                ],
                [
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        2
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        4
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        6
                    ]
                ],
                [
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        3,
                        2
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        5
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        7
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        9
                    ]
                ],
                [
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        3,
                        2
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        5
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        7
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        9
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        11
                    ]
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n\nstd::vector<std::pair<int, int>> palindromePairs(const std::vector<std::string> &words) {\n    std::vector<std::pair<int, int>> result;\n\n    for (size_t i = 0; i < words.size(); i++) {\n        for (size_t j = 0; j < words.size(); j++) {\n            if (i == j) continue;\n            std::string concat = words[i] + words[j];\n\n            bool is_palindrome = true;\n            for (size_t left = 0, right = concat.size() - 1; left < right; left++, right--) {\n                if (concat[left] != concat[right]) {\n                    is_palindrome = false;\n                    break;\n                }\n            }\n\n            if (is_palindrome) {\n                result.push_back(std::make_pair(i, j));\n            }\n        }\n    }\n\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> palindromePairs(String[] words) {\n    List<List<Integer>> result = new ArrayList<>();\n\n    for (int i = 0; i < words.length; i++) {\n        for (int j = 0; j < words.length; j++) {\n            if (i == j) continue;\n            String concat = words[i] + words[j];\n\n            boolean isPalindrome = true;\n            for (int left = 0, right = concat.length() - 1; left < right; left++, right--) {\n                if (concat.charAt(left) != concat.charAt(right)) {\n                    isPalindrome = false;\n                    break;\n                }\n            }\n\n            if (isPalindrome) {\n                List<Integer> pair = new ArrayList<>();\n                pair.add(i);\n                pair.add(j);\n                result.add(pair);\n            }\n        }\n    }\n\n    return result;\n}\n",
            "python": "def palindrome_pairs(words):\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    result = []\n    for i in range(len(words)):\n        for j in range(len(words)):\n            if i == j:\n                continue\n            concat = words[i] + words[j]\n            if is_palindrome(concat):\n                result.append([i, j])\n    return result\n",
            "javascript": "function palindromePairs(words) {\n    function isPalindrome(s) {\n        return s === s.split('').reverse().join('');\n    }\n\n    const result = [];\n    for (let i = 0; i < words.length; i++) {\n        for (let j = 0; j < words.length; j++) {\n            if (i === j) continue;\n            const concat = words[i] + words[j];\n            if (isPalindrome(concat)) {\n                result.push([i, j]);\n            }\n        }\n    }\n\n    return result;\n}\n",
            "explanation": "The algorithm starts by defining a nested function `isPalindrome` to check if a given string is a palindrome. This function will be used later in the code. \n\nThen, a `result` list (vector in C++) is created to store the index pairs of the palindrome concatenations.\n\nTwo nested loops are used to iterate through all the pairs of words in the input list. If the two words are the same (i.e., the indices `i` and `j` are equal), the current iteration is ignored (with a `continue` statement). This ensures that we only process distinct pairs of words.\n\nNext, we concatenate the two words, and check if the resulting string is a palindrome using the `isPalindrome` function. If it is, we add the indices as a pair to the `result` list.\n\nOnce the two loops complete, the `result` list is returned, containing all the unique index pairs (i, j) where the concatenation of words[i] and words[j] is a palindrome."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n\nstd::vector<std::pair<int, int>> palindromePairs(const std::vector<std::string> &words)  {\n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> palindromePairs(String[] words)  {\n    // Your code here\n}\n",
            "python": "def palindrome_pairs(words):\n    # Your code here\n\n",
            "javascript": "function palindromePairs(words)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <iostream>\n\nstd::vector<std::pair<int, int>> palindromePairs(const std::vector<std::string> &words) {\n    std::vector<std::pair<int, int>> result;\n\n    for (size_t i = 0; i < words.size(); i++) {\n        for (size_t j = 0; j < words.size(); j++) {\n            if (i == j) continue;\n            std::string concat = words[i] + words[j];\n\n            bool is_palindrome = true;\n            for (size_t left = 0, right = concat.size() - 1; left < right; left++, right--) {\n                if (concat[left] != concat[right]) {\n                    is_palindrome = false;\n                    break;\n                }\n            }\n\n            if (is_palindrome) {\n                result.push_back(std::make_pair(i, j));\n            }\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    std::vector<std::string> words = $args;\n    std::vector<std::pair<int, int>> result = palindromePairs(words);\n\n    for (const auto& pair : result) {\n        std::cout << pair.first << \" \" << pair.second << std::endl;\n    }\n\n    return 0;\n}",
            "java": "public List<List<Integer>> palindromePairs(String[] words) {\n    List<List<Integer>> result = new ArrayList<>();\n\n    for (int i = 0; i < words.length; i++) {\n        for (int j = 0; j < words.length; j++) {\n            if (i == j) continue;\n            String concat = words[i] + words[j];\n\n            boolean isPalindrome = true;\n            for (int left = 0, right = concat.length() - 1; left < right; left++, right--) {\n                if (concat.charAt(left) != concat.charAt(right)) {\n                    isPalindrome = false;\n                    break;\n                }\n            }\n\n            if (isPalindrome) {\n                List<Integer> pair = new ArrayList<>();\n                pair.add(i);\n                pair.add(j);\n                result.add(pair);\n            }\n        }\n    }\n\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    words =$args\n    result = palindrome_pairs(words)\n    print(result)",
            "javascript": "function palindromePairs(words) {\n    function isPalindrome(s) {\n        return s === s.split('').reverse().join('');\n    }\n\n    const result = palindromePairs(words);\n\n    return result;\n}"
        },
        "Qid": "336"
    },
    {
        "_id": {
            "$oid": "661ea73c555605d7c1275806"
        },
        "title": "Counting Ones in Binary Representation",
        "description": "Given an integer `n`, return an array `ans` of length `n + 1` such that for each `i` (`0 <= i <= n`), `ans[i]` is the number of `1`'s in the binary representation of `i`.",
        "example": "Example 1:\n\nInput: n = 2\nOutput: [0,1,1]\nExplanation:\n0 --> 0\n1 --> 1\n2 --> 10\n\nExample 2:\n\nInput: n = 5\nOutput: [0,1,1,2,1,2]\nExplanation:\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101",
        "level": "Easy",
        "tags": [
            "Array",
            "Bit Manipulation"
        ],
        "test_cases": {
            "inputs": [
                2,
                5,
                0,
                10,
                15,
                100
            ],
            "outputs": [
                [
                    0,
                    1,
                    1
                ],
                [
                    0,
                    1,
                    1,
                    2,
                    1,
                    2
                ],
                [
                    0
                ],
                [
                    0,
                    1,
                    1,
                    2,
                    1,
                    2,
                    2,
                    3,
                    1,
                    2,
                    2
                ],
                [
                    0,
                    1,
                    1,
                    2,
                    1,
                    2,
                    2,
                    3,
                    1,
                    2,
                    2,
                    3,
                    2,
                    3,
                    3,
                    4
                ],
                [
                    0,
                    1,
                    1,
                    2,
                    1,
                    2,
                    2,
                    3,
                    1,
                    2,
                    2,
                    3,
                    2,
                    3,
                    3,
                    4,
                    1,
                    2,
                    2,
                    3,
                    2,
                    3,
                    3,
                    4,
                    2,
                    3,
                    3,
                    4,
                    3,
                    4,
                    4,
                    5,
                    1,
                    2,
                    2,
                    3,
                    2,
                    3,
                    3,
                    4,
                    2,
                    3,
                    3,
                    4,
                    3,
                    4,
                    4,
                    5,
                    2,
                    3,
                    3,
                    4,
                    3,
                    4,
                    4,
                    5,
                    3,
                    4,
                    4,
                    5,
                    4,
                    5,
                    5,
                    6,
                    1,
                    2,
                    2,
                    3,
                    2,
                    3,
                    3,
                    4,
                    2,
                    3,
                    3,
                    4,
                    3,
                    4,
                    4,
                    5,
                    2,
                    3,
                    3,
                    4,
                    3,
                    4,
                    4,
                    5,
                    3,
                    4,
                    4,
                    5,
                    4,
                    5,
                    5,
                    6,
                    2,
                    3,
                    3,
                    4,
                    3,
                    4,
                    4,
                    5,
                    3,
                    4,
                    4,
                    5,
                    4,
                    5,
                    5,
                    6,
                    3,
                    4,
                    4,
                    5,
                    4,
                    5,
                    5,
                    6,
                    4,
                    5,
                    5,
                    6,
                    5,
                    6,
                    6,
                    7
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> countBits(int n) {\n    vector<int> ans(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        ans[i] = ans[i & (i - 1)] + 1;\n    }\n    return ans;\n}\n",
            "java": "public int[] countBits(int n) {\n    int[] ans = new int[n + 1];\n    for (int i = 1; i <= n; ++i) {\n        ans[i] = ans[i & (i - 1)] + 1;\n    }\n    return ans;\n}\n",
            "python": "def countBits(n):\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        ans[i] = ans[i & (i - 1)] + 1\n    return ans\n",
            "javascript": "function countBits(n) {\n    const ans = new Array(n + 1).fill(0);\n    for (let i = 1; i <= n; ++i) {\n        ans[i] = ans[i & (i - 1)] + 1;\n    }\n    return ans;\n}\n",
            "explanation": "The algorithm leverages a key observation: `(i & (i - 1))` has the same binary representation as `i`, but with the least significant `1` bit removed. This leads to a fast and efficient way to count the number of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nFor each number `i` in the range `[1, n]`, we calculate `ans[i]` based on `ans[i & (i - 1)]`. Since `ans[i & (i - 1)]` is the count of `1` bits in the binary representation of `(i & (i - 1))`, adding `1` to that count will give us the count of `1` bits in the binary representation of `i`.\n\nThe algorithm iterates through the range `[1, n]` and fills the output array `ans` accordingly. The final array `ans` contains the count of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nThe time complexity of this algorithm is O(n) as it iterates through the range `[1, n]` only once, and the space complexity is O(n + 1) since it creates an array of length `n + 1` to store the results."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> countBits(int n)  {\n    // Your code here\n}\n",
            "java": "public int[] countBits(int n)  {\n    // Your code here\n}\n",
            "python": "def countBits(n):\n    # Your code here\n\n",
            "javascript": "function countBits(n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nint main() {\n    int n = $args;\n    vector<int> result = countBits(n);\n    for (int i = 0; i < result.size(); ++i) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "java": "public int[] countBits(int n) {\n    int[] ans = new int[n + 1];\n    for (int i = 1; i <= n; ++i) {\n        ans[i] = ans[i & (i - 1)] + 1;\n    }\n    return ans;\n}",
            "python": "if __name__ == \"__main__\":\n    n =$args\n    result = countBits(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = countBits(n);\n    console.log(result);\n}"
        },
        "Qid": "338"
    },
    {
        "_id": {
            "$oid": "661ed4ee555605d7c1275807"
        },
        "title": "Nested List Depth Sum",
        "description": "You are given a nested list of integers `nestedList`. Each element is either an integer or a list whose elements may also be integers or other lists. The depth of an integer is the number of lists that it is inside of. Return the sum of each integer in `nestedList` multiplied by its depth.",
        "example": "Example 1:\n\nInput: nestedList = [[1,1],2,[1,1]]\nOutput: 10\nExplanation: Four 1's at depth 2, one 2 at depth 1. 1*2 + 1*2 + 2*1 + 1*2 + 1*2 = 10.\n\nExample 2:\n\nInput: nestedList = [1,[4,[6]]]\nOutput: 27\nExplanation: One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3. 1*1 + 4*2 + 6*3 = 27.\n\nExample 3:\n\nInput: nestedList = [0]\nOutput: 0",
        "level": "Easy",
        "tags": [
            "nested list",
            "depth",
            "sum"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        1
                    ],
                    2,
                    [
                        1,
                        1
                    ]
                ],
                [
                    1,
                    [
                        4,
                        [
                            6
                        ]
                    ]
                ],
                [
                    0
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        [
                            2,
                            3
                        ]
                    ],
                    [
                        4,
                        [
                            5,
                            6
                        ]
                    ]
                ],
                [
                    [
                        1,
                        [
                            2,
                            [
                                3,
                                [
                                    4
                                ]
                            ]
                        ]
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        [
                            4,
                            5,
                            6
                        ],
                        [
                            7,
                            8,
                            9
                        ]
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        [
                            4,
                            5,
                            6
                        ],
                        [
                            [
                                7,
                                8,
                                9
                            ]
                        ]
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        [
                            4,
                            5,
                            6
                        ],
                        [
                            [
                                7,
                                8,
                                9
                            ],
                            [
                                10,
                                11,
                                12
                            ]
                        ]
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        [
                            4,
                            5,
                            6
                        ],
                        [
                            [
                                7,
                                8,
                                9
                            ],
                            [
                                10,
                                11,
                                12,
                                [
                                    13,
                                    14,
                                    15
                                ]
                            ]
                        ]
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        [
                            4,
                            5,
                            6
                        ],
                        [
                            [
                                7,
                                8,
                                9
                            ],
                            [
                                10,
                                11,
                                12,
                                [
                                    13,
                                    14,
                                    15,
                                    [
                                        16,
                                        17,
                                        18
                                    ]
                                ]
                            ]
                        ]
                    ]
                ]
            ],
            "outputs": [
                10,
                27,
                0,
                44,
                44,
                10,
                45,
                45,
                45,
                75,
                75,
                75,
                125,
                125,
                125,
                175,
                175,
                175,
                225,
                225,
                225,
                275,
                275,
                275,
                325,
                325
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <variant>\n\nusing NestedList = std::vector<std::variant<int, std::vector<std::variant<int, std::vector<int>>>>>;\n\nint depthSumHelper(NestedList nestedList, int depth) {\n    int sum = 0;\n    for (auto& element : nestedList) {\n        if (std::holds_alternative<int>(element)) {\n            sum += std::get<int>(element) * depth;\n        } else {\n            sum += depthSumHelper(std::get<std::vector<std::variant<int, std::vector<int>>>>(element), depth + 1);\n        }\n    }\n    return sum;\n}\n\nint depthSum(NestedList nestedList) {\n    return depthSumHelper(nestedList, 1);\n}\n\n",
            "java": "import java.util.List;\n\npublic int depthSum(List<?> nestedList) {\n    return depthSumHelper(nestedList, 1);\n}\n\nprivate int depthSumHelper(List<?> nestedList, int depth) {\n    int sum = 0;\n    for (Object element : nestedList) {\n        if (element instanceof Integer) {\n            sum += (int) element * depth;\n        } else {\n            sum += depthSumHelper((List<?>) element, depth + 1);\n        }\n    }\n    return sum;\n}\n\n",
            "python": "from typing import List, Union\n\ndef depth_sum(nested_list: List[Union[int, List]]) -> int:\n    def depth_sum_helper(nested_list: List[Union[int, List]], depth: int) -> int:\n        return sum(element * depth if isinstance(element, int) else depth_sum_helper(element, depth + 1) for element in nested_list)\n\n    return depth_sum_helper(nested_list, 1)\n\n",
            "javascript": "function depthSum(nestedList) {\n    return depthSumHelper(nestedList, 1);\n}\n\nfunction depthSumHelper(nestedList, depth) {\n    let sum = 0;\n    for (let element of nestedList) {\n        if (typeof element === \"number\") {\n            sum += element * depth;\n        } else {\n            sum += depthSumHelper(element, depth + 1);\n        }\n    }\n    return sum;\n}\n\n",
            "explanation": "The algorithm utilizes a helper function that takes the nested list and the current depth. It loops through each element in the nested list. If the element is an integer, it adds the product of the integer and the depth to the sum. If the element is a list, it recursively calls the helper function with the element and a higher depth. This continues until all elements are processed, and the sum is returned."
        },
        "structure": {
            "c++": "#include <vector>\n#include <variant>\n\nusing NestedList = std::vector<std::variant<int, std::vector<std::variant<int, std::vector<int>>>>>;\n\nint depthSumHelper(NestedList nestedList, int depth)  {\n    // Your code here\n}\n\n",
            "java": "import java.util.List;\n\npublic int depthSum(List<?> nestedList)  {\n    // Your code here\n}\n\n",
            "python": "from typing import List, Union\n    # Your code here\n\n",
            "javascript": "function depthSum(nestedList)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <variant>\n#include <iostream>\n\nusing NestedList = std::vector<std::variant<int, std::vector<std::variant<int, std::vector<int>>>>>;\n\nint depthSumHelper(NestedList nestedList, int depth) {\n    int sum = 0;\n    for (auto& element : nestedList) {\n        if (std::holds_alternative<int>(element)) {\n            sum += std::get<int>(element) * depth;\n        } else {\n            sum += depthSumHelper(std::get<std::vector<std::variant<int, std::vector<int>>>>(element), depth + 1);\n        }\n    }\n    return sum;\n}\n\nint depthSum(NestedList nestedList) {\n    return depthSumHelper(nestedList, 1);\n}\n\nint main() {\n    NestedList nestedList = $args;\n    int result = depthSum(nestedList);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int depthSum(List<?> nestedList) {\n    return depthSumHelper(nestedList, 1);\n}",
            "python": "if __name__ == \"__main__\":\n    nested_list = $args\n    result = depth_sum(nested_list)\n    print(result)",
            "javascript": "function main() {\n    const nestedList = $args;\n    const result = depthSum(nestedList);\n    console.log(result);\n}"
        },
        "Qid": "339"
    },
    {
        "_id": {
            "$oid": "661ed5d4555605d7c1275808"
        },
        "title": "Longest Substring with At Most K Distinct Characters",
        "description": "Given a string `s` and an integer `k`, find the length of the longest substring of `s` that contains at most `k` distinct characters. Return the length of the longest substring.",
        "example": "Example:\n\nInput: s = \"eceba\", k = 2\nOutput: 3\nExplanation: The longest substring with at most 2 distinct characters is \"ece\" with length 3.\n\nInput: s = \"aa\", k = 1\nOutput: 2\nExplanation: The longest substring with at most 1 distinct character is \"aa\" with length 2.",
        "level": "Medium",
        "tags": [
            "string",
            "sliding window",
            "hash table"
        ],
        "test_cases": {
            "inputs": [
                [
                    "eceba",
                    2
                ],
                [
                    "aa",
                    1
                ],
                [
                    "",
                    0
                ],
                [
                    "a",
                    1
                ],
                [
                    "abcabcbb",
                    2
                ],
                [
                    "pwwkew",
                    3
                ],
                [
                    "abcdefg",
                    1
                ],
                [
                    "aab",
                    1
                ],
                [
                    "aab",
                    2
                ],
                [
                    "aab",
                    3
                ],
                [
                    "aabbcc",
                    1
                ],
                [
                    "aabbcc",
                    2
                ],
                [
                    "aabbcc",
                    3
                ],
                [
                    "aabbcc",
                    4
                ],
                [
                    "aabbcc",
                    5
                ],
                [
                    "aabbcc",
                    6
                ],
                [
                    "aabbcc",
                    7
                ],
                [
                    "aabbcc",
                    8
                ],
                [
                    "aabbcc",
                    9
                ],
                [
                    "aabbcc",
                    10
                ]
            ],
            "outputs": [
                3,
                2,
                0,
                1,
                4,
                3,
                1,
                2,
                3,
                3,
                1,
                2,
                3,
                4,
                6,
                6,
                6,
                6,
                6,
                6
            ]
        },
        "sample_code": {
            "c++": "#include <unordered_map>\n#include <algorithm>\n\nint lengthOfLongestSubstringKDistinct(std::string s, int k) {\n    std::unordered_map<char, int> charCount;\n    int left = 0, maxLength = 0;\n\n    for (int right = 0; right < s.size(); ++right) {\n        charCount[s[right]]++;\n\n        while (charCount.size() > k) {\n            charCount[s[left]]--;\n            if (charCount[s[left]] == 0) {\n                charCount.erase(s[left]);\n            }\n            left++;\n        }\n\n        maxLength = std::max(maxLength, right - left + 1);\n    }\n    return maxLength;\n}\n",
            "java": "import java.util.HashMap;\n\npublic int lengthOfLongestSubstringKDistinct(String s, int k) {\n    HashMap<Character, Integer> charCount = new HashMap<>();\n    int left = 0, maxLength = 0;\n\n    for (int right = 0; right < s.length(); ++right) {\n        charCount.put(s.charAt(right), charCount.getOrDefault(s.charAt(right), 0) + 1);\n\n        while (charCount.size() > k) {\n            charCount.put(s.charAt(left), charCount.get(s.charAt(left)) - 1);\n            if (charCount.get(s.charAt(left)) == 0) {\n                charCount.remove(s.charAt(left));\n            }\n            left++;\n        }\n\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    return maxLength;\n}\n",
            "python": "def length_of_longest_substring_k_distinct(s: str, k: int) -> int:\n    char_count = {}\n    left = 0\n    max_length = 0\n\n    for right, char in enumerate(s):\n        char_count[char] = char_count.get(char, 0) + 1\n\n        while len(char_count) > k:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n\n        max_length = max(max_length, right - left + 1)\n\n    return max_length\n",
            "javascript": "function lengthOfLongestSubstringKDistinct(s, k) {\n    const charCount = new Map();\n    let left = 0;\n    let maxLength = 0;\n\n    for (let right = 0; right < s.length; ++right) {\n        charCount.set(s[right], (charCount.get(s[right]) || 0) + 1);\n\n        while (charCount.size > k) {\n            charCount.set(s[left], charCount.get(s[left]) - 1);\n            if (charCount.get(s[left]) === 0) {\n                charCount.delete(s[left]);\n            }\n            left++;\n        }\n\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    return maxLength;\n}\n",
            "explanation": "1. Create a hashmap to store character counts within the sliding window.\n2. Initialize `left` and `maxLength` to zero.\n3. Iterate through the string with a for loop:\n    a. Increment the count of the current character in the hashmap.\n    b. If there are more than `k` distinct characters in the hashmap, move `left` to the right to shrink the window and update the count in the hashmap (remove the entry if the count is zero).\n    c. Update `maxLength` with the length of the current window right - left + 1.\n4. Return `maxLength`."
        },
        "structure": {
            "c++": "#include <unordered_map>\n#include <algorithm>\n\nint lengthOfLongestSubstringKDistinct(std::string s, int k)  {\n    // Your code here\n}\n",
            "java": "import java.util.HashMap;\n\npublic int lengthOfLongestSubstringKDistinct(String s, int k)  {\n    // Your code here\n}\n",
            "python": "def length_of_longest_substring_k_distinct(s: str, k: int) -> int:\n    # Your code here\n\n",
            "javascript": "function lengthOfLongestSubstringKDistinct(s, k)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <unordered_map>\n#include <algorithm>\n#include <iostream>\n\nint main() {\n    std::string s = $args;\n    int k = $args;\n    int result = lengthOfLongestSubstringKDistinct(s, k);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int lengthOfLongestSubstringKDistinct(String s, int k) {\n    HashMap<Character, Integer> charCount = new HashMap<>();\n    int left = 0, maxLength = 0;\n\n    for (int right = 0; right < s.length(); ++right) {\n        charCount.put(s.charAt(right), charCount.getOrDefault(s.charAt(right), 0) + 1);\n\n        while (charCount.size() > k) {\n            charCount.put(s.charAt(left), charCount.get(s.charAt(left)) - 1);\n            if (charCount.get(s.charAt(left)) == 0) {\n                charCount.remove(s.charAt(left));\n            }\n            left++;\n        }\n\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    return maxLength;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    s = inputs[0]\n    k = inputs[1]\n    result = length_of_longest_substring_k_distinct(s, k)\n    print(result)",
            "javascript": "function main() {\n    const s = $args[0];\n    const k = $args[1];\n    const result = lengthOfLongestSubstringKDistinct(s, k);\n    console.log(result);\n}"
        },
        "Qid": "340"
    },
    {
        "_id": {
            "$oid": "661ed5f1555605d7c1275809"
        },
        "title": "Power of Four",
        "description": "Given an integer `n`, determine if it is a power of four. Return `true` if `n` is a power of four, otherwise return `false`. An integer `n` is a power of four if there exists an integer `x` such that `n == 4^x`.",
        "example": "Example 1:\n\nInput: n = 16\nOutput: true\nExplanation: 16 is equal to 4^2, so it is a power of four.\n\nExample 2:\n\nInput: n = 5\nOutput: false\nExplanation: 5 is not a power of four.\n\nExample 3:\n\nInput: n = 1\nOutput: true\nExplanation: 1 is equal to 4^0, so it is a power of four.",
        "level": "Easy",
        "tags": [
            "math",
            "bit manipulation"
        ],
        "test_cases": {
            "inputs": [
                16,
                5,
                1,
                0,
                64,
                100,
                256,
                1024,
                10000,
                1048576,
                1073741824,
                2147483647,
                -16,
                -5,
                -1,
                -64,
                -100,
                -256,
                -1024,
                -10000
            ],
            "outputs": [
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                true,
                false,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "bool isPowerOfFour(int n) {\n    if (n <= 0) return false;\n    while (n % 4 == 0) {\n        n /= 4;\n    }\n    return n == 1;\n}\n",
            "java": "public boolean isPowerOfFour(int n) {\n    if (n <= 0) return false;\n    while (n % 4 == 0) {\n        n /= 4;\n    }\n    return n == 1;\n}\n",
            "python": "def isPowerOfFour(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n % 4 == 0:\n        n //= 4\n    return n == 1\n",
            "javascript": "function isPowerOfFour(n) {\n    if (n <= 0) return false;\n    while (n % 4 === 0) {\n        n = Math.floor(n / 4);\n    }\n    return n === 1;\n}\n",
            "explanation": "The algorithm checks if a given integer `n` is a power of 4 or not. If `n` is less than or equal to 0, it immediately returns `false`. Otherwise, it enters a loop that checks if `n` is divisible by 4. If it is, it keeps dividing the number by 4 until it is no longer divisible by 4. After the loop, the algorithm checks whether the final remainder is 1 or not. If the remainder is 1, the number was initially a power of 4, and it returns `true`. Otherwise, it returns `false`."
        },
        "structure": {
            "c++": "bool isPowerOfFour(int n)  {\n    // Your code here\n}\n",
            "java": "public boolean isPowerOfFour(int n)  {\n    // Your code here\n}\n",
            "python": "def isPowerOfFour(n: int) -> bool:\n    # Your code here\n\n",
            "javascript": "function isPowerOfFour(n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nbool isPowerOfFour(int n);\n\nint main() {\n    int n = $args;\n    bool result = isPowerOfFour(n);\n    cout << boolalpha << result << endl;\n    return 0;\n}\n",
            "java": "public static void main(String[] args) {\n    int n = $args;\n    boolean result = isPowerOfFour(n);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    result = isPowerOfFour(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = isPowerOfFour(n);\n    console.log(result);\n}"
        },
        "Qid": "342"
    },
    {
        "_id": {
            "$oid": "661ed608555605d7c127580a"
        },
        "title": "Maximum Product of Integer Break",
        "description": "Given an integer `n`, break it into the sum of `k` positive integers, where `k >= 2`, and maximize the product of those integers. Return the maximum product you can get.",
        "example": "Example 1:\n\nInput: n = 2\nOutput: 1\nExplanation: 2 = 1 + 1, 1 * 1 = 1.\n\nExample 2:\n\nInput: n = 10\nOutput: 36\nExplanation: 10 = 3 + 3 + 4, 3 * 3 * 4 = 36.",
        "level": "Medium",
        "tags": [
            "mathematics",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                2,
                10,
                5,
                15,
                20,
                30,
                58,
                3,
                8,
                12,
                25,
                40,
                50,
                55,
                6,
                18,
                24,
                36,
                45,
                52
            ],
            "outputs": [
                1,
                36,
                6,
                243,
                1458,
                24300,
                1549681956,
                2,
                18,
                81,
                8748,
                4860000,
                40500000,
                {
                    "$numberLong": "23514624000"
                },
                9,
                486,
                8748,
                874800,
                40500000,
                {
                    "$numberLong": "23514624000"
                }
            ]
        },
        "sample_code": {
            "c++": "int integerBreak(int n) {\n    if (n <= 3) return n - 1;\n    int product = 1;\n    while (n > 4) {\n        product *= 3;\n        n -= 3;\n    }\n    return product * n;\n}\n",
            "java": "public int integerBreak(int n) {\n    if (n <= 3) return n - 1;\n    int product = 1;\n    while (n > 4) {\n        product *= 3;\n        n -= 3;\n    }\n    return product * n;\n}\n",
            "python": "def integer_break(n):\n    if n <= 3:\n        return n - 1\n    product = 1\n    while n > 4:\n        product *= 3\n        n -= 3\n    return product * n\n",
            "javascript": "function integerBreak(n) {\n    if (n <= 3) return n - 1;\n    let product = 1;\n    while (n > 4) {\n        product *= 3;\n        n -= 3;\n    }\n    return product * n;\n}\n",
            "explanation": "The algorithm is based on the fact that the optimal factorization for the integer n consists of as many 3s as possible, and maybe a 2 or a 4. If we have a factor composed of five 1s, we can always break it into two 2s and a 3, which has a larger product (2 * 2 * 3 > 1 * 1 * 1 * 1 * 1). This means that the factors included in the final product will never be smaller than 2.\n\nThe solution is to repeatedly subtract 3 from the given number `n` and multiply the product by 3. If we end up with `n` being 2, 3, or 4 after this process, we multiply the product by `n` and return it.\n\nThis solution runs in O(n) time complexity."
        },
        "structure": {
            "c++": "int integerBreak(int n)  {\n    // Your code here\n}\n",
            "java": "public int integerBreak(int n)  {\n    // Your code here\n}\n",
            "python": "def integer_break(n):\n    # Your code here\n\n",
            "javascript": "function integerBreak(n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = integerBreak(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int main(int args) {\n    int n = $args;\n    int result = integerBreak(n);\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = integer_break(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = integerBreak(n);\n    console.log(result);\n}"
        },
        "Qid": "343"
    },
    {
        "_id": {
            "$oid": "661ed6d2555605d7c127580b"
        },
        "title": "Reverse String",
        "description": "Write a function that reverses a string. The input string is given as an array of characters `s`. You must do this by modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm) with `O(1)` extra memory.",
        "example": "Example:\n\nInput: s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]",
        "level": "Easy",
        "tags": [
            "Array",
            "String",
            "In-place"
        ],
        "test_cases": {
            "inputs": [
                [
                    "h",
                    "e",
                    "l",
                    "l",
                    "o"
                ],
                [
                    "H",
                    "a",
                    "n",
                    "n",
                    "a",
                    "h"
                ],
                [
                    "a",
                    "b",
                    "c",
                    "d",
                    "e"
                ],
                [
                    "1",
                    "2",
                    "3",
                    "4",
                    "5"
                ],
                [
                    "a"
                ],
                [
                    "A",
                    "B",
                    "C"
                ],
                [
                    "d",
                    "o",
                    "g"
                ],
                [
                    "r",
                    "a",
                    "c",
                    "e",
                    "c",
                    "a",
                    "r"
                ],
                [
                    "l",
                    "e",
                    "v",
                    "e",
                    "l"
                ],
                [
                    "m",
                    "a",
                    "d",
                    "a",
                    "m"
                ],
                [
                    "r",
                    "o",
                    "t",
                    "a",
                    "t",
                    "o",
                    "r"
                ],
                [
                    "s",
                    "t",
                    "a",
                    "t",
                    "i",
                    "o",
                    "n"
                ],
                [
                    "r",
                    "e",
                    "v",
                    "e",
                    "r",
                    "s",
                    "e"
                ],
                [
                    "p",
                    "a",
                    "l",
                    "i",
                    "n",
                    "d",
                    "r",
                    "o",
                    "m",
                    "e"
                ],
                [
                    "a",
                    "n",
                    "a",
                    "g",
                    "r",
                    "a",
                    "m"
                ],
                [
                    "c",
                    "o",
                    "d",
                    "i",
                    "n",
                    "g"
                ],
                [
                    "q",
                    "u",
                    "e",
                    "s",
                    "t",
                    "i",
                    "o",
                    "n"
                ],
                [
                    "e",
                    "x",
                    "a",
                    "m",
                    "p",
                    "l",
                    "e"
                ],
                [
                    "t",
                    "e",
                    "s",
                    "t"
                ],
                [
                    "i",
                    "n",
                    "p",
                    "u",
                    "t"
                ]
            ],
            "outputs": [
                "[\"o\",\"l\",\"l\",\"e\",\"h\"]",
                "[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]",
                "[\"e\",\"d\",\"c\",\"b\",\"a\"]",
                "[\"5\",\"4\",\"3\",\"2\",\"1\"]",
                "[\"a\"]",
                "[\"C\",\"B\",\"A\"]",
                "[\"g\",\"o\",\"d\"]",
                "[\"r\",\"a\",\"c\",\"e\",\"c\",\"a\",\"r\"]",
                "[\"l\",\"e\",\"v\",\"e\",\"l\"]",
                "[\"m\",\"a\",\"d\",\"a\",\"m\"]",
                "[\"r\",\"o\",\"t\",\"a\",\"t\",\"o\",\"r\"]",
                "[\"n\",\"o\",\"i\",\"t\",\"a\",\"t\",\"s\"]",
                "[\"e\",\"s\",\"r\",\"e\",\"v\",\"e\",\"r\"]",
                "[\"e\",\"m\",\"o\",\"r\",\"d\",\"n\",\"i\",\"l\",\"a\",\"p\"]",
                "[\"m\",\"a\",\"r\",\"g\",\"a\",\"n\",\"a\"]",
                "[\"g\",\"n\",\"i\",\"d\",\"o\",\"c\"]",
                "[\"n\",\"o\",\"i\",\"t\",\"s\",\"u\",\"e\",\"q\"]",
                "[\"e\",\"l\",\"p\",\"m\",\"a\",\"x\",\"e\"]",
                "[\"t\",\"s\",\"e\",\"t\"]",
                "[\"t\",\"u\",\"p\",\"n\",\"i\"]"
            ]
        },
        "sample_code": {
            "c++": "void reverseString(vector<char>& s) {\n    int left = 0, right = s.size() - 1;\n    while (left < right) {\n        swap(s[left++], s[right--]);\n    }\n}\n",
            "java": "public void reverseString(char[] s) {\n    int left = 0, right = s.length - 1;\n    while (left < right) {\n        char temp = s[left];\n        s[left++] = s[right];\n        s[right--] = temp;\n    }\n}\n",
            "python": "def reverseString(s: list[str]) -> None:\n    left, right = 0, len(s) - 1\n    while left < right:\n        s[left], s[right] = s[right], s[left]\n        left, right = left + 1, right - 1\n",
            "javascript": "function reverseString(s) {\n    let left = 0, right = s.length - 1;\n    while (left < right) {\n        [s[left], s[right]] = [s[right], s[left]];\n        left++;\n        right--;\n    }\n}\n",
            "explanation": "The algorithm follows a two-pointer approach. Initialize two pointers, `left` and `right`, at the beginning and end of the input array. Using a while loop, run until the `left` pointer is greater than or equal to the `right` pointer. In the loop, swap the elements at the `left` and `right` pointers. Increment the `left` pointer and decrement the `right` pointer. Repeat this process until the loop terminates, which means the entire string has been reversed."
        },
        "structure": {
            "c++": "void reverseString(vector<char>& s)  {\n    // Your code here\n}\n",
            "java": "public void reverseString(char[] s)  {\n    // Your code here\n}\n",
            "python": "def reverseString(s: list[str]) -> None:\n    # Your code here\n\n",
            "javascript": "function reverseString(s)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "void reverseString(vector<char>& s) {\n    int left = 0, right = s.size() - 1;\n    while (left < right) {\n        swap(s[left++], s[right--]);\n    }\n}",
            "java": "public void reverseString(char[] s) {\n    int left = 0, right = s.length - 1;\n    while (left < right) {\n        char temp = s[left];\n        s[left++] = s[right];\n        s[right--] = temp;\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    s =$args\n    reverseString(s)\n    print(s)",
            "javascript": "function main() {\n    const s = $args;\n    reverseString(s);\n    console.log(s);\n}"
        },
        "Qid": "344"
    },
    {
        "_id": {
            "$oid": "661ed6f7555605d7c127580c"
        },
        "title": "Reverse Vowels in a String",
        "description": "Given a string `s`, reverse only all the vowels in the string and return it. The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.",
        "example": "Example:\n\nInput: s = \"hello\"\nOutput: \"holle\"\n\nExplanation: The vowels in the string are 'e' and 'o'. Reversing them gives us the string \"holle\".",
        "level": "Easy",
        "tags": [
            "String",
            "Two Pointers"
        ],
        "test_cases": {
            "inputs": [
                "\"hello\"",
                "\"leetcode\"",
                "\"aA\"",
                "\"race car\"",
                "\"apple\"",
                "\"banana\"",
                "\"Abcde\"",
                "\"aeiou\"",
                "\"a\"",
                "\"\"",
                "\"AaEeIiOoUu\""
            ],
            "outputs": [
                "\"holle\"",
                "\"leotcede\"",
                "\"Aa\"",
                "\"rec a car\"",
                "\"eppla\"",
                "\"banane\"",
                "\"edcbA\"",
                "\"uoiea\"",
                "\"a\"",
                "\"\"",
                "\"UuOoIiEeAa\""
            ]
        },
        "sample_code": {
            "c++": "#include <algorithm>\n#include <string>\n\nstd::string reverseVowels(std::string s) {\n    int i = 0, j = s.size() - 1;\n    while (i < j) {\n        if (!isVowel(s[i])) {\n            i++;\n        } else if (!isVowel(s[j])) {\n            j--;\n        } else {\n            std::swap(s[i], s[j]);\n            i++;\n            j--;\n        }\n    }\n    return s;\n}\n\nbool isVowel(char c) {\n    c = std::tolower(c);\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n}\n",
            "java": "import java.util.HashSet;\nimport java.util.Set;\n\npublic String reverseVowels(String s) {\n    int i = 0, j = s.length() - 1;\n    char[] result = new char[s.length()];\n    Set<Character> vowels = new HashSet<>();\n    for (char c : \"aeiouAEIOU\".toCharArray()) {\n        vowels.add(c);\n    }\n    while (i <= j) {\n        char ci = s.charAt(i);\n        char cj = s.charAt(j);\n        if (!vowels.contains(ci)) {\n            result[i++] = ci;\n        } else if (!vowels.contains(cj)) {\n            result[j--] = cj;\n        } else {\n            result[i++] = cj;\n            result[j--] = ci;\n        }\n    }\n    return new String(result);\n}\n",
            "python": "def reverseVowels(s: str) -> str:\n    vowels = set('aeiouAEIOU')\n    s_list = list(s)\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s_list[i] not in vowels:\n            i += 1\n        elif s_list[j] not in vowels:\n            j -= 1\n        else:\n            s_list[i], s_list[j] = s_list[j], s_list[i]\n            i += 1\n            j -= 1\n    return ''.join(s_list)\n",
            "javascript": "function reverseVowels(s) {\n    const vowels = new Set('aeiouAEIOU');\n    let chars = Array.from(s);\n    let i = 0, j = s.length - 1;\n    while (i < j) {\n        if (!vowels.has(chars[i])) {\n            i++;\n        } else if (!vowels.has(chars[j])) {\n            j--;\n        } else {\n            [chars[i], chars[j]] = [chars[j], chars[i]];\n            i++;\n            j--;\n        }\n    }\n    return chars.join('');\n}\n",
            "explanation": "The algorithm uses two-pointer technique to iterate over the string from both the start and the end. It then checks if the characters at the pointers are vowels or not. If the characters are not vowels, the pointers move accordingly. If both characters are vowels, they are swapped and the pointers move forward. This process continues until the pointers meet in the middle of the string or cross each other. Finally, the modified string is returned."
        },
        "structure": {
            "c++": "#include <algorithm>\n#include <string>\n\nstd::string reverseVowels(std::string s)  {\n    // Your code here\n}\n",
            "java": "import java.util.HashSet;\nimport java.util.Set;\n\npublic String reverseVowels(String s)  {\n    // Your code here\n}\n",
            "python": "def reverseVowels(s: str) -> str:\n    # Your code here\n\n",
            "javascript": "function reverseVowels(s)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <algorithm>\n#include <string>\n\nstd::string reverseVowels(std::string s) {\n    int i = 0, j = s.size() - 1;\n    while (i < j) {\n        if (!isVowel(s[i])) {\n            i++;\n        } else if (!isVowel(s[j])) {\n            j--;\n        } else {\n            std::swap(s[i], s[j]);\n            i++;\n            j--;\n        }\n    }\n    return s;\n}\n\nbool isVowel(char c) {\n    c = std::tolower(c);\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n}\n\nint main() {\n    std::string s = $args;\n    std::string result = reverseVowels(s);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public String reverseVowels(String s) {\n    int i = 0, j = s.length() - 1;\n    char[] result = new char[s.length()];\n    Set<Character> vowels = new HashSet<>();\n    for (char c : \"aeiouAEIOU\".toCharArray()) {\n        vowels.add(c);\n    }\n    while (i <= j) {\n        char ci = s.charAt(i);\n        char cj = s.charAt(j);\n        if (!vowels.contains(ci)) {\n            result[i++] = ci;\n        } else if (!vowels.contains(cj)) {\n            result[j--] = cj;\n        } else {\n            result[i++] = cj;\n            result[j--] = ci;\n        }\n    }\n    return new String(result);\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = reverseVowels(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = reverseVowels(s);\n    console.log(result);\n}"
        },
        "Qid": "345"
    },
    {
        "_id": {
            "$oid": "661ed7c0555605d7c127580d"
        },
        "title": "Array Intersection",
        "description": "Given two integer arrays `nums1` and `nums2`, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.",
        "example": "Example:\n\nInput: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2]\n\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [9,4]\nExplanation: [4,9] is also accepted.",
        "level": "Easy",
        "tags": [
            "array",
            "intersection"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        2,
                        2,
                        1
                    ],
                    [
                        2,
                        2
                    ]
                ],
                [
                    [
                        4,
                        9,
                        5
                    ],
                    [
                        9,
                        4,
                        9,
                        8,
                        4
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1
                    ]
                ],
                [
                    [],
                    []
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    []
                ],
                [
                    [],
                    [
                        1,
                        2,
                        3
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        5,
                        4,
                        3,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1,
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1,
                        11,
                        12,
                        13,
                        14,
                        15,
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ]
            ],
            "outputs": [
                [
                    2
                ],
                [
                    9,
                    4
                ],
                [],
                [
                    1
                ],
                [],
                [],
                [],
                [],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <set>\n\nstd::vector<int> intersection(std::vector<int>& nums1, std::vector<int>& nums2) {\n    std::set<int> set1(nums1.begin(), nums1.end());\n    std::set<int> result;\n    for (int num : nums2) {\n        if (set1.count(num)) {\n            result.insert(num);\n        }\n    }\n    return std::vector<int>(result.begin(), result.end());\n}\n",
            "java": "import java.util.HashSet;\nimport java.util.Set;\n\npublic int[] intersection(int[] nums1, int[] nums2) {\n    Set<Integer> set1 = new HashSet<>();\n    for (int num : nums1) {\n        set1.add(num);\n    }\n    \n    Set<Integer> resultSet = new HashSet<>();\n    for (int num : nums2) {\n        if (set1.contains(num)) {\n            resultSet.add(num);\n        }\n    }\n    \n    int[] result = new int[resultSet.size()];\n    int i = 0;\n    for (int num : resultSet) {\n        result[i++] = num;\n    }\n    return result;\n}\n",
            "python": "def intersection(nums1, nums2):\n    set1 = set(nums1)\n    result = set1.intersection(nums2)\n    return list(result)\n",
            "javascript": "function intersection(nums1, nums2) {\n    const set1 = new Set(nums1);\n    const resultSet = new Set();\n\n    for (const num of nums2) {\n        if (set1.has(num)) {\n            resultSet.add(num);\n        }\n    }\n\n    return Array.from(resultSet);\n}\n\n",
            "explanation": "The function first creates a set `set1` from the first array `nums1`, which eliminates duplicate elements in it. Then, the function iterates through the second array `nums2`. For each element in `nums2`, it checks whether it exists in the `set1`. If so, this element is added to the result set `resultSet`. Finally, the result set is converted to an array and returned."
        },
        "structure": {
            "c++": "#include <vector>\n#include <set>\n\nstd::vector<int> intersection(std::vector<int>& nums1, std::vector<int>& nums2)  {\n    // Your code here\n}\n",
            "java": "import java.util.HashSet;\nimport java.util.Set;\n\npublic int[] intersection(int[] nums1, int[] nums2)  {\n    // Your code here\n}\n",
            "python": "def intersection(nums1, nums2):\n    # Your code here\n\n",
            "javascript": "function intersection(nums1, nums2)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <set>\n\nstd::vector<int> intersection(std::vector<int>& nums1, std::vector<int>& nums2) {\n    std::set<int> set1(nums1.begin(), nums1.end());\n    std::set<int> result;\n    for (int num : nums2) {\n        if (set1.count(num)) {\n            result.insert(num);\n        }\n    }\n    return std::vector<int>(result.begin(), result.end());\n}\n\nint main() {\n    std::vector<int> nums1 = $args;\n    std::vector<int> nums2 = $args;\n    std::vector<int> result = intersection(nums1, nums2);\n    for (int num : result) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}",
            "java": "public int[] intersection(int[] nums1, int[] nums2) {\n    Set<Integer> set1 = new HashSet<>();\n    for (int num : nums1) {\n        set1.add(num);\n    }\n    \n    Set<Integer> resultSet = new HashSet<>();\n    for (int num : nums2) {\n        if (set1.contains(num)) {\n            resultSet.add(num);\n        }\n    }\n    \n    int[] result = new int[resultSet.size()];\n    int i = 0;\n    for (int num : resultSet) {\n        result[i++] = num;\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    nums1 = inputs[0]\n    nums2 = inputs[1]\n    result = intersection(nums1, nums2)\n    print(result)",
            "javascript": "function main() {\n    const nums1 = $args[0];\n    const nums2 = $args[1];\n    const set1 = new Set(nums1);\n    const resultSet = new Set();\n\n    for (const num of nums2) {\n        if (set1.has(num)) {\n            resultSet.add(num);\n        }\n    }\n\n    const result = Array.from(resultSet);\n    console.log(result);\n}"
        },
        "Qid": "349"
    },
    {
        "_id": {
            "$oid": "661ed7c9555605d7c127580e"
        },
        "title": "Intersection of Two Arrays II",
        "description": "Given two integer arrays `nums1` and `nums2`, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.",
        "example": "Example 1:\n\nInput: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2,2]\n\nExample 2:\n\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [4,9]\nExplanation: [9,4] is also accepted.",
        "level": "Easy",
        "tags": [
            "array",
            "hash table",
            "two pointers",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        2,
                        2,
                        1
                    ],
                    [
                        2,
                        2
                    ]
                ],
                [
                    [
                        4,
                        9,
                        5
                    ],
                    [
                        9,
                        4,
                        9,
                        8,
                        4
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ]
                ],
                [
                    [],
                    []
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    []
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1,
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        15,
                        14,
                        13,
                        12,
                        11,
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        15,
                        14,
                        13,
                        12,
                        11,
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1,
                        16,
                        17,
                        18,
                        19,
                        20
                    ]
                ],
                [
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ],
                    [
                        5,
                        4,
                        3,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        1,
                        2,
                        2,
                        3,
                        3,
                        4,
                        4,
                        5,
                        5
                    ],
                    [
                        5,
                        4,
                        3,
                        2,
                        1,
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ]
            ],
            "outputs": [
                [
                    2,
                    2
                ],
                [
                    4,
                    9
                ],
                [],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [],
                [],
                [],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [],
                [],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [],
                [],
                [],
                [],
                [
                    1,
                    1,
                    2,
                    2,
                    3,
                    3,
                    4,
                    4,
                    5,
                    5
                ],
                [
                    1,
                    1,
                    2,
                    2,
                    3,
                    3,
                    4,
                    4,
                    5,
                    5
                ],
                [],
                []
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <unordered_map>\n\nstd::vector<int> intersect(std::vector<int>& nums1, std::vector<int>& nums2) {\n    std::unordered_map<int, int> count_map;\n    std::vector<int> result;\n    \n    for (int num : nums1) {\n        count_map[num]++;\n    }\n    \n    for (int num : nums2) {\n        if (count_map[num] > 0) {\n            result.push_back(num);\n            count_map[num]--;\n        }\n    }\n\n    return result;\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashMap;\n\npublic int[] intersect(int[] nums1, int[] nums2) {\n    HashMap<Integer, Integer> countMap = new HashMap<>();\n    ArrayList<Integer> result = new ArrayList<>();\n    \n    for (int num : nums1) {\n        countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n    }\n    \n    for (int num : nums2) {\n        if (countMap.getOrDefault(num, 0) > 0) {\n            result.add(num);\n            countMap.put(num, countMap.get(num) - 1);\n        }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n}\n\n",
            "python": "def intersect(nums1, nums2):\n    count_map = {}\n    result = []\n    \n    for num in nums1:\n        count_map[num] = count_map.get(num, 0) + 1\n    \n    for num in nums2:\n        if count_map.get(num, 0) > 0:\n            result.append(num)\n            count_map[num] -= 1\n\n    return result\n\n",
            "javascript": "function intersect(nums1, nums2) {\n    const countMap = {};\n    const result = [];\n    \n    for (const num of nums1) {\n        countMap[num] = (countMap[num] || 0) + 1;\n    }\n    \n    for (const num of nums2) {\n        if (countMap[num] > 0) {\n            result.push(num);\n            countMap[num]--;\n        }\n    }\n\n    return result;\n}\n\n",
            "explanation": "1. Create a hashmap (or dictionary) to count the occurrences of each integer in the first input array, nums1.\n2. Iterate through the second input array, nums2.\n   a. For each element in nums2, check if the element exists in the hashmap and has a count greater than 0.\n   b. If yes, append the element to the result array and decrement the count in the hashmap for that element.\n3. Return the result array containing the intersection elements."
        },
        "structure": {
            "c++": "#include <vector>\n#include <unordered_map>\n\nstd::vector<int> intersect(std::vector<int>& nums1, std::vector<int>& nums2)  {\n    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashMap;\n\npublic int[] intersect(int[] nums1, int[] nums2)  {\n    // Your code here\n}\n\n",
            "python": "def intersect(nums1, nums2):\n    # Your code here\n\n",
            "javascript": "function intersect(nums1, nums2)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <unordered_map>\n#include <iostream>\n\nint main() {\n    std::vector<int> nums1 = $args;\n    std::vector<int> nums2 = $args;\n    std::vector<int> result = intersect(nums1, nums2);\n    \n    for (int num : result) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}",
            "java": "public int[] intersect(int[] nums1, int[] nums2) {\n    HashMap<Integer, Integer> countMap = new HashMap<>();\n    ArrayList<Integer> result = new ArrayList<>();\n    \n    for (int num : nums1) {\n        countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n    }\n    \n    for (int num : nums2) {\n        if (countMap.getOrDefault(num, 0) > 0) {\n            result.add(num);\n            countMap.put(num, countMap.get(num) - 1);\n        }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n}\n",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    nums1 = inputs[0]\n    nums2 = inputs[1]\n    result = intersect(nums1, nums2)\n    print(result)",
            "javascript": "function main() {\n    const nums1 = $args[0];\n    const nums2 = $args[1];\n    const countMap = {};\n    const result = [];\n    \n    for (const num of nums1) {\n        countMap[num] = (countMap[num] || 0) + 1;\n    }\n    \n    for (const num of nums2) {\n        if (countMap[num] > 0) {\n            result.push(num);\n            countMap[num]--;\n        }\n    }\n\n    console.log(result);\n}"
        },
        "Qid": "350"
    },
    {
        "_id": {
            "$oid": "661ed8be555605d7c127580f"
        },
        "title": "Android Unlock Patterns",
        "description": "Android devices have a special lock screen with a `3 x 3` grid of dots. Users can set an 'unlock pattern' by connecting the dots in a specific sequence, forming a series of joined line segments where each segment's endpoints are two consecutive dots in the sequence. A sequence of `k` dots is a valid unlock pattern if both of the following are true:\n\n- All the dots in the sequence are distinct.\n- If the line segment connecting two consecutive dots in the sequence passes through the center of any other dot, the other dot must have previously appeared in the sequence. No jumps through the center non-selected dots are allowed.\n\nHere are some example valid and invalid unlock patterns:\n\n- The 1st pattern `[4,1,3,6]` is invalid because the line connecting dots `1` and `3` pass through dot `2`, but dot `2` did not previously appear in the sequence.\n- The 2nd pattern `[4,1,9,2]` is invalid because the line connecting dots `1` and `9` pass through dot `5`, but dot `5` did not previously appear in the sequence.\n- The 3rd pattern `[2,4,1,3,6]` is valid because it follows the conditions. The line connecting dots `1` and `3` meets the condition because dot `2` previously appeared in the sequence.\n- The 4th pattern `[6,5,4,1,9,2]` is valid because it follows the conditions. The line connecting dots `1` and `9` meets the condition because dot `5` previously appeared in the sequence.\n\nGiven two integers `m` and `n`, return the number of unique and valid unlock patterns of the Android grid lock screen that consist of at least `m` keys and at most `n` keys.\n\nTwo unlock patterns are considered unique if there is a dot in one sequence that is not in the other, or the order of the dots is different.",
        "example": "Example:\n\nInput: m = 1, n = 1\nOutput: 9\n\nInput: m = 1, n = 2\nOutput: 65",
        "level": "Medium",
        "tags": [
            "grid",
            "sequence",
            "combinations"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    1
                ],
                [
                    1,
                    2
                ],
                [
                    2,
                    2
                ],
                [
                    2,
                    3
                ],
                [
                    3,
                    3
                ],
                [
                    3,
                    4
                ],
                [
                    4,
                    4
                ],
                [
                    4,
                    5
                ],
                [
                    5,
                    5
                ],
                [
                    5,
                    6
                ],
                [
                    6,
                    6
                ],
                [
                    6,
                    7
                ],
                [
                    7,
                    7
                ],
                [
                    7,
                    8
                ],
                [
                    8,
                    8
                ],
                [
                    8,
                    9
                ],
                [
                    9,
                    9
                ],
                [
                    1,
                    9
                ],
                [
                    2,
                    9
                ],
                [
                    3,
                    9
                ]
            ],
            "outputs": [
                9,
                65,
                4,
                64,
                139,
                576,
                1206,
                3364,
                7140,
                14034,
                24640,
                38368,
                56100,
                79120,
                105136,
                135751,
                169344,
                389112,
                963504,
                1988736
            ]
        },
        "sample_code": {
            "c++": "int numberOfPatterns(int m, int n) {\n    const vector<vector<int>> jumps(10, vector<int>(10, 0));\n    jumps[1][3] = jumps[3][1] = 2;\n    jumps[1][7] = jumps[7][1] = 4;\n    jumps[3][9] = jumps[9][3] = 6;\n    jumps[7][9] = jumps[9][7] = 8;\n    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5;\n\n    vector<bool> visited(10, false);\n\n    int cnt = 0;\n    for (int i = m; i <= n; ++i) {\n        cnt += dfs(jumps, visited, 1, i - 1) * 4; // 1, 3, 7, 9\n        cnt += dfs(jumps, visited, 2, i - 1) * 4; // 2, 4, 6, 8\n        cnt += dfs(jumps, visited, 5, i - 1);     // 5\n    }\n\n    return cnt;\n}\n\nint dfs(const vector<vector<int>>& jumps, vector<bool>& visited, int curr, int remaining) {\n    if (remaining < 0) return 0;\n    if (remaining == 0) return 1;\n\n    visited[curr] = true;\n    int cnt = 0;\n    for (int next = 1; next <= 9; ++next) {\n        if (!visited[next] && (jumps[curr][next] == 0 || visited[jumps[curr][next]])) {\n            cnt += dfs(jumps, visited, next, remaining - 1);\n        }\n    }\n    visited[curr] = false;\n\n    return cnt;\n}\n\n",
            "java": "public int numberOfPatterns(int m, int n) {\n    int[][] jumps = new int[10][10];\n    jumps[1][3] = jumps[3][1] = 2;\n    jumps[1][7] = jumps[7][1] = 4;\n    jumps[3][9] = jumps[9][3] = 6;\n    jumps[7][9] = jumps[9][7] = 8;\n    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5;\n\n    boolean[] visited = new boolean[10];\n\n    int cnt = 0;\n    for (int i = m; i <= n; ++i) {\n        cnt += dfs(jumps, visited, 1, i - 1) * 4; // 1, 3, 7, 9\n        cnt += dfs(jumps, visited, 2, i - 1) * 4; // 2, 4, 6, 8\n        cnt += dfs(jumps, visited, 5, i - 1);     // 5\n    }\n\n    return cnt;\n}\n\nprivate int dfs(int[][] jumps, boolean[] visited, int curr, int remaining) {\n    if (remaining < 0) return 0;\n    if (remaining == 0) return 1;\n\n    visited[curr] = true;\n    int cnt = 0;\n    for (int next = 1; next <= 9; ++next) {\n        if (!visited[next] && (jumps[curr][next] == 0 || visited[jumps[curr][next]])) {\n            cnt += dfs(jumps, visited, next, remaining - 1);\n        }\n    }\n    visited[curr] = false;\n\n    return cnt;\n}\n\n",
            "python": "def numberOfPatterns(m: int, n: int) -> int:\n    def dfs(curr, remaining):\n        if remaining < 0:\n            return 0\n        if remaining == 0:\n            return 1\n\n        visited[curr] = True\n        cnt = 0\n        for next in range(1, 10):\n            if not visited[next] and (jumps[curr][next] == 0 or visited[jumps[curr][next]]):\n                cnt += dfs(next, remaining - 1)\n        visited[curr] = False\n\n        return cnt\n\n    jumps = [[0] * 10 for _ in range(10)]\n    jumps[1][3] = jumps[3][1] = 2\n    jumps[1][7] = jumps[7][1] = 4\n    jumps[3][9] = jumps[9][3] = 6\n    jumps[7][9] = jumps[9][7] = 8\n    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5\n\n    visited = [False] * 10\n\n    cnt = 0\n    for i in range(m, n + 1):\n        cnt += dfs(1, i - 1) * 4  # 1, 3, 7, 9\n        cnt += dfs(2, i - 1) * 4  # 2, 4, 6, 8\n        cnt += dfs(5, i - 1)      # 5\n\n    return cnt\n\n",
            "javascript": "var numberOfPatterns = function(m, n) {\n    const jumps = Array.from({length: 10}, () => Array(10).fill(0));\n    jumps[1][3] = jumps[3][1] = 2;\n    jumps[1][7] = jumps[7][1] = 4;\n    jumps[3][9] = jumps[9][3] = 6;\n    jumps[7][9] = jumps[9][7] = 8;\n    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5;\n\n    const visited = Array(10).fill(false);\n\n    let cnt = 0;\n    for (let i = m; i <= n; ++i) {\n        cnt += dfs(jumps, visited, 1, i - 1) * 4; // 1, 3, 7, 9\n        cnt += dfs(jumps, visited, 2, i - 1) * 4; // 2, 4, 6, 8\n        cnt += dfs(jumps, visited, 5, i - 1);     // 5\n    }\n\n    return cnt;\n};\n\nfunction dfs(jumps, visited, curr, remaining) {\n    if (remaining < 0) return 0;\n    if (remaining === 0) return 1;\n\n    visited[curr] = true;\n    let cnt = 0;\n    for (let next = 1; next <= 9; ++next) {\n        if (!visited[next] && (jumps[curr][next] === 0 || visited[jumps[curr][next]])) {\n            cnt += dfs(jumps, visited, next, remaining - 1);\n        }\n    }\n    visited[curr] = false;\n\n    return cnt;\n}\n\n",
            "explanation": "The algorithm starts with a depth-first search (DFS) approach to explore all the possible combinations of the unlock patterns. We create a `jumps` matrix to store the condition that if a line segment between any two points passes through another point, the number in the `jumps` matrix represents the middle point.\n\nThe DFS function starts at a certain point and recursively explores all the possible points that can be reached according to the rules. It keeps track of visited points using the `visited` array. The DFS function returns the count of valid patterns for the range of `m` to `n`.\n\nFor each iteration from `m` to `n`, we calculate the number of valid unlock patterns, and we multiply the results by 4 since the grid is symmetric (e.g., patterns starting with 1, 3, 7, 9 are equivalent, and patterns starting with 2, 4, 6, 8 are equivalent). We do this for each corner and side midpoints separately. Finally, we add the count for the center point (5), and return the total count."
        },
        "structure": {
            "c++": "int numberOfPatterns(int m, int n)  {\n    // Your code here\n}\n\n",
            "java": "public int numberOfPatterns(int m, int n)  {\n    // Your code here\n}\n\n",
            "python": "def numberOfPatterns(m: int, n: int) -> int:\n    # Your code here\n\n",
            "javascript": "var numberOfPatterns = function(m, n)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int m = $args;\n    int n = $args;\n    int result = numberOfPatterns(m, n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int numberOfPatterns(int m, int n) {\n    int[][] jumps = new int[10][10];\n    jumps[1][3] = jumps[3][1] = 2;\n    jumps[1][7] = jumps[7][1] = 4;\n    jumps[3][9] = jumps[9][3] = 6;\n    jumps[7][9] = jumps[9][7] = 8;\n    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5;\n\n    boolean[] visited = new boolean[10];\n\n    int cnt = 0;\n    for (int i = m; i <= n; ++i) {\n        cnt += dfs(jumps, visited, 1, i - 1) * 4; // 1, 3, 7, 9\n        cnt += dfs(jumps, visited, 2, i - 1) * 4; // 2, 4, 6, 8\n        cnt += dfs(jumps, visited, 5, i - 1);     // 5\n    }\n\n    return cnt;\n}\n\nprivate int dfs(int[][] jumps, boolean[] visited, int curr, int remaining) {\n    if (remaining < 0) return 0;\n    if (remaining == 0) return 1;\n\n    visited[curr] = true;\n    int cnt = 0;\n    for (int next = 1; next <= 9; ++next) {\n        if (!visited[next] && (jumps[curr][next] == 0 || visited[jumps[curr][next]])) {\n            cnt += dfs(jumps, visited, next, remaining - 1);\n        }\n    }\n    visited[curr] = false;\n\n    return cnt;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    m = inputs[0]\n    n = inputs[1]\n    result = numberOfPatterns(m, n)\n    print(result)",
            "javascript": "function numberOfPatterns(m, n) {\n    const jumps = Array.from({length: 10}, () => Array(10).fill(0));\n    jumps[1][3] = jumps[3][1] = 2;\n    jumps[1][7] = jumps[7][1] = 4;\n    jumps[3][9] = jumps[9][3] = 6;\n    jumps[7][9] = jumps[9][7] = 8;\n    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5;\n\n    const visited = Array(10).fill(false);\n\n    let cnt = 0;\n    for (let i = m; i <= n; ++i) {\n        cnt += dfs(jumps, visited, 1, i - 1) * 4; // 1, 3, 7, 9\n        cnt += dfs(jumps, visited, 2, i - 1) * 4; // 2, 4, 6, 8\n        cnt += dfs(jumps, visited, 5, i - 1);     // 5\n    }\n\n    return cnt;\n}\n\nfunction dfs(jumps, visited, curr, remaining) {\n    if (remaining < 0) return 0;\n    if (remaining === 0) return 1;\n\n    visited[curr] = true;\n    let cnt = 0;\n    for (let next = 1; next <= 9; ++next) {\n        if (!visited[next] && (jumps[curr][next] === 0 || visited[jumps[curr][next]])) {\n            cnt += dfs(jumps, visited, next, remaining - 1);\n        }\n    }\n    visited[curr] = false;\n\n    return cnt;\n}"
        },
        "Qid": "351"
    },
    {
        "_id": {
            "$oid": "661edb10555605d7c1275810"
        },
        "title": "Snake Game",
        "description": "Design a Snake game that is played on a device with screen size `height x width`. The snake is initially positioned at the top left corner `(0, 0)` with a length of `1` unit. You are given an array `food` where `food[i] = (ri, ci)` is the row and column position of a piece of food that the snake can eat. When a snake eats a piece of food, its length and the game's score both increase by `1`. Each piece of food appears one by one on the screen, meaning the second piece of food will not appear until the snake eats the first piece of food. When a piece of food appears on the screen, it is guaranteed that it will not appear on a block occupied by the snake. The game is over if the snake goes out of bounds (hits a wall) or if its head occupies a space that its body occupies after moving (i.e. a snake of length 4 cannot run into itself). Implement the `SnakeGame` class: `SnakeGame(int width, int height, int[][] food)` initializes the object with a screen of size `height x width` and the positions of the `food`. `int move(String direction)` returns the score of the game after applying one `direction` move by the snake. If the game is over, return `-1`.",
        "example": "SnakeGame snakeGame = new SnakeGame(3, 2, [[1, 2], [0, 1]]);\nsnakeGame.move(\"R\"); // return 0\nsnakeGame.move(\"D\"); // return 0\nsnakeGame.move(\"R\"); // return 1, snake eats the first piece of food. The second piece of food appears at (0, 1).\nsnakeGame.move(\"U\"); // return 1\nsnakeGame.move(\"L\"); // return 2, snake eats the second food. No more food appears.\nsnakeGame.move(\"U\"); // return -1, game over because snake collides with border",
        "level": "Medium",
        "tags": [
            "Array",
            "Simulation"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    2,
                    [
                        [
                            1,
                            2
                        ],
                        [
                            0,
                            1
                        ]
                    ],
                    "R"
                ],
                [
                    3,
                    2,
                    [
                        [
                            1,
                            2
                        ],
                        [
                            0,
                            1
                        ]
                    ],
                    "D"
                ],
                [
                    3,
                    2,
                    [
                        [
                            1,
                            2
                        ],
                        [
                            0,
                            1
                        ]
                    ],
                    "R"
                ],
                [
                    3,
                    2,
                    [
                        [
                            1,
                            2
                        ],
                        [
                            0,
                            1
                        ]
                    ],
                    "U"
                ],
                [
                    3,
                    2,
                    [
                        [
                            1,
                            2
                        ],
                        [
                            0,
                            1
                        ]
                    ],
                    "L"
                ],
                [
                    3,
                    2,
                    [
                        [
                            1,
                            2
                        ],
                        [
                            0,
                            1
                        ]
                    ],
                    "U"
                ],
                [
                    3,
                    2,
                    [
                        [
                            1,
                            2
                        ],
                        [
                            0,
                            1
                        ]
                    ],
                    "R"
                ],
                [
                    3,
                    2,
                    [
                        [
                            1,
                            2
                        ],
                        [
                            0,
                            1
                        ]
                    ],
                    "D"
                ],
                [
                    3,
                    2,
                    [
                        [
                            1,
                            2
                        ],
                        [
                            0,
                            1
                        ]
                    ],
                    "R"
                ],
                [
                    3,
                    2,
                    [
                        [
                            1,
                            2
                        ],
                        [
                            0,
                            1
                        ]
                    ],
                    "U"
                ],
                [
                    3,
                    2,
                    [
                        [
                            1,
                            2
                        ],
                        [
                            0,
                            1
                        ]
                    ],
                    "L"
                ],
                [
                    3,
                    2,
                    [
                        [
                            1,
                            2
                        ],
                        [
                            0,
                            1
                        ]
                    ],
                    "U"
                ],
                [
                    3,
                    2,
                    [
                        [
                            1,
                            2
                        ],
                        [
                            0,
                            1
                        ]
                    ],
                    "R"
                ],
                [
                    3,
                    2,
                    [
                        [
                            1,
                            2
                        ],
                        [
                            0,
                            1
                        ]
                    ],
                    "D"
                ],
                [
                    3,
                    2,
                    [
                        [
                            1,
                            2
                        ],
                        [
                            0,
                            1
                        ]
                    ],
                    "R"
                ],
                [
                    3,
                    2,
                    [
                        [
                            1,
                            2
                        ],
                        [
                            0,
                            1
                        ]
                    ],
                    "U"
                ],
                [
                    3,
                    2,
                    [
                        [
                            1,
                            2
                        ],
                        [
                            0,
                            1
                        ]
                    ],
                    "L"
                ],
                [
                    3,
                    2,
                    [
                        [
                            1,
                            2
                        ],
                        [
                            0,
                            1
                        ]
                    ],
                    "U"
                ],
                [
                    3,
                    2,
                    [
                        [
                            1,
                            2
                        ],
                        [
                            0,
                            1
                        ]
                    ],
                    "R"
                ],
                [
                    3,
                    2,
                    [
                        [
                            1,
                            2
                        ],
                        [
                            0,
                            1
                        ]
                    ],
                    "D"
                ]
            ],
            "outputs": [
                0,
                0,
                1,
                1,
                2,
                -1,
                0,
                0,
                1,
                1,
                2,
                -1,
                0,
                0,
                1,
                1,
                2,
                -1,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "#include <list>\n#include <unordered_set>\n#include <vector>\n\nclass SnakeGame {\npublic:\n    SnakeGame(int width, int height, std::vector<std::vector<int>>& food)\n        : width(width), height(height), food(food), pos(0), score(0) {\n        snake.push_back({0, 0});\n        occupied.insert(0);\n    }\n\n    int move(std::string direction) {\n        int new_x = snake.back().first + dx[direction];\n        int new_y = snake.back().second + dy[direction];\n\n        if (new_x < 0 || new_x >= height || new_y < 0 || new_y >= width) {\n            return -1;\n        }\n\n        std::pair<int, int> new_head = std::make_pair(new_x, new_y);\n        std::pair<int, int> tail = snake.front();\n\n        if (pos < food.size() && food[pos][0] == new_x && food[pos][1] == new_y) {\n            score++;\n            pos++;\n        } else {\n            snake.pop_front();\n            occupied.erase(tail.first * width + tail.second);\n        }\n\n        if (occupied.count(new_head.first * width + new_head.second)) {\n            return -1;\n        }\n\n        snake.push_back(new_head);\n        occupied.insert(new_head.first * width + new_head.second);\n        return score;\n    }\n\nprivate:\n    int width;\n    int height;\n    std::vector<std::vector<int>> food;\n    int pos;\n    int score;\n    std::list<std::pair<int, int>> snake;\n    std::unordered_set<int> occupied;\n    std::unordered_map<std::string, int> dx = {{\"U\", -1}, {\"D\", 1}, {\"L\", 0}, {\"R\", 0}};\n    std::unordered_map<std::string, int> dy = {{\"U\", 0}, {\"D\", 0}, {\"L\", -1}, {\"R\", 1}};\n};\n",
            "java": "import java.util.*;\n\nclass SnakeGame {\n    private int width, height, pos, score;\n    private int[][] food;\n    private LinkedList<int[]> snake;\n    private Set<String> occupied;\n\n    public SnakeGame(int width, int height, int[][] food) {\n        this.width = width;\n        this.height = height;\n        this.food = food;\n        pos = 0;\n        score = 0;\n        snake = new LinkedList<>();\n        occupied = new HashSet<>();\n        snake.add(new int[]{0, 0});\n        occupied.add(\"0_0\");\n    }\n\n    public int move(String direction) {\n        int newX = snake.peekLast()[0] + dx.get(direction);\n        int newY = snake.peekLast()[1] + dy.get(direction);\n\n        if (newX < 0 || newX >= height || newY < 0 || newY >= width) {\n            return -1;\n        }\n\n        int[] newHead = new int[]{newX, newY};\n        int[] tail = snake.poll();\n\n        if (pos < food.length && food[pos][0] == newX && food[pos][1] == newY) {\n            score++;\n            pos++;\n        } else {\n            occupied.remove(tail[0] + \"_\" + tail[1]);\n        }\n\n        if (occupied.contains(newX + \"_\" + newY)) {\n            return -1;\n        }\n\n        snake.add(newHead);\n        occupied.add(newX + \"_\" + newY);\n        return score;\n    }\n\n    private static final Map<String, Integer> dx = Map.of(\"U\", -1, \"D\", 1, \"L\", 0, \"R\", 0);\n    private static final Map<String, Integer> dy = Map.of(\"U\", 0, \"D\", 0, \"L\", -1, \"R\", 1);\n}\n",
            "python": "from collections import deque\nfrom typing import List\n\nclass SnakeGame:\n    def __init__(self, width: int, height: int, food: List[List[int]]):\n        self.width = width\n        self.height = height\n        self.food = food\n        self.pos = 0\n        self.score = 0\n        self.snake = deque([(0, 0)])\n        self.occupied = {(0, 0)}\n        self.dx = {'U': -1, 'D': 1, 'L': 0, 'R': 0}\n        self.dy = {'U': 0, 'D': 0, 'L': -1, 'R': 1}\n\n    def move(self, direction: str) -> int:\n        new_x = self.snake[-1][0] + self.dx[direction]\n        new_y = self.snake[-1][1] + self.dy[direction]\n\n        if new_x < 0 or new_x >= self.height or new_y < 0 or new_y >= self.width:\n            return -1\n\n        new_head = (new_x, new_y)\n        tail = self.snake.popleft()\n\n        if self.pos < len(self.food) and self.food[self.pos] == list(new_head):\n            self.score += 1\n            self.pos += 1\n        else:\n            self.occupied.remove(tail)\n\n        if new_head in self.occupied:\n            return -1\n\n        self.snake.append(new_head)\n        self.occupied.add(new_head)\n        return self.score\n",
            "javascript": "class SnakeGame {\n    constructor(width, height, food) {\n        this.width = width;\n        this.height = height;\n        this.food = food;\n        this.pos = 0;\n        this.score = 0;\n        this.snake = [[0, 0]];\n        this.occupied = new Set(['0_0']);\n        this.dx = {'U': -1, 'D': 1, 'L': 0, 'R': 0};\n        this.dy = {'U': 0, 'D': 0, 'L': -1, 'R': 1};\n    }\n\n    move(direction) {\n        let newX = this.snake[this.snake.length - 1][0] + this.dx[direction];\n        let newY = this.snake[this.snake.length - 1][1] + this.dy[direction];\n\n        if (newX < 0 || newX >= this.height || newY < 0 || newY >= this.width) {\n            return -1;\n        }\n\n        let newHead = [newX, newY];\n        let tail = this.snake.shift();\n\n        if (this.pos < this.food.length && this.food[this.pos][0] === newX && this.food[this.pos][1] === newY) {\n            this.score++;\n            this.pos++;\n        } else {\n            this.occupied.delete(tail[0] + '_' + tail[1]);\n        }\n\n        if (this.occupied.has(newX + '_' + newY)) {\n            return -1;\n        }\n\n        this.snake.push(newHead);\n        this.occupied.add(newX + '_' + newY);\n        return this.score;\n    }\n}\n",
            "explanation": "1. Initialize variables width, height, food, pos (food position), score, snake deque with initial position (0, 0), occupied set with initial position, dx and dy dictionary to update coordinate values based on given direction.\n2. In the move method, calculate the next possible coordinates new_x and new_y using dx and dy dictionary.\n3. Check if the new_x and new_y are out of the boundary, if yes then return -1 as it's a game over.\n4. Check if the new position matches with food, if yes then update the score and increment the pos otherwise remove the tail block from the snake and occupied set.\n5. If new_head is already in the occupied set, return -1, Because after moving the snake is colliding itself.\n6. Otherwise, add the new_head in the snake deque and occupied set then return the current score."
        },
        "structure": {
            "c++": "# {include <list>\n#include <unordered_set>\n#include <vector>\n\nclass SnakeGame \n    // Your code here\n};\n",
            "java": "i {mport java.util.*;\n\nclass SnakeGame \n    // Your code here\n}\n",
            "python": "from collections import deque\n    # Your code here\n\n",
            "javascript": "c {lass SnakeGame \n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int width = $args;\n    int height = $args;\n    std::vector<std::vector<int>> food = $args;\n\n    SnakeGame game(width, height, food);\n\n    std::string direction;\n    while (std::cin >> direction) {\n        int result = game.move(direction);\n        std::cout << result << std::endl;\n    }\n\n    return 0;\n}",
            "java": "public int move(String direction)",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    width = inputs[0]\n    height =inputs[1]\n    food = inputs[2]\n    game = SnakeGame(width, height, food)\n    directions = inputs[3]\n    result = []\n    for direction in directions:\n        score = game.move(direction)\n        result.append(score)\n    print(result)",
            "javascript": "function main() {\n    const width = $args[0];\n    const height = $args[1];\n    const food = $args[2];\n\n    const game = new SnakeGame(width, height, food);\n    const direction = $args[3];\n    const result = game.move(direction);\n\n    console.log(result);\n}"
        },
        "Qid": "353"
    },
    {
        "_id": {
            "$oid": "661edb54555605d7c1275811"
        },
        "title": "Russian Doll Envelopes",
        "description": "You are given a 2D array of integers `envelopes` where `envelopes[i] = [wi, hi]` represents the width and the height of an envelope. One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height. Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other). Note: You cannot rotate an envelope.",
        "example": "Example:\n\nInput: envelopes = [[5,4],[6,4],[6,7],[2,3]]\nOutput: 3\nExplanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        5,
                        4
                    ],
                    [
                        6,
                        4
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        2,
                        3
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        1
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        3
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ]
                ],
                [
                    [
                        4,
                        4
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ]
                ],
                [
                    [
                        5,
                        5
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ]
                ],
                [
                    [
                        6,
                        6
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ]
                ],
                [
                    [
                        7,
                        7
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ]
                ],
                [
                    [
                        8,
                        8
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ]
                ],
                [
                    [
                        9,
                        9
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ]
                ],
                [
                    [
                        10,
                        10
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ]
                ],
                [
                    [
                        11,
                        11
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ]
                ],
                [
                    [
                        12,
                        12
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        1,
                        1
                    ]
                ]
            ],
            "outputs": [
                3,
                1,
                4,
                2,
                1,
                1,
                2,
                1,
                2,
                1,
                2,
                1,
                2,
                1,
                2,
                1,
                2,
                1,
                2,
                1
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\n\nint maxEnvelopes(std::vector<std::vector<int>>& envelopes) {\n    std::sort(envelopes.begin(), envelopes.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];\n    });\n    \n    std::vector<int> dp;\n    for (const auto& envelope : envelopes) {\n        auto it = std::lower_bound(dp.begin(), dp.end(), envelope[1]);\n        if (it == dp.end()) {\n            dp.push_back(envelope[1]);\n        } else {\n            *it = envelope[1];\n        }\n    }\n    \n    return dp.size();\n}\n",
            "java": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic int maxEnvelopes(int[][] envelopes) {\n    Arrays.sort(envelopes, new Comparator<int[]>() {\n        public int compare(int[] a, int[] b) {\n            return a[0] == b[0] ? b[1] - a[1] : a[0] - b[0];\n        }\n    });\n\n    int[] dp = new int[envelopes.length];\n    int len = 0;\n    for (int[] envelope : envelopes) {\n        int idx = Arrays.binarySearch(dp, 0, len, envelope[1]);\n        if (idx < 0) {\n            idx = -(idx + 1);\n        }\n        dp[idx] = envelope[1];\n        if (idx == len) {\n            len++;\n        }\n    }\n\n    return len;\n}\n",
            "python": "from bisect import bisect_left\n\ndef max_envelopes(envelopes):\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = []\n    \n    for _, h in envelopes:\n        idx = bisect_left(dp, h)\n        if idx == len(dp):\n            dp.append(h)\n        else:\n            dp[idx] = h\n\n    return len(dp)\n",
            "javascript": "function maxEnvelopes(envelopes) {\n    envelopes.sort((a, b) => a[0] === b[0] ? b[1] - a[1] : a[0] - b[0]);\n    const dp = [];\n\n    for (const envelope of envelopes) {\n        const idx = lowerBound(dp, envelope[1]);\n        if (idx === dp.length) {\n            dp.push(envelope[1]);\n        } else {\n            dp[idx] = envelope[1];\n        }\n    }\n\n    return dp.length;\n\n    function lowerBound(arr, target) {\n        let low = 0, high = arr.length;\n        while (low < high) {\n            const mid = Math.floor((low + high) / 2);\n            if (arr[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n}\n",
            "explanation": "1. Sort the envelopes based on width and in ascending order. If the widths are equal, sort by height in descending order.\n2. Create an empty list `dp` to maintain the increasing subsequence.\n3. Iterate through the sorted envelopes and for each envelope, find the index of the height in `dp` with binary search. If the index is equal to the length of `dp`, append the height to `dp`. Otherwise, replace the element at the index in `dp` with the current height.\n4. The length of `dp` will be the maximum number of envelopes that can be put one inside the other."
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\n\nint maxEnvelopes(std::vector<std::vector<int>>& envelopes)  {\n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic int maxEnvelopes(int[][] envelopes)  {\n    // Your code here\n}\n",
            "python": "from bisect import bisect_left\n    # Your code here\n\n",
            "javascript": "function maxEnvelopes(envelopes)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nint maxEnvelopes(std::vector<std::vector<int>>& envelopes) {\n    std::sort(envelopes.begin(), envelopes.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];\n    });\n    \n    std::vector<int> dp;\n    for (const auto& envelope : envelopes) {\n        auto it = std::lower_bound(dp.begin(), dp.end(), envelope[1]);\n        if (it == dp.end()) {\n            dp.push_back(envelope[1]);\n        } else {\n            *it = envelope[1];\n        }\n    }\n    \n    return dp.size();\n}\n\nint main() {\n    std::vector<std::vector<int>> envelopes = $args;\n    int result = maxEnvelopes(envelopes);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int maxEnvelopes(int[][] envelopes) {\n    Arrays.sort(envelopes, new Comparator<int[]>() {\n        public int compare(int[] a, int[] b) {\n            return a[0] == b[0] ? b[1] - a[1] : a[0] - b[0];\n        }\n    });\n\n    int[] dp = new int[envelopes.length];\n    int len = 0;\n    for (int[] envelope : envelopes) {\n        int idx = Arrays.binarySearch(dp, 0, len, envelope[1]);\n        if (idx < 0) {\n            idx = -(idx + 1);\n        }\n        dp[idx] = envelope[1];\n        if (idx == len) {\n            len++;\n        }\n    }\n\n    return len;\n}",
            "python": "if __name__ == \"__main__\":\n    envelopes = $args\n    result = max_envelopes(envelopes)\n    print(result)",
            "javascript": "function main() {\n    const envelopes = $args;\n    envelopes.sort((a, b) => a[0] === b[0] ? b[1] - a[1] : a[0] - b[0]);\n    const dp = [];\n\n    for (const envelope of envelopes) {\n        const idx = lowerBound(dp, envelope[1]);\n        if (idx === dp.length) {\n            dp.push(envelope[1]);\n        } else {\n            dp[idx] = envelope[1];\n        }\n    }\n\n    return dp.length;\n\n    function lowerBound(arr, target) {\n        let low = 0, high = arr.length;\n        while (low < high) {\n            const mid = Math.floor((low + high) / 2);\n            if (arr[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n}"
        },
        "Qid": "354"
    },
    {
        "_id": {
            "$oid": "66205cc28257d25e0805c75e"
        },
        "title": "Symmetric Reflection",
        "description": "Given `n` points on a 2D plane, determine if there exists a line parallel to the y-axis that reflects the given points symmetrically. In other words, check if there is a line such that after reflecting all points over the line, the original points' set is the same as the reflected ones. Note that there can be repeated points.",
        "example": "Example:\n\nInput: points = [[1,1],[-1,1]]\nOutput: true\nExplanation: We can choose the line x = 0.",
        "level": "Medium",
        "tags": [
            "geometry",
            "reflection",
            "symmetry"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        1
                    ],
                    [
                        -1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        -1,
                        -1
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        -1,
                        -1
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        -1,
                        -1
                    ],
                    [
                        -2,
                        -2
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ]
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "bool isReflected(vector<vector<int>>& points) {\n    int minX = INT_MAX;\n    int maxX = INT_MIN;\n\n    unordered_set<string> pointSet;\n    for(const auto& point : points) {\n        minX = min(minX, point[0]);\n        maxX = max(maxX, point[0]);\n        pointSet.insert(to_string(point[0]) + \",\" + to_string(point[1]));\n    }\n\n    int sum = minX + maxX;\n    for(const auto& point : points) {\n        if(!pointSet.count(to_string(sum - point[0]) + \",\" + to_string(point[1]))) {\n            return false;\n        }\n    }\n\n    return true;\n}\n",
            "java": "public boolean isReflected(int[][] points) {\n    int minX = Integer.MAX_VALUE;\n    int maxX = Integer.MIN_VALUE;\n    Set<String> pointSet = new HashSet<>();\n\n    for (int[] point : points) {\n        minX = Math.min(minX, point[0]);\n        maxX = Math.max(maxX, point[0]);\n        pointSet.add(point[0] + \",\" + point[1]);\n    }\n\n    int sum = minX + maxX;\n    for (int[] point : points) {\n        if (!pointSet.contains((sum - point[0]) + \",\" + point[1])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n",
            "python": "def isReflected(points):\n    min_x = min(point[0] for point in points)\n    max_x = max(point[0] for point in points)\n    point_set = {(point[0], point[1]) for point in points}\n    \n    sum_x = min_x + max_x\n    for point in points:\n        if (sum_x - point[0], point[1]) not in point_set:\n            return False\n\n    return True\n",
            "javascript": "function isReflected(points) {\n    let minX = Infinity;\n    let maxX = -Infinity;\n    const pointSet = new Set();\n\n    for (const point of points) {\n        minX = Math.min(minX, point[0]);\n        maxX = Math.max(maxX, point[0]);\n        pointSet.add(point[0] + \",\" + point[1]);\n    }\n\n    const sum = minX + maxX;\n    for (const point of points) {\n        if (!pointSet.has((sum - point[0]) + \",\" + point[1])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n",
            "explanation": "1. Iterate through the points and find the minimum and maximum x coordinates. Also, save all points as string (x,y) in a set.\n2. Calculate the sum of min_x and max_x (this will give the x-coordinate of the line of reflection).\n3. Iterate through the points again and check if the reflection point is in the set of points (using the calculated sum from step 2).\n4. If all reflection points exist in the set, return true. Otherwise, return false."
        },
        "structure": {
            "c++": "bool isReflected(vector<vector<int>>& points)  {\n    // Your code here\n}\n",
            "java": "public boolean isReflected(int[][] points)  {\n    // Your code here\n}\n",
            "python": "def isReflected(points):\n    # Your code here\n\n",
            "javascript": "function isReflected(points)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "bool isReflected(vector<vector<int>>& points) {\n    int minX = INT_MAX;\n    int maxX = INT_MIN;\n\n    unordered_set<string> pointSet;\n    for(const auto& point : points) {\n        minX = min(minX, point[0]);\n        maxX = max(maxX, point[0]);\n        pointSet.insert(to_string(point[0]) + \",\" + to_string(point[1]));\n    }\n\n    int sum = minX + maxX;\n    for(const auto& point : points) {\n        if(!pointSet.count(to_string(sum - point[0]) + \",\" + to_string(point[1]))) {\n            return false;\n        }\n    }\n\n    return true;\n}",
            "java": "public boolean isReflected(int[][] points) {\n    int minX = Integer.MAX_VALUE;\n    int maxX = Integer.MIN_VALUE;\n    Set<String> pointSet = new HashSet<>();\n\n    for (int[] point : points) {\n        minX = Math.min(minX, point[0]);\n        maxX = Math.max(maxX, point[0]);\n        pointSet.add(point[0] + \",\" + point[1]);\n    }\n\n    int sum = minX + maxX;\n    for (int[] point : points) {\n        if (!pointSet.contains((sum - point[0]) + \",\" + point[1])) {\n            return false;\n        }\n    }\n\n    return true;\n}",
            "python": "if __name__ == \"__main__\":\n    points = $args[0]\n    result = isReflected(points)\n    print(result)",
            "javascript": "function main() {\n    const points = $args;\n    const result = isReflected(points);\n    console.log(result);\n}"
        },
        "Qid": "356"
    },
    {
        "_id": {
            "$oid": "66205d478257d25e0805c75f"
        },
        "title": "Count of Numbers with Unique Digits",
        "description": "Given an integer `n`, return the count of all numbers with unique digits, `x`, where `0 <= x < 10n`. A number is considered to have unique digits if all the digits in the number are different from each other. For example, the number 123 has unique digits, but the number 122 does not have unique digits.",
        "example": "Example 1:\n\nInput: n = 2\nOutput: 91\nExplanation: The answer should be the total numbers in the range of 0 <= x < 100, excluding 11, 22, 33, 44, 55, 66, 77, 88, 99\n\nExample 2:\n\nInput: n = 0\nOutput: 1",
        "level": "Easy",
        "tags": [
            "Math",
            "Numbers"
        ],
        "test_cases": {
            "inputs": [
                2,
                0,
                1,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "outputs": [
                91,
                1,
                10,
                739,
                5275,
                32491,
                168571,
                712891,
                2345851
            ]
        },
        "sample_code": {
            "c++": "int countNumbersWithUniqueDigits(int n) {\n    if (n == 0) return 1;\n    \n    int total = 10;\n    int uniqueDigits = 9;\n    int currentAvailableDigits = 9;\n    \n    while(n-- > 1 && currentAvailableDigits > 0) {\n        uniqueDigits *= currentAvailableDigits;\n        total += uniqueDigits;\n        currentAvailableDigits--;\n    }\n    \n    return total;\n}\n\n",
            "java": "public int countNumbersWithUniqueDigits(int n) {\n    if (n == 0) return 1;\n\n    int total = 10;\n    int uniqueDigits = 9;\n    int currentAvailableDigits = 9;\n\n    while (n-- > 1 && currentAvailableDigits > 0) {\n        uniqueDigits *= currentAvailableDigits;\n        total += uniqueDigits;\n        currentAvailableDigits--;\n    }\n\n    return total;\n}\n\n",
            "python": "def countNumbersWithUniqueDigits(n):\n    if n == 0:\n        return 1\n    \n    total = 10\n    unique_digits = 9\n    current_available_digits = 9\n    \n    while n > 1 and current_available_digits > 0:\n        unique_digits *= current_available_digits\n        total += unique_digits\n        current_available_digits -= 1\n        n -= 1\n        \n    return total\n\n",
            "javascript": "function countNumbersWithUniqueDigits(n) {\n    if (n === 0) return 1;\n\n    let total = 10;\n    let uniqueDigits = 9;\n    let currentAvailableDigits = 9;\n\n    while (n-- > 1 && currentAvailableDigits > 0) {\n        uniqueDigits *= currentAvailableDigits;\n        total += uniqueDigits;\n        currentAvailableDigits--;\n    }\n\n    return total;\n}\n\n",
            "explanation": "The algorithm starts with a base case when n=0, the result is 1, as there's only one number, 0, that has unique digits.\n\nFor other cases, it initializes total count to 10 (0 to 9), the unique digit count to 9, and the available digits count to 9. Then, it iterates until n becomes 1 or the available digits count becomes 0. In each iteration, the unique digit count is multiplied by the available digit count, which is then added to the total count. The available digit count is decremented in each iteration, as there will be one less digit to choose from to keep the numbers unique.\n\nAt the end, the total count is returned."
        },
        "structure": {
            "c++": "int countNumbersWithUniqueDigits(int n)  {\n    // Your code here\n}\n\n",
            "java": "public int countNumbersWithUniqueDigits(int n)  {\n    // Your code here\n}\n\n",
            "python": "def countNumbersWithUniqueDigits(n):\n    # Your code here\n\n",
            "javascript": "function countNumbersWithUniqueDigits(n)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n = $args;\n    int result = countNumbersWithUniqueDigits(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int countNumbersWithUniqueDigits(int n) {\n    if (n == 0) return 1;\n\n    int total = 10;\n    int uniqueDigits = 9;\n    int currentAvailableDigits = 9;\n\n    while (n-- > 1 && currentAvailableDigits > 0) {\n        uniqueDigits *= currentAvailableDigits;\n        total += uniqueDigits;\n        currentAvailableDigits--;\n    }\n\n    return total;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = countNumbersWithUniqueDigits(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = countNumbersWithUniqueDigits(n);\n    console.log(result);\n}"
        },
        "Qid": "357"
    },
    {
        "_id": {
            "$oid": "66205da48257d25e0805c760"
        },
        "title": "Quadratic Function Application",
        "description": "Given a sorted integer array `nums` and three integers `a`, `b`, and `c`, apply a quadratic function of the form `f(x) = ax^2 + bx + c` to each element `nums[i]` in the array, and return the array in sorted order.",
        "example": "Example:\n\nInput: nums = [-4,-2,2,4], a = 1, b = 3, c = 5\nOutput: [3,9,15,33]\n\nExplanation: Applying the quadratic function to each element in the array results in [1+3+5, 4+6+5, 16+12+5, 36+12+5] = [9, 15, 33, 53]. Sorting the array gives the final output [3, 9, 15, 33].",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        -4,
                        -2,
                        2,
                        4
                    ],
                    1,
                    3,
                    5
                ],
                [
                    [
                        -4,
                        -2,
                        2,
                        4
                    ],
                    -1,
                    3,
                    5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    2,
                    1,
                    0
                ],
                [
                    [
                        0,
                        0,
                        0,
                        0
                    ],
                    0,
                    0,
                    0
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    0,
                    0,
                    1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1,
                    0,
                    0
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    0,
                    1,
                    0
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1,
                    1,
                    1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    -1,
                    -1,
                    -1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    2,
                    -1,
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    -2,
                    1,
                    -3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1,
                    -2,
                    1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    -1,
                    2,
                    -1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    2,
                    2,
                    2
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    -2,
                    -2,
                    -2
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    0,
                    0,
                    0
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1,
                    0,
                    1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    0,
                    1,
                    1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1,
                    1,
                    0
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    -1,
                    -1,
                    0
                ]
            ],
            "outputs": [
                [
                    3,
                    9,
                    15,
                    33
                ],
                [
                    -23,
                    -5,
                    1,
                    7
                ],
                [
                    2,
                    5,
                    10,
                    17,
                    26
                ],
                [
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    3,
                    5,
                    7,
                    9,
                    11
                ],
                [
                    -3,
                    -3,
                    -3,
                    -3,
                    -3
                ],
                [
                    1,
                    0,
                    3,
                    10,
                    21
                ],
                [
                    -3,
                    -1,
                    1,
                    5,
                    11
                ],
                [
                    1,
                    0,
                    1,
                    4,
                    9
                ],
                [
                    -3,
                    -1,
                    1,
                    5,
                    11
                ],
                [
                    6,
                    8,
                    12,
                    20,
                    30
                ],
                [
                    -6,
                    -8,
                    -12,
                    -20,
                    -30
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    2,
                    3,
                    4,
                    5,
                    6
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ]
            ]
        },
        "sample_code": {
            "c++": "vector<int> sortTransformedArray(vector<int>& nums, int a, int b, int c) {\n    vector<int> result(nums.size());\n    int i = 0, j = nums.size() - 1, index = (a >= 0) ? nums.size() - 1 : 0;\n    \n    while (i <= j) {\n        int left = nums[i] * nums[i] * a + nums[i] * b + c;\n        int right = nums[j] * nums[j] * a + nums[j] * b + c;\n        \n        if (a >= 0) {\n            if (left >= right) {\n                result[index--] = left;\n                i++;\n            } else {\n                result[index--] = right;\n                j--;\n            }\n        } else {\n            if (left <= right) {\n                result[index++] = left;\n                i++;\n            } else {\n                result[index++] = right;\n                j--;\n            }\n        }\n    }\n    return result;\n}\n",
            "java": "public int[] sortTransformedArray(int[] nums, int a, int b, int c) {\n    int[] result = new int[nums.length];\n    int i = 0, j = nums.length - 1, index = (a >= 0) ? nums.length - 1 : 0;\n    \n    while (i <= j) {\n        int left = nums[i] * nums[i] * a + nums[i] * b + c;\n        int right = nums[j] * nums[j] * a + nums[j] * b + c;\n        \n        if (a >= 0) {\n            if (left >= right) {\n                result[index--] = left;\n                i++;\n            } else {\n                result[index--] = right;\n                j--;\n            }\n        } else {\n            if (left <= right) {\n                result[index++] = left;\n                i++;\n            } else {\n                result[index++] = right;\n                j--;\n            }\n        }\n    }\n    return result;\n}\n",
            "python": "def sort_transformed_array(nums, a, b, c):\n    result = [0] * len(nums)\n    i, j = 0, len(nums) - 1\n    index = len(nums) - 1 if a >= 0 else 0\n    \n    while i <= j:\n        left = nums[i] * nums[i] * a + nums[i] * b + c\n        right = nums[j] * nums[j] * a + nums[j] * b + c\n        \n        if a >= 0:\n            if left >= right:\n                result[index] = left\n                index -= 1\n                i += 1\n            else:\n                result[index] = right\n                index -= 1\n                j -= 1\n        else:\n            if left <= right:\n                result[index] = left\n                index += 1\n                i += 1\n            else:\n                result[index] = right\n                index += 1\n                j -= 1\n    return result\n",
            "javascript": "function sortTransformedArray(nums, a, b, c) {\n    let result = new Array(nums.length);\n    let i = 0, j = nums.length - 1;\n    let index = (a >= 0) ? nums.length - 1 : 0;\n    \n    while (i <= j) {\n        let left = nums[i] * nums[i] * a + nums[i] * b + c;\n        let right = nums[j] * nums[j] * a + nums[j] * b + c;\n        \n        if (a >= 0) {\n            if (left >= right) {\n                result[index--] = left;\n                i++;\n            } else {\n                result[index--] = right;\n                j--;\n            }\n        } else {\n            if (left <= right) {\n                result[index++] = left;\n                i++;\n            } else {\n                result[index++] = right;\n                j--;\n            }\n        }\n    }\n    return result;\n}\n\n",
            "explanation": "The given sorted array needs to be transformed by applying the given quadratic function: f(x) = ax^2 + bx + c. We need to return the new array in sorted order. To solve this problem in O(n) time, we utilize a two-pointer technique. Initialize pointers, i and j, at the beginning and end of the array. Depending on whether the given coefficient 'a' is positive or negative, we'll determine how the values are sorted after transformation when calculated from left or right of the array.\n\nIf 'a' is positive or zero, the parabola of the quadratic function opens upward, meaning larger x values will yield a higher f(x). So, we traverse the array, compare the quadratic function at the indices i and j, and fill the result array from the end to the beginning. If the value at i is greater, store it at current index index, decrement index, and increment i. If value at j is greater or equal, store it and decrement j and index.\n\nOn the other hand, if 'a' is negative, the parabola opens downward, meaning smaller x values will yield a higher f(x). In this case, compare the quadratic function at the indices i and j, fill the result array from the beginning to the end. If the value at i is smaller or equal, store it at current index index, increment index and i. If value at j is smaller, store it and decrement j, then increment index. Once i > j, the result array is fully filled with the sorted transformed values."
        },
        "structure": {
            "c++": "vector<int> sortTransformedArray(vector<int>& nums, int a, int b, int c)  {\n    // Your code here\n}\n",
            "java": "public int[] sortTransformedArray(int[] nums, int a, int b, int c)  {\n    // Your code here\n}\n",
            "python": "def sort_transformed_array(nums, a, b, c):\n    # Your code here\n\n",
            "javascript": "function sortTransformedArray(nums, a, b, c)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "vector<int> sortTransformedArray(vector<int>& nums, int a, int b, int c) {\n    vector<int> result(nums.size());\n    int i = 0, j = nums.size() - 1, index = (a >= 0) ? nums.size() - 1 : 0;\n    \n    while (i <= j) {\n        int left = nums[i] * nums[i] * a + nums[i] * b + c;\n        int right = nums[j] * nums[j] * a + nums[j] * b + c;\n        \n        if (a >= 0) {\n            if (left >= right) {\n                result[index--] = left;\n                i++;\n            } else {\n                result[index--] = right;\n                j--;\n            }\n        } else {\n            if (left <= right) {\n                result[index++] = left;\n                i++;\n            } else {\n                result[index++] = right;\n                j--;\n            }\n        }\n    }\n    return result;\n}",
            "java": "public int[] sortTransformedArray(int[] nums, int a, int b, int c) {\n    int[] result = new int[nums.length];\n    int i = 0, j = nums.length - 1, index = (a >= 0) ? nums.length - 1 : 0;\n    \n    while (i <= j) {\n        int left = nums[i] * nums[i] * a + nums[i] * b + c;\n        int right = nums[j] * nums[j] * a + nums[j] * b + c;\n        \n        if (a >= 0) {\n            if (left >= right) {\n                result[index--] = left;\n                i++;\n            } else {\n                result[index--] = right;\n                j--;\n            }\n        } else {\n            if (left <= right) {\n                result[index++] = left;\n                i++;\n            } else {\n                result[index++] = right;\n                j--;\n            }\n        }\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    nums = inputs[0]\n    a = inputs[1]\n    b = inputs[2]\n    c = inputs[3]\n    result = sort_transformed_array(nums, a, b, c)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args[0];\n    const a = $args[1];\n    const b = $args[2];\n    const c = $args[3];\n    const result = sortTransformedArray(nums, a, b, c);\n    console.log(result);\n}"
        },
        "Qid": "360"
    },
    {
        "_id": {
            "$oid": "66205dbf8257d25e0805c761"
        },
        "title": "Maximum Enemies to Kill",
        "description": "Given an `m x n` matrix `grid` where each cell is either a wall 'W', an enemy 'E' or empty '0', return the maximum enemies you can kill using one bomb. You can only place the bomb in an empty cell.\n\nThe bomb kills all the enemies in the same row and column from the planted point until it hits the wall since it is too strong to be destroyed.",
        "example": "Example:\n\nInput: grid = [['0', 'E', '0', '0'], ['E', '0', 'W', 'E'], ['0', 'E', '0', '0']]\nOutput: 3\n\nExplanation: The bomb can be placed at (1, 2) to kill 3 enemies in the same row and column.\n\nInput: grid = [['W', 'W', 'W'], ['0', '0', '0'], ['E', 'E', 'E']]\nOutput: 1\n\nExplanation: The bomb can be placed at (1, 1) to kill 1 enemy in the same row and column.",
        "level": "Medium",
        "tags": [
            "matrix",
            "grid",
            "bomb",
            "maximum",
            "enemies"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "0",
                        "E",
                        "0",
                        "0"
                    ],
                    [
                        "E",
                        "0",
                        "W",
                        "E"
                    ],
                    [
                        "0",
                        "E",
                        "0",
                        "0"
                    ]
                ],
                [
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "E",
                        "E",
                        "E"
                    ]
                ],
                [
                    [
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "0",
                        "0",
                        "0"
                    ]
                ],
                [
                    [
                        "E",
                        "E",
                        "E"
                    ],
                    [
                        "E",
                        "E",
                        "E"
                    ],
                    [
                        "E",
                        "E",
                        "E"
                    ]
                ],
                [
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "W",
                        "W"
                    ]
                ],
                [
                    [
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "0",
                        "E",
                        "0"
                    ],
                    [
                        "0",
                        "0",
                        "0"
                    ]
                ],
                [
                    [
                        "E",
                        "E",
                        "E"
                    ],
                    [
                        "E",
                        "0",
                        "E"
                    ],
                    [
                        "E",
                        "E",
                        "E"
                    ]
                ],
                [
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "0",
                        "W"
                    ],
                    [
                        "W",
                        "W",
                        "W"
                    ]
                ],
                [
                    [
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "0",
                        "E",
                        "0"
                    ]
                ],
                [
                    [
                        "E",
                        "E",
                        "E"
                    ],
                    [
                        "E",
                        "E",
                        "E"
                    ],
                    [
                        "E",
                        "0",
                        "E"
                    ]
                ],
                [
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "0",
                        "W"
                    ]
                ],
                [
                    [
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "0",
                        "0",
                        "E"
                    ]
                ],
                [
                    [
                        "E",
                        "E",
                        "E"
                    ],
                    [
                        "E",
                        "E",
                        "E"
                    ],
                    [
                        "0",
                        "E",
                        "E"
                    ]
                ],
                [
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "0",
                        "W",
                        "W"
                    ]
                ],
                [
                    [
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "E",
                        "0",
                        "0"
                    ]
                ],
                [
                    [
                        "E",
                        "E",
                        "E"
                    ],
                    [
                        "E",
                        "E",
                        "E"
                    ],
                    [
                        "E",
                        "0",
                        "0"
                    ]
                ],
                [
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "0",
                        "0"
                    ]
                ],
                [
                    [
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "0",
                        "0",
                        "0"
                    ],
                    [
                        "0",
                        "0",
                        "W"
                    ]
                ],
                [
                    [
                        "E",
                        "E",
                        "E"
                    ],
                    [
                        "E",
                        "E",
                        "E"
                    ],
                    [
                        "E",
                        "E",
                        "0"
                    ]
                ],
                [
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "W",
                        "W",
                        "0"
                    ]
                ]
            ],
            "outputs": [
                3,
                1,
                0,
                9,
                0,
                1,
                8,
                0,
                1,
                7,
                0,
                1,
                6,
                0,
                1,
                5,
                0,
                1,
                4,
                0
            ]
        },
        "sample_code": {
            "c++": "int maxKilledEnemies(vector<vector<char>>& grid) {\n    if (grid.empty()) return 0;\n    int m = grid.size(), n = grid[0].size(), result = 0, rowhits = 0;\n    vector<int> colhits(n, 0);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (j == 0 || grid[i][j - 1] == 'W') {\n                rowhits = 0;\n                for (int k = j; k < n && grid[i][k] != 'W'; k++)\n                    rowhits += grid[i][k] == 'E';\n            }\n            if (i == 0 || grid[i - 1][j] == 'W') {\n                colhits[j] = 0;\n                for (int k = i; k < m && grid[k][j] != 'W'; k++)\n                    colhits[j] += grid[k][j] == 'E';\n            }\n            if (grid[i][j] == '0') result = max(result, rowhits + colhits[j]);\n        }\n    }\n    return result;\n}\n",
            "java": "public int maxKilledEnemies(char[][] grid) {\n    if (grid.length == 0) return 0;\n    int m = grid.length, n = grid[0].length, result = 0, rowhits;\n    int[] colhits = new int[n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (j == 0 || grid[i][j-1] == 'W') {\n                rowhits = 0;\n                for (int k = j; k < n && grid[i][k] != 'W'; k++)\n                    rowhits += grid[i][k] == 'E' ? 1 : 0;\n            }\n            if (i == 0 || grid[i-1][j] == 'W') {\n                colhits[j] = 0;\n                for (int k = i; k < m && grid[k][j] != 'W'; k++)\n                    colhits[j] += grid[k][j] == 'E' ? 1 : 0;\n            }\n            if (grid[i][j] == '0') result = Math.max(result, rowhits + colhits[j]);\n        }\n    }\n    return result;\n}\n",
            "python": "def maxKilledEnemies(grid):\n    if not grid: return 0\n    m, n, result, rowhits = len(grid), len(grid[0]), 0, 0\n    colhits = [0] * n\n    for i in range(m):\n        for j in range(n):\n            if j == 0 or grid[i][j - 1] == 'W':\n                rowhits = 0\n                k = j\n                while k < n and grid[i][k] != 'W':\n                    rowhits += grid[i][k] == 'E'\n                    k += 1\n            if i == 0 or grid[i - 1][j] == 'W':\n                colhits[j] = 0\n                k = i\n                while k < m and grid[k][j] != 'W':\n                    colhits[j] += grid[k][j] == 'E'\n                    k += 1\n            if grid[i][j] == '0':\n                result = max(result, rowhits + colhits[j])\n    return result\n",
            "javascript": "function maxKilledEnemies(grid) {\n    if (!grid.length) return 0;\n    let m = grid.length, n = grid[0].length, result = 0, rowhits;\n    let colhits = new Array(n).fill(0);\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (j === 0 || grid[i][j - 1] === 'W') {\n                rowhits = 0;\n                for (let k = j; k < n && grid[i][k] !== 'W'; k++)\n                    rowhits += grid[i][k] === 'E' ? 1 : 0;\n            }\n            if (i === 0 || grid[i - 1][j] === 'W') {\n                colhits[j] = 0;\n                for (let k = i; k < m && grid[k][j] !== 'W'; k++)\n                    colhits[j] += grid[k][j] === 'E' ? 1 : 0;\n            }\n            if (grid[i][j] === '0') result = Math.max(result, rowhits + colhits[j]);\n        }\n    }\n    return result;\n}\n",
            "explanation": "Initialize `result` to keep track of the maximum number of enemies that can be killed. Then, initialize `rowhits` and `colhits` to store the number of enemies in the current row and column.\n\nLoop through the `grid`. When you start a new row or encounter a wall in the previous cell, reset `rowhits` and count the number of enemies in the row. If you are in the first row, or encounter a wall in the cell above, reset the `colhits` for that column and count the number of enemies in the column.\n \nIf you encounter an empty cell, update the `result` with the maximum of its current value and the sum of `rowhits` and `colhits` for that position.\n\nReturn `result`."
        },
        "structure": {
            "c++": "int maxKilledEnemies(vector<vector<char>>& grid)  {\n    // Your code here\n}\n",
            "java": "public int maxKilledEnemies(char[][] grid)  {\n    // Your code here\n}\n",
            "python": "def maxKilledEnemies(grid):\n    # Your code here\n\n",
            "javascript": "function maxKilledEnemies(grid)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int maxKilledEnemies(vector<vector<char>>& grid) {\n    if (grid.empty()) return 0;\n    int m = grid.size(), n = grid[0].size(), result = 0, rowhits = 0;\n    vector<int> colhits(n, 0);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (j == 0 || grid[i][j - 1] == 'W') {\n                rowhits = 0;\n                for (int k = j; k < n && grid[i][k] != 'W'; k++)\n                    rowhits += grid[i][k] == 'E';\n            }\n            if (i == 0 || grid[i - 1][j] == 'W') {\n                colhits[j] = 0;\n                for (int k = i; k < m && grid[k][j] != 'W'; k++)\n                    colhits[j] += grid[k][j] == 'E';\n            }\n            if (grid[i][j] == '0') result = max(result, rowhits + colhits[j]);\n        }\n    }\n    return result;\n}",
            "java": "public int maxKilledEnemies(char[][] grid) {\n    if (grid.length == 0) return 0;\n    int m = grid.length, n = grid[0].length, result = 0, rowhits;\n    int[] colhits = new int[n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (j == 0 || grid[i][j-1] == 'W') {\n                rowhits = 0;\n                for (int k = j; k < n && grid[i][k] != 'W'; k++)\n                    rowhits += grid[i][k] == 'E' ? 1 : 0;\n            }\n            if (i == 0 || grid[i-1][j] == 'W') {\n                colhits[j] = 0;\n                for (int k = i; k < m && grid[k][j] != 'W'; k++)\n                    colhits[j] += grid[k][j] == 'E' ? 1 : 0;\n            }\n            if (grid[i][j] == '0') result = Math.max(result, rowhits + colhits[j]);\n        }\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    grid = $args\n    result = maxKilledEnemies(grid)\n    print(result)",
            "javascript": "function maxKilledEnemies(grid) {\n    if (!grid.length) return 0;\n    let m = grid.length, n = grid[0].length, result = 0, rowhits;\n    let colhits = new Array(n).fill(0);\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (j === 0 || grid[i][j - 1] === 'W') {\n                rowhits = 0;\n                for (let k = j; k < n && grid[i][k] !== 'W'; k++)\n                    rowhits += grid[i][k] === 'E' ? 1 : 0;\n            }\n            if (i === 0 || grid[i - 1][j] === 'W') {\n                colhits[j] = 0;\n                for (let k = i; k < m && grid[k][j] !== 'W'; k++)\n                    colhits[j] += grid[k][j] === 'E' ? 1 : 0;\n            }\n            if (grid[i][j] === '0') result = Math.max(result, rowhits + colhits[j]);\n        }\n    }\n    return result;\n}"
        },
        "Qid": "361"
    },
    {
        "_id": {
            "$oid": "66205dfa8257d25e0805c762"
        },
        "title": "Nested List Weight Sum",
        "description": "You are given a nested list of integers `nestedList`. Each element is either an integer or a list whose elements may also be integers or other lists.\n\nThe depth of an integer is the number of lists that it is inside of. For example, the nested list `[1,[2,2],[[3],2],1]` has each integer's value set to its depth. Let `maxDepth` be the maximum depth of any integer.\n\nThe weight of an integer is `maxDepth - (the depth of the integer) + 1`.\n\nReturn the sum of each integer in `nestedList` multiplied by its weight.",
        "example": "Example:\n\nInput: nestedList = [[1,1],2,[1,1]]\nOutput: 8\nExplanation: Four 1's with a weight of 1, one 2 with a weight of 2.\n1*1 + 1*1 + 2*2 + 1*1 + 1*1 = 8",
        "level": "Medium",
        "tags": [
            "nested list",
            "depth",
            "weight",
            "sum"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        1
                    ],
                    2,
                    [
                        1,
                        1
                    ]
                ],
                [
                    1,
                    [
                        4,
                        [
                            6
                        ]
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    4,
                    [
                        5,
                        [
                            6,
                            7
                        ]
                    ]
                ],
                [
                    [
                        1,
                        [
                            2,
                            [
                                3,
                                [
                                    4
                                ]
                            ]
                        ]
                    ],
                    5
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    4,
                    [
                        5,
                        [
                            6,
                            [
                                7,
                                [
                                    8
                                ]
                            ]
                        ]
                    ]
                ],
                [
                    [
                        1,
                        [
                            2,
                            [
                                3,
                                [
                                    4,
                                    [
                                        5
                                    ]
                                ]
                            ]
                        ]
                    ],
                    6
                ],
                [
                    [
                        1,
                        [
                            2,
                            [
                                3,
                                [
                                    4,
                                    [
                                        5,
                                        [
                                            6
                                        ]
                                    ]
                                ]
                            ]
                        ]
                    ],
                    7
                ],
                [
                    [
                        1,
                        [
                            2,
                            [
                                3,
                                [
                                    4,
                                    [
                                        5,
                                        [
                                            6,
                                            [
                                                7
                                            ]
                                        ]
                                    ]
                                ]
                            ]
                        ]
                    ],
                    8
                ],
                [
                    [
                        1,
                        [
                            2,
                            [
                                3,
                                [
                                    4,
                                    [
                                        5,
                                        [
                                            6,
                                            [
                                                7,
                                                [
                                                    8
                                                ]
                                            ]
                                        ]
                                    ]
                                ]
                            ]
                        ]
                    ],
                    9
                ],
                [
                    [
                        1,
                        [
                            2,
                            [
                                3,
                                [
                                    4,
                                    [
                                        5,
                                        [
                                            6,
                                            [
                                                7,
                                                [
                                                    8,
                                                    [
                                                        9
                                                    ]
                                                ]
                                            ]
                                        ]
                                    ]
                                ]
                            ]
                        ]
                    ],
                    10
                ],
                [
                    [
                        1,
                        [
                            2,
                            [
                                3,
                                [
                                    4,
                                    [
                                        5,
                                        [
                                            6,
                                            [
                                                7,
                                                [
                                                    8,
                                                    [
                                                        9,
                                                        [
                                                            10
                                                        ]
                                                    ]
                                                ]
                                            ]
                                        ]
                                    ]
                                ]
                            ]
                        ]
                    ],
                    11
                ],
                [
                    [
                        1,
                        [
                            2,
                            [
                                3,
                                [
                                    4,
                                    [
                                        5,
                                        [
                                            6,
                                            [
                                                7,
                                                [
                                                    8,
                                                    [
                                                        9,
                                                        [
                                                            10,
                                                            [
                                                                11
                                                            ]
                                                        ]
                                                    ]
                                                ]
                                            ]
                                        ]
                                    ]
                                ]
                            ]
                        ]
                    ],
                    12
                ],
                [
                    [
                        1,
                        [
                            2,
                            [
                                3,
                                [
                                    4,
                                    [
                                        5,
                                        [
                                            6,
                                            [
                                                7,
                                                [
                                                    8,
                                                    [
                                                        9,
                                                        [
                                                            10,
                                                            [
                                                                11,
                                                                [
                                                                    12
                                                                ]
                                                            ]
                                                        ]
                                                    ]
                                                ]
                                            ]
                                        ]
                                    ]
                                ]
                            ]
                        ]
                    ],
                    13
                ],
                [
                    [
                        1,
                        [
                            2,
                            [
                                3,
                                [
                                    4,
                                    [
                                        5,
                                        [
                                            6,
                                            [
                                                7,
                                                [
                                                    8,
                                                    [
                                                        9,
                                                        [
                                                            10,
                                                            [
                                                                11,
                                                                [
                                                                    12,
                                                                    [
                                                                        13
                                                                    ]
                                                                ]
                                                            ]
                                                        ]
                                                    ]
                                                ]
                                            ]
                                        ]
                                    ]
                                ]
                            ]
                        ]
                    ],
                    14
                ],
                [
                    [
                        1,
                        [
                            2,
                            [
                                3,
                                [
                                    4,
                                    [
                                        5,
                                        [
                                            6,
                                            [
                                                7,
                                                [
                                                    8,
                                                    [
                                                        9,
                                                        [
                                                            10,
                                                            [
                                                                11,
                                                                [
                                                                    12,
                                                                    [
                                                                        13,
                                                                        [
                                                                            14
                                                                        ]
                                                                    ]
                                                                ]
                                                            ]
                                                        ]
                                                    ]
                                                ]
                                            ]
                                        ]
                                    ]
                                ]
                            ]
                        ]
                    ],
                    15
                ],
                [
                    [
                        1,
                        [
                            2,
                            [
                                3,
                                [
                                    4,
                                    [
                                        5,
                                        [
                                            6,
                                            [
                                                7,
                                                [
                                                    8,
                                                    [
                                                        9,
                                                        [
                                                            10,
                                                            [
                                                                11,
                                                                [
                                                                    12,
                                                                    [
                                                                        13,
                                                                        [
                                                                            14,
                                                                            [
                                                                                15
                                                                            ]
                                                                        ]
                                                                    ]
                                                                ]
                                                            ]
                                                        ]
                                                    ]
                                                ]
                                            ]
                                        ]
                                    ]
                                ]
                            ]
                        ]
                    ],
                    16
                ],
                [
                    [
                        1,
                        [
                            2,
                            [
                                3,
                                [
                                    4,
                                    [
                                        5,
                                        [
                                            6,
                                            [
                                                7,
                                                [
                                                    8,
                                                    [
                                                        9,
                                                        [
                                                            10,
                                                            [
                                                                11,
                                                                [
                                                                    12,
                                                                    [
                                                                        13,
                                                                        [
                                                                            14,
                                                                            [
                                                                                15,
                                                                                [
                                                                                    16
                                                                                ]
                                                                            ]
                                                                        ]
                                                                    ]
                                                                ]
                                                            ]
                                                        ]
                                                    ]
                                                ]
                                            ]
                                        ]
                                    ]
                                ]
                            ]
                        ]
                    ],
                    17
                ],
                [
                    [
                        1,
                        [
                            2,
                            [
                                3,
                                [
                                    4,
                                    [
                                        5,
                                        [
                                            6,
                                            [
                                                7,
                                                [
                                                    8,
                                                    [
                                                        9,
                                                        [
                                                            10,
                                                            [
                                                                11,
                                                                [
                                                                    12,
                                                                    [
                                                                        13,
                                                                        [
                                                                            14,
                                                                            [
                                                                                15,
                                                                                [
                                                                                    16,
                                                                                    [
                                                                                        17
                                                                                    ]
                                                                                ]
                                                                            ]
                                                                        ]
                                                                    ]
                                                                ]
                                                            ]
                                                        ]
                                                    ]
                                                ]
                                            ]
                                        ]
                                    ]
                                ]
                            ]
                        ]
                    ],
                    18
                ],
                [
                    [
                        1,
                        [
                            2,
                            [
                                3,
                                [
                                    4,
                                    [
                                        5,
                                        [
                                            6,
                                            [
                                                7,
                                                [
                                                    8,
                                                    [
                                                        9,
                                                        [
                                                            10,
                                                            [
                                                                11,
                                                                [
                                                                    12,
                                                                    [
                                                                        13,
                                                                        [
                                                                            14,
                                                                            [
                                                                                15,
                                                                                [
                                                                                    16,
                                                                                    [
                                                                                        17,
                                                                                        [
                                                                                            18
                                                                                        ]
                                                                                    ]
                                                                                ]
                                                                            ]
                                                                        ]
                                                                    ]
                                                                ]
                                                            ]
                                                        ]
                                                    ]
                                                ]
                                            ]
                                        ]
                                    ]
                                ]
                            ]
                        ]
                    ],
                    19
                ],
                [
                    [
                        1,
                        [
                            2,
                            [
                                3,
                                [
                                    4,
                                    [
                                        5,
                                        [
                                            6,
                                            [
                                                7,
                                                [
                                                    8,
                                                    [
                                                        9,
                                                        [
                                                            10,
                                                            [
                                                                11,
                                                                [
                                                                    12,
                                                                    [
                                                                        13,
                                                                        [
                                                                            14,
                                                                            [
                                                                                15,
                                                                                [
                                                                                    16,
                                                                                    [
                                                                                        17,
                                                                                        [
                                                                                            18,
                                                                                            [
                                                                                                19
                                                                                            ]
                                                                                        ]
                                                                                    ]
                                                                                ]
                                                                            ]
                                                                        ]
                                                                    ]
                                                                ]
                                                            ]
                                                        ]
                                                    ]
                                                ]
                                            ]
                                        ]
                                    ]
                                ]
                            ]
                        ]
                    ],
                    20
                ]
            ],
            "outputs": [
                8,
                17,
                55,
                15,
                110,
                21,
                140,
                36,
                220,
                55,
                286,
                78,
                455,
                105,
                650,
                153,
                880,
                210,
                1155,
                276
            ]
        },
        "sample_code": {
            "c++": "#include <variant>\n#include <vector>\n\nusing NestedInteger = std::variant<int, std::vector<std::variant<int, std::vector<NestedInteger>>>>;\n\nint sumHelper(NestedInteger& nested, int depth) {\n    int sum = 0;\n    if (auto pInt = std::get_if<int>(&nested)) {\n        sum += depth * (*pInt);\n    } else {\n        auto& list = std::get<std::vector<NestedInteger>>(nested);\n        for (auto& element : list) {\n            sum += sumHelper(element, depth - 1);\n        }\n    }\n    return sum;\n}\n\nint maxDepth(NestedInteger& nested) {\n    if (std::holds_alternative<int>(nested)) return 0;\n    int depth = 1;\n    for (auto& element : std::get<std::vector<NestedInteger>>(nested)) {\n        depth = std::max(depth, 1 + maxDepth(element));\n    }\n    return depth;\n}\n\nint depthSumInverse(std::vector<NestedInteger>& nestedList) {\n    int max_depth = 1;\n    for (auto& nested : nestedList) {\n        max_depth = std::max(max_depth, 1 + maxDepth(nested));\n    }\n    int sum = 0;\n    for (auto& nested : nestedList) {\n        sum += sumHelper(nested, max_depth);\n    }\n    return sum;\n}\n",
            "java": "import java.util.*;\n\npublic int depthSumInverse(List<NestedInteger> nestedList) {\n    int maxDepth = maxDepth(nestedList);\n    return sumHelper(nestedList, maxDepth);\n}\n\nprivate int maxDepth(List<NestedInteger> nestedList) {\n    int depth = 1;\n    for (NestedInteger nested : nestedList) {\n        if (!nested.isInteger()) {\n            depth = Math.max(depth, 1 + maxDepth(nested.getList()));\n        }\n    }\n    return depth;\n}\n\nprivate int sumHelper(List<NestedInteger> nestedList, int depth) {\n    int sum = 0;\n    for (NestedInteger nested : nestedList) {\n        if (nested.isInteger()) {\n            sum += depth * nested.getInteger();\n        } else {\n            sum += sumHelper(nested.getList(), depth - 1);\n        }\n    }\n    return sum;\n}\n",
            "python": "from typing import List, Union\n\nNestedInteger = Union[int, List[Union[int, \"NestedInteger\"]]]\n\ndef depthSumInverse(nestedList: List[NestedInteger]) -> int:\n    max_depth = max_depth_helper(nestedList)\n    return sum_helper(nestedList, max_depth)\n\ndef max_depth_helper(nested_list: List[NestedInteger]) -> int:\n    depth = 1\n    for nested in nested_list:\n        if isinstance(nested, list):\n            depth = max(depth, 1 + max_depth_helper(nested))\n    return depth\n\ndef sum_helper(nested_list: List[NestedInteger], depth: int) -> int:\n    sum = 0\n    for nested in nested_list:\n        if isinstance(nested, int):\n            sum += depth * nested\n        else:\n            sum += sum_helper(nested, depth - 1)\n    return sum\n",
            "javascript": "function depthSumInverse(nestedList) {\n    function maxDepthHelper(nestedList) {\n        let depth = 1;\n        for (let nested of nestedList) {\n            if (Array.isArray(nested)) {\n                depth = Math.max(depth, 1 + maxDepthHelper(nested));\n            }\n        }\n        return depth;\n    }\n    function sumHelper(nestedList, depth) {\n        let sum = 0;\n        for (let nested of nestedList) {\n            if (typeof nested === \"number\") {\n                sum += depth * nested;\n            } else {\n                sum += sumHelper(nested, depth - 1);\n            }\n        }\n        return sum;\n    }\n    let maxDepth = maxDepthHelper(nestedList);\n    return sumHelper(nestedList, maxDepth);\n}\n",
            "explanation": "1. First, we find the maximum depth of the integers in the input nestedList using a helper function maxDepthHelper by recursively going through all elements in nestedList. For every sublist encountered, we update the depth to the maximum depth found so far.\n2. Then, we compute the weighted sum of all integers in the nestedList by calling another helper function sumHelper. sumHelper goes through every element in nestedList and, for each integer, it calculates the weighted sum by multiplying the integer value with its corresponding weight (which is maxDepth - currentDepth + 1).\n3. Finally, the main function returns the total weighted sum obtained in the previous step.\n\nTime complexity: O(N) where N is the total number of elements (integers and nested lists) in the input nestedList. In each recursive call, we process a single element.\nSpace complexity: O(D) where D is the maximum depth of integers found in the nestedList. This is for the recursive call stack."
        },
        "structure": {
            "c++": "#include <variant>\n#include <vector>\n\nusing NestedInteger = std::variant<int, std::vector<std::variant<int, std::vector<NestedInteger>>>>;\n\nint sumHelper(NestedInteger& nested, int depth)  {\n    // Your code here\n}\n",
            "java": "import java.util.*;\n\npublic int depthSumInverse(List<NestedInteger> nestedList)  {\n    // Your code here\n}\n",
            "python": "from typing import List, Union\n    # Your code here\n\n",
            "javascript": "function depthSumInverse(nestedList)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <variant>\n#include <vector>\n\nusing NestedInteger = std::variant<int, std::vector<std::variant<int, std::vector<NestedInteger>>>>;\n\nint sumHelper(NestedInteger& nested, int depth) {\n    int sum = 0;\n    if (auto pInt = std::get_if<int>(&nested)) {\n        sum += depth * (*pInt);\n    } else {\n        auto& list = std::get<std::vector<NestedInteger>>(nested);\n        for (auto& element : list) {\n            sum += sumHelper(element, depth - 1);\n        }\n    }\n    return sum;\n}\n\nint maxDepth(NestedInteger& nested) {\n    if (std::holds_alternative<int>(nested)) return 0;\n    int depth = 1;\n    for (auto& element : std::get<std::vector<NestedInteger>>(nested)) {\n        depth = std::max(depth, 1 + maxDepth(element));\n    }\n    return depth;\n}\n\nint depthSumInverse(std::vector<NestedInteger>& nestedList) {\n    int max_depth = 1;\n    for (auto& nested : nestedList) {\n        max_depth = std::max(max_depth, 1 + maxDepth(nested));\n    }\n    int sum = 0;\n    for (auto& nested : nestedList) {\n        sum += sumHelper(nested, max_depth);\n    }\n    return sum;\n}\n\nint main() {\n    std::vector<NestedInteger> nestedList = $args;\n    int result = depthSumInverse(nestedList);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int depthSumInverse(List<NestedInteger> nestedList) {\n    int maxDepth = maxDepth(nestedList);\n    return sumHelper(nestedList, maxDepth);\n}\n\nprivate int maxDepth(List<NestedInteger> nestedList) {\n    int depth = 1;\n    for (NestedInteger nested : nestedList) {\n        if (!nested.isInteger()) {\n            depth = Math.max(depth, 1 + maxDepth(nested.getList()));\n        }\n    }\n    return depth;\n}\n\nprivate int sumHelper(List<NestedInteger> nestedList, int depth) {\n    int sum = 0;\n    for (NestedInteger nested : nestedList) {\n        if (nested.isInteger()) {\n            sum += depth * nested.getInteger();\n        } else {\n            sum += sumHelper(nested.getList(), depth - 1);\n        }\n    }\n    return sum;\n}",
            "python": "if __name__ == \"__main__\":\n    nestedList = $args\n    result = depthSumInverse(nestedList)\n    print(result)",
            "javascript": "function depthSumInverse(nestedList) {\n    function maxDepthHelper(nestedList) {\n        let depth = 1;\n        for (let nested of nestedList) {\n            if (Array.isArray(nested)) {\n                depth = Math.max(depth, 1 + maxDepthHelper(nested));\n            }\n        }\n        return depth;\n    }\n    function sumHelper(nestedList, depth) {\n        let sum = 0;\n        for (let nested of nestedList) {\n            if (typeof nested === \"number\") {\n                sum += depth * nested;\n            } else {\n                sum += sumHelper(nested, depth - 1);\n            }\n        }\n        return sum;\n    }\n    let maxDepth = maxDepthHelper(nestedList);\n    return sumHelper(nestedList, maxDepth);\n}"
        },
        "Qid": "364"
    },
    {
        "_id": {
            "$oid": "66205e258257d25e0805c763"
        },
        "title": "Measuring Water with Two Jugs",
        "description": "You are given two jugs with capacities `jug1Capacity` and `jug2Capacity` liters. There is an infinite amount of water supply available. Determine whether it is possible to measure exactly `targetCapacity` liters using these two jugs.\n\nIf `targetCapacity` liters of water are measurable, you must have `targetCapacity` liters of water contained **within one or both buckets** by the end.\n\nOperations allowed:\n\n* Fill any of the jugs with water.\n* Empty any of the jugs.\n* Pour water from one jug into another till the other jug is completely full, or the first jug itself is empty.",
        "example": "Example:\n\nInput: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4\nOutput: true\nExplanation: The famous [Die Hard](https://www.youtube.com/watch?v=BVtQNK_ZUJg&ab_channel=notnek01) example",
        "level": "Medium",
        "tags": [
            "math",
            "puzzle"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    5,
                    4
                ],
                [
                    2,
                    6,
                    5
                ],
                [
                    1,
                    2,
                    3
                ],
                [
                    7,
                    11,
                    10
                ],
                [
                    4,
                    9,
                    7
                ],
                [
                    6,
                    8,
                    7
                ],
                [
                    10,
                    10,
                    20
                ],
                [
                    1,
                    1,
                    1
                ],
                [
                    5,
                    5,
                    10
                ],
                [
                    2,
                    3,
                    4
                ],
                [
                    8,
                    12,
                    16
                ],
                [
                    7,
                    7,
                    14
                ],
                [
                    3,
                    4,
                    5
                ],
                [
                    6,
                    9,
                    15
                ],
                [
                    2,
                    5,
                    7
                ],
                [
                    10,
                    15,
                    25
                ],
                [
                    1,
                    3,
                    2
                ],
                [
                    4,
                    7,
                    11
                ],
                [
                    5,
                    8,
                    13
                ],
                [
                    9,
                    12,
                    21
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                false,
                true,
                true,
                true,
                true,
                false,
                true,
                true,
                true,
                true,
                false,
                true,
                false,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "bool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {\n    if (targetCapacity > jug1Capacity + jug2Capacity) return false;\n    if (jug1Capacity == targetCapacity || jug2Capacity == targetCapacity \n        || jug1Capacity + jug2Capacity == targetCapacity) return true;\n    return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0;\n}\n\nint gcd(int a, int b) {\n    while (b) {\n        int tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n\n",
            "java": "public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {\n    if (targetCapacity > jug1Capacity + jug2Capacity) return false;\n    if (jug1Capacity == targetCapacity || jug2Capacity == targetCapacity \n        || jug1Capacity + jug2Capacity == targetCapacity) return true;\n    return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0;\n}\n\nprivate int gcd(int a, int b) {\n    while (b != 0) {\n        int tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n\n",
            "python": "def canMeasureWater(jug1Capacity, jug2Capacity, targetCapacity):\n    if targetCapacity > jug1Capacity + jug2Capacity:\n        return False\n    if jug1Capacity == targetCapacity or jug2Capacity == targetCapacity or jug1Capacity + jug2Capacity == targetCapacity:\n        return True\n    return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n",
            "javascript": "function canMeasureWater(jug1Capacity, jug2Capacity, targetCapacity) {\n    if (targetCapacity > jug1Capacity + jug2Capacity) return false;\n    if (jug1Capacity == targetCapacity || jug2Capacity == targetCapacity \n        || jug1Capacity + jug2Capacity == targetCapacity) return true;\n    return targetCapacity % gcd(jug1Capacity, jug2Capacity) === 0;\n}\n\nfunction gcd(a, b) {\n    while (b) {\n        let tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n",
            "explanation": "To measure exactly targetCapacity liters using the two jugs, we need to use their GCD (Greatest Common Divisor). The problem can be solved using the mathematical property that the target capacity should be divisible by the GCD of jug1Capacity and jug2Capacity.\n\nFirst, we calculate GCD of the two jug capacities.\nThen, we check if the target capacity is smaller than or equal to the sum of the two jug capacities. If not, it's impossible to get targetCapacity liters.\nReturn true if targetCapacity is equal to either of the jug capacities or their sum, as it's achievable without performing any GCD checks.\nThen, we simply check if targetCapacity is divisible by the GCD of the two jug capacities, returning true if so.\n\nThe algorithm uses a single GCD calculation and a few checks to determine whether it's possible to measure the target capacity or not, making it fast and efficient."
        },
        "structure": {
            "c++": "bool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity)  {\n    // Your code here\n}\n\n",
            "java": "public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity)  {\n    // Your code here\n}\n\n",
            "python": "def canMeasureWater(jug1Capacity, jug2Capacity, targetCapacity):\n    # Your code here\n\n",
            "javascript": "function canMeasureWater(jug1Capacity, jug2Capacity, targetCapacity)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nbool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {\n    if (targetCapacity > jug1Capacity + jug2Capacity) return false;\n    if (jug1Capacity == targetCapacity || jug2Capacity == targetCapacity \n        || jug1Capacity + jug2Capacity == targetCapacity) return true;\n    return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0;\n}\n\nint gcd(int a, int b) {\n    while (b) {\n        int tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n\nint main() {\n    int jug1Capacity = $args;\n    int jug2Capacity = $args;\n    int targetCapacity = $args;\n    bool result = canMeasureWater(jug1Capacity, jug2Capacity, targetCapacity);\n    cout << boolalpha << result << endl;\n    return 0;\n}",
            "java": "public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {\n    if (targetCapacity > jug1Capacity + jug2Capacity) return false;\n    if (jug1Capacity == targetCapacity || jug2Capacity == targetCapacity \n        || jug1Capacity + jug2Capacity == targetCapacity) return true;\n    return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0;\n}\n\nprivate int gcd(int a, int b) {\n    while (b != 0) {\n        int tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n\npublic static void main(String[] args) {\n    int jug1Capacity = $args;\n    int jug2Capacity = $args;\n    int targetCapacity = $args;\n    boolean result = canMeasureWater(jug1Capacity, jug2Capacity, targetCapacity);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    jug1Capacity =inputs[0]\n    jug2Capacity =inputs[1]\n    targetCapacity = inputs[2]\n    result = canMeasureWater(jug1Capacity, jug2Capacity, targetCapacity)\n    print(result)",
            "javascript": "function main() {\n    const jug1Capacity = $args[0];\n    const jug2Capacity = $args[1];\n    const targetCapacity = $args[2];\n    const result = canMeasureWater(jug1Capacity, jug2Capacity, targetCapacity);\n    console.log(result);\n}"
        },
        "Qid": "365"
    },
    {
        "_id": {
            "$oid": "66205e608257d25e0805c764"
        },
        "title": "Perfect Square",
        "description": "Given a positive integer num, determine if it is a perfect square.",
        "example": "Example 1:\n\nInput: num = 16\nOutput: true\nExplanation: 4 * 4 = 16\n\nExample 2:\n\nInput: num = 14\nOutput: false\nExplanation: There is no integer whose square is equal to 14.",
        "level": "Easy",
        "tags": [
            "math",
            "binary search"
        ],
        "test_cases": {
            "inputs": [
                16,
                14,
                1,
                2,
                3,
                4,
                9,
                10,
                11,
                12,
                13,
                15,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24
            ],
            "outputs": [
                true,
                false,
                true,
                false,
                false,
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "bool isPerfectSquare(int num) {\n    if (num < 2) return true;\n    long long left = 2, right = num / 2, mid, square;\n    while (left <= right) {\n        mid = left + (right - left) / 2;\n        square = mid * mid;\n        if (square == num) return true;\n        if (square > num) right = mid - 1;\n        else left = mid + 1;\n    }\n    return false;\n}\n",
            "java": "boolean isPerfectSquare(int num) {\n    if (num < 2) return true;\n    long left = 2, right = num / 2, mid, square;\n    while (left <= right) {\n        mid = left + (right - left) / 2;\n        square = mid * mid;\n        if (square == num) return true;\n        if (square > num) right = mid - 1;\n        else left = mid + 1;\n    }\n    return false;\n}\n",
            "python": "def is_perfect_square(num: int) -> bool:\n    if num < 2:\n        return True\n    left, right = 2, num // 2\n    while left <= right:\n        mid = left + (right - left) // 2\n        square = mid * mid\n        if square == num:\n            return True\n        if square > num:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return False\n",
            "javascript": "function isPerfectSquare(num) {\n    if (num < 2) return true;\n    let left = 2, right = Math.floor(num / 2), mid, square;\n    while (left <= right) {\n        mid = left + Math.floor((right - left) / 2);\n        square = mid * mid;\n        if (square === num) return true;\n        if (square > num) right = mid - 1;\n        else left = mid + 1;\n    }\n    return false;\n}\n",
            "explanation": "The algorithm uses a binary search approach to find the square root of the given number. It starts with left at 2 and right at half of the input number. It calculates the middle value and squares it. If the squared middle value is equal to the input number, the function returns True; the number is a perfect square. If the squared middle value is greater than the input number, it updates the right to mid - 1; otherwise, it updates the left to mid + 1. The function repeats until the left value is greater than the right value. In that case, the function returns False, indicating that the input number is not a perfect square."
        },
        "structure": {
            "c++": "bool isPerfectSquare(int num)  {\n    // Your code here\n}\n",
            "java": "boolean isPerfectSquare(int num)  {\n    // Your code here\n}\n",
            "python": "def is_perfect_square(num: int) -> bool:\n    # Your code here\n\n",
            "javascript": "function isPerfectSquare(num)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nbool isPerfectSquare(int num) {\n    if (num < 2) return true;\n    long long left = 2, right = num / 2, mid, square;\n    while (left <= right) {\n        mid = left + (right - left) / 2;\n        square = mid * mid;\n        if (square == num) return true;\n        if (square > num) right = mid - 1;\n        else left = mid + 1;\n    }\n    return false;\n}\n\nint main() {\n    int num = $args;\n    bool result = isPerfectSquare(num);\n    cout << boolalpha << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n    int num = $args;\n    boolean result = isPerfectSquare(num);\n    System.out.println(result);\n}",
            "python": "if __name__ == \"__main__\":\n    num = $args\n    result = is_perfect_square(num)\n    print(result)",
            "javascript": "function main() {\n    const num = $args;\n    const result = isPerfectSquare(num);\n    console.log(result);\n}"
        },
        "Qid": "367"
    },
    {
        "_id": {
            "$oid": "66205e868257d25e0805c765"
        },
        "title": "Largest Divisible Subset",
        "description": "Given a set of distinct positive integers `nums`, return the largest subset `answer` such that every pair `(answer[i], answer[j])` of elements in this subset satisfies:\n\n*   `answer[i] % answer[j] == 0`, or\n*   `answer[j] % answer[i] == 0`\n\nIf there are multiple solutions, return any of them.",
        "example": "Example 1:\n\nInput: nums = [1,2,3]\nOutput: [1,2]\nExplanation: [1,3] is also accepted.\n\nExample 2:\n\nInput: nums = [1,2,4,8]\nOutput: [1,2,4,8]",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3
                ],
                [
                    1,
                    2,
                    4,
                    8
                ],
                [
                    2,
                    3,
                    5,
                    7,
                    11
                ],
                [
                    4,
                    8,
                    12,
                    16,
                    20
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9,
                    11,
                    13,
                    15,
                    17,
                    19
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10,
                    12,
                    14,
                    16,
                    18,
                    20
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    32,
                    64,
                    128,
                    256,
                    512
                ],
                [
                    3,
                    6,
                    9,
                    12,
                    15,
                    18,
                    21,
                    24,
                    27,
                    30
                ],
                [
                    5,
                    10,
                    15,
                    20,
                    25,
                    30,
                    35,
                    40,
                    45,
                    50
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ]
            ],
            "outputs": [
                [
                    1,
                    2
                ],
                [
                    1,
                    2,
                    4,
                    8
                ],
                [
                    2,
                    5
                ],
                [
                    4,
                    8,
                    12,
                    16,
                    20
                ],
                [
                    1,
                    3,
                    9
                ],
                [
                    2,
                    4,
                    8,
                    16,
                    20
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    32,
                    64,
                    128,
                    256,
                    512
                ],
                [
                    3,
                    6,
                    9,
                    12,
                    15,
                    18,
                    21,
                    24,
                    27,
                    30
                ],
                [
                    5,
                    10,
                    20
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    32,
                    64,
                    128,
                    256,
                    512
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> largestDivisibleSubset(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    int n = nums.size();\n    vector<int> count(n, 1), prev(n, -1), res;\n    int max_idx = 0;\n\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (nums[i] % nums[j] == 0 && count[i] < count[j] + 1) {\n                count[i] = count[j] + 1;\n                prev[i] = j;\n            }\n        }\n        if (count[max_idx] < count[i]) max_idx = i;\n    }\n\n    for (int i = max_idx; i >= 0; i = prev[i]) {\n        res.push_back(nums[i]);\n    }\n\n    return res;\n}\n",
            "java": "import java.util.*;\n\npublic List<Integer> largestDivisibleSubset(int[] nums) {\n    Arrays.sort(nums);\n    int n = nums.length;\n    int[] count = new int[n];\n    int[] prev = new int[n];\n    int max_idx = 0;\n    Arrays.fill(prev, -1);\n    Arrays.fill(count, 1);\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[i] % nums[j] == 0 && count[i] < count[j] + 1) {\n                count[i] = count[j] + 1;\n                prev[i] = j;\n            }\n        }\n        if (count[max_idx] < count[i]) max_idx = i;\n    }\n\n    List<Integer> res = new ArrayList<>();\n    for (int i = max_idx; i >= 0; i = prev[i]) {\n        res.add(nums[i]);\n    }\n\n    return res;\n}\n",
            "python": "def largestDivisibleSubset(nums):\n    nums.sort()\n    n = len(nums)\n    count = [1] * n\n    prev = [-1] * n\n\n    max_idx = 0\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] % nums[j] == 0 and count[i] < count[j] + 1:\n                count[i] = count[j] + 1\n                prev[i] = j\n        if count[max_idx] < count[i]:\n            max_idx = i\n\n    res = []\n    i = max_idx\n    while i >= 0:\n        res.append(nums[i])\n        i = prev[i]\n\n    return res\n",
            "javascript": "function largestDivisibleSubset(nums) {\n    nums.sort((a, b) => a - b);\n    const n = nums.length;\n    const count = new Array(n).fill(1);\n    const prev = new Array(n).fill(-1);\n    let max_idx = 0;\n\n    for (let i = 1; i < n; i++) {\n        for (let j = 0; j < i; j++) {\n            if (nums[i] % nums[j] === 0 && count[i] < count[j] + 1) {\n                count[i] = count[j] + 1;\n                prev[i] = j;\n            }\n        }\n        if (count[max_idx] < count[i]) {\n            max_idx = i;\n        }\n    }\n\n    const res = [];\n    for (let i = max_idx; i >= 0; i = prev[i]) {\n        res.push(nums[i]);\n    }\n\n    return res;\n}\n",
            "explanation": "1. Sort the input array.\n2. Initialize two arrays: count and prev, both with the same length as the input array.\n   - count will store the length of the largest subsets ending at index i.\n   - prev stores the index of the previous element in the largest subset.\n3. Initialize max_idx to store the index of the maximum count.\n4. Loop through the sorted array, and for each element, compare it with its previous elements.\n   - If it is divisible by the previous element, update the count and prev arrays accordingly.\n5. After looping and updating the arrays, use max_idx to trace back the elements forming the largest subset.\n6. Return the largest subset."
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> largestDivisibleSubset(vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "import java.util.*;\n\npublic List<Integer> largestDivisibleSubset(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def largestDivisibleSubset(nums):\n    # Your code here\n\n",
            "javascript": "function largestDivisibleSubset(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> largestDivisibleSubset(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    int n = nums.size();\n    vector<int> count(n, 1), prev(n, -1), res;\n    int max_idx = 0;\n\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (nums[i] % nums[j] == 0 && count[i] < count[j] + 1) {\n                count[i] = count[j] + 1;\n                prev[i] = j;\n            }\n        }\n        if (count[max_idx] < count[i]) max_idx = i;\n    }\n\n    for (int i = max_idx; i >= 0; i = prev[i]) {\n        res.push_back(nums[i]);\n    }\n\n    return res;\n}\n\nint main() {\n    vector<int> nums = $args;\n    vector<int> result = largestDivisibleSubset(nums);\n    for (int i = 0; i < result.size(); ++i) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "java": "public List<Integer> largestDivisibleSubset(int[] nums) {\n    Arrays.sort(nums);\n    int n = nums.length;\n    int[] count = new int[n];\n    int[] prev = new int[n];\n    int max_idx = 0;\n    Arrays.fill(prev, -1);\n    Arrays.fill(count, 1);\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[i] % nums[j] == 0 && count[i] < count[j] + 1) {\n                count[i] = count[j] + 1;\n                prev[i] = j;\n            }\n        }\n        if (count[max_idx] < count[i]) max_idx = i;\n    }\n\n    List<Integer> res = new ArrayList<>();\n    for (int i = max_idx; i >= 0; i = prev[i]) {\n        res.add(nums[i]);\n    }\n\n    return res;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = largestDivisibleSubset(nums)\n    print(result)",
            "javascript": "function largestDivisibleSubset(nums) {\n    nums.sort((a, b) => a - b);\n    const n = nums.length;\n    const count = new Array(n).fill(1);\n    const prev = new Array(n).fill(-1);\n    let max_idx = 0;\n\n    for (let i = 1; i < n; i++) {\n        for (let j = 0; j < i; j++) {\n            if (nums[i] % nums[j] === 0 && count[i] < count[j] + 1) {\n                count[i] = count[j] + 1;\n                prev[i] = j;\n            }\n        }\n        if (count[max_idx] < count[i]) {\n            max_idx = i;\n        }\n    }\n\n    const res = [];\n    for (let i = max_idx; i >= 0; i = prev[i]) {\n        res.push(nums[i]);\n    }\n\n    return res;\n}"
        },
        "Qid": "368"
    },
    {
        "_id": {
            "$oid": "662060fc8257d25e0805c766"
        },
        "title": "Sum of Two Integers without + and - Operators",
        "description": "Given two integers `a` and `b`, return the sum of the two integers without using the operators `+` and `-`. You can assume that the input integers `a` and `b` will be within the range of -1000 to 1000.",
        "example": "Example:\n\nInput: a = 1, b = 2\nOutput: 3\n\nInput: a = 2, b = 3\nOutput: 5",
        "level": "Easy",
        "tags": [
            "math",
            "bit manipulation"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2
                ],
                [
                    2,
                    3
                ],
                [
                    0,
                    0
                ],
                [
                    5,
                    -3
                ],
                [
                    -10,
                    10
                ],
                [
                    1000,
                    -1000
                ],
                [
                    -1000,
                    -1000
                ],
                [
                    999,
                    1
                ],
                [
                    -999,
                    -1
                ],
                [
                    1000,
                    0
                ],
                [
                    0,
                    -1000
                ],
                [
                    1,
                    -1
                ],
                [
                    -1,
                    1
                ],
                [
                    123,
                    456
                ],
                [
                    -789,
                    123
                ],
                [
                    987,
                    -654
                ],
                [
                    -321,
                    -654
                ],
                [
                    1000,
                    1000
                ],
                [
                    -1000,
                    1000
                ],
                [
                    1000,
                    -1000
                ]
            ],
            "outputs": [
                3,
                5,
                0,
                2,
                0,
                0,
                -2000,
                1000,
                -1000,
                1000,
                -1000,
                0,
                0,
                579,
                -666,
                333,
                -975,
                2000,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "int add(int a, int b) {\n    while (b != 0) {\n        int carry = a & b;\n        a = a ^ b;\n        b = carry << 1;\n    }\n    return a;\n}\n",
            "java": "public int add(int a, int b) {\n    while (b != 0) {\n        int carry = a & b;\n        a = a ^ b;\n        b = carry << 1;\n    }\n    return a;\n}\n",
            "python": "def add(a, b):\n    MAX = 0x7FFFFFFF\n    MASK = 0xFFFFFFFF\n    while b:\n        a, b = (a ^ b) & MASK, ((a & b) << 1) & MASK\n    return a if a <= MAX else ~(a ^ MASK)\n",
            "javascript": "function add(a, b) {\n    while (b) {\n        let carry = a & b;\n        a = a ^ b;\n        b = carry << 1;\n    }\n    return a;\n}\n",
            "explanation": "The algorithm uses bitwise operations to add the two integers without using + or - operators. The addition process can be divided into two parts: addition without considering a carry and handling the carry generated. \n\n1. XOR (^) can be used for adding without carrying, as it sets the bit at a position if the bits in the two numbers being added are different at that position.\n2. AND (&) operation, followed by left shift (<<), is used to find the carry. With this operation, we find the bits which are set in both numbers, and they represent the carry. Then, we shift these bits to the left by one position, which is the correct position of the carry bit.\n\nFinally, we keep looping until there is no carry, at which point we have the sum of the two integers. In the Python implementation, extra steps are required due to the lack of fixed-size integers."
        },
        "structure": {
            "c++": "int add(int a, int b)  {\n    // Your code here\n}\n",
            "java": "public int add(int a, int b)  {\n    // Your code here\n}\n",
            "python": "def add(a, b):\n    # Your code here\n\n",
            "javascript": "function add(a, b)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int a = $args;\n    int b = $args;\n    int result = add(a, b);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int add(int a, int b) {\n    while (b != 0) {\n        int carry = a & b;\n        a = a ^ b;\n        b = carry << 1;\n    }\n    return a;\n}",
            "python": "if __name__ == \"__main__\":\n    a = $args[0]\n    b = $args[1]\n    result = add(a, b)\n    print(result)",
            "javascript": "function main() {\n    const a = $args[0];\n    const b = $args[1];\n    const result = add(a, b);\n    console.log(result);\n}"
        },
        "Qid": "371"
    },
    {
        "_id": {
            "$oid": "662061a58257d25e0805c767"
        },
        "title": "Minimum Money to Guarantee a Win",
        "description": "You are playing the Guessing Game. The game works as follows: I pick a number between 1 and n. You guess a number. If you guess the right number, you win the game. If you guess the wrong number, I will tell you whether the number I picked is higher or lower, and you will continue guessing. Every time you guess a wrong number x, you will pay x dollars. If you run out of money, you lose the game. Given a particular n, return the minimum amount of money you need to guarantee a win regardless of what number I pick.",
        "example": "Example:\n\nInput: n = 10\nOutput: 16\nExplanation: The winning strategy is as follows:\n- The range is [1,10]. Guess 7.\n    - If this is my number, your total is $0. Otherwise, you pay $7.\n    - If my number is higher, the range is [8,10]. Guess 9.\n        - If this is my number, your total is $7. Otherwise, you pay $9.\n        - If my number is higher, it must be 10. Guess 10. Your total is $7 + $9 = $16.\n        - If my number is lower, it must be 8. Guess 8. Your total is $7 + $9 = $16.\n    - If my number is lower, the range is [1,6]. Guess 3.\n        - If this is my number, your total is $7. Otherwise, you pay $3.\n        - If my number is higher, the range is [4,6]. Guess 5.\n            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $5.\n            - If my number is higher, it must be 6. Guess 6. Your total is $7 + $3 + $5 = $15.\n            - If my number is lower, it must be 4. Guess 4. Your total is $7 + $3 + $5 = $15.\n        - If my number is lower, the range is [1,2]. Guess 1.\n            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $1.\n            - If my number is higher, it must be 2. Guess 2. Your total is $7 + $3 + $1 = $11.\nThe worst case in all these scenarios is that you pay $16. Hence, you only need $16 to guarantee a win.",
        "level": "Medium",
        "tags": [
            "dynamic programming",
            "game theory"
        ],
        "test_cases": {
            "inputs": [
                10,
                1,
                2,
                5,
                15,
                20,
                50,
                100,
                150,
                200,
                7,
                12,
                25,
                30,
                75,
                125,
                175,
                180,
                190,
                195
            ],
            "outputs": [
                16,
                0,
                1,
                6,
                56,
                190,
                625,
                2550,
                5625,
                10100,
                10,
                35,
                175,
                266,
                1125,
                3125,
                6875,
                7426,
                9025,
                10100
            ]
        },
        "sample_code": {
            "c++": "int getMoneyAmount(int n) {\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n    for (int i = n - 1; i >= 1; i--) {\n        for (int j = i + 1; j <= n; j++) {\n            int min_cost = INT_MAX;\n            for (int k = i; k < j; k++) {\n                int cost = k + max(dp[i][k - 1], dp[k + 1][j]);\n                min_cost = min(min_cost, cost);\n            }\n            dp[i][j] = min_cost;\n        }\n    }\n    return dp[1][n];\n}\n",
            "java": "public int getMoneyAmount(int n) {\n    int[][] dp = new int[n + 1][n + 1];\n    for (int i = n - 1; i >= 1; i--) {\n        for (int j = i + 1; j <= n; j++) {\n            int min_cost = Integer.MAX_VALUE;\n            for (int k = i; k < j; k++) {\n                int cost = k + Math.max(dp[i][k - 1], dp[k + 1][j]);\n                min_cost = Math.min(min_cost, cost);\n            }\n            dp[i][j] = min_cost;\n        }\n    }\n    return dp[1][n];\n}\n",
            "python": "def getMoneyAmount(n: int) -> int:\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, 0, -1):\n        for j in range(i + 1, n + 1):\n            min_cost = float(\"inf\")\n            for k in range(i, j):\n                cost = k + max(dp[i][k - 1], dp[k + 1][j])\n                min_cost = min(min_cost, cost)\n            dp[i][j] = min_cost\n    return dp[1][n]\n",
            "javascript": "function getMoneyAmount(n) {\n    const dp = Array.from(Array(n + 1), () => Array(n + 1).fill(0));\n    for (let i = n - 1; i >= 1; i--) {\n        for (let j = i + 1; j <= n; j++) {\n            let min_cost = Infinity;\n            for (let k = i; k < j; k++) {\n                const cost = k + Math.max(dp[i][k - 1], dp[k + 1][j]);\n                min_cost = Math.min(min_cost, cost);\n            }\n            dp[i][j] = min_cost;\n        }\n    }\n    return dp[1][n];\n}\n",
            "explanation": "The algorithm uses dynamic programming to find the minimum cost required to guarantee a win. We create a 2D array `dp` where `dp[i][j]` represents the minimum cost required to guess the correct number from numbers between i and j inclusive.\n\nWe fill in this array from the bottom right corner, and move towards the top left corner. For each value of `i` and `j`, we calculate the cost by guessing a number `k` between `i` and `j`. The cost is equal to `k + max(dp[i][k-1], dp[k+1][j])`, which means that we pay `k` and take the worst-case scenario, and we try to minimize this cost.\n\nAfter filling the `dp` array, the minimum cost required to win the game when guessing numbers from 1 to `n` is stored in `dp[1][n]`."
        },
        "structure": {
            "c++": "int getMoneyAmount(int n)  {\n    // Your code here\n}\n",
            "java": "public int getMoneyAmount(int n)  {\n    // Your code here\n}\n",
            "python": "def getMoneyAmount(n: int) -> int:\n    # Your code here\n\n",
            "javascript": "function getMoneyAmount(n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = getMoneyAmount(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int getMoneyAmount(int n) {\n    int[][] dp = new int[n + 1][n + 1];\n    for (int i = n - 1; i >= 1; i--) {\n        for (int j = i + 1; j <= n; j++) {\n            int min_cost = Integer.MAX_VALUE;\n            for (int k = i; k < j; k++) {\n                int cost = k + Math.max(dp[i][k - 1], dp[k + 1][j]);\n                min_cost = Math.min(min_cost, cost);\n            }\n            dp[i][j] = min_cost;\n        }\n    }\n    return dp[1][n];\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = getMoneyAmount(n)\n    print(result)",
            "javascript": "function getMoneyAmount(n) {\n    const dp = Array.from(Array(n + 1), () => Array(n + 1).fill(0));\n    for (let i = n - 1; i >= 1; i--) {\n        for (let j = i + 1; j <= n; j++) {\n            let min_cost = Infinity;\n            for (let k = i; k < j; k++) {\n                const cost = k + Math.max(dp[i][k - 1], dp[k + 1][j]);\n                min_cost = Math.min(min_cost, cost);\n            }\n            dp[i][j] = min_cost;\n        }\n    }\n    return dp[1][n];\n}"
        },
        "Qid": "375"
    },
    {
        "_id": {
            "$oid": "662061ac8257d25e0805c768"
        },
        "title": "Longest Wiggle Subsequence",
        "description": "A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences. Given an integer array nums, return the length of the longest wiggle subsequence of nums.",
        "example": "Example:\n\nInput: nums = [1,7,4,9,2,5]\nOutput: 6\nExplanation: The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    7,
                    4,
                    9,
                    2,
                    5
                ],
                [
                    1,
                    17,
                    5,
                    10,
                    13,
                    15,
                    10,
                    5,
                    16,
                    8
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    3,
                    2,
                    4,
                    5,
                    7,
                    6,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ]
            ],
            "outputs": [
                6,
                7,
                2,
                1,
                10,
                10,
                6,
                19,
                20,
                40
            ]
        },
        "sample_code": {
            "c++": "int wiggleMaxLength(vector<int>& nums) {\n    int len = nums.size();\n    if (len < 2) return len;\n\n    int up = 1, down = 1;\n    for (int i = 1; i < len; ++i) {\n        if (nums[i] > nums[i - 1])\n            up = down + 1;\n        else if (nums[i] < nums[i - 1])\n            down = up + 1;\n    }\n    return max(up, down);\n}\n",
            "java": "public int wiggleMaxLength(int[] nums) {\n    int len = nums.length;\n    if (len < 2) return len;\n\n    int up = 1, down = 1;\n    for (int i = 1; i < len; ++i) {\n        if (nums[i] > nums[i - 1])\n            up = down + 1;\n        else if (nums[i] < nums[i - 1])\n            down = up + 1;\n    }\n    return Math.max(up, down);\n}\n",
            "python": "def wiggleMaxLength(nums):\n    if len(nums) < 2:\n        return len(nums)\n\n    up, down = 1, 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            up = down + 1\n        elif nums[i] < nums[i - 1]:\n            down = up + 1\n    return max(up, down)\n",
            "javascript": "function wiggleMaxLength(nums) {\n    let len = nums.length;\n    if (len < 2) return len;\n\n    let up = 1, down = 1;\n    for (let i = 1; i < len; ++i) {\n        if (nums[i] > nums[i - 1])\n            up = down + 1;\n        else if (nums[i] < nums[i - 1])\n            down = up + 1;\n    }\n    return Math.max(up, down);\n}\n",
            "explanation": "The algorithm uses dynamic programming to find the longest wiggle subsequence in a given array or list of integers. The dynamic programming consists of two parts: the longest increasing subsequence (up) and the longest decreasing subsequence (down).\n\nInitialize up and down to 1. Loop through the input array starting from index 1. For each element, if the current element is greater than the previous element, update `up` to be `down + 1`. If the current element is less than the previous element, update `down` to be `up + 1`.\n\nAfter iterating through the entire array, return the greater value between `up` and `down`, which represents the length of the longest wiggle sequence.\n\nThe algorithm's time complexity is O(n) since it iterates through the input array once, and its space complexity is O(1) as it only uses a constant amount of additional memory."
        },
        "structure": {
            "c++": "int wiggleMaxLength(vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "public int wiggleMaxLength(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def wiggleMaxLength(nums):\n    # Your code here\n\n",
            "javascript": "function wiggleMaxLength(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int wiggleMaxLength(vector<int>& nums) {\n    int len = nums.size();\n    if (len < 2) return len;\n\n    int up = 1, down = 1;\n    for (int i = 1; i < len; ++i) {\n        if (nums[i] > nums[i - 1])\n            up = down + 1;\n        else if (nums[i] < nums[i - 1])\n            down = up + 1;\n    }\n    return max(up, down);\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = wiggleMaxLength(nums)\n    print(result)",
            "java": "",
            "javascript": ""
        },
        "Qid": "376"
    },
    {
        "_id": {
            "$oid": "662063658257d25e0805c769"
        },
        "title": "Ransom Note Construction",
        "description": "Given two strings `ransomNote` and `magazine`, determine if `ransomNote` can be constructed using the letters from `magazine`. Each letter in `magazine` can only be used once in `ransomNote`.",
        "example": "For example, given `ransomNote = \"aa\"` and `magazine = \"aab\"`, we can construct `ransomNote` using the letters from `magazine`. Therefore, the output would be `true`.",
        "level": "Easy",
        "tags": [
            "string",
            "hash table"
        ],
        "test_cases": {
            "inputs": [
                [
                    "a",
                    "b"
                ],
                [
                    "aa",
                    "ab"
                ],
                [
                    "aa",
                    "aab"
                ],
                [
                    "abc",
                    "def"
                ],
                [
                    "",
                    ""
                ],
                [
                    "abc",
                    ""
                ],
                [
                    "",
                    "abc"
                ],
                [
                    "hello",
                    "world"
                ],
                [
                    "apple",
                    "banana"
                ],
                [
                    "programming",
                    "coding"
                ],
                [
                    "python",
                    "java"
                ],
                [
                    "leetcode",
                    "leet"
                ],
                [
                    "algorithm",
                    "logarithm"
                ],
                [
                    "abcd",
                    "dcba"
                ],
                [
                    "xyz",
                    "zyx"
                ],
                [
                    "hello",
                    "hello"
                ],
                [
                    "goodbye",
                    "goodbye"
                ],
                [
                    "hello",
                    "world"
                ],
                [
                    "abcde",
                    "edcba"
                ]
            ],
            "outputs": [
                false,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                false,
                false,
                false,
                false,
                true,
                false,
                true,
                true,
                true,
                true,
                false,
                true
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <unordered_map>\n\nbool canConstruct(std::string ransomNote, std::string magazine) {\n    std::unordered_map<char, int> letterCount;\n    for (char c : magazine) {\n        letterCount[c]++;\n    }\n    \n    for (char c : ransomNote) {\n        if (letterCount[c] == 0) {\n            return false;\n        }\n        letterCount[c]--;\n    }\n\n    return true;\n}\n",
            "java": "import java.util.HashMap;\n\npublic boolean canConstruct(String ransomNote, String magazine) {\n    HashMap<Character, Integer> letterCount = new HashMap<>();\n    \n    for (char c : magazine.toCharArray()) {\n        letterCount.put(c, letterCount.getOrDefault(c, 0) + 1);\n    }\n    \n    for (char c : ransomNote.toCharArray()) {\n        if (!letterCount.containsKey(c) || letterCount.get(c) == 0) {\n            return false;\n        }\n        letterCount.put(c, letterCount.get(c) - 1);\n    }\n\n    return true;\n}\n",
            "python": "def can_construct(ransom_note, magazine):\n    letter_count = {}\n    \n    for c in magazine:\n        letter_count[c] = letter_count.get(c, 0) + 1\n        \n    for c in ransom_note:\n        if c not in letter_count or letter_count[c] == 0:\n            return False\n        letter_count[c] -= 1\n        \n    return True\n",
            "javascript": "function canConstruct(ransomNote, magazine) {\n    let letterCount = new Map();\n    \n    for (const c of magazine) {\n        letterCount.set(c, (letterCount.get(c) || 0) + 1);\n    }\n    \n    for (const c of ransomNote) {\n        if (!letterCount.has(c) || letterCount.get(c) === 0) {\n            return false;\n        }\n        letterCount.set(c, letterCount.get(c) - 1);\n    }\n\n    return true;\n}\n",
            "explanation": "The algorithm works as follows:\n1. Create a hash map called `letterCount`, which holds the count of each character in the `magazine` string.\n2. Iterate over the characters in `ransomNote`. For each character:\n   a. If the character is not in `letterCount` or its count is 0, return `false`, as the required letter is not available in `magazine`.\n   b. Decrease the count of the character in `letterCount` by 1.\n3. Once the iteration is done, if the entire `ransomNote` string is processed without any issue, return `true`.\n\nThis algorithm checks if the `ransomNote` can be made from the available characters in the `magazine` by using a single pass through each string and maintaining the count of characters in a hash map."
        },
        "structure": {
            "c++": "#include <string>\n#include <unordered_map>\n\nbool canConstruct(std::string ransomNote, std::string magazine)  {\n    // Your code here\n}\n",
            "java": "import java.util.HashMap;\n\npublic boolean canConstruct(String ransomNote, String magazine)  {\n    // Your code here\n}\n",
            "python": "def can_construct(ransom_note, magazine):\n    # Your code here\n\n",
            "javascript": "function canConstruct(ransomNote, magazine)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <unordered_map>\n#include <iostream>\n\nbool canConstruct(std::string ransomNote, std::string magazine) {\n    std::unordered_map<char, int> letterCount;\n    for (char c : magazine) {\n        letterCount[c]++;\n    }\n    \n    for (char c : ransomNote) {\n        if (letterCount[c] == 0) {\n            return false;\n        }\n        letterCount[c]--;\n    }\n\n    return true;\n}\n\nint main() {\n    std::string ransomNote = $args;\n    std::string magazine = $args;\n    bool result = canConstruct(ransomNote, magazine);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "java": "public boolean canConstruct(String ransomNote, String magazine) {\n    HashMap<Character, Integer> letterCount = new HashMap<>();\n    \n    for (char c : magazine.toCharArray()) {\n        letterCount.put(c, letterCount.getOrDefault(c, 0) + 1);\n    }\n    \n    for (char c : ransomNote.toCharArray()) {\n        if (!letterCount.containsKey(c) || letterCount.get(c) == 0) {\n            return false;\n        }\n        letterCount.put(c, letterCount.get(c) - 1);\n    }\n\n    return true;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    ransom_note = inputs[0]\n    magazine = inputs[1]\n    result = can_construct(ransom_note, magazine)\n    print(result)",
            "javascript": "function main() {\n    const ransomNote = $args[0];\n    const magazine = $args[1];\n    const result = canConstruct(ransomNote, magazine);\n    console.log(result);\n}"
        },
        "Qid": "383"
    },
    {
        "_id": {
            "$oid": "6620638e8257d25e0805c76a"
        },
        "title": "Lexicographical Order",
        "description": "Given an integer `n`, return all the numbers in the range `[1, n]` sorted in lexicographical order. Implement an algorithm that runs in `O(n)` time and uses `O(1)` extra space.",
        "example": "Example:\n\nInput: n = 13\nOutput: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n\nExplanation: The numbers from 1 to 13 are sorted in lexicographical order.\n\nInput: n = 2\nOutput: [1,2]\n\nExplanation: The numbers from 1 to 2 are already sorted in lexicographical order.",
        "level": "Medium",
        "tags": [
            "sorting",
            "lexicographical order"
        ],
        "test_cases": {
            "inputs": [
                13,
                2,
                5,
                20,
                1,
                100,
                50,
                10,
                3,
                7,
                15,
                30,
                8,
                25,
                4,
                6,
                12,
                18,
                9,
                11
            ],
            "outputs": [
                [
                    1,
                    10,
                    11,
                    12,
                    13,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    1,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    2,
                    20,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    1
                ],
                [
                    1,
                    10,
                    100,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    2,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    3,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    4,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    5,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    6,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    7,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    8,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    9,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99
                ],
                [
                    1,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    2,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    3,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    4,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    5,
                    50
                ],
                [
                    1,
                    10,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    1,
                    2,
                    3
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7
                ],
                [
                    1,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    2,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    3,
                    30
                ],
                [
                    1,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    2,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    3,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    4,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    5,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    6,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    7,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    8,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    9,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99
                ],
                [
                    1,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    2,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    3,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    4,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    5,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    6,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    7,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    8,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    9,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99
                ],
                [
                    1,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    2,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    3,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    4,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    5,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    6,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    7,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    8,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    9,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99
                ],
                [
                    1,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    2,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    3,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    4,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    5,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    6,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    7,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    8,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    9,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99
                ],
                [
                    1,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    2,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    3,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    4,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    5,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    6,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    7,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    8,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    9,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99
                ],
                [
                    1,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    2,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    3,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    4,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    5,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    6,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    7,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    8,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    9,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99
                ],
                [
                    1,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    2,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    3,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    4,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    5,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    6,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    7,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    8,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    9,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99
                ],
                [
                    1,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    2,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    3,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    4,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    5,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    6,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    7,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    8,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    9,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99
                ],
                [
                    1,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    2,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    3,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    4,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    5,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    6,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    7,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    8,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    9,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n\nvoid lexicographicalOrderHelper(int current, int n, std::vector<int>& result) {\n    if (current > n) return;\n\n    result.push_back(current);\n    for (int i = 0; i <= 9; ++i) {\n        lexicographicalOrderHelper(current * 10 + i, n, result);\n    }\n}\n\nstd::vector<int> lexicalOrder(int n) {\n    std::vector<int> result;\n    for (int i = 1; i <= 9; ++i) {\n        lexicographicalOrderHelper(i, n, result);\n    }\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic static void lexicographicalOrderHelper(int current, int n, List<Integer> result) {\n    if (current > n) return;\n\n    result.add(current);\n    for (int i = 0; i <= 9; ++i) {\n        lexicographicalOrderHelper(current * 10 + i, n, result);\n    }\n}\n\npublic static List<Integer> lexicalOrder(int n) {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i <= 9; ++i) {\n        lexicographicalOrderHelper(i, n, result);\n    }\n    return result;\n}\n",
            "python": "def lexicographical_order_helper(current, n, result):\n    if current > n:\n        return\n\n    result.append(current)\n    for i in range(10):\n        lexicographical_order_helper(current * 10 + i, n, result)\n\ndef lexical_order(n):\n    result = []\n    for i in range(1, 10):\n        lexicographical_order_helper(i, n, result)\n    return result\n",
            "javascript": "function lexicographicalOrderHelper(current, n, result) {\n    if (current > n) return;\n\n    result.push(current);\n    for (let i = 0; i <= 9; ++i) {\n        lexicographicalOrderHelper(current * 10 + i, n, result);\n    }\n}\n\nfunction lexicalOrder(n) {\n    let result = [];\n    for (let i = 1; i <= 9; ++i) {\n        lexicographicalOrderHelper(i, n, result);\n    }\n    return result;\n}\n",
            "explanation": "The algorithm relies on a helper function (`lexicographicalOrderHelper`) that takes the current number, n, and the result array as input. This helper function uses recursion to traverse the range of numbers from 1 to n in lexicographical order.\n\nFirst, the function checks if the current number is greater than n. If so, it returns. Otherwise, it adds the current number to the result array. Then, it loops through the digits 0 to 9, appending each digit to the current number and then recursively calling the function again with the updated value.\n\nThe main function (`lexicalOrder`) initializes the result array and iterates through the starting digits (1 to 9), calling the helper function for each starting digit.\n\nThe algorithm has a time complexity of O(n), as it goes through each number in the range once. Moreover, the function has an extra space complexity of O(1) because all input parameters are scalars (except for the result array, which is created only once and returned, and recursive calls only manipulate references or scalars)."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n\nvoid lexicographicalOrderHelper(int current, int n, std::vector<int>& result)  {\n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic static void lexicographicalOrderHelper(int current, int n, List<Integer> result)  {\n    // Your code here\n}\n",
            "python": "def lexicographical_order_helper(current, n, result):\n    # Your code here\n\n",
            "javascript": "function lexicographicalOrderHelper(current, n, result)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <iostream>\n\nvoid lexicographicalOrderHelper(int current, int n, std::vector<int>& result) {\n    if (current > n) return;\n\n    result.push_back(current);\n    for (int i = 0; i <= 9; ++i) {\n        lexicographicalOrderHelper(current * 10 + i, n, result);\n    }\n}\n\nstd::vector<int> lexicalOrder(int n) {\n    std::vector<int> result;\n    for (int i = 1; i <= 9; ++i) {\n        lexicographicalOrderHelper(i, n, result);\n    }\n    return result;\n}\n\nint main() {\n    int n = $args;\n    std::vector<int> result = lexicalOrder(n);\n    for (int i : result) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}",
            "java": "public static List<Integer> lexicalOrder(int n) {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i <= 9; ++i) {\n        lexicographicalOrderHelper(i, n, result);\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = lexical_order(n)\n    print(result)",
            "javascript": "function lexicalOrder(n) {\n    let result = [];\n    for (let i = 1; i <= 9; ++i) {\n        lexicographicalOrderHelper(i, n, result);\n    }\n    return result;\n}"
        },
        "Qid": "386"
    },
    {
        "_id": {
            "$oid": "662063f28257d25e0805c76b"
        },
        "title": "Longest Absolute File Path",
        "description": "You are given a file system that stores both files and directories. Each file and directory has a unique absolute path in the file system. Your task is to find the length of the longest absolute path to a file in the file system.",
        "example": "Example:\n\ninput = \"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\"\nOutput: 20\nExplanation: The longest absolute path to a file is \"dir/subdir2/file.ext\" with a length of 20.",
        "level": "Medium",
        "tags": [
            "string",
            "file system",
            "path"
        ],
        "test_cases": {
            "inputs": [
                "\"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\"",
                "\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\"",
                "\"a\""
            ],
            "outputs": [
                20,
                32,
                0
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nint lengthLongestPath(std::string input) {\n    std::istringstream ss(input);\n    std::vector<int> dir_length_stack;\n    std::string line;\n    int max_file_length = 0;\n\n    while (std::getline(ss, line, '\\n')) {\n        int level = 0;\n        while (line.find('\\t') != std::string::npos) {\n            line.erase(0, 1);\n            level++;\n        }\n\n        while (dir_length_stack.size() > level)\n            dir_length_stack.pop_back();\n\n        int length;\n        if (dir_length_stack.empty()) {\n            length = line.length();\n        } else {\n            length = dir_length_stack.back() + line.length() + 1;\n        }\n        dir_length_stack.push_back(length);\n\n        if (line.find('.') != std::string::npos) {\n            max_file_length = std::max(max_file_length, length);\n        }\n    }\n\n    return max_file_length;\n}\n\n",
            "java": "import java.util.Stack;\n\npublic int lengthLongestPath(String input) {\n    Stack<Integer> dirLengthStack = new Stack<>();\n    String[] lines = input.split(\"\\n\");\n    int maxFileLength = 0;\n\n    for (String line : lines) {\n        int level = line.lastIndexOf('\\t') + 1;\n        line = line.substring(level);\n\n        while (dirLengthStack.size() > level) {\n            dirLengthStack.pop();\n        }\n\n        int length = (dirLengthStack.isEmpty()) ? line.length() : dirLengthStack.peek() + line.length() + 1;\n        dirLengthStack.push(length);\n\n        if (line.contains(\".\")) {\n            maxFileLength = Math.max(maxFileLength, length);\n        }\n    }\n\n    return maxFileLength;\n}\n\n",
            "python": "def length_longest_path(input: str) -> int:\n    dir_length_stack = []\n    max_file_length = 0\n    lines = input.split('\\n')\n\n    for line in lines:\n        level = line.count('\\t')\n        line = line.lstrip('\\t')\n\n        while len(dir_length_stack) > level:\n            dir_length_stack.pop()\n\n        if dir_length_stack:\n            length = dir_length_stack[-1] + len(line) + 1\n        else:\n            length = len(line)\n        dir_length_stack.append(length)\n\n        if '.' in line:\n            max_file_length = max(max_file_length, length)\n            \n    return max_file_length\n\n",
            "javascript": "function lengthLongestPath(input) {\n    const dirLengthStack = [];\n    const lines = input.split('\\n');\n    let maxFileLength = 0;\n\n    for (const line of lines) {\n        const level = (line.match(/\\t/g) || []).length;\n        const lineText = line.replace(/\\t/g, '');\n\n        while (dirLengthStack.length > level)\n            dirLengthStack.pop();\n\n        const length = (dirLengthStack.length === 0) ? lineText.length : (dirLengthStack[dirLengthStack.length - 1] + lineText.length + 1);\n        dirLengthStack.push(length);\n\n        if (lineText.includes('.')) {\n            maxFileLength = Math.max(maxFileLength, length);\n        }\n    }\n\n    return maxFileLength;\n}\n\n",
            "explanation": "The algorithm maintains a stack named `dir_length_stack` to remember the lengths of the directory paths seen so far.\n\n1. We split the input by new-line `\\n` to get the lines.\n2. For each line, we calculate its level by counting the number of tab `\\t` characters.\n3. We discard old levels from the `dir_length_stack` by popping elements until reaching the current level.\n4. If `dir_length_stack` is not empty, we calculate the length of the current file/directory by adding the length of the parent directory, and the name of the current file/directory. If `dir_length_stack` is empty, we simply use the length of the current line.\n5. We push the length into the `dir_length_stack`.\n6. If the line contains a '.' (file), we update the maximum path length.\n7. After the iteration, the result stored in `max_file_length` is returned."
        },
        "structure": {
            "c++": "#include <string>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nint lengthLongestPath(std::string input)  {\n    // Your code here\n}\n\n",
            "java": "import java.util.Stack;\n\npublic int lengthLongestPath(String input)  {\n    // Your code here\n}\n\n",
            "python": "def length_longest_path(input: str) -> int:\n    # Your code here\n\n",
            "javascript": "function lengthLongestPath(input)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\nint main() {\n    std::string input = $args;\n    int result = lengthLongestPath(input);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public int lengthLongestPath(String input) {\n    Stack<Integer> dirLengthStack = new Stack<>();\n    String[] lines = input.split(\"\\n\");\n    int maxFileLength = 0;\n\n    for (String line : lines) {\n        int level = line.lastIndexOf('\\t') + 1;\n        line = line.substring(level);\n\n        while (dirLengthStack.size() > level) {\n            dirLengthStack.pop();\n        }\n\n        int length = (dirLengthStack.isEmpty()) ? line.length() : dirLengthStack.peek() + line.length() + 1;\n        dirLengthStack.push(length);\n\n        if (line.contains(\".\")) {\n            maxFileLength = Math.max(maxFileLength, length);\n        }\n    }\n\n    return maxFileLength;\n}\n",
            "python": "if __name__ == \"__main__\":\n    input = $args[0]\n    result = length_longest_path(input)\n    print(result)",
            "javascript": "function main() {\n    const input = $args;\n    const result = lengthLongestPath(input);\n    console.log(result);\n}"
        },
        "Qid": "388"
    },
    {
        "_id": {
            "$oid": "662064c98257d25e0805c76c"
        },
        "title": "Last Remaining Number",
        "description": "You have a list `arr` of all integers in the range `[1, n]` sorted in a strictly increasing order. Apply the following algorithm on `arr`: Starting from left to right, remove the first number and every other number afterward until you reach the end of the list. Repeat the previous step again, but this time from right to left, remove the rightmost number and every other number from the remaining numbers. Keep repeating the steps again, alternating left to right and right to left, until a single number remains. Given the integer `n`, return the last number that remains in `arr`.",
        "example": "Example:\n\nInput: n = 9\nOutput: 6\nExplanation:\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\narr = [2, 4, 6, 8]\narr = [2, 6]\narr = [6]",
        "level": "Medium",
        "tags": [
            "array",
            "math"
        ],
        "test_cases": {
            "inputs": [
                9,
                1,
                5,
                10,
                15,
                20,
                100,
                1000,
                10000,
                100000,
                1000000,
                10000000,
                100000000,
                1000000000,
                999999999,
                123456789,
                987654321,
                1234567890,
                {
                    "$numberLong": "9876543210"
                },
                {
                    "$numberLong": "12345678910"
                }
            ],
            "outputs": [
                6,
                1,
                2,
                6,
                8,
                10,
                54,
                512,
                512,
                512,
                512,
                512,
                512,
                512,
                7828354,
                732674608,
                732674608,
                732674608,
                732674608,
                732674608
            ]
        },
        "sample_code": {
            "c++": "int lastRemaining(int n) {\n    bool direction = true;\n    int head = 1, remaining = n, step = 1;\n\n    while (remaining > 1) {\n        if (direction || remaining % 2 == 1) {\n            head += step;\n        }\n        remaining /= 2;\n        step *= 2;\n        direction = !direction;\n    }\n\n    return head;\n}\n",
            "java": "public int lastRemaining(int n) {\n    boolean direction = true;\n    int head = 1, remaining = n, step = 1;\n\n    while (remaining > 1) {\n        if (direction || remaining % 2 == 1) {\n            head += step;\n        }\n        remaining /= 2;\n        step *= 2;\n        direction = !direction;\n    }\n\n    return head;\n}\n",
            "python": "def last_remaining(n: int) -> int:\n    direction = True\n    head = 1\n    remaining = n\n    step = 1\n\n    while remaining > 1:\n        if direction or remaining % 2 == 1:\n            head += step\n        remaining //= 2\n        step *= 2\n        direction = not direction\n\n    return head\n",
            "javascript": "function lastRemaining(n) {\n    let direction = true;\n    let head = 1, remaining = n, step = 1;\n\n    while (remaining > 1) {\n        if (direction || remaining % 2 === 1) {\n            head += step;\n        }\n        remaining = Math.floor(remaining / 2);\n        step *= 2;\n        direction = !direction;\n    }\n\n    return head;\n}\n",
            "explanation": "The algorithm starts with `head` pointing to the first element, and it will move `head` according to the direction flag and the current value of `remaining`. The `direction` flag alternates between `true` and `false` in each iteration, indicating whether we need to move forwards or backwards. The `remaining` variable represents the number of elements left in the list.\n\nIn each iteration, if the direction is forward (`true`) or the remaining elements are odd, we will increment `head` by the current `step`. Then, we update the remaining elements by dividing it by 2, as half elements are removed in each iteration, and the `step` doubles as the number of removed elements in the next round will also double. Finally, we toggle the `direction` flag, which means reversing the direction in which we move `head`.\n\nAt the end of the algorithm, when there is only one element remaining, the position of `head` will be the number that remains."
        },
        "structure": {
            "c++": "int lastRemaining(int n)  {\n    // Your code here\n}\n",
            "java": "public int lastRemaining(int n)  {\n    // Your code here\n}\n",
            "python": "def last_remaining(n: int) -> int:\n    # Your code here\n\n",
            "javascript": "function lastRemaining(n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n = $args;\n    int result = lastRemaining(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int lastRemaining(int n) {\n    boolean direction = true;\n    int head = 1, remaining = n, step = 1;\n\n    while (remaining > 1) {\n        if (direction || remaining % 2 == 1) {\n            head += step;\n        }\n        remaining /= 2;\n        step *= 2;\n        direction = !direction;\n    }\n\n    return head;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    result = last_remaining(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = lastRemaining(n);\n    console.log(result);\n}"
        },
        "Qid": "390"
    },
    {
        "_id": {
            "$oid": "662064f18257d25e0805c76d"
        },
        "title": "UTF-8 Encoding Validation",
        "description": "Given an integer array `data` representing the data, return whether it is a valid **UTF-8** encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).\n\nA character in **UTF8** can be from **1 to 4 bytes** long, subjected to the following rules:\n\n1.  For a **1-byte** character, the first bit is a `0`, followed by its Unicode code.\n2.  For an **n-bytes** character, the first `n` bits are all one's, the `n + 1` bit is `0`, followed by `n - 1` bytes with the most significant `2` bits being `10`.\n\nThis is how the UTF-8 encoding would work:\n\n     Number of Bytes   |        UTF-8 Octet Sequence\n                       |              (binary)\n   --------------------+-----------------------------------------\n            1          |   0xxxxxxx\n            2          |   110xxxxx 10xxxxxx\n            3          |   1110xxxx 10xxxxxx 10xxxxxx\n            4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n`x` denotes a bit in the binary form of a byte that may be either `0` or `1`.\n\n**Note:** The input is an array of integers. Only the **least significant 8 bits** of each integer is used to store the data. This means each integer represents only 1 byte of data.",
        "example": "Example:\n\n**Input:** data = [197,130,1]\n**Output:** true\n**Explanation:** data represents the octet sequence: 11000101 10000010 00000001.\nIt is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.",
        "level": "Medium",
        "tags": [
            "array",
            "bit manipulation"
        ],
        "test_cases": {
            "inputs": [
                [
                    197,
                    130,
                    1
                ],
                [
                    235,
                    140,
                    4
                ],
                [
                    240,
                    144,
                    128,
                    128
                ],
                [
                    255,
                    255,
                    255,
                    255
                ],
                [
                    192,
                    168,
                    1,
                    1
                ],
                [
                    0,
                    0,
                    0,
                    0
                ],
                [
                    128,
                    128,
                    128,
                    128
                ],
                [
                    193,
                    128,
                    128,
                    128
                ],
                [
                    225,
                    128,
                    128,
                    128
                ],
                [
                    240,
                    128,
                    128,
                    128
                ],
                [
                    255,
                    128,
                    128,
                    128
                ],
                [
                    197,
                    130,
                    1,
                    197,
                    130,
                    1
                ],
                [
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1
                ],
                [
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1
                ],
                [
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1
                ],
                [
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1
                ],
                [
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1
                ],
                [
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1
                ],
                [
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1
                ],
                [
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1
                ],
                [
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1,
                    197,
                    130,
                    1
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "bool validUtf8(vector<int>& data) {\n    int count = 0;\n    for (int byte : data) {\n        if (count == 0) { \n            if ((byte >> 5) == 0b110) count = 1;\n            else if ((byte >> 4) == 0b1110) count = 2;\n            else if ((byte >> 3) == 0b11110) count = 3;\n            else if ((byte >> 7)) return false; \n        } else { \n            if ((byte >> 6) != 0b10) return false;\n            count--;\n        }\n    }\n    return count == 0;\n}\n",
            "java": "public boolean validUtf8(int[] data) {\n    int count = 0;\n    for (int byteValue : data) {\n        if (count == 0) {\n            if ((byteValue >> 5) == 0b110) count = 1;\n            else if ((byteValue >> 4) == 0b1110) count = 2;\n            else if ((byteValue >> 3) == 0b11110) count = 3;\n            else if ((byteValue >> 7) == 1) return false;\n        } else {\n            if ((byteValue >> 6) != 0b10) return false;\n            count--;\n        }\n    }\n    return count == 0;\n}\n",
            "python": "def validUtf8(data):\n    count = 0\n    for byte in data:\n        if count == 0:\n            if byte >> 5 == 0b110:\n                count = 1\n            elif byte >> 4 == 0b1110:\n                count = 2\n            elif byte >> 3 == 0b11110:\n                count = 3\n            elif byte >> 7:\n                return False\n        else:\n            if byte >> 6 != 0b10:\n                return False\n            count -= 1\n    return count == 0\n",
            "javascript": "function validUtf8(data) {\n    let count = 0;\n    for (let byte of data) {\n        if (count === 0) {\n            if (byte >> 5 === 0b110) count = 1;\n            else if (byte >> 4 === 0b1110) count = 2;\n            else if (byte >> 3 === 0b11110) count = 3;\n            else if (byte >> 7) return false;\n        } else {\n            if (byte >> 6 !== 0b10) return false;\n            count--;\n        }\n    }\n    return count === 0;\n}\n",
            "explanation": "We iterate through each byte in the given data array. If we are not currently processing a multi-byte character (count = 0), we check if it's a 1-byte, 2-byte, 3-byte, or 4-byte character encodings, and update the `count` accordingly. For 1-byte characters, we just check if the first bit is 0.\n\nIn case the current byte is a part of multi-byte character (count > 0), we check whether it is a valid continuation byte by checking if its two most significant bits are `10`. If it's not a valid continuation byte, return `false`.\n\nFinally, return `true` if the `count` is 0 at the end of the iteration, i.e., there are no unfinished multi-byte sequences."
        },
        "structure": {
            "c++": "bool validUtf8(vector<int>& data)  {\n    // Your code here\n}\n",
            "java": "public boolean validUtf8(int[] data)  {\n    // Your code here\n}\n",
            "python": "def validUtf8(data):\n    # Your code here\n\n",
            "javascript": "function validUtf8(data)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "bool validUtf8(vector<int>& data) {\n    int count = 0;\n    for (int byte : data) {\n        if (count == 0) { \n            if ((byte >> 5) == 0b110) count = 1;\n            else if ((byte >> 4) == 0b1110) count = 2;\n            else if ((byte >> 3) == 0b11110) count = 3;\n            else if ((byte >> 7)) return false; \n        } else { \n            if ((byte >> 6) != 0b10) return false;\n            count--;\n        }\n    }\n    return count == 0;\n}",
            "java": "public boolean validUtf8(int[] data) {\n    int count = 0;\n    for (int byteValue : data) {\n        if (count == 0) {\n            if ((byteValue >> 5) == 0b110) count = 1;\n            else if ((byteValue >> 4) == 0b1110) count = 2;\n            else if ((byteValue >> 3) == 0b11110) count = 3;\n            else if ((byteValue >> 7) == 1) return false;\n        } else {\n            if ((byteValue >> 6) != 0b10) return false;\n            count--;\n        }\n    }\n    return count == 0;\n}",
            "python": "if __name__ == \"__main__\":\n    data = $args[0]\n    result = validUtf8(data)\n    print(result)",
            "javascript": "function main() {\n    const data = $args;\n    const result = validUtf8(data);\n    console.log(result);\n}"
        },
        "Qid": "393"
    },
    {
        "_id": {
            "$oid": "6620653e8257d25e0805c76e"
        },
        "title": "Decoded String",
        "description": "Given an encoded string, return its decoded string. The encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. Note that `k` is guaranteed to be a positive integer. You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, `k`. For example, there will not be input like `3a` or `2[4]`. The test cases are generated so that the length of the output will never exceed `105`.",
        "example": "For example, given the input string `3[a]2[bc]`, the output should be `aaabcbc`. The string `a` is repeated 3 times and the string `bc` is repeated 2 times.",
        "level": "Easy",
        "tags": [
            "string",
            "recursion"
        ],
        "test_cases": {
            "inputs": [
                "\"3[a]2[bc]\"",
                "\"3[a2[c]]\"",
                "\"2[abc]3[cd]ef\"",
                "\"4[x]5[y]6[z]\"",
                "\"2[hello]3[world]\"",
                "\"10[a]\"",
                "\"2[ab]3[cd]\"",
                "\"5[a2[b]3[c]]\"",
                "\"2[xyz]4[abc]\"",
                "\"3[hello]2[world]\"",
                "\"1[a]\"",
                "\"2[ab]\"",
                "\"3[abc]\"",
                "\"4[abcd]\"",
                "\"5[abcde]\"",
                "\"6[abcdef]\"",
                "\"7[abcdefg]\"",
                "\"8[abcdefgh]\"",
                "\"9[abcdefghi]\"",
                "\"10[abcdefghij]\""
            ],
            "outputs": [
                "\"aaabcbc\"",
                "\"accaccacc\"",
                "\"abcabccdcdcdef\"",
                "\"xxxxyyyyyzzzzzz\"",
                "\"hellohelloworldworldworld\"",
                "\"aaaaaaaaaa\"",
                "\"ababcdcdcdbcdcdbcdcdbcd\"",
                "\"abbbcccabbbcccabbbccc\"",
                "\"xyzxyzabcxyzxyzabcxyzxyzabcxyzxyzabc\"",
                "\"hellohellohelloworldworldworld\"",
                "\"a\"",
                "\"abab\"",
                "\"abcabcabc\"",
                "\"abcdabcdabcdabcd\"",
                "\"abcdeabcdeabcdeabcdeabcde\"",
                "\"abcdefabcdefabcdefabcdefabcdef\"",
                "\"abcdefgabcdefgabcdefgabcdefgabcdefg\"",
                "\"abcdefghabcdefghabcdefghabcdefghabcdefgh\"",
                "\"abcdefghiabcdefghiabcdefghiabcdefghiabcdefghi\"",
                "\"abcdefghijabcdefghijabcdefghijabcdefghijabcdefghij\""
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <stack>\n\nstd::string decodeString(const std::string &s) {\n    std::stack<int> counts;\n    std::stack<std::string> results;\n    std::string current;\n    int ptr = 0;\n\n    while (ptr < s.size()) {\n        if (isdigit(s[ptr])) {\n            int count = 0;\n            while (isdigit(s[ptr])) {\n                count = count * 10 + (s[ptr] - '0');\n                ptr++;\n            }\n            counts.push(count);\n        } else if (s[ptr] == '[') {\n            results.push(current);\n            current = \"\";\n            ptr++;\n        } else if (s[ptr] == ']') {\n            std::string prev = results.top();\n            results.pop();\n            int count = counts.top();\n            counts.pop();\n            for (int i = 0; i < count; i++) {\n                prev += current;\n            }\n            current = prev;\n            ptr++;\n        } else {\n            current += s[ptr];\n            ptr++;\n        }\n    }\n\n    return current;\n}\n",
            "java": "import java.util.*;\n\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Integer> counts = new Stack<>();\n        Stack<String> results = new Stack<>();\n        String current = \"\";\n        int ptr = 0;\n\n        while (ptr < s.length()) {\n            if (Character.isDigit(s.charAt(ptr))) {\n                int count = 0;\n                while (Character.isDigit(s.charAt(ptr))) {\n                    count = count * 10 + (s.charAt(ptr) - '0');\n                    ptr++;\n                }\n                counts.push(count);\n            } else if (s.charAt(ptr) == '[') {\n                results.push(current);\n                current = \"\";\n                ptr++;\n            } else if (s.charAt(ptr) == ']') {\n                String prev = results.pop();\n                int count = counts.pop();\n                for (int i = 0; i < count; i++) {\n                    prev += current;\n                }\n                current = prev;\n                ptr++;\n            } else {\n                current += s.charAt(ptr);\n                ptr++;\n            }\n        }\n\n        return current;\n    }\n}\n",
            "python": "def decodeString(s):\n    counts = []\n    results = []\n    current = \"\"\n    ptr = 0\n\n    while ptr < len(s):\n        if s[ptr].isdigit():\n            count = 0\n            while s[ptr].isdigit():\n                count = count * 10 + int(s[ptr])\n                ptr += 1\n            counts.append(count)\n        elif s[ptr] == '[':\n            results.append(current)\n            current = \"\"\n            ptr += 1\n        elif s[ptr] == ']':\n            prev = results.pop()\n            count = counts.pop()\n            current = prev + current * count\n            ptr += 1\n        else:\n            current += s[ptr]\n            ptr += 1\n\n    return current\n",
            "javascript": "function decodeString(s) {\n    const counts = [];\n    const results = [];\n    let current = \"\";\n    let ptr = 0;\n\n    while (ptr < s.length) {\n        if (s[ptr].match(/\\d/)) {\n            let count = 0;\n            while (s[ptr].match(/\\d/)) {\n                count = count * 10 + parseInt(s[ptr]);\n                ptr++;\n            }\n            counts.push(count);\n        } else if (s[ptr] === '[') {\n            results.push(current);\n            current = \"\";\n            ptr++;\n        } else if (s[ptr] === ']') {\n            const prev = results.pop();\n            const count = counts.pop();\n            for (let i = 0; i < count; i++) {\n                prev += current;\n            }\n            current = prev;\n            ptr++;\n        } else {\n            current += s[ptr];\n            ptr++;\n        }\n    }\n\n    return current;\n}\n",
            "explanation": "1. Initialize two stacks `counts` and `results`, a pointer `ptr`, and a `current` string.\n2. Loop through the input string `s`.\n3. If the current character is a digit, calculate the number and push it onto the `counts` stack.\n4. If the current character is an opening bracket `[`, push the `current` string into the `results` stack and reset the `current` string.\n5. If the current character is a closing bracket `]`, pop the top strings from the `results` stack and multiply the `current` string with the top count from the `counts` stack. Update the `current` string.\n6. If the current character is a letter, add it to the `current` string.\n7. After looping through `s`, return the `current` string, which is now the decoded version of the input string."
        },
        "structure": {
            "c++": "#include <string>\n#include <stack>\n\nstd::string decodeString(const std::string &s)  {\n    // Your code here\n}\n",
            "java": "i {mport java.util.*;\n\nclass Solution \n    // Your code here\n}\n",
            "python": "def decodeString(s):\n    # Your code here\n\n",
            "javascript": "function decodeString(s)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <stack>\n\nstd::string decodeString(const std::string &s) {\n    std::stack<int> counts;\n    std::stack<std::string> results;\n    std::string current;\n    int ptr = 0;\n\n    while (ptr < s.size()) {\n        if (isdigit(s[ptr])) {\n            int count = 0;\n            while (isdigit(s[ptr])) {\n                count = count * 10 + (s[ptr] - '0');\n                ptr++;\n            }\n            counts.push(count);\n        } else if (s[ptr] == '[') {\n            results.push(current);\n            current = \"\";\n            ptr++;\n        } else if (s[ptr] == ']') {\n            std::string prev = results.top();\n            results.pop();\n            int count = counts.top();\n            counts.pop();\n            for (int i = 0; i < count; i++) {\n                prev += current;\n            }\n            current = prev;\n            ptr++;\n        } else {\n            current += s[ptr];\n            ptr++;\n        }\n    }\n\n    return current;\n}\n\nint main() {\n    std::string s = $args;\n    std::string result = decodeString(s);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n        int n = $args;\n        boolean result = isPowerOfFour(n);\n        System.out.println(result);\n    }\n",
            "python": "if __name__ == \"__main__\":\n    s = $args[0]\n    result = decodeString(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = decodeString(s);\n    console.log(result);\n}"
        },
        "Qid": "394"
    },
    {
        "_id": {
            "$oid": "662065918257d25e0805c76f"
        },
        "title": "Minimum Operations to Reach One",
        "description": "Given a positive integer `n`, you can apply one of the following operations:\n\n1. If `n` is even, replace `n` with `n / 2`.\n2. If `n` is odd, replace `n` with either `n + 1` or `n - 1`.\n\nReturn the minimum number of operations needed for `n` to become 1.",
        "example": "Example:\n\nInput: n = 8\nOutput: 3\nExplanation: 8 -> 4 -> 2 -> 1",
        "level": "Easy",
        "tags": [
            "math",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                8,
                7,
                4,
                1,
                15,
                100,
                231
            ],
            "outputs": [
                3,
                4,
                2,
                0,
                5,
                7,
                9
            ]
        },
        "sample_code": {
            "c++": "int minOperations(int n) {\n    int steps = 0;\n    while(n > 1) {\n        n = (n % 2 == 0) ? n / 2 : n - 1;\n        steps++;\n    }\n    return steps;\n}\n",
            "java": "int minOperations(int n) {\n    int steps = 0;\n    while(n > 1) {\n        n = (n % 2 == 0) ? n / 2 : n - 1;\n        steps++;\n    }\n    return steps;\n}\n",
            "python": "def min_operations(n):\n    steps = 0\n    while n > 1:\n        n = n // 2 if n % 2 == 0 else n - 1\n        steps += 1\n    return steps\n",
            "javascript": "function minOperations(n) {\n    let steps = 0;\n    while(n > 1) {\n        n = (n % 2 === 0) ? n / 2 : n - 1;\n        steps++;\n    }\n    return steps;\n}\n",
            "explanation": "The algorithm to calculate the minimum number of operations needed for n to become 1 is straightforward. We initialize a variable `steps` to 0 to keep track of the number of operations performed. In a loop, we iterate until n becomes 1.\n\nIn each iteration of the loop, we check if n is an even number (n % 2 == 0). If it is, we divide n by 2; otherwise, we subtract 1 from n. We increase the count of `steps` by 1 in each iteration.\n\nFinally, we return the total number of `steps` when the loop terminates (when n becomes 1)."
        },
        "structure": {
            "c++": "int minOperations(int n)  {\n    // Your code here\n}\n",
            "java": "int minOperations(int n)  {\n    // Your code here\n}\n",
            "python": "def min_operations(n):\n    # Your code here\n\n",
            "javascript": "function minOperations(n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = minOperations(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "int minOperations(int n) {\n    int steps = 0;\n    while(n > 1) {\n        n = (n % 2 == 0) ? n / 2 : n - 1;\n        steps++;\n    }\n    return steps;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    result = min_operations(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = minOperations(n);\n    console.log(result);\n}"
        },
        "Qid": "397"
    },
    {
        "_id": {
            "$oid": "6620664a8257d25e0805c770"
        },
        "title": "Nth Digit of Infinite Integer Sequence",
        "description": "Given an integer `n`, return the `nth` digit of the infinite integer sequence `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]`. The sequence starts from 1 and continues indefinitely by concatenating the next integer to the previous one. For example, the first 10 digits of the sequence are 1234567891. Write a function that takes an integer `n` as input and returns the `nth` digit of the sequence.",
        "example": "Example:\n\nInput: n = 3\nOutput: 3\n\nInput: n = 11\nOutput: 0\nExplanation: The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.",
        "level": "Easy",
        "tags": [
            "Math",
            "Sequence"
        ],
        "test_cases": {
            "inputs": [
                3,
                11,
                15,
                25,
                100,
                123,
                1000,
                10000,
                100000,
                1000000,
                10000000,
                100000000,
                1000000000,
                {
                    "$numberLong": "10000000000"
                },
                {
                    "$numberLong": "100000000000"
                },
                {
                    "$numberLong": "1000000000000"
                },
                {
                    "$numberLong": "10000000000000"
                },
                {
                    "$numberLong": "100000000000000"
                },
                {
                    "$numberLong": "1000000000000000"
                },
                {
                    "$numberLong": "10000000000000000"
                }
            ],
            "outputs": [
                3,
                0,
                2,
                7,
                5,
                1,
                1,
                7,
                5,
                1,
                7,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "int findNthDigit(int n) {\n    int size = 1;\n    long length = 9;\n    int start = 1;\n\n    while (n > length * size) {\n        n -= length * size;\n        size++;\n        length *= 10;\n        start *= 10;\n    }\n\n    start += (n - 1) / size;\n    string s = to_string(start);\n    return s[(n - 1) % size] - '0';\n}\n",
            "java": "public int findNthDigit(int n) {\n    int size = 1;\n    long length = 9;\n    int start = 1;\n\n    while (n > length * size) {\n        n -= length * size;\n        size++;\n        length *= 10;\n        start *= 10;\n    }\n\n    start += (n - 1) / size;\n    String s = Integer.toString(start);\n    return Character.getNumericValue(s.charAt((n - 1) % size));\n}\n",
            "python": "def findNthDigit(n):\n    size = 1\n    length = 9\n    start = 1\n\n    while n > length * size:\n        n -= length * size\n        size += 1\n        length *= 10\n        start *= 10\n\n    start += (n - 1) // size\n    s = str(start)\n    return int(s[(n - 1) % size])\n",
            "javascript": "function findNthDigit(n) {\n    let size = 1;\n    let length = 9;\n    let start = 1;\n\n    while (n > length * size) {\n        n -= length * size;\n        size++;\n        length *= 10;\n        start *= 10;\n    }\n\n    start += Math.floor((n - 1) / size);\n    const s = start.toString();\n    return parseInt(s.charAt((n - 1) % size));\n}\n",
            "explanation": "The solution works as follows:\n1. Initialize the `size` of each number at `1` (single-digit numbers), the `length` of numbers of that size at 9 (there are 9 single-digit numbers), and the `start` number of size `1` as `1`.\n2. Keep subtracting the total length of numbers of the current size from `n` as long as `n` is greater than the total length of numbers of that size.\n3. Increment `size` and multiply `length` and `start` by `10` when moving to the next size.\n4. Add `(n - 1) / size` to `start` (adjusted for index 0) to find the number in the sequence that contains the nth digit.\n5. Convert the found number to a string, and return the digit at position `(n - 1) % size`. In C++ and JavaScript, subtract '0' or use `parseInt` to convert the character back to an integer."
        },
        "structure": {
            "c++": "int findNthDigit(int n)  {\n    // Your code here\n}\n",
            "java": "public int findNthDigit(int n)  {\n    // Your code here\n}\n",
            "python": "def findNthDigit(n):\n    # Your code here\n\n",
            "javascript": "function findNthDigit(n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = findNthDigit(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int findNthDigit(int n) {\n    int size = 1;\n    long length = 9;\n    int start = 1;\n\n    while (n > length * size) {\n        n -= length * size;\n        size++;\n        length *= 10;\n        start *= 10;\n    }\n\n    start += (n - 1) / size;\n    String s = Integer.toString(start);\n    return Character.getNumericValue(s.charAt((n - 1) % size));\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = findNthDigit(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = findNthDigit(n);\n    console.log(result);\n}"
        },
        "Qid": "400"
    },
    {
        "_id": {
            "$oid": "662071ce8257d25e0805c771"
        },
        "title": "Binary Watch Time Combinations",
        "description": "A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right. Given an integer `turnedOn` which represents the number of LEDs that are currently on (ignoring the PM), return all possible times the watch could represent. The hour must not contain a leading zero. The minute must consist of two digits and may contain a leading zero.",
        "example": "For example, if the `turnedOn` is 1, the possible times the watch could represent are ['0:01', '0:02', '0:04', '0:08', '0:16', '0:32', '1:00', '2:00', '4:00', '8:00'].",
        "level": "Medium",
        "tags": [
            "bit manipulation",
            "combinations"
        ],
        "test_cases": {
            "inputs": [
                1,
                9,
                0,
                2,
                5
            ],
            "outputs": [
                [
                    "0:01",
                    "0:02",
                    "0:04",
                    "0:08",
                    "0:16",
                    "0:32",
                    "1:00",
                    "2:00",
                    "4:00",
                    "8:00"
                ],
                [],
                [
                    "0:00"
                ],
                [
                    "0:03",
                    "0:05",
                    "0:09",
                    "0:06",
                    "0:10",
                    "0:18",
                    "0:33",
                    "0:17",
                    "0:34",
                    "0:20",
                    "0:36",
                    "0:24",
                    "0:40",
                    "0:48",
                    "1:01",
                    "1:02",
                    "1:04",
                    "1:08",
                    "1:16",
                    "1:32",
                    "2:01",
                    "2:02",
                    "2:04",
                    "2:08",
                    "2:16",
                    "2:32",
                    "4:01",
                    "4:02",
                    "4:04",
                    "4:08",
                    "4:16",
                    "4:32",
                    "8:01",
                    "8:02",
                    "8:04",
                    "8:08",
                    "8:16",
                    "8:32"
                ],
                [
                    "0:31",
                    "0:47",
                    "0:55",
                    "0:59",
                    "1:30",
                    "1:46",
                    "1:54",
                    "1:58",
                    "2:30",
                    "2:46",
                    "2:54",
                    "2:58",
                    "3:30",
                    "3:46",
                    "3:54",
                    "3:58",
                    "4:30",
                    "4:46",
                    "4:54",
                    "4:58",
                    "5:30",
                    "5:46",
                    "5:54",
                    "5:58",
                    "6:30",
                    "6:46",
                    "6:54",
                    "6:58",
                    "7:30",
                    "7:46",
                    "7:54",
                    "7:58",
                    "8:30",
                    "8:46",
                    "8:54",
                    "8:58",
                    "9:30",
                    "9:46",
                    "9:54",
                    "9:58",
                    "10:30",
                    "10:46",
                    "10:54",
                    "10:58",
                    "11:30",
                    "11:46",
                    "11:54",
                    "11:58"
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> readBinaryWatch(int turnedOn) {\n    vector<string> times;\n    for (int h = 0; h < 12; h++) {\n        for (int m = 0; m < 60; m++) {\n            if (__builtin_popcount(h) + __builtin_popcount(m) == turnedOn) {\n                times.push_back(to_string(h) + (m < 10 ? \":0\" : \":\") + to_string(m));\n            }\n        }\n    }\n    return times;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> readBinaryWatch(int turnedOn) {\n    List<String> times = new ArrayList<>();\n    for (int h = 0; h < 12; h++) {\n        for (int m = 0; m < 60; m++) {\n            if (Integer.bitCount(h) + Integer.bitCount(m) == turnedOn) {\n                times.add(String.format(\"%d:%02d\", h, m));\n            }\n        }\n    }\n    return times;\n}\n",
            "python": "def readBinaryWatch(turnedOn: int):\n    def count_bits(n):\n        return bin(n).count('1')\n\n    times = []\n    for h in range(12):\n        for m in range(60):\n            if count_bits(h) + count_bits(m) == turnedOn:\n                times.append(f\"{h}:{m:02d}\")\n    return times\n",
            "javascript": "function readBinaryWatch(turnedOn) {\n    function countBits(n) {\n        return n.toString(2).split('1').length - 1;\n    }\n\n    const times = [];\n    for (let h = 0; h < 12; h++) {\n        for (let m = 0; m < 60; m++) {\n            if (countBits(h) + countBits(m) === turnedOn) {\n                times.push(`${h}:${m.toString().padStart(2, '0')}`);\n            }\n        }\n    }\n    return times;\n}\n",
            "explanation": "The algorithm consists of enumerating all possible hour values (0-11) and minute values (0-59), and checking the number of bits set in both. We have a helper function `count_bits` (or named similarly) in each language to count the number of bits set in the binary representation of a given value. The function either uses the built-in bit counting function (__builtin_popcount in C++, Integer.bitCount in Java), or in Python and JavaScript, we convert the numbers to binary strings and count the number of '1's. \n\nFor each pair (h, m), if the total number of turned-on LEDs is equal to the given integer `turnedOn`, we add the corresponding formatted string to the result list. In the end, we return the list of all possible times."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> readBinaryWatch(int turnedOn)  {\n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> readBinaryWatch(int turnedOn)  {\n    // Your code here\n}\n",
            "python": "def readBinaryWatch(turnedOn: int):\n    # Your code here\n\n",
            "javascript": "function readBinaryWatch(turnedOn)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\nusing namespace std;\n\nint main() {\n    int turnedOn = $args;\n    vector<string> result = readBinaryWatch(turnedOn);\n    for (string time : result) {\n        cout << time << endl;\n    }\n    return 0;\n}",
            "java": "public List<String> readBinaryWatch(int turnedOn) {\n    List<String> times = new ArrayList<>();\n    for (int h = 0; h < 12; h++) {\n        for (int m = 0; m < 60; m++) {\n            if (Integer.bitCount(h) + Integer.bitCount(m) == turnedOn) {\n                times.add(String.format(\"%d:%02d\", h, m));\n            }\n        }\n    }\n    return times;\n}",
            "python": "if __name__ == \"__main__\":\n    turnedOn = $args\n    result = readBinaryWatch(turnedOn)\n    print(result)",
            "javascript": "function main() {\n    const turnedOn = $args;\n    const result = readBinaryWatch(turnedOn);\n    console.log(result);\n}"
        },
        "Qid": "401"
    },
    {
        "_id": {
            "$oid": "6620720a8257d25e0805c772"
        },
        "title": "Frog River Crossing",
        "description": "A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water. Given a list of `stones`' positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit. If the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.",
        "example": "Example:\n\nInput: stones = [0,1,3,5,6,8,12,17]\nOutput: true\nExplanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    0,
                    1,
                    3,
                    5,
                    6,
                    8,
                    12,
                    17
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4,
                    8,
                    9,
                    11
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99,
                    100
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                true,
                false
            ]
        },
        "sample_code": {
            "c++": "#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nbool canCross(vector<int>& stones) {\n    unordered_map<int, unordered_set<int>> dp;\n    int n = stones.size();\n    for (int stone : stones)\n        dp[stone] = unordered_set<int>();\n    dp[0].insert(0);\n\n    for (int stone : stones) {\n        for (int k : dp[stone]) {\n            for (int jump : {k - 1, k, k + 1}) {\n                if (jump > 0 && dp.count(stone + jump))\n                    dp[stone + jump].insert(jump);\n            }\n        }\n    }\n    return !dp[stones.back()].empty();\n}\n\n",
            "java": "import java.util.*;\n\npublic boolean canCross(int[] stones) {\n    Map<Integer, Set<Integer>> dp = new HashMap<>();\n    for (int stone : stones)\n        dp.put(stone, new HashSet<>());\n    dp.get(0).add(0);\n\n    for (int stone : stones) {\n        for (int k : dp.get(stone)) {\n            for (int jump : new int[]{k - 1, k, k + 1}) {\n                if (jump > 0 && dp.containsKey(stone + jump))\n                    dp.get(stone + jump).add(jump);\n            }\n        }\n    }\n    return !dp.get(stones[stones.length - 1]).isEmpty();\n}\n\n",
            "python": "def can_cross(stones):\n    dp = {stone: set() for stone in stones}\n    dp[0].add(0)\n\n    for stone in stones:\n        for k in dp[stone]:\n            for jump in (k - 1, k, k + 1):\n                if jump > 0 and stone + jump in dp:\n                    dp[stone + jump].add(jump)\n\n    return bool(dp[stones[-1]])\n\n",
            "javascript": "function canCross(stones) {\n    const dp = new Map();\n    stones.forEach(stone => dp.set(stone, new Set()));\n    dp.get(0).add(0);\n\n    for (const stone of stones) {\n        for (const k of dp.get(stone)) {\n            for (const jump of [k - 1, k, k + 1]) {\n                if (jump > 0 && dp.has(stone + jump))\n                    dp.get(stone + jump).add(jump);\n            }\n        }\n    }\n    return dp.get(stones[stones.length - 1]).size > 0;\n}\n\n",
            "explanation": "The algorithm initializes an empty hash map `dp` with a key for each stone position and the values set to be an empty set. We then add the initial jump (0) to the first stone in the `dp` hash map. The algorithm proceeds iteratively for each of the stones. For each stone, the algorithm checks all possible jump lengths (`k`) in the `dp` hash map for the stone. The next possible jumps are then calculated (k - 1, k, and k + 1) and added to their respective stone positions in the `dp` map. This process continues until all stones are traversed. At the end, if the last stone in `dp` map contains any elements, it means the frog can reach the last stone, and the function returns True/True or False. Otherwise, the function returns False/false."
        },
        "structure": {
            "c++": "#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nbool canCross(vector<int>& stones)  {\n    // Your code here\n}\n\n",
            "java": "import java.util.*;\n\npublic boolean canCross(int[] stones)  {\n    // Your code here\n}\n\n",
            "python": "def can_cross(stones):\n    # Your code here\n\n",
            "javascript": "function canCross(stones)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nbool canCross(vector<int>& stones) {\n    unordered_map<int, unordered_set<int>> dp;\n    int n = stones.size();\n    for (int stone : stones)\n        dp[stone] = unordered_set<int>();\n    dp[0].insert(0);\n\n    for (int stone : stones) {\n        for (int k : dp[stone]) {\n            for (int jump : {k - 1, k, k + 1}) {\n                if (jump > 0 && dp.count(stone + jump))\n                    dp[stone + jump].insert(jump);\n            }\n        }\n    }\n    return !dp[stones.back()].empty();\n}\n\nint main() {\n    vector<int> stones = $args;\n    bool result = canCross(stones);\n    cout << boolalpha << result << endl;\n    return 0;\n}",
            "java": "public boolean canCross(int[] stones) {\n    Map<Integer, Set<Integer>> dp = new HashMap<>();\n    for (int stone : stones)\n        dp.put(stone, new HashSet<>());\n    dp.get(0).add(0);\n\n    for (int stone : stones) {\n        for (int k : dp.get(stone)) {\n            for (int jump : new int[]{k - 1, k, k + 1}) {\n                if (jump > 0 && dp.containsKey(stone + jump))\n                    dp.get(stone + jump).add(jump);\n            }\n        }\n    }\n    return !dp.get(stones[stones.length - 1]).isEmpty();\n}",
            "python": "if __name__ == \"__main__\":\n    stones = $args[0]\n    result = can_cross(stones)\n    print(result)",
            "javascript": "function main() {\n    const stones = $args;\n    const dp = new Map();\n    stones.forEach(stone => dp.set(stone, new Set()));\n    dp.get(0).add(0);\n\n    for (const stone of stones) {\n        for (const k of dp.get(stone)) {\n            for (const jump of [k - 1, k, k + 1]) {\n                if (jump > 0 && dp.has(stone + jump))\n                    dp.get(stone + jump).add(jump);\n            }\n        }\n    }\n    return dp.get(stones[stones.length - 1]).size > 0;\n}\n"
        },
        "Qid": "403"
    },
    {
        "_id": {
            "$oid": "662072228257d25e0805c773"
        },
        "title": "Hexadecimal Representation",
        "description": "Given an integer `num`, return a string representing its hexadecimal representation. For negative integers, two's complement method is used. All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.",
        "example": "Example:\n\nInput: num = 26\nOutput: \"1a\"\n\nInput: num = -1\nOutput: \"ffffffff\"",
        "level": "Easy",
        "tags": [
            "math",
            "bit manipulation"
        ],
        "test_cases": {
            "inputs": [
                26,
                -1,
                0,
                15,
                16,
                255,
                -255,
                1000,
                -1000,
                2147483647,
                -2147483648
            ],
            "outputs": [
                "1a",
                "ffffffff",
                "0",
                "f",
                "10",
                "ff",
                "ffffff01",
                "3e8",
                "fffffc18",
                "7fffffff",
                "80000000"
            ]
        },
        "sample_code": {
            "c++": "std::string toHex(int num) {\n    if (num == 0) return \"0\";\n    std::string hex = \"\";\n    unsigned int n = num;\n    char hexDigits[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n    while (n) {\n        hex = hexDigits[n & 15] + hex;\n        n >>= 4;\n    }\n    return hex;\n}\n",
            "java": "public String toHex(int num) {\n    if (num == 0) return \"0\";\n    String hex = \"\";\n    char[] hexDigits = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n    for (int i = 0; num != 0 && i < 8; ++i) {\n        hex = hexDigits[num & 0xf] + hex;\n        num >>>= 4;\n    }\n    return hex;\n}\n",
            "python": "def to_hex(num: int) -> str:\n    if num == 0:\n        return '0'\n    hex_str = ''\n    hex_digits = '0123456789abcdef'\n    n = num & 0xffffffff\n    while n:\n        hex_str = hex_digits[n & 0xf] + hex_str\n        n >>= 4\n    return hex_str\n",
            "javascript": "function toHex(num) {\n  if (num === 0) return '0';\n  const hexDigits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n  let hex = '';\n  let n = num >>> 0;\n  while (n) {\n    hex = hexDigits[n & 0xf] + hex;\n    n >>>= 4;\n  }\n  return hex;\n}\n",
            "explanation": "The algorithm for converting an integer to its hexadecimal representation follows these steps:\n\n1. Check if the input number is 0, if so, return the string \"0\".\n2. Initialize an empty string (hex) to store the hexadecimal representation of the integer.\n3. Initialize an array or string (hexDigits) containing the characters representing the hexadecimal digits from 0 to 15 (0-9 and a-f).\n4. If the input integer is negative, convert it to its unsigned 32-bit integer representation.\n5. While the integer is not 0, extract the last 4 bits using a bitwise AND operation with the value `0xf` (15 in decimal) and use the result as an index to get the corresponding hexadecimal character from hexDigits. Append this character to the left side of the hex string.\n6. Shift the integer right by 4 bits (n >>= 4) to move on to the next 4 bits.\n7. Repeat steps 5 and 6 until the integer is 0.\n8. Return the hex string as the final hexadecimal representation of the input integer."
        },
        "structure": {
            "c++": "std::string toHex(int num)  {\n    // Your code here\n}\n",
            "java": "public String toHex(int num)  {\n    // Your code here\n}\n",
            "python": "def to_hex(num: int) -> str:\n    # Your code here\n\n",
            "javascript": "function toHex(num)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "std::string toHex(int num) {\n    if (num == 0) return \"0\";\n    std::string hex = \"\";\n    unsigned int n = num;\n    char hexDigits[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n    while (n) {\n        hex = hexDigits[n & 15] + hex;\n        n >>= 4;\n    }\n    return hex;\n}\n\nint main() {\n    int num = $args;\n    std::string result = toHex(num);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public String toHex(int num) {\n    if (num == 0) return \"0\";\n    String hex = \"\";\n    char[] hexDigits = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n    for (int i = 0; num != 0 && i < 8; ++i) {\n        hex = hexDigits[num & 0xf] + hex;\n        num >>>= 4;\n    }\n    return hex;\n}",
            "python": "if __name__ == \"__main__\":\n    num = $args[0]\n    result = to_hex(num)\n    print(result)",
            "javascript": "function main() {\n  const num = $args;\n  const result = toHex(num);\n  console.log(result);\n}"
        },
        "Qid": "405"
    },
    {
        "_id": {
            "$oid": "662072478257d25e0805c774"
        },
        "title": "Reconstruct Queue",
        "description": "You are given an array of people, `people`, which are the attributes of some people in a queue (not necessarily in order). Each `people[i] = [hi, ki]` represents the `ith` person of height `hi` with **exactly** `ki` other people in front who have a height greater than or equal to `hi`. Reconstruct and return the queue that is represented by the input array `people`. The returned queue should be formatted as an array `queue`, where `queue[j] = [hj, kj]` is the attributes of the `jth` person in the queue (`queue[0]` is the person at the front of the queue).",
        "example": "Example:\n\nInput: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]\nOutput: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\nExplanation:\nPerson 0 has height 5 with no other people taller or the same height in front.\nPerson 1 has height 7 with no other people taller or the same height in front.\nPerson 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.\nPerson 3 has height 6 with one person taller or the same height in front, which is person 1.\nPerson 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.\nPerson 5 has height 7 with one person taller or the same height in front, which is person 1.\nHence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        7,
                        0
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        7,
                        1
                    ],
                    [
                        5,
                        0
                    ],
                    [
                        6,
                        1
                    ],
                    [
                        5,
                        2
                    ]
                ],
                [
                    [
                        6,
                        0
                    ],
                    [
                        5,
                        0
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        3,
                        2
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        1,
                        4
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        5,
                        0
                    ]
                ],
                [
                    [
                        5,
                        0
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        1,
                        0
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        1,
                        4
                    ]
                ],
                [
                    [
                        1,
                        4
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        1,
                        0
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        1
                    ],
                    [
                        3,
                        2
                    ],
                    [
                        4,
                        3
                    ],
                    [
                        5,
                        4
                    ]
                ],
                [
                    [
                        5,
                        4
                    ],
                    [
                        4,
                        3
                    ],
                    [
                        3,
                        2
                    ],
                    [
                        2,
                        1
                    ],
                    [
                        1,
                        0
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        5,
                        1
                    ]
                ],
                [
                    [
                        5,
                        1
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        1,
                        0
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        4,
                        1
                    ],
                    [
                        5,
                        0
                    ]
                ],
                [
                    [
                        5,
                        0
                    ],
                    [
                        4,
                        1
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        1,
                        0
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        3,
                        1
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        5,
                        0
                    ]
                ],
                [
                    [
                        5,
                        0
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        3,
                        1
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        1,
                        0
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        1
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        5,
                        0
                    ]
                ],
                [
                    [
                        5,
                        0
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        2,
                        1
                    ],
                    [
                        1,
                        0
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        5,
                        0
                    ]
                ],
                [
                    [
                        5,
                        0
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ]
                ]
            ],
            "outputs": [
                [
                    [
                        5,
                        0
                    ],
                    [
                        7,
                        0
                    ],
                    [
                        5,
                        2
                    ],
                    [
                        6,
                        1
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        7,
                        1
                    ]
                ],
                [
                    [
                        4,
                        0
                    ],
                    [
                        5,
                        0
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        2
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        6,
                        0
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        5,
                        0
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        5,
                        0
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        1,
                        4
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        1,
                        4
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        1
                    ],
                    [
                        3,
                        2
                    ],
                    [
                        4,
                        3
                    ],
                    [
                        5,
                        4
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        1
                    ],
                    [
                        3,
                        2
                    ],
                    [
                        4,
                        3
                    ],
                    [
                        5,
                        4
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        5,
                        1
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        5,
                        1
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        4,
                        1
                    ],
                    [
                        5,
                        0
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        4,
                        1
                    ],
                    [
                        5,
                        0
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        3,
                        1
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        5,
                        0
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        3,
                        1
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        5,
                        0
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        1
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        5,
                        0
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        1
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        5,
                        0
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        5,
                        0
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        5,
                        0
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ]
                ],
                [
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        0
                    ]
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> reconstructQueue(std::vector<std::vector<int>>& people) {\n    std::sort(people.begin(), people.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[0] > b[0] || (a[0] == b[0] && a[1] < b[1]);\n    });\n\n    std::vector<std::vector<int>> result;\n    for (const std::vector<int>& p : people) {\n        result.insert(result.begin() + p[1], p);\n    }\n    return result;\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic int[][] reconstructQueue(int[][] people) {\n    Arrays.sort(people, (a, b) -> a[0] == b[0] ? a[1] - b[1] : b[0] - a[0]);\n\n    List<int[]> result = new ArrayList<>();\n    for (int[] p : people) {\n        result.add(p[1], p);\n    }\n    return result.toArray(new int[people.length][2]);\n}\n\n",
            "python": "from typing import List\n\ndef reconstructQueue(people: List[List[int]]) -> List[List[int]]:\n    people.sort(key=lambda x: (-x[0], x[1]))\n\n    result = []\n    for p in people:\n        result.insert(p[1], p)\n    return result\n\n",
            "javascript": "function reconstructQueue(people) {\n    people.sort((a, b) => {\n        return a[0] !== b[0] ? b[0] - a[0] : a[1] - b[1];\n    });\n\n    const result = [];\n    for (const p of people) {\n        result.splice(p[1], 0, p);\n    }\n    return result;\n}\n\n",
            "explanation": "The algorithm to solve this problem can be broken down into the following steps:\n\n1. Sort the input array of people in decreasing order of height (h). If two people have the same height, sort them in increasing order of the count of taller people in front (k).\n2. Create an empty result array.\n3. Iterate through the sorted input array, and insert each person at the index corresponding to the count of taller people in front (k) in the result array.\n\nThe time complexity of this algorithm is O(n^2) due to the insert operations, where n is the number of people in the input array. The space complexity is O(n), as we construct a new array for the result."
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> reconstructQueue(std::vector<std::vector<int>>& people)  {\n    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic int[][] reconstructQueue(int[][] people)  {\n    // Your code here\n}\n\n",
            "python": "from typing import List\n    # Your code here\n\n",
            "javascript": "function reconstructQueue(people)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nint main() {\n    std::vector<std::vector<int>> people = $args;\n    std::vector<std::vector<int>> result = reconstructQueue(people);\n    for (const std::vector<int>& p : result) {\n        for (int val : p) {\n            std::cout << val << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}\n",
            "java": "public int[][] reconstructQueue(int[][] people) {\n    Arrays.sort(people, (a, b) -> a[0] == b[0] ? a[1] - b[1] : b[0] - a[0]);\n\n    List<int[]> result = new ArrayList<>();\n    for (int[] p : people) {\n        result.add(p[1], p);\n    }\n    return result.toArray(new int[people.length][2]);\n}",
            "python": "if __name__ == \"__main__\":\n    people = $args[0]\n    result = reconstructQueue(people)\n    print(result)",
            "javascript": "function main() {\n    const people = $args;\n    people.sort((a, b) => {\n        return a[0] !== b[0] ? b[0] - a[0] : a[1] - b[1];\n    });\n\n    const result = [];\n    for (const p of people) {\n        result.splice(p[1], 0, p);\n    }\n    console.log(result);\n}"
        },
        "Qid": "406"
    },
    {
        "_id": {
            "$oid": "6620761d8257d25e0805c775"
        },
        "title": "String Abbreviation Matching",
        "description": "Given a string `word` and an abbreviation `abbr`, determine whether the string matches the given abbreviation. A string can be abbreviated by replacing any number of non-adjacent, non-empty substrings with their lengths. The lengths should not have leading zeros. Return true if the string matches the abbreviation, and false otherwise.",
        "example": "Example 1:\n\nInput: word = \"internationalization\", abbr = \"i12iz4n\"\nOutput: true\nExplanation: The word \"internationalization\" can be abbreviated as \"i12iz4n\" (\"i nternational iz atio n\").\n\nExample 2:\n\nInput: word = \"apple\", abbr = \"a2e\"\nOutput: false\nExplanation: The word \"apple\" cannot be abbreviated as \"a2e\".",
        "level": "Medium",
        "tags": [
            "string",
            "substring",
            "matching"
        ],
        "test_cases": {
            "inputs": [
                [
                    "internationalization",
                    "i12iz4n"
                ],
                [
                    "apple",
                    "a2e"
                ],
                [
                    "substitution",
                    "s10n"
                ],
                [
                    "substitution",
                    "sub4u4"
                ],
                [
                    "substitution",
                    "12"
                ],
                [
                    "substitution",
                    "su3i1u2on"
                ],
                [
                    "substitution",
                    "substitution"
                ],
                [
                    "substitution",
                    "s55n"
                ],
                [
                    "substitution",
                    "s010n"
                ],
                [
                    "substitution",
                    "s0ubstitution"
                ],
                [
                    "hello",
                    "h3o"
                ],
                [
                    "hello",
                    "h2o"
                ],
                [
                    "hello",
                    "h1o"
                ],
                [
                    "hello",
                    "h0o"
                ],
                [
                    "hello",
                    "h10o"
                ],
                [
                    "hello",
                    "h01o"
                ],
                [
                    "hello",
                    "h001o"
                ],
                [
                    "hello",
                    "h0001o"
                ],
                [
                    "hello",
                    "h00001o"
                ],
                [
                    "hello",
                    "h000001o"
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                false,
                false,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "bool validWordAbbreviation(string word, string abbr) {\n    int i = 0, j = 0;\n    while (i < word.size() && j < abbr.size()) {\n        if (isdigit(abbr[j])) {\n            if (abbr[j] == '0') return false; // leading zero\n            int num = 0;\n            while (j < abbr.size() && isdigit(abbr[j]))\n                num = num * 10 + (abbr[j++] - '0');\n            i += num;\n        } else {\n            if (word[i++] != abbr[j++]) return false;\n        }\n    }\n    return i == word.size() && j == abbr.size();\n}\n",
            "java": "public boolean validWordAbbreviation(String word, String abbr) {\n    int i = 0, j = 0;\n    while (i < word.length() && j < abbr.length()) {\n        if (Character.isDigit(abbr.charAt(j))) {\n            if (abbr.charAt(j) == '0') return false; // leading zero\n            int num = 0;\n            while (j < abbr.length() && Character.isDigit(abbr.charAt(j)))\n                num = num * 10 + (abbr.charAt(j++) - '0');\n            i += num;\n        } else {\n            if (word.charAt(i++) != abbr.charAt(j++)) return false;\n        }\n    }\n    return i == word.length() && j == abbr.length();\n}\n",
            "python": "def validWordAbbreviation(word, abbr):\n    i, j = 0, 0\n    while i < len(word) and j < len(abbr):\n        if abbr[j].isdigit():\n            if abbr[j] == '0': return False  # leading zero\n            num = 0\n            while j < len(abbr) and abbr[j].isdigit():\n                num = num * 10 + int(abbr[j])\n                j += 1\n            i += num\n        else:\n            if word[i] != abbr[j]: return False\n            i, j = i + 1, j + 1\n    return i == len(word) and j == len(abbr)\n",
            "javascript": "function validWordAbbreviation(word, abbr) {\n    let i = 0, j = 0;\n    while (i < word.length && j < abbr.length) {\n        if (!isNaN(abbr[j])) {\n            if (abbr[j] === '0') return false; // leading zero\n            let num = 0;\n            while (j < abbr.length && !isNaN(abbr[j])) {\n                num = num * 10 + parseInt(abbr[j]);\n                j++;\n            }\n            i += num;\n        } else {\n            if (word[i] !== abbr[j]) return false;\n            i++; j++;\n        }\n    }\n    return i === word.length && j === abbr.length;\n}\n",
            "explanation": "The algorithm uses two pointers, i and j, to compare the characters in the word and the abbr. If the current character in abbr is a digit, we check if it's a leading zero and return false if so. Then, we sum all the consecutive digits to calculate the number and update i accordingly. If the current character is a letter, we compare the characters in word and abbr and return false if they're not equal. Finally, we check if we've reached the end of both the word and the abbr and return true if so."
        },
        "structure": {
            "c++": "bool validWordAbbreviation(string word, string abbr)  {\n    // Your code here\n}\n",
            "java": "public boolean validWordAbbreviation(String word, String abbr)  {\n    // Your code here\n}\n",
            "python": "def validWordAbbreviation(word, abbr):\n    # Your code here\n\n",
            "javascript": "function validWordAbbreviation(word, abbr)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "bool validWordAbbreviation(string word, string abbr) {\n    int i = 0, j = 0;\n    while (i < word.size() && j < abbr.size()) {\n        if (isdigit(abbr[j])) {\n            if (abbr[j] == '0') return false; // leading zero\n            int num = 0;\n            while (j < abbr.size() && isdigit(abbr[j]))\n                num = num * 10 + (abbr[j++] - '0');\n            i += num;\n        } else {\n            if (word[i++] != abbr[j++]) return false;\n        }\n    }\n    return i == word.size() && j == abbr.size();\n}",
            "java": "public boolean validWordAbbreviation(String word, String abbr) {\n    int i = 0, j = 0;\n    while (i < word.length() && j < abbr.length()) {\n        if (Character.isDigit(abbr.charAt(j))) {\n            if (abbr.charAt(j) == '0') return false; // leading zero\n            int num = 0;\n            while (j < abbr.length() && Character.isDigit(abbr.charAt(j)))\n                num = num * 10 + (abbr.charAt(j++) - '0');\n            i += num;\n        } else {\n            if (word.charAt(i++) != abbr.charAt(j++)) return false;\n        }\n    }\n    return i == word.length() && j == abbr.length();\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    word = inputs[0]\n    abbr = inputs[1]\n    result = validWordAbbreviation(word, abbr)\n    print(result)",
            "javascript": "function main() {\n    const word = $args[0];\n    const abbr = $args[1];\n    const result = validWordAbbreviation(word, abbr);\n    console.log(result);\n}"
        },
        "Qid": "408"
    },
    {
        "_id": {
            "$oid": "662076988257d25e0805c776"
        },
        "title": "FizzBuzz",
        "description": "Given an integer `n`, return a string array `answer` (1-indexed) where each element follows the FizzBuzz rules. If the element is divisible by 3 and 5, the element should be 'FizzBuzz'. If the element is divisible by 3, the element should be 'Fizz'. If the element is divisible by 5, the element should be 'Buzz'. Otherwise, the element should be the number itself as a string.",
        "example": "For example, given n = 5, the output should be ['1', '2', 'Fizz', '4', 'Buzz'].\nExplanation: \n1 is not divisible by 3 or 5, so it is '1'.\n2 is not divisible by 3 or 5, so it is '2'.\n3 is divisible by 3, so it is 'Fizz'.\n4 is not divisible by 3 or 5, so it is '4'.\n5 is divisible by 5, so it is 'Buzz'.\nTherefore, the output is ['1', '2', 'Fizz', '4', 'Buzz'].",
        "level": "Easy",
        "tags": [
            "Array",
            "Math"
        ],
        "test_cases": {
            "inputs": [
                3,
                5,
                15,
                1,
                10,
                20,
                30,
                100,
                101,
                104,
                1000,
                10000,
                100000,
                1000000,
                10000000,
                100000000,
                1000000000,
                {
                    "$numberLong": "10000000000"
                },
                {
                    "$numberLong": "100000000000"
                },
                {
                    "$numberLong": "1000000000000"
                }
            ],
            "outputs": [
                [
                    "1",
                    "2",
                    "Fizz"
                ],
                [
                    "1",
                    "2",
                    "Fizz",
                    "4",
                    "Buzz"
                ],
                [
                    "1",
                    "2",
                    "Fizz",
                    "4",
                    "Buzz",
                    "Fizz",
                    "7",
                    "8",
                    "Fizz",
                    "Buzz",
                    "11",
                    "Fizz",
                    "13",
                    "14",
                    "FizzBuzz"
                ],
                [
                    "1"
                ],
                [
                    "1",
                    "2",
                    "Fizz",
                    "4",
                    "Buzz",
                    "Fizz",
                    "7",
                    "8",
                    "Fizz",
                    "Buzz"
                ],
                [
                    "1",
                    "2",
                    "Fizz",
                    "4",
                    "Buzz",
                    "Fizz",
                    "7",
                    "8",
                    "Fizz",
                    "Buzz",
                    "11",
                    "Fizz",
                    "13",
                    "14",
                    "FizzBuzz",
                    "16",
                    "17",
                    "Fizz",
                    "19",
                    "Buzz"
                ],
                [
                    "1",
                    "2",
                    "Fizz",
                    "4",
                    "Buzz",
                    "Fizz",
                    "7",
                    "8",
                    "Fizz",
                    "Buzz",
                    "11",
                    "Fizz",
                    "13",
                    "14",
                    "FizzBuzz",
                    "16",
                    "17",
                    "Fizz",
                    "19",
                    "Buzz",
                    "Fizz",
                    "22",
                    "23",
                    "Fizz",
                    "Buzz",
                    "26",
                    "Fizz",
                    "28",
                    "29",
                    "FizzBuzz"
                ],
                [
                    "1",
                    "2",
                    "Fizz",
                    "4",
                    "Buzz",
                    "Fizz",
                    "7",
                    "8",
                    "Fizz",
                    "Buzz",
                    "11",
                    "Fizz",
                    "13",
                    "14",
                    "FizzBuzz",
                    "16",
                    "17",
                    "Fizz",
                    "19",
                    "Buzz",
                    "Fizz",
                    "22",
                    "23",
                    "Fizz",
                    "Buzz",
                    "26",
                    "Fizz",
                    "28",
                    "29",
                    "FizzBuzz",
                    "31",
                    "32",
                    "Fizz",
                    "34",
                    "Buzz",
                    "Fizz",
                    "37",
                    "38",
                    "Fizz",
                    "Buzz",
                    "41",
                    "Fizz",
                    "43",
                    "44",
                    "FizzBuzz",
                    "46",
                    "47",
                    "Fizz",
                    "49",
                    "Buzz",
                    "Fizz",
                    "52",
                    "53",
                    "Fizz",
                    "Buzz",
                    "56",
                    "Fizz",
                    "58",
                    "59",
                    "FizzBuzz",
                    "61",
                    "62",
                    "Fizz",
                    "64",
                    "Buzz",
                    "Fizz",
                    "67",
                    "68",
                    "Fizz",
                    "Buzz",
                    "71",
                    "Fizz",
                    "73",
                    "74",
                    "FizzBuzz",
                    "76",
                    "77",
                    "Fizz",
                    "79",
                    "Buzz",
                    "Fizz",
                    "82",
                    "83",
                    "Fizz",
                    "Buzz",
                    "86",
                    "Fizz",
                    "88",
                    "89",
                    "FizzBuzz",
                    "91",
                    "92",
                    "Fizz",
                    "94",
                    "Buzz",
                    "Fizz",
                    "97",
                    "98",
                    "Fizz",
                    "Buzz"
                ],
                [
                    "1",
                    "2",
                    "Fizz",
                    "4",
                    "Buzz",
                    "Fizz",
                    "7",
                    "8",
                    "Fizz",
                    "Buzz",
                    "11",
                    "Fizz",
                    "13",
                    "14",
                    "FizzBuzz",
                    "16",
                    "17",
                    "Fizz",
                    "19",
                    "Buzz",
                    "Fizz",
                    "22",
                    "23",
                    "Fizz",
                    "Buzz",
                    "26",
                    "Fizz",
                    "28",
                    "29",
                    "FizzBuzz",
                    "31",
                    "32",
                    "Fizz",
                    "34",
                    "Buzz",
                    "Fizz",
                    "37",
                    "38",
                    "Fizz",
                    "Buzz",
                    "41",
                    "Fizz",
                    "43",
                    "44",
                    "FizzBuzz",
                    "46",
                    "47",
                    "Fizz",
                    "49",
                    "Buzz",
                    "Fizz",
                    "52",
                    "53",
                    "Fizz",
                    "Buzz",
                    "56",
                    "Fizz",
                    "58",
                    "59",
                    "FizzBuzz",
                    "61",
                    "62",
                    "Fizz",
                    "64",
                    "Buzz",
                    "Fizz",
                    "67",
                    "68",
                    "Fizz",
                    "Buzz",
                    "71",
                    "Fizz",
                    "73",
                    "74",
                    "FizzBuzz",
                    "76",
                    "77",
                    "Fizz",
                    "79",
                    "Buzz",
                    "Fizz",
                    "82",
                    "83",
                    "Fizz",
                    "Buzz",
                    "86",
                    "Fizz",
                    "88",
                    "89",
                    "FizzBuzz",
                    "91",
                    "92",
                    "Fizz",
                    "94",
                    "Buzz",
                    "Fizz",
                    "97",
                    "98",
                    "Fizz",
                    "Buzz",
                    "Fizz",
                    "Buzz"
                ],
                [
                    "1",
                    "2",
                    "Fizz",
                    "4",
                    "Buzz",
                    "Fizz",
                    "7",
                    "8",
                    "Fizz",
                    "Buzz",
                    "11",
                    "Fizz",
                    "13",
                    "14",
                    "FizzBuzz",
                    "16",
                    "17",
                    "Fizz",
                    "19",
                    "Buzz",
                    "Fizz",
                    "22",
                    "23",
                    "Fizz",
                    "Buzz",
                    "26",
                    "Fizz",
                    "28",
                    "29",
                    "FizzBuzz",
                    "31",
                    "32",
                    "Fizz",
                    "34",
                    "Buzz",
                    "Fizz",
                    "37",
                    "38",
                    "Fizz",
                    "Buzz",
                    "41",
                    "Fizz",
                    "43",
                    "44",
                    "FizzBuzz",
                    "46",
                    "47",
                    "Fizz",
                    "49",
                    "Buzz",
                    "Fizz",
                    "52",
                    "53",
                    "Fizz",
                    "Buzz",
                    "56",
                    "Fizz",
                    "58",
                    "59",
                    "FizzBuzz",
                    "61",
                    "62",
                    "Fizz",
                    "64",
                    "Buzz",
                    "Fizz",
                    "67",
                    "68",
                    "Fizz",
                    "Buzz",
                    "71",
                    "Fizz",
                    "73",
                    "74",
                    "FizzBuzz",
                    "76",
                    "77",
                    "Fizz",
                    "79",
                    "Buzz",
                    "Fizz",
                    "82",
                    "83",
                    "Fizz",
                    "Buzz",
                    "86",
                    "Fizz",
                    "88",
                    "89",
                    "FizzBuzz",
                    "91",
                    "92",
                    "Fizz",
                    "94",
                    "Buzz",
                    "Fizz",
                    "97",
                    "98",
                    "Fizz",
                    "Buzz",
                    "Fizz",
                    "Buzz",
                    "Fizz"
                ],
                [
                    "1",
                    "2",
                    "Fizz",
                    "4",
                    "Buzz",
                    "Fizz",
                    "7",
                    "8",
                    "Fizz",
                    "Buzz",
                    "11",
                    "Fizz",
                    "13",
                    "14",
                    "FizzBuzz",
                    "16",
                    "17",
                    "Fizz",
                    "19",
                    "Buzz",
                    "Fizz",
                    "22",
                    "23",
                    "Fizz",
                    "Buzz",
                    "26",
                    "Fizz",
                    "28",
                    "29",
                    "FizzBuzz",
                    "31",
                    "32",
                    "Fizz",
                    "34",
                    "Buzz",
                    "Fizz",
                    "37",
                    "38",
                    "Fizz",
                    "Buzz",
                    "41",
                    "Fizz",
                    "43",
                    "44",
                    "FizzBuzz",
                    "46",
                    "47",
                    "Fizz",
                    "49",
                    "Buzz",
                    "Fizz",
                    "52",
                    "53",
                    "Fizz",
                    "Buzz",
                    "56",
                    "Fizz",
                    "58",
                    "59",
                    "FizzBuzz",
                    "61",
                    "62",
                    "Fizz",
                    "64",
                    "Buzz",
                    "Fizz",
                    "67",
                    "68",
                    "Fizz",
                    "Buzz",
                    "71",
                    "Fizz",
                    "73",
                    "74",
                    "FizzBuzz",
                    "76",
                    "77",
                    "Fizz",
                    "79",
                    "Buzz",
                    "Fizz",
                    "82",
                    "83",
                    "Fizz",
                    "Buzz",
                    "86",
                    "Fizz",
                    "88",
                    "89",
                    "FizzBuzz",
                    "91",
                    "92",
                    "Fizz",
                    "94",
                    "Buzz",
                    "Fizz",
                    "97",
                    "98",
                    "Fizz",
                    "Buzz",
                    "Fizz",
                    "Buzz",
                    "Fizz",
                    "Buzz"
                ],
                [
                    "1",
                    "2",
                    "Fizz",
                    "4",
                    "Buzz",
                    "Fizz",
                    "7",
                    "8",
                    "Fizz",
                    "Buzz",
                    "11",
                    "Fizz",
                    "13",
                    "14",
                    "FizzBuzz",
                    "16",
                    "17",
                    "Fizz",
                    "19",
                    "Buzz",
                    "Fizz",
                    "22",
                    "23",
                    "Fizz",
                    "Buzz",
                    "26",
                    "Fizz",
                    "28",
                    "29",
                    "FizzBuzz",
                    "31",
                    "32",
                    "Fizz",
                    "34",
                    "Buzz",
                    "Fizz",
                    "37",
                    "38",
                    "Fizz",
                    "Buzz",
                    "41",
                    "Fizz",
                    "43",
                    "44",
                    "FizzBuzz",
                    "46",
                    "47",
                    "Fizz",
                    "49",
                    "Buzz",
                    "Fizz",
                    "52",
                    "53",
                    "Fizz",
                    "Buzz",
                    "56",
                    "Fizz",
                    "58",
                    "59",
                    "FizzBuzz",
                    "61",
                    "62",
                    "Fizz",
                    "64",
                    "Buzz",
                    "Fizz",
                    "67",
                    "68",
                    "Fizz",
                    "Buzz",
                    "71",
                    "Fizz",
                    "73",
                    "74",
                    "FizzBuzz",
                    "76",
                    "77",
                    "Fizz",
                    "79",
                    "Buzz",
                    "Fizz",
                    "82",
                    "83",
                    "Fizz",
                    "Buzz",
                    "86",
                    "Fizz",
                    "88",
                    "89",
                    "FizzBuzz",
                    "91",
                    "92",
                    "Fizz",
                    "94",
                    "Buzz",
                    "Fizz",
                    "97",
                    "98",
                    "Fizz",
                    "Buzz",
                    "Fizz",
                    "Buzz",
                    "Fizz",
                    "Buzz",
                    "FizzBuzz"
                ],
                [
                    "1",
                    "2",
                    "Fizz",
                    "4",
                    "Buzz",
                    "Fizz",
                    "7",
                    "8",
                    "Fizz",
                    "Buzz",
                    "11",
                    "Fizz",
                    "13",
                    "14",
                    "FizzBuzz",
                    "16",
                    "17",
                    "Fizz",
                    "19",
                    "Buzz",
                    "Fizz",
                    "22",
                    "23",
                    "Fizz",
                    "Buzz",
                    "26",
                    "Fizz",
                    "28",
                    "29",
                    "FizzBuzz",
                    "31",
                    "32",
                    "Fizz",
                    "34",
                    "Buzz",
                    "Fizz",
                    "37",
                    "38",
                    "Fizz",
                    "Buzz",
                    "41",
                    "Fizz",
                    "43",
                    "44",
                    "FizzBuzz",
                    "46",
                    "47",
                    "Fizz",
                    "49",
                    "Buzz",
                    "Fizz",
                    "52",
                    "53",
                    "Fizz",
                    "Buzz",
                    "56",
                    "Fizz",
                    "58",
                    "59",
                    "FizzBuzz",
                    "61",
                    "62",
                    "Fizz",
                    "64",
                    "Buzz",
                    "Fizz",
                    "67",
                    "68",
                    "Fizz",
                    "Buzz",
                    "71",
                    "Fizz",
                    "73",
                    "74",
                    "FizzBuzz",
                    "76",
                    "77",
                    "Fizz",
                    "79",
                    "Buzz",
                    "Fizz",
                    "82",
                    "83",
                    "Fizz",
                    "Buzz",
                    "86",
                    "Fizz",
                    "88",
                    "89",
                    "FizzBuzz",
                    "91",
                    "92",
                    "Fizz",
                    "94",
                    "Buzz",
                    "Fizz",
                    "97",
                    "98",
                    "Fizz",
                    "Buzz",
                    "Fizz",
                    "Buzz",
                    "Fizz",
                    "Buzz",
                    "FizzBuzz",
                    "Buzz"
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n\nstd::vector<std::string> fizzBuzz(int n) {\n    std::vector<std::string> result(n);\n    for(int i = 1; i <= n; ++i) {\n        if (i % 15 == 0) result[i - 1] = \"FizzBuzz\";\n        else if (i % 3 == 0) result[i - 1] = \"Fizz\";\n        else if (i % 5 == 0) result[i - 1] = \"Buzz\";\n        else result[i - 1] = std::to_string(i);\n    }\n    return result;\n}\n",
            "java": "import java.util.ArrayList;\n\npublic ArrayList<String> fizzBuzz(int n) {\n    ArrayList<String> result = new ArrayList<>();\n    for (int i = 1; i <= n; i++) {\n        if (i % 15 == 0) result.add(\"FizzBuzz\");\n        else if (i % 3 == 0) result.add(\"Fizz\");\n        else if (i % 5 == 0) result.add(\"Buzz\");\n        else result.add(Integer.toString(i));\n    }\n    return result;\n}\n",
            "python": "def fizzBuzz(n):\n    result = []\n    for i in range(1, n + 1):\n        if i % 15 == 0:\n            result.append(\"FizzBuzz\")\n        elif i % 3 == 0:\n            result.append(\"Fizz\")\n        elif i % 5 == 0:\n            result.append(\"Buzz\")\n        else:\n            result.append(str(i))\n    return result\n",
            "javascript": "function fizzBuzz(n) {\n    let result = [];\n    for (let i = 1; i <= n; i++) {\n        if (i % 15 === 0) result.push(\"FizzBuzz\");\n        else if (i % 3 === 0) result.push(\"Fizz\");\n        else if (i % 5 === 0) result.push(\"Buzz\");\n        else result.push(String(i));\n    }\n    return result;\n}\n",
            "explanation": "The algorithm for this problem simply consists of iterating over the integers from 1 to n, checking the divisibility rules for FizzBuzz, and inserting the appropriate string into the array for each index. For each number i in the range [1,n], we check if it's divisible by 3 and 5 (i % 15 == 0), just 3 (i % 3 == 0), just 5 (i % 5 == 0), or none of the above. Based on the conditions met, we append the corresponding string to the array (i.e., \"FizzBuzz\", \"Fizz\", \"Buzz\", or the number itself as a string).\n\nThe code implementations in each language follow their respective syntax, but the core logic is the same across all languages."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n\nstd::vector<std::string> fizzBuzz(int n)  {\n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\n\npublic ArrayList<String> fizzBuzz(int n)  {\n    // Your code here\n}\n",
            "python": "def fizzBuzz(n):\n    # Your code here\n\n",
            "javascript": "function fizzBuzz(n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <iostream>\n\nint main() {\n    int n = $args;\n    std::vector<std::string> result = fizzBuzz(n);\n    for (const auto& str : result) {\n        std::cout << str << std::endl;\n    }\n    return 0;\n}",
            "java": "public ArrayList<String> fizzBuzz(int n) {\n    ArrayList<String> result = new ArrayList<>();\n    for (int i = 1; i <= n; i++) {\n        if (i % 15 == 0) result.add(\"FizzBuzz\");\n        else if (i % 3 == 0) result.add(\"Fizz\");\n        else if (i % 5 == 0) result.add(\"Buzz\");\n        else result.add(Integer.toString(i));\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    result = fizzBuzz(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = fizzBuzz(n);\n    console.log(result);\n}"
        },
        "Qid": "412"
    },
    {
        "_id": {
            "$oid": "662077918257d25e0805c777"
        },
        "title": "Arithmetic Subarrays",
        "description": "Given an integer array `nums`, find the number of arithmetic subarrays in `nums`. An arithmetic subarray is a contiguous subsequence of `nums` in which the difference between any two consecutive elements is the same.",
        "example": "Example:\n\nInput: nums = [1,2,3,4]\nOutput: 3\nExplanation: We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4], and [1, 2, 3, 4] itself.",
        "level": "Medium",
        "tags": [
            "Array",
            "Dynamic Programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3,
                    4
                ],
                [
                    7,
                    7,
                    7,
                    7
                ],
                [
                    3,
                    -1,
                    -5,
                    -9
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9,
                    11,
                    13,
                    15,
                    17,
                    19,
                    21,
                    23,
                    25,
                    27,
                    29,
                    31,
                    33,
                    35,
                    37,
                    39,
                    41,
                    43,
                    45,
                    47,
                    49,
                    51,
                    53,
                    55,
                    57,
                    59,
                    61,
                    63,
                    65,
                    67,
                    69,
                    71,
                    73,
                    75,
                    77,
                    79,
                    81,
                    83,
                    85,
                    87,
                    89,
                    91,
                    93,
                    95,
                    97,
                    99
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99,
                    100
                ]
            ],
            "outputs": [
                3,
                6,
                8,
                36,
                105,
                190,
                1225,
                45,
                4950
            ]
        },
        "sample_code": {
            "c++": "int numberOfArithmeticSlices(vector<int>& nums) {\n    int n = nums.size(), count = 0, cur = 0;\n    for (int i = 2; i < n; ++i) {\n        if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {\n            cur++;\n            count += cur;\n        } else {\n            cur = 0;\n        }\n    }\n    return count;\n}\n",
            "java": "public int numberOfArithmeticSlices(int[] nums) {\n    int n = nums.length, count = 0, cur = 0;\n    for (int i = 2; i < n; ++i) {\n        if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {\n            cur++;\n            count += cur;\n        } else {\n            cur = 0;\n        }\n    }\n    return count;\n}\n",
            "python": "def numberOfArithmeticSlices(nums):\n    n = len(nums)\n    count, cur = 0, 0\n    for i in range(2, n):\n        if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n            cur += 1\n            count += cur\n        else:\n            cur = 0\n    return count\n",
            "javascript": "function numberOfArithmeticSlices(nums) {\n    let n = nums.length, count = 0, cur = 0;\n    for (let i = 2; i < n; ++i) {\n        if (nums[i] - nums[i - 1] === nums[i - 1] - nums[i - 2]) {\n            cur++;\n            count += cur;\n        } else {\n            cur = 0;\n        }\n    }\n    return count;\n}\n",
            "explanation": "The algorithm iterates through the given integer array `nums`. Starting from the third element (index 2), for each element, it checks if the difference between the current and the previous element is the same as the difference between the previous and the element before the previous one. If the differences are the same, that means we have an arithmetic subarray, so we increment the `cur` value to keep track of the consecutive arithmetic subarrays, and then add `cur` to the `count` which tracks the total number of arithmetic subarrays. If the differences are not the same, we reset `cur` to 0. Finally, the `count` is returned as the result."
        },
        "structure": {
            "c++": "int numberOfArithmeticSlices(vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "public int numberOfArithmeticSlices(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def numberOfArithmeticSlices(nums):\n    # Your code here\n\n",
            "javascript": "function numberOfArithmeticSlices(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> nums = $args;\n    int result = numberOfArithmeticSlices(nums);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int numberOfArithmeticSlices(int[] nums) {\n    int n = nums.length, count = 0, cur = 0;\n    for (int i = 2; i < n; ++i) {\n        if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {\n            cur++;\n            count += cur;\n        } else {\n            cur = 0;\n        }\n    }\n    return count;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = numberOfArithmeticSlices(nums)\n    print(result)",
            "javascript": ""
        },
        "Qid": "413"
    },
    {
        "_id": {
            "$oid": "662077a38257d25e0805c778"
        },
        "title": "Third Distinct Maximum",
        "description": "Given an integer array `nums`, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.",
        "example": "Example 1:\n\nInput: nums = [3,2,1]\nOutput: 1\nExplanation:\nThe first distinct maximum is 3.\nThe second distinct maximum is 2.\nThe third distinct maximum is 1.\n\nExample 2:\n\nInput: nums = [1,2]\nOutput: 2\nExplanation:\nThe first distinct maximum is 2.\nThe second distinct maximum is 1.\nThe third distinct maximum does not exist, so the maximum (2) is returned instead.\n\nExample 3:\n\nInput: nums = [2,2,3,1]\nOutput: 1\nExplanation:\nThe first distinct maximum is 3.\nThe second distinct maximum is 2 (both 2`s are counted together since they have the same value).\nThe third distinct maximum is 1.",
        "level": "Easy",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    2,
                    1
                ],
                [
                    1,
                    2
                ],
                [
                    2,
                    2,
                    3,
                    1
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    1,
                    1,
                    1,
                    2,
                    2,
                    2,
                    3,
                    3,
                    3
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1
                ],
                []
            ],
            "outputs": [
                "1",
                "2",
                "1",
                "5",
                "1",
                "9",
                "-1",
                "0",
                "8",
                "10",
                "1",
                "null"
            ]
        },
        "sample_code": {
            "c++": "#include <set>\n\nint thirdMax(vector<int>& nums) {\n    set<int> top3;\n    for (int num : nums) {\n        top3.insert(num);\n        if (top3.size() > 3) {\n            top3.erase(top3.begin());\n        }\n    }\n    return top3.size() == 3 ? *top3.begin() : *top3.rbegin();\n}\n",
            "java": "import java.util.TreeSet;\n\npublic int thirdMax(int[] nums) {\n    TreeSet<Integer> top3 = new TreeSet<>();\n    for (int num : nums) {\n        top3.add(num);\n        if (top3.size() > 3) {\n            top3.remove(top3.first());\n        }\n    }\n    return top3.size() == 3 ? top3.first() : top3.last();\n}\n",
            "python": "def third_max(nums):\n    top3 = set()\n    for num in nums:\n        top3.add(num)\n        if len(top3) > 3:\n            top3.remove(min(top3))\n    return min(top3) if len(top3) == 3 else max(top3)\n",
            "javascript": "function thirdMax(nums) {\n    const top3 = new Set();\n    for (const num of nums) {\n        top3.add(num);\n        if (top3.size > 3) {\n            top3.delete(Math.min(...top3));\n        }\n    }\n    return top3.size === 3 ? Math.min(...top3) : Math.max(...top3);\n}\n",
            "explanation": "The algorithm to solve the problem is as follows:\n1. Initialize an empty set called `top3` to keep track of the top 3 distinct maximum numbers in the array.\n2. Iterate through the input array, `nums`.\n3. For each number in `nums`, insert it into `top3`.\n4. If the size of `top3` becomes greater than 3, remove the smallest number in `top3`.\n5. If the size of `top3` is 3, which means there are three distinct maximum numbers, return the smallest number in `top3`. Otherwise, return the largest number in `top3`."
        },
        "structure": {
            "c++": "#include <set>\n\nint thirdMax(vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "import java.util.TreeSet;\n\npublic int thirdMax(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def third_max(nums):\n    # Your code here\n\n",
            "javascript": "function thirdMax(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <set>\n\nint main() {\n    vector<int> nums = $args;\n    int result = thirdMax(nums);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int thirdMax(int[] nums) {\n    TreeSet<Integer> top3 = new TreeSet<>();\n    for (int num : nums) {\n        top3.add(num);\n        if (top3.size() > 3) {\n            top3.remove(top3.first());\n        }\n    }\n    return top3.size() == 3 ? top3.first() : top3.last();\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = third_max(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = thirdMax(nums);\n    console.log(result);\n}"
        },
        "Qid": "414"
    },
    {
        "_id": {
            "$oid": "662077e18257d25e0805c779"
        },
        "title": "Partition Equal Subset Sum",
        "description": "Given an integer array `nums`, return `true` if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or `false` otherwise.",
        "example": "Example 1:\n\nInput: nums = [1,5,11,5]\nOutput: true\nExplanation: The array can be partitioned as [1, 5, 5] and [11].\n\nExample 2:\n\nInput: nums = [1,2,3,5]\nOutput: false\nExplanation: The array cannot be partitioned into equal sum subsets.",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    5,
                    11,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9
                ],
                [
                    2,
                    3,
                    5,
                    7,
                    11
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100,
                    110,
                    120,
                    130,
                    140,
                    150,
                    160,
                    170,
                    180,
                    190,
                    200
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100,
                    110,
                    120,
                    130,
                    140,
                    150,
                    160,
                    170,
                    180,
                    190,
                    200,
                    210,
                    220,
                    230,
                    240,
                    250,
                    260,
                    270,
                    280,
                    290,
                    300
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100,
                    110,
                    120,
                    130,
                    140,
                    150,
                    160,
                    170,
                    180,
                    190,
                    200,
                    210,
                    220,
                    230,
                    240,
                    250,
                    260,
                    270,
                    280,
                    290,
                    300,
                    310,
                    320,
                    330,
                    340,
                    350,
                    360,
                    370,
                    380,
                    390,
                    400
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100,
                    110,
                    120,
                    130,
                    140,
                    150,
                    160,
                    170,
                    180,
                    190,
                    200,
                    210,
                    220,
                    230,
                    240,
                    250,
                    260,
                    270,
                    280,
                    290,
                    300,
                    310,
                    320,
                    330,
                    340,
                    350,
                    360,
                    370,
                    380,
                    390,
                    400,
                    410,
                    420,
                    430,
                    440,
                    450,
                    460,
                    470,
                    480,
                    490,
                    500
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    60
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100,
                    110,
                    120,
                    130,
                    140,
                    150,
                    160,
                    170,
                    180,
                    190,
                    200,
                    210,
                    220,
                    230,
                    240,
                    250,
                    260,
                    270,
                    280,
                    290,
                    300,
                    310,
                    320,
                    330,
                    340,
                    350,
                    360,
                    370,
                    380,
                    390,
                    400,
                    410,
                    420,
                    430,
                    440,
                    450,
                    460,
                    470,
                    480,
                    490,
                    500,
                    510,
                    520,
                    530,
                    540,
                    550,
                    560,
                    570,
                    580,
                    590,
                    600
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    70
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100,
                    110,
                    120,
                    130,
                    140,
                    150,
                    160,
                    170,
                    180,
                    190,
                    200,
                    210,
                    220,
                    230,
                    240,
                    250,
                    260,
                    270,
                    280,
                    290,
                    300,
                    310,
                    320,
                    330,
                    340,
                    350,
                    360,
                    370,
                    380,
                    390,
                    400,
                    410,
                    420,
                    430,
                    440,
                    450,
                    460,
                    470,
                    480,
                    490,
                    500,
                    510,
                    520,
                    530,
                    540,
                    550,
                    560,
                    570,
                    580,
                    590,
                    600,
                    610,
                    620,
                    630,
                    640,
                    650,
                    660,
                    670,
                    680,
                    690,
                    700
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    80
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100,
                    110,
                    120,
                    130,
                    140,
                    150,
                    160,
                    170,
                    180,
                    190,
                    200,
                    210,
                    220,
                    230,
                    240,
                    250,
                    260,
                    270,
                    280,
                    290,
                    300,
                    310,
                    320,
                    330,
                    340,
                    350,
                    360,
                    370,
                    380,
                    390,
                    400,
                    410,
                    420,
                    430,
                    440,
                    450,
                    460,
                    470,
                    480,
                    490,
                    500,
                    510,
                    520,
                    530,
                    540,
                    550,
                    560,
                    570,
                    580,
                    590,
                    600,
                    610,
                    620,
                    630,
                    640,
                    650,
                    660,
                    670,
                    680,
                    690,
                    700,
                    710,
                    720,
                    730,
                    740,
                    750,
                    760,
                    770,
                    780,
                    790,
                    800
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    90
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100,
                    110,
                    120,
                    130,
                    140,
                    150,
                    160,
                    170,
                    180,
                    190,
                    200,
                    210,
                    220,
                    230,
                    240,
                    250,
                    260,
                    270,
                    280,
                    290,
                    300,
                    310,
                    320,
                    330,
                    340,
                    350,
                    360,
                    370,
                    380,
                    390,
                    400,
                    410,
                    420,
                    430,
                    440,
                    450,
                    460,
                    470,
                    480,
                    490,
                    500,
                    510,
                    520,
                    530,
                    540,
                    550,
                    560,
                    570,
                    580,
                    590,
                    600,
                    610,
                    620,
                    630,
                    640,
                    650,
                    660,
                    670,
                    680,
                    690,
                    700,
                    710,
                    720,
                    730,
                    740,
                    750,
                    760,
                    770,
                    780,
                    790,
                    800,
                    810,
                    820,
                    830,
                    840,
                    850,
                    860,
                    870,
                    880,
                    890,
                    900
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99,
                    100
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50,
                    60,
                    70,
                    80,
                    90,
                    100,
                    110,
                    120,
                    130,
                    140,
                    150,
                    160,
                    170,
                    180,
                    190,
                    200,
                    210,
                    220,
                    230,
                    240,
                    250,
                    260,
                    270,
                    280,
                    290,
                    300,
                    310,
                    320,
                    330,
                    340,
                    350,
                    360,
                    370,
                    380,
                    390,
                    400,
                    410,
                    420,
                    430,
                    440,
                    450,
                    460,
                    470,
                    480,
                    490,
                    500,
                    510,
                    520,
                    530,
                    540,
                    550,
                    560,
                    570,
                    580,
                    590,
                    600,
                    610,
                    620,
                    630,
                    640,
                    650,
                    660,
                    670,
                    680,
                    690,
                    700,
                    710,
                    720,
                    730,
                    740,
                    750,
                    760,
                    770,
                    780,
                    790,
                    800,
                    810,
                    820,
                    830,
                    840,
                    850,
                    860,
                    870,
                    880,
                    890,
                    900,
                    910,
                    920,
                    930,
                    940,
                    950,
                    960,
                    970,
                    980,
                    990,
                    1000
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nbool canPartition(vector<int>& nums) {\n    int sum = 0;\n    for (int num : nums) sum += num;\n    \n    if (sum % 2 != 0) return false;\n    \n    int target = sum / 2;\n    vector<bool> dp(target + 1, false);\n    dp[0] = true;\n    \n    for (int num : nums) {\n        for (int i = target; i >= num; i--) {\n            dp[i] = dp[i] || dp[i - num];\n        }\n    }\n    return dp[target];\n}\n",
            "java": "public boolean canPartition(int[] nums) {\n    int sum = 0;\n    for (int num : nums) sum += num;\n    \n    if (sum % 2 != 0) return false;\n    \n    int target = sum / 2;\n    boolean[] dp = new boolean[target + 1];\n    dp[0] = true;\n    \n    for (int num : nums) {\n        for (int i = target; i >= num; i--) {\n            dp[i] = dp[i] || dp[i - num];\n        }\n    }\n    return dp[target];\n}\n",
            "python": "def canPartition(nums):\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    \n    target = total_sum // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n    \n    for num in nums:\n        for i in range(target, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n    \n    return dp[target]\n",
            "javascript": "function canPartition(nums) {\n    const sum = nums.reduce((a, b) => a + b);\n    if (sum % 2 !== 0) return false;\n\n    const target = sum / 2;\n    const dp = new Array(target + 1).fill(false);\n    dp[0] = true;\n\n    for (const num of nums) {\n        for (let i = target; i >= num; i--) {\n            dp[i] = dp[i] || dp[i - num];\n        }\n    }\n    return dp[target];\n}\n\n",
            "explanation": "The algorithm is using Dynamic Programming to solve the partition problem. To determine if the array can be divided into two subsets with equal sum, first find the total sum of the array. If the total sum is odd, it's not possible to divide it into two equal subsets, so return false. If the total sum is even, find the target sum by dividing the total sum by 2.\n\nThe key idea is to find if there is a subset whose sum is equal to the target sum. Create a boolean dp array, where dp[i] represents if there is a subset with sum i. Initialize dp[0] to true, since the sum of 0 can be achieved with an empty subset.\n\nIterate through each number in the array, and for each number, iterate through the dp array backwards starting from the target sum. Update dp[i] to be true if dp[i - num] is true, meaning a subset with sum i - num is possible, and adding the current number num results in a subset with sum i.\n\nFinally, if dp[target] is true, it means there is a subset in the array with sum equal to target, so the array can be partitioned into two equal subsets. Otherwise, it cannot be partitioned."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nbool canPartition(vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "public boolean canPartition(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def canPartition(nums):\n    # Your code here\n\n",
            "javascript": "function canPartition(nums)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nbool canPartition(vector<int>& nums) {\n    int sum = 0;\n    for (int num : nums) sum += num;\n    \n    if (sum % 2 != 0) return false;\n    \n    int target = sum / 2;\n    vector<bool> dp(target + 1, false);\n    dp[0] = true;\n    \n    for (int num : nums) {\n        for (int i = target; i >= num; i--) {\n            dp[i] = dp[i] || dp[i - num];\n        }\n    }\n    return dp[target];\n}",
            "java": "public boolean canPartition(int[] nums) {\n    int sum = 0;\n    for (int num : nums) sum += num;\n    \n    if (sum % 2 != 0) return false;\n    \n    int target = sum / 2;\n    boolean[] dp = new boolean[target + 1];\n    dp[0] = true;\n    \n    for (int num : nums) {\n        for (int i = target; i >= num; i--) {\n            dp[i] = dp[i] || dp[i - num];\n        }\n    }\n    return dp[target];\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = canPartition(nums)\n    print(result)",
            "javascript": "function canPartition(nums) {\n    const sum = nums.reduce((a, b) => a + b);\n    if (sum % 2 !== 0) return false;\n\n    const target = sum / 2;\n    const dp = new Array(target + 1).fill(false);\n    dp[0] = true;\n\n    for (const num of nums) {\n        for (let i = target; i >= num; i--) {\n            dp[i] = dp[i] || dp[i - num];\n        }\n    }\n    return dp[target];\n}\n"
        },
        "Qid": "416"
    },
    {
        "_id": {
            "$oid": "662078058257d25e0805c77a"
        },
        "title": "Rain Water Flow",
        "description": "Given an `m x n` rectangular island that borders both the Pacific Ocean and Atlantic Ocean, and an `m x n` integer matrix `heights` representing the height above sea level of each cell, determine the cells from which rain water can flow to both the Pacific and Atlantic oceans. Water can flow from a cell to its neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Return a 2D list of grid coordinates where each coordinate denotes a cell from which rain water can flow to both oceans.",
        "example": "Example:\n\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\nExplanation: The following cells can flow to the Pacific and Atlantic oceans:\n[0,4]: [0,4] -> Pacific Ocean\n       [0,4] -> Atlantic Ocean\n[1,3]: [1,3] -> [0,3] -> Pacific Ocean\n       [1,3] -> [1,4] -> Atlantic Ocean\n[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean\n       [1,4] -> Atlantic Ocean\n[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean\n       [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean\n[3,0]: [3,0] -> Pacific Ocean\n       [3,0] -> [4,0] -> Atlantic Ocean\n[3,1]: [3,1] -> [3,0] -> Pacific Ocean\n       [3,1] -> [4,1] -> Atlantic Ocean\n[4,0]: [4,0] -> Pacific Ocean\n       [4,0] -> Atlantic Ocean\nNote that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.",
        "level": "Medium",
        "tags": [
            "matrix",
            "graph",
            "DFS",
            "BFS"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        2,
                        2,
                        3,
                        5
                    ],
                    [
                        3,
                        2,
                        3,
                        4,
                        4
                    ],
                    [
                        2,
                        4,
                        5,
                        3,
                        1
                    ],
                    [
                        6,
                        7,
                        1,
                        4,
                        5
                    ],
                    [
                        5,
                        1,
                        1,
                        2,
                        4
                    ]
                ],
                [
                    [
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ]
                ],
                [
                    [
                        5,
                        4,
                        3,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        2,
                        2,
                        2,
                        2,
                        2
                    ],
                    [
                        3,
                        3,
                        3,
                        3,
                        3
                    ],
                    [
                        4,
                        4,
                        4,
                        4,
                        4
                    ],
                    [
                        5,
                        5,
                        5,
                        5,
                        5
                    ]
                ],
                [
                    [
                        5,
                        4,
                        3,
                        2,
                        1
                    ],
                    [
                        4,
                        3,
                        2,
                        1,
                        0
                    ],
                    [
                        3,
                        2,
                        1,
                        0,
                        -1
                    ],
                    [
                        2,
                        1,
                        0,
                        -1,
                        -2
                    ],
                    [
                        1,
                        0,
                        -1,
                        -2,
                        -3
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        5,
                        6,
                        7,
                        8,
                        9
                    ]
                ],
                [
                    [
                        9,
                        8,
                        7,
                        6,
                        5
                    ],
                    [
                        8,
                        7,
                        6,
                        5,
                        4
                    ],
                    [
                        7,
                        6,
                        5,
                        4,
                        3
                    ],
                    [
                        6,
                        5,
                        4,
                        3,
                        2
                    ],
                    [
                        5,
                        4,
                        3,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    [
                        10,
                        9,
                        8,
                        7,
                        6
                    ],
                    [
                        9,
                        8,
                        7,
                        6,
                        5
                    ],
                    [
                        8,
                        7,
                        6,
                        5,
                        4
                    ],
                    [
                        7,
                        6,
                        5,
                        4,
                        3
                    ],
                    [
                        6,
                        5,
                        4,
                        3,
                        2
                    ],
                    [
                        5,
                        4,
                        3,
                        2,
                        1
                    ]
                ]
            ],
            "outputs": [
                [
                    [
                        0,
                        4
                    ],
                    [
                        1,
                        3
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        3,
                        1
                    ],
                    [
                        4,
                        0
                    ]
                ],
                [
                    [
                        0,
                        0
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        0,
                        1
                    ],
                    [
                        0,
                        2
                    ],
                    [
                        0,
                        3
                    ],
                    [
                        0,
                        4
                    ]
                ],
                [
                    [
                        4,
                        0
                    ],
                    [
                        4,
                        1
                    ],
                    [
                        4,
                        2
                    ],
                    [
                        4,
                        3
                    ],
                    [
                        4,
                        4
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        0,
                        1
                    ],
                    [
                        0,
                        2
                    ],
                    [
                        0,
                        3
                    ],
                    [
                        0,
                        4
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        4,
                        4
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        0,
                        1
                    ],
                    [
                        0,
                        2
                    ],
                    [
                        0,
                        3
                    ],
                    [
                        0,
                        4
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        4,
                        4
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        0,
                        1
                    ],
                    [
                        0,
                        2
                    ],
                    [
                        0,
                        3
                    ],
                    [
                        0,
                        4
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        4,
                        4
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        0,
                        1
                    ],
                    [
                        0,
                        2
                    ],
                    [
                        0,
                        3
                    ],
                    [
                        0,
                        4
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        4,
                        4
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        0,
                        1
                    ],
                    [
                        0,
                        2
                    ],
                    [
                        0,
                        3
                    ],
                    [
                        0,
                        4
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        0
                    ],
                    [
                        5,
                        4
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        0,
                        1
                    ],
                    [
                        0,
                        2
                    ],
                    [
                        0,
                        3
                    ],
                    [
                        0,
                        4
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        0
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        0
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        0
                    ],
                    [
                        5,
                        4
                    ]
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nusing namespace std;\n\nvoid dfs(const vector<vector<int>>& heights, int r, int c, int prevHeight, vector<vector<bool>>& visited) {\n    if (r < 0 || r >= heights.size() || c < 0 || c >= heights[0].size())\n        return;\n    if (heights[r][c] >= prevHeight && !visited[r][c]) {\n        visited[r][c] = true;\n        dfs(heights, r - 1, c, heights[r][c], visited);\n        dfs(heights, r + 1, c, heights[r][c], visited);\n        dfs(heights, r, c - 1, heights[r][c], visited);\n        dfs(heights, r, c + 1, heights[r][c], visited);\n    }\n}\n\nvector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\n    int m = heights.size();\n    int n = heights[0].size();\n    vector<vector<bool>> pacific(m, vector<bool>(n, false));\n    vector<vector<bool>> atlantic(m, vector<bool>(n, false));\n\n    for (int r = 0; r < m; ++r) {\n        dfs(heights, r, 0, -1, pacific);\n        dfs(heights, r, n - 1, -1, atlantic);\n    }\n    for (int c = 0; c < n; ++c) {\n        dfs(heights, 0, c, -1, pacific);\n        dfs(heights, m - 1, c, -1, atlantic);\n    }\n    vector<vector<int>> result;\n    for (int r = 0; r < m; ++r) {\n        for (int c = 0; c < n; ++c) {\n            if (pacific[r][c] && atlantic[r][c]) {\n                result.push_back({r, c});\n            }\n        }\n    }\n    return result;\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<int[]> pacificAtlantic(int[][] heights) {\n    int m = heights.length;\n    int n = heights[0].length;\n    boolean[][] pacific = new boolean[m][n];\n    boolean[][] atlantic = new boolean[m][n];\n\n    for (int r = 0; r < m; ++r) {\n        dfs(heights, r, 0, -1, pacific);\n        dfs(heights, r, n - 1, -1, atlantic);\n    }\n    for (int c = 0; c < n; ++c) {\n        dfs(heights, 0, c, -1, pacific);\n        dfs(heights, m - 1, c, -1, atlantic);\n    }\n    List<int[]> result = new ArrayList<>();\n    for (int r = 0; r < m; ++r) {\n        for (int c = 0; c < n; ++c) {\n            if (pacific[r][c] && atlantic[r][c]) {\n                result.add(new int[]{r, c});\n            }\n        }\n    }\n    return result;\n}\n\nprivate void dfs(int[][] heights, int r, int c, int prevHeight, boolean[][] visited) {\n    if (r < 0 || r >= heights.length || c < 0 || c >= heights[0].length) return;\n    if (heights[r][c] >= prevHeight && !visited[r][c]) {\n        visited[r][c] = true;\n        dfs(heights, r - 1, c, heights[r][c], visited);\n        dfs(heights, r + 1, c, heights[r][c], visited);\n        dfs(heights, r, c - 1, heights[r][c], visited);\n        dfs(heights, r, c + 1, heights[r][c], visited);\n    }\n}\n\n",
            "python": "def pacificAtlantic(heights):\n    def dfs(r, c, prev_height, visited):\n        if not (0 <= r < len(heights)) or not (0 <= c < len(heights[0])):\n            return\n        if heights[r][c] >= prev_height and not visited[r][c]:\n            visited[r][c] = True\n            dfs(r - 1, c, heights[r][c], visited)\n            dfs(r + 1, c, heights[r][c], visited)\n            dfs(r, c - 1, heights[r][c], visited)\n            dfs(r, c + 1, heights[r][c], visited)\n\n    m, n = len(heights), len(heights[0])\n    pacific = [[False] * n for _ in range(m)]\n    atlantic = [[False] * n for _ in range(m)]\n\n    for r in range(m):\n        dfs(r, 0, -1, pacific)\n        dfs(r, n - 1, -1, atlantic)\n    for c in range(n):\n        dfs(0, c, -1, pacific)\n        dfs(m - 1, c, -1, atlantic)\n\n    result = []\n    for r in range(m):\n        for c in range(n):\n            if pacific[r][c] and atlantic[r][c]:\n                result.append([r, c])\n    return result\n\n",
            "javascript": "function pacificAtlantic(heights) {\n    function dfs(r, c, prevHeight, visited) {\n        if (r < 0 || r >= heights.length || c < 0 || c >= heights[0].length) return;\n        if (heights[r][c] >= prevHeight && !visited[r][c]) {\n            visited[r][c] = true;\n            dfs(r - 1, c, heights[r][c], visited);\n            dfs(r + 1, c, heights[r][c], visited);\n            dfs(r, c - 1, heights[r][c], visited);\n            dfs(r, c + 1, heights[r][c], visited);\n        }\n    }\n\n    const m = heights.length;\n    const n = heights[0].length;\n    const pacific = Array.from(Array(m), () => new Array(n).fill(false));\n    const atlantic = Array.from(Array(m), () => new Array(n).fill(false));\n\n    for (let r = 0; r < m; ++r) {\n        dfs(r, 0, -1, pacific);\n        dfs(r, n - 1, -1, atlantic);\n    }\n    for (let c = 0; c < n; ++c) {\n        dfs(0, c, -1, pacific);\n        dfs(m - 1, c, -1, atlantic);\n    }\n    const result = [];\n    for (let r = 0; r < m; ++r) {\n        for (let c = 0; c < n; ++c) {\n            if (pacific[r][c] && atlantic[r][c]) {\n                result.push([r, c]);\n            }\n        }\n    }\n    return result;\n}\n\n",
            "explanation": "We use DFS to traverse the island, starting from the ocean borders. We create two separate matrices (`pacific` and `atlantic`) keeping track of which cells can flow water to the corresponding ocean. For each cell, we perform DFS in all 4 directions if the neighboring cell's height is less than or equal to the current cell's height.\n\nAfter finishing the DFS search for both oceans, we iterate through the matrices to find the intersections (cells that can flow water to both oceans). If a cell can flow water to both oceans, we add its coordinates to the result list."
        },
        "structure": {
            "c++": "#include <vector>\n\nusing namespace std;\n\nvoid dfs(const vector<vector<int>>& heights, int r, int c, int prevHeight, vector<vector<bool>>& visited)  {\n    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<int[]> pacificAtlantic(int[][] heights)  {\n    // Your code here\n}\n\n",
            "python": "def pacificAtlantic(heights):\n    # Your code here\n\n",
            "javascript": "function pacificAtlantic(heights)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\n    int m = heights.size();\n    int n = heights[0].size();\n    vector<vector<bool>> pacific(m, vector<bool>(n, false));\n    vector<vector<bool>> atlantic(m, vector<bool>(n, false));\n\n    for (int r = 0; r < m; ++r) {\n        dfs(heights, r, 0, -1, pacific);\n        dfs(heights, r, n - 1, -1, atlantic);\n    }\n    for (int c = 0; c < n; ++c) {\n        dfs(heights, 0, c, -1, pacific);\n        dfs(heights, m - 1, c, -1, atlantic);\n    }\n    vector<vector<int>> result;\n    for (int r = 0; r < m; ++r) {\n        for (int c = 0; c < n; ++c) {\n            if (pacific[r][c] && atlantic[r][c]) {\n                result.push_back({r, c});\n            }\n        }\n    }\n    return result;\n}",
            "java": "public List<int[]> pacificAtlantic(int[][] heights) {\n    int m = heights.length;\n    int n = heights[0].length;\n    boolean[][] pacific = new boolean[m][n];\n    boolean[][] atlantic = new boolean[m][n];\n\n    for (int r = 0; r < m; ++r) {\n        dfs(heights, r, 0, -1, pacific);\n        dfs(heights, r, n - 1, -1, atlantic);\n    }\n    for (int c = 0; c < n; ++c) {\n        dfs(heights, 0, c, -1, pacific);\n        dfs(heights, m - 1, c, -1, atlantic);\n    }\n    List<int[]> result = new ArrayList<>();\n    for (int r = 0; r < m; ++r) {\n        for (int c = 0; c < n; ++c) {\n            if (pacific[r][c] && atlantic[r][c]) {\n                result.add(new int[]{r, c});\n            }\n        }\n    }\n    return result;\n}\n\nprivate void dfs(int[][] heights, int r, int c, int prevHeight, boolean[][] visited) {\n    if (r < 0 || r >= heights.length || c < 0 || c >= heights[0].length) return;\n    if (heights[r][c] >= prevHeight && !visited[r][c]) {\n        visited[r][c] = true;\n        dfs(heights, r - 1, c, heights[r][c], visited);\n        dfs(heights, r + 1, c, heights[r][c], visited);\n        dfs(heights, r, c - 1, heights[r][c], visited);\n        dfs(heights, r, c + 1, heights[r][c], visited);\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    heights = $args[0]\n    result = pacificAtlantic(heights)\n    print(result)",
            "javascript": "function pacificAtlantic(heights) {\n    function dfs(r, c, prevHeight, visited) {\n        if (r < 0 || r >= heights.length || c < 0 || c >= heights[0].length) return;\n        if (heights[r][c] >= prevHeight && !visited[r][c]) {\n            visited[r][c] = true;\n            dfs(r - 1, c, heights[r][c], visited);\n            dfs(r + 1, c, heights[r][c], visited);\n            dfs(r, c - 1, heights[r][c], visited);\n            dfs(r, c + 1, heights[r][c], visited);\n        }\n    }\n\n    const m = heights.length;\n    const n = heights[0].length;\n    const pacific = Array.from(Array(m), () => new Array(n).fill(false));\n    const atlantic = Array.from(Array(m), () => new Array(n).fill(false));\n\n    for (let r = 0; r < m; ++r) {\n        dfs(r, 0, -1, pacific);\n        dfs(r, n - 1, -1, atlantic);\n    }\n    for (let c = 0; c < n; ++c) {\n        dfs(0, c, -1, pacific);\n        dfs(m - 1, c, -1, atlantic);\n    }\n    const result = [];\n    for (let r = 0; r < m; ++r) {\n        for (let c = 0; c < n; ++c) {\n            if (pacific[r][c] && atlantic[r][c]) {\n                result.push([r, c]);\n            }\n        }\n    }\n    return result;\n}"
        },
        "Qid": "417"
    },
    {
        "_id": {
            "$oid": "662078e78257d25e0805c77b"
        },
        "title": "Sentence Fitting",
        "description": "Given a `rows x cols` screen and a `sentence` represented as a list of strings, return the number of times the given sentence can be fitted on the screen. The order of words in the sentence must remain unchanged, and a word cannot be split into two lines. A single space must separate two consecutive words in a line.",
        "example": "Example:\n\nInput: sentence = [\"hello \", \"world \"], rows = 2, cols = 8\nOutput: 1\nExplanation:\nhello---\nworld---\nThe character '-' signifies an empty space on the screen.",
        "level": "Medium",
        "tags": [
            "string",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "hello ",
                        "world "
                    ],
                    2,
                    8
                ],
                [
                    [
                        "a ",
                        "bcd ",
                        "e "
                    ],
                    3,
                    6
                ],
                [
                    [
                        "i ",
                        "had ",
                        "apple ",
                        "pie "
                    ],
                    4,
                    5
                ],
                [
                    [
                        "this ",
                        "is ",
                        "a ",
                        "test "
                    ],
                    5,
                    10
                ],
                [
                    [
                        "coding ",
                        "is ",
                        "fun "
                    ],
                    2,
                    10
                ],
                [
                    [
                        "hello ",
                        "world ",
                        "how ",
                        "are ",
                        "you "
                    ],
                    3,
                    15
                ],
                [
                    [
                        "a ",
                        "b ",
                        "c ",
                        "d ",
                        "e ",
                        "f ",
                        "g ",
                        "h ",
                        "i ",
                        "j "
                    ],
                    10,
                    5
                ],
                [
                    [
                        "this ",
                        "is ",
                        "a ",
                        "long ",
                        "sentence ",
                        "that ",
                        "needs ",
                        "to ",
                        "be ",
                        "fitted "
                    ],
                    5,
                    20
                ],
                [
                    [
                        "one ",
                        "two ",
                        "three ",
                        "four ",
                        "five ",
                        "six ",
                        "seven ",
                        "eight ",
                        "nine ",
                        "ten "
                    ],
                    10,
                    10
                ],
                [
                    [
                        "a ",
                        "b ",
                        "c ",
                        "d ",
                        "e ",
                        "f ",
                        "g ",
                        "h ",
                        "i ",
                        "j ",
                        "k ",
                        "l ",
                        "m ",
                        "n ",
                        "o ",
                        "p ",
                        "q ",
                        "r ",
                        "s ",
                        "t ",
                        "u ",
                        "v ",
                        "w ",
                        "x ",
                        "y ",
                        "z "
                    ],
                    26,
                    2
                ],
                [
                    [
                        "this ",
                        "is ",
                        "a ",
                        "sentence ",
                        "with ",
                        "a ",
                        "lot ",
                        "of ",
                        "words ",
                        "that ",
                        "need ",
                        "to ",
                        "be ",
                        "fitted ",
                        "on ",
                        "the ",
                        "screen "
                    ],
                    10,
                    20
                ],
                [
                    [
                        "a ",
                        "b ",
                        "c ",
                        "d ",
                        "e ",
                        "f ",
                        "g ",
                        "h ",
                        "i ",
                        "j ",
                        "k ",
                        "l ",
                        "m ",
                        "n ",
                        "o ",
                        "p ",
                        "q ",
                        "r ",
                        "s ",
                        "t ",
                        "u ",
                        "v ",
                        "w ",
                        "x ",
                        "y ",
                        "z "
                    ],
                    26,
                    10
                ],
                [
                    [
                        "this ",
                        "is ",
                        "a ",
                        "test ",
                        "sentence ",
                        "with ",
                        "a ",
                        "lot ",
                        "of ",
                        "words "
                    ],
                    5,
                    10
                ],
                [
                    [
                        "a ",
                        "b ",
                        "c ",
                        "d ",
                        "e ",
                        "f ",
                        "g ",
                        "h ",
                        "i ",
                        "j ",
                        "k ",
                        "l ",
                        "m ",
                        "n ",
                        "o ",
                        "p ",
                        "q ",
                        "r ",
                        "s ",
                        "t ",
                        "u ",
                        "v ",
                        "w ",
                        "x ",
                        "y ",
                        "z "
                    ],
                    26,
                    20
                ],
                [
                    [
                        "this ",
                        "is ",
                        "a ",
                        "sentence ",
                        "with ",
                        "a ",
                        "lot ",
                        "of ",
                        "words ",
                        "that ",
                        "need ",
                        "to ",
                        "be ",
                        "fitted ",
                        "on ",
                        "the ",
                        "screen "
                    ],
                    10,
                    10
                ],
                [
                    [
                        "a ",
                        "b ",
                        "c ",
                        "d ",
                        "e ",
                        "f ",
                        "g ",
                        "h ",
                        "i ",
                        "j ",
                        "k ",
                        "l ",
                        "m ",
                        "n ",
                        "o ",
                        "p ",
                        "q ",
                        "r ",
                        "s ",
                        "t ",
                        "u ",
                        "v ",
                        "w ",
                        "x ",
                        "y ",
                        "z "
                    ],
                    26,
                    5
                ],
                [
                    [
                        "this ",
                        "is ",
                        "a ",
                        "test ",
                        "sentence ",
                        "with ",
                        "a ",
                        "lot ",
                        "of ",
                        "words "
                    ],
                    5,
                    20
                ],
                [
                    [
                        "a ",
                        "b ",
                        "c ",
                        "d ",
                        "e ",
                        "f ",
                        "g ",
                        "h ",
                        "i ",
                        "j ",
                        "k ",
                        "l ",
                        "m ",
                        "n ",
                        "o ",
                        "p ",
                        "q ",
                        "r ",
                        "s ",
                        "t ",
                        "u ",
                        "v ",
                        "w ",
                        "x ",
                        "y ",
                        "z "
                    ],
                    26,
                    10
                ],
                [
                    [
                        "this ",
                        "is ",
                        "a ",
                        "sentence ",
                        "with ",
                        "a ",
                        "lot ",
                        "of ",
                        "words ",
                        "that ",
                        "need ",
                        "to ",
                        "be ",
                        "fitted ",
                        "on ",
                        "the ",
                        "screen "
                    ],
                    10,
                    20
                ],
                [
                    [
                        "a ",
                        "b ",
                        "c ",
                        "d ",
                        "e ",
                        "f ",
                        "g ",
                        "h ",
                        "i ",
                        "j ",
                        "k ",
                        "l ",
                        "m ",
                        "n ",
                        "o ",
                        "p ",
                        "q ",
                        "r ",
                        "s ",
                        "t ",
                        "u ",
                        "v ",
                        "w ",
                        "x ",
                        "y ",
                        "z "
                    ],
                    26,
                    2
                ]
            ],
            "outputs": [
                1,
                2,
                1,
                2,
                1,
                1,
                10,
                1,
                1,
                13,
                2,
                1,
                2,
                1,
                1,
                2,
                1,
                2,
                1
            ]
        },
        "sample_code": {
            "c++": "int wordsTyping(vector<string>& sentence, int rows, int cols) {\n    int total_chars = 0;\n    for (const auto& word : sentence) {\n        total_chars += word.size() + 1;\n    }\n\n    int result = 0;\n    int index = 0;\n    for (int r = 0; r < rows; ++r) {\n        int remaining_cols = cols;\n        while (true) {\n            int word_len = sentence[index].size();\n            if (remaining_cols >= word_len) {\n                remaining_cols -= word_len + 1;\n                index = (index + 1) % sentence.size();\n                if (index == 0) result++;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n",
            "java": "public int wordsTyping(String[] sentence, int rows, int cols) {\n    int totalChars = 0;\n    for (String word : sentence) {\n        totalChars += word.length() + 1;\n    }\n\n    int result = 0;\n    int index = 0;\n    for (int r = 0; r < rows; ++r) {\n        int remainingCols = cols;\n        while (true) {\n            int wordLen = sentence[index].length();\n            if (remainingCols >= wordLen) {\n                remainingCols -= wordLen + 1;\n                index = (index + 1) % sentence.length;\n                if (index == 0) result++;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n",
            "python": "def words_typing(sentence, rows, cols):\n    total_chars = sum(len(word) + 1 for word in sentence)\n\n    result = 0\n    index = 0\n    for _ in range(rows):\n        remaining_cols = cols\n        while True:\n            word_len = len(sentence[index])\n            if remaining_cols >= word_len:\n                remaining_cols -= word_len + 1\n                index = (index + 1) % len(sentence)\n                if index == 0:\n                    result += 1\n            else:\n                break\n\n    return result\n",
            "javascript": "function wordsTyping(sentence, rows, cols) {\n    let totalChars = sentence.reduce((acc, word) => acc + word.length + 1, 0);\n\n    let result = 0;\n    let index = 0;\n    for (let r = 0; r < rows; ++r) {\n        let remainingCols = cols;\n        while (true) {\n            let wordLen = sentence[index].length;\n            if (remainingCols >= wordLen) {\n                remainingCols -= wordLen + 1;\n                index = (index + 1) % sentence.length;\n                if (index === 0) result++;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n",
            "explanation": "The algorithm works as follows:\n1. Calculate the total number of characters in the sentence (including space after each word).\n2. Initialize the result (count of repetitions) and the index of the current word in the sentence.\n3. For each row:\n   1. Keep track of remaining columns (initially equal to `cols`).\n   2. Iterate through words in the sentence, and for each word:\n      1. Check if the word can fit in the remaining columns.\n      2. If it fits, update the remaining columns and index for the next word. If the index equals zero, increment the result.\n      3. If it doesn't fit, break the current row iteration.\n4. Return the result."
        },
        "structure": {
            "c++": "int wordsTyping(vector<string>& sentence, int rows, int cols)  {\n    // Your code here\n}\n",
            "java": "public int wordsTyping(String[] sentence, int rows, int cols)  {\n    // Your code here\n}\n",
            "python": "def words_typing(sentence, rows, cols):\n    # Your code here\n\n",
            "javascript": "function wordsTyping(sentence, rows, cols)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<string> sentence = $args;\n    int rows = 3;\n    int cols = 6;\n    int result = wordsTyping(sentence, rows, cols);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int wordsTyping(String[] sentence, int rows, int cols) {\n    int totalChars = 0;\n    for (String word : sentence) {\n        totalChars += word.length() + 1;\n    }\n\n    int result = 0;\n    int index = 0;\n    for (int r = 0; r < rows; ++r) {\n        int remainingCols = cols;\n        while (true) {\n            int wordLen = sentence[index].length();\n            if (remainingCols >= wordLen) {\n                remainingCols -= wordLen + 1;\n                index = (index + 1) % sentence.length;\n                if (index == 0) result++;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    sentence = inputs[0]\n    rows = inputs[1]\n    cols = inputs[2]\n    result = words_typing(sentence, rows, cols)\n    print(result)",
            "javascript": "function main() {\n    const sentence = $args[0];\n    const rows = $args[1];\n    const cols = $args[2];\n    const result = wordsTyping(sentence, rows, cols);\n    console.log(result);\n}"
        },
        "Qid": "418"
    },
    {
        "_id": {
            "$oid": "662078f58257d25e0805c77c"
        },
        "title": "Count Battleships",
        "description": "Given an `m x n` matrix `board` where each cell is a battleship 'X' or empty '.', return the number of battleships on the board. Battleships can only be placed horizontally or vertically on the board. In other words, they can only be made of the shape `1 x k` (1 row, k columns) or `k x 1` (k rows, 1 column), where k can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).",
        "example": "Example:\n\nInput: board = [['X', '.', '.', 'X'], ['.', '.', '.', 'X'], ['.', '.', '.', 'X']]\nOutput: 2\n\nExplanation: There are two battleships on the board.\n\nExample:\n\nInput: board = [['.']]\nOutput: 0\n\nExplanation: There are no battleships on the board.",
        "level": "Easy",
        "tags": [
            "matrix",
            "counting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "X",
                        ".",
                        ".",
                        "X"
                    ],
                    [
                        ".",
                        ".",
                        ".",
                        "X"
                    ],
                    [
                        ".",
                        ".",
                        ".",
                        "X"
                    ]
                ],
                [
                    [
                        "."
                    ]
                ]
            ],
            "outputs": [
                2,
                0
            ]
        },
        "sample_code": {
            "c++": "int countBattleships(vector<vector<char>>& board) {\n    int count = 0;\n    for (int i = 0; i < board.size(); i++) {\n        for (int j = 0; j < board[i].size(); j++) {\n            if (board[i][j] == 'X' &&\n                (i == 0 || board[i - 1][j] == '.') &&\n                (j == 0 || board[i][j - 1] == '.')) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n",
            "java": "public int countBattleships(char[][] board) {\n    int count = 0;\n    for (int i = 0; i < board.length; i++) {\n        for (int j = 0; j < board[i].length; j++) {\n            if (board[i][j] == 'X' &&\n                (i == 0 || board[i - 1][j] == '.') &&\n                (j == 0 || board[i][j - 1] == '.')) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n",
            "python": "def countBattleships(board):\n    count = 0\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if (board[i][j] == 'X' and\n                (i == 0 or board[i - 1][j] == '.') and\n                (j == 0 or board[i][j - 1] == '.')):\n                count += 1\n    return count\n",
            "javascript": "function countBattleships(board) {\n    let count = 0;\n    for (let i = 0; i < board.length; i++) {\n        for (let j = 0; j < board[i].length; j++) {\n            if (board[i][j] === 'X' &&\n                (i === 0 || board[i - 1][j] === '.') &&\n                (j === 0 || board[i][j - 1] === '.')) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n",
            "explanation": "The algorithm iterates over each cell in the given `board`. If the current cell is 'X' (a battleship) and both the cell above it (if exists) and the cell to its left (if exists) are not 'X', it means we have found a new battleship. We increment the count of battleships in this case. In the end, we return the total count of battleships found.\n\nThe reason we check only the top and left cells is that we only want to count the start of a battleship, and not count the same battleship multiple times. Since the battleships can be in the horizontal or vertical direction, checking the left and top cells ensures that we count each battleship only once. "
        },
        "structure": {
            "c++": "int countBattleships(vector<vector<char>>& board)  {\n    // Your code here\n}\n",
            "java": "public int countBattleships(char[][] board)  {\n    // Your code here\n}\n",
            "python": "def countBattleships(board):\n    # Your code here\n\n",
            "javascript": "function countBattleships(board)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int countBattleships(vector<vector<char>>& board) {\n    int count = 0;\n    for (int i = 0; i < board.size(); i++) {\n        for (int j = 0; j < board[i].size(); j++) {\n            if (board[i][j] == 'X' &&\n                (i == 0 || board[i - 1][j] == '.') &&\n                (j == 0 || board[i][j - 1] == '.')) {\n                count++;\n            }\n        }\n    }\n    return count;\n}",
            "java": "public int countBattleships(char[][] board) {\n    int count = 0;\n    for (int i = 0; i < board.length; i++) {\n        for (int j = 0; j < board[i].length; j++) {\n            if (board[i][j] == 'X' &&\n                (i == 0 || board[i - 1][j] == '.') &&\n                (j == 0 || board[i][j - 1] == '.')) {\n                count++;\n            }\n        }\n    }\n    return count;\n}",
            "python": "if __name__ == \"__main__\":\n    board = $args[0]\n    result = countBattleships(board)\n    print(result)",
            "javascript": "function main() {\n    const board = $args;\n    const result = countBattleships(board);\n    console.log(result);\n}"
        },
        "Qid": "419"
    },
    {
        "_id": {
            "$oid": "6620790a8257d25e0805c77d"
        },
        "title": "Password Strength",
        "description": "A password is considered strong if it meets the following conditions:\n\n- It has at least 6 characters and at most 20 characters.\n- It contains at least one lowercase letter, one uppercase letter, and one digit.\n- It does not contain three repeating characters in a row.\n\nGiven a string `password`, write a function to return the minimum number of steps required to make the password strong. If the password is already strong, return 0.\n\nIn one step, you can:\n- Insert one character to the password\n- Delete one character from the password\n- Replace one character of the password with another character.",
        "example": "Example:\n\nInput: password = \"a\"\nOutput: 5\n\nExplanation: The password has only one character and it needs to have at least 6 characters. Therefore, we need to insert 5 characters to make it strong.\n\nInput: password = \"aA1\"\nOutput: 3\n\nExplanation: The password is already strong and doesn't require any changes.\n\nInput: password = \"1337C0d3\"\nOutput: 0\n\nExplanation: The password is already strong and doesn't require any changes.",
        "level": "Medium",
        "tags": [
            "string",
            "password",
            "validation"
        ],
        "test_cases": {
            "inputs": [
                "\"a\"",
                "\"aA1\"",
                "\"1337C0d3\"",
                "\"password\"",
                "\"123456\"",
                "\"Abcdefg\"",
                "\"!@#$%^&*()\"",
                "\"aA1!\"",
                "\"aA1!2\"",
                "\"aA1!2@\"",
                "\"aA1!2@3\"",
                "\"aA1!2@3#\"",
                "\"aA1!2@3#4\"",
                "\"aA1!2@3#4$\"",
                "\"aA1!2@3#4$5\"",
                "\"aA1!2@3#4$5%\"",
                "\"aA1!2@3#4$5%6\"",
                "\"aA1!2@3#4$5%6^\"",
                "\"aA1!2@3#4$5%6^7\"",
                "\"aA1!2@3#4$5%6^7&\""
            ],
            "outputs": [
                "5",
                "3",
                "0",
                "8",
                "1",
                "0",
                "6",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0"
            ]
        },
        "sample_code": {
            "c++": "#include <cctype>\n#include <algorithm>\nint strongPassword(string password) {\n    int missingLower = 1, missingUpper = 1, missingDigit = 1;\n    int total = (int)password.size();\n    for (char c : password) {\n        if (islower(c)) missingLower = 0;\n        if (isupper(c)) missingUpper = 0;\n        if (isdigit(c)) missingDigit = 0;\n    }\n    int missing = missingLower + missingUpper + missingDigit;\n    if (total < 6) return max(missing, 6 - total);\n    if (total > 20) return missing + total - 20;\n    return missing;\n}\n",
            "java": "int strongPassword(String password) {\n    int missingLower = 1, missingUpper = 1, missingDigit = 1;\n    int total = password.length();\n    for (char c : password.toCharArray()) {\n        if (Character.isLowerCase(c)) missingLower = 0;\n        if (Character.isUpperCase(c)) missingUpper = 0;\n        if (Character.isDigit(c)) missingDigit = 0;\n    }\n    int missing = missingLower + missingUpper + missingDigit;\n    if (total < 6) return Math.max(missing, 6 - total);\n    if (total > 20) return missing + total - 20;\n    return missing;\n}\n",
            "python": "def strong_password(password):\n    missing_lower = 1\n    missing_upper = 1\n    missing_digit = 1\n    total = len(password)\n    \n    for c in password:\n        if c.islower(): missing_lower = 0\n        if c.isupper(): missing_upper = 0\n        if c.isdigit(): missing_digit = 0\n    \n    missing = missing_lower + missing_upper + missing_digit\n    if total < 6: return max(missing, 6 - total)\n    if total > 20: return missing + total - 20\n\n    return missing\n",
            "javascript": "function strongPassword(password) {\n    let missingLower = 1, missingUpper = 1, missingDigit = 1;\n    let total = password.length;\n    for (const c of password) {\n        if (c.match(/[a-z]/)) missingLower = 0;\n        if (c.match(/[A-Z]/)) missingUpper = 0;\n        if (c.match(/[0-9]/)) missingDigit = 0;\n    }\n    let missing = missingLower + missingUpper + missingDigit;\n    if (total < 6) return Math.max(missing, 6 - total);\n    if (total > 20) return missing + total - 20;\n    return missing;\n}\n",
            "explanation": "We first initiate three variables `missingLower`, `missingUpper`, and `missingDigit` indicating if we need a lowercase letter, an uppercase letter, or a digit, respectively. Then, we iterate through each character of the password, updating the missing variables if we find a character that satisfies the respective condition. After that, we calculate the total number of missing characters.\n\nThe final result depends on the total length of the password:\n- if it is less than 6, the result is equal to the maximum of missing characters and the difference between the desired length (6) and the current length.\n- if it is greater than 20, the result is equal to the sum of missing characters and the difference between the current length and the desired length (20).\n- otherwise, the result is equal to the number of missing characters."
        },
        "structure": {
            "c++": "#include <cctype>\n#include <algorithm>\nint strongPassword(string password)  {\n    // Your code here\n}\n",
            "java": "int strongPassword(String password)  {\n    // Your code here\n}\n",
            "python": "def strong_password(password):\n    # Your code here\n\n",
            "javascript": "function strongPassword(password)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <cctype>\n#include <algorithm>\n\nint main() {\n    string password = $args;\n    int result = strongPassword(password);\n    cout << result << endl;\n    return 0;\n}",
            "java": "int strongPassword(String password) {\n    int missingLower = 1, missingUpper = 1, missingDigit = 1;\n    int total = password.length();\n    for (char c : password.toCharArray()) {\n        if (Character.isLowerCase(c)) missingLower = 0;\n        if (Character.isUpperCase(c)) missingUpper = 0;\n        if (Character.isDigit(c)) missingDigit = 0;\n    }\n    int missing = missingLower + missingUpper + missingDigit;\n    if (total < 6) return Math.max(missing, 6 - total);\n    if (total > 20) return missing + total - 20;\n    return missing;\n}",
            "python": "if __name__ == \"__main__\":\n    password = $args[0]\n    result = strong_password(password)\n    print(result)",
            "javascript": "function strongPassword(password) {\n    let missingLower = 1, missingUpper = 1, missingDigit = 1;\n    let total = password.length;\n    for (const c of password) {\n        if (c.match(/[a-z]/)) missingLower = 0;\n        if (c.match(/[A-Z]/)) missingUpper = 0;\n        if (c.match(/[0-9]/)) missingDigit = 0;\n    }\n    let missing = missingLower + missingUpper + missingDigit;\n    if (total < 6) return Math.max(missing, 6 - total);\n    if (total > 20) return missing + total - 20;\n    return missing;\n}"
        },
        "Qid": "420"
    },
    {
        "_id": {
            "$oid": "6620791a8257d25e0805c77e"
        },
        "title": "Maximum XOR Pair",
        "description": "Given an integer array `nums`, find the maximum result of XOR operation between any two elements in the array.",
        "example": "Example 1:\n\nInput: nums = [3,10,5,25,2,8]\nOutput: 28\nExplanation: The maximum result is 5 XOR 25 = 28.\n\nExample 2:\n\nInput: nums = [14,70,53,83,49,91,36,80,92,51,66,70]\nOutput: 127",
        "level": "Medium",
        "tags": [
            "array",
            "bit manipulation"
        ],
        "test_cases": {
            "inputs": [
                [
                    3,
                    10,
                    5,
                    25,
                    2,
                    8
                ],
                [
                    14,
                    70,
                    53,
                    83,
                    49,
                    91,
                    36,
                    80,
                    92,
                    51,
                    66,
                    70
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    100,
                    200,
                    300,
                    400,
                    500
                ],
                [
                    1024,
                    2048,
                    4096,
                    8192,
                    16384
                ],
                [
                    15,
                    30,
                    45,
                    60,
                    75,
                    90
                ],
                [
                    17,
                    34,
                    51,
                    68,
                    85,
                    102
                ],
                [
                    255,
                    255,
                    255,
                    255,
                    255,
                    255
                ]
            ],
            "outputs": [
                28,
                127,
                0,
                7,
                15,
                600,
                32768,
                105,
                119,
                0
            ]
        },
        "sample_code": {
            "c++": "int findMaximumXOR(vector<int>& nums) {\n    int max_xor = 0;\n    int mask = 0;\n\n    for (int i = 31; i >= 0; i--) {\n        mask |= (1 << i);\n        unordered_set<int> prefixes;\n\n        for (int num : nums) {\n            prefixes.insert(num & mask);\n        }\n\n        int possible_max = max_xor | (1 << i);\n\n        for (int prefix : prefixes) {\n            if (prefixes.count(prefix ^ possible_max)) {\n                max_xor = possible_max;\n                break;\n            }\n        }\n    }\n\n    return max_xor;\n}\n",
            "java": "public int findMaximumXOR(int[] nums) {\n    int max_xor = 0, mask = 0;\n    \n    for (int i = 31; i >= 0; i--) {\n        mask |= (1 << i);\n        HashSet<Integer> prefixes = new HashSet<>();\n        \n        for (int num : nums) {\n            prefixes.add(num & mask);\n        }\n        \n        int possible_max = max_xor | (1 << i);\n        \n        for (int prefix : prefixes) {\n            if (prefixes.contains(prefix ^ possible_max)) {\n                max_xor = possible_max;\n                break;\n            }\n        }\n    }\n    \n    return max_xor;\n}\n",
            "python": "def findMaximumXOR(nums):\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n\n        possible_max = max_xor | (1 << i)\n\n        for prefix in prefixes:\n            if prefix ^ possible_max in prefixes:\n                max_xor = possible_max\n                break\n\n    return max_xor\n",
            "javascript": "function findMaximumXOR(nums) {\n    let max_xor = 0, mask = 0;\n    \n    for (let i = 31; i >= 0; i--) {\n        mask |= (1 << i);\n        let prefixes = new Set();\n        \n        for (let num of nums) {\n            prefixes.add(num & mask);\n        }\n        \n        let possible_max = max_xor | (1 << i);\n\n        for (let prefix of prefixes) {\n            if (prefixes.has(prefix ^ possible_max)) {\n                max_xor = possible_max;\n                break;\n            }\n        }\n    }\n    \n    return max_xor;\n}\n",
            "explanation": "1. Initialize max_xor and mask to 0.\n2. Loop through the 32-bit integer type from the most significant bit to the least significant bit.\n3. In each iteration, find the longest prefix of the XOR value, which is built from more significant bits to less significant bit. Update mask by left-shifting 1 and bitwise OR with the mask.\n4. Add each element bitwise AND the mask into a set called prefixes.\n5. Calculate the possible max XOR value up to the current bit by bitwise OR with (1 << i) and the current max_xor.\n6. Loop through the prefixes and check if the XOR of prefix and possible_max is in the set of prefixes.\n7. If it's in the set, update max_xor to the possible_max and break the loop, otherwise, continue with the next bit.\n8. After processing all bits, return max_xor as the final result."
        },
        "structure": {
            "c++": "int findMaximumXOR(vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "public int findMaximumXOR(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def findMaximumXOR(nums):\n    # Your code here\n\n",
            "javascript": "function findMaximumXOR(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int findMaximumXOR(vector<int>& nums) {\n    int max_xor = 0;\n    int mask = 0;\n\n    for (int i = 31; i >= 0; i--) {\n        mask |= (1 << i);\n        unordered_set<int> prefixes;\n\n        for (int num : nums) {\n            prefixes.insert(num & mask);\n        }\n\n        int possible_max = max_xor | (1 << i);\n\n        for (int prefix : prefixes) {\n            if (prefixes.count(prefix ^ possible_max)) {\n                max_xor = possible_max;\n                break;\n            }\n        }\n    }\n\n    return max_xor;\n}",
            "java": "public int findMaximumXOR(int[] nums) {\n    int max_xor = 0, mask = 0;\n    \n    for (int i = 31; i >= 0; i--) {\n        mask |= (1 << i);\n        HashSet<Integer> prefixes = new HashSet<>();\n        \n        for (int num : nums) {\n            prefixes.add(num & mask);\n        }\n        \n        int possible_max = max_xor | (1 << i);\n        \n        for (int prefix : prefixes) {\n            if (prefixes.contains(prefix ^ possible_max)) {\n                max_xor = possible_max;\n                break;\n            }\n        }\n    }\n    \n    return max_xor;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args[0]\n    result = findMaximumXOR(nums)\n    print(result)",
            "javascript": "function findMaximumXOR(nums) {\n    let max_xor = 0, mask = 0;\n    \n    for (let i = 31; i >= 0; i--) {\n        mask |= (1 << i);\n        let prefixes = new Set();\n        \n        for (let num of nums) {\n            prefixes.add(num & mask);\n        }\n        \n        let possible_max = max_xor | (1 << i);\n\n        for (let prefix of prefixes) {\n            if (prefixes.has(prefix ^ possible_max)) {\n                max_xor = possible_max;\n                break;\n            }\n        }\n    }\n    \n    return max_xor;\n}"
        },
        "Qid": "421"
    },
    {
        "_id": {
            "$oid": "66207a8b8257d25e0805c77f"
        },
        "title": "Ascending Order of Digits",
        "description": "Given a string `s` containing an out-of-order English representation of digits `0-9`, return the digits in ascending order.",
        "example": "Example:\n\nInput: s = \"owoztneoer\"\nOutput: \"012\"\n\nInput: s = \"fviefuro\"\nOutput: \"45\"",
        "level": "Easy",
        "tags": [
            "string",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "\"owoztneoer\"",
                "\"fviefuro\"",
                "\"xvz\"",
                "\"hgfedcba\"",
                "\"s\"",
                "\"t\"",
                "\"n\"",
                "\"i\"",
                "\"g\"",
                "\"e\"",
                "\"r\"",
                "\"u\"",
                "\"w\"",
                "\"o\"",
                "\"z\"",
                "\"v\"",
                "\"x\"",
                "\"t\"",
                "\"s\"",
                "\"n\"",
                "\"r\""
            ],
            "outputs": [
                "\"012\"",
                "\"45\"",
                "\"xz\"",
                "\"abcdefgh\"",
                "\"\"",
                "\"\"",
                "\"\"",
                "\"\"",
                "\"\"",
                "\"\"",
                "\"\"",
                "\"\"",
                "\"\"",
                "\"\"",
                "\"\"",
                "\"\"",
                "\"\"",
                "\"\"",
                "\"\"",
                "\"\""
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring find_digits_in_ascending_order(string s) {\n    vector<int> count(10, 0);\n    for (char c : s) {\n        if (c == 'z') count[0]++;\n        if (c == 'w') count[2]++;\n        if (c == 'u') count[4]++;\n        if (c == 'x') count[6]++;\n        if (c == 'g') count[8]++;\n        if (c == 'o') count[1]++;  // o = one + two + four\n        if (c == 'h') count[3]++;  // h = three + eight\n        if (c == 'f') count[5]++;  // f = five + seven\n        if (c == 's') count[7]++;  // s = six + seven\n        if (c == 'i') count[9]++;  // i = five + six + eight + nine\n    }\n    count[1] -= count[0] + count[2] + count[4];\n    count[3] -= count[8];\n    count[5] -= count[4];\n    count[7] -= count[6];\n    count[9] -= count[5] + count[6] + count[8];\n    \n    string res;\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < count[i]; j++) {\n            res += to_string(i);\n        }\n    }\n    return res;\n}\n\n",
            "java": "public String findDigitsInAscendingOrder(String s) {\n    int[] count = new int[10];\n    for (char c : s.toCharArray()) {\n        if (c == 'z') count[0]++;\n        if (c == 'w') count[2]++;\n        if (c == 'u') count[4]++;\n        if (c == 'x') count[6]++;\n        if (c == 'g') count[8]++;\n        if (c == 'o') count[1]++;\n        if (c == 'h') count[3]++;\n        if (c == 'f') count[5]++;\n        if (c == 's') count[7]++;\n        if (c == 'i') count[9]++;\n    }\n    count[1] -= count[0] + count[2] + count[4];\n    count[3] -= count[8];\n    count[5] -= count[4];\n    count[7] -= count[6];\n    count[9] -= count[5] + count[6] + count[8];\n    \n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < count[i]; j++) {\n            sb.append(i);\n        }\n    }\n    return sb.toString();\n}\n\n",
            "python": "def find_digits_in_ascending_order(s):\n    count = [0] * 10\n    for c in s:\n        if c == 'z': count[0] += 1\n        if c == 'w': count[2] += 1\n        if c == 'u': count[4] += 1\n        if c == 'x': count[6] += 1\n        if c == 'g': count[8] += 1\n        if c == 'o': count[1] += 1\n        if c == 'h': count[3] += 1\n        if c == 'f': count[5] += 1\n        if c == 's': count[7] += 1\n        if c == 'i': count[9] += 1\n    count[1] -= count[0] + count[2] + count[4]\n    count[3] -= count[8]\n    count[5] -= count[4]\n    count[7] -= count[6]\n    count[9] -= count[5] + count[6] + count[8]\n    \n    res = []\n    for i in range(10):\n        res.extend([str(i)] * count[i])\n    return ''.join(res)\n\n",
            "javascript": "function findDigitsInAscendingOrder(s) {\n    const count = new Array(10).fill(0);\n    for (const c of s) {\n        if (c === 'z') count[0]++;\n        if (c === 'w') count[2]++;\n        if (c === 'u') count[4]++;\n        if (c === 'x') count[6]++;\n        if (c === 'g') count[8]++;\n        if (c === 'o') count[1]++;\n        if (c === 'h') count[3]++;\n        if (c === 'f') count[5]++;\n        if (c === 's') count[7]++;\n        if (c === 'i') count[9]++;\n    }\n    count[1] -= (count[0] + count[2] + count[4]);\n    count[3] -= count[8];\n    count[5] -= count[4];\n    count[7] -= count[6];\n    count[9] -= (count[5] + count[6] + count[8]);\n    \n    let res = \"\";\n    for (let i = 0; i < 10; i++) {\n        res += String(i).repeat(count[i]);\n    }\n    return res;\n}\n\n",
            "explanation": "The algorithm consists of the following steps:\n1. Initialize an array `count` of size 10 to store the count of digits from 0 to 9.\n2. Iterate through the given string (`s`). Update the `count` array according to the appearance of characters as follows:\n    - Count `0` for every `'z'`\n    - Count `2` for every `'w'`\n    - Count `4` for every `'u'`\n    - Count `6` for every `'x'`\n    - Count `8` for every `'g'`\n    - Count `1` for every `'o'` (one + two + four)\n    - Count `3` for every `'h'` (three + eight)\n    - Count `5` for every `'f'` (five + seven)\n    - Count `7` for every `'s'` (six + seven)\n    - Count `9` for every `'i'` (five + six + eight + nine)\n3. Update the counts of digits `1`, `3`, `5`, `7`, and `9` by subtracting the overlapping counts of other digits.\n4. Iterate through the `count` array and append the digit (i) `count[i]` times to the result string. This ensures we have the digits in ascending order.\n5. Return the result."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring find_digits_in_ascending_order(string s)  {\n    // Your code here\n}\n\n",
            "java": "public String findDigitsInAscendingOrder(String s)  {\n    // Your code here\n}\n\n",
            "python": "def find_digits_in_ascending_order(s):\n    # Your code here\n\n",
            "javascript": "function findDigitsInAscendingOrder(s)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    string s = $args;\n    string result = find_digits_in_ascending_order(s);\n    cout << result << endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args[0]\n    result = find_digits_in_ascending_order(s)\n    print(result)",
            "java": "",
            "javascript": ""
        },
        "Qid": "423"
    },
    {
        "_id": {
            "$oid": "66207ac98257d25e0805c780"
        },
        "title": "Longest Substring with Same Letters After K Replacement",
        "description": "Given a string `s` and an integer `k`, you can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times. Write a function that returns the length of the longest substring containing the same letter you can get after performing the above operations.",
        "example": "For example, given the string `s = \"ABAB\"` and `k = 2`, you can replace the two 'A's with two 'B's or vice versa. The longest substring containing the same letter is \"BBBB\" with a length of 4.",
        "level": "Medium",
        "tags": [
            "string",
            "sliding window",
            "two pointers"
        ],
        "test_cases": {
            "inputs": [
                [
                    "ABAB",
                    2
                ],
                [
                    "AABABBA",
                    1
                ],
                [
                    "AAAA",
                    0
                ],
                [
                    "ABCD",
                    1
                ],
                [
                    "ABBBB",
                    2
                ],
                [
                    "AABBBB",
                    3
                ],
                [
                    "ABABAB",
                    0
                ],
                [
                    "ABABAB",
                    1
                ],
                [
                    "ABABAB",
                    2
                ],
                [
                    "ABABAB",
                    3
                ],
                [
                    "ABABAB",
                    4
                ],
                [
                    "ABABAB",
                    5
                ],
                [
                    "ABABAB",
                    6
                ],
                [
                    "ABABAB",
                    7
                ],
                [
                    "ABABAB",
                    8
                ],
                [
                    "ABABAB",
                    9
                ],
                [
                    "ABABAB",
                    10
                ],
                [
                    "ABABAB",
                    11
                ],
                [
                    "ABABAB",
                    12
                ],
                [
                    "ABABAB",
                    13
                ]
            ],
            "outputs": [
                4,
                4,
                4,
                2,
                5,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                6
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nint characterReplacement(string s, int k) {\n    int n = s.length();\n    int left = 0, right = 0, maxFreq = 0, result = 0;\n    int freq[26] = {0};\n    \n    for (right = 0; right < n; right++) {\n        freq[s[right] - 'A']++;\n        maxFreq = max(maxFreq, freq[s[right] - 'A']);\n        \n        if (right - left + 1 - maxFreq > k) {\n            freq[s[left] - 'A']--;\n            left++;\n        }\n        \n        result = max(result, right - left + 1);\n    }\n    \n    return result;\n}\n\n",
            "java": "public int characterReplacement(String s, int k) {\n    int n = s.length();\n    int left = 0, right = 0, maxFreq = 0, result = 0;\n    int[] freq = new int[26];\n    \n    for (right = 0; right < n; right++) {\n        freq[s.charAt(right) - 'A']++;\n        maxFreq = Math.max(maxFreq, freq[s.charAt(right) - 'A']);\n        \n        if (right - left + 1 - maxFreq > k) {\n            freq[s.charAt(left) - 'A']--;\n            left++;\n        }\n        \n        result = Math.max(result, right - left + 1);\n    }\n    \n    return result;\n}\n\n",
            "python": "def characterReplacement(s:str, k:int) -> int:\n    n = len(s)\n    left = 0\n    right = 0\n    maxFreq = 0\n    result = 0\n    freq = [0] * 26\n\n    for right in range(n):\n        freq[ord(s[right]) - ord('A')] += 1\n        maxFreq = max(maxFreq, freq[ord(s[right]) - ord('A')])\n\n        if right - left + 1 - maxFreq > k:\n            freq[ord(s[left]) - ord('A')] -= 1\n            left += 1\n\n        result = max(result, right - left + 1)\n\n    return result\n\n",
            "javascript": "function characterReplacement(s, k) {\n    let n = s.length;\n    let left = 0, right = 0, maxFreq = 0, result = 0;\n    let freq = new Array(26).fill(0);\n\n    for (right = 0; right < n; right++) {\n        freq[s.charCodeAt(right) - 'A'.charCodeAt(0)]++;\n        maxFreq = Math.max(maxFreq, freq[s.charCodeAt(right) - 'A'.charCodeAt(0)]);\n\n        if (right - left + 1 - maxFreq > k) {\n            freq[s.charCodeAt(left) - 'A'.charCodeAt(0)]--;\n            left++;\n        }\n\n        result = Math.max(result, right - left + 1);\n    }\n    \n    return result;\n}\n\n",
            "explanation": "1. Keep two pointers, left and right, to define the current substring we are evaluating.\n2. For each character, increment its count in the frequency array and update the current maximum frequency.\n3. If the length of the current substring minus the maximum frequency (i.e., the number of changes needed to make all characters the same) is greater than k, move the left pointer and update the frequency array.\n4. Keep track of the longest substring updating result and return it after iterating through the string."
        },
        "structure": {
            "c++": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nint characterReplacement(string s, int k)  {\n    // Your code here\n}\n\n",
            "java": "public int characterReplacement(String s, int k)  {\n    // Your code here\n}\n\n",
            "python": "def characterReplacement(s:str, k:int) -> int:\n    # Your code here\n\n",
            "javascript": "function characterReplacement(s, k)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    string s = $args;\n    int k = $args;\n    int result = characterReplacement(s, k);\n    cout << result << endl;\n    return 0;\n}\n",
            "java": "public int characterReplacement(String s, int k) {\n    int n = s.length();\n    int left = 0, right = 0, maxFreq = 0, result = 0;\n    int[] freq = new int[26];\n    \n    for (right = 0; right < n; right++) {\n        freq[s.charAt(right) - 'A']++;\n        maxFreq = Math.max(maxFreq, freq[s.charAt(right) - 'A']);\n        \n        if (right - left + 1 - maxFreq > k) {\n            freq[s.charAt(left) - 'A']--;\n            left++;\n        }\n        \n        result = Math.max(result, right - left + 1);\n    }\n    \n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    s = inputs[0]\n    k = inputs[1]\n    result = characterReplacement(s, k)\n    print(result)",
            "javascript": "function characterReplacement(s, k) {\n    const n = s.length;\n    let left = 0, right = 0, maxFreq = 0, result = 0;\n    const freq = new Array(26).fill(0);\n\n    for (right = 0; right < n; right++) {\n        freq[s.charCodeAt(right) - \"A\".charCodeAt(0)]++;\n        maxFreq = Math.max(maxFreq, freq[s.charCodeAt(right) - \"A\".charCodeAt(0)]);\n\n        if (right - left + 1 - maxFreq > k) {\n            freq[s.charCodeAt(left) - \"A\".charCodeAt(0)]--;\n            left++;\n        }\n\n        result = Math.max(result, right - left + 1);\n    }\n    \n    return result;\n}"
        },
        "Qid": "424"
    },
    {
        "_id": {
            "$oid": "66207b208257d25e0805c781"
        },
        "title": "Minimum Number of Gene Mutations",
        "description": "A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and 'T'. Suppose we need to investigate a mutation from a gene string `startGene` to a gene string `endGene` where one mutation is defined as one single character changed in the gene string. There is also a gene bank `bank` that records all the valid gene mutations. A gene must be in `bank` to make it a valid gene string. Given the two gene strings `startGene` and `endGene` and the gene bank `bank`, return the minimum number of mutations needed to mutate from `startGene` to `endGene`. If there is no such a mutation, return -1. Note that the starting point is assumed to be valid, so it might not be included in the bank.",
        "example": "Example:\n\nInput: startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]\nOutput: 1\n\nInput: startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\", \"AACCGCTA\", \"AAACGGTA\"]\nOutput: 2",
        "level": "Medium",
        "tags": [
            "string",
            "search",
            "mutation"
        ],
        "test_cases": {
            "inputs": [
                [
                    "AACCGGTT",
                    "AACCGGTA",
                    [
                        "AACCGGTA"
                    ]
                ],
                [
                    "AACCGGTT",
                    "AAACGGTA",
                    [
                        "AACCGGTA",
                        "AACCGCTA",
                        "AAACGGTA"
                    ]
                ],
                [
                    "AACCGGTT",
                    "AACCGGTT",
                    []
                ],
                [
                    "AACCGGTT",
                    "AACCGGTA",
                    []
                ],
                [
                    "AACCGGTT",
                    "AACCGGTA",
                    [
                        "AACCGGTT"
                    ]
                ],
                [
                    "AACCGGTT",
                    "AACCGGTA",
                    [
                        "AACCGGTT",
                        "AACCGGTC"
                    ]
                ],
                [
                    "AACCGGTT",
                    "AACCGGTA",
                    [
                        "AACCGGTT",
                        "AACCGGTC",
                        "AACCGGTT"
                    ]
                ],
                [
                    "AACCGGTT",
                    "AACCGGTA",
                    [
                        "AACCGGTT",
                        "AACCGGTC",
                        "AACCGGTA"
                    ]
                ],
                [
                    "AACCGGTT",
                    "AACCGGTA",
                    [
                        "AACCGGTT",
                        "AACCGGTC",
                        "AACCGGTA",
                        "AACCGGTA"
                    ]
                ],
                [
                    "AACCGGTT",
                    "AACCGGTA",
                    [
                        "AACCGGTT",
                        "AACCGGTC",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA"
                    ]
                ],
                [
                    "AACCGGTT",
                    "AACCGGTA",
                    [
                        "AACCGGTT",
                        "AACCGGTC",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA"
                    ]
                ],
                [
                    "AACCGGTT",
                    "AACCGGTA",
                    [
                        "AACCGGTT",
                        "AACCGGTC",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA"
                    ]
                ],
                [
                    "AACCGGTT",
                    "AACCGGTA",
                    [
                        "AACCGGTT",
                        "AACCGGTC",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA"
                    ]
                ],
                [
                    "AACCGGTT",
                    "AACCGGTA",
                    [
                        "AACCGGTT",
                        "AACCGGTC",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA"
                    ]
                ],
                [
                    "AACCGGTT",
                    "AACCGGTA",
                    [
                        "AACCGGTT",
                        "AACCGGTC",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA"
                    ]
                ],
                [
                    "AACCGGTT",
                    "AACCGGTA",
                    [
                        "AACCGGTT",
                        "AACCGGTC",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA"
                    ]
                ],
                [
                    "AACCGGTT",
                    "AACCGGTA",
                    [
                        "AACCGGTT",
                        "AACCGGTC",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA"
                    ]
                ],
                [
                    "AACCGGTT",
                    "AACCGGTA",
                    [
                        "AACCGGTT",
                        "AACCGGTC",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA"
                    ]
                ],
                [
                    "AACCGGTT",
                    "AACCGGTA",
                    [
                        "AACCGGTT",
                        "AACCGGTC",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA"
                    ]
                ],
                [
                    "AACCGGTT",
                    "AACCGGTA",
                    [
                        "AACCGGTT",
                        "AACCGGTC",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA"
                    ]
                ],
                [
                    "AACCGGTT",
                    "AACCGGTA",
                    [
                        "AACCGGTT",
                        "AACCGGTC",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA"
                    ]
                ],
                [
                    "AACCGGTT",
                    "AACCGGTA",
                    [
                        "AACCGGTT",
                        "AACCGGTC",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA"
                    ]
                ],
                [
                    "AACCGGTT",
                    "AACCGGTA",
                    [
                        "AACCGGTT",
                        "AACCGGTC",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA",
                        "AACCGGTA"
                    ]
                ]
            ],
            "outputs": [
                1,
                2,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <queue>\n#include <unordered_set>\n\nint minMutation(std::string start, std::string end, std::vector<std::string>& bank) {\n    std::queue<std::string> q;\n    q.push(start);\n    std::unordered_set<std::string> visited;\n    visited.insert(start);\n    int depth = 0;\n\n    while (!q.empty()) {\n        int levelSize = q.size();\n        for (int i = 0; i < levelSize; ++i) {\n            std::string current = q.front();\n            q.pop();\n            if (current == end) return depth;\n\n            for (const auto& gene : bank) {\n                if (!visited.count(gene)) {\n                    int diff = 0;\n                    for (int j = 0; j < 8; ++j) {\n                        if (current[j] != gene[j]) ++diff;\n                        if (diff > 1) break;\n                    }\n\n                    if (diff == 1) {\n                        q.push(gene);\n                        visited.insert(gene);\n                    }\n                }\n            }\n        }\n        depth++;\n    }\n    return -1;\n}\n\n",
            "java": "import java.util.*;\n\npublic int minMutation(String start, String end, String[] bank) {\n    Queue<String> q = new LinkedList<>();\n    q.offer(start);\n    Set<String> visited = new HashSet<>();\n    visited.add(start);\n    int depth = 0;\n    \n    while (!q.isEmpty()) {\n        int levelSize = q.size();\n        for (int i = 0; i < levelSize; i++) {\n            String current = q.poll();\n            if (current.equals(end)) return depth;\n            \n            for (String gene : bank) {\n                if (!visited.contains(gene)) {\n                    int diff = 0;\n                    for (int j = 0; j < 8; j++) {\n                        if (current.charAt(j) != gene.charAt(j)) diff++;\n                        if (diff > 1) break;\n                    }\n                    \n                    if (diff == 1) {\n                        q.offer(gene);\n                        visited.add(gene);\n                    }\n                }\n            }\n        }\n        depth++;\n    }\n    return -1;\n}\n\n",
            "python": "from collections import deque\n\ndef minMutation(start, end, bank):\n    q = deque([start])\n    visited = set([start])\n    depth = 0\n\n    while q:\n        levelSize = len(q)\n        for _ in range(levelSize):\n            current = q.popleft()\n            if current == end:\n                return depth\n\n            for gene in bank:\n                if gene not in visited:\n                    diff = sum(1 for j in range(8) if current[j] != gene[j])\n                    if diff == 1:\n                        q.append(gene)\n                        visited.add(gene)\n        depth += 1\n    return -1\n\n",
            "javascript": "function minMutation(start, end, bank) {\n    const q = [start];\n    const visited = new Set([start]);\n    let depth = 0;\n\n    while (q.length) {\n        const levelSize = q.length;\n        for (let i = 0; i < levelSize; i++) {\n            const current = q.shift();\n            if (current === end) return depth;\n\n            for (const gene of bank) {\n                if (!visited.has(gene)) {\n                    let diff = 0;\n                    for (let j = 0; j < 8; j++) {\n                        if (current[j] !== gene[j]) diff++;\n                        if (diff > 1) break;\n                    }\n\n                    if (diff === 1) {\n                        q.push(gene);\n                        visited.add(gene);\n                    }\n                }\n            }\n        }\n        depth++;\n    }\n    return -1;\n}\n\n",
            "explanation": "1. Use a queue to perform Breadth-First Search.\n2. Push the starting gene onto the queue, and add it to the visited set.\n3. Iterate until the queue is empty.\n   - Iterate through each level (mutations with the same depth) to find valid gene mutations.\n   - For each gene in the bank, if it has not been visited:\n     - Calculate the difference between the current gene and other genes by iterating character by character.\n     - If the difference is only 1, push the new gene onto the queue and add it to the visited set.\n   - Increase the depth (mutation count) after each level has been fully considered.\n4. If the loop ends and the end gene has not been found, return -1, otherwise return the depth."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <queue>\n#include <unordered_set>\n\nint minMutation(std::string start, std::string end, std::vector<std::string>& bank)  {\n    // Your code here\n}\n\n",
            "java": "import java.util.*;\n\npublic int minMutation(String start, String end, String[] bank)  {\n    // Your code here\n}\n\n",
            "python": "from collections import deque\n    # Your code here\n\n",
            "javascript": "function minMutation(start, end, bank)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <queue>\n#include <unordered_set>\n\nint main() {\n    std::string start = $args;\n    std::string end = $args;\n    std::vector<std::string> bank = $args;\n    int result = minMutation(start, end, bank);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public int minMutation(String start, String end, String[] bank) {\n    Queue<String> q = new LinkedList<>();\n    q.offer(start);\n    Set<String> visited = new HashSet<>();\n    visited.add(start);\n    int depth = 0;\n    \n    while (!q.isEmpty()) {\n        int levelSize = q.size();\n        for (int i = 0; i < levelSize; i++) {\n            String current = q.poll();\n            if (current.equals(end)) return depth;\n            \n            for (String gene : bank) {\n                if (!visited.contains(gene)) {\n                    int diff = 0;\n                    for (int j = 0; j < 8; j++) {\n                        if (current.charAt(j) != gene.charAt(j)) diff++;\n                        if (diff > 1) break;\n                    }\n                    \n                    if (diff == 1) {\n                        q.offer(gene);\n                        visited.add(gene);\n                    }\n                }\n            }\n        }\n        depth++;\n    }\n    return -1;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    start = inputs[0]\n    end = inputs[1]\n    bank = inputs[2]\n    result = minMutation(start, end, bank)\n    print(result)",
            "javascript": "function minMutation(start, end, bank) {\n    const q = [start];\n    const visited = new Set([start]);\n    let depth = 0;\n\n    while (q.length) {\n        const levelSize = q.length;\n        for (let i = 0; i < levelSize; i++) {\n            const current = q.shift();\n            if (current === end) return depth;\n\n            for (const gene of bank) {\n                if (!visited.has(gene)) {\n                    let diff = 0;\n                    for (let j = 0; j < 8; j++) {\n                        if (current[j] !== gene[j]) diff++;\n                        if (diff > 1) break;\n                    }\n\n                    if (diff === 1) {\n                        q.push(gene);\n                        visited.add(gene);\n                    }\n                }\n            }\n        }\n        depth++;\n    }\n    return -1;\n}"
        },
        "Qid": "433"
    },
    {
        "_id": {
            "$oid": "66207b368257d25e0805c782"
        },
        "title": "Number of Segments in a String",
        "description": "Given a string `s`, return the number of segments in the string. A segment is defined as a contiguous sequence of non-space characters.",
        "example": "Example 1:\n\nInput: s = \"Hello, my name is John \"\nOutput: 5\nExplanation: The five segments are [\"Hello, \", \"my \", \"name \", \"is \", \"John \"]\n\nExample 2:\n\nInput: s = \"Hello \"\nOutput: 1",
        "level": "Easy",
        "tags": [
            "string",
            "parsing"
        ],
        "test_cases": {
            "inputs": [
                "\"Hello, my name is John \"",
                "\"Hello \"",
                "\"This is a test\"",
                "\"123 456 789\"",
                "\"!@#$%^&*()_+-=,.:\"",
                "\"\"",
                "\"   \"",
                "\"Hello, world!\"",
                "\"Hello, my name is John Doe\"",
                "\"This is a longer string with multiple segments\""
            ],
            "outputs": [
                5,
                1,
                4,
                3,
                1,
                0,
                0,
                2,
                6,
                6
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <sstream>\n\nint countSegments(const std::string& s) {\n    std::stringstream ss(s);\n    int count = 0;\n    std::string temp;\n\n    while (ss >> temp) {\n        ++count;\n    }\n\n    return count;\n}\n",
            "java": "public int countSegments(String s) {\n    if (s == null || s.trim().length() == 0) {\n        return 0;\n    }\n    String[] segments = s.trim().split(\"\\\\s+\");\n    return segments.length;\n}\n",
            "python": "def count_segments(s: str) -> int:\n    return len(s.split())\n",
            "javascript": "function countSegments(s) {\n    if (!s || s.trim().length === 0) {\n        return 0;\n    }\n    const segments = s.trim().split(/\\s+/);\n    return segments.length;\n}\n",
            "explanation": "The algorithm goes as follows:\n\n1. Remove leading and trailing spaces from the input string.\n2. Split the string on any whitespace into an array or list.\n3. Return the length of the resulting array or list, which corresponds to the number of segments in the input string.\n\nIn C++, the `std::stringstream` is used to read words separated by spaces with the `>>` operator. Java and JavaScript use a regex to match any whitespace, and Python has a built-in `split()` method that splits on any whitespace by default."
        },
        "structure": {
            "c++": "#include <string>\n#include <sstream>\n\nint countSegments(const std::string& s)  {\n    // Your code here\n}\n",
            "java": "public int countSegments(String s)  {\n    // Your code here\n}\n",
            "python": "def count_segments(s: str) -> int:\n    # Your code here\n\n",
            "javascript": "function countSegments(s)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <sstream>\n#include <iostream>\n\nint main() {\n    std::string s = $args;\n    int result = countSegments(s);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int countSegments(String s) {\n    if (s == null || s.trim().length() == 0) {\n        return 0;\n    }\n    String[] segments = s.trim().split(\"\\\\s+\");\n    return segments.length;\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args[0]\n    result = count_segments(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = countSegments(s);\n    console.log(result);\n}"
        },
        "Qid": "434"
    },
    {
        "_id": {
            "$oid": "66207b628257d25e0805c783"
        },
        "title": "Minimum Number of Intervals to Remove",
        "description": "Given an array of intervals `intervals` where `intervals[i] = [starti, endi]`, you need to determine the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.",
        "example": "Example 1:\n\nInput: intervals = [[1,2],[2,3],[3,4],[1,3]]\nOutput: 1\nExplanation: [1,3] can be removed and the rest of the intervals are non-overlapping.",
        "level": "Medium",
        "tags": [
            "array",
            "greedy"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        1,
                        3
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        1,
                        2
                    ],
                    [
                        1,
                        2
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        6
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        3,
                        5
                    ],
                    [
                        4,
                        6
                    ]
                ],
                [
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ],
                    [
                        19,
                        20
                    ]
                ]
            ],
            "outputs": [
                1,
                2,
                0,
                1,
                2,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\n\nbool compare(const std::vector<int>& a, const std::vector<int>& b) {\n    return a[1] < b[1];\n}\n\nint eraseOverlapIntervals(std::vector<std::vector<int>>& intervals) {\n    if (intervals.empty()) return 0;\n    \n    std::sort(intervals.begin(), intervals.end(), compare);\n    \n    int count = 0;\n    int prev_end = intervals[0][1];\n    \n    for (size_t i = 1; i < intervals.size(); i++) {\n        if (intervals[i][0] < prev_end) {\n            count++;\n        } else {\n            prev_end = intervals[i][1];\n        }\n    }\n    \n    return count;\n}\n",
            "java": "import java.util.Arrays;\n\npublic int eraseOverlapIntervals(int[][] intervals) {\n    if (intervals.length == 0) return 0;\n\n    Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\n\n    int count = 0;\n    int prev_end = intervals[0][1];\n\n    for (int i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] < prev_end) {\n            count++;\n        } else {\n            prev_end = intervals[i][1];\n        }\n    }\n\n    return count;\n}\n",
            "python": "def eraseOverlapIntervals(intervals):\n    if not intervals:\n        return 0\n    \n    intervals.sort(key=lambda x: x[1])\n    \n    count = 0\n    prev_end = intervals[0][1]\n    \n    for i in range(1, len(intervals)):\n        if intervals[i][0] < prev_end:\n            count += 1\n        else:\n            prev_end = intervals[i][1]\n    \n    return count\n",
            "javascript": "function eraseOverlapIntervals(intervals) {\n    if (intervals.length === 0) return 0;\n\n    intervals.sort((a, b) => a[1] - b[1]);\n\n    let count = 0;\n    let prev_end = intervals[0][1];\n\n    for (let i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] < prev_end) {\n            count++;\n        } else {\n            prev_end = intervals[i][1];\n        }\n    }\n\n    return count;\n}\n",
            "explanation": "The algorithm starts by sorting the input intervals by their ending times. This is because we want to select a minimum number of intervals with the smallest end time to make the rest of the intervals non-overlapping. Then, the algorithm initializes the count of overlapping intervals to 0 and the previous ending value with the first interval's end time.\n\nWe loop through the intervals starting from the second interval. In each iteration, if the current interval's start time is less than the previous end time, it means the current interval overlaps with the previous one. We increment the count in this case. If there's no overlap, we update the previous end time with the current interval's end time. After looping through all the intervals, the count is returned as the minimum number of intervals to remove for non-overlapping intervals."
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\n\nbool compare(const std::vector<int>& a, const std::vector<int>& b)  {\n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\n\npublic int eraseOverlapIntervals(int[][] intervals)  {\n    // Your code here\n}\n",
            "python": "def eraseOverlapIntervals(intervals):\n    # Your code here\n\n",
            "javascript": "function eraseOverlapIntervals(intervals)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nbool compare(const std::vector<int>& a, const std::vector<int>& b) {\n    return a[1] < b[1];\n}\n\nint main() {\n    std::vector<std::vector<int>> intervals = $args;\n    int result = eraseOverlapIntervals(intervals);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int eraseOverlapIntervals(int[][] intervals) {\n    if (intervals.length == 0) return 0;\n\n    Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\n\n    int count = 0;\n    int prev_end = intervals[0][1];\n\n    for (int i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] < prev_end) {\n            count++;\n        } else {\n            prev_end = intervals[i][1];\n        }\n    }\n\n    return count;\n}",
            "python": "if __name__ == \"__main__\":\n    intervals = $args[0]\n    result = eraseOverlapIntervals(intervals)\n    print(result)",
            "javascript": "function main() {\n    const intervals = $args;\n    const result = eraseOverlapIntervals(intervals);\n    console.log(result);\n}"
        },
        "Qid": "435"
    },
    {
        "_id": {
            "$oid": "66207b6e8257d25e0805c784"
        },
        "title": "Right Interval",
        "description": "You are given an array of intervals, where each interval is represented as [start, end]. The start point of each interval is unique. The right interval for an interval i is an interval j such that start_j >= end_i and start_j is minimized. Return an array of right interval indices for each interval i. If no right interval exists for interval i, put -1 at index i.",
        "example": "Example 1:\n\nInput: intervals = [[1,2]]\nOutput: [-1]\nExplanation: There is only one interval in the collection, so it outputs -1.\n\nExample 2:\n\nInput: intervals = [[3,4],[2,3],[1,2]]\nOutput: [-1,0,1]\nExplanation: There is no right interval for [3,4]. The right interval for [2,3] is [3,4] since start0 = 3 is the smallest start that is >= end1 = 3. The right interval for [1,2] is [2,3] since start1 = 2 is the smallest start that is >= end2 = 2.\n\nExample 3:\n\nInput: intervals = [[1,4],[2,3],[3,4]]\nOutput: [-1,2,-1]\nExplanation: There is no right interval for [1,4] and [3,4]. The right interval for [2,3] is [3,4] since start2 = 3 is the smallest start that is >= end1 = 3.",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        2
                    ]
                ],
                [
                    [
                        3,
                        4
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        1,
                        2
                    ]
                ],
                [
                    [
                        1,
                        4
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ]
                ],
                [
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        5
                    ],
                    [
                        6,
                        9
                    ]
                ],
                [
                    [
                        5,
                        10
                    ],
                    [
                        2,
                        7
                    ],
                    [
                        8,
                        12
                    ],
                    [
                        15,
                        20
                    ]
                ],
                [
                    [
                        1,
                        3
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        3,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        6,
                        7
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ]
                ]
            ],
            "outputs": [
                [
                    -1
                ],
                [
                    -1,
                    0,
                    1
                ],
                [
                    -1,
                    2,
                    -1
                ],
                [
                    -1,
                    2,
                    -1
                ],
                [
                    -1,
                    0,
                    2,
                    -1
                ],
                [
                    -1,
                    0,
                    1
                ],
                [
                    -1,
                    0,
                    1
                ],
                [
                    -1,
                    0,
                    -1
                ],
                [
                    -1,
                    -1,
                    -1
                ],
                [
                    -1,
                    0,
                    1,
                    -1
                ],
                [
                    -1,
                    0,
                    1,
                    -1
                ],
                [
                    -1,
                    0,
                    1,
                    -1,
                    -1
                ],
                [
                    -1,
                    0,
                    1,
                    -1,
                    -1
                ],
                [
                    -1,
                    0,
                    1,
                    -1,
                    -1,
                    -1
                ],
                [
                    -1,
                    0,
                    1,
                    -1,
                    -1,
                    -1
                ],
                [
                    -1,
                    0,
                    1,
                    -1,
                    -1,
                    -1,
                    -1
                ],
                [
                    -1,
                    0,
                    1,
                    -1,
                    -1,
                    -1,
                    -1
                ],
                [
                    -1,
                    0,
                    1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1
                ],
                [
                    -1,
                    0,
                    1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1
                ],
                [
                    -1,
                    0,
                    1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <map>\n\nstd::vector<int> findRightInterval(std::vector<std::vector<int>>& intervals) {\n    std::vector<int> res(intervals.size(), -1);\n    std::map<int, int> starts;\n    for(int i = 0; i < intervals.size(); ++i) {\n        starts[intervals[i][0]] = i;\n    }\n\n    for(int i = 0; i < intervals.size(); ++i) {\n        auto it = starts.lower_bound(intervals[i][1]);\n        if(it != starts.end()) {\n            res[i] = it->second;\n        }\n    }\n\n    return res;\n}\n",
            "java": "import java.util.TreeMap;\nimport java.util.Map;\n\npublic int[] findRightInterval(int[][] intervals) {\n    int[] res = new int[intervals.length];\n    TreeMap<Integer, Integer> starts = new TreeMap<>();\n\n    for(int i = 0; i < intervals.length; i++) {\n        starts.put(intervals[i][0], i);\n    }\n\n    for(int i = 0; i < intervals.length; i++) {\n        Map.Entry<Integer, Integer> right = starts.ceilingEntry(intervals[i][1]);\n        res[i] = right == null ? -1 : right.getValue();\n    }\n\n    return res;\n}\n",
            "python": "def findRightInterval(intervals):\n    starts = {interval[0]: index for index, interval in enumerate(intervals)}\n    res = []\n\n    for interval in intervals:\n        right = min(filter(lambda x: x >= interval[1], starts.keys()), default=-1)\n        res.append(starts[right] if right != -1 else -1)\n\n    return res\n",
            "javascript": "function findRightInterval(intervals) {\n    const starts = new Map();\n    const res = [];\n\n    intervals.forEach((interval, index) => {\n        starts.set(interval[0], index);\n    });\n\n    for (const interval of intervals) {\n        const rightKeys = [...starts.keys()].filter(x => x >= interval[1]);\n        const right = Math.min(...rightKeys);\n        res.push(right === Infinity ? -1 : starts.get(right));\n    }\n\n    return res;\n}\n",
            "explanation": "The algorithm first creates a map, `starts`, to store the start times of each interval with their corresponding index in the original array. Then, we iterate through each interval, finding the minimum interval start time greater than or equal to the interval's end time using either lower_bound (C++) or ceilingEntry (Java) or filter (Python, JavaScript). If we find a valid start time, we get the corresponding index from the `starts` map and store it in the result array, otherwise we store -1."
        },
        "structure": {
            "c++": "#include <vector>\n#include <map>\n\nstd::vector<int> findRightInterval(std::vector<std::vector<int>>& intervals)  {\n    // Your code here\n}\n",
            "java": "import java.util.TreeMap;\nimport java.util.Map;\n\npublic int[] findRightInterval(int[][] intervals)  {\n    // Your code here\n}\n",
            "python": "def findRightInterval(intervals):\n    # Your code here\n\n",
            "javascript": "function findRightInterval(intervals)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <map>\n#include <iostream>\n\nint main() {\n    std::vector<std::vector<int>> intervals = $args;\n    std::vector<int> result = findRightInterval(intervals);\n    for(int i = 0; i < result.size(); ++i) {\n        std::cout << result[i] << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}",
            "java": "public int[] findRightInterval(int[][] intervals) {\n    int[] res = new int[intervals.length];\n    TreeMap<Integer, Integer> starts = new TreeMap<>();\n\n    for(int i = 0; i < intervals.length; i++) {\n        starts.put(intervals[i][0], i);\n    }\n\n    for(int i = 0; i < intervals.length; i++) {\n        Map.Entry<Integer, Integer> right = starts.ceilingEntry(intervals[i][1]);\n        res[i] = right == null ? -1 : right.getValue();\n    }\n\n    return res;\n}",
            "python": "if __name__ == \"__main__\":\n    intervals = $args[0]\n    result = findRightInterval(intervals)\n    print(result)",
            "javascript": "function findRightInterval(intervals) {\n    const starts = new Map();\n    const res = [];\n\n    intervals.forEach((interval, index) => {\n        starts.set(interval[0], index);\n    });\n\n    for (const interval of intervals) {\n        const rightKeys = [...starts.keys()].filter(x => x >= interval[1]);\n        const right = Math.min(...rightKeys);\n        res.push(right === Infinity ? -1 : starts.get(right));\n    }\n\n    return res;\n}"
        },
        "Qid": "436"
    },
    {
        "_id": {
            "$oid": "66207cd68257d25e0805c785"
        },
        "title": "Kth Lexicographically Smallest Integer",
        "description": "Given two integers `n` and `k`, return the `kth` lexicographically smallest integer in the range `[1, n]`.",
        "example": "Example 1:\n\nInput: n = 13, k = 2\nOutput: 10\nExplanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.\n\nExample 2:\n\nInput: n = 1, k = 1\nOutput: 1",
        "level": "Medium",
        "tags": [
            "Math",
            "Sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    13,
                    2
                ],
                [
                    1,
                    1
                ],
                [
                    5,
                    3
                ],
                [
                    100,
                    50
                ],
                [
                    10,
                    10
                ],
                [
                    20,
                    15
                ],
                [
                    1000,
                    500
                ],
                [
                    10000,
                    1000
                ],
                [
                    12345,
                    6789
                ],
                [
                    987654321,
                    123456789
                ],
                [
                    1000000000,
                    999999999
                ],
                [
                    999999999,
                    1
                ]
            ],
            "outputs": [
                10,
                1,
                3,
                50,
                10,
                15,
                500,
                1000,
                6789,
                123456789,
                999999999,
                1
            ]
        },
        "sample_code": {
            "c++": "#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint findKthNumber(int n, int k) {\n    vector<int> nums;\n    for (int i = 1; i <= n; ++i) {\n        nums.push_back(i);\n    }\n    sort(nums.begin(), nums.end(), [](int a, int b) {\n        return to_string(a) < to_string(b);\n    });\n    return nums[k - 1];\n}\n\n",
            "java": "import java.util.*;\npublic class Solution {\n    public int findKthNumber(int n, int k) {\n        List<Integer> nums = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            nums.add(i);\n        }\n        nums.sort((a, b) -> String.valueOf(a).compareTo(String.valueOf(b)));\n        return nums.get(k - 1);\n    }\n}\n\n",
            "python": "def find_kth_number(n, k):\n    nums = [i for i in range(1, n + 1)]\n    nums.sort(key=lambda x: str(x))\n    return nums[k - 1]\n\n",
            "javascript": "function findKthNumber(n, k) {\n    const nums = [];\n    for (let i = 1; i <= n; i++) {\n        nums.push(i);\n    }\n    nums.sort((a, b) => String(a).localeCompare(String(b)));\n    return nums[k - 1];\n}\n\n",
            "explanation": "First, we initialize a list or vector containing all the integers from 1 to n. \n\nThen, we sort this list lexicographically. For C++ and Java, we use a lambda function to compare the string representation of the numbers. In Python, we use a lambda function inside the sort function, and in JavaScript, we use the `localeCompare()` method to sort the integers lexicographically.\n\nFinally, we return the Kth element in the sorted list by accessing the element at index `k - 1`."
        },
        "structure": {
            "c++": "#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint findKthNumber(int n, int k)  {\n    // Your code here\n}\n\n",
            "java": "i {mport java.util.*;\npublic class Solution \n    // Your code here\n}\n\n",
            "python": "def find_kth_number(n, k):\n    # Your code here\n\n",
            "javascript": "function findKthNumber(n, k)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n = $args;\n    int k = $args;\n    int result = findKthNumber(n, k);\n    cout << result << endl;\n    return 0;\n}\n",
            "java": "public int findKthNumber(int n, int k) {\n        List<Integer> nums = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            nums.add(i);\n        }\n        nums.sort((a, b) -> String.valueOf(a).compareTo(String.valueOf(b)));\n        return nums.get(k - 1);\n    }",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    n = inputs[0]\n    k = inputs[1]\n    result = find_kth_number(n, k)\n    print(result)",
            "javascript": "function main() {\n    const n = $args[0];\n    const k = $args[1];\n    const result = findKthNumber(n, k);\n    console.log(result);\n}"
        },
        "Qid": "440"
    },
    {
        "_id": {
            "$oid": "66207cfd8257d25e0805c786"
        },
        "title": "Staircase Rows",
        "description": "You have `n` coins and you want to build a staircase with these coins. The staircase consists of `k` rows where the `ith` row has exactly `i` coins. The last row of the staircase **may be** incomplete. Given the integer `n`, return the number of complete rows of the staircase you will build.",
        "example": "Example 1:\n\nInput: n = 5\nOutput: 2\nExplanation: Because the 3rd row is incomplete, we return 2.\n\nExample 2:\n\nInput: n = 8\nOutput: 3\nExplanation: Because the 4th row is incomplete, we return 3.",
        "level": "Easy",
        "tags": [
            "math",
            "loops"
        ],
        "test_cases": {
            "inputs": [
                5,
                8,
                1,
                10,
                15,
                20,
                25,
                30,
                50,
                100,
                1000,
                10000,
                100000,
                1000000,
                10000000,
                100000000,
                1000000000,
                2147483647
            ],
            "outputs": [
                2,
                3,
                1,
                4,
                5,
                5,
                5,
                6,
                7,
                13,
                44,
                141,
                447,
                1414,
                4472,
                14142,
                44721,
                46340
            ]
        },
        "sample_code": {
            "c++": "int arrangeCoins(int n) {\n    int k = 0;\n    while (n > k) {\n        k++;\n        n -= k;\n    }\n    return k;\n}\n",
            "java": "public int arrangeCoins(int n) {\n    int k = 0;\n    while (n > k) {\n        k++;\n        n -= k;\n    }\n    return k;\n}\n",
            "python": "def arrange_coins(n: int) -> int:\n    k = 0\n    while n > k:\n        k += 1\n        n -= k\n    return k\n",
            "javascript": "function arrangeCoins(n) {\n    let k = 0;\n    while (n > k) {\n        k++;\n        n -= k;\n    }\n    return k;\n}\n",
            "explanation": "The algorithm initializes a variable k, which represents the current row number, to 0. Then it enters a loop where it checks if n is greater than k. If so, it increments k by 1 and subtracts k from n. This process continues until n is no longer greater than k. Finally, the value of k is returned, representing the number of complete rows of the staircase. This approach has a time complexity of O(sqrt(n)) since the number of iterations increases linearly with the size of the staircase."
        },
        "structure": {
            "c++": "int arrangeCoins(int n)  {\n    // Your code here\n}\n",
            "java": "public int arrangeCoins(int n)  {\n    // Your code here\n}\n",
            "python": "def arrange_coins(n: int) -> int:\n    # Your code here\n\n",
            "javascript": "function arrangeCoins(n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = arrangeCoins(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int arrangeCoins(int n) {\n    int k = 0;\n    while (n > k) {\n        k++;\n        n -= k;\n    }\n    return k;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args[0]\n    result = arrange_coins(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = arrangeCoins(n);\n    console.log(result);\n}"
        },
        "Qid": "441"
    },
    {
        "_id": {
            "$oid": "6620cdd4292c6db776c5e625"
        },
        "title": "Longest Substring Without Repeating Characters",
        "description": "Given a string `s`, find the length of the longest substring without repeating characters.",
        "example": "Example 1:\n\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.",
        "level": "Medium",
        "tags": [
            "string",
            "sliding window",
            "hash table"
        ],
        "test_cases": {
            "inputs": [
                "\"abcabcbb\"",
                "\"bbbbb\"",
                "\"pwwkew\"",
                "\"\"",
                "\"a\"",
                "\"abcdefg\"",
                "\"aab\"",
                "\"abb\"",
                "\"abcabcabc\"",
                "\"abcdeffghijklmnopqrstuvwxyz\""
            ],
            "outputs": [
                "3",
                "1",
                "3",
                "0",
                "1",
                "7",
                "2",
                "2",
                "3",
                "26"
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <unordered_set>\n\nint lengthOfLongestSubstring(std::string s) {\n    int left = 0, right = 0, maxLength = 0;\n    std::unordered_set<char> characters;\n\n    while (right < s.size()) {\n        if (characters.find(s[right]) == characters.end()) {\n            characters.insert(s[right]);\n            maxLength = std::max(maxLength, right - left + 1);\n            right++;\n        } else {\n            characters.erase(s[left]);\n            left++;\n        }\n    }\n\n    return maxLength;\n}\n",
            "java": "public static int lengthOfLongestSubstring(String s) {\n    int left = 0, right = 0, maxLength = 0;\n    Set<Character> characters = new HashSet<>();\n\n    while (right < s.length()) {\n        if (!characters.contains(s.charAt(right))) {\n            characters.add(s.charAt(right));\n            maxLength = Math.max(maxLength, right - left + 1);\n            right++;\n        } else {\n            characters.remove(s.charAt(left));\n            left++;\n        }\n    }\n\n    return maxLength;\n}\n",
            "python": "def length_of_longest_substring(s: str) -> int:\n    left = 0\n    right = 0\n    max_length = 0\n    characters = set()\n\n    while right < len(s):\n        if s[right] not in characters:\n            characters.add(s[right])\n            max_length = max(max_length, right - left + 1)\n            right += 1\n        else:\n            characters.remove(s[left])\n            left += 1\n\n    return max_length\n",
            "javascript": "function lengthOfLongestSubstring(s) {\n    let left = 0, right = 0, maxLength = 0;\n    const characters = new Set();\n\n    while (right < s.length) {\n        if (!characters.has(s.charAt(right))) {\n            characters.add(s.charAt(right));\n            maxLength = Math.max(maxLength, right - left + 1);\n            right++;\n        } else {\n            characters.delete(s.charAt(left));\n            left++;\n        }\n    }\n\n    return maxLength;\n}\n",
            "explanation": "The algorithm uses a sliding window with two pointers, left and right, to iterate through the string. It also uses a set to store the unique characters in the current window.\n\n1. Initialize left and right pointers to the start of the string, and maxLength to 0.\n2. Check if the character at the right index is in the set.\n   - If it's not in the set, add the character to the set, update maxLength, and move the right pointer forward.\n   - If it's in the set, remove the character at the left index from the set, and move the left pointer forward.\n3. Repeat step 2 until the right pointer reaches the end of the string.\n4. Return maxLength. \n\nThe algorithm runs in O(n) time, where n is the length of the input string."
        },
        "structure": {
            "c++": "#include <string>\n#include <unordered_set>\n\nint lengthOfLongestSubstring(std::string s)  {\n    // Your code here\n}\n",
            "java": "public static int lengthOfLongestSubstring(String s) {\n    // Your code here\n}\n",
            "python": "def length_of_longest_substring(s: str) -> int:\n    # Your code here\n\n",
            "javascript": "function lengthOfLongestSubstring(s)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\n#include <string>\n#include <unordered_set>\n\nint main() {\n    std::string s = $args;\n    int result = lengthOfLongestSubstring(s);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    s = $args\n    result = length_of_longest_substring(s)\n    print(result)",
            "javascript": "function main() {\n    const s = $args;\n    const result = lengthOfLongestSubstring(s);\n    console.log(result);\n}",
            "java": "public static void main(String[] args) {\n        String input = $args;\n        int result = lengthOfLongestSubstring(input);\n        System.out.println(result);\n    }"
        },
        "Qid": "3",
        "languages verified": "all"
    },
    {
        "_id": {
            "$oid": "66299128baf481a372cdfe22"
        },
        "title": "Find Duplicates in Array",
        "description": "Given an integer array `nums` of length `n` where all the integers of `nums` are in the range `[1, n]` and each integer appears **once** or **twice**, write a function to return an array of all the integers that appear **twice**.",
        "example": "Example 1:\n\nInput: nums = [4,3,2,7,8,2,3,1]\nOutput: [2,3]\n\nExample 2:\n\nInput: nums = [1,1,2]\nOutput: [1]\n\nExample 3:\n\nInput: nums = [1]\nOutput: []",
        "level": "Easy",
        "tags": [
            "Array",
            "Hash Table"
        ],
        "test_cases": {
            "inputs": [
                [
                    4,
                    3,
                    2,
                    7,
                    8,
                    2,
                    3,
                    1
                ],
                [
                    1,
                    1,
                    2
                ],
                [
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    3,
                    1,
                    4,
                    2,
                    1,
                    4,
                    2
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    9
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    3,
                    3,
                    3,
                    3,
                    3,
                    3,
                    3,
                    3,
                    3,
                    3
                ],
                [
                    4,
                    4,
                    4,
                    4,
                    4,
                    4,
                    4,
                    4,
                    4,
                    4
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    6,
                    6,
                    6,
                    6,
                    6,
                    6,
                    6,
                    6,
                    6,
                    6
                ],
                [
                    7,
                    7,
                    7,
                    7,
                    7,
                    7,
                    7,
                    7,
                    7,
                    7
                ],
                [
                    8,
                    8,
                    8,
                    8,
                    8,
                    8,
                    8,
                    8,
                    8,
                    8
                ],
                [
                    9,
                    9,
                    9,
                    9,
                    9,
                    9,
                    9,
                    9,
                    9,
                    9
                ],
                [
                    10,
                    10,
                    10,
                    10,
                    10,
                    10,
                    10,
                    10,
                    10,
                    10
                ]
            ],
            "outputs": [
                [
                    2,
                    3
                ],
                [
                    1
                ],
                [],
                [
                    2
                ],
                [
                    1,
                    2,
                    4
                ],
                [],
                [
                    1
                ],
                [
                    9
                ],
                [],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1
                ],
                [
                    2
                ],
                [
                    3
                ],
                [
                    4
                ],
                [
                    5
                ],
                [
                    6
                ],
                [
                    7
                ],
                [
                    8
                ],
                [
                    9
                ],
                [
                    10
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <cmath>\n\nstd::vector<int> findDuplicates(std::vector<int>& nums) {\n    std::vector<int> duplicates;\n    for (int i = 0; i < nums.size(); i++) {\n        int index = abs(nums[i]) - 1;\n        if (nums[index] < 0) {\n            duplicates.push_back(abs(nums[i]));\n        } else {\n            nums[index] *= -1;\n        }\n    }\n    return duplicates;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> findDuplicates(int[] nums) {\n    List<Integer> duplicates = new ArrayList<>();\n    for (int i = 0; i < nums.length; i++) {\n        int index = Math.abs(nums[i]) - 1;\n        if (nums[index] < 0) {\n            duplicates.add(Math.abs(nums[i]));\n        } else {\n            nums[index] *= -1;\n        }\n    }\n    return duplicates;\n}\n",
            "python": "def find_duplicates(nums):\n    duplicates = []\n    for i in range(len(nums)):\n        index = abs(nums[i]) - 1\n        if nums[index] < 0:\n            duplicates.append(abs(nums[i]))\n        else:\n            nums[index] *= -1\n    return duplicates\n",
            "javascript": "function findDuplicates(nums) {\n    let duplicates = [];\n    for (let i = 0; i < nums.length; i++) {\n        let index = Math.abs(nums[i]) - 1;\n        if (nums[index] < 0) {\n            duplicates.push(Math.abs(nums[i]));\n        } else {\n            nums[index] *= -1;\n        }\n    }\n    return duplicates;\n}\n",
            "explanation": "The algorithm iterates through the input array, using the array values as indices. For each index, we make the corresponding value in the array negative. If we encounter a negative value during the process, that means this index was seen before (i.e., the value was duplicated), so we add the absolute value of the duplicated number to the result.\n\nThe algorithm runs in O(n) time complexity, as there is only one iteration through the input array. It also uses constant extra space, because the input array is utilized for marking, and only the result array is created separately."
        },
        "structure": {
            "c++": "#include <vector>\n#include <cmath>\n\nstd::vector<int> findDuplicates(std::vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> findDuplicates(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def find_duplicates(nums):\n    # Your code here\n\n",
            "javascript": "function findDuplicates(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <cmath>\n#include <iostream>\n\nstd::vector<int> findDuplicates(std::vector<int>& nums);\n\nint main() {\n    std::vector<int> nums = $args;\n    std::vector<int> result = findDuplicates(nums);\n    for (int i = 0; i < result.size(); i++) {\n        std::cout << result[i] << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}\n",
            "java": "public List<Integer> findDuplicates(int[] nums) {\n    List<Integer> duplicates = new ArrayList<>();\n    for (int i = 0; i < nums.length; i++) {\n        int index = Math.abs(nums[i]) - 1;\n        if (nums[index] < 0) {\n            duplicates.add(Math.abs(nums[i]));\n        } else {\n            nums[index] *= -1;\n        }\n    }\n    return duplicates;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = find_duplicates(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = findDuplicates(nums);\n    console.log(result);\n}"
        },
        "Qid": "442"
    },
    {
        "_id": {
            "$oid": "662991c6baf481a372cdfe23"
        },
        "title": "Arithmetic Subsequences",
        "description": "Given an integer array `nums`, return the number of all the arithmetic subsequences of `nums`. A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.",
        "example": "Example:\n\nInput: nums = [2,4,6,8,10]\nOutput: 7\nExplanation: All arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]",
        "level": "Medium",
        "tags": [
            "array",
            "subsequence",
            "arithmetic"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    4,
                    6,
                    8,
                    10
                ],
                [
                    7,
                    7,
                    7,
                    7,
                    7
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9
                ],
                [
                    3,
                    -1,
                    -5,
                    -9
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16
                ],
                [
                    1,
                    2,
                    4,
                    7,
                    11
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    15
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    32
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    31
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    30
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    29
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    28
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    27
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    26
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    25
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    24
                ],
                [
                    1,
                    2,
                    4,
                    8,
                    16,
                    23
                ]
            ],
            "outputs": [
                7,
                16,
                7,
                10,
                16,
                7,
                15,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <unordered_map>\n\nint numberOfArithmeticSlices(std::vector<int>& nums) {\n    int res = 0;\n    int n = nums.size();\n    std::vector<std::unordered_map<int, int>> dp(n);\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            long diff = (long)nums[i] - (long)nums[j];\n            if (diff <= INT_MIN || diff > INT_MAX) continue;\n\n            int delta = (int)diff;\n            dp[i][delta] += 1;\n\n            if (dp[j].count(delta)) {\n                res += dp[j][delta];\n                dp[i][delta] += dp[j][delta];\n            }\n        }\n    }\n    return res;\n}\n\n",
            "java": "import java.util.HashMap;\nimport java.util.Map;\n\npublic int numberOfArithmeticSlices(int[] nums) {\n    int res = 0;\n    int n = nums.length;\n    Map<Integer, Integer>[] dp = new HashMap[n];\n\n    for (int i = 0; i < n; ++i) {\n        dp[i] = new HashMap<>();\n        for (int j = 0; j < i; ++j) {\n            long diff = (long)nums[i] - (long)nums[j];\n            if (diff <= Integer.MIN_VALUE || diff > Integer.MAX_VALUE) continue;\n\n            int delta = (int)diff;\n            dp[i].put(delta, dp[i].getOrDefault(delta, 0) + 1);\n\n            if (dp[j].containsKey(delta)) {\n                res += dp[j].get(delta);\n                dp[i].put(delta, dp[i].get(delta) + dp[j].get(delta));\n            }\n        }\n    }\n    return res;\n}\n\n",
            "python": "def numberOfArithmeticSlices(nums):\n    res = 0\n    n = len(nums)\n    dp = [dict() for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            diff = nums[i] - nums[j]\n            if diff <= -2**31 or diff > 2**31:\n                continue\n\n            dp[i][diff] = dp[i].get(diff, 0) + 1\n\n            if diff in dp[j]:\n                res += dp[j][diff]\n                dp[i][diff] += dp[j][diff]\n\n    return res\n\n",
            "javascript": "function numberOfArithmeticSlices(nums) {\n    let res = 0;\n    const n = nums.length;\n    const dp = new Array(n).fill(0).map(() => new Map());\n\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < i; ++j) {\n            const diff = nums[i] - nums[j];\n            if (diff <= Number.MIN_SAFE_INTEGER || diff > Number.MAX_SAFE_INTEGER) continue;\n\n            if (!dp[i].has(diff)) {\n                dp[i].set(diff, 0);\n            }\n\n            dp[i].set(diff, dp[i].get(diff) + 1);\n\n            if (dp[j].has(diff)) {\n                res += dp[j].get(diff);\n                dp[i].set(diff, dp[i].get(diff) + dp[j].get(diff));\n            }\n        }\n    }\n    return res;\n}\n\n",
            "explanation": "To solve this problem, we use dynamic programming. The `dp` data structure is an array of hashmaps or dictionaries. Each index `i` in the array represents an element in the given array `nums`, and the hashmap stored at `dp[i]` will store the count of arithmetic subsequences that end at the element `nums[i]`, with keys representing the differences between elements.\n\nStarting with index `i = 0`, we iterate through the `nums` array. For each element `nums[i]`, we iterate through all previous elements `nums[j]` with `j < i`.\n\nFor each pair of elements `(nums[i], nums[j])`, we calculate their difference and store the count of arithmetic subsequences formed by this difference at `dp[i]`.\n\nIf an existing subsequence with the same difference is found in `dp[j]`, we should be able to append `nums[i]` to all previously formed subsequences ending at `nums[j]`. Thus, we add the count of subsequences from `dp[j][delta]` to the result, and also update the count in `dp[i][delta]`.\n\nFinally, after iterating through all elements, the `res` variable will hold the count of all the arithmetic subsequences."
        },
        "structure": {
            "c++": "#include <vector>\n#include <unordered_map>\n\nint numberOfArithmeticSlices(std::vector<int>& nums)  {\n    // Your code here\n}\n\n",
            "java": "import java.util.HashMap;\nimport java.util.Map;\n\npublic int numberOfArithmeticSlices(int[] nums)  {\n    // Your code here\n}\n\n",
            "python": "def numberOfArithmeticSlices(nums):\n    # Your code here\n\n",
            "javascript": "function numberOfArithmeticSlices(nums)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <unordered_map>\n#include <iostream>\n\nint main() {\n    std::vector<int> nums = $args;\n    int result = numberOfArithmeticSlices(nums);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public int numberOfArithmeticSlices(int[] nums) {\n    int res = 0;\n    int n = nums.length;\n    Map<Integer, Integer>[] dp = new HashMap[n];\n\n    for (int i = 0; i < n; ++i) {\n        dp[i] = new HashMap<>();\n        for (int j = 0; j < i; ++j) {\n            long diff = (long)nums[i] - (long)nums[j];\n            if (diff <= Integer.MIN_VALUE || diff > Integer.MAX_VALUE) continue;\n\n            int delta = (int)diff;\n            dp[i].put(delta, dp[i].getOrDefault(delta, 0) + 1);\n\n            if (dp[j].containsKey(delta)) {\n                res += dp[j].get(delta);\n                dp[i].put(delta, dp[i].get(delta) + dp[j].get(delta));\n            }\n        }\n    }\n    return res;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = numberOfArithmeticSlices(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = numberOfArithmeticSlices(nums);\n    console.log(result);\n}"
        },
        "Qid": "446"
    },
    {
        "_id": {
            "$oid": "662991f1baf481a372cdfe24"
        },
        "title": "Number of Boomerangs",
        "description": "You are given `n` `points` in the plane that are all **distinct**, where `points[i] = [xi, yi]`. A **boomerang** is a tuple of points `(i, j, k)` such that the distance between `i` and `j` equals the distance between `i` and `k` **(the order of the tuple matters)**. Return the number of boomerangs.",
        "example": "Example:\n\nInput: points = [[0,0],[1,0],[2,0]]\nOutput: 2\nExplanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]].",
        "level": "Medium",
        "tags": [
            "Array",
            "Math"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        0
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ]
                ],
                [
                    [
                        1,
                        1
                    ]
                ],
                [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ],
                    [
                        26,
                        26
                    ],
                    [
                        27,
                        27
                    ],
                    [
                        28,
                        28
                    ],
                    [
                        29,
                        29
                    ],
                    [
                        30,
                        30
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ],
                    [
                        26,
                        26
                    ],
                    [
                        27,
                        27
                    ],
                    [
                        28,
                        28
                    ],
                    [
                        29,
                        29
                    ],
                    [
                        30,
                        30
                    ],
                    [
                        31,
                        31
                    ],
                    [
                        32,
                        32
                    ],
                    [
                        33,
                        33
                    ],
                    [
                        34,
                        34
                    ],
                    [
                        35,
                        35
                    ],
                    [
                        36,
                        36
                    ],
                    [
                        37,
                        37
                    ],
                    [
                        38,
                        38
                    ],
                    [
                        39,
                        39
                    ],
                    [
                        40,
                        40
                    ]
                ],
                [
                    [
                        1,
                        1
                    ],
                    [
                        2,
                        2
                    ],
                    [
                        3,
                        3
                    ],
                    [
                        4,
                        4
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        6,
                        6
                    ],
                    [
                        7,
                        7
                    ],
                    [
                        8,
                        8
                    ],
                    [
                        9,
                        9
                    ],
                    [
                        10,
                        10
                    ],
                    [
                        11,
                        11
                    ],
                    [
                        12,
                        12
                    ],
                    [
                        13,
                        13
                    ],
                    [
                        14,
                        14
                    ],
                    [
                        15,
                        15
                    ],
                    [
                        16,
                        16
                    ],
                    [
                        17,
                        17
                    ],
                    [
                        18,
                        18
                    ],
                    [
                        19,
                        19
                    ],
                    [
                        20,
                        20
                    ],
                    [
                        21,
                        21
                    ],
                    [
                        22,
                        22
                    ],
                    [
                        23,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ],
                    [
                        26,
                        26
                    ],
                    [
                        27,
                        27
                    ],
                    [
                        28,
                        28
                    ],
                    [
                        29,
                        29
                    ],
                    [
                        30,
                        30
                    ],
                    [
                        31,
                        31
                    ],
                    [
                        32,
                        32
                    ],
                    [
                        33,
                        33
                    ],
                    [
                        34,
                        34
                    ],
                    [
                        35,
                        35
                    ],
                    [
                        36,
                        36
                    ],
                    [
                        37,
                        37
                    ],
                    [
                        38,
                        38
                    ],
                    [
                        39,
                        39
                    ],
                    [
                        40,
                        40
                    ],
                    [
                        41,
                        41
                    ],
                    [
                        42,
                        42
                    ],
                    [
                        43,
                        43
                    ],
                    [
                        44,
                        44
                    ],
                    [
                        45,
                        45
                    ],
                    [
                        46,
                        46
                    ],
                    [
                        47,
                        47
                    ],
                    [
                        48,
                        48
                    ],
                    [
                        49,
                        49
                    ],
                    [
                        50,
                        50
                    ]
                ]
            ],
            "outputs": [
                2,
                2,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "#include <unordered_map>\n\nint numberOfBoomerangs(vector<vector<int>>& points) {\n    int count = 0;\n\n    for (auto& i : points) {\n        unordered_map<int, int> group_count;\n        for (auto& j : points) {\n            int dx = i[0] - j[0], dy = i[1] - j[1];\n            int dist = dx * dx + dy * dy;\n            group_count[dist]++;\n        }\n\n        for (auto& g : group_count) {\n            count += g.second * (g.second - 1);\n        }\n    }\n\n    return count;\n}\n",
            "java": "import java.util.HashMap;\n\npublic int numberOfBoomerangs(int[][] points) {\n    int count = 0;\n\n    for (int[] i : points) {\n        HashMap<Integer, Integer> group_count = new HashMap<>();\n        for (int[] j : points) {\n            int dx = i[0] - j[0], dy = i[1] - j[1];\n            int dist = dx * dx + dy * dy;\n\n            group_count.put(dist, group_count.getOrDefault(dist, 0) + 1);\n        }\n\n        for (int g : group_count.values()) {\n            count += g * (g - 1);\n        }\n    }\n\n    return count;\n}\n",
            "python": "def numberOfBoomerangs(points):\n    count = 0\n\n    for i in points:\n        group_count = {}\n        for j in points:\n            dx, dy = i[0] - j[0], i[1] - j[1]\n            dist = dx * dx + dy * dy\n            group_count[dist] = group_count.get(dist, 0) + 1\n\n        for g in group_count.values():\n            count += g * (g - 1)\n\n    return count\n",
            "javascript": "function numberOfBoomerangs(points) {\n    let count = 0;\n\n    for (let i of points) {\n        let group_count = new Map();\n        for (let j of points) {\n            let dx = i[0] - j[0], dy = i[1] - j[1];\n            let dist = dx * dx + dy * dy;\n            group_count.set(dist, (group_count.get(dist) || 0) + 1);\n        }\n\n        for (let g of group_count.values()) {\n            count += g * (g - 1);\n        }\n    }\n\n    return count;\n}\n",
            "explanation": "1. For every point `i` in the input, we create a hash map called `group_count` to store the count of points with the same distance from point `i`.\n2. For every point `j`, we calculate the squared distance from `i` to `j`. We use the squared distance to avoid using a square root function, as it's not necessary for this problem.\n3. Increment the count of the squared distance in `group_count`.\n4. To calculate the number of boomerangs, iterate through the values of `group_count`. For every count `g`, we have `g * (g - 1)` boomerangs because there are `g` choices for the second point and `g - 1` choices for the third point.\n5. Return the total number of boomerangs."
        },
        "structure": {
            "c++": "#include <unordered_map>\n\nint numberOfBoomerangs(vector<vector<int>>& points)  {\n    // Your code here\n}\n",
            "java": "import java.util.HashMap;\n\npublic int numberOfBoomerangs(int[][] points)  {\n    // Your code here\n}\n",
            "python": "def numberOfBoomerangs(points):\n    # Your code here\n\n",
            "javascript": "function numberOfBoomerangs(points)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <unordered_map>\n#include <vector>\n#include <iostream>\n\nint numberOfBoomerangs(vector<vector<int>>& points) {\n    int count = 0;\n\n    for (auto& i : points) {\n        unordered_map<int, int> group_count;\n        for (auto& j : points) {\n            int dx = i[0] - j[0], dy = i[1] - j[1];\n            int dist = dx * dx + dy * dy;\n            group_count[dist]++;\n        }\n\n        for (auto& g : group_count) {\n            count += g.second * (g.second - 1);\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    vector<vector<int>> points = $args;\n    int result = numberOfBoomerangs(points);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int numberOfBoomerangs(int[][] points) {\n    int count = 0;\n\n    for (int[] i : points) {\n        HashMap<Integer, Integer> group_count = new HashMap<>();\n        for (int[] j : points) {\n            int dx = i[0] - j[0], dy = i[1] - j[1];\n            int dist = dx * dx + dy * dy;\n\n            group_count.put(dist, group_count.getOrDefault(dist, 0) + 1);\n        }\n\n        for (int g : group_count.values()) {\n            count += g * (g - 1);\n        }\n    }\n\n    return count;\n}",
            "python": "if __name__ == \"__main__\":\n    points = $args\n    result = numberOfBoomerangs(points)\n    print(result)",
            "javascript": "function main() {\n    const points = $args;\n    const result = numberOfBoomerangs(points);\n    console.log(result);\n}"
        },
        "Qid": "447"
    },
    {
        "_id": {
            "$oid": "6629921bbaf481a372cdfe25"
        },
        "title": "Missing Numbers",
        "description": "Given an array `nums` of `n` integers where `nums[i]` is in the range `[1, n]`, return an array of all the integers in the range `[1, n]` that do not appear in `nums`.",
        "example": "Example 1:\n\nInput: nums = [4,3,2,7,8,2,3,1]\nOutput: [5,6]\n\nExample 2:\n\nInput: nums = [1,1]\nOutput: [2]",
        "level": "Easy",
        "tags": [
            "Array",
            "Sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    4,
                    3,
                    2,
                    7,
                    8,
                    2,
                    3,
                    1
                ],
                [
                    1,
                    1
                ],
                [
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1
                ],
                [
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50,
                    51,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    60,
                    61,
                    62,
                    63,
                    64,
                    65,
                    66,
                    67,
                    68,
                    69,
                    70,
                    71,
                    72,
                    73,
                    74,
                    75,
                    76,
                    77,
                    78,
                    79,
                    80,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86,
                    87,
                    88,
                    89,
                    90,
                    91,
                    92,
                    93,
                    94,
                    95,
                    96,
                    97,
                    98,
                    99,
                    100
                ]
            ],
            "outputs": [
                [
                    5,
                    6
                ],
                [
                    2
                ],
                [],
                [],
                [
                    1,
                    2,
                    3,
                    4,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [],
                [],
                [
                    2
                ],
                [
                    1
                ],
                []
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> findDisappearedNumbers(vector<int> &nums) {\n    vector<int> result;\n    \n    for (int i = 0; i < nums.size(); ++i) {\n        int index = abs(nums[i]) - 1;\n        nums[index] = -abs(nums[index]);\n    }\n    \n    for (int i = 0; i < nums.size(); ++i) {\n        if (nums[i] > 0) {\n            result.push_back(i + 1);\n        }\n    }\n    \n    return result;\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> findDisappearedNumbers(int[] nums) {\n    List<Integer> result = new ArrayList<>();\n    \n    for (int i = 0; i < nums.length; i++) {\n        int index = Math.abs(nums[i]) - 1;\n        nums[index] = -Math.abs(nums[index]);\n    }\n\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] > 0) {\n            result.add(i + 1);\n        }\n    }\n\n    return result;\n}\n",
            "python": "def find_disappeared_numbers(nums):\n    result = []\n    \n    for num in nums:\n        index = abs(num) - 1\n        nums[index] = -abs(nums[index])\n\n    for i, num in enumerate(nums):\n        if num > 0:\n            result.append(i + 1)\n\n    return result\n",
            "javascript": "function findDisappearedNumbers(nums) {\n    const result = [];\n\n    for (let i = 0; i < nums.length; i++) {\n        const index = Math.abs(nums[i]) - 1;\n        nums[index] = -Math.abs(nums[index]);\n    }\n\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] > 0) {\n            result.push(i + 1);\n        }\n    }\n\n    return result;\n}\n",
            "explanation": "The algorithm works as follows:\n\n1. Iterate through the input array.\n2. For each value `nums[i]`, find its index by subtracting 1 (`index = abs(nums[i]) - 1`). This is because the integers in the range are 1 to n, and indices are 0-indexed.\n3. Negate the value at this index (`nums[index] = -abs(nums[index])`). This marks the value as \"found\".\n4. Iterate through the modified array.\n5. If a value is positive, it means the integer corresponding to that index hasn't been found. Add it to the result array.\n\nThis algorithm has a time complexity of O(n) and doesn't use any additional space other than the result array."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> findDisappearedNumbers(vector<int> &nums)  {\n    // Your code here\n}\n",
            "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> findDisappearedNumbers(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def find_disappeared_numbers(nums):\n    # Your code here\n\n",
            "javascript": "function findDisappearedNumbers(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nint main() {\n    vector<int> nums = $args;\n    vector<int> result = findDisappearedNumbers(nums);\n    \n    for (int i = 0; i < result.size(); ++i) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n",
            "java": "public List<Integer> findDisappearedNumbers(int[] nums) {\n    List<Integer> result = new ArrayList<>();\n    \n    for (int i = 0; i < nums.length; i++) {\n        int index = Math.abs(nums[i]) - 1;\n        nums[index] = -Math.abs(nums[index]);\n    }\n\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] > 0) {\n            result.add(i + 1);\n        }\n    }\n\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = find_disappeared_numbers(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = findDisappearedNumbers(nums);\n    console.log(result);\n}"
        },
        "Qid": "448"
    },
    {
        "_id": {
            "$oid": "66299303baf481a372cdfe26"
        },
        "title": "Sort String by Character Frequency",
        "description": "Given a string `s`, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string. Return the sorted string. If there are multiple answers, return any of them.",
        "example": "Example 1:\n\nInput: s = \"tree \"\nOutput: \"eert \"\nExplanation: 'e' appears twice while 'r' and 't' both appear once. So 'e' must appear before both 'r' and 't'. Therefore \"eetr \" is also a valid answer.\n\nExample 2:\n\nInput: s = \"cccaaa \"\nOutput: \"aaaccc \"\nExplanation: Both 'c' and 'a' appear three times, so both \"cccaaa \" and \"aaaccc \" are valid answers. Note that \"cacaca \" is incorrect, as the same characters must be together.\n\nExample 3:\n\nInput: s = \"Aabb \"\nOutput: \"bbAa \"\nExplanation: \"bbaA \" is also a valid answer, but \"Aabb \" is incorrect. Note that 'A' and 'a' are treated as two different characters.",
        "level": "Easy",
        "tags": [
            "string",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                "\"tree \"",
                "\"cccaaa \"",
                "\"Aabb \"",
                "\"hello world\"",
                "\"aabbbcccdddeeefff\"",
                "\"abcde\"",
                "\"aaaaa\"",
                "\"bbbbb\"",
                "\"ccccc\"",
                "\"ddddd\"",
                "\"eeeee\"",
                "\"ffffff\"",
                "\"gggggg\"",
                "\"hhhhhh\"",
                "\"iiiiii\"",
                "\"jjjjjj\"",
                "\"kkkkkk\"",
                "\"llllll\"",
                "\"mmmmmm\"",
                "\"nnnnnn\"",
                "\"oooooo\"",
                "\"pppppp\"",
                "\"qqqqqq\"",
                "\"rrrrrr\"",
                "\"ssssss\"",
                "\"tttttt\"",
                "\"uuuuuu\"",
                "\"vvvvvv\"",
                "\"wwwwww\"",
                "\"xxxxxx\"",
                "\"yyyyyy\"",
                "\"zzzzzz\""
            ],
            "outputs": [
                "\"eert \"",
                "\"aaaccc \"",
                "\"bbAa \"",
                "\"llllldeohrw \"",
                "\"eeefffdddbbbccc \"",
                "\"edcba\"",
                "\"aaaaa\"",
                "\"bbbbb\"",
                "\"ccccc\"",
                "\"ddddd\"",
                "\"eeeee\"",
                "\"ffffff\"",
                "\"gggggg\"",
                "\"hhhhhh\"",
                "\"iiiiii\"",
                "\"jjjjjj\"",
                "\"kkkkkk\"",
                "\"llllll\"",
                "\"mmmmmm\"",
                "\"nnnnnn\"",
                "\"oooooo\"",
                "\"pppppp\"",
                "\"qqqqqq\"",
                "\"rrrrrr\"",
                "\"ssssss\"",
                "\"tttttt\"",
                "\"uuuuuu\"",
                "\"vvvvvv\"",
                "\"wwwwww\"",
                "\"xxxxxx\"",
                "\"yyyyyy\"",
                "\"zzzzzz\""
            ]
        },
        "sample_code": {
            "c++": "#include <unordered_map>\n#include <vector>\n#include <algorithm>\n\nstd::string sortByFrequency(std::string s) {\n    std::unordered_map<char, int> freq;\n    std::vector<char> chars(s.begin(), s.end());\n    \n    for (char c : s)\n        freq[c]++;\n        \n    std::sort(chars.begin(), chars.end(), \n              [&](char a, char b) { return freq[a] > freq[b]; });\n              \n    return std::string(chars.begin(), chars.end());\n}\n",
            "java": "import java.util.*;\n\npublic String sortByFrequency(String s) {\n    Map<Character, Integer> freq = new HashMap<>();\n    Character[] chars = new Character[m.length()];\n    \n    for (int i = 0; i < m.length(); i++) {\n        chars[i] = m.charAt(i);\n        freq.put(chars[i], freq.getOrDefault(chars[i], 0) + 1);\n    }\n    \n    Arrays.sort(chars, (a, b) -> freq.get(b).compareTo(freq.get(a)));\n    \n    StringBuilder sb = new StringBuilder();\n    for (Character c : chars) {\n        sb.append(c);\n    }\n    return sb.toString();\n}\n",
            "python": "from collections import Counter\n\ndef sort_by_frequency(s):\n    freq = Counter(s)\n    chars = list(s)\n    chars.sort(key=lambda c: freq[c], reverse=True)\n    return ''.join(chars)\n",
            "javascript": "function sortByFrequency(s) {\n    const freq = {};\n    const chars = [...s];\n    \n    for (const c of s)\n        freq[c] = (freq[c] || 0) + 1;\n        \n    chars.sort((a, b) => freq[b] - freq[a]);\n    \n    return chars.join('');\n}\n",
            "explanation": "1. Create a frequency map `freq` to store the frequency of each character in the input string.\n2. Create an array or list `chars` containing all characters of the input string.\n3. Loop through the input string and increment the frequency count for each character in the frequency map.\n4. Sort the `chars` array or list based on the frequency of each character in the frequency map in descending order (higher frequency first).\n5. Combine the sorted `chars` array or list into a string and return the result."
        },
        "structure": {
            "c++": "#include <unordered_map>\n#include <vector>\n#include <algorithm>\n\nstd::string sortByFrequency(std::string s)  {\n    // Your code here\n}\n",
            "java": "import java.util.*;\n\npublic String sortByFrequency(String s)  {\n    // Your code here\n}\n",
            "python": "from collections import Counter\n    # Your code here\n\n",
            "javascript": "function sortByFrequency(s)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <unordered_map>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::string s = $args;\n    std::string result = sortByFrequency(s);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    s =$args\n    result = sort_by_frequency(s)\n    print(result)",
            "java": "",
            "javascript": ""
        },
        "Qid": "451"
    },
    {
        "_id": {
            "$oid": "66299377baf481a372cdfe27"
        },
        "title": "Minimum Number of Arrows to Burst Balloons",
        "description": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array `points` where `points[i] = [xstart, xend]` denotes a balloon whose **horizontal diameter** stretches between `xstart` and `xend`. You do not know the exact y-coordinates of the balloons.\n\nArrows can be shot up **directly vertically** (in the positive y-direction) from different points along the x-axis. A balloon with `xstart` and `xend` is **burst** by an arrow shot at `x` if `xstart <= x <= xend`. There is **no limit** to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\n\nGiven the array `points`, return the **minimum** number of arrows that must be shot to burst all balloons.",
        "example": "Example:\n\nInput: points = [[10,16],[2,8],[1,6],[7,12]]\nOutput: 2\nExplanation: The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 6, bursting the balloons [[2,8]] and [[1,6]].\n- Shoot an arrow at x = 11, bursting the balloons [[10,16]] and [[7,12]].",
        "level": "Medium",
        "tags": [
            "array",
            "sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        10,
                        16
                    ],
                    [
                        2,
                        8
                    ],
                    [
                        1,
                        6
                    ],
                    [
                        7,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ]
                ],
                [
                    [
                        1,
                        5
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        3,
                        6
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        10
                    ],
                    [
                        2,
                        9
                    ],
                    [
                        3,
                        8
                    ],
                    [
                        4,
                        7
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        2,
                        3
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        6,
                        7
                    ],
                    [
                        7,
                        8
                    ],
                    [
                        8,
                        9
                    ],
                    [
                        9,
                        10
                    ],
                    [
                        10,
                        11
                    ],
                    [
                        11,
                        12
                    ],
                    [
                        12,
                        13
                    ],
                    [
                        13,
                        14
                    ],
                    [
                        14,
                        15
                    ],
                    [
                        15,
                        16
                    ],
                    [
                        16,
                        17
                    ],
                    [
                        17,
                        18
                    ],
                    [
                        18,
                        19
                    ],
                    [
                        19,
                        20
                    ]
                ]
            ],
            "outputs": [
                2,
                4,
                2,
                2,
                1,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <algorithm>\n\nint findMinArrowShots(std::vector<std::vector<int>>& points) {\n    if (points.empty()) return 0;\n    std::sort(points.begin(), points.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[1] < b[1];\n    });\n\n    int arrows = 1;\n    int end = points[0][1];\n\n    for (int i = 1; i < points.size(); ++i) {\n        if (points[i][0] > end) {\n            arrows++;\n            end = points[i][1];\n        }\n    }\n\n    return arrows;\n}\n",
            "java": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic int findMinArrowShots(int[][] points) {\n    if (points.length == 0) return 0;\n    Arrays.sort(points, Comparator.comparingInt(a -> a[1]));\n\n    int arrows = 1;\n    int end = points[0][1];\n\n    for (int i = 1; i < points.length; i++) {\n        if (points[i][0] > end) {\n            arrows++;\n            end = points[i][1];\n        }\n    }\n\n    return arrows;\n}\n",
            "python": "def findMinArrowShots(points):\n    if not points:\n        return 0\n    points.sort(key=lambda x: x[1])\n\n    arrows = 1\n    end = points[0][1]\n\n    for i in range(1, len(points)):\n        if points[i][0] > end:\n            arrows += 1\n            end = points[i][1]\n\n    return arrows\n",
            "javascript": "function findMinArrowShots(points) {\n    if (points.length === 0) return 0;\n    points.sort((a, b) => a[1] - b[1]);\n\n    let arrows = 1;\n    let end = points[0][1];\n\n    for (let i = 1; i < points.length; i++) {\n        if (points[i][0] > end) {\n            arrows++;\n            end = points[i][1];\n        }\n    }\n\n    return arrows;\n}\n",
            "explanation": "The algorithm sorts the given points by the end value of their ranges. Then, it initializes a variable `arrows` to 1 (to count the first arrow) and `end` to the end value of the first point (to keep track of the last point reached by arrows).\n\nThen, it iterates through the array, starting from the second point to the end. For each point, it checks whether the start value is greater than the current `end` value. If it is, that means this point is not covered by the previous arrows, so it increments the `arrows` counter and updates `end` to the end value of the current point.\n\nFinally, it returns the value of `arrows` as the minimum number of arrows needed to burst all balloons. "
        },
        "structure": {
            "c++": "#include <vector>\n#include <algorithm>\n\nint findMinArrowShots(std::vector<std::vector<int>>& points)  {\n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic int findMinArrowShots(int[][] points)  {\n    // Your code here\n}\n",
            "python": "def findMinArrowShots(points):\n    # Your code here\n\n",
            "javascript": "function findMinArrowShots(points)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nint main() {\n    std::vector<std::vector<int>> points = $args;\n    int result = findMinArrowShots(points);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "python": "if __name__ == \"__main__\":\n    points = $args\n    result = findMinArrowShots(points)\n    print(result)",
            "java": "",
            "javascript": ""
        },
        "Qid": "452"
    },
    {
        "_id": {
            "$oid": "66299393baf481a372cdfe28"
        },
        "title": "Minimum Moves to Equal Array Elements",
        "description": "Given an integer array `nums` of size `n`, you need to find the minimum number of moves required to make all array elements equal. In one move, you can increment `n - 1` elements of the array by `1`.",
        "example": "Example:\n\nInput: nums = [1,2,3]\nOutput: 3\nExplanation: Only three moves are needed (remember each move increments two elements):\n[1,2,3] => [2,3,3] => [3,4,3] => [4,4,4]",
        "level": "Easy",
        "tags": [
            "array",
            "math"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3
                ],
                [
                    1,
                    1,
                    1
                ],
                [
                    5,
                    5,
                    5,
                    5
                ],
                [
                    2,
                    4,
                    6,
                    8
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    3,
                    5,
                    7,
                    9
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50
                ],
                [
                    100,
                    200,
                    300,
                    400,
                    500
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    2
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    -1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    -2
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    100
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1000
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    10000
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    100000
                ]
            ],
            "outputs": [
                3,
                0,
                0,
                12,
                0,
                20,
                120,
                1200,
                45,
                45,
                0,
                0,
                1,
                1,
                2,
                2,
                99,
                999,
                9999,
                99999
            ]
        },
        "sample_code": {
            "c++": "int minMoves(vector<int>& nums) {\n    int min_element = *min_element(nums.begin(), nums.end());\n    int moves = 0;\n    for (int num : nums) {\n        moves += (num - min_element);\n    }\n    return moves;\n}\n\n",
            "java": "public int minMoves(int[] nums) {\n    int min_element = nums[0];\n    for (int num : nums) {\n        min_element = Math.min(min_element, num);\n    }\n    int moves = 0;\n    for (int num : nums) {\n        moves += (num - min_element);\n    }\n    return moves;\n}\n\n",
            "python": "def min_moves(nums):\n    min_element = min(nums)\n    moves = sum(num - min_element for num in nums)\n    return moves\n\n",
            "javascript": "function minMoves(nums) {\n    let min_element = Math.min(...nums);\n    let moves = nums.reduce((acc, num) => acc + (num - min_element), 0);\n    return moves;\n}\n\n",
            "explanation": "The algorithm works as follows:\n\n1. Find the minimum element in nums.\n2. Calculate the number of moves required to make other elements equal to the minimum element by summing the difference between each element and the minimum element (n-1 up moves for each number).\n3. Return the calculated number of moves.\n\nThe algorithm has a time complexity of O(n) as it iterates through the array twice. The space complexity is also O(n) in the case of the Python solution (due to list comprehensions), otherwise O(1)."
        },
        "structure": {
            "c++": "int minMoves(vector<int>& nums)  {\n    // Your code here\n}\n\n",
            "java": "public int minMoves(int[] nums)  {\n    // Your code here\n}\n\n",
            "python": "def min_moves(nums):\n    # Your code here\n\n",
            "javascript": "function minMoves(nums)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> nums = $args;\n    int result = minMoves(nums);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int minMoves(int[] nums) {\n    int min_element = nums[0];\n    for (int num : nums) {\n        min_element = Math.min(min_element, num);\n    }\n    int moves = 0;\n    for (int num : nums) {\n        moves += (num - min_element);\n    }\n    return moves;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = min_moves(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = minMoves(nums);\n    console.log(result);\n}\n"
        },
        "Qid": "453"
    },
    {
        "_id": {
            "$oid": "66299459baf481a372cdfe29"
        },
        "title": "132 Pattern",
        "description": "Given an array of `n` integers `nums`, a **132 pattern** is a subsequence of three integers `nums[i]`, `nums[j]` and `nums[k]` such that `i < j < k` and `nums[i] < nums[k] < nums[j]`. Return `true` if there is a 132 pattern in `nums`, otherwise, return `false`.",
        "example": "Example:\n\nInput: nums = [1,2,3,4]\nOutput: false\nExplanation: There is no 132 pattern in the sequence.",
        "level": "Medium",
        "tags": [
            "array",
            "subsequence"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    3,
                    4
                ],
                [
                    3,
                    1,
                    4,
                    2
                ],
                [
                    -1,
                    3,
                    2,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    5,
                    2,
                    4,
                    3
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    10,
                    2,
                    9,
                    3,
                    8,
                    4,
                    7,
                    5,
                    6
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    20,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    20,
                    2,
                    19,
                    3,
                    18,
                    4,
                    17,
                    5,
                    16,
                    6,
                    15,
                    7,
                    14,
                    8,
                    13,
                    9,
                    12,
                    10,
                    11
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30
                ],
                [
                    30,
                    29,
                    28,
                    27,
                    26,
                    25,
                    24,
                    23,
                    22,
                    21,
                    20,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    30,
                    2,
                    29,
                    3,
                    28,
                    4,
                    27,
                    5,
                    26,
                    6,
                    25,
                    7,
                    24,
                    8,
                    23,
                    9,
                    22,
                    10,
                    21,
                    11,
                    20,
                    12,
                    19,
                    13,
                    18,
                    14,
                    17,
                    15,
                    16
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5
                ],
                [
                    -5,
                    -4,
                    -3,
                    -2,
                    -1
                ],
                [
                    -1,
                    -5,
                    -2,
                    -4,
                    -3
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    -6,
                    -7,
                    -8,
                    -9,
                    -10
                ],
                [
                    -10,
                    -9,
                    -8,
                    -7,
                    -6,
                    -5,
                    -4,
                    -3,
                    -2,
                    -1
                ],
                [
                    -1,
                    -10,
                    -2,
                    -9,
                    -3,
                    -8,
                    -4,
                    -7,
                    -5,
                    -6
                ]
            ],
            "outputs": [
                false,
                true,
                true,
                false,
                false,
                true,
                false,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                true,
                false,
                false,
                true,
                false,
                true
            ]
        },
        "sample_code": {
            "c++": "bool find132pattern(vector<int>& nums) {\n    int n = nums.size(), third = INT_MIN;\n    stack<int> st;\n    for (int i = n - 1; i >= 0; --i) {\n        if (nums[i] < third) return true;\n        while (!st.empty() && st.top() < nums[i]) {\n            third = st.top(); st.pop();\n        }\n        st.push(nums[i]);\n    }\n    return false;\n}\n",
            "java": "public boolean find132pattern(int[] nums) {\n    int n = nums.length;\n    int[] min = new int[n];\n    min[0] = nums[0];\n    for (int i = 1; i < n; ++i) {\n        min[i] = Math.min(min[i - 1], nums[i]);\n    }\n    Stack<Integer> stack = new Stack<>();\n    for (int j = n - 1; j >= 0; --j) {\n        if (nums[j] > min[j]) {\n            while (!stack.isEmpty() && stack.peek() <= min[j]) {\n                stack.pop();\n            }\n            if (!stack.isEmpty() && stack.peek() < nums[j]) {\n                return true;\n            }\n            stack.push(nums[j]);\n        }\n    }\n    return false;\n}\n",
            "python": "def find132pattern(nums):\n    third, stack = float('-inf'), []\n    for num in reversed(nums):\n        if num < third:\n            return True\n        while stack and stack[-1] < num:\n            third = stack.pop()\n        stack.append(num)\n    return False\n",
            "javascript": "function find132pattern(nums) {\n    const stack = [];\n    let third = Number.MIN_SAFE_INTEGER;\n    for (let i = nums.length - 1; i >= 0; --i) {\n        if (nums[i] < third) {\n            return true;\n        }\n        while (stack.length && stack[stack.length - 1] < nums[i]) {\n            third = stack.pop();\n        }\n        stack.push(nums[i]);\n    }\n    return false;\n}\n",
            "explanation": "To find the 132 pattern, we iterate through the array from the end to the beginning. We use a stack to keep track of potential third elements (nums[k]) in the 132 pattern. We also keep track of the maximum third element found so far. If we find a number that is smaller than the maximum third element, we know that a 132 pattern exists.\n\nIn the Java and Python implementations, we also create a separate array to store the minimum values found so far from the start of the array, which helps in identifying the first element (nums[i]) in the 132 pattern. This step can be skipped in C++ and JavaScript implementations by directly comparing the first element (nums[i]) with the maximum third element stored in the stack.\n\nDuring the iteration, we check if the current number is smaller than the maximum third element, which would mean a 132 pattern has been found. If not, we update the maximum third element and the stack as necessary to continue searching for the 132 pattern. Finally, we return whether the 132 pattern has been found."
        },
        "structure": {
            "c++": "bool find132pattern(vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "public boolean find132pattern(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def find132pattern(nums):\n    # Your code here\n\n",
            "javascript": "function find132pattern(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "bool find132pattern(vector<int>& nums) {\n    int n = nums.size(), third = INT_MIN;\n    stack<int> st;\n    for (int i = n - 1; i >= 0; --i) {\n        if (nums[i] < third) return true;\n        while (!st.empty() && st.top() < nums[i]) {\n            third = st.top(); st.pop();\n        }\n        st.push(nums[i]);\n    }\n    return false;\n}",
            "java": "public boolean find132pattern(int[] nums) {\n    int n = nums.length;\n    int[] min = new int[n];\n    min[0] = nums[0];\n    for (int i = 1; i < n; ++i) {\n        min[i] = Math.min(min[i - 1], nums[i]);\n    }\n    Stack<Integer> stack = new Stack<>();\n    for (int j = n - 1; j >= 0; --j) {\n        if (nums[j] > min[j]) {\n            while (!stack.isEmpty() && stack.peek() <= min[j]) {\n                stack.pop();\n            }\n            if (!stack.isEmpty() && stack.peek() < nums[j]) {\n                return true;\n            }\n            stack.push(nums[j]);\n        }\n    }\n    return false;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = find132pattern(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = find132pattern(nums);\n    console.log(result);\n}"
        },
        "Qid": "456"
    },
    {
        "_id": {
            "$oid": "662994b6baf481a372cdfe2a"
        },
        "title": "Circular Array Cycle",
        "description": "You are given a circular array of non-zero integers `nums`. Each `nums[i]` denotes the number of indices forward/backward you must move if you are located at index `i`. If `nums[i]` is positive, move `nums[i]` steps forward, and if `nums[i]` is negative, move `nums[i]` steps backward. Since the array is circular, moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element. A cycle in the array consists of a sequence of indices `seq` of length `k` where following the movement rules results in the repeating index sequence `seq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ...`. Every `nums[seq[j]]` is either all positive or all negative, and `k > 1`. Write a function that returns `true` if there is a cycle in `nums`, or `false` otherwise.",
        "example": "Example:\n\nInput: nums = [2,-1,1,2,2]\nOutput: true\nExplanation: The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward. We can see the cycle 0 --> 2 --> 3 --> 0 --> ..., and all of its nodes are white (jumping in the same direction).",
        "level": "Medium",
        "tags": [
            "Array",
            "Graph"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    -1,
                    1,
                    2,
                    2
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    6
                ],
                [
                    1,
                    -1,
                    5,
                    1,
                    4
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    -1,
                    -1,
                    -1,
                    -1,
                    -1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5
                ],
                [
                    1,
                    -2,
                    3,
                    -4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    -5
                ],
                [
                    1,
                    -2,
                    3,
                    4,
                    -5
                ],
                [
                    1,
                    2,
                    3,
                    -4,
                    -5
                ],
                [
                    1,
                    -2,
                    3,
                    -4,
                    -5
                ],
                [
                    1,
                    2,
                    -3,
                    4,
                    5
                ],
                [
                    1,
                    -2,
                    -3,
                    4,
                    5
                ],
                [
                    1,
                    2,
                    -3,
                    -4,
                    5
                ],
                [
                    1,
                    -2,
                    -3,
                    -4,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    -1,
                    -2,
                    -3,
                    -4,
                    -5,
                    -6,
                    -7,
                    -8,
                    -9,
                    -10
                ],
                [
                    1,
                    -1,
                    1,
                    -1,
                    1,
                    -1,
                    1,
                    -1,
                    1,
                    -1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "bool circularArrayLoop(vector<int>& nums) {\n    int N = nums.size();\n    for (int i = 0; i < N; i++) {\n        int slow = i, fast = i;\n        do {\n            slow = getNextIndex(slow, nums);\n            fast = getNextIndex(getNextIndex(fast, nums), nums);\n        } while (slow != fast && nums[slow] * nums[fast] > 0);\n\n        if (slow != fast) continue;\n        bool cycle = false;\n        int start = slow;\n        do {\n            cycle |= getNextIndex(start, nums) == start;\n            start = getNextIndex(start, nums);\n        } while (start != slow);\n        if (!cycle) return true;\n    }\n    return false;\n}\n\nint getNextIndex(int idx, vector<int>& nums) {\n    int N = nums.size();\n    return ((idx + nums[idx]) % N + N) % N;\n}\n\n",
            "java": "public boolean circularArrayLoop(int[] nums) {\n    int N = nums.length;\n    for (int i = 0; i < N; i++) {\n        int slow = i, fast = i;\n        do {\n            slow = getNextIndex(slow, nums);\n            fast = getNextIndex(getNextIndex(fast, nums), nums);\n        } while (slow != fast && nums[slow] * nums[fast] > 0);\n\n        if (slow != fast) continue;\n        boolean cycle = false;\n        int start = slow;\n        do {\n            cycle |= getNextIndex(start, nums) == start;\n            start = getNextIndex(start, nums);\n        } while (start != slow);\n        if (!cycle) return true;\n    }\n    return false;\n}\n\nint getNextIndex(int idx, int[] nums) {\n    int N = nums.length;\n    return ((idx + nums[idx]) % N + N) % N;\n}\n\n",
            "python": "def circularArrayLoop(nums: list[int]) -> bool:\n    N = len(nums)\n    for i in range(N):\n        slow, fast = i, i\n        while True:\n            slow = getNextIndex(slow, nums)\n            fast = getNextIndex(getNextIndex(fast, nums), nums)\n            if slow != fast and nums[slow] * nums[fast] > 0:\n                break\n            if slow == fast:\n                break\n        else:\n            continue\n        cycle = False\n        start = slow\n        while start != slow:\n            cycle |= getNextIndex(start, nums) == start\n            start = getNextIndex(start, nums)\n        if not cycle:\n            return True\n    return False\n\ndef getNextIndex(idx: int, nums: list[int]) -> int:\n    N = len(nums)\n    return (idx + nums[idx]) % N\n\n",
            "javascript": "function circularArrayLoop(nums) {\n  const N = nums.length;\n  for (let i = 0; i < N; i++) {\n    let slow = i, fast = i;\n    do {\n      slow = getNextIndex(slow, nums);\n      fast = getNextIndex(getNextIndex(fast, nums), nums);\n    } while (slow !== fast && nums[slow] * nums[fast] > 0);\n\n    if (slow !== fast) continue;\n    let cycle = false;\n    let start = slow;\n    do {\n      cycle |= getNextIndex(start, nums) === start;\n      start = getNextIndex(start, nums);\n    } while (start !== slow);\n    if (!cycle) return true;\n  }\n  return false;\n}\n\nfunction getNextIndex(idx, nums) {\n    const N = nums.length;\n    return ((idx + nums[idx]) % N + N) % N;\n}\n\n",
            "explanation": "The algorithm is designed to detect a cycle in a circular array. It uses a slow and fast pointer approach inspired by the \"Floyd's Tortoise and Hare\" algorithm. The slow pointer moves one step at a time and the fast pointer moves two steps at a time. If there is a cycle in the array, the slow and fast pointers will eventually meet at the same index.\n\nThe algorithm iterates through the entire array to detect any possible cycle with the given starting index. For each index, the slow and fast pointers are initialized, and the getNextIndex function is used to get the next index, considering the circular nature of the array. The loop continues to execute as long as the slow and fast pointers are different and the product of nums[slow] and nums[fast] is positive.\n\nIf the slow and fast pointers meet, there is a possibility of having a cycle. To verify this, the algorithm checks if there is a cycle by traversing from the start index, and if there is no cycle, it returns true. If no cycle is found, the algorithm continues to search the array for cycles.\n\nFinally, if there is no cycle in the whole array, it returns false."
        },
        "structure": {
            "c++": "bool circularArrayLoop(vector<int>& nums)  {\n    // Your code here\n}\n\n",
            "java": "public boolean circularArrayLoop(int[] nums)  {\n    // Your code here\n}\n\n",
            "python": "def circularArrayLoop(nums: List[int]) -> bool:\n    # Your code here\n\n",
            "javascript": "function circularArrayLoop(nums)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "bool circularArrayLoop(vector<int>& nums) {\n    int N = nums.size();\n    for (int i = 0; i < N; i++) {\n        int slow = i, fast = i;\n        do {\n            slow = getNextIndex(slow, nums);\n            fast = getNextIndex(getNextIndex(fast, nums), nums);\n        } while (slow != fast && nums[slow] * nums[fast] > 0);\n\n        if (slow != fast) continue;\n        bool cycle = false;\n        int start = slow;\n        do {\n            cycle |= getNextIndex(start, nums) == start;\n            start = getNextIndex(start, nums);\n        } while (start != slow);\n        if (!cycle) return true;\n    }\n    return false;\n}\n\nint getNextIndex(int idx, vector<int>& nums) {\n    int N = nums.size();\n    return ((idx + nums[idx]) % N + N) % N;\n}",
            "java": "public boolean circularArrayLoop(int[] nums) {\n    int N = nums.length;\n    for (int i = 0; i < N; i++) {\n        int slow = i, fast = i;\n        do {\n            slow = getNextIndex(slow, nums);\n            fast = getNextIndex(getNextIndex(fast, nums), nums);\n        } while (slow != fast && nums[slow] * nums[fast] > 0);\n\n        if (slow != fast) continue;\n        boolean cycle = false;\n        int start = slow;\n        do {\n            cycle |= getNextIndex(start, nums) == start;\n            start = getNextIndex(start, nums);\n        } while (start != slow);\n        if (!cycle) return true;\n    }\n    return false;\n}\n\nint getNextIndex(int idx, int[] nums) {\n    int N = nums.length;\n    return ((idx + nums[idx]) % N + N) % N;\n}",
            "python": "if __name__ == \"__main__\":\n    nums =$args\n    result = circularArrayLoop(nums)\n    print(result)",
            "javascript": "function main() {\n  const nums = $args;\n  const result = circularArrayLoop(nums);\n  console.log(result);\n}"
        },
        "Qid": "457"
    },
    {
        "_id": {
            "$oid": "66299544baf481a372cdfe2b"
        },
        "title": "Minimum Number of Pigs",
        "description": "There are `buckets` buckets of liquid, where **exactly one** of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have `minutesToTest` minutes to determine which bucket is poisonous.\n\nYou can feed the pigs according to these steps:\n\n1. Choose some live pigs to feed.\n2. For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs.\n3. Wait for `minutesToDie` minutes. You may **not** feed any other pigs during this time.\n4. After `minutesToDie` minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.\n5. Repeat this process until you run out of time.\n\nGiven `buckets`, `minutesToDie`, and `minutesToTest`, return the **minimum** number of pigs needed to figure out which bucket is poisonous within the allotted time.",
        "example": "Example:\n\nInput: buckets = 4, minutesToDie = 15, minutesToTest = 15\nOutput: 2\nExplanation: We can determine the poisonous bucket as follows:\nAt time 0, feed the first pig buckets 1 and 2, and feed the second pig buckets 2 and 3.\nAt time 15, there are 4 possible outcomes:\n- If only the first pig dies, then bucket 1 must be poisonous.\n- If only the second pig dies, then bucket 3 must be poisonous.\n- If both pigs die, then bucket 2 must be poisonous.\n- If neither pig dies, then bucket 4 must be poisonous.",
        "level": "Medium",
        "tags": [
            "math",
            "logic"
        ],
        "test_cases": {
            "inputs": [
                [
                    4,
                    15,
                    15
                ],
                [
                    4,
                    15,
                    30
                ],
                [
                    1,
                    1,
                    1
                ],
                [
                    10,
                    5,
                    10
                ],
                [
                    100,
                    10,
                    100
                ],
                [
                    1000,
                    100,
                    100
                ],
                [
                    5,
                    10,
                    10
                ],
                [
                    2,
                    5,
                    5
                ],
                [
                    3,
                    5,
                    10
                ],
                [
                    7,
                    7,
                    7
                ],
                [
                    20,
                    10,
                    20
                ],
                [
                    50,
                    5,
                    50
                ],
                [
                    100,
                    1,
                    100
                ],
                [
                    1000,
                    100,
                    1000
                ],
                [
                    10,
                    10,
                    10
                ],
                [
                    3,
                    1,
                    3
                ],
                [
                    5,
                    5,
                    5
                ],
                [
                    2,
                    2,
                    2
                ],
                [
                    1,
                    100,
                    100
                ],
                [
                    1000,
                    1000,
                    1000
                ]
            ],
            "outputs": [
                2,
                2,
                1,
                2,
                10,
                10,
                2,
                2,
                2,
                2,
                4,
                5,
                100,
                10,
                2,
                1,
                2,
                1,
                1,
                10
            ]
        },
        "sample_code": {
            "c++": "int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n    int pigs = 0;\n    while (pow((minutesToTest / minutesToDie) + 1, pigs) < buckets) {\n        pigs++;\n    }\n    return pigs;\n}\n\n",
            "java": "public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n    int pigs = 0;\n    while (Math.pow((minutesToTest / minutesToDie) + 1, pigs) < buckets) {\n        pigs++;\n    }\n    return pigs;\n}\n\n",
            "python": "def poor_pigs(buckets, minutes_to_die, minutes_to_test):\n    pigs = 0\n    while (minutes_to_test // minutes_to_die + 1) ** pigs < buckets:\n        pigs += 1\n    return pigs\n\n",
            "javascript": "function poorPigs(buckets, minutesToDie, minutesToTest) {\n    let pigs = 0;\n    while (Math.pow(Math.floor(minutesToTest / minutesToDie) + 1, pigs) < buckets) {\n        pigs++;\n    }\n    return pigs;\n}\n\n",
            "explanation": "The algorithm calculates the minimum number of pigs required to test all the buckets within the given time constraint. It is based on the fact that each pig can be used to test multiple buckets (in a binary search manner) within the time constraint, as it is repeatedly fed different buckets.\n\n1. Initialize the number of pigs to 0.\n2. Calculate the maximum number of tests each pig can make within the given time constraint (`minutesToTest / minutesToDie + 1`).\n3. Iterate and increment the number of pigs until the total number of buckets is less than the power of the number of tests each pig can make to the number of pigs.\n4. Return the minimum number of pigs required.\n\nThe algorithm leverages the multi-level testing capacity of the pigs within the given time frame to minimize the number of pigs needed. Each pig represents an additional level of testing capacity, reducing the total number of tests needed."
        },
        "structure": {
            "c++": "int poorPigs(int buckets, int minutesToDie, int minutesToTest)  {\n    // Your code here\n}\n\n",
            "java": "public int poorPigs(int buckets, int minutesToDie, int minutesToTest)  {\n    // Your code here\n}\n\n",
            "python": "def poor_pigs(buckets, minutes_to_die, minutes_to_test):\n    # Your code here\n\n",
            "javascript": "function poorPigs(buckets, minutesToDie, minutesToTest)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int buckets = $args;\n    int minutesToDie = $args;\n    int minutesToTest = $args;\n    int result = poorPigs(buckets, minutesToDie, minutesToTest);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int main(int buckets, int minutesToDie, int minutesToTest) {\n    int pigs = 0;\n    while (Math.pow((minutesToTest / minutesToDie) + 1, pigs) < buckets) {\n        pigs++;\n    }\n    return pigs;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    buckets = inputs[0]\n    minutes_to_die = inputs[1]\n    minutes_to_test = inputs[2]\n    result = poor_pigs(buckets, minutes_to_die, minutes_to_test)\n    print(result)",
            "javascript": "function main() {\n    const buckets = $args[0];\n    const minutesToDie = $args[1];\n    const minutesToTest = $args[2];\n    const result = poorPigs(buckets, minutesToDie, minutesToTest);\n    console.log(result);\n}"
        },
        "Qid": "458"
    },
    {
        "_id": {
            "$oid": "6629957dbaf481a372cdfe2c"
        },
        "title": "Hamming Distance",
        "description": "The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, write a function to return the Hamming distance between them.",
        "example": "Example:\n\nInput: x = 1, y = 4\nOutput: 2\nExplanation:\n1   (0 0 0 1)\n4   (0 1 0 0)\n       -->   -->\nThe above arrows point to positions where the corresponding bits are different.",
        "level": "Easy",
        "tags": [
            "bit manipulation",
            "math"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    4
                ],
                [
                    3,
                    1
                ],
                [
                    0,
                    0
                ],
                [
                    7,
                    7
                ],
                [
                    10,
                    5
                ],
                [
                    15,
                    0
                ],
                [
                    255,
                    0
                ],
                [
                    255,
                    255
                ],
                [
                    231,
                    231
                ],
                [
                    231,
                    0
                ],
                [
                    0,
                    231
                ],
                [
                    2147483647,
                    0
                ],
                [
                    0,
                    2147483647
                ],
                [
                    2147483647,
                    2147483647
                ],
                [
                    2147483647,
                    1
                ],
                [
                    1,
                    2147483647
                ]
            ],
            "outputs": [
                2,
                1,
                0,
                0,
                4,
                4,
                8,
                0,
                0,
                8,
                8,
                31,
                31,
                0,
                31,
                31
            ]
        },
        "sample_code": {
            "c++": "int hammingDistance(int x, int y) {\n    int dist = 0, xorResult = x ^ y;\n    while (xorResult) {\n        dist += xorResult & 1;\n        xorResult >>= 1;\n    }\n    return dist;\n}\n",
            "java": "public int hammingDistance(int x, int y) {\n    int dist = 0, xorResult = x ^ y;\n    while (xorResult != 0) {\n        dist += xorResult & 1;\n        xorResult >>= 1;\n    }\n    return dist;\n}\n",
            "python": "def hammingDistance(x: int, y: int) -> int:\n    xorResult = x ^ y\n    dist = 0\n    while xorResult:\n        dist += xorResult & 1\n        xorResult >>= 1\n    return dist\n",
            "javascript": "function hammingDistance(x, y) {\n    let dist = 0;\n    let xorResult = x ^ y;\n    while (xorResult != 0) {\n        dist += xorResult & 1;\n        xorResult >>= 1;\n    }\n    return dist;\n}\n",
            "explanation": "We can start by taking the XOR of `x` and `y`. A XOR B value will have a bit set only if both A and B bits are different at that position. We then iterate through the bits of the XOR result, counting the number of set bits, which should give us the Hamming distance required.\n\n1. Calculate `xorResult` by XORing `x` and `y`.\n2. Initialize `dist` to 0.\n3. While `xorResult` is not 0, do the following:\n   a. Add the least significant bit of `xorResult` to `dist`.\n   b. Right shift `xorResult` by 1.\n4. Return `dist`.\n\nThis algorithm performs bitwise operations and loops through the bits of `xorResult`, which has a maximum of 31 bits due to the constraint `0 <= x, y <= 2^31 - 1`. Thus, the time complexity is O(31) = O(1)."
        },
        "structure": {
            "c++": "int hammingDistance(int x, int y)  {\n    // Your code here\n}\n",
            "java": "public int hammingDistance(int x, int y)  {\n    // Your code here\n}\n",
            "python": "def hammingDistance(x: int, y: int) -> int:\n    # Your code here\n\n",
            "javascript": "function hammingDistance(x, y)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int x = $args;\n    int y = $args;\n    int result = hammingDistance(x, y);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int hammingDistance(int x, int y) {\n    int dist = 0, xorResult = x ^ y;\n    while (xorResult != 0) {\n        dist += xorResult & 1;\n        xorResult >>= 1;\n    }\n    return dist;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    x = inputs[0]\n    y = inputs[1]\n    result = hammingDistance(x, y)\n    print(result)",
            "javascript": "function main() {\n    const x = $args[0];\n    const y = $args[1];\n    const result = hammingDistance(x, y);\n    console.log(result);\n}"
        },
        "Qid": "461"
    },
    {
        "_id": {
            "$oid": "66299623baf481a372cdfe2d"
        },
        "title": "Island Perimeter",
        "description": "You are given a grid representing a map where 1 represents land and 0 represents water. The grid is completely surrounded by water, and there is exactly one island. Determine the perimeter of the island.",
        "example": "Example:\n\nInput: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\nOutput: 16\nExplanation: The perimeter is the 16 yellow stripes in the image above.",
        "level": "Easy",
        "tags": [
            "array",
            "grid",
            "perimeter"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        0,
                        1,
                        0,
                        0
                    ],
                    [
                        1,
                        1,
                        1,
                        0
                    ],
                    [
                        0,
                        1,
                        0,
                        0
                    ],
                    [
                        1,
                        1,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1
                    ]
                ],
                [
                    [
                        1,
                        0
                    ]
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1
                    ]
                ],
                [
                    [
                        0,
                        0,
                        0,
                        0
                    ]
                ],
                [
                    [
                        1,
                        0,
                        1,
                        0
                    ]
                ],
                [
                    [
                        1,
                        1,
                        0,
                        0
                    ],
                    [
                        1,
                        0,
                        0,
                        0
                    ],
                    [
                        0,
                        0,
                        0,
                        1
                    ],
                    [
                        0,
                        0,
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ]
                ],
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        1,
                        0,
                        0,
                        0,
                        0,
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        1,
                        0,
                        1,
                        1,
                        0,
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        1,
                        0,
                        1,
                        1,
                        0,
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        1,
                        0,
                        0,
                        0,
                        0,
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1
                    ]
                ]
            ],
            "outputs": [
                16,
                4,
                4,
                16,
                0,
                8,
                24,
                40,
                84
            ]
        },
        "sample_code": {
            "c++": "int islandPerimeter(vector<vector<int>>& grid) {\n    int perimeter = 0;\n    for (int row = 0; row < grid.size(); row++) {\n        for (int col = 0; col < grid[row].size(); col++) {\n            if (grid[row][col] == 1) {\n                perimeter += 4;\n                if (row > 0 && grid[row - 1][col] == 1) perimeter -= 2;\n                if (col > 0 && grid[row][col - 1] == 1) perimeter -= 2;\n            }\n        }\n    }\n    return perimeter;\n}\n",
            "java": "public int islandPerimeter(int[][] grid) {\n    int perimeter = 0;\n    for (int row = 0; row < grid.length; row++) {\n        for (int col = 0; col < grid[row].length; col++) {\n            if (grid[row][col] == 1) {\n                perimeter += 4;\n                if (row > 0 && grid[row - 1][col] == 1) perimeter -= 2;\n                if (col > 0 && grid[row][col - 1] == 1) perimeter -= 2;\n            }\n        }\n    }\n    return perimeter;\n}\n",
            "python": "def islandPerimeter(grid):\n    perimeter = 0\n    for row in range(len(grid)):\n        for col in range(len(grid[row])):\n            if grid[row][col] == 1:\n                perimeter += 4\n                if row > 0 and grid[row - 1][col] == 1:\n                    perimeter -= 2\n                if col > 0 and grid[row][col - 1] == 1:\n                    perimeter -= 2\n    return perimeter\n",
            "javascript": "function islandPerimeter(grid) {\n    let perimeter = 0;\n    for (let row = 0; row < grid.length; row++) {\n        for (let col = 0; col < grid[row].length; col++) {\n            if (grid[row][col] === 1) {\n                perimeter += 4;\n                if (row > 0 && grid[row - 1][col] === 1) perimeter -= 2;\n                if (col > 0 && grid[row][col - 1] === 1) perimeter -= 2;\n            }\n        }\n    }\n    return perimeter;\n}\n",
            "explanation": "The algorithm iterates through each cell in the grid. If a cell contains land, increment the perimeter count by 4 (each side of the square). If there is land in the adjacent cell to the left or above, decrement the perimeter count by 2 for each adjacent land cell as they share a common side. This way, we can calculate the total perimeter of the island without any extra data structures or recursion."
        },
        "structure": {
            "c++": "int islandPerimeter(vector<vector<int>>& grid)  {\n    // Your code here\n}\n",
            "java": "public int islandPerimeter(int[][] grid)  {\n    // Your code here\n}\n",
            "python": "def islandPerimeter(grid):\n    # Your code here\n\n",
            "javascript": "function islandPerimeter(grid)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<vector<int>> grid = $args;\n    int result = islandPerimeter(grid);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int islandPerimeter(int[][] grid) {\n    int perimeter = 0;\n    for (int row = 0; row < grid.length; row++) {\n        for (int col = 0; col < grid[row].length; col++) {\n            if (grid[row][col] == 1) {\n                perimeter += 4;\n                if (row > 0 && grid[row - 1][col] == 1) perimeter -= 2;\n                if (col > 0 && grid[row][col - 1] == 1) perimeter -= 2;\n            }\n        }\n    }\n    return perimeter;\n}",
            "python": "if __name__ == \"__main__\":\n    grid = $args\n    result = islandPerimeter(grid)\n    print(result)",
            "javascript": "function islandPerimeter(grid) {\n    let perimeter = 0;\n    for (let row = 0; row < grid.length; row++) {\n        for (let col = 0; col < grid[row].length; col++) {\n            if (grid[row][col] === 1) {\n                perimeter += 4;\n                if (row > 0 && grid[row - 1][col] === 1) perimeter -= 2;\n                if (col > 0 && grid[row][col - 1] === 1) perimeter -= 2;\n            }\n        }\n    }\n    return perimeter;\n}"
        },
        "Qid": "463"
    },
    {
        "_id": {
            "$oid": "6629966dbaf481a372cdfe2e"
        },
        "title": "Winning the Game",
        "description": "In the '100 game', two players take turns adding any integer from 1 to 10 to a running total. The player who first causes the running total to reach or exceed 100 wins. Now, let's change the game so that players cannot reuse integers. For example, two players take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total greater than or equal to 100. Given two integers maxChoosableInteger and desiredTotal, determine if the first player to move can force a win. Return true if the first player can force a win, otherwise return false. Assume both players play optimally.",
        "example": "Example:\n\nInput: maxChoosableInteger = 10, desiredTotal = 11\nOutput: false\nExplanation: No matter which integer the first player chooses, they will lose. The second player can always choose the remaining integers to reach or exceed the desired total.\n\nInput: maxChoosableInteger = 10, desiredTotal = 0\nOutput: true\n\nInput: maxChoosableInteger = 10, desiredTotal = 1\nOutput: true",
        "level": "Medium",
        "tags": [
            "game theory",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    10,
                    11
                ],
                [
                    10,
                    0
                ],
                [
                    10,
                    1
                ],
                [
                    5,
                    10
                ],
                [
                    15,
                    100
                ],
                [
                    20,
                    200
                ],
                [
                    20,
                    300
                ],
                [
                    1,
                    1
                ],
                [
                    2,
                    3
                ],
                [
                    3,
                    5
                ],
                [
                    4,
                    7
                ],
                [
                    5,
                    9
                ],
                [
                    6,
                    11
                ],
                [
                    7,
                    13
                ],
                [
                    8,
                    15
                ],
                [
                    9,
                    17
                ],
                [
                    10,
                    19
                ],
                [
                    15,
                    25
                ],
                [
                    20,
                    30
                ],
                [
                    20,
                    40
                ]
            ],
            "outputs": [
                false,
                true,
                true,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
            ]
        },
        "sample_code": {
            "c++": "#include <unordered_map>\n\nbool canWin(int maxChoosableInteger, int desiredTotal, int state, std::unordered_map<int, bool>& memo) {\n    if(desiredTotal <= 0) {\n        return false;\n    }\n    if(memo.count(state) > 0) {\n        return memo[state];\n    }\n    for(int i = 1; i <= maxChoosableInteger; i++) {\n        int bitCheck = 1 << i;\n        if((state & bitCheck) == 0) {\n            if(!canWin(maxChoosableInteger, desiredTotal - i, state | bitCheck, memo)) {\n                memo[state] = true;\n                return true;\n            }\n        }\n    }\n    memo[state] = false;\n    return false;\n}\n\nbool canIWin(int maxChoosableInteger, int desiredTotal) {\n    if (maxChoosableInteger >= desiredTotal) return true;\n    if ((maxChoosableInteger * (maxChoosableInteger + 1)) / 2 < desiredTotal) return false;\n\n    std::unordered_map<int, bool> memo;\n    int state = 0;\n    return canWin(maxChoosableInteger, desiredTotal, state, memo);\n}\n\n",
            "java": "import java.util.HashMap;\n\npublic class Solution {\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        if (maxChoosableInteger >= desiredTotal) return true;\n        if ((maxChoosableInteger * (maxChoosableInteger + 1)) / 2 < desiredTotal) return false;\n        \n        HashMap<Integer, Boolean> memo = new HashMap<>();\n        int state = 0;\n        return canWin(maxChoosableInteger, desiredTotal, state, memo);\n    }\n    \n    private boolean canWin(int maxChoosableInteger, int desiredTotal, int state, HashMap<Integer, Boolean> memo) {\n        if (desiredTotal <= 0) return false;\n        if (memo.containsKey(state)) return memo.get(state);\n        \n        for (int i = 1; i <= maxChoosableInteger; i++) {\n            int bitCheck = 1 << i;\n            if ((state & bitCheck) == 0) {\n                if (!canWin(maxChoosableInteger, desiredTotal - i, state | bitCheck, memo)) {\n                    memo.put(state, true);\n                    return true;\n                }\n            }\n        }\n        \n        memo.put(state, false);\n        return false;\n    }\n}\n\n",
            "python": "def canIWin(maxChoosableInteger, desiredTotal):\n    if maxChoosableInteger >= desiredTotal: return True\n    if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal: return False\n\n    memo = {}\n        \n    def canWin(state):\n        if state in memo:\n            return memo[state]\n        for i in range(1, maxChoosableInteger + 1):\n            bitCheck = 1 << i\n            if (state & bitCheck) == 0:\n                if not canWin(state | bitCheck):\n                    memo[state] = True\n                    return True\n    \n        memo[state] = False\n        return False\n\n    return canWin(0)\n\n",
            "javascript": "var canIWin = function(maxChoosableInteger, desiredTotal) {\n    if (maxChoosableInteger >= desiredTotal) return true;\n    if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) return false;\n\n    const memo = new Map();\n\n    function canWin(state) {\n        if (memo.has(state)) return memo.get(state);\n\n        for (let i = 1; i <= maxChoosableInteger; i++) {\n            let bitCheck = 1 << i;\n            if ((state & bitCheck) === 0) {\n                if (!canWin(state | bitCheck)) {\n                    memo.set(state, true);\n                    return true;\n                }\n            }\n        }\n\n        memo.set(state, false);\n        return false;\n    }\n\n    return canWin(0);\n}\n\n",
            "explanation": "We use a state, represented by an integer where each bit indicates if a number has been taken or not, and store the states in a memoization table. With each function call, we try to take each number from 1 to maxChoosableInteger if it hasn't been taken before, and update the state accordingly. If no moves can be made which forces a win, return false. If the desired total is equal to or less than zero, then the player has lost, and we return false. \n\nBoth players play optimally, so we can recursively call the function for each possible number and check if it doesn't result in a win for the other player. If we find such a scenario, then the first player can force a win. At the end, we return the final result from the memoization table."
        },
        "structure": {
            "c++": "#include <unordered_map>\n\nbool canWin(int maxChoosableInteger, int desiredTotal, int state, std::unordered_map<int, bool>& memo)  {\n    // Your code here\n}\n\n",
            "java": "i {mport java.util.HashMap;\n\npublic class Solution \n    // Your code here\n}\n\n",
            "python": "def canIWin(maxChoosableInteger, desiredTotal):\n    # Your code here\n\n",
            "javascript": "var canIWin = function(maxChoosableInteger, desiredTotal)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <unordered_map>\n#include <iostream>\n\nbool canWin(int maxChoosableInteger, int desiredTotal, int state, std::unordered_map<int, bool>& memo) {\n    if(desiredTotal <= 0) {\n        return false;\n    }\n    if(memo.count(state) > 0) {\n        return memo[state];\n    }\n    for(int i = 1; i <= maxChoosableInteger; i++) {\n        int bitCheck = 1 << i;\n        if((state & bitCheck) == 0) {\n            if(!canWin(maxChoosableInteger, desiredTotal - i, state | bitCheck, memo)) {\n                memo[state] = true;\n                return true;\n            }\n        }\n    }\n    memo[state] = false;\n    return false;\n}\n\nbool canIWin(int maxChoosableInteger, int desiredTotal) {\n    if (maxChoosableInteger >= desiredTotal) return true;\n    if ((maxChoosableInteger * (maxChoosableInteger + 1)) / 2 < desiredTotal) return false;\n\n    std::unordered_map<int, bool> memo;\n    int state = 0;\n    return canWin(maxChoosableInteger, desiredTotal, state, memo);\n}\n\nint main() {\n    int maxChoosableInteger = $args;\n    int desiredTotal = $args;\n    bool result = canIWin(maxChoosableInteger, desiredTotal);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "java": "public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        if (maxChoosableInteger >= desiredTotal) return true;\n        if ((maxChoosableInteger * (maxChoosableInteger + 1)) / 2 < desiredTotal) return false;\n        \n        HashMap<Integer, Boolean> memo = new HashMap<>();\n        int state = 0;\n        return canWin(maxChoosableInteger, desiredTotal, state, memo);\n    }\n    \n    private boolean canWin(int maxChoosableInteger, int desiredTotal, int state, HashMap<Integer, Boolean> memo) {\n        if (desiredTotal <= 0) return false;\n        if (memo.containsKey(state)) return memo.get(state);\n        \n        for (int i = 1; i <= maxChoosableInteger; i++) {\n            int bitCheck = 1 << i;\n            if ((state & bitCheck) == 0) {\n                if (!canWin(maxChoosableInteger, desiredTotal - i, state | bitCheck, memo)) {\n                    memo.put(state, true);\n                    return true;\n                }\n            }\n        }\n        \n        memo.put(state, false);\n        return false;\n    }",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    maxChoosableInteger = inputs[0]\n    desiredTotal = inputs[1]\n    result = canIWin(maxChoosableInteger, desiredTotal)\n    print(result)",
            "javascript": "function main() {\n    const maxChoosableInteger = $args[0];\n    const desiredTotal = $args[1];\n    const result = canIWin(maxChoosableInteger, desiredTotal);\n    console.log(result);\n}"
        },
        "Qid": "464"
    },
    {
        "_id": {
            "$oid": "66299698baf481a372cdfe2f"
        },
        "title": "Minimum Number of Transactions",
        "description": "You are given an array of transactions `transactions` where `transactions[i] = [fromi, toi, amounti]` indicates that the person with `ID = fromi` gave `amounti $` to the person with `ID = toi`. Return the minimum number of transactions required to settle the debt.",
        "example": "Example 1:\n\nInput: transactions = [[0,1,10],[2,0,5]]\nOutput: 2\nExplanation: Person #0 gave person #1 $10. Person #2 gave person #0 $5. Two transactions are needed. One way to settle the debt is person #1 pays person #0 and #2 $5 each.\n\nExample 2:\n\nInput: transactions = [[0,1,10],[1,0,1],[1,2,5],[2,0,5]]\nOutput: 1\nExplanation: Person #0 gave person #1 $10. Person #1 gave person #0 $1. Person #1 gave person #2 $5. Person #2 gave person #0 $5. Therefore, person #1 only need to give person #0 $4, and all debt is settled.",
        "level": "Medium",
        "tags": [
            "array",
            "graph",
            "greedy"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        2,
                        0,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ],
                    [
                        0,
                        2,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ],
                    [
                        0,
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ],
                    [
                        0,
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        2,
                        3,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ],
                    [
                        0,
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        2,
                        3,
                        5
                    ],
                    [
                        3,
                        4,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ],
                    [
                        0,
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        2,
                        3,
                        5
                    ],
                    [
                        3,
                        4,
                        5
                    ],
                    [
                        4,
                        5,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ],
                    [
                        0,
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        2,
                        3,
                        5
                    ],
                    [
                        3,
                        4,
                        5
                    ],
                    [
                        4,
                        5,
                        5
                    ],
                    [
                        5,
                        6,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ],
                    [
                        0,
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        2,
                        3,
                        5
                    ],
                    [
                        3,
                        4,
                        5
                    ],
                    [
                        4,
                        5,
                        5
                    ],
                    [
                        5,
                        6,
                        5
                    ],
                    [
                        6,
                        7,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ],
                    [
                        0,
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        2,
                        3,
                        5
                    ],
                    [
                        3,
                        4,
                        5
                    ],
                    [
                        4,
                        5,
                        5
                    ],
                    [
                        5,
                        6,
                        5
                    ],
                    [
                        6,
                        7,
                        5
                    ],
                    [
                        7,
                        8,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ],
                    [
                        0,
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        2,
                        3,
                        5
                    ],
                    [
                        3,
                        4,
                        5
                    ],
                    [
                        4,
                        5,
                        5
                    ],
                    [
                        5,
                        6,
                        5
                    ],
                    [
                        6,
                        7,
                        5
                    ],
                    [
                        7,
                        8,
                        5
                    ],
                    [
                        8,
                        9,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ],
                    [
                        0,
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        2,
                        3,
                        5
                    ],
                    [
                        3,
                        4,
                        5
                    ],
                    [
                        4,
                        5,
                        5
                    ],
                    [
                        5,
                        6,
                        5
                    ],
                    [
                        6,
                        7,
                        5
                    ],
                    [
                        7,
                        8,
                        5
                    ],
                    [
                        8,
                        9,
                        5
                    ],
                    [
                        9,
                        10,
                        5
                    ]
                ],
                [
                    [
                        0,
                        1,
                        10
                    ],
                    [
                        1,
                        0,
                        5
                    ],
                    [
                        2,
                        0,
                        5
                    ],
                    [
                        3,
                        0,
                        5
                    ],
                    [
                        4,
                        0,
                        5
                    ],
                    [
                        5,
                        0,
                        5
                    ],
                    [
                        6,
                        0,
                        5
                    ],
                    [
                        7,
                        0,
                        5
                    ],
                    [
                        8,
                        0,
                        5
                    ],
                    [
                        9,
                        0,
                        5
                    ],
                    [
                        10,
                        0,
                        5
                    ],
                    [
                        11,
                        0,
                        5
                    ],
                    [
                        0,
                        2,
                        5
                    ],
                    [
                        1,
                        2,
                        5
                    ],
                    [
                        2,
                        3,
                        5
                    ],
                    [
                        3,
                        4,
                        5
                    ],
                    [
                        4,
                        5,
                        5
                    ],
                    [
                        5,
                        6,
                        5
                    ],
                    [
                        6,
                        7,
                        5
                    ],
                    [
                        7,
                        8,
                        5
                    ],
                    [
                        8,
                        9,
                        5
                    ],
                    [
                        9,
                        10,
                        5
                    ],
                    [
                        10,
                        11,
                        5
                    ]
                ]
            ],
            "outputs": [
                2,
                1,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <unordered_map>\n\nint minTransfers(std::vector<std::vector<int>>& transactions) {\n    std::unordered_map<int, int> balances;\n    for (const auto& transaction : transactions) {\n        balances[transaction[0]] -= transaction[2];\n        balances[transaction[1]] += transaction[2];\n    }\n\n    std_msgs::vector<int> debts;\n    for (const auto& balance : balances) {\n        if (balance.second != 0) {\n            debts.push_back(balance.second);\n        }\n    }\n    return dfs(debts, 0);\n}\n\nint dfs(std::vector<int>& debts, int start) {\n    while (start < debts.size() && debts[start] == 0) {\n        start++;\n    }\n    if (start == debts.size()) {\n        return 0;\n    }\n    int result = INT_MAX;\n    for (int i = start + 1; i < debts.size(); ++i) {\n        if ((debts[start] > 0) != (debts[i] > 0)) {\n            debts[i] += debts[start];\n            result = std::min(result, 1 + dfs(debts, start + 1));\n            debts[i] -= debts[start];\n        }\n    }\n    return result;\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic int minTransfers(int[][] transactions) {\n    Map<Integer, Integer> balances = new HashMap<>();\n    for (int[] transaction : transactions) {\n        balances.put(transaction[0], balances.getOrDefault(transaction[0], 0) - transaction[2]);\n        balances.put(transaction[1], balances.getOrDefault(transaction[1], 0) + transaction[2]);\n    }\n\n    List<Integer> debts = new ArrayList<>();\n    for (int balance : balances.values()) {\n        if (balance != 0) {\n            debts.add(balance);\n        }\n    }\n    return dfs(debts, 0);\n}\n\nprivate int dfs(List<Integer> debts, int start) {\n    while (start < debts.size() && debts.get(start) == 0) {\n        start++;\n    }\n    if (start == debts.size()) {\n        return 0;\n    }\n    int result = Integer.MAX_VALUE;\n    for (int i = start + 1; i < debts.size(); ++i) {\n        if ((debts.get(start) > 0) != (debts.get(i) > 0)) {\n            debts.set(i, debts.get(i) + debts.get(start));\n            result = Math.min(result, 1 + dfs(debts, start + 1));\n            debts.set(i, debts.get(i) - debts.get(start));\n        }\n    }\n    return result;\n}\n\n",
            "python": "from collections import defaultdict\n\ndef minTransfers(transactions):\n    balances = defaultdict(int)\n    for transaction in transactions:\n        balances[transaction[0]] -= transaction[2]\n        balances[transaction[1]] += transaction[2]\n\n    debts = [balance for balance in balances.values() if balance != 0]\n    return dfs(debts, 0)\n\ndef dfs(debts, start):\n    while start < len(debts) and debts[start] == 0:\n        start += 1\n    if start == len(debts):\n        return 0\n    result = float('inf')\n    for i in range(start + 1, len(debts)):\n        if (debts[start] > 0) != (debts[i] > 0):\n            debts[i] += debts[start]\n            result = min(result, 1 + dfs(debts, start + 1))\n            debts[i] -= debts[start]\n    return result\n\n",
            "javascript": "function minTransfers(transactions) {\n    const balances = new Map();\n    for (const transaction of transactions) {\n        balances.set(transaction[0], (balances.get(transaction[0]) || 0) - transaction[2]);\n        balances.set(transaction[1], (balances.get(transaction[1]) || 0) + transaction[2]);\n    }\n\n    const debts = [];\n    for (const balance of balances.values()) {\n        if (balance !== 0) {\n            debts.push(balance);\n        }\n    }\n    return dfs(debts, 0);\n}\n\nfunction dfs(debts, start) {\n    while (start < debts.length && debts[start] === 0) {\n        start++;\n    }\n    if (start === debts.length) {\n        return 0;\n    }\n    let result = Infinity;\n    for (let i = start + 1; i < debts.length; ++i) {\n        if ((debts[start] > 0) !== (debts[i] > 0)) {\n            debts[i] += debts[start];\n            result = Math.min(result, 1 + dfs(debts, start + 1));\n            debts[i] -= debts[start];\n        }\n    }\n    return result;\n}\n\n",
            "explanation": "The algorithm works by first iterating through the transactions and calculating the debt balance for each person. The debt balance maintains how much each person owes or is owed. Then, it stores the non-zero balance values in a separate list called `debts`.\n\nNext, it performs a depth-first search (DFS) to minimize the transaction counts. The DFS function iterates over each pair of debts, and if one member owes money and the other is owed money, it simulates settling the debt by adjusting the balance and calling the DFS function recursively with the updated balance. After this step, it reverts the changes to the balance and compares the minimum transactions found.\n\nThe algorithm iterates over all possible subsets of debts and returns the minimum number of transactions required to settle the debts."
        },
        "structure": {
            "c++": "#include <vector>\n#include <unordered_map>\n\nint minTransfers(std::vector<std::vector<int>>& transactions)  {\n    // Your code here\n}\n\n",
            "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic int minTransfers(int[][] transactions)  {\n    // Your code here\n}\n\n",
            "python": "from collections import defaultdict\n    # Your code here\n\n",
            "javascript": "function minTransfers(transactions)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <unordered_map>\n\nint main() {\n    std::vector<std::vector<int>> transactions = $args;\n    int result = minTransfers(transactions);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int minTransfers(int[][] transactions) {\n    Map<Integer, Integer> balances = new HashMap<>();\n    for (int[] transaction : transactions) {\n        balances.put(transaction[0], balances.getOrDefault(transaction[0], 0) - transaction[2]);\n        balances.put(transaction[1], balances.getOrDefault(transaction[1], 0) + transaction[2]);\n    }\n\n    List<Integer> debts = new ArrayList<>();\n    for (int balance : balances.values()) {\n        if (balance != 0) {\n            debts.add(balance);\n        }\n    }\n    return dfs(debts, 0);\n}\n\nprivate int dfs(List<Integer> debts, int start) {\n    while (start < debts.size() && debts.get(start) == 0) {\n        start++;\n    }\n    if (start == debts.size()) {\n        return 0;\n    }\n    int result = Integer.MAX_VALUE;\n    for (int i = start + 1; i < debts.size(); ++i) {\n        if ((debts.get(start) > 0) != (debts.get(i) > 0)) {\n            debts.set(i, debts.get(i) + debts.get(start));\n            result = Math.min(result, 1 + dfs(debts, start + 1));\n            debts.set(i, debts.get(i) - debts.get(start));\n        }\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    transactions = $args\n    result = minTransfers(transactions)\n    print(result)",
            "javascript": "function minTransfers(transactions) {\n    const balances = new Map();\n    for (const transaction of transactions) {\n        balances.set(transaction[0], (balances.get(transaction[0]) || 0) - transaction[2]);\n        balances.set(transaction[1], (balances.get(transaction[1]) || 0) + transaction[2]);\n    }\n\n    const debts = [];\n    for (const balance of balances.values()) {\n        if (balance !== 0) {\n            debts.push(balance);\n        }\n    }\n    return dfs(debts, 0);\n}\n\nfunction dfs(debts, start) {\n    while (start < debts.length && debts[start] === 0) {\n        start++;\n    }\n    if (start === debts.length) {\n        return 0;\n    }\n    let result = Infinity;\n    for (let i = start + 1; i < debts.length; ++i) {\n        if ((debts[start] > 0) !== (debts[i] > 0)) {\n            debts[i] += debts[start];\n            result = Math.min(result, 1 + dfs(debts, start + 1));\n            debts[i] -= debts[start];\n        }\n    }\n    return result;\n}"
        },
        "Qid": "465"
    },
    {
        "_id": {
            "$oid": "662996cabaf481a372cdfe30"
        },
        "title": "Maximum String Concatenation",
        "description": "Given two strings `s1` and `s2` and two integers `n1` and `n2`, we define `str = [s, n]` as the string `str` which consists of the string `s` concatenated `n` times. For example, `str == [\"abc \", 3] == \"abcabcabc \"`. We define that string `s1` can be obtained from string `s2` if we can remove some characters from `s2` such that it becomes `s1`. For example, `s1 = \"abc \"` can be obtained from `s2 = \"ab**dbe**c \"` based on our definition by removing the bolded characters. Return the maximum integer `m` such that `str = [str2, m]` can be obtained from `str1`.",
        "example": "Example:\n\nInput: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2\n\nExplanation: The string `str1` is \"acbacbacbacb\" and the string `str2` is \"abab\". We can obtain `str2` from `str1` by removing the characters 'c' and 'c' from `str1` twice.\n\nInput: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1\n\nExplanation: The string `str1` is \"acb\" and the string `str2` is \"acb\". We can obtain `str2` from `str1` without removing any characters.",
        "level": "Medium",
        "tags": [
            "string",
            "concatenation"
        ],
        "test_cases": {
            "inputs": [
                [
                    "acb",
                    4,
                    "ab",
                    2
                ],
                [
                    "acb",
                    1,
                    "acb",
                    1
                ],
                [
                    "abc",
                    3,
                    "ab",
                    2
                ],
                [
                    "abc",
                    1,
                    "abc",
                    1
                ],
                [
                    "abc",
                    2,
                    "abc",
                    2
                ],
                [
                    "abc",
                    2,
                    "ab",
                    1
                ],
                [
                    "abc",
                    1,
                    "ab",
                    2
                ],
                [
                    "abc",
                    0,
                    "ab",
                    2
                ],
                [
                    "abc",
                    2,
                    "ab",
                    0
                ],
                [
                    "",
                    0,
                    "",
                    0
                ],
                [
                    "a",
                    1,
                    "",
                    0
                ],
                [
                    "",
                    0,
                    "a",
                    1
                ],
                [
                    "a",
                    1,
                    "a",
                    1
                ],
                [
                    "a",
                    2,
                    "a",
                    1
                ],
                [
                    "a",
                    1,
                    "a",
                    2
                ],
                [
                    "a",
                    2,
                    "a",
                    2
                ],
                [
                    "a",
                    3,
                    "a",
                    2
                ],
                [
                    "a",
                    2,
                    "a",
                    3
                ],
                [
                    "a",
                    3,
                    "a",
                    3
                ]
            ],
            "outputs": [
                2,
                1,
                0,
                1,
                2,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                1,
                1,
                2,
                2,
                2,
                2,
                3
            ]
        },
        "sample_code": {
            "c++": "int getMaxRepetitions(string s1, int n1, string s2, int n2) {\n    int count1 = 0, count2 = 0, i = 0, j = 0;\n    while (count1 < n1) {\n        if (s1[i] == s2[j]) {\n            j++;\n            if (j == s2.size()) {\n                j = 0;\n                count2++;\n            }\n        }\n        i++;\n        if (i == s1.size()) {\n            i = 0;\n            count1++;\n        }\n    }\n    return count2 / n2;\n}\n\n",
            "java": "public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\n    int count1 = 0, count2 = 0, i = 0, j = 0;\n    while (count1 < n1) {\n        if (s1.charAt(i) == s2.charAt(j)) {\n            j++;\n            if (j == s2.length()) {\n                j = 0;\n                count2++;\n            }\n        }\n        i++;\n        if (i == s1.length()) {\n            i = 0;\n            count1++;\n        }\n    }\n    return count2 / n2;\n}\n\n",
            "python": "def getMaxRepetitions(s1: str, n1: int, s2: str, n2: int) -> int:\n    count1, count2, i, j = 0, 0, 0, 0\n    while count1 < n1:\n        if s1[i] == s2[j]:\n            j += 1\n            if j == len(s2):\n                j = 0\n                count2 += 1\n        i += 1\n        if i == len(s1):\n            i = 0\n            count1 += 1\n    return count2 // n2\n\n",
            "javascript": "function getMaxRepetitions(s1, n1, s2, n2) {\n    let count1 = 0, count2 = 0, i = 0, j = 0;\n    while (count1 < n1) {\n        if (s1.charAt(i) === s2.charAt(j)) {\n            j++;\n            if (j === s2.length) {\n                j = 0;\n                count2++;\n            }\n        }\n        i++;\n        if (i === s1.length) {\n            i = 0;\n            count1++;\n        }\n    }\n    return Math.floor(count2 / n2);\n}\n\n",
            "explanation": "1. Initialize counter variables for both strings (count1 and count2) as well as indices for both strings (i and j).\n2. Iterate through str1 while count1 is less than n1.\n3. Compare the characters at the current indices of s1 and s2. If they match, increment index j of s2.\n4. If j reaches the length of s2, reset j to 0 and increment count2.\n5. Increment index i of s1. If i reaches the length of s1, reset i to 0 and increment count1.\n6. Return the integer division of count2 by n2 as the maximum integer m."
        },
        "structure": {
            "c++": "int getMaxRepetitions(string s1, int n1, string s2, int n2)  {\n    // Your code here\n}\n\n",
            "java": "public int getMaxRepetitions(String s1, int n1, String s2, int n2)  {\n    // Your code here\n}\n\n",
            "python": "def getMaxRepetitions(s1: str, n1: int, s2: str, n2: int) -> int:\n    # Your code here\n\n",
            "javascript": "function getMaxRepetitions(s1, n1, s2, n2)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int getMaxRepetitions(string s1, int n1, string s2, int n2) {\n    int count1 = 0, count2 = 0, i = 0, j = 0;\n    while (count1 < n1) {\n        if (s1[i] == s2[j]) {\n            j++;\n            if (j == s2.size()) {\n                j = 0;\n                count2++;\n            }\n        }\n        i++;\n        if (i == s1.size()) {\n            i = 0;\n            count1++;\n        }\n    }\n    return count2 / n2;\n}\n\nint main() {\n    string s1 = $args;\n    int n1 = $args;\n    string s2 = $args;\n    int n2 = $args;\n    int result = getMaxRepetitions(s1, n1, s2, n2);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\n    int count1 = 0, count2 = 0, i = 0, j = 0;\n    while (count1 < n1) {\n        if (s1.charAt(i) == s2.charAt(j)) {\n            j++;\n            if (j == s2.length()) {\n                j = 0;\n                count2++;\n            }\n        }\n        i++;\n        if (i == s1.length()) {\n            i = 0;\n            count1++;\n        }\n    }\n    return count2 / n2;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    s1 = inputs[0]\n    n1 = inputs[1]\n    s2 = inputs[2]\n    n2 = inputs[3]\n    result = getMaxRepetitions(s1, n1, s2, n2)\n    print(result)",
            "javascript": "function getMaxRepetitions(s1, n1, s2, n2) {\n    const result = getMaxRepetitions(s1, n1, s2, n2);\n    console.log(result);\n}"
        },
        "Qid": "466"
    },
    {
        "_id": {
            "$oid": "66299784baf481a372cdfe31"
        },
        "title": "Validate IP Address",
        "description": "Given a string `queryIP`, determine if it is a valid IPv4 or IPv6 address. Return 'IPv4' if it is a valid IPv4 address, 'IPv6' if it is a valid IPv6 address, or 'Neither' if it is not a correct IP of any type.",
        "example": "Example 1:\n\nInput: queryIP = '172.16.254.1'\nOutput: 'IPv4'\nExplanation: This is a valid IPv4 address, so the output is 'IPv4'.\n\nExample 2:\n\nInput: queryIP = '2001:0db8:85a3:0:0:8A2E:0370:7334'\nOutput: 'IPv6'\nExplanation: This is a valid IPv6 address, so the output is 'IPv6'.\n\nExample 3:\n\nInput: queryIP = '256.256.256.256'\nOutput: 'Neither'\nExplanation: This is neither a valid IPv4 address nor a valid IPv6 address, so the output is 'Neither'.",
        "level": "Easy",
        "tags": [
            "string",
            "validation"
        ],
        "test_cases": {
            "inputs": [
                "'172.16.254.1'",
                "'2001:0db8:85a3:0:0:8A2E:0370:7334'",
                "'256.256.256.256'",
                "'192.168.1.1'",
                "'192.168.1.0'",
                "'192.168.01.1'",
                "'192.168.1.00'",
                "'192.168@1.1'",
                "'2001:0db8:85a3::8A2E:037j:7334'",
                "'02001:0db8:85a3:0000:0000:8a2e:0370:7334'",
                "'2001:0db8:85a3:0000:0000:8a2e:0370:7334'",
                "'2001:db8:85a3:0:0:8A2E:0370:7334'",
                "'2001:0db8:85a3:0000:0000:8a2e:0370:7334'",
                "'2001:db8:85a3:0:0:8A2E:0370:7334'",
                "'2001:0db8:85a3:0000:0000:8a2e:0370:7334'",
                "'2001:db8:85a3:0:0:8A2E:0370:7334'",
                "'2001:0db8:85a3:0000:0000:8a2e:0370:7334'",
                "'2001:db8:85a3:0:0:8A2E:0370:7334'",
                "'2001:0db8:85a3:0000:0000:8a2e:0370:7334'",
                "'2001:db8:85a3:0:0:8A2E:0370:7334'",
                "'2001:0db8:85a3:0000:0000:8a2e:0370:7334'",
                "'2001:db8:85a3:0:0:8A2E:0370:7334'"
            ],
            "outputs": [
                "'IPv4'",
                "'IPv6'",
                "'Neither'",
                "'IPv4'",
                "'IPv4'",
                "'Neither'",
                "'Neither'",
                "'Neither'",
                "'Neither'",
                "'Neither'",
                "'IPv6'",
                "'Neither'",
                "'IPv6'",
                "'Neither'",
                "'IPv6'",
                "'Neither'",
                "'IPv6'",
                "'Neither'",
                "'IPv6'",
                "'Neither'",
                "'IPv6'",
                "'Neither'"
            ]
        },
        "sample_code": {
            "c++": "#include <sstream>\n#include <string>\n#include <vector>\n\nbool isValidIPv4(const std::string& part);\nbool isValidIPv6(const std::string& part);\n\nstd::string validateIP(const std::string& queryIP) {\n    std::stringstream ss(queryIP);\n    std::string part;\n    int partsCount = 0;\n\n    if (queryIP.find(':') == std::string::npos) {\n        while (getline(ss, part, '.')) {\n            if (!isValidIPv4(part)) return \"Neither\";\n            partsCount++;\n        }\n        if (partsCount == 4) return \"IPv4\";\n    } else {\n        while (getline(ss, part, ':')) {\n            if (!isValidIPv6(part)) return \"Neither\";\n            partsCount++;\n        }\n        if (partsCount == 8) return \"IPv6\";\n    }\n\n    return \"Neither\";\n}\n\nbool isValidIPv4(const std::string& part) {\n    if (part.empty() || part.size() > 3) return false;\n    if (part.size() > 1 && part[0] == '0') return false;\n\n    int num = 0;\n    for (char ch : part) {\n        if (!isdigit(ch)) return false;\n        num = num * 10 + (ch - '0');\n    }\n\n    return num >= 0 && num <= 255;\n}\n\nbool isValidIPv6(const std::string& part) {\n    if (part.empty() || part.size() > 4) return false;\n\n    for (char ch : part) {\n        if (!isxdigit(ch)) return false;\n    }\n\n    return true;\n}\n",
            "java": "public String validateIP(String queryIP) {\n    String[] ipv4Parts = queryIP.split(\"\\\\.\", -1);\n    String[] ipv6Parts = queryIP.split(\":\", -1);\n\n    if (ipv4Parts.length == 4) {\n        if (isValidIPv4(ipv4Parts)) return \"IPv4\";\n    } else if (ipv6Parts.length == 8) {\n        if (isValidIPv6(ipv6Parts)) return \"IPv6\";\n    }\n\n    return \"Neither\";\n}\n\nprivate boolean isValidIPv4(String[] parts) {\n    for (String part : parts) {\n        if (part.length() == 0 || part.length() > 3 || (part.length() > 1 && part.charAt(0) == '0')) return false;\n\n        int num = 0;\n        for (char ch : part.toCharArray()) {\n            if (!Character.isDigit(ch)) return false;\n            num = num * 10 + (ch - '0');\n        }\n\n        if (num < 0 || num > 255) return false;\n    }\n\n    return true;\n}\n\nprivate boolean isValidIPv6(String[] parts) {\n    for (String part : parts) {\n        if (part.length() == 0 || part.length() > 4) return false;\n\n        for (char ch : part.toCharArray()) {\n            if (!Character.isDigit(ch) && !(ch >= 'a' && ch <= 'f') && !(ch >= 'A' && ch <= 'F')) return false;\n        }\n    }\n\n    return true;\n}\n",
            "python": "def validateIP(queryIP):\n    ipv4_parts = queryIP.split('.')\n    ipv6_parts = queryIP.split(':')\n\n    if len(ipv4_parts) == 4:\n        if is_valid_ipv4(ipv4_parts):\n            return \"IPv4\"\n    elif len(ipv6_parts) == 8:\n        if is_valid_ipv6(ipv6_parts):\n            return \"IPv6\"\n\n    return \"Neither\"\n\ndef is_valid_ipv4(parts):\n    for part in parts:\n        if not part or len(part) > 3 or (len(part) > 1 and part[0] == '0'):\n            return False\n\n        if not part.isdigit() or int(part) < 0 or int(part) > 255:\n            return False\n\n    return True\n\ndef is_valid_ipv6(parts):\n    for part in parts:\n        if not part or len(part) > 4:\n            return False\n\n        for ch in part:\n            if not ch.isdigit() and not (ch.lower() >= 'a' and ch.lower() <= 'f'):\n                return False\n\n    return True\n",
            "javascript": "function validateIP(queryIP) {\n    const ipv4_parts = queryIP.split('.');\n    const ipv6_parts = queryIP.split(':');\n\n    if (ipv4_parts.length == 4) {\n        if (isValidIPv4(ipv4_parts)) return \"IPv4\";\n    } else if (ipv6_parts.length == 8) {\n        if (isValidIPv6(ipv6_parts)) return \"IPv6\";\n    }\n\n    return \"Neither\";\n}\n\nfunction isValidIPv4(parts) {\n    for (let part of parts) {\n        if (!part || part.length > 3 || (part.length > 1 && part[0] == '0')) return false;\n\n        let num = 0;\n        for (let ch of part) {\n            if (!/[0-9]/.test(ch)) return false;\n            num = num * 10 + parseInt(ch);\n        }\n\n        if (num < 0 || num > 255) return false;\n    }\n\n    return true;\n}\n\nfunction isValidIPv6(parts) {\n    for (let part of parts) {\n        if (!part || part.length > 4) return false;\n\n        for (let ch of part) {\n            if (!/[0-9a-fA-F]/.test(ch)) return false;\n        }\n    }\n\n    return true;\n}\n",
            "explanation": "The algorithm checks if the given `queryIP` is an IPv4 or IPv6, then proceeds as follows:\n\n1. For IPv4, we split the input by dots '.' and validate if there are exactly 4 parts. Each part should be a string with length between 1 and 3, and should not have leading zeros. We then check if each character of the part is a digit and if the integer value of the part is between 0 and 255 inclusive.\n\n2. For IPv6, we split the input by colons ':' and validate if there are exactly 8 parts. Each part should be a string with length between 1 and 4. We then check if each character of the part is a hexadecimal digit (0-9, a-f or A-F).\n\nIf the given `queryIP` passes either of the above validations, it is considered a valid IPv4 or IPv6 address. Otherwise, it is considered \"Neither\"."
        },
        "structure": {
            "c++": "#include <sstream>\n#include <string>\n#include <vector>\n\nbool isValidIPv4(const std::string& part); {\nbool isValidIPv6(const std::string& part);\n\nstd::string validateIP(const std::string& queryIP) \n    // Your code here\n}\n",
            "java": "public String validateIP(String queryIP)  {\n    // Your code here\n}\n",
            "python": "def validateIP(queryIP):\n    # Your code here\n\n",
            "javascript": "function validateIP(queryIP)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <sstream>\n#include <string>\n#include <vector>\n\nint main() {\n    std::string queryIP = $args;\n    std::string result = validateIP(queryIP);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public String validateIP(String queryIP) {\n    String[] ipv4Parts = queryIP.split(\"\\\\.\", -1);\n    String[] ipv6Parts = queryIP.split(\":\", -1);\n\n    if (ipv4Parts.length == 4) {\n        if (isValidIPv4(ipv4Parts)) return \"IPv4\";\n    } else if (ipv6Parts.length == 8) {\n        if (isValidIPv6(ipv6Parts)) return \"IPv6\";\n    }\n\n    return \"Neither\";\n}\n\nprivate boolean isValidIPv4(String[] parts) {\n    for (String part : parts) {\n        if (part.length() == 0 || part.length() > 3 || (part.length() > 1 && part.charAt(0) == '0')) return false;\n\n        int num = 0;\n        for (char ch : part.toCharArray()) {\n            if (!Character.isDigit(ch)) return false;\n            num = num * 10 + (ch - '0');\n        }\n\n        if (num < 0 || num > 255) return false;\n    }\n\n    return true;\n}\n\nprivate boolean isValidIPv6(String[] parts) {\n    for (String part : parts) {\n        if (part.length() == 0 || part.length() > 4) return false;\n\n        for (char ch : part.toCharArray()) {\n            if (!Character.isDigit(ch) && !(ch >= 'a' && ch <= 'f') && !(ch >= 'A' && ch <= 'F')) return false;\n        }\n    }\n\n    return true;\n}",
            "python": "if __name__ == \"__main__\":\n    queryIP = $args[0]\n    result = validateIP(queryIP)\n    print(result)",
            "javascript": "function main() {\n    const queryIP = $args;\n    const result = validateIP(queryIP);\n    console.log(result);\n}"
        },
        "Qid": "468"
    },
    {
        "_id": {
            "$oid": "6629af0cbaf481a372cdfe32"
        },
        "title": "Matchstick Square",
        "description": "You are given an integer array `matchsticks` where `matchsticks[i]` is the length of the `ith` matchstick. You want to use **all the matchsticks** to make one square. You **should not break** any stick, but you can link them up, and each matchstick must be used **exactly one time**. Return `true` if you can make this square and `false` otherwise.",
        "example": "Example:\n\nInput: matchsticks = [1,1,2,2,2]\nOutput: true\nExplanation: You can form a square with length 2, one side of the square came two sticks with length 1.",
        "level": "Medium",
        "tags": [
            "array",
            "backtracking"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    1,
                    2,
                    2,
                    2
                ],
                [
                    3,
                    3,
                    3,
                    3,
                    4
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    16
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    17
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    18
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    19
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    20
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    21
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    22
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    23
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    24
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    25
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    26
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    27
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    28
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    29
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    30
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    31
                ]
            ],
            "outputs": [
                true,
                false,
                true,
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <numeric>\n#include <algorithm>\n\nbool makesquare(std::vector<int>& matchsticks) {\n    if (matchsticks.size() < 4) return false;\n    int sum = std::accumulate(matchsticks.begin(), matchsticks.end(), 0);\n    if (sum % 4) return false;\n    int target = sum / 4;\n    std::sort(matchsticks.rbegin(), matchsticks.rend());\n    std::vector<int> sums(4, 0);\n    return dfs(matchsticks, sums, target, 0);\n}\n\nbool dfs(std::vector<int>& matchsticks, std::vector<int>& sums, int target, int index) {\n    if (index == matchsticks.size()) {\n        return sums[0] == target && sums[1] == target && sums[2] == target;\n    }\n    for (int i = 0; i < 4; ++i) {\n        if (sums[i] + matchsticks[index] <= target) {\n            sums[i] += matchsticks[index];\n            if (dfs(matchsticks, sums, target, index + 1)) return true;\n            sums[i] -= matchsticks[index];\n        }\n    }\n    return false;\n}\n\n",
            "java": "import java.util.Arrays;\n\npublic class Solution {\n    public boolean makesquare(int[] matchsticks) {\n        if (matchsticks == null || matchsticks.length < 4) return false;\n        int sum = 0;\n        for (int matchstick : matchsticks) sum += matchstick;\n        if (sum % 4 != 0) return false;\n        int target = sum / 4;\n        Arrays.sort(matchsticks);\n        reverse(matchsticks);\n        int[] sums = new int[4];\n        return dfs(matchsticks, sums, target, 0);\n    }\n\n    private void reverse(int[] nums) {\n        int left = 0, right = nums.length - 1;\n        while (left < right) {\n            int temp = nums[left];\n            nums[left] = nums[right];\n            nums[right] = temp;\n            left++;\n            right--;\n        }\n    }\n\n    private boolean dfs(int[] matchsticks, int[] sums, int target, int index) {\n        if (index == matchsticks.length) {\n            return sums[0] == target && sums[1] == target && sums[2] == target;\n        }\n        for (int i = 0; i < 4; i++) {\n            if (sums[i] + matchsticks[index] <= target) {\n                sums[i] += matchsticks[index];\n                if (dfs(matchsticks, sums, target, index + 1)) return true;\n                sums[i] -= matchsticks[index];\n            }\n        }\n        return false;\n    }\n}\n\n",
            "python": "from itertools import chain\n\ndef makesquare(matchsticks):\n    if len(matchsticks) < 4:\n        return False\n    total = sum(matchsticks)\n    if total % 4:\n        return False\n    target = total // 4\n    matchsticks.sort(reverse=True)\n    sums = [0]*4\n    return dfs(matchsticks, sums, target, 0)\n\ndef dfs(matchsticks, sums, target, index):\n    if index == len(matchsticks):\n        return sums[0] == target and sums[1] == target and sums[2] == target\n    for i in range(4):\n        if sums[i] + matchsticks[index] <= target:\n            sums[i] += matchsticks[index]\n            if dfs(matchsticks, sums, target, index + 1):\n                return True\n            sums[i] -= matchsticks[index]\n    return False\n\n",
            "javascript": "function makesquare(matchsticks) {\n    if (matchsticks.length < 4) return false;\n    const total = matchsticks.reduce((a, b) => a + b, 0);\n    if (total % 4 !== 0) return false;\n    const target = total / 4;\n    matchsticks.sort((a, b) => b - a);\n    const sums = [0, 0, 0, 0];\n    return dfs(matchsticks, sums, target, 0);\n}\n\nfunction dfs(matchsticks, sums, target, index) {\n    if (index === matchsticks.length) {\n        return sums[0] === target && sums[1] === target && sums[2] === target;\n    }\n    for (let i = 0; i < 4; i++) {\n        if (sums[i] + matchsticks[index] <= target) {\n            sums[i] += matchsticks[index];\n            if (dfs(matchsticks, sums, target, index + 1)) return true;\n            sums[i] -= matchsticks[index];\n        }\n    }\n    return false;\n}\n\n",
            "explanation": "1. First, we check if there are enough matchsticks and if the total length of matchsticks can be divided by 4 to form a square. If not, return false.\n2. Sort the matchsticks in descending order to traverse them from the largest to the smallest. This helps to prune branches in the depth-first search.\n3. Utilize a recursive depth-first search function to try placing matchsticks i (0 <= i < 4) to form each side. If we reach the sum of all the matchsticks in a square, return true.\n4. Make sure each matchstick is used exactly once and check if the assigned sums satisfy the required target.\n5. If we reach the end and could not make a square, return false."
        },
        "structure": {
            "c++": "#include <vector>\n#include <numeric>\n#include <algorithm>\n\nbool makesquare(std::vector<int>& matchsticks)  {\n    // Your code here\n}\n\n",
            "java": "i {mport java.util.Arrays;\n\npublic class Solution \n    // Your code here\n}\n\n",
            "python": "from itertools import chain\n    # Your code here\n\n",
            "javascript": "function makesquare(matchsticks)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <iostream>\n\nbool dfs(std::vector<int>& matchsticks, std::vector<int>& sums, int target, int index);\n\nbool makesquare(std::vector<int>& matchsticks) {\n    if (matchsticks.size() < 4) return false;\n    int sum = std::accumulate(matchsticks.begin(), matchsticks.end(), 0);\n    if (sum % 4) return false;\n    int target = sum / 4;\n    std::sort(matchsticks.rbegin(), matchsticks.rend());\n    std::vector<int> sums(4, 0);\n    return dfs(matchsticks, sums, target, 0);\n}\n\nbool dfs(std::vector<int>& matchsticks, std::vector<int>& sums, int target, int index) {\n    if (index == matchsticks.size()) {\n        return sums[0] == target && sums[1] == target && sums[2] == target;\n    }\n    for (int i = 0; i < 4; ++i) {\n        if (sums[i] + matchsticks[index] <= target) {\n            sums[i] += matchsticks[index];\n            if (dfs(matchsticks, sums, target, index + 1)) return true;\n            sums[i] -= matchsticks[index];\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::vector<int> matchsticks = $args;\n    bool result = makesquare(matchsticks);\n    std::cout << std::boolalpha << result << std::endl;\n    return 0;\n}",
            "java": "public boolean makesquare(int[] matchsticks) {\n        if (matchsticks == null || matchsticks.length < 4) return false;\n        int sum = 0;\n        for (int matchstick : matchsticks) sum += matchstick;\n        if (sum % 4 != 0) return false;\n        int target = sum / 4;\n        Arrays.sort(matchsticks);\n        reverse(matchsticks);\n        int[] sums = new int[4];\n        return dfs(matchsticks, sums, target, 0);\n    }\n\n    private void reverse(int[] nums) {\n        int left = 0, right = nums.length - 1;\n        while (left < right) {\n            int temp = nums[left];\n            nums[left] = nums[right];\n            nums[right] = temp;\n            left++;\n            right--;\n        }\n    }\n\n    private boolean dfs(int[] matchsticks, int[] sums, int target, int index) {\n        if (index == matchsticks.length) {\n            return sums[0] == target && sums[1] == target && sums[2] == target;\n        }\n        for (int i = 0; i < 4; i++) {\n            if (sums[i] + matchsticks[index] <= target) {\n                sums[i] += matchsticks[index];\n                if (dfs(matchsticks, sums, target, index + 1)) return true;\n                sums[i] -= matchsticks[index];\n            }\n        }\n        return false;\n    }\n}",
            "python": "if __name__ == \"__main__\":\n    matchsticks = $args\n    result = makesquare(matchsticks)\n    print(result)",
            "javascript": "function makesquare(matchsticks) {\n    if (matchsticks.length < 4) return false;\n    const total = matchsticks.reduce((a, b) => a + b, 0);\n    if (total % 4 !== 0) return false;\n    const target = total / 4;\n    matchsticks.sort((a, b) => b - a);\n    const sums = [0, 0, 0, 0];\n    return dfs(matchsticks, sums, target, 0);\n}\n\nfunction dfs(matchsticks, sums, target, index) {\n    if (index === matchsticks.length) {\n        return sums[0] === target && sums[1] === target && sums[2] === target;\n    }\n    for (let i = 0; i < 4; i++) {\n        if (sums[i] + matchsticks[index] <= target) {\n            sums[i] += matchsticks[index];\n            if (dfs(matchsticks, sums, target, index + 1)) return true;\n            sums[i] -= matchsticks[index];\n        }\n    }\n    return false;\n}"
        },
        "Qid": "473"
    },
    {
        "_id": {
            "$oid": "6629af3dbaf481a372cdfe33"
        },
        "title": "Largest Subset of Binary Strings",
        "description": "Given an array of binary strings `strs` and two integers `m` and `n`, find the size of the largest subset of `strs` such that there are at most `m` 0's and `n` 1's in the subset. A set `x` is a subset of a set `y` if all elements of `x` are also elements of `y`.",
        "example": "Example:\n\nInput: strs = [\"10\", \"0001\", \"111001\", \"1\", \"0\"], m = 5, n = 3\nOutput: 4\nExplanation: The largest subset with at most 5 0's and 3 1's is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4. Other valid but smaller subsets include {\"0001\", \"1\"} and {\"10\", \"1\", \"0\"}. {\"111001\"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        "10",
                        "0001",
                        "111001",
                        "1",
                        "0"
                    ],
                    5,
                    3
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    1,
                    1
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    0,
                    0
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    2,
                    2
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    3,
                    1
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    1,
                    3
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    0,
                    1
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    1,
                    0
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    2,
                    1
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    1,
                    2
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    3,
                    0
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    0,
                    3
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    2,
                    0
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    0,
                    2
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    1,
                    1
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    2,
                    2
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    3,
                    3
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    4,
                    4
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    5,
                    5
                ],
                [
                    [
                        "10",
                        "0",
                        "1"
                    ],
                    6,
                    6
                ]
            ],
            "outputs": [
                4,
                2,
                3,
                3,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <string>\n#include <algorithm>\n\nint findMaxForm(std::vector<std::string>& strs, int m, int n) {\n    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1));\n    \n    for (const std::string& str: strs) {\n        int ones = std::count(str.begin(), str.end(), '1');\n        int zeros = str.length() - ones;\n        \n        for (int i = m; i >= zeros; --i) {\n            for (int j = n; j >= ones; --j) {\n                dp[i][j] = std::max(dp[i][j], dp[i - zeros][j - ones] + 1);\n            }\n        }\n    }\n    return dp[m][n];\n}\n",
            "java": "import java.util.Arrays;\n\npublic int findMaxForm(String[] strs, int m, int n) {\n    int[][] dp = new int[m + 1][n + 1];\n    \n    for (String str: strs) {\n        int ones = (int) str.chars().filter(ch -> ch == '1').count();\n        int zeros = str.length() - ones;\n        \n        for (int i = m; i >= zeros; --i) {\n            for (int j = n; j >= ones; --j) {\n                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);\n            }\n        }\n    }\n    return dp[m][n];\n}\n",
            "python": "def findMaxForm(strs, m, n):\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for s in strs:\n        ones = s.count('1')\n        zeros = len(s) - ones\n        \n        for i in range(m, zeros - 1, -1):\n            for j in range(n, ones - 1, -1):\n                dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n    \n    return dp[m][n]\n",
            "javascript": "function findMaxForm(strs, m, n) {\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    \n    for (const str of strs) {\n        const ones = str.split('').filter(ch => ch === '1').length;\n        const zeros = str.length - ones;\n        \n        for (let i = m; i >= zeros; --i) {\n            for (let j = n; j >= ones; --j) {\n                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);\n            }\n        }\n    }\n    return dp[m][n];\n}\n",
            "explanation": "1. Initialize a 2-dimensional DP table dp, where dp[i][j] represents the maximum size of a subset with i 0's and j 1's.\n2. Loop through each string in strs.\n3. Count the number of 0's (zeros) and 1's (ones) in each string.\n4. Iterate backward through the DP table, updating dp[i][j] to the maximum of its current value and dp[i - zeros][j - ones] + 1. This is because a string with zeros 0's and ones 1's will be included in the subset if i 0's and j 1's are available.\n5. After processing all the strings, return dp[m][n], which represents the size of the largest subset with at most m 0's and n 1's."
        },
        "structure": {
            "c++": "#include <vector>\n#include <string>\n#include <algorithm>\n\nint findMaxForm(std::vector<std::string>& strs, int m, int n)  {\n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\n\npublic int findMaxForm(String[] strs, int m, int n)  {\n    // Your code here\n}\n",
            "python": "def findMaxForm(strs, m, n):\n    # Your code here\n\n",
            "javascript": "function findMaxForm(strs, m, n)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <string>\n#include <algorithm>\n\nint main() {\n    std::vector<std::string> strs = $args;\n    int m = 5;\n    int n = 3;\n    int result = findMaxForm(strs, m, n);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int findMaxForm(String[] strs, int m, int n) {\n    int[][] dp = new int[m + 1][n + 1];\n    \n    for (String str: strs) {\n        int ones = (int) str.chars().filter(ch -> ch == '1').count();\n        int zeros = str.length() - ones;\n        \n        for (int i = m; i >= zeros; --i) {\n            for (int j = n; j >= ones; --j) {\n                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);\n            }\n        }\n    }\n    return dp[m][n];\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    strs = inputs[0]\n    m = inputs[1]\n    n = inputs[2]\n    result = findMaxForm(strs, m, n)\n    print(result)",
            "javascript": "function findMaxForm(strs, m, n) {\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    \n    for (const str of strs) {\n        const ones = str.split('').filter(ch => ch === '1').length;\n        const zeros = str.length - ones;\n        \n        for (let i = m; i >= zeros; --i) {\n            for (let j = n; j >= ones; --j) {\n                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);\n            }\n        }\n    }\n    return dp[m][n];\n}"
        },
        "Qid": "474"
    },
    {
        "_id": {
            "$oid": "6629af69baf481a372cdfe34"
        },
        "title": "Binary Complement",
        "description": "Given an integer `num`, find its complement by flipping all the `0`'s to `1`'s and all the `1`'s to `0`'s in its binary representation.",
        "example": "Example:\n\nInput: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So the output is 2.",
        "level": "Easy",
        "tags": [
            "bit manipulation",
            "binary representation"
        ],
        "test_cases": {
            "inputs": [
                5,
                1,
                0,
                10,
                15,
                100,
                255,
                1023,
                2047,
                4095,
                8191,
                16383,
                32767,
                65535,
                131071,
                262143,
                524287,
                1048575,
                2097151,
                4194303
            ],
            "outputs": [
                2,
                0,
                1,
                5,
                0,
                27,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "int findComplement(int num) {\n    int bitLength = 0;\n    int mask = num;\n    while (mask > 0) {\n        mask >>= 1;\n        bitLength++;\n    }\n    int allOnes = (1 << bitLength) - 1;\n\n    return num ^ allOnes;\n}\n",
            "java": "public int findComplement(int num) {\n    int bitLength = 0;\n    int mask = num;\n    while (mask > 0) {\n        mask >>= 1;\n        bitLength++;\n    }\n    int allOnes = (1 << bitLength) - 1;\n\n    return num ^ allOnes;\n}\n",
            "python": "def find_complement(num: int) -> int:\n    bit_length = 0\n    mask = num\n    while mask > 0:\n        mask >>= 1\n        bit_length += 1\n    all_ones = (1 << bit_length) - 1\n\n    return num ^ all_ones\n",
            "javascript": "function findComplement(num) {\n    let bitLength = 0;\n    let mask = num;\n    while (mask > 0) {\n        mask >>= 1;\n        bitLength++;\n    }\n    const allOnes = (1 << bitLength) - 1;\n\n    return num ^ allOnes;\n}\n",
            "explanation": "First, we calculate the number of bits in the binary representation of the input integer `num`. We do this by consecutively right-shifting the number (bitwise operation) and counting the iterations until the number becomes 0. This gives us the length of the binary representation.\n\nOnce we have the length, we create a bitmask of the same length with all bits set to 1 (for example, if the length is 3, the bitmask would be 111 in binary). To get the complement of the input integer, we then XOR (`^` operator) the number with this all-1 mask. The XOR operation returns 1 when the input bits are different and 0 when they are the same, so if we have a 0 in the input, we will get 1 and vice versa. This way, we get the complement of the original number.\n\nFinally, we return the resulting number, which is the complement of the input integer `num`."
        },
        "structure": {
            "c++": "int findComplement(int num)  {\n    // Your code here\n}\n",
            "java": "public int findComplement(int num)  {\n    // Your code here\n}\n",
            "python": "def find_complement(num: int) -> int:\n    # Your code here\n\n",
            "javascript": "function findComplement(num)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int num = $args;\n    int result = findComplement(num);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int findComplement(int num) {\n    int bitLength = 0;\n    int mask = num;\n    while (mask > 0) {\n        mask >>= 1;\n        bitLength++;\n    }\n    int allOnes = (1 << bitLength) - 1;\n\n    return num ^ allOnes;\n}",
            "python": "if __name__ == \"__main__\":\n    num = $args\n    result = find_complement(num)\n    print(result)",
            "javascript": "function main() {\n    const num = $args;\n    const bitLength = 0;\n    let mask = num;\n    while (mask > 0) {\n        mask >>= 1;\n        bitLength++;\n    }\n    const allOnes = (1 << bitLength) - 1;\n\n    const result = num ^ allOnes;\n    console.log(result);\n}"
        },
        "Qid": "476"
    },
    {
        "_id": {
            "$oid": "6629af7fbaf481a372cdfe35"
        },
        "title": "Hamming Distance Sum",
        "description": "Given an integer array `nums`, return the sum of Hamming distances between all the pairs of the integers in `nums`. The Hamming distance between two integers is the number of positions at which the corresponding bits are different.",
        "example": "Example:\n\nInput: nums = [4,14,2]\nOutput: 6\nExplanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just showing the four bits relevant in this case). The answer will be: HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.",
        "level": "Medium",
        "tags": [
            "bit manipulation",
            "array"
        ],
        "test_cases": {
            "inputs": [
                [
                    4,
                    14,
                    2
                ],
                [
                    4,
                    14,
                    4
                ],
                [
                    0,
                    0,
                    0
                ],
                [
                    1,
                    2,
                    3,
                    4
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50
                ],
                [
                    100,
                    200,
                    300,
                    400,
                    500
                ],
                [
                    1024,
                    2048,
                    4096,
                    8192
                ],
                [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    15,
                    15,
                    15,
                    15,
                    15
                ],
                [
                    16,
                    16,
                    16,
                    16,
                    16
                ]
            ],
            "outputs": [
                6,
                4,
                0,
                10,
                40,
                80,
                48,
                90,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "int totalHammingDistance(vector<int>& nums) {\n    int total_distance = 0, n = nums.size();\n    \n    for (int i = 0; i < 32; ++i) {\n        int bit_count = 0;\n        for (int num : nums) {\n            bit_count += (num >> i) & 1;\n        }\n        total_distance += bit_count * (n - bit_count);\n    }\n    \n    return total_distance;\n}\n",
            "java": "public int totalHammingDistance(int[] nums) {\n    int totalDistance = 0, n = nums.length;\n    \n    for (int i = 0; i < 32; ++i) {\n        int bitCount = 0;\n        for (int num : nums) {\n            bitCount += (num >> i) & 1;\n        }\n        totalDistance += bitCount * (n - bitCount);\n    }\n    \n    return totalDistance;\n}\n",
            "python": "def total_hamming_distance(nums):\n    total_distance = 0\n    n = len(nums)\n\n    for i in range(32):\n        bit_count = sum(((num >> i) & 1) for num in nums)\n        total_distance += bit_count * (n - bit_count)\n\n    return total_distance\n",
            "javascript": "function totalHammingDistance(nums) {\n    let totalDistance = 0, n = nums.length;\n    \n    for (let i = 0; i < 32; ++i) {\n        let bitCount = 0;\n        for (let num of nums) {\n            bitCount += (num >> i) & 1;\n        }\n        totalDistance += bitCount * (n - bitCount);\n    }\n    \n    return totalDistance;\n}\n",
            "explanation": "The algorithm iterates through the 32-bit positions of the integers. For each bit position, it counts the number of integers in the array that have a 1 at that position. Then, it calculates the Hamming distance for that bit position by multiplying the number of 1s by the number of 0s at that position. Finally, it sums up the Hamming distances for all the bit positions to find the total Hamming distance between all the pairs of integers in the array. This way, the algorithm has a linear runtime complexity with respect to the size of the input array."
        },
        "structure": {
            "c++": "int totalHammingDistance(vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "public int totalHammingDistance(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def total_hamming_distance(nums):\n    # Your code here\n\n",
            "javascript": "function totalHammingDistance(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int main() {\n    vector<int> nums = $args;\n    int result = totalHammingDistance(nums);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int callTotalHammingDistance(int[] nums) {\n    int totalDistance = 0, n = nums.length;\n    \n    for (int i = 0; i < 32; ++i) {\n        int bitCount = 0;\n        for (int num : nums) {\n            bitCount += (num >> i) & 1;\n        }\n        totalDistance += bitCount * (n - bitCount);\n    }\n    \n    return totalDistance;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = total_hamming_distance(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = totalHammingDistance(nums);\n    console.log(result);\n}"
        },
        "Qid": "477"
    },
    {
        "_id": {
            "$oid": "6629b087baf481a372cdfe37"
        },
        "title": "Largest Palindromic Integer",
        "description": "Given an integer n, return the largest palindromic integer that can be represented as the product of two n-digit integers. Since the answer can be very large, return it modulo 1337.",
        "example": "Example:\n\nInput: n = 2\nOutput: 987\nExplanation: 99 x 91 = 9009, 9009 % 1337 = 987",
        "level": "Medium",
        "tags": [
            "Math",
            "Palindrome"
        ],
        "test_cases": {
            "inputs": [
                2,
                1,
                3,
                4,
                5,
                6,
                7,
                8
            ],
            "outputs": [
                987,
                9,
                12321,
                597795,
                9009,
                906609,
                99000099,
                {
                    "$numberLong": "9966006699"
                }
            ]
        },
        "sample_code": {
            "c++": "int largestPalindrome(int n) {\n    if (n == 1) return 9;\n    int upper_limit = pow(10, n) - 1;\n    int lower_limit = upper_limit / 10;\n    for (int i = upper_limit; i > lower_limit; --i) {\n        long long temp = i;\n        long long reverse = 0;\n        while (temp != 0) {\n            reverse = reverse * 10 + temp % 10;\n            temp /= 10;\n        }\n        long long palindrome = i * pow(10, n) + reverse;\n        for (long long j = upper_limit; j > lower_limit; --j) {\n            long long product = palindrome / j;\n            if (palindrome % j == 0 && product <= upper_limit) {\n                return palindrome % 1337;\n            }\n        }\n    }\n    return -1;\n}\n",
            "java": "int largestPalindrome(int n) {\n    if (n == 1) return 9;\n    int upper_limit = (int) Math.pow(10, n) - 1;\n    int lower_limit = upper_limit / 10;\n    for (int i = upper_limit; i > lower_limit; --i) {\n        long temp = i;\n        long reverse = 0;\n        while (temp != 0) {\n            reverse = reverse * 10 + temp % 10;\n            temp /= 10;\n        }\n        long palindrome = i * (long) Math.pow(10, n) + reverse;\n        for (long j = upper_limit; j > lower_limit; --j) {\n            long product = palindrome / j;\n            if (palindrome % j == 0 && product <= upper_limit) {\n                return (int) (palindrome % 1337);\n            }\n        }\n    }\n    return -1;\n}\n",
            "python": "def largestPalindrome(n):\n    if n == 1: \n        return 9\n    upper_limit = 10**n - 1\n    lower_limit = upper_limit // 10\n    for i in range(upper_limit, lower_limit, -1):\n        temp = i\n        reverse = 0\n        while temp != 0:\n            reverse = reverse * 10 + temp % 10\n            temp //= 10\n        palindrome = i * (10**n) + reverse\n        for j in range(upper_limit, lower_limit, -1):\n            product = palindrome // j\n            if palindrome % j == 0 and product <= upper_limit:\n                return palindrome % 1337\n    return -1\n",
            "javascript": "function largestPalindrome(n) {\n    if (n === 1) return 9; // Handle 1-digit numbers\n    let upper_limit = Math.pow(10, n) - 1;\n    let lower_limit = Math.floor(upper_limit / 10);\n    for (let i = upper_limit; i > lower_limit; i--) {\n        let temp = i;\n        let reverse = 0;\n        while (temp !== 0) {\n            reverse = reverse * 10 + temp % 10;\n            temp = Math.floor(temp / 10);\n        }\n        let palindrome = i * Math.pow(10, n) + reverse;\n        for (let j = upper_limit; j > lower_limit; j--) {\n            let product = Math.floor(palindrome / j);\n            if (palindrome % j === 0 && product <= upper_limit) {\n                return palindrome % 1337;\n            }\n        }\n    }\n    return -1;\n}\n\n",
            "explanation": "1. If n is 1, return 9 (the largest palindromic product of two 1-digit numbers is 9).\n2. Calculate the upper and lower limits for the n-digit numbers.\n3. Loop through the numbers in reverse order, starting from the upper limit down to the lower limit.\n4. Within the loop, find the reverse of the current iteration number.\n5. Calculate the possible palindrome by concatenating the current number and its reverse.\n6. Loop through the numbers again to find the two factors of the palindrome.\n7. If a palindrome with valid factors is found, return the palindrome modulo 1337.\n8. If no such palindrome is found, return -1."
        },
        "structure": {
            "c++": "int largestPalindrome(int n)  {\n    // Your code here\n}\n",
            "java": "int largestPalindrome(int n)  {\n    // Your code here\n}\n",
            "python": "def largestPalindrome(n):\n    # Your code here\n\n",
            "javascript": "function largestPalindrome(n)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = largestPalindrome(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "int largestPalindrome(int n) {\n    if (n == 1) return 9;\n    int upper_limit = (int) Math.pow(10, n) - 1;\n    int lower_limit = upper_limit / 10;\n    for (int i = upper_limit; i > lower_limit; --i) {\n        long temp = i;\n        long reverse = 0;\n        while (temp != 0) {\n            reverse = reverse * 10 + temp % 10;\n            temp /= 10;\n        }\n        long palindrome = i * (long) Math.pow(10, n) + reverse;\n        for (long j = upper_limit; j > lower_limit; --j) {\n            long product = palindrome / j;\n            if (palindrome % j == 0 && product <= upper_limit) {\n                return (int) (palindrome % 1337);\n            }\n        }\n    }\n    return -1;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = largestPalindrome(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = largestPalindrome(n);\n    console.log(result);\n}"
        },
        "Qid": "479"
    },
    {
        "_id": {
            "$oid": "6629b0c4baf481a372cdfe38"
        },
        "title": "Count of 1's in Magical String",
        "description": "A magical string `s` consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n\nThe first few elements of s is s = \"1221121221221121122...... \". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ...... \" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ...... \". You can see that the occurrence sequence is s itself.\n\nGiven an integer n, return the number of 1's in the first n number in the magical string s.",
        "example": "Example:\n\nInput: n = 6\nOutput: 3\nExplanation: The first 6 elements of magical string s is \"122112\" and it contains three 1's, so return 3.",
        "level": "Easy",
        "tags": [
            "string",
            "counting"
        ],
        "test_cases": {
            "inputs": [
                6,
                1,
                10,
                15,
                20,
                25,
                30,
                50,
                100,
                1000,
                10000,
                50000,
                100000,
                105,
                500,
                10000,
                50000,
                100000,
                1000000,
                10000000
            ],
            "outputs": [
                3,
                1,
                4,
                7,
                9,
                12,
                15,
                26,
                53,
                504,
                5004,
                25004,
                50004,
                52,
                252,
                5004,
                25004,
                50004,
                500004,
                5000004
            ]
        },
        "sample_code": {
            "c++": "int magicalString(int n) {\n    if (n == 0) return 0;\n    if (n <= 3) return 1;\n    \n    vector<int> magic = {1, 2, 2};\n    int count_ones = 1;\n    int index = 2;\n    int value = 1;\n    \n    while (magic.size() < n) {\n        for (int i = 0; i < magic[index]; ++i) {\n            magic.push_back(value);\n            if (value == 1 && magic.size() <= n) count_ones++;\n        }\n        value = 3 - value;\n        index++;\n    }\n    \n    return count_ones;\n}\n\n",
            "java": "public int magicalString(int n) {\n    if (n == 0) return 0;\n    if (n <= 3) return 1;\n    \n    int[] magic = new int[n + 1];\n    magic[0] = 1;\n    magic[1] = 2;\n    magic[2] = 2;\n    int count_ones = 1;\n    int index = 2;\n    int value = 1;\n    \n    while (index < n) {\n        for (int i = 0; i < magic[index] && index < n; i++) {\n            magic[++index] = value;\n            if (value == 1) count_ones++;\n        }\n        value = 3 - value;\n    }\n    \n    return count_ones;\n}\n\n",
            "python": "def magical_string(n: int) -> int:\n    if n == 0:\n        return 0\n    if n <= 3:\n        return 1\n\n    magic = [1, 2, 2]\n    count_ones = 1\n    index = 2\n    value = 1\n\n    while len(magic) < n:\n        for _ in range(magic[index]):\n            magic.append(value)\n            if value == 1 and len(magic) <= n:\n                count_ones += 1\n        value = 3 - value\n        index += 1\n\n    return count_ones\n\n",
            "javascript": "function magicalString(n) {\n    if (n === 0) return 0;\n    if (n <= 3) return 1;\n\n    let magic = [1, 2, 2];\n    let countOnes = 1;\n    let index = 2;\n    let value = 1;\n\n    while (magic.length < n) {\n        for (let i = 0; i < magic[index]; i++) {\n            magic.push(value);\n            if (value === 1 && magic.length <= n) countOnes++;\n        }\n        value = 3 - value;\n        index++;\n    }\n\n    return countOnes;\n}\n\n",
            "explanation": "1. If n is 0, return 0. If n is 1, 2 or 3, return 1.\n2. Initialize the magic array with the first 3 elements: [1, 2, 2].\n3. Initialize count_ones to 1, index to 2, and value to 1.\n4. While the length of the magic array is less than n, loop through the following steps:\n   a. Loop from 0 to magic[index] (exclusive), pushing the current value to the magic array.\n   b. If the value is 1 and the length of the magic array is less than or equal to n, increment count_ones by 1.\n   c. Switch the value between 1 and 2 by setting value to 3 - value.\n   d. Increment the index by 1.\n5. Return the count_ones variable."
        },
        "structure": {
            "c++": "int magicalString(int n)  {\n    // Your code here\n}\n\n",
            "java": "public int magicalString(int n)  {\n    // Your code here\n}\n\n",
            "python": "def magical_string(n: int) -> int:\n    # Your code here\n\n",
            "javascript": "function magicalString(n)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "int main() {\n    int n = $args;\n    int result = magicalString(n);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public int magicalString(int n) {\n    if (n == 0) return 0;\n    if (n <= 3) return 1;\n    \n    int[] magic = new int[n + 1];\n    magic[0] = 1;\n    magic[1] = 2;\n    magic[2] = 2;\n    int count_ones = 1;\n    int index = 2;\n    int value = 1;\n    \n    while (index < n) {\n        for (int i = 0; i < magic[index] && index < n; i++) {\n            magic[++index] = value;\n            if (value == 1) count_ones++;\n        }\n        value = 3 - value;\n    }\n    \n    return count_ones;\n}",
            "python": "if __name__ == \"__main__\":\n    n = $args\n    result = magical_string(n)\n    print(result)",
            "javascript": "function main() {\n    const n = $args;\n    const result = magicalString(n);\n    console.log(result);\n}"
        },
        "Qid": "481"
    },
    {
        "_id": {
            "$oid": "6629b0eebaf481a372cdfe39"
        },
        "title": "Maximum Consecutive Ones",
        "description": "Given a binary array `nums`, find the maximum number of consecutive `1`'s in the array.",
        "example": "Example 1:\n\nInput: nums = [1,1,0,1,1,1]\nOutput: 3\nExplanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\n\nExample 2:\n\nInput: nums = [1,0,1,1,0,1]\nOutput: 2",
        "level": "Easy",
        "tags": [
            "array",
            "iteration"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    1,
                    0,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    0,
                    1,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    0,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    0,
                    0,
                    1,
                    1
                ],
                [
                    0,
                    1,
                    1,
                    1,
                    0,
                    0
                ],
                [
                    1,
                    0,
                    1,
                    0,
                    1,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    0,
                    0,
                    0
                ],
                [
                    0,
                    0,
                    0,
                    1,
                    1,
                    1
                ],
                [
                    1,
                    0,
                    1,
                    0,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    0,
                    1,
                    0,
                    1
                ],
                [
                    0,
                    1,
                    0,
                    1,
                    1,
                    0
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    0,
                    1
                ],
                [
                    0,
                    1,
                    1,
                    0,
                    1,
                    1
                ],
                [
                    1,
                    0,
                    0,
                    1,
                    1,
                    0
                ],
                [
                    0,
                    0,
                    1,
                    1,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    0,
                    0,
                    1,
                    0
                ],
                [
                    0,
                    1,
                    0,
                    0,
                    0,
                    1
                ],
                [
                    1,
                    0,
                    1,
                    1,
                    1,
                    0
                ]
            ],
            "outputs": [
                3,
                2,
                6,
                0,
                1,
                2,
                3,
                1,
                3,
                3,
                2,
                2,
                2,
                4,
                2,
                2,
                2,
                1,
                1,
                3
            ]
        },
        "sample_code": {
            "c++": "int findMaxConsecutiveOnes(vector<int>& nums) {\n    int max_consecutive = 0, current_consecutive = 0;\n    for (int num : nums) {\n        current_consecutive = (num == 1) ? current_consecutive + 1 : 0;\n        max_consecutive = max(max_consecutive, current_consecutive);\n    }\n    return max_consecutive;\n}\n",
            "java": "public int findMaxConsecutiveOnes(int[] nums) {\n    int maxConsecutive = 0, currentConsecutive = 0;\n    for (int num : nums) {\n        currentConsecutive = (num == 1) ? currentConsecutive + 1 : 0;\n        maxConsecutive = Math.max(maxConsecutive, currentConsecutive);\n    }\n    return maxConsecutive;\n}\n",
            "python": "def findMaxConsecutiveOnes(nums):\n    max_consecutive, current_consecutive = 0, 0\n    for num in nums:\n        current_consecutive = current_consecutive + 1 if num == 1 else 0\n        max_consecutive = max(max_consecutive, current_consecutive)\n    return max_consecutive\n",
            "javascript": "function findMaxConsecutiveOnes(nums) {\n    let maxConsecutive = 0, currentConsecutive = 0;\n    for (let num of nums) {\n        currentConsecutive = (num === 1) ? currentConsecutive + 1 : 0;\n        maxConsecutive = Math.max(maxConsecutive, currentConsecutive);\n    }\n    return maxConsecutive;\n}\n",
            "explanation": "The algorithm iterates through the given binary array `nums`. For each element, it checks if the current number is 1, then it increments the `current_consecutive` counter; otherwise, it resets the counter to 0. After updating the counter, it compares the current value of `current_consecutive` with the current maximum consecutive ones count (`max_consecutive`) and updates the maximum count if the current count is higher. After iterating through the entire array, the algorithm returns the maximum number of consecutive 1's found."
        },
        "structure": {
            "c++": "int findMaxConsecutiveOnes(vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "public int findMaxConsecutiveOnes(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def findMaxConsecutiveOnes(nums):\n    # Your code here\n\n",
            "javascript": "function findMaxConsecutiveOnes(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "int findMaxConsecutiveOnes(vector<int>& nums) {\n    int max_consecutive = 0, current_consecutive = 0;\n    for (int num : nums) {\n        current_consecutive = (num == 1) ? current_consecutive + 1 : 0;\n        max_consecutive = max(max_consecutive, current_consecutive);\n    }\n    return max_consecutive;\n}",
            "java": "public int findMaxConsecutiveOnes(int[] nums) {\n    int maxConsecutive = 0, currentConsecutive = 0;\n    for (int num : nums) {\n        currentConsecutive = (num == 1) ? currentConsecutive + 1 : 0;\n        maxConsecutive = Math.max(maxConsecutive, currentConsecutive);\n    }\n    return maxConsecutive;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = findMaxConsecutiveOnes(nums)\n    print(result)",
            "javascript": "function main() {\n    const nums = $args;\n    const result = findMaxConsecutiveOnes(nums);\n    console.log(result);\n}"
        },
        "Qid": "485"
    },
    {
        "_id": {
            "$oid": "6629b19cbaf481a372cdfe3a"
        },
        "title": "Zuma Game",
        "description": "You are playing a variation of the game Zuma. In this variation, there is a single row of colored balls on a board, where each ball can be colored red \"R\", yellow \"Y\", blue \"B\", green \"G\", or white \"W\". Your goal is to clear all of the balls from the board. On each turn, you can pick any ball from your hand and insert it in between two balls in the row or on either end of the row. If there is a group of three or more consecutive balls of the same color, remove the group of balls from the board. If this removal causes more groups of three or more of the same color to form, then continue removing each group until there are none left. If there are no more balls on the board, then you win the game. Repeat this process until you either win or do not have any more balls in your hand. Given a string board representing the row of balls on the board, and a string hand representing the balls in your hand, return the minimum number of balls you have to insert to clear all the balls from the board. If you cannot clear all the balls from the board using the balls in your hand, return -1.",
        "example": "Example:\n\nInput: board = \"WRRBBW\", hand = \"RB\"\nOutput: -1\nExplanation: It is impossible to clear all the balls. The best you can do is:\n- Insert 'R' so the board becomes WRRRBBW. WRRRBBW -> WBBW.\n- Insert 'B' so the board becomes WBBBW. WBBBW -> WW.\nThere are still balls remaining on the board, and you are out of balls to insert.",
        "level": "Medium",
        "tags": [
            "string",
            "recursion",
            "backtracking"
        ],
        "test_cases": {
            "inputs": [
                [
                    "WRRBBW",
                    "RB"
                ],
                [
                    "WWRRBBWW",
                    "WRBRW"
                ],
                [
                    "G",
                    "GGGGG"
                ],
                [
                    "RRRR",
                    "RR"
                ],
                [
                    "RRRR",
                    "RRR"
                ],
                [
                    "RRRR",
                    "RRRR"
                ],
                [
                    "RRRR",
                    "RRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRRRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRRRRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRRRRRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRRRRRRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRRRRRRRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRRRRRRRRRRRR"
                ],
                [
                    "RRRR",
                    "RRRRRRRRRRRRRRRRRR"
                ]
            ],
            "outputs": [
                -1,
                2,
                2,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },
        "sample_code": {
            "c++": "#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nint find_min_step_helper(string& board, unordered_map<string, int>& memo, unordered_map<char, int>& hand) {\n    if (board.empty()) return 0;\n    if (memo.count(board)) return memo[board];\n\n    int result = INT_MAX;\n    for (int i = 0, j = 0; i < board.size(); i = j) {\n        while (j < board.size() and board[i] == board[j]) ++j;\n        char color = board[i];\n        int required = 3 - (j - i);\n        if (hand[color] >= required) {\n            hand[color] -= required;\n            string next_board = board.substr(0, i) + board.substr(j);\n            int tmp = find_min_step_helper(next_board, memo, hand);\n            if (tmp != -1) result = min(result, tmp + required);\n            hand[color] += required;\n        }\n    }\n\n    memo[board] = result == INT_MAX ? -1 : result;\n    return memo[board];\n}\n\nint find_min_step(string board, string hand) {\n    unordered_map<char, int> hand_map;\n    for (char c : hand) ++hand_map[c];\n    unordered_map<string, int> memo;\n    return find_min_step_helper(board, memo, hand_map);\n}\n\n",
            "java": "import java.util.*;\n\nclass Solution {\n    public int findMinStep(String board, String hand) {\n        HashMap<Character, Integer> handMap = new HashMap<>();\n        for (char c : hand.toCharArray()) handMap.put(c, handMap.getOrDefault(c, 0) + 1);\n\n        return findMinStepHelper(board, new HashMap<String, Integer>(), handMap);\n    }\n\n    private int findMinStepHelper(String board, HashMap<String, Integer> memo, HashMap<Character, Integer> hand) {\n        if (board.isEmpty()) return 0;\n        if (memo.containsKey(board)) return memo.get(board);\n\n        int result = Integer.MAX_VALUE;\n        for (int i = 0, j = 0; i < board.length(); i = j) {\n            while (j < board.length() && board.charAt(i) == board.charAt(j)) ++j;\n            char color = board.charAt(i);\n            int required = 3 - (j - i);\n            if (hand.getOrDefault(color, 0) >= required) {\n                hand.put(color, hand.get(color) - required);\n                String nextBoard = board.substring(0, i) + board.substring(j);\n                int tmp = findMinStepHelper(nextBoard, memo, hand);\n                if (tmp != -1) result = Math.min(result, tmp + required);\n                hand.put(color, hand.get(color) + required);\n            }\n        }\n\n        int res = (result == Integer.MAX_VALUE) ? -1 : result;\n        memo.put(board, res);\n        return res;\n    }\n}\n\n",
            "python": "from collections import Counter\n\ndef find_min_step(board: str, hand: str) -> int:\n    def find_min_step_helper(board, memo, hand):\n        if not board:\n            return 0\n        if board in memo:\n            return memo[board]\n\n        result = float('inf')\n        i = 0\n        while i < len(board):\n            j = i\n            while j < len(board) and board[i] == board[j]:\n                j += 1            \n\n            color = board[i]\n            required = 3 - (j - i)\n            if hand[color] >= required:\n                hand[color] -= required\n                next_board = board[:i] + board[j:]\n                tmp = find_min_step_helper(next_board, memo, hand)\n                if tmp != -1:\n                    result = min(result, tmp + required)\n                hand[color] += required\n            i = j\n\n        memo[board] = -1 if result == float('inf') else result\n        return memo[board]\n\n    hand_count = Counter(hand)\n    memo = {}\n    return find_min_step_helper(board, memo, hand_count)\n\n",
            "javascript": "function findMinStep(board, hand) {\n    function findMinStepHelper(board, memo, hand) {\n        if (board.length === 0) return 0;\n        if (memo.has(board)) return memo.get(board);\n\n        let result = Infinity;\n        let i = 0;\n        while (i < board.length) {\n            let j = i;\n            while (j < board.length && board[i] === board[j]) j++;\n\n            let color = board[i];\n            let required = 3 - (j - i);\n            if (hand[color] >= required) {\n                hand[color] -= required;\n                let nextBoard = board.slice(0, i) + board.slice(j);\n                let tmp = findMinStepHelper(nextBoard, memo, hand);\n                if (tmp !== -1) result = Math.min(result, tmp + required);\n                hand[color] += required;\n            }\n            i = j;\n        }\n\n        let res = (result === Infinity) ? -1 : result;\n        memo.set(board, res);\n        return res;\n    }\n\n    let handMap = {};\n    for (let c of hand) handMap[c] = (handMap[c] || 0) + 1;\n\n    return findMinStepHelper(board, new Map(), handMap);\n}\n\n",
            "explanation": "The algorithm uses a backtracking approach along with memoization. The base case for the recursion is when there is an empty board, in which case the minimum number of balls to clear the board is 0.\n\nThe function loops through the board to find sequences of the same color. For each sequence, it calculates the number of balls needed to reach at least 3 in a row. If the required number of balls are available in hand, it removes the required balls from hand and proceeds recursively with the rest of the board.\n\nAfter the recursive call, the removed balls are added back to the hand.\n\nThe memoization is used to store the results of subproblems based on the current state of the board.\n\nThe result is -1 if the balls in hand cannot clear the board, otherwise, the minimum number of balls required to clear the board is returned."
        },
        "structure": {
            "c++": "#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nint find_min_step_helper(string& board, unordered_map<string, int>& memo, unordered_map<char, int>& hand)  {\n    // Your code here\n}\n\n",
            "java": "i {mport java.util.*;\n\nclass Solution \n    // Your code here\n}\n\n",
            "python": "from collections import Counter\n    # Your code here\n\n",
            "javascript": "function findMinStep(board, hand)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    string board = $args;\n    string hand = $args;\n    unordered_map<char, int> hand_map;\n    for (char c : hand) ++hand_map[c];\n    unordered_map<string, int> memo;\n    int result = find_min_step_helper(board, memo, hand_map);\n    cout << result << endl;\n    return 0;\n}",
            "java": "public static void main(String[] args) {\n        int n = $args;\n        boolean result = isPowerOfFour(n);\n        System.out.println(result);\n    }\n",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    board = inputs[0]\n    hand = inputs[1]\n    result = find_min_step(board, hand)\n    print(result)",
            "javascript": "function findMinStep(board, hand) {\n    function findMinStepHelper(board, memo, hand) {\n        if (board.length === 0) return 0;\n        if (memo.has(board)) return memo.get(board);\n\n        let result = Infinity;\n        let i = 0;\n        while (i < board.length) {\n            let j = i;\n            while (j < board.length && board[i] === board[j]) j++;\n\n            let color = board[i];\n            let required = 3 - (j - i);\n            if (hand[color] >= required) {\n                hand[color] -= required;\n                let nextBoard = board.slice(0, i) + board.slice(j);\n                let tmp = findMinStepHelper(nextBoard, memo, hand);\n                if (tmp !== -1) result = Math.min(result, tmp + required);\n                hand[color] += required;\n            }\n            i = j;\n        }\n\n        let res = (result === Infinity) ? -1 : result;\n        memo.set(board, res);\n        return res;\n    }\n\n    let handMap = {};\n    for (let c of hand) handMap[c] = (handMap[c] || 0) + 1;\n\n    return findMinStepHelper(board, new Map(), handMap);\n}"
        },
        "Qid": "488"
    },
    {
        "_id": {
            "$oid": "6629b1e7baf481a372cdfe3b"
        },
        "title": "Web Page Design",
        "description": "A web developer needs to know how to design a web page's size. Given a specific rectangular web page's area, your task is to design a rectangular web page with length L and width W that satisfy the following requirements:\n\n1. The area of the rectangular web page you design must be equal to the given target area.\n2. The width `W` should not be larger than the length `L`, which means `L >= W`.\n3. The difference between length `L` and width `W` should be as small as possible.\n\nReturn an array `[L, W]` where `L` and `W` are the length and width of the web page you designed in sequence.",
        "example": "Example:\n\nInput: area = 4\nOutput: [2,2]\nExplanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. But according to requirement 2, [1,4] is illegal; according to requirement 3, [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.",
        "level": "Easy",
        "tags": [
            "Math",
            "Geometry"
        ],
        "test_cases": {
            "inputs": [
                4,
                37,
                122122,
                1,
                100,
                999999,
                107,
                50,
                25,
                64,
                81,
                121,
                144,
                169,
                196,
                225,
                256,
                289,
                324,
                361
            ],
            "outputs": [
                [
                    2,
                    2
                ],
                [
                    37,
                    1
                ],
                [
                    427,
                    286
                ],
                [
                    1,
                    1
                ],
                [
                    10,
                    10
                ],
                [
                    999,
                    999
                ],
                [
                    107,
                    1
                ],
                [
                    10,
                    5
                ],
                [
                    5,
                    5
                ],
                [
                    8,
                    8
                ],
                [
                    9,
                    9
                ],
                [
                    11,
                    11
                ],
                [
                    12,
                    12
                ],
                [
                    13,
                    13
                ],
                [
                    14,
                    14
                ],
                [
                    15,
                    15
                ],
                [
                    16,
                    16
                ],
                [
                    17,
                    17
                ],
                [
                    18,
                    18
                ],
                [
                    19,
                    19
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <cmath>\n\nstd::vector<int> constructRectangle(int area) {\n    int width = std::sqrt(area);\n    while(area % width != 0) {\n        width -= 1;\n    }\n    int length = area / width;\n    return {length, width};\n}\n",
            "java": "public int[] constructRectangle(int area) {\n    int width = (int)Math.sqrt(area);\n    while(area % width != 0) {\n        width--;\n    }\n    int length = area / width;\n    return new int[]{length, width};\n}\n",
            "python": "def constructRectangle(area: int) -> list[int]:\n    width = int(area**0.5)\n    while area % width != 0:\n        width -= 1\n    length = area // width\n    return [length, width]\n",
            "javascript": "function constructRectangle(area) {\n    let width = Math.floor(Math.sqrt(area));\n    while(area % width !== 0) {\n        width--;\n    }\n    let length = area / width;\n    return [length, width];\n}\n",
            "explanation": "The algorithm starts by calculating the square root of the given area, using the sqrt function in each language. Since web pages with more rectangular shapes are preferred, we start the width from `sqrt(area)` and work our way down.\n\nWe initialize the variable width with the integer value of the square root of the area: `width = sqrt(area)`. This initialization ensures that our width and length will be as close as possible to each other.\n\nWe then use a while loop to check if the current width divides the area evenly (`area % width != 0`). If it doesn't, we decrement the width by one and repeat the loop until we find a width that divides the area evenly.\n\nFinally, we calculate the length by dividing the area with the width: `length = area / width`. We return the length and width as an array in the required sequence: `[length, width]`."
        },
        "structure": {
            "c++": "#include <vector>\n#include <cmath>\n\nstd::vector<int> constructRectangle(int area)  {\n    // Your code here\n}\n",
            "java": "public int[] constructRectangle(int area)  {\n    // Your code here\n}\n",
            "python": "def constructRectangle(area: int) -> List[int]:\n    # Your code here\n\n",
            "javascript": "function constructRectangle(area)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <cmath>\n#include <iostream>\n\nint main() {\n    int area = $args;\n    std::vector<int> result = constructRectangle(area);\n    std::cout << result[0] << \" \" << result[1] << std::endl;\n    return 0;\n}",
            "java": "public int[] constructRectangle(int area) {\n    int width = (int)Math.sqrt(area);\n    while(area % width != 0) {\n        width--;\n    }\n    int length = area / width;\n    return new int[]{length, width};\n}",
            "python": "if __name__ == \"__main__\":\n    area = $args\n    result = constructRectangle(area)\n    print(result)",
            "javascript": "function main() {\n    const area = $args;\n    const result = constructRectangle(area);\n    console.log(result);\n}"
        },
        "Qid": "492"
    },
    {
        "_id": {
            "$oid": "6629b20ebaf481a372cdfe3c"
        },
        "title": "Reverse Pairs in Array",
        "description": "Given an integer array `nums`, return the number of reverse pairs in the array. A reverse pair is a pair `(i, j)` where `0 <= i < j < nums.length` and `nums[i] > 2 * nums[j]`.",
        "example": "Example 1:\n\nInput: nums = [1,3,2,3,1]\nOutput: 2\nExplanation: The reverse pairs are:\n(1, 4) --> nums[1] = 3, nums[4] = 1, 3 > 2 * 1\n(3, 4) --> nums[3] = 3, nums[4] = 1, 3 > 2 * 1\n\nExample 2:\n\nInput: nums = [2,4,3,5,1]\nOutput: 3\nExplanation: The reverse pairs are:\n(1, 4) --> nums[1] = 4, nums[4] = 1, 4 > 2 * 1\n(2, 4) --> nums[2] = 3, nums[4] = 1, 3 > 2 * 1\n(3, 4) --> nums[3] = 5, nums[4] = 1, 5 > 2 * 1",
        "level": "Medium",
        "tags": [
            "Array",
            "Sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    3,
                    2,
                    3,
                    1
                ],
                [
                    2,
                    4,
                    3,
                    5,
                    1
                ],
                [
                    5,
                    10,
                    15,
                    20,
                    25
                ],
                [
                    3,
                    6,
                    9,
                    12,
                    15
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    10,
                    20,
                    30,
                    40,
                    50
                ],
                [
                    50,
                    40,
                    30,
                    20,
                    10
                ],
                [
                    2,
                    4,
                    6,
                    8,
                    10
                ],
                [
                    10,
                    8,
                    6,
                    4,
                    2
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    2,
                    2,
                    2,
                    2,
                    2
                ],
                [
                    3,
                    3,
                    3,
                    3,
                    3
                ],
                [
                    4,
                    4,
                    4,
                    4,
                    4
                ],
                [
                    5,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ],
                [
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    2,
                    2,
                    2,
                    3,
                    3,
                    3
                ],
                [
                    3,
                    3,
                    3,
                    2,
                    2,
                    2,
                    1,
                    1,
                    1
                ],
                [
                    5,
                    5,
                    5,
                    4,
                    4,
                    4,
                    3,
                    3,
                    3
                ]
            ],
            "outputs": [
                2,
                3,
                0,
                0,
                0,
                10,
                0,
                10,
                0,
                10,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                6,
                6,
                9
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nint merge(std::vector<int>& nums, std::vector<int>& temp, int left, int mid, int right) {\n    int count = 0;\n    int j = mid;\n    for (int i = left; i < mid; i++) {\n        while (j <= right && (long long)nums[i] > 2LL * nums[j]) {\n            j++;\n        }\n        count += j - mid;\n    }\n    std::merge(nums.begin() + left, nums.begin() + mid, nums.begin() + mid, nums.begin() + right + 1, temp.begin() + left);\n    \n    return count;\n}\n\nint countReversePairs(std::vector<int>& nums, std::vector<int>& temp, int left, int right) {\n    if (left >= right) {\n        return 0;\n    }\n    int mid = left + (right - left) / 2;\n    int count = countReversePairs(nums, temp, left, mid) + countReversePairs(nums, temp, mid + 1, right);\n    count += merge(nums, temp, left, mid + 1, right);\n    std::copy(temp.begin() + left, temp.begin() + right + 1, nums.begin() + left);\n    \n    return count;\n}\n\nint reversePairs(std::vector<int>& nums) {\n    std::vector<int> temp(nums.size());\n    return countReversePairs(nums, temp, 0, nums.size() - 1);\n}\n",
            "java": "public int reversePairs(int[] nums) {\n    return mergeSort(nums, 0, nums.length - 1, new int[nums.length]);\n}\n\nprivate int mergeSort(int[] nums, int left, int right, int[] temp) {\n    if (left >= right) {\n        return 0;\n    }\n    int mid = left + (right - left) / 2;\n    int count = mergeSort(nums, left, mid, temp) + mergeSort(nums, mid + 1, right, temp);\n    count += merge(nums, left, mid, right, temp);\n    \n    return count;\n}\n\nprivate int merge(int[] nums, int left, int mid, int right, int[] temp) {\n    int count = 0;\n    System.arraycopy(nums, left, temp, left, right - left + 1);\n    int j = mid + 1;\n    for (int i = left; i <= mid; i++) {\n        while (j <= right && (long) nums[i] > 2L * nums[j]) {\n            j++;\n        }\n        count += j - (mid + 1);\n    }\n    int i = left;\n    j = mid + 1;\n    int k = left;\n    while (i <= mid && j <= right) {\n        if (temp[i] <= temp[j]) {\n            nums[k++] = temp[i++];\n        } else {\n            nums[k++] = temp[j++];\n        }\n    }\n    while (i <= mid) {\n        nums[k++] = temp[i++];\n    }\n    while (j <= right) {\n        nums[k++] = temp[j++];\n    }\n    \n    return count;\n}\n",
            "python": "def reversePairs(nums):\n    def mergeSort(l, r):\n        if l >= r:\n            return 0\n        \n        mid = (l + r) // 2\n        count = mergeSort(l, mid) + mergeSort(mid + 1, r)\n        j = mid + 1\n        for i in range(l, mid + 1):\n            while j <= r and nums[i] > 2 * nums[j]:\n                j += 1\n            count += j - (mid + 1)\n        \n        nums[l:r + 1] = sorted(nums[l:r + 1])\n        \n        return count\n    \n    return mergeSort(0, len(nums) - 1)\n\n",
            "javascript": "function reversePairs(nums) {\n    function mergeSort(l, r) {\n        if (l >= r) {\n            return 0;\n        }\n\n        const mid = Math.floor((l + r) / 2);\n        let count = mergeSort(l, mid) + mergeSort(mid + 1, r);\n        let j = mid + 1;\n        for (let i = l; i <= mid; i++) {\n            while (j <= r && nums[i] > 2 * nums[j]) {\n                j++;\n            }\n            count += j - (mid + 1);\n        }\n\n        const merged = nums.slice(l, r + 1).sort((a, b) => a - b);\n        nums.splice(l, merged.length, ...merged);\n\n        return count;\n    }\n\n    return mergeSort(0, nums.length - 1);\n}\n\n\n",
            "explanation": "The algorithm uses a modified merge sort to solve the problem efficiently. It counts the number of reverse pairs during the merge process, compares the elements in the left subarray with those in the right subarray, and increments the count based on the condition `nums[i] > 2 * nums[j]`. The merge sort divides the array into smaller subarrays, which are recursively sorted and merged.\n\nFor each subarray, we use two pointers `i` and `j` to find out the number of reverse pairs that satisfy the condition `nums[i] > 2 * nums[j]`. When iterating through the left subarray with `i`, we move `j` from the right subarray until we find the first index that doesn't satisfy the condition or we reach the end of the right subarray. The difference between the current position of `j` and the starting position is the count of valid reverse pairs. To get the overall count, we sum up the count value from both the left and right subarrays and also add the count found during merging the subarrays.\n\nFinally, we merge the sorted subarrays using built-in sort functions. The process is similar in all four languages: C++ uses `std::merge` and `std::copy`, Java uses `System.arraycopy`, Python uses list slicing with `sorted()`, and JavaScript uses `Array.prototype.sort()` and `Array.prototype.splice()`.\n\nThe time complexity of the algorithm is O(n log n), as it takes advantage of the merge sort structure."
        },
        "structure": {
            "c++": "#include <vector>\n\nint merge(std::vector<int>& nums, std::vector<int>& temp, int left, int mid, int right)  {\n    // Your code here\n}\n",
            "java": "public int reversePairs(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def reversePairs(nums):\n    # Your code here\n\n",
            "javascript": "function reversePairs(nums)  {\n    // Your code here\n}\n\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nint merge(std::vector<int>& nums, std::vector<int>& temp, int left, int mid, int right) {\n    int count = 0;\n    int j = mid;\n    for (int i = left; i < mid; i++) {\n        while (j <= right && (long long)nums[i] > 2LL * nums[j]) {\n            j++;\n        }\n        count += j - mid;\n    }\n    std::merge(nums.begin() + left, nums.begin() + mid, nums.begin() + mid, nums.begin() + right + 1, temp.begin() + left);\n    \n    return count;\n}\n\nint countReversePairs(std::vector<int>& nums, std::vector<int>& temp, int left, int right) {\n    if (left >= right) {\n        return 0;\n    }\n    int mid = left + (right - left) / 2;\n    int count = countReversePairs(nums, temp, left, mid) + countReversePairs(nums, temp, mid + 1, right);\n    count += merge(nums, temp, left, mid + 1, right);\n    std::copy(temp.begin() + left, temp.begin() + right + 1, nums.begin() + left);\n    \n    return count;\n}\n\nint reversePairs(std::vector<int>& nums) {\n    std::vector<int> temp(nums.size());\n    return countReversePairs(nums, temp, 0, nums.size() - 1);\n}\n\nint main() {\n    std::vector<int> nums = $args;\n    int result = reversePairs(nums);\n    std::cout << result << std::endl;\n    return 0;\n}",
            "java": "public int reversePairs(int[] nums) {\n    return mergeSort(nums, 0, nums.length - 1, new int[nums.length]);\n}\n\nprivate int mergeSort(int[] nums, int left, int right, int[] temp) {\n    if (left >= right) {\n        return 0;\n    }\n    int mid = left + (right - left) / 2;\n    int count = mergeSort(nums, left, mid, temp) + mergeSort(nums, mid + 1, right, temp);\n    count += merge(nums, left, mid, right, temp);\n    \n    return count;\n}\n\nprivate int merge(int[] nums, int left, int mid, int right, int[] temp) {\n    int count = 0;\n    System.arraycopy(nums, left, temp, left, right - left + 1);\n    int j = mid + 1;\n    for (int i = left; i <= mid; i++) {\n        while (j <= right && (long) nums[i] > 2L * nums[j]) {\n            j++;\n        }\n        count += j - (mid + 1);\n    }\n    int i = left;\n    j = mid + 1;\n    int k = left;\n    while (i <= mid && j <= right) {\n        if (temp[i] <= temp[j]) {\n            nums[k++] = temp[i++];\n        } else {\n            nums[k++] = temp[j++];\n        }\n    }\n    while (i <= mid) {\n        nums[k++] = temp[i++];\n    }\n    while (j <= right) {\n        nums[k++] = temp[j++];\n    }\n    \n    return count;\n}",
            "python": "if __name__ == \"__main__\":\n    nums = $args\n    result = reversePairs(nums)\n    print(result)",
            "javascript": "function reversePairs(nums) {\n    function mergeSort(l, r) {\n        if (l >= r) {\n            return 0;\n        }\n\n        const mid = Math.floor((l + r) / 2);\n        let count = mergeSort(l, mid) + mergeSort(mid + 1, r);\n        let j = mid + 1;\n        for (let i = l; i <= mid; i++) {\n            while (j <= r && nums[i] > 2 * nums[j]) {\n                j++;\n            }\n            count += j - (mid + 1);\n        }\n\n        const merged = nums.slice(l, r + 1).sort((a, b) => a - b);\n        nums.splice(l, merged.length, ...merged);\n\n        return count;\n    }\n\n    return mergeSort(0, nums.length - 1);\n}"
        },
        "Qid": "493"
    },
    {
        "_id": {
            "$oid": "6629b26fbaf481a372cdfe3d"
        },
        "title": "Expression Builder",
        "description": "You are given an integer array `nums` and an integer `target`. You want to build an **expression** out of nums by adding one of the symbols `'+'` and `'-'` before each integer in nums and then concatenate them to build the expression. Return the number of different **expressions** that you can build, which evaluates to `target`.",
        "example": "Example:\n\nInput: nums = [1,1,1,1,1], target = 3\nOutput: 5\nExplanation: There are 5 ways to assign symbols to make the sum of nums be target 3.\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3",
        "level": "Medium",
        "tags": [
            "array",
            "dynamic programming"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    3
                ],
                [
                    [
                        1
                    ],
                    1
                ],
                [
                    [
                        2,
                        3,
                        4,
                        5
                    ],
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    0
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    15
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    -5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    100
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    -100
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    1
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    2
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    3
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    4
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    5
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    6
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    7
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    8
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    9
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    10
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    11
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    12
                ]
            ],
            "outputs": [
                5,
                1,
                2,
                0,
                2,
                2,
                0,
                0,
                1,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n\nint findTargetSumWays(std::vector<int>& nums, int target) {\n    int sum = 0;\n    for (int num : nums) sum += num;\n    if (sum < target || (sum + target) % 2 != 0) return 0;\n    int target_sum = (sum + target) / 2;\n    std::vector<int> dp(target_sum + 1, 0);\n    dp[0] = 1;\n    for (int num : nums) {\n        for (int j = target_sum; j >= num; j--) {\n            dp[j] += dp[j - num];\n        }\n    }\n    return dp[target_sum];\n}\n\n",
            "java": "public int findTargetSumWays(int[] nums, int target) {\n    int sum = 0;\n    for (int num : nums) sum += num;\n    if (sum < target || (sum + target) % 2 != 0) return 0;\n    int target_sum = (sum + target) / 2;\n    int[] dp = new int[target_sum + 1];\n    dp[0] = 1;\n    for (int num : nums) {\n        for (int j = target_sum; j >= num; j--) {\n            dp[j] += dp[j - num];\n        }\n    }\n    return dp[target_sum];\n}\n\n",
            "python": "def findTargetSumWays(nums, target):\n    total_sum = sum(nums)\n    if total_sum < target or (total_sum + target) % 2 != 0:\n        return 0\n    target_sum = (total_sum + target) // 2\n    dp = [0] * (target_sum + 1)\n    dp[0] = 1\n    for num in nums:\n        for j in range(target_sum, num - 1, -1):\n            dp[j] += dp[j - num]\n    return dp[target_sum]\n\n",
            "javascript": "function findTargetSumWays(nums, target) {\n    let sum = nums.reduce((a, b) => a + b);\n    if (sum < target || (sum + target) % 2 !== 0) return 0;\n    let target_sum = (sum + target) >> 1;\n    let dp = new Array(target_sum + 1).fill(0);\n    dp[0] = 1;\n    for (const num of nums) {\n        for (let j = target_sum; j >= num; j--) {\n            dp[j] += dp[j - num];\n        }\n    }\n    return dp[target_sum];\n}\n\n",
            "explanation": "The problem can be reduced to a subset sum problem by doing some simple math. First, calculate the sum of all numbers in the array. If the sum of integers is less than the target value or the total sum with target value is odd, there are no possible combinations.\n\nThe required subset sum is (sum + target) / 2. We will use dynamic programming to count the number of subsets with the target sum. Initialize a DP array of size `target_sum + 1` and set the first value to 1 because the empty subset adds up to 0.\n\nIterate through the given numbers and for each number, update the values in DP array by enumerating the subsets with the i-th number included as follows:\n\n1. If the current number is less than or equal to the target_sum, calculate the new value of the current subset by adding the value at a position shifted by the current number.\n\n2. Store the new value and the current number in the DP array.\n\nReturn the greater number of different target-sum expressions saved in the DP array."
        },
        "structure": {
            "c++": "#include <vector>\n\nint findTargetSumWays(std::vector<int>& nums, int target)  {\n    // Your code here\n}\n\n",
            "java": "public int findTargetSumWays(int[] nums, int target)  {\n    // Your code here\n}\n\n",
            "python": "def findTargetSumWays(nums, target):\n    # Your code here\n\n",
            "javascript": "function findTargetSumWays(nums, target)  {\n    // Your code here\n}\n\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <iostream>\n\nint findTargetSumWays(std::vector<int>& nums, int target);\n\nint main() {\n    std::vector<int> nums = $args;\n    int target = $args;\n    int result = findTargetSumWays(nums, target);\n    std::cout << result << std::endl;\n    return 0;\n}\n",
            "java": "public int findTargetSumWays(int[] nums, int target) {\n    int sum = 0;\n    for (int num : nums) sum += num;\n    if (sum < target || (sum + target) % 2 != 0) return 0;\n    int target_sum = (sum + target) / 2;\n    int[] dp = new int[target_sum + 1];\n    dp[0] = 1;\n    for (int num : nums) {\n        for (int j = target_sum; j >= num; j--) {\n            dp[j] += dp[j - num];\n        }\n    }\n    return dp[target_sum];\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    nums = inputs[0]\n    target = inputs[1]\n    result = findTargetSumWays(nums, target)\n    print(result)",
            "javascript": "function findTargetSumWays(nums, target) {\n    let sum = nums.reduce((a, b) => a + b);\n    if (sum < target || (sum + target) % 2 !== 0) return 0;\n    let target_sum = (sum + target) >> 1;\n    let dp = new Array(target_sum + 1).fill(0);\n    dp[0] = 1;\n    for (const num of nums) {\n        for (let j = target_sum; j >= num; j--) {\n            dp[j] += dp[j - num];\n        }\n    }\n    return dp[target_sum];\n}"
        },
        "Qid": "494"
    },
    {
        "_id": {
            "$oid": "6629bfd0baf481a372cdfe3e"
        },
        "title": "Next Greater Element",
        "description": "Given two distinct 0-indexed integer arrays `nums1` and `nums2`, where `nums1` is a subset of `nums2`, find the next greater element for each value of `nums1` in `nums2`. The next greater element of some element `x` in an array is the first greater element that is to the right of `x` in the same array. If there is no next greater element, the answer is -1.",
        "example": "Example 1:\n\nInput: nums1 = [4,1,2], nums2 = [1,3,4,2]\nOutput: [-1,3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n\nExample 2:\n\nInput: nums1 = [2,4], nums2 = [1,2,3,4]\nOutput: [3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1.",
        "level": "Medium",
        "tags": [
            "array",
            "stack"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        4,
                        1,
                        2
                    ],
                    [
                        1,
                        3,
                        4,
                        2
                    ]
                ],
                [
                    [
                        2,
                        4
                    ],
                    [
                        1,
                        2,
                        3,
                        4
                    ]
                ],
                [
                    [
                        1,
                        3,
                        5,
                        7
                    ],
                    [
                        2,
                        4,
                        6,
                        8
                    ]
                ],
                [
                    [
                        9,
                        8,
                        7,
                        6
                    ],
                    [
                        1,
                        2,
                        3,
                        4
                    ]
                ],
                [
                    [
                        5,
                        10,
                        15
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        4,
                        3,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        1,
                        2,
                        3,
                        4
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        4,
                        3,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        15,
                        14,
                        13,
                        12,
                        11,
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        5,
                        10,
                        15,
                        20,
                        25,
                        30,
                        35,
                        40,
                        45,
                        50,
                        55,
                        60,
                        65,
                        70,
                        75
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        15,
                        14,
                        13,
                        12,
                        11,
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1,
                        16,
                        17,
                        18,
                        19,
                        20
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        15,
                        14,
                        13,
                        12,
                        11,
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1,
                        20,
                        19,
                        18,
                        17,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        15,
                        14,
                        13,
                        12,
                        11,
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1,
                        20,
                        19,
                        18,
                        17,
                        16,
                        21,
                        22,
                        23,
                        24,
                        25
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        15,
                        14,
                        13,
                        12,
                        11,
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1,
                        25,
                        24,
                        23,
                        22,
                        21,
                        20,
                        19,
                        18,
                        17,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        15,
                        14,
                        13,
                        12,
                        11,
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1,
                        25,
                        24,
                        23,
                        22,
                        21,
                        20,
                        19,
                        18,
                        17,
                        16,
                        26,
                        27,
                        28,
                        29,
                        30
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        15,
                        14,
                        13,
                        12,
                        11,
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1,
                        30,
                        29,
                        28,
                        27,
                        26,
                        25,
                        24,
                        23,
                        22,
                        21,
                        20,
                        19,
                        18,
                        17,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        15,
                        14,
                        13,
                        12,
                        11,
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1,
                        30,
                        29,
                        28,
                        27,
                        26,
                        25,
                        24,
                        23,
                        22,
                        21,
                        20,
                        19,
                        18,
                        17,
                        16,
                        31,
                        32,
                        33,
                        34,
                        35
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        15,
                        14,
                        13,
                        12,
                        11,
                        10,
                        9,
                        8,
                        7,
                        6,
                        5,
                        4,
                        3,
                        2,
                        1,
                        35,
                        34,
                        33,
                        32,
                        31,
                        30,
                        29,
                        28,
                        27,
                        26,
                        25,
                        24,
                        23,
                        22,
                        21,
                        20,
                        19,
                        18,
                        17,
                        16
                    ]
                ]
            ],
            "outputs": [
                [
                    -1,
                    3,
                    -1
                ],
                [
                    3,
                    -1
                ],
                [
                    3,
                    6,
                    8,
                    -1
                ],
                [
                    -1,
                    -1,
                    -1,
                    -1
                ],
                [
                    10,
                    15,
                    -1
                ],
                [
                    -1,
                    -1,
                    -1,
                    -1
                ],
                [
                    -1,
                    -1,
                    -1,
                    -1
                ],
                [
                    2,
                    3,
                    4,
                    -1
                ],
                [
                    -1,
                    -1,
                    -1,
                    -1
                ],
                [
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1
                ],
                [
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1
                ],
                [
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    20,
                    25,
                    30,
                    35,
                    40,
                    45,
                    50,
                    55,
                    60,
                    65,
                    70,
                    75,
                    -1,
                    -1,
                    -1
                ],
                [
                    20,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    20,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    25,
                    24,
                    23,
                    22,
                    21,
                    20,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    25,
                    24,
                    23,
                    22,
                    21,
                    20,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    30,
                    29,
                    28,
                    27,
                    26,
                    25,
                    24,
                    23,
                    22,
                    21,
                    20,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    30,
                    29,
                    28,
                    27,
                    26,
                    25,
                    24,
                    23,
                    22,
                    21,
                    20,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    35,
                    34,
                    33,
                    32,
                    31,
                    30,
                    29,
                    28,
                    27,
                    26,
                    25,
                    24,
                    23,
                    22,
                    21,
                    20,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    35,
                    34,
                    33,
                    32,
                    31,
                    30,
                    29,
                    28,
                    27,
                    26,
                    25,
                    24,
                    23,
                    22,
                    21,
                    20,
                    19,
                    18,
                    17,
                    16,
                    15,
                    14,
                    13,
                    12,
                    11,
                    10,
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <stack>\n#include <unordered_map>\n\nstd::vector<int> nextGreaterElement(std::vector<int>& nums1, std::vector<int>& nums2) {\n    std::unordered_map<int, int> nextGreater;\n    std::stack<int> stk;\n\n    for (int num : nums2) {\n        while (!stk.empty() && stk.top() < num) {\n            nextGreater[stk.top()] = num;\n            stk.pop();\n        }\n        stk.push(num);\n    }\n\n    std::vector<int> result(nums1.size());\n    for (size_t i = 0; i < nums1.size(); ++i) {\n        result[i] = nextGreater.count(nums1[i]) ? nextGreater[nums1[i]] : -1;\n    }\n\n    return result;\n}\n",
            "java": "import java.util.HashMap;\nimport java.util.Stack;\n\npublic int[] nextGreaterElement(int[] nums1, int[] nums2) {\n    HashMap<Integer, Integer> nextGreater = new HashMap<>();\n    Stack<Integer> stack = new Stack<>();\n\n    for (int num : nums2) {\n        while (!stack.isEmpty() && stack.peek() < num) {\n            nextGreater.put(stack.pop(), num);\n        }\n        stack.push(num);\n    }\n\n    int[] result = new int[nums1.length];\n    for (int i = 0; i < nums1.length; i++) {\n        result[i] = nextGreater.getOrDefault(nums1[i], -1);\n    }\n\n    return result;\n}\n",
            "python": "def next_greater_element(nums1, nums2):\n    next_greater = {}\n    stack = []\n\n    for num in nums2:\n        while stack and stack[-1] < num:\n            next_greater[stack.pop()] = num\n        stack.append(num)\n\n    return [next_greater.get(n, -1) for n in nums1]\n",
            "javascript": "function nextGreaterElement(nums1, nums2) {\n    const nextGreater = new Map();\n    const stack = [];\n\n    nums2.forEach(num => {\n        while (stack.length && stack[stack.length - 1] < num) {\n            nextGreater.set(stack.pop(), num);\n        }\n        stack.push(num);\n    });\n\n    return nums1.map(n => nextGreater.get(n) || -1);\n}\n",
            "explanation": "The algorithm uses a stack, following these steps:\n1. Initialize an empty stack.\n2. Iterate through nums2 elements:\n   a. While the stack is not empty and the top of the stack is less than the current nums2 element, add the next greater element of the top of the stack as the current nums2 element and pop it.\n   b. Push the current nums2 element into the stack.\n3. For every element in nums1, get the next greater element found in step 2 or -1 if no such element was found.\n4. Return the result array.\n\nThe key point is using the stack to keep track of the previous elements that still need to find their next greater element while iterating nums2 in a single pass. This ensures that the algorithm runs in linear O(n) time complexity."
        },
        "structure": {
            "c++": "#include <vector>\n#include <stack>\n#include <unordered_map>\n\nstd::vector<int> nextGreaterElement(std::vector<int>& nums1, std::vector<int>& nums2)  {\n    // Your code here\n}\n",
            "java": "import java.util.HashMap;\nimport java.util.Stack;\n\npublic int[] nextGreaterElement(int[] nums1, int[] nums2)  {\n    // Your code here\n}\n",
            "python": "def next_greater_element(nums1, nums2):\n    # Your code here\n\n",
            "javascript": "function nextGreaterElement(nums1, nums2)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <stack>\n#include <unordered_map>\n\nstd::vector<int> nextGreaterElement(std::vector<int>& nums1, std::vector<int>& nums2) {\n    std::unordered_map<int, int> nextGreater;\n    std::stack<int> stk;\n\n    for (int num : nums2) {\n        while (!stk.empty() && stk.top() < num) {\n            nextGreater[stk.top()] = num;\n            stk.pop();\n        }\n        stk.push(num);\n    }\n\n    std::vector<int> result(nums1.size());\n    for (size_t i = 0; i < nums1.size(); ++i) {\n        result[i] = nextGreater.count(nums1[i]) ? nextGreater[nums1[i]] : -1;\n    }\n\n    return result;\n}",
            "java": "public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n    HashMap<Integer, Integer> nextGreater = new HashMap<>();\n    Stack<Integer> stack = new Stack<>();\n\n    for (int num : nums2) {\n        while (!stack.isEmpty() && stack.peek() < num) {\n            nextGreater.put(stack.pop(), num);\n        }\n        stack.push(num);\n    }\n\n    int[] result = new int[nums1.length];\n    for (int i = 0; i < nums1.length; i++) {\n        result[i] = nextGreater.getOrDefault(nums1[i], -1);\n    }\n\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    nums1 = inputs[0]\n    nums2 = inputs[1]\n    result = next_greater_element(nums1, nums2)\n    print(result)",
            "javascript": "function main() {\n    const nums1 = $args[0];\n    const nums2 = $args[1];\n    const nextGreater = new Map();\n    const stack = [];\n\n    nums2.forEach(num => {\n        while (stack.length && stack[stack.length - 1] < num) {\n            nextGreater.set(stack.pop(), num);\n        }\n        stack.push(num);\n    });\n\n    const result = nums1.map(n => nextGreater.get(n) || -1);\n    console.log(result);\n}"
        },
        "Qid": "496"
    },
    {
        "_id": {
            "$oid": "6629c09abaf481a372cdfe3f"
        },
        "title": "Diagonal Order",
        "description": "Given an `m x n` matrix `mat`, return an array of all the elements of the array in a diagonal order.",
        "example": "Example 1:\n\nInput: mat = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,4,7,5,3,6,8,9]\n\nExample 2:\n\nInput: mat = [[1,2],[3,4]]\nOutput: [1,2,3,4]",
        "level": "Easy",
        "tags": [
            "array",
            "matrix"
        ],
        "test_cases": {
            "inputs": [
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    [
                        1,
                        2
                    ],
                    [
                        3,
                        4
                    ],
                    [
                        5,
                        6
                    ],
                    [
                        7,
                        8
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9,
                        10,
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ],
                    [
                        7,
                        8,
                        9
                    ],
                    [
                        10,
                        11,
                        12
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15
                    ],
                    [
                        16,
                        17,
                        18,
                        19,
                        20
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16
                    ],
                    [
                        17,
                        18,
                        19,
                        20
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7
                    ],
                    [
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16
                    ],
                    [
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15,
                        16
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16
                    ],
                    [
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24
                    ],
                    [
                        25,
                        26,
                        27,
                        28
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    [
                        10,
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16
                    ],
                    [
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24
                    ],
                    [
                        25,
                        26,
                        27,
                        28
                    ],
                    [
                        29,
                        30,
                        31,
                        32
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ],
                    [
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16
                    ],
                    [
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24
                    ],
                    [
                        25,
                        26,
                        27,
                        28
                    ],
                    [
                        29,
                        30,
                        31,
                        32
                    ],
                    [
                        33,
                        34,
                        35,
                        36
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    [
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20,
                        21,
                        22
                    ]
                ],
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ],
                    [
                        5,
                        6,
                        7,
                        8
                    ],
                    [
                        9,
                        10,
                        11,
                        12
                    ],
                    [
                        13,
                        14,
                        15,
                        16
                    ],
                    [
                        17,
                        18,
                        19,
                        20
                    ],
                    [
                        21,
                        22,
                        23,
                        24
                    ],
                    [
                        25,
                        26,
                        27,
                        28
                    ],
                    [
                        29,
                        30,
                        31,
                        32
                    ],
                    [
                        33,
                        34,
                        35,
                        36
                    ],
                    [
                        37,
                        38,
                        39,
                        40
                    ]
                ]
            ],
            "outputs": [
                [
                    1,
                    2,
                    4,
                    7,
                    5,
                    3,
                    6,
                    8,
                    9
                ],
                [
                    1,
                    2,
                    3,
                    4
                ],
                [
                    1,
                    2,
                    5,
                    9,
                    6,
                    3,
                    4,
                    7,
                    10,
                    11,
                    8,
                    12
                ],
                [
                    1,
                    2,
                    4,
                    5,
                    3,
                    6
                ],
                [
                    1,
                    2,
                    6,
                    11,
                    7,
                    3,
                    4,
                    8,
                    12,
                    13,
                    9,
                    5,
                    10,
                    14,
                    15
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8
                ],
                [
                    1,
                    2,
                    7,
                    12,
                    8,
                    3,
                    4,
                    9,
                    13,
                    14,
                    10,
                    5,
                    6,
                    11,
                    15
                ],
                [
                    1,
                    2,
                    4,
                    7,
                    5,
                    3,
                    8,
                    11,
                    9,
                    6,
                    10,
                    12
                ],
                [
                    1,
                    2,
                    4,
                    7,
                    5,
                    3,
                    8,
                    12,
                    9,
                    6,
                    10,
                    13,
                    16,
                    11,
                    14,
                    15
                ],
                [
                    1,
                    2,
                    4,
                    7,
                    5,
                    3,
                    8,
                    12,
                    9,
                    6,
                    10,
                    13,
                    17,
                    14,
                    11,
                    15,
                    18,
                    19,
                    16,
                    20
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12
                ],
                [
                    1,
                    2,
                    4,
                    7,
                    5,
                    3,
                    8,
                    12,
                    9,
                    6,
                    10,
                    13,
                    17,
                    14,
                    11,
                    15,
                    18,
                    21,
                    19,
                    16,
                    20,
                    22,
                    23
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14
                ],
                [
                    1,
                    2,
                    4,
                    7,
                    5,
                    3,
                    8,
                    12,
                    9,
                    6,
                    10,
                    13,
                    17,
                    14,
                    11,
                    15,
                    18,
                    21,
                    19,
                    16,
                    20,
                    22,
                    25,
                    23,
                    26,
                    27
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16
                ],
                [
                    1,
                    2,
                    4,
                    7,
                    5,
                    3,
                    8,
                    12,
                    9,
                    6,
                    10,
                    13,
                    17,
                    14,
                    11,
                    15,
                    18,
                    21,
                    19,
                    16,
                    20,
                    22,
                    25,
                    23,
                    26,
                    27,
                    29,
                    30,
                    28,
                    31,
                    32
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18
                ],
                [
                    1,
                    2,
                    4,
                    7,
                    5,
                    3,
                    8,
                    12,
                    9,
                    6,
                    10,
                    13,
                    17,
                    14,
                    11,
                    15,
                    18,
                    21,
                    19,
                    16,
                    20,
                    22,
                    25,
                    23,
                    26,
                    27,
                    29,
                    30,
                    28,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20
                ],
                [
                    1,
                    2,
                    4,
                    7,
                    5,
                    3,
                    8,
                    12,
                    9,
                    6,
                    10,
                    13,
                    17,
                    14,
                    11,
                    15,
                    18,
                    21,
                    19,
                    16,
                    20,
                    22,
                    25,
                    23,
                    26,
                    27,
                    29,
                    30,
                    28,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> findDiagonalOrder(vector<vector<int>>& mat) {\n    int m = mat.size();\n    int n = mat[0].size();\n    vector<int> result(m * n);\n    int row = 0, col = 0;\n    for (int i = 0; i < m * n; i++) {\n        result[i] = mat[row][col];\n        if ((row + col) % 2 == 0) {\n            if (col == n - 1) {\n                row++;\n            } else if (row == 0) {\n                col++;\n            } else {\n                row--;\n                col++;\n            }\n        } else {\n            if (row == m - 1) {\n                col++;\n            } else if (col == 0) {\n                row++;\n            } else {\n                row++;\n                col--;\n            }\n        }\n    }\n    return result;\n}\n",
            "java": "import java.util.Arrays;\n\npublic int[] findDiagonalOrder(int[][] mat) {\n    int m = mat.length;\n    int n = mat[0].length;\n    int[] result = new int[m * n];\n    int row = 0, col = 0;\n    for (int i = 0; i < m * n; i++) {\n        result[i] = mat[row][col];\n        if ((row + col) % 2 == 0) {\n            if (col == n - 1) {\n                row++;\n            } else if (row == 0) {\n                col++;\n            } else {\n                row--;\n                col++;\n            }\n        } else {\n            if (row == m - 1) {\n                col++;\n            } else if (col == 0) {\n                row++;\n            } else {\n                row++;\n                col--;\n            }\n        }\n    }\n    return result;\n}\n",
            "python": "from typing import List\n\ndef findDiagonalOrder(mat: List[List[int]]) -> List[int]:\n    m, n = len(mat), len(mat[0])\n    result = [0] * (m * n)\n    row, col = 0, 0\n    for i in range(m * n):\n        result[i] = mat[row][col]\n        if (row + col) % 2 == 0:\n            if col == n - 1:\n                row += 1\n            elif row == 0:\n                col += 1\n            else:\n                row -= 1\n                col += 1\n        else:\n            if row == m - 1:\n                col += 1\n            elif col == 0:\n                row += 1\n            else:\n                row += 1\n                col -= 1\n    return result\n",
            "javascript": "function findDiagonalOrder(mat) {\n    const m = mat.length;\n    const n = mat[0].length;\n    const result = new Array(m * n);\n    let row = 0, col = 0;\n    for (let i = 0; i < m * n; i++) {\n        result[i] = mat[row][col];\n        if ((row + col) % 2 === 0) {\n            if (col === n - 1) {\n                row++;\n            } else if (row === 0) {\n                col++;\n            } else {\n                row--;\n                col++;\n            }\n        } else {\n            if (row === m - 1) {\n                col++;\n            } else if (col === 0) {\n                row++;\n            } else {\n                row++;\n                col--;\n            }\n        }\n    }\n    return result;\n}\n",
            "explanation": "The algorithm iterates through each element of the matrix in a diagonal order. We set up a double loop that runs through the total number of elements in the matrix (m * n). We keep track of the current row and column while iterating. \n\nWe use a conditional statement to check if the sum of the current row and column is even, which means we need to move up diagonally to the right. If we are at the right edge, we move down one row. If we are at the top edge, we move right one column. Otherwise, we move up diagonally (row - 1, col + 1).\n\nIf the sum of the current row and column is odd, it means we need to move down diagonally to the left. If we are at the bottom edge, we move right one column. If we are at the left edge, we move down one row. Otherwise, we move down diagonally (row + 1, col - 1)."
        },
        "structure": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> findDiagonalOrder(vector<vector<int>>& mat)  {\n    // Your code here\n}\n",
            "java": "import java.util.Arrays;\n\npublic int[] findDiagonalOrder(int[][] mat)  {\n    // Your code here\n}\n",
            "python": "from typing import List\n    # Your code here\n\n",
            "javascript": "function findDiagonalOrder(mat)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\nusing namespace std;\n\nvector<int> findDiagonalOrder(vector<vector<int>>& mat) {\n    int m = mat.size();\n    int n = mat[0].size();\n    vector<int> result(m * n);\n    int row = 0, col = 0;\n    for (int i = 0; i < m * n; i++) {\n        result[i] = mat[row][col];\n        if ((row + col) % 2 == 0) {\n            if (col == n - 1) {\n                row++;\n            } else if (row == 0) {\n                col++;\n            } else {\n                row--;\n                col++;\n            }\n        } else {\n            if (row == m - 1) {\n                col++;\n            } else if (col == 0) {\n                row++;\n            } else {\n                row++;\n                col--;\n            }\n        }\n    }\n    return result;\n}\n\nint main() {\n    vector<vector<int>> mat = $args;\n    vector<int> result = findDiagonalOrder(mat);\n    for (int i = 0; i < result.size(); i++) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
            "java": "public int[] findDiagonalOrder(int[][] mat) {\n    int m = mat.length;\n    int n = mat[0].length;\n    int[] result = new int[m * n];\n    int row = 0, col = 0;\n    for (int i = 0; i < m * n; i++) {\n        result[i] = mat[row][col];\n        if ((row + col) % 2 == 0) {\n            if (col == n - 1) {\n                row++;\n            } else if (row == 0) {\n                col++;\n            } else {\n                row--;\n                col++;\n            }\n        } else {\n            if (row == m - 1) {\n                col++;\n            } else if (col == 0) {\n                row++;\n            } else {\n                row++;\n                col--;\n            }\n        }\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    mat =$args\n    result = findDiagonalOrder(mat)\n    print(result)",
            "javascript": "function findDiagonalOrder(mat) {\n    const m = mat.length;\n    const n = mat[0].length;\n    const result = new Array(m * n);\n    let row = 0, col = 0;\n    for (let i = 0; i < m * n; i++) {\n        result[i] = mat[row][col];\n        if ((row + col) % 2 === 0) {\n            if (col === n - 1) {\n                row++;\n            } else if (row === 0) {\n                col++;\n            } else {\n                row--;\n                col++;\n            }\n        } else {\n            if (row === m - 1) {\n                col++;\n            } else if (col === 0) {\n                row++;\n            } else {\n                row++;\n                col--;\n            }\n        }\n    }\n    return result;\n}"
        },
        "Qid": "498"
    },
    {
        "_id": {
            "$oid": "662af5573cdc8feb456b7ef0"
        },
        "title": "Maximize Capital",
        "description": "LeetCode is planning to start its IPO and wants to work on some projects to increase its capital before the IPO. However, there is a limit on the number of projects they can finish before the IPO. LeetCode needs your help to design the best way to maximize its total capital after finishing at most `k` distinct projects. You are given `n` projects, each with a pure profit `profits[i]` and a minimum capital `capital[i]` needed to start it. Initially, you have `w` capital. When you finish a project, you obtain its pure profit, which is added to your total capital. Pick a list of at most `k` distinct projects to maximize your final capital and return the final maximized capital. The answer is guaranteed to fit in a 32-bit signed integer.",
        "example": "Example:\n\nInput: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\nOutput: 4\nExplanation: Since your initial capital is 0, you can only start the project indexed 0. After finishing it, you will obtain profit 1 and your capital becomes 1. With capital 1, you can either start the project indexed 1 or the project indexed 2. Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital. Therefore, the final maximized capital is 0 + 1 + 3 = 4.",
        "level": "Medium",
        "tags": [
            "Greedy",
            "Heap",
            "Sorting"
        ],
        "test_cases": {
            "inputs": [
                [
                    2,
                    0,
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        0,
                        1,
                        1
                    ]
                ],
                [
                    3,
                    0,
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        0,
                        1,
                        2
                    ]
                ],
                [
                    1,
                    10,
                    [
                        5,
                        10,
                        15
                    ],
                    [
                        0,
                        5,
                        10
                    ]
                ],
                [
                    5,
                    100,
                    [
                        10,
                        20,
                        30,
                        40,
                        50
                    ],
                    [
                        0,
                        10,
                        20,
                        30,
                        40
                    ]
                ],
                [
                    4,
                    5,
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        0,
                        1,
                        2,
                        3,
                        4
                    ]
                ],
                [
                    2,
                    1000,
                    [
                        100,
                        200,
                        300,
                        400,
                        500
                    ],
                    [
                        0,
                        100,
                        200,
                        300,
                        400
                    ]
                ],
                [
                    3,
                    50,
                    [
                        10,
                        20,
                        30,
                        40,
                        50
                    ],
                    [
                        0,
                        10,
                        20,
                        30,
                        40
                    ]
                ],
                [
                    1,
                    0,
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        0,
                        1,
                        2,
                        3,
                        4
                    ]
                ],
                [
                    5,
                    100,
                    [
                        10,
                        20,
                        30,
                        40,
                        50
                    ],
                    [
                        0,
                        10,
                        20,
                        30,
                        40
                    ]
                ],
                [
                    4,
                    5,
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        0,
                        1,
                        2,
                        3,
                        4
                    ]
                ],
                [
                    2,
                    1000,
                    [
                        100,
                        200,
                        300,
                        400,
                        500
                    ],
                    [
                        0,
                        100,
                        200,
                        300,
                        400
                    ]
                ],
                [
                    3,
                    50,
                    [
                        10,
                        20,
                        30,
                        40,
                        50
                    ],
                    [
                        0,
                        10,
                        20,
                        30,
                        40
                    ]
                ],
                [
                    1,
                    0,
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        0,
                        1,
                        2,
                        3,
                        4
                    ]
                ],
                [
                    5,
                    100,
                    [
                        10,
                        20,
                        30,
                        40,
                        50
                    ],
                    [
                        0,
                        10,
                        20,
                        30,
                        40
                    ]
                ],
                [
                    4,
                    5,
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        0,
                        1,
                        2,
                        3,
                        4
                    ]
                ],
                [
                    2,
                    1000,
                    [
                        100,
                        200,
                        300,
                        400,
                        500
                    ],
                    [
                        0,
                        100,
                        200,
                        300,
                        400
                    ]
                ],
                [
                    3,
                    50,
                    [
                        10,
                        20,
                        30,
                        40,
                        50
                    ],
                    [
                        0,
                        10,
                        20,
                        30,
                        40
                    ]
                ],
                [
                    1,
                    0,
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        0,
                        1,
                        2,
                        3,
                        4
                    ]
                ],
                [
                    5,
                    100,
                    [
                        10,
                        20,
                        30,
                        40,
                        50
                    ],
                    [
                        0,
                        10,
                        20,
                        30,
                        40
                    ]
                ],
                [
                    4,
                    5,
                    [
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    [
                        0,
                        1,
                        2,
                        3,
                        4
                    ]
                ],
                [
                    2,
                    1000,
                    [
                        100,
                        200,
                        300,
                        400,
                        500
                    ],
                    [
                        0,
                        100,
                        200,
                        300,
                        400
                    ]
                ]
            ],
            "outputs": [
                4,
                6,
                15,
                150,
                15,
                1500,
                120,
                1,
                150,
                15,
                1500,
                120,
                1,
                150,
                15,
                1500,
                120,
                1,
                150,
                15,
                1500
            ]
        },
        "sample_code": {
            "c++": "#include <queue>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {\n    vector<pair<int, int>> project_pool;\n    \n    for (size_t i = 0; i < profits.size(); i++) {\n        project_pool.emplace_back(capital[i], profits[i]);\n    }\n    \n    sort(project_pool.begin(), project_pool.end());\n    \n    priority_queue<int> profit_pool;\n    int index = 0;\n    \n    for (int i = 0; i < k; i++) {\n        while (index < project_pool.size() &&\n               project_pool[index].first <= w) {\n            profit_pool.push(project_pool[index++].second);\n        }\n        \n        if (!profit_pool.empty()) {\n            w += profit_pool.top();\n            profit_pool.pop();\n        } else {\n            break;\n        }\n    }\n    \n    return w;\n}\n",
            "java": "import java.util.PriorityQueue;\nimport java.util.Arrays;\n\npublic class Solution {\n    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {\n        int[][] project_pool = new int[profits.length][2];\n        \n        for (int i = 0; i < profits.length; i++) {\n            project_pool[i] = new int[] {capital[i], profits[i]};\n        }\n        \n        Arrays.sort(project_pool, (a, b) -> a[0] - b[0]);\n        \n        PriorityQueue<Integer> profit_pool = new PriorityQueue<>((a, b) -> b - a);\n        int index = 0;\n        \n        for (int i = 0; i < k; i++) {\n            while (index < project_pool.length &&\n                   project_pool[index][0] <= w) {\n                profit_pool.add(project_pool[index++][1]);\n            }\n            \n            if (!profit_pool.isEmpty()) {\n                w += profit_pool.poll();\n            } else {\n                break;\n            }\n        }\n        \n        return w;\n    }\n}\n",
            "python": "import heapq\n\ndef findMaximizedCapital(k: int, w: int, profits, capital) -> int:\n    project_pool = list(zip(capital, profits))\n    project_pool.sort(reverse=True)\n    \n    profit_pool = []\n    \n    while k:\n        while project_pool and project_pool[-1][0] <= w:\n            heapq.heappush(profit_pool, -project_pool.pop()[1])\n        \n        if not profit_pool:\n            break\n        \n        w -= heapq.heappop(profit_pool)\n        k -= 1\n        \n    return w\n",
            "javascript": "function findMaximizedCapital(k, w, profits, capital) {\n    const project_pool = profits.map((p, i) => [capital[i], p]).sort((a, b) => a[0] - b[0]);\n    const profit_pool = new MaxPriorityQueue();\n    let index = 0;\n\n    for (let i = 0; i < k; i++) {\n        while (index < project_pool.length && project_pool[index][0] <= w) {\n            profit_pool.insert(project_pool[index++][1]);\n        }\n\n        if (!profit_pool.isEmpty()) {\n            w += profit_pool.removeMax();\n        } else {\n            break;\n        }\n    }\n\n    return w;\n}\n\nclass MaxPriorityQueue {\n    constructor() {\n        this.queue = [];\n    }\n    \n    insert(value) {\n        this.queue.push(value);\n        this.siftUp(this.queue.length - 1);\n    }\n    \n    removeMax() {\n        const maxValue = this.queue[0];\n        const lastValue = this.queue.pop();\n        \n        if (this.queue.length) {\n            this.queue[0] = lastValue;\n            this.siftDown(0);\n        }\n        \n        return maxValue;\n    }\n    \n    siftUp(index) {\n        while (index) {\n            const parentIndex = (index - 1) >> 1;\n            if (this.queue[parentIndex] >= this.queue[index]) break;\n            [this.queue[parentIndex], this.queue[index]] = [this.queue[index], this.queue[parentIndex]];\n            index = parentIndex;\n        }\n    }\n    \n    siftDown(index) {\n        while (true) {\n            const leftIndex = (index << 1) + 1;\n            const rightIndex = leftIndex + 1;\n            let maxIndex = index;\n            if (leftIndex < this.queue.length && this.queue[leftIndex] > this.queue[maxIndex]) maxIndex = leftIndex;\n            if (rightIndex < this.queue.length && this.queue[rightIndex] > this.queue[maxIndex]) maxIndex = rightIndex;\n            if (maxIndex === index) break;\n            [this.queue[index], this.queue[maxIndex]] = [this.queue[maxIndex], this.queue[index]];\n            index = maxIndex;\n        }\n    }\n    \n    isEmpty() {\n        return this.queue.length === 0;\n    }\n}\n",
            "explanation": "1. Create an array of project pool, where each element is a pair of (capital, profit).\n2. Sort the project pool array by capital in ascending order.\n3. Initialize a priority queue called profit pool to store the profits of projects based on which one has the highest profit.\n4. Iterate through projects up to k times.\n5. In each iteration, check projects with capitals less than or equal to w in the project pool, push their profits into the profit pool and remove them from the project pool.\n6. If there is any profit in the profit pool, pop the one with the highest profit and add the profit to w.\n7. Return the final maximized capital w after finishing at most k distinct projects."
        },
        "structure": {
            "c++": "#include <queue>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital)  {\n    // Your code here\n}\n",
            "java": "i {mport java.util.PriorityQueue;\nimport java.util.Arrays;\n\npublic class Solution \n    // Your code here\n}\n",
            "python": "import heapq\n    # Your code here\n\n",
            "javascript": "function findMaximizedCapital(k, w, profits, capital)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <queue>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int k = $args;\n    int w = $args;\n    vector<int> profits = $args;\n    vector<int> capital = $args;\n    \n    int result = findMaximizedCapital(k, w, profits, capital);\n    cout << result << endl;\n    \n    return 0;\n}\n",
            "java": "public int findMaximizedCapital(int k, int w, int[] profits, int[] capital)",
            "python": "if __name__ == \"__main__\":\n    inputs=$args\n    k =inputs[0]\n    w = inputs[1]\n    profits = inputs[2]\n    capital = inputs[3]\n    result = findMaximizedCapital(k, w, profits, capital)\n    print(result)",
            "javascript": "const inputs=$args\nconst k = inputs[0]; // Number of projects to select\nconst w = inputs[1]; // Initial capital\nconst profits = inputs[2]; // Profits for each project\nconst capital = inputs[3]; // Required capital for each project\n\nconst result = findMaximizedCapital(k, w, profits, capital);\n\nconsole.log(result);\n"
        },
        "languages verified": [
            "python",
            "javascript"
        ],
        "Qid": "502"
    },
    {
        "_id": {
            "$oid": "662af5b53cdc8feb456b7ef1"
        },
        "title": "Next Greater Number in Circular Array",
        "description": "Given a circular integer array `nums`, return the next greater number for every element in `nums`. The next greater number of a number `x` is the first greater number to its traversing-order next in the array. If it doesn't exist, return -1 for this number.",
        "example": "Example:\n\nInput: nums = [1,2,1]\nOutput: [2,-1,2]\nExplanation: The first 1's next greater number is 2. The number 2 can't find the next greater number. The second 1's next greater number needs to search circularly, which is also 2.",
        "level": "Medium",
        "tags": [
            "array",
            "circular array",
            "stack"
        ],
        "test_cases": {
            "inputs": [
                [
                    1,
                    2,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    3
                ],
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                [
                    3,
                    1,
                    2,
                    4,
                    5
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                [
                    1
                ],
                [
                    1,
                    1
                ],
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9
                ],
                [
                    9,
                    8,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    9
                ]
            ],
            "outputs": [
                [
                    2,
                    -1,
                    2
                ],
                [
                    2,
                    3,
                    4,
                    -1,
                    4
                ],
                [
                    -1,
                    5,
                    5,
                    5,
                    5
                ],
                [
                    -1,
                    -1,
                    -1,
                    -1,
                    -1
                ],
                [
                    4,
                    2,
                    4,
                    5,
                    -1
                ],
                [
                    -1,
                    9,
                    9,
                    9,
                    9,
                    9,
                    9,
                    9,
                    9
                ],
                [
                    -1
                ],
                [
                    -1,
                    -1
                ],
                [
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    -1
                ],
                [
                    9,
                    9,
                    9,
                    9,
                    9,
                    9,
                    9,
                    9,
                    9,
                    -1
                ]
            ]
        },
        "sample_code": {
            "c++": "#include <vector>\n#include <stack>\n\nstd::vector<int> nextGreaterElements(std::vector<int>& nums) {\n    std::vector<int> result(nums.size(), -1);\n    std::stack<int> s;\n\n    for (int i = 0; i < nums.size() * 2; ++i) {\n        int index = i % nums.size();\n        while (!s.empty() && nums[s.top()] < nums[index]) {\n            result[s.top()] = nums[index];\n            s.pop();\n        }\n        if (i < nums.size()) {\n            s.push(index);\n        }\n    }\n    return result;\n}\n",
            "java": "import java.util.Stack;\n\npublic int[] nextGreaterElements(int[] nums) {\n    int n = nums.length;\n    int[] result = new int[n];\n    Stack<Integer> stack = new Stack<>();\n    \n    for (int i = 0; i < n * 2; i++) {\n        int index = i % n;\n        while (!stack.isEmpty() && nums[stack.peek()] < nums[index]) {\n            result[stack.pop()] = nums[index];\n        }\n        if (i < n) {\n            stack.push(index);\n        }\n    }\n    return result;\n}\n",
            "python": "def nextGreaterElements(nums):\n    result = [-1] * len(nums)\n    stack = []\n\n    for i in range(len(nums) * 2):\n        index = i % len(nums)\n        while stack and nums[stack[-1]] < nums[index]:\n            result[stack.pop()] = nums[index]\n        if i < len(nums):\n            stack.append(index)\n\n    return result\n",
            "javascript": "function nextGreaterElements(nums) {\n  const result = new Array(nums.length).fill(-1);\n  const stack = [];\n\n  for (let i = 0; i < nums.length * 2; i++) {\n    const index = i % nums.length;\n    while (stack.length > 0 && nums[stack[stack.length - 1]] < nums[index]) {\n      result[stack.pop()] = nums[index];\n    }\n    if (i < nums.length) {\n      stack.push(index);\n    }\n  }\n  return result;\n}\n",
            "explanation": "The algorithm uses a stack to keep track of the indices of the elements in the `nums` array. We traverse the array twice (using modulo operator) since it's circular. For each element, we check if it's greater than the top element (index) of the stack. If it is, we update the corresponding result for that index with the current element and pop the index from the stack. We push the current index onto the stack if we are still in the first traversal.\n\nFinally, we return `result` list which holds the next greater element for all elements in the input list. If a greater element is not found for an element, its value in the result list will remain `-1`. "
        },
        "structure": {
            "c++": "#include <vector>\n#include <stack>\n\nstd::vector<int> nextGreaterElements(std::vector<int>& nums)  {\n    // Your code here\n}\n",
            "java": "import java.util.Stack;\n\npublic int[] nextGreaterElements(int[] nums)  {\n    // Your code here\n}\n",
            "python": "def nextGreaterElements(nums):\n    # Your code here\n\n",
            "javascript": "function nextGreaterElements(nums)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "#include <vector>\n#include <stack>\n\nstd::vector<int> nextGreaterElements(std::vector<int>& nums) {\n    std::vector<int> result(nums.size(), -1);\n    std::stack<int> s;\n\n    for (int i = 0; i < nums.size() * 2; ++i) {\n        int index = i % nums.size();\n        while (!s.empty() && nums[s.top()] < nums[index]) {\n            result[s.top()] = nums[index];\n            s.pop();\n        }\n        if (i < nums.size()) {\n            s.push(index);\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::vector<int> nums = $args;\n    std::vector<int> result = nextGreaterElements(nums);\n    for (int i = 0; i < result.size(); ++i) {\n        std::cout << result[i] << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}",
            "java": "public int[] nextGreaterElements(int[] nums) {\n    int n = nums.length;\n    int[] result = new int[n];\n    Stack<Integer> stack = new Stack<>();\n    \n    for (int i = 0; i < n * 2; i++) {\n        int index = i % n;\n        while (!stack.isEmpty() && nums[stack.peek()] < nums[index]) {\n            result[stack.pop()] = nums[index];\n        }\n        if (i < n) {\n            stack.push(index);\n        }\n    }\n    return result;\n}",
            "python": "if __name__ == \"__main__\":\n    nums =$args\n    result = nextGreaterElements(nums)\n    print(result)",
            "javascript": "const nums = $args;\n\nconst result = nextGreaterElements(nums);\n\nconsole.log(result);\n"
        },
        "languages verified": [
            "python",
            "javascript"
        ],
        "Qid": "503"
    },
    {
        "_id": {
            "$oid": "662af5f63cdc8feb456b7ef2"
        },
        "title": "Base 7 Representation",
        "description": "Given an integer `num`, return a string of its base 7 representation.",
        "example": "Example:\n\nInput: num = 100\nOutput: \"202\"\n\nInput: num = -7\nOutput: \"-10\"",
        "level": "Easy",
        "tags": [
            "math",
            "conversion"
        ],
        "test_cases": {
            "inputs": [
                100,
                -7,
                0,
                7,
                49,
                -49,
                1000000,
                -1000000,
                1,
                -1,
                107,
                -107,
                999,
                -999,
                123456,
                -123456,
                987654,
                -987654,
                9999999,
                -9999999
            ],
            "outputs": [
                "202",
                "-10",
                "0",
                "10",
                "100",
                "-100",
                "2624660",
                "-2624660",
                "1",
                "-1",
                "250",
                "-250",
                "26241",
                "-26241",
                "150666",
                "-150666",
                "603660",
                "-603660",
                "15066666",
                "-15066666"
            ]
        },
        "sample_code": {
            "c++": "std::string convertToBase7(int num) {\n    if (num == 0) return \"0\";\n    std::string result = \"\";\n    bool negative = num < 0;\n    if (negative) num *= -1;\n    while (num > 0) {\n        result = std::to_string(num % 7) + result;\n        num /= 7;\n    }\n    return negative ? \"-\" + result : result;\n}\n",
            "java": "public String convertToBase7(int num) {\n    if (num == 0) return \"0\";\n    StringBuilder result = new StringBuilder();\n    boolean negative = num < 0;\n    if (negative) num *= -1;\n    while (num > 0) {\n        result.insert(0, num % 7);\n        num /= 7;\n    }\n    return negative ? \"-\" + result.toString() : result.toString();\n}\n",
            "python": "def convert_to_base7(num: int) -> str:\n    if num == 0:\n        return \"0\"\n    result = \"\"\n    negative = num < 0\n    if negative:\n        num *= -1\n    while num > 0:\n        result = str(num % 7) + result\n        num //= 7\n    return \"-\" + result if negative else result\n",
            "javascript": "function convertToBase7(num) {\n    if (num === 0) return \"0\";\n    let result = \"\";\n    let negative = num < 0;\n    if (negative) num *= -1;\n    while (num > 0) {\n        result = (num % 7).toString() + result;\n        num = Math.floor(num / 7);\n    }\n    return negative ? \"-\" + result : result;\n}\n",
            "explanation": "The algorithm first checks if the input number is 0, and if so, it simply returns the base-7 representation as \"0\". If the number is negative, it keeps track of the sign and converts the number to positive. Then, it iteratively divides the number by 7 (integer division) and prepends the remainder (modulus) to the result string. Finally, if the input number was negative, it adds the minus sign back to the result string. The same algorithm is implemented in C++, Java, Python, and JavaScript with minor syntax adjustments."
        },
        "structure": {
            "c++": "std::string convertToBase7(int num)  {\n    // Your code here\n}\n",
            "java": "public String convertToBase7(int num)  {\n    // Your code here\n}\n",
            "python": "def convert_to_base7(num: int) -> str:\n    # Your code here\n\n",
            "javascript": "function convertToBase7(num)  {\n    // Your code here\n}\n"
        },
        "call_functions": {
            "c++": "std::string convertToBase7(int num) {\n    if (num == 0) return \"0\";\n    std::string result = \"\";\n    bool negative = num < 0;\n    if (negative) num *= -1;\n    while (num > 0) {\n        result = std::to_string(num % 7) + result;\n        num /= 7;\n    }\n    return negative ? \"-\" + result : result;\n}",
            "java": "public String convertToBase7(int num) {\n    if (num == 0) return \"0\";\n    StringBuilder result = new StringBuilder();\n    boolean negative = num < 0;\n    if (negative) num *= -1;\n    while (num > 0) {\n        result.insert(0, num % 7);\n        num /= 7;\n    }\n    return negative ? \"-\" + result.toString() : result.toString();\n}",
            "python": "if __name__ == \"__main__\":\n    num = $args\n    result = convert_to_base7(num)\n    print(result)",
            "javascript": "function main() {\n    const num = $args;\n    const result = convertToBase7(num);\n    console.log(result);\n}\nmain();"
        },
        "languages verified": [
            "python",
            "javascript"
        ],
        "Qid": "504"
    }
]