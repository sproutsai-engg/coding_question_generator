Question ID: 2
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    current = dummy
    carry = 0

    while l1 or l2 or carry:
        sum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry
        carry = sum_val // 10
        current.next = ListNode(sum_val % 10)
        current = current.next

        if l1: l1 = l1.next
        if l2: l2 = l2.next

    return dummy.next

-----
class ListNode:
    # Your code here


************************************
Question ID: 19
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def removeNthFromEnd(head, n):
    first = head
    second = head
    
    for i in range(n):
        first = first.next
    
    if not first:
        head = head.next
        return head
    
    while first.next:
        first = first.next
        second = second.next
    
    second.next = second.next.next
    
    return head

-----
class ListNode:
    # Your code here


************************************
Question ID: 21
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
         
def merge_two_lists(list1, list2):
    if list1 is None:
        return list2
    if list2 is None:
        return list1

    if list1.val < list2.val:
        list1.next = merge_two_lists(list1.next, list2)
        return list1
    else:
        list2.next = merge_two_lists(list1, list2.next)
        return list2

-----
class ListNode:
    # Your code here


************************************
Question ID: 23
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
        
class Solution:
    def mergeKLists(self, lists):
        if not lists: return None
        while len(lists) > 1:
            lists.append(self.merge2Lists(lists.pop(0), lists.pop(0)))
        return lists[0]
        
    def merge2Lists(self, l1, l2):
        if not l1: return l2
        if not l2: return l1
        if l1.val <= l2.val:
            l1.next = self.merge2Lists(l1.next, l2)
            return l1
        else:
            l2.next = self.merge2Lists(l1, l2.next)
            return l2


-----
class ListNode:
    # Your code here


************************************
Question ID: 25
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseKGroup(head, k):
    if not head or k == 1:
        return head
        
    cur = head
    length = 0
    while cur:
        length += 1
        cur = cur.next
        
    dummy = ListNode(0)
    dummy.next = head
    prev = dummy
    cur = head
    
    while length >= k:
        for _ in range(1, k):
            temp = cur.next
            cur.next = temp.next
            temp.next = prev.next
            prev.next = temp
            
        prev = cur
        cur = cur.next
        length -= k
        
    return dummy.next


-----
class ListNode:
    # Your code here


************************************
Question ID: 61
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def rotateRight(head, k):
    if not head or not head.next or k == 0:
        return head

    current = head
    length = 1
    while current.next:
        length += 1
        current = current.next
    current.next = head
    k = length - k % length

    while k:
        k -= 1
        current = current.next
    head = current.next
    current.next = None

    return head

-----
class ListNode:
    # Your code here


************************************
Question ID: 82
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def deleteDuplicates(head):
    dummy = ListNode(0)
    dummy.next = head
    prev, curr = dummy, head
    while curr:
        while curr.next and curr.val == curr.next.val:
            curr = curr.next
        if prev.next == curr:
            prev = prev.next
        else:
            prev.next = curr.next
        curr = curr.next
    return dummy.next

-----
class ListNode:
    # Your code here


************************************
Question ID: 83
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def delete_duplicates(head):
    current = head
    while current and current.next:
        if current.next.val == current.val:
            current.next = current.next.next
        else:
            current = current.next
    return head

-----
class ListNode:
    # Your code here


************************************
Question ID: 86
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def partition(head, x):
    less_head = ListNode(0)
    more_head = ListNode(0)
    less_ptr, more_ptr = less_head, more_head
    
    while head:
        if head.val < x:
            less_ptr.next = head
            less_ptr = head
        else:
            more_ptr.next = head
            more_ptr = head
        head = head.next
    
    less_ptr.next = more_head.next
    more_ptr.next = None
    
    return less_head.next

-----
class ListNode:
    # Your code here


************************************
Question ID: 94
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def inorderTraversalHelper(root, result):
    if not root:
        return
    inorderTraversalHelper(root.left, result)
    result.append(root.val)
    inorderTraversalHelper(root.right, result)

def inorderTraversal(root):
    result = []
    inorderTraversalHelper(root, result)
    return result

-----
class TreeNode:
    # Your code here


************************************
Question ID: 95
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def generate_trees(start, end):
    trees = []
    if start > end:
        trees.append(None)
        return trees

    for i in range(start, end + 1):
        left_subtrees = generate_trees(start, i - 1)
        right_subtrees = generate_trees(i + 1, end)

        for left in left_subtrees:
            for right in right_subtrees:
                new_node = TreeNode(i)
                new_node.left = left
                new_node.right = right
                trees.append(new_node)

    return trees

def generate_trees(n):
    if n == 0:
        return []
    return generate_trees(1, n)


-----
class TreeNode:
    # Your code here


************************************
Question ID: 98
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def isValidBSTHelper(node, min_val, max_val):
    if node is None:
        return True
    if not min_val < node.val < max_val:
        return False
    return (isValidBSTHelper(node.left, min_val, node.val) and
            isValidBSTHelper(node.right, node.val, max_val))

def isValidBST(root):
    return isValidBSTHelper(root, float('-inf'), float('inf'))

-----
class TreeNode:
    # Your code here


************************************
Question ID: 100
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_same_tree(p, q):
    if p is None and q is None:
        return True
    if p is None or q is None:
        return False
    if p.val != q.val:
        return False
    return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)


-----
class TreeNode:
    # Your code here


************************************
Question ID: 102
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def levelOrder(root):
    if not root:
        return []

    result = []
    queue = [root]

    while queue:
        level = []
        for i in range(len(queue)):
            node = queue.pop(0)

            if node.left:
                queue.append(node.left)

            if node.right:
                queue.append(node.right)

            level.append(node.val)

        result.append(level)

    return result


-----
class TreeNode:
    # Your code here


************************************
Question ID: 103
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def zigzagLevelOrder(root):
    if not root:
        return []

    result = []
    queue = [root]
    zigzag = False

    while queue:
        level = []
        for i in range(len(queue)):
            node = queue.pop(0)

            if zigzag:
                level.insert(0, node.val)
            else:
                level.append(node.val)

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        result.append(level)
        zigzag = not zigzag

    return result

-----
class TreeNode:
    # Your code here


************************************
Question ID: 105
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def build_tree(preorder, inorder):
    def construct_tree(in_left, in_right):
        nonlocal pre_idx
        if in_left > in_right:
            return None

        root_val = preorder[pre_idx]
        root = TreeNode(root_val)
        idx = in_map[root_val]

        pre_idx += 1
        root.left = construct_tree(in_left, idx - 1)
        root.right = construct_tree(idx + 1, in_right)

        return root

    in_map = {val: idx for idx, val in enumerate(inorder)}
    pre_idx = 0
    return construct_tree(0, len(inorder) - 1)

-----
class TreeNode:
    # Your code here


************************************
Question ID: 106
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def buildTree(self, inorder, postorder):
        def _build(in_left, in_right, post_root):
            if in_left > in_right:
                return None
            
            root = TreeNode(postorder[post_root])

            inorder_root_index = index_map[root.val]
            left_tree_size = inorder_root_index - in_left

            root.left = _build(in_left, inorder_root_index - 1, post_root - 1 - in_right + inorder_root_index)
            root.right = _build(inorder_root_index + 1, in_right, post_root - 1)

            return root

        index_map = {val: i for i, val in enumerate(inorder)}
        return _build(0, len(inorder) - 1, len(postorder) - 1)

-----
class TreeNode:
    # Your code here


************************************
Question ID: 108
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def sorted_array_to_bst(nums):
    def helper(start, end):
        if start > end:
            return None

        mid = start + (end - start) // 2
        node = TreeNode(nums[mid])
        node.left = helper(start, mid - 1)
        node.right = helper(mid + 1, end)

        return node

    return helper(0, len(nums) - 1)


-----
class TreeNode:
    # Your code here


************************************
Question ID: 109
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def sortedListToBST(head):
    if not head:
        return None
    if not head.next:
        return TreeNode(head.val)
    slow = head
    fast = head
    prev = None

    while fast and fast.next:
        prev = slow
        slow = slow.next
        fast = fast.next.next

    prev.next = None

    root = TreeNode(slow.val)
    root.left = sortedListToBST(head)
    root.right = sortedListToBST(slow.next)
    return root

-----
class ListNode:
    # Your code here


************************************
Question ID: 110
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def getHeight(node):
    if not node:
        return 0
    left_height = getHeight(node.left)
    right_height = getHeight(node.right)
    if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1:
        return -1
    return 1 + max(left_height, right_height)

def isBalanced(root):
    return getHeight(root) != -1


-----
class TreeNode:
    # Your code here


************************************
Question ID: 112
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def hasPathSum(root, targetSum):
    if root is None:
        return False
    if root.left is None and root.right is None:
        return targetSum - root.val == 0
    return hasPathSum(root.left, targetSum - root.val) or hasPathSum(root.right, targetSum - root.val)

-----
class TreeNode:
    # Your code here


************************************
Question ID: 113
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def pathSum(root, targetSum):
    def helper(root, targetSum, current, ans):
        if not root:
            return
        current.append(root.val)
        if not root.left and not root.right and targetSum == root.val:
            ans.append(current[:])
        helper(root.left, targetSum - root.val, current, ans)
        helper(root.right, targetSum - root.val, current, ans)
        current.pop()

    ans = []
    helper(root, targetSum, [], ans)
    return ans

-----
class TreeNode:
    # Your code here


************************************
Question ID: 117
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next

def connect(root: 'Node') -> 'Node':
    if not root:
        return None

    q = [root]

    while q:
        level_size = len(q)
        prev = None

        for i in range(level_size):
            current_node = q.pop(0)

            if prev:
                prev.next = current_node
            prev = current_node

            if current_node.left:
                q.append(current_node.left)
            if current_node.right:
                q.append(current_node.right)

    return root


-----
class Node:
    # Your code here


************************************
Question ID: 124
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def maxPathSum(root: TreeNode) -> int:
    def helper(root):
        nonlocal maxSum
        if not root:
            return 0

        left = max(0, helper(root.left))
        right = max(0, helper(root.right))

        maxSum = max(maxSum, left + right + root.val)

        return max(left, right) + root.val

    maxSum = float('-inf')
    helper(root)
    return maxSum

-----
class TreeNode:
    # Your code here


************************************
Question ID: 130
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        if not board:
            return
        m, n = len(board), len(board[0])

        def dfs(x, y):
            if x < 0 or x >= m or y < 0 or y >= n or board[x][y] != 'O':
                return
            board[x][y] = '#'
            dfs(x - 1, y)
            dfs(x + 1, y)
            dfs(x, y - 1)
            dfs(x, y + 1)

        for i in range(m):
            dfs(i, 0)
            dfs(i, n - 1)
        for i in range(n):
            dfs(0, i)
            dfs(m - 1, i)

        for i in range(m):
            for j in range(n):
                if board[i][j] == '#':
                    board[i][j] = 'O'
                elif board[i][j] == 'O':
                    board[i][j] = 'X'

-----
class Solution:
    # Your code here


************************************
Question ID: 133
class Node:
    def __init__(self, val=0, neighbors=None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []

def cloneGraph(node, visited=None):
    if node is None:
        return None

    if visited is None:
        visited = {}

    if node in visited:
        return visited[node]

    cloneNode = Node(node.val)
    visited[node] = cloneNode

    for neighbor in node.neighbors:
        cloneNode.neighbors.append(cloneGraph(neighbor, visited))

    return cloneNode


-----
class Node:
    # Your code here


************************************
Question ID: 138
class Node:
    def __init__(self, val, next=None, random=None):
        self.val = val
        self.next = next
        self.random = random
        
def copyRandomList(head):
    if not head:
        return None

    curr = head
    while curr:
        temp = Node(curr.val)
        temp.next = curr.next
        curr.next = temp
        curr = curr.next.next

    curr = head
    while curr:
        if curr.random:
            curr.next.random = curr.random.next
        curr = curr.next.next

    orig = head
    copy = head.next
    copy_head = copy

    while orig and copy:
        orig.next = copy.next
        orig = orig.next
        if orig:
            copy.next = orig.next
            copy = copy.next

    return copy_head

-----
class Node:
    # Your code here


************************************
Question ID: 142
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def detectCycle(head):
    slow, fast = head, head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        
        if slow == fast:
            start = head
            while start != slow:
                start = start.next
                slow = slow.next
            return start
    
    return None

-----
class ListNode:
    # Your code here


************************************
Question ID: 143
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reorderList(head):
    if not head or not head.next or not head.next.next:
        return

    # Find the middle node
    slow = head
    fast = head
    while fast.next and fast.next.next:
        slow = slow.next
        fast = fast.next.next

    # Reverse the second half
    prev = None
    curr = slow.next
    while curr:
        next = curr.next
        curr.next = prev
        prev = curr
        curr = next
    slow.next = None

    # Merge two halves
    first = head
    second = prev
    while second:
        next = first.next
        first.next = second
        first = second
        second = next

-----
class ListNode:
    # Your code here


************************************
Question ID: 144
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def preorderTraversal(root):
    if root is None:
        return []
        
    return [root.val] + preorderTraversal(root.left) + preorderTraversal(root.right)

-----
class TreeNode:
    # Your code here


************************************
Question ID: 145
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def postorderTraversal(root):
    if not root:
        return []

    result = []
    s = [root]
    while s:
        current = s.pop()
        result.insert(0, current.val)
        if current.left:
            s.append(current.left)
        if current.right:
            s.append(current.right)

    return result

-----
class TreeNode:
    # Your code here


************************************
Question ID: 147
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def insertionSortList(head):
    dummy = ListNode(0)
    cur = dummy

    while head:
        while cur.next and cur.next.val < head.val:
            cur = cur.next
        
        temp = head.next
        head.next = cur.next
        cur.next = head
        head = temp
        cur = dummy

    return dummy.next

-----
class ListNode:
    # Your code here


************************************
Question ID: 148
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def sortList(head):
    if not head or not head.next:
        return head

    slow, fast = head, head.next
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

    mid = slow.next
    slow.next = None

    return merge(sortList(head), sortList(mid))

def merge(left, right):
    if not left:
        return right
    if not right:
        return left
    if left.val < right.val:
        left.next = merge(left.next, right)
        return left
    else:
        right.next = merge(left, right.next)
        return right


-----
class ListNode:
    # Your code here


************************************
Question ID: 155
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = []
        
    def push(self, val: int):
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)
        
    def pop(self):
        if self.stack[-1] == self.min_stack[-1]:
            self.min_stack.pop()
        self.stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]

-----
class MinStack:
    # Your code here


************************************
Question ID: 156
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def upside_down_binary_tree(root):
    if not root or not root.left:
        return root
    new_root = upside_down_binary_tree(root.left)
    root.left.right = root
    root.left.left = root.right
    root.left = None
    root.right = None
    return new_root

-----
class TreeNode:
    # Your code here


************************************
Question ID: 158
class Solution:
    def __init__(self):
        self.buffer_index = 0
        self.buffer_len = 0
        self.buf4 = [None] * 4

    def read(self, buf, n):
        cnt = 0
        while cnt < n:
            if self.buffer_index == self.buffer_len:
                self.buffer_len = self.read4(self.buf4)
                self.buffer_index = 0
            if self.buffer_len == 0:
                break
            while cnt < n and self.buffer_index < self.buffer_len:
                buf[cnt] = self.buf4[self.buffer_index]
                cnt += 1
                self.buffer_index += 1
        return cnt

    def read4(self, buf4):
        return 0

-----
class Solution:
    # Your code here


************************************
Question ID: 160
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def getIntersectionNode(headA, headB):
    pA, pB = headA, headB
    while pA is not pB:
        pA = pA.next if pA else headB
        pB = pB.next if pB else headA
    return pA


-----
class ListNode:
    # Your code here


************************************
Question ID: 170
class TwoSum:

    def __init__(self):
        self.nums = {}

    def add(self, number: int) -> None:
        if number in self.nums:
            self.nums[number] += 1
        else:
            self.nums[number] = 1

    def find(self, value: int) -> bool:
        for num in self.nums:
            target = value - num
            if target in self.nums:
                if target != num or self.nums[num] > 1:
                    return True
        return False

-----
class TwoSum:
    # Your code here


************************************
Question ID: 173
class BSTIterator:

    def __init__(self, root):
        self.stack = []
        self.push_left(root)

    def next(self):
        top = self.stack.pop()
        self.push_left(top.right)
        return top.val

    def hasNext(self):
        return len(self.stack) > 0

    def push_left(self, node):
        while node:
            self.stack.append(node)
            node = node.left

-----
class BSTIterator:
    # Your code here


************************************
Question ID: 199
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def rightSideView(root):
    if not root:
        return []

    result = []
    queue = [root]

    while queue:
        level_size = len(queue)

        for i in range(level_size):
            current = queue.pop(0)

            if i == level_size - 1:
                result.append(current.val)
            
            if current.left:
                queue.append(current.left)
            if current.right:
                queue.append(current.right)

    return result

-----
class TreeNode:
    # Your code here


************************************
Question ID: 203
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def remove_elements(head, val):
    sentinel = ListNode(0)
    sentinel.next = head
    prev, curr = sentinel, head

    while curr:
        if curr.val == val:
            prev.next = curr.next
        else:
            prev = curr
        curr = curr.next

    return sentinel.next

-----
class ListNode:
    # Your code here


************************************
Question ID: 206
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_list(head):
    prev = None
    current = head
    while current is not None:
        next = current.next
        current.next = prev
        prev = current
        current = next
    return prev

-----
class ListNode:
    # Your code here


************************************
Question ID: 208
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        node = self.root
        for c in word:
            if c not in node.children:
                node.children[c] = TrieNode()
            node = node.children[c]
        node.is_end_of_word = True

    def search(self, word: str) -> bool:
        node = self.root
        for c in word:
            if c not in node.children:
                return False
            node = node.children[c]
        return node.is_end_of_word

    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for c in prefix:
            if c not in node.children:
                return False
            node = node.children[c]
        return True

-----
class TrieNode:
    # Your code here


************************************
Question ID: 211
class TrieNode:
    def __init__(self):
        self.children = [None] * 26
        self.is_word = False

class WordDictionary:
    def __init__(self):
        self.root = TrieNode()

    def addWord(self, word: str) -> None:
        current = self.root
        for c in word:
            index = ord(c) - ord('a')
            if current.children[index] is None:
                current.children[index] = TrieNode()
            current = current.children[index]
        current.is_word = True

    def search(self, word: str) -> bool:
        return self._search_helper(self.root, word, 0)

    def _search_helper(self, node: TrieNode, word: str, index: int) -> bool:
        if index == len(word):
            return node.is_word

        if word[index] == '.':
            for child_node in node.children:
                if child_node is not None and self._search_helper(child_node, word, index + 1):
                    return True
            return False
        else:
            child_node = node.children[ord(word[index]) - ord('a')]
            if child_node is None:
                return False
            return self._search_helper(child_node, word, index + 1)


-----
class TrieNode:
    # Your code here


************************************
Question ID: 222
class TreeNode:
    def __init__(self, left=None, right=None):
        self.left = left
        self.right = right

def count_nodes(root):
    if not root:
        return 0
    ld = rd = 0
    l = r = root

    while l:
        l = l.left
        ld += 1

    while r:
        r = r.right
        rd += 1

    if ld == rd:
        return (1 << ld) - 1
    return 1 + count_nodes(root.left) + count_nodes(root.right)

-----
class TreeNode:
    # Your code here


************************************
Question ID: 226
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def invert_tree(root):
    if root is None:
        return None
    root.left, root.right = invert_tree(root.right), invert_tree(root.left)
    return root

-----
class TreeNode:
    # Your code here


************************************
Question ID: 230
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def kthSmallest(root, k):
    stk = []
    curr = root
    
    while True:
        while curr:
            stk.append(curr)
            curr = curr.left
        
        curr = stk.pop()
        
        k -= 1
        if k == 0:
            return curr.val
        
        curr = curr.right

-----
class TreeNode:
    # Your code here


************************************
Question ID: 232
class MyQueue:

    def __init__(self):
        self.stack1 = []
        self.stack2 = []

    def push(self, x: int) -> None:
        self.stack1.append(x)

    def pop(self) -> int:
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        return self.stack2.pop()

    def peek(self) -> int:
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        return self.stack2[-1]

    def empty(self) -> bool:
        return not self.stack1 and not self.stack2

-----
class MyQueue:
    # Your code here


************************************
Question ID: 234
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def isPalindrome(head):
    if not head or not head.next:
        return True

    fast, slow, prev = head, head, None
    while fast and fast.next:
        fast = fast.next.next
        temp = slow.next
        slow.next = prev
        prev = slow
        slow = temp

    if fast:
        slow = slow.next

    while prev and prev.val == slow.val:
        prev = prev.next
        slow = slow.next

    return prev == None

-----
class ListNode:
    # Your code here


************************************
Question ID: 235
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def lowest_common_ancestor(root, p, q):
    if root is None or root == p or root == q:
        return root

    left = lowest_common_ancestor(root.left, p, q)
    right = lowest_common_ancestor(root.right, p, q)

    if left is not None and right is not None:
        return root
    else:
        return left if left is not None else right


-----
class TreeNode:
    # Your code here


************************************
Question ID: 236
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def lowestCommonAncestor(root, p, q):
    if not root or root == p or root == q:
        return root
    left = lowestCommonAncestor(root.left, p, q)
    right = lowestCommonAncestor(root.right, p, q)
    return right if left is None else (left if right is None else root)


-----
class TreeNode:
    # Your code here


************************************
Question ID: 244
class WordDistance:

    def __init__(self, wordsDict):
        self.word_indexes = {}
        for i, word in enumerate(wordsDict):
            if word not in self.word_indexes:
                self.word_indexes[word] = []
            self.word_indexes[word].append(i)

    def shortest(self, word1, word2):
        indexes1 = self.word_indexes[word1]
        indexes2 = self.word_indexes[word2]
        i, j, min_dist = 0, 0, float('inf')

        while i < len(indexes1) and j < len(indexes2):
            min_dist = min(min_dist, abs(indexes1[i] - indexes2[j]))
            if indexes1[i] < indexes2[j]:
                i += 1
            else:
                j += 1

        return min_dist
```
-----
class WordDistance:
    # Your code here

```
************************************
Question ID: 250
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def countUnivalSubtrees(self, root: TreeNode) -> int:
        count = 0

        def helper(node):
            nonlocal count
            if node is None:
                return True

            left = helper(node.left)
            right = helper(node.right)

            if left and right:
                if node.left and node.val != node.left.val:
                    return False
                if node.right and node.val != node.right.val:
                    return False
                count += 1
                return True

            return False

        helper(root)
        return count

-----
class TreeNode:
    # Your code here


************************************
Question ID: 251
class Vector2D:
    def __init__(self, vec):
        self.vec = vec
        self.row = 0
        self.col = 0

    def next(self):
        val = self.vec[self.row][self.col]
        self.col += 1
        return val

    def hasNext(self):
        while self.row < len(self.vec):
            if self.col < len(self.vec[self.row]):
                return True
            self.row += 1
            self.col = 0
        return False


-----
class Vector2D:
    # Your code here


************************************
Question ID: 257
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def binary_tree_paths(root: TreeNode):
    if not root:
        return []
    if not root.left and not root.right:
        return [str(root.val)]
    paths = []
    for path in binary_tree_paths(root.left):
        paths.append(str(root.val) + "->" + path)
    for path in binary_tree_paths(root.right):
        paths.append(str(root.val) + "->" + path)
    return paths

-----
class TreeNode:
    # Your code here


************************************
Question ID: 270
class Solution:
    def closestValue(self, root: TreeNode, target: float) -> int:
        closest = root.val
        while root:
            if abs(target - closest) > abs(target - root.val):
                closest = root.val
            root = root.left if target < root.val else root.right
        return closest

-----
class Solution:
    # Your code here


************************************
Question ID: 273
class Solution:
    def numberToWords(self, num: int) -> str:
        if num == 0:
            return "Zero"
        LESS_THAN_20 = ["", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"]
        TENS = ["", "Ten", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"]
        THOUSANDS = ["", "Thousand", "Million", "Billion"]

        def helper(num):
            if num == 0:
                return ""
            elif num < 20:
                return LESS_THAN_20[num] + " "
            elif num < 100:
                return TENS[num // 10] + " " + helper(num % 10)
            else:
                return LESS_THAN_20[num // 100] + " Hundred " + helper(num % 100)

        result = ""
        i = 0
        while num > 0:
            if num % 1000 != 0:
                result = helper(num % 1000) + THOUSANDS[i] + " " + result
            num //= 1000
            i += 1
        return result.strip()

-----
class Solution:
    # Your code here


************************************
Question ID: 281
class ZigzagIterator:

    def __init__(self, v1: List[int], v2: List[int]):
        self.v1, self.v2 = v1, v2
        self.index1, self.index2 = 0, 0

    def next(self) -> int:
        if self.index1 < len(self.v1) and (self.index1 <= self.index2 or self.index2 == len(self.v2)):
            result = self.v1[self.index1]
            self.index1 += 1
            return result
        if self.index2 < len(self.v2) and (self.index2 < self.index1 or self.index1 == len(self.v1)):
            result = self.v2[self.index2]
            self.index2 += 1
            return result

    def hasNext(self) -> bool:
        return self.index1 < len(self.v1) or self.index2 < len(self.v2)

-----
class ZigzagIterator:
    # Your code here


************************************
Question ID: 284
class PeekingIterator:
    def __init__(self, iterator):
        self.iterator = iterator
        self.next_val = next(self.iterator, None)

    def peek(self):
        return self.next_val

    def next(self):
        current_val = self.next_val
        self.next_val = next(self.iterator, None)
        return current_val

    def hasNext(self):
        return self.next_val is not None

-----
class PeekingIterator:
    # Your code here


************************************
Question ID: 285
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def inorder_successor(root: TreeNode, p: TreeNode) -> TreeNode:
    successor = None
    while root:
        if root.val > p.val:
            successor = root
            root = root.left
        else:
            root = root.right
    return successor
```
-----
class TreeNode:
    # Your code here

```
************************************
Question ID: 288
class ValidWordAbbr:

    def __init__(self, dictionary):
        self.word_map = {}
        for word in dictionary:
            abbr = self.get_abbreviation(word)
            if abbr not in self.word_map:
                self.word_map[abbr] = {word}
            else:
                self.word_map[abbr].add(word)

    def isUnique(self, word):
        abbr = self.get_abbreviation(word)
        abbr_group = self.word_map.get(abbr, set())
        return len(abbr_group) == 0 or (len(abbr_group) == 1 and word in abbr_group)

    def get_abbreviation(self, word):
        n = len(word)
        return word if n <= 2 else word[0] + str(n - 2) + word[-1]


-----
class ValidWordAbbr:
    # Your code here


************************************
Question ID: 297
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def serialize(root):
    if not root: return "null,"
    return str(root.val) + "," + serialize(root.left) + serialize(root.right)

def deserialize(data):
    def deserialize_helper(values):
        val = values.pop(0)
        if val == 'null': return None
        root = TreeNode(int(val))
        root.left = deserialize_helper(values)
        root.right = deserialize_helper(values)
        return root

    values = data.split(",")
    return deserialize_helper(values[:-1])  # Excluding the last empty element


-----
class TreeNode:
    # Your code here


************************************
Question ID: 298
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def longest_consecutive_sequence(root, longest_path):
    if root is None:
        return 0
    left = longest_consecutive_sequence(root.left, longest_path)
    right = longest_consecutive_sequence(root.right, longest_path)
    curr_path = 1
    if root.left and root.left.val == root.val + 1:
        curr_path = max(curr_path, left + 1)
    if root.right and root.right.val == root.val + 1:
        curr_path = max(curr_path, right + 1)
    longest_path[0] = max(longest_path[0], curr_path)
    return curr_path

def longest_consecutive(root):
    longest_path = [0]
    longest_consecutive_sequence(root, longest_path)
    return longest_path[0]


-----
class TreeNode:
    # Your code here


************************************
Question ID: 303
class NumArray:

    def __init__(self, nums: List[int]):
        self.pSum = [0] * (len(nums) + 1)
        for i, num in enumerate(nums):
            self.pSum[i + 1] = self.pSum[i] + num

    def sumRange(self, left: int, right: int) -> int:
        return self.pSum[right + 1] - self.pSum[left]

-----
class NumArray:
    # Your code here


************************************
Question ID: 304
class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        m, n = len(matrix), len(matrix[0])
        self.dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                self.dp[i][j] = self.dp[i - 1][j] + self.dp[i][j - 1] - self.dp[i - 1][j - 1] + matrix[i - 1][j - 1]

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        return self.dp[row2 + 1][col2 + 1] - self.dp[row1][col2 + 1] - self.dp[row2 + 1][col1] + self.dp[row1][col1]

-----
class NumMatrix:
    # Your code here


************************************
Question ID: 307
class NumArray:

    def __init__(self, nums: List[int]):
        self.prefix_sum = [0] * (len(nums) + 1)
        for i in range(len(nums)):
            self.prefix_sum[i + 1] = self.prefix_sum[i] + nums[i]

    def sumRange(self, left: int, right: int) -> int:
        return self.prefix_sum[right + 1] - self.prefix_sum[left]


-----
class NumArray:
    # Your code here


************************************
Question ID: 308
class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        self.dp = [[0] * (len(matrix[0]) + 1) for _ in range(len(matrix) + 1)]
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                self.dp[i + 1][j + 1] = self.dp[i + 1][j] + self.dp[i][j + 1] - self.dp[i][j] + matrix[i][j]
                
    def update(self, row: int, col: int, val: int) -> None:
        oldValue = self.dp[row + 1][col + 1] - self.dp[row + 1][col] - self.dp[row][col + 1] + self.dp[row][col]
        delta = val - oldValue
        for i in range(row + 1, len(self.dp)):
            for j in range(col + 1, len(self.dp[0])):
                self.dp[i][j] += delta

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        return self.dp[row2 + 1][col2 + 1] - self.dp[row2 + 1][col1] - self.dp[row1][col2 + 1] + self.dp[row1][col1]


-----
class NumMatrix:
    # Your code here


************************************
Question ID: 328
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def odd_even_list(head: ListNode) -> ListNode:
    if not head:
        return None
    odd, even, even_head = head, head.next, head.next
    while even and even.next:
        odd.next = even.next
        odd = odd.next
        even.next = odd.next
        even = even.next
    odd.next = even_head
    return head

-----
class ListNode:
    # Your code here


************************************
Question ID: 333
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def largestBSTSubtree(root: TreeNode) -> int:
    def largestBSTUtil(root):
        if not root:
            return True, 0, float('inf'), float('-inf')
        
        left = largestBSTUtil(root.left)
        right = largestBSTUtil(root.right)
        
        if left[0] and root.val > left[3] and right[0] and root.val < right[2]:
            largestBST[0] = max(largestBST[0], left[1] + 1 + right[1])
            return True, left[1] + 1 + right[1], min(root.val, left[2]), max(root.val, right[3])
        
        return False, -1, float('inf'), float('-inf')
    
    largestBST = [0]
    largestBSTUtil(root)
    
    return largestBST[0]

-----
class TreeNode:
    # Your code here


************************************
Question ID: 341
class NestedIterator:
    def __init__(self, nestedList):
        def flatten(nestedList, flatList):
            for item in nestedList:
                if isinstance(item, int):
                    flatList.append(item)
                else:
                    flatten(item, flatList)
        self.flatList = []
        flatten(nestedList, self.flatList)
        self.index = 0

    def next(self):
        result = self.flatList[self.index]
        self.index += 1
        return result

    def hasNext(self):
        return self.index < len(self.flatList)

-----
class NestedIterator:
    # Your code here


************************************
Question ID: 348
class TicTacToe:
    def __init__(self, n: int):
        self.rows, self.cols = [0] * n, [0] * n
        self.diagonal = self.anti_diagonal = self.n = n

    def move(self, row: int, col: int, player: int) -> int:
        to_add = 1 if player == 1 else -1

        self.rows[row] += to_add
        self.cols[col] += to_add

        if row == col:
            self.diagonal += to_add
        if row + col == self.n - 1:
            self.anti_diagonal += to_add

        if (abs(self.rows[row]) == self.n or abs(self.cols[col]) == self.n
                or abs(self.diagonal) == self.n or abs(self.anti_diagonal) == self.n):
            return player

        return 0


-----
class TicTacToe:
    # Your code here


************************************
Question ID: 359
class Logger:
    def __init__(self):
        self.message_timestamps = {}

    def shouldPrintMessage(self, timestamp: int, message: str) -> bool:
        if message not in self.message_timestamps or timestamp - self.message_timestamps[message] >= 10:
            self.message_timestamps[message] = timestamp
            return True
        return False

-----
class Logger:
    # Your code here


************************************
Question ID: 366
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def find_leaves(node, result, level):
    if not node:
        return -1
    left_level = find_leaves(node.left, result, level + 1)
    right_level = find_leaves(node.right, result, level + 1)
    level = max(left_level, right_level) + 1
    if len(result) <= level:
        result.append([])
    result[level].append(node.val)
    return level

def findLeaves(root):
    result = []
    find_leaves(root, result, 0)
    return result

-----
class TreeNode:
    # Your code here


************************************
Question ID: 369
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def plusOne(head: ListNode) -> ListNode:
    def plusOneDfs(node):
        if not node:
            return 1
        carry = plusOneDfs(node.next)
        if carry + node.val == 10:
            node.val = 0
            return 1
        else:
            node.val += carry
            return 0

    if not head:
        return head
    carry = plusOneDfs(head)
    if carry == 1:
        new_head = ListNode(1)
        new_head.next = head
        return new_head
    return head


-----
class ListNode:
    # Your code here


************************************
Question ID: 385
class NestedInteger:
    def __init__(self, value=None):
        pass

    def add(self, ni):
        pass

def deserialize(s: str) -> NestedInteger:
    if s[0] != '[':
        return NestedInteger(int(s))

    stack = []
    curr, start = None, 0

    for i, c in enumerate(s):
        if c == '[':
            if curr:
                stack.append(curr)
            curr = NestedInteger()
            start = i + 1
        elif c == ',' or c == ']':
            if i > start:
                curr.add(NestedInteger(int(s[start:i])))
            start = i + 1

            if c == ']' and stack:
                popped = stack.pop()
                popped.add(curr)
                curr = popped

    return curr

-----
class NestedInteger:
    # Your code here


************************************
Question ID: 404
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def sum_of_left_leaves(root):
    if not root:
        return 0
    left_sum = 0
    if root.left and not root.left.left and not root.left.right:
        left_sum += root.left.val
    return left_sum + sum_of_left_leaves(root.left) + sum_of_left_leaves(root.right)

-----
class TreeNode:
    # Your code here


************************************
Question ID: 426
class Node:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        if not root:
            return None

        first = None
        last = None
        
        def inOrder(node):
            nonlocal first, last
            
            if not node:
                return

            inOrder(node.left)

            if last:
                last.right = node
                node.left = last
            else:
                first = node
            
            last = node

            inOrder(node.right)

        inOrder(root)

        first.left = last
        last.right = first

        return first


-----
class Node:
    # Your code here


************************************
Question ID: 427
class Node:
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight

def build(grid, row, col, size):
    if size == 1:
        return Node(grid[row][col] == 1, True, None, None, None, None)
    half = size // 2
    topLeft = build(grid, row, col, half)
    topRight = build(grid, row, col + half, half)
    bottomLeft = build(grid, row + half, col, half)
    bottomRight = build(grid, row + half, col + half, half)
    if topLeft.isLeaf and topRight.isLeaf and bottomLeft.isLeaf and bottomRight.isLeaf and topLeft.val == topRight.val and topLeft.val == bottomLeft.val and topLeft.val == bottomRight.val:
        return topLeft
    return Node(False, False, topLeft, topRight, bottomLeft, bottomRight)

def construct(grid):
    return build(grid, 0, 0, len(grid))

-----
class Node:
    # Your code here


************************************
Question ID: 428
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []

class Codec:
    def serialize(self, root):
        if root is None:
            return ""
        
        data = str(root.val) + " "
        for child in root.children:
            data += self.serialize(child)
        data += "# "
        return data

    def deserialize(self, data):
        def dfs(iter_data):
            val = next(iter_data)
            if val == "#":
                return None
            
            node = Node(int(val))
            while True:
                child = dfs(iter_data)
                if child is None:
                    break
                node.children.append(child)
            return node

        return dfs(iter(data.split()))


-----
class Node:
    # Your code here


************************************
Question ID: 429
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []

def levelOrder(root):
    if not root:
        return []
    
    result = []
    queue = [root]
    
    while queue:
        currentLevel = []
        nextLevel = []
        
        for node in queue:
            currentLevel.append(node.val)
            nextLevel.extend(node.children)
            
        result.append(currentLevel)
        queue = nextLevel
            
    return result

-----
class Node:
    # Your code here


************************************
Question ID: 430
class Node:
    def __init__(self, val, prev, next, child):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child

def flatten(head: Node) -> Node:
    if not head:
        return None
    
    cur, prev, next_node = head, None, None

    while cur:
        next_node = cur.next

        if cur.child:
            cur.next = flatten(cur.child)
            cur.child.prev = cur
            cur.child = None

            if next_node:
                prev = cur
                while cur.next:
                    cur = cur.next
                    prev = prev.next

                cur.next = next_node
                next_node.prev = prev

        cur = next_node

    return head

-----
class Node:
    # Your code here


************************************
Question ID: 431
class NaryTreeNode:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []

class BinaryTreeNode:
    def __init__(self, val=None, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def encode(root: NaryTreeNode) -> BinaryTreeNode:
    if not root:
        return None
    binary_root = BinaryTreeNode(root.val)
    if root.children:
        binary_root.left = encode(root.children[0])
    sibling = binary_root.left
    for child in root.children[1:]:
        sibling.right = encode(child)
        sibling = sibling.right
    return binary_root

def decode(root: BinaryTreeNode) -> NaryTreeNode:
    if not root:
        return None
    nary_root = NaryTreeNode(root.val)
    sibling = root.left
    while sibling:
        nary_root.children.append(decode(sibling))
        sibling = sibling.right
    return nary_root

-----
class NaryTreeNode:
    # Your code here


************************************
Question ID: 432
class AllOne:
    def __init__(self):
        self.data = dict()

    def inc(self, key: str) -> None:
        self.data[key] = self.data.get(key, 0) + 1

    def dec(self, key: str) -> None:
        self.data[key] = self.data.get(key, 0) - 1
        if self.data[key] == 0:
            del self.data[key]

    def getMaxKey(self) -> str:
        if not self.data:
            return ""
        return max(self.data, key=lambda x: self.data[x])

    def getMinKey(self) -> str:
        if not self.data:
            return ""
        return min(self.data, key=lambda x: self.data[x])


-----
class AllOne:
    # Your code here


************************************
Question ID: 445
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    result = ListNode(0)
    current = result
    carry = 0
    while l1 or l2 or carry:
        sum = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry
        carry = sum // 10
        current.next = ListNode(sum % 10)
        current = current.next
        if l1: l1 = l1.next
        if l2: l2 = l2.next
    return result.next

-----
class ListNode:
    # Your code here


************************************
Question ID: 449
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def serialize(root):
    if not root:
        return "#"
    return str(root.val) + "," + serialize(root.left) + "," + serialize(root.right)

def deserialize(data):
    def deserialize_helper(values):
        val = next(values)
        if val == "#":
            return None
        node = TreeNode(int(val))
        node.left = deserialize_helper(values)
        node.right = deserialize_helper(values)
        return node

    values = iter(data.split(","))
    return deserialize_helper(values)


-----
class TreeNode:
    # Your code here


************************************
Question ID: 450
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def deleteNode(root, key):
    if root is None:
        return None

    if key < root.val:
        root.left = deleteNode(root.left, key)
    elif key > root.val:
        root.right = deleteNode(root.right, key)
    else:
        if root.left is None:
            return root.right
        elif root.right is None:
            return root.left
        else:
            temp = root.right
            while temp.left is not None:
                temp = temp.left
            root.val = temp.val
            root.right = deleteNode(root.right, temp.val)

    return root

-----
class TreeNode:
    # Your code here


************************************
Question ID: 460
class LFUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.min_freq = 0
        self.key_value = {}
        self.key_freq = {}
        self.freq_list = {1: []}

    def get(self, key: int) -> int:
        if key not in self.key_value:
            return -1
        count = self.key_freq[key]
        self.key_freq[key] += 1
        self.freq_list[count].remove(key)

        if count == self.min_freq and not self.freq_list[count]:
            self.min_freq += 1

        if count + 1 not in self.freq_list:
            self.freq_list[count + 1] = []
        self.freq_list[count + 1].append(key)

        return self.key_value[key]

    def put(self, key: int, value: int) -> None:
        if self.capacity <= 0:
            return
        if key in self.key_value:
            self.key_value[key] = value
            self.get(key)
            return
        
        if len(self.key_value) >= self.capacity:
            evict = self.freq_list[self.min_freq][0]
            self.freq_list[self.min_freq].pop(0)
            del self.key_value[evict]

        self.key_value[key] = value
        self.key_freq[key] = 1
        self.min_freq = 1
        self.freq_list[1].append(key)


-----
class LFUCache:
    # Your code here


************************************
Question ID: 510
class Node:
    def __init__(self, val, left=None, right=None, parent=None):
        self.val = val
        self.left = left
        self.right = right
        self.parent = parent

def inorder_successor(node: Node) -> Node:
    if node.right:
        node = node.right
        while node.left:
            node = node.left
        return node

    while node.parent and node == node.parent.right:
        node = node.parent

    return node.parent

-----
class Node:
    # Your code here


************************************
Question ID: 528
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def swapNodes(head, k):
    first, second, temp = head, head, head
    for _ in range(k - 1):
        temp = temp.next
    first = temp
    temp = temp.next
    while temp:
        temp = temp.next
        second = second.next

    first.val, second.val = second.val, first.val
    return head

-----
class ListNode:
    # Your code here


************************************
Question ID: 530
class TreeNode:
    def __init__(self, x: int):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        result = float('inf')
        prev = None

        def inorderTraversal(node):
            nonlocal result, prev
            if node is None:
                return
            inorderTraversal(node.left)
            if prev is not None:
                result = min(result, node.val - prev.val)
            prev = node
            inorderTraversal(node.right)

        inorderTraversal(root)
        return result

-----
class TreeNode:
    # Your code here


************************************
Question ID: 536
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def str2tree(self, s: str) -> TreeNode:
        def str2tree_helper(idx):
            if idx[0] >= len(s):
                return None

            sign = 1
            if s[idx[0]] == '-':
                sign = -1
                idx[0] += 1
                
            num = 0
            while idx[0] < len(s) and s[idx[0]].isdigit():
                num = num * 10 + int(s[idx[0]])
                idx[0] += 1

            node = TreeNode(sign * num)

            if idx[0] < len(s) and s[idx[0]] == '(':
                idx[0] += 1
                node.left = str2tree_helper(idx)
                idx[0] += 1
            if idx[0] < len(s) and s[idx[0]] == '(':
                idx[0] += 1
                node.right = str2tree_helper(idx)
                idx[0] += 1

            return node

        idx = [0]
        return str2tree_helper(idx)


-----
class TreeNode:
    # Your code here


************************************
Question ID: 538
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def __init__(self):
        self.sum = 0

    def convertBST(self, root: TreeNode) -> TreeNode:
        if root:
            self.convertBST(root.right)
            self.sum += root.val
            root.val = self.sum
            self.convertBST(root.left)
        
        return root

-----
class TreeNode:
    # Your code here


************************************
Question ID: 543
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def diameter_of_binary_tree(root):
    def _diameter_of_binary_tree(node):
        if not node:
            return 0, 0
        left_height, left_diameter = _diameter_of_binary_tree(node.left)
        right_height, right_diameter = _diameter_of_binary_tree(node.right)
        height = 1 + max(left_height, right_height)
        diameter = max(left_height + right_height, max(left_diameter, right_diameter))
        return height, diameter

    return _diameter_of_binary_tree(root)[1]

-----
class TreeNode:
    # Your code here


************************************
Question ID: 545
class Solution:
    def leftBoundary(self, node, boundary):
        if not node or not (node.left or node.right):
            return
        boundary.append(node.val)
        if node.left:
            self.leftBoundary(node.left, boundary)
        else:
            self.leftBoundary(node.right, boundary)

    def rightBoundary(self, node, boundary):
        if not node or not (node.left or node.right):
            return
        if node.right:
            self.rightBoundary(node.right, boundary)
        else:
            self.rightBoundary(node.left, boundary)
        boundary.append(node.val)

    def leaves(self, node, boundary):
        if not node:
            return
        if not (node.left or node.right):
            boundary.append(node.val)
        self.leaves(node.left, boundary)
        self.leaves(node.right, boundary)

    def boundaryOfBinaryTree(self, root):
        res = []
        if not root:
            return res
        res.append(root.val)
        self.leftBoundary(root.left, res)
        self.leaves(root, res)
        self.rightBoundary(root.right, res)
        return res


-----
class Solution:
    # Your code here


************************************
Question ID: 549
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def longest_consecutive(root: TreeNode) -> int:
    def longest_consecutive_path_util(node, max_length):
        if not node:
            return 0
        left = longest_consecutive_path_util(node.left, max_length) + 1
        right = longest_consecutive_path_util(node.right, max_length) + 1
        if node.left and node.left.val != node.val + 1:
            left = 1
        if node.right and node.right.val != node.val + 1:
            right = 1
        length = max(left, right)
        max_length[0] = max(max_length[0], left + right - 1)
        return length

    max_length = [0]
    longest_consecutive_path_util(root, max_length)
    return max_length[0]

-----
class TreeNode:
    # Your code here


************************************
Question ID: 558
class Node:
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight

class Solution:
    def intersect(self, quadTree1: 'Node', quadTree2: 'Node') -> 'Node':
        if quadTree1.isLeaf:
            return quadTree1 if quadTree1.val else quadTree2
        if quadTree2.isLeaf:
            return quadTree2 if quadTree2.val else quadTree1
        
        quadTree1.topLeft = self.intersect(quadTree1.topLeft, quadTree2.topLeft)
        quadTree1.topRight = self.intersect(quadTree1.topRight, quadTree2.topRight)
        quadTree1.bottomLeft = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)
        quadTree1.bottomRight = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)
        
        if (quadTree1.topLeft.isLeaf and quadTree1.topRight.isLeaf and
            quadTree1.bottomLeft.isLeaf and quadTree1.bottomRight.isLeaf and
            quadTree1.topLeft.val == quadTree1.topRight.val and
            quadTree1.topLeft.val == quadTree1.bottomLeft.val and
            quadTree1.topLeft.val == quadTree1.bottomRight.val):
            quadTree1.isLeaf = True
            quadTree1.val = quadTree1.topLeft.val
        
        return quadTree1


-----
class Node:
    # Your code here


************************************
Question ID: 559
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []

def max_depth(root):
    if root is None:
        return 0
    max_depth = 0
    for child in root.children:
        max_depth = max(max_depth, max_depth(child))
    return max_depth + 1

-----
class Node:
    # Your code here


************************************
Question ID: 588
class FileSystem:
    class Node:
        def __init__(self):
            self.is_file = False
            self.content = ""
            self.children = {}

    def __init__(self):
        self.root = self.Node()

    def ls(self, path: str):
        node = self.root
        path_parts = self.split_path(path)

        for part in path_parts:
            node = node.children[part]

        if node.is_file:
            return path_parts[-1:]
        else:
            return sorted(node.children.keys())

    def mkdir(self, path: str):
        node = self.root
        path_parts = self.split_path(path)

        for part in path_parts:
            if part not in node.children:
                node.children[part] = self.Node()
            node = node.children[part]

    def addContentToFile(self, filePath: str, content: str):
        node = self.root
        path_parts = self.split_path(filePath)

        for part in path_parts:
            if part not in node.children:
                node.children[part] = self.Node()
            node = node.children[part]

        node.is_file = True
        node.content += content

    def readContentFromFile(self, filePath: str) -> str:
        node = self.root
        path_parts = self.split_path(filePath)

        for part in path_parts:
            node = node.children[part]

        return node.content

    @staticmethod
    def split_path(path: str):
        return [part for part in path.split("/") if part]


-----
class FileSystem:
    # Your code here


************************************
Question ID: 589
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children

def preorder(root):
    result = []
    if not root:
        return result
    nodes = [root]

    while nodes:
        current = nodes.pop()
        result.append(current.val)
        nodes.extend(reversed(current.children))
    return result

-----
class Node:
    # Your code here


************************************
Question ID: 590
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children or []

def postorder(root):
    result = []
    if not root:
        return result
    
    stk = [root]
    
    while stk:
        current = stk.pop()
        result.append(current.val)
        
        for child in current.children:
            stk.append(child)
    
    return result[::-1]

-----
class Node:
    # Your code here


************************************
Question ID: 604
class StringIterator:
    def __init__(self, compressedString: str):
        self.s = compressedString
        self.i = 0
        self.count = 0
        self.ch = " "
    
    def next(self) -> str:
        if not self.hasNext():
            return " "
        if self.count == 0:
            self.ch = self.s[self.i]
            self.i += 1
            while self.i < len(self.s) and self.s[self.i].isdigit():
                self.count = self.count * 10 + int(self.s[self.i])
                self.i += 1
        self.count -= 1
        return self.ch
    
    def hasNext(self) -> bool:
        return self.i < len(self.s) or self.count != 0


-----
class StringIterator:
    # Your code here


************************************
Question ID: 606
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def tree2str(t):
    if not t:
        return ""
    if not t.left and not t.right:
        return str(t.val)
    if not t.right:
        return "{}({})".format(t.val, tree2str(t.left))
    return "{}({})({})".format(t.val, tree2str(t.left), tree2str(t.right))

-----
class TreeNode:
    # Your code here


************************************
Question ID: 617
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def merge_trees(root1: TreeNode, root2: TreeNode) -> TreeNode:
    if root1 is None: return root2
    if root2 is None: return root1

    root1.val += root2.val
    root1.left = merge_trees(root1.left, root2.left)
    root1.right = merge_trees(root1.right, root2.right)
    return root1

-----
class TreeNode:
    # Your code here


************************************
Question ID: 622
class MyCircularQueue:

    def __init__(self, k: int):
        self.size = k
        self.data = [0]*k
        self.front = -1
        self.rear = -1

    def enQueue(self, value: int) -> bool:
        if self.isFull():
            return False
        if self.isEmpty():
            self.front = 0
        self.rear = (self.rear + 1) % self.size
        self.data[self.rear] = value
        return True

    def deQueue(self) -> bool:
        if self.isEmpty():
            return False
        if self.front == self.rear:
            self.front = -1
            self.rear = -1
        else:
            self.front = (self.front + 1) % self.size
        return True

    def Front(self) -> int:
        if self.isEmpty():
            return -1
        return self.data[self.front]

    def Rear(self) -> int:
        if self.isEmpty():
            return -1
        return self.data[self.rear]

    def isEmpty(self) -> bool:
        return self.front == -1

    def isFull(self) -> bool:
        return (self.rear + 1) % self.size == self.front


-----
class MyCircularQueue:
    # Your code here


************************************
Question ID: 631
class Excel:

    def __init__(self, height: int, width: str):
        self.mat = [[0] * (ord(width) - ord('A') + 1) for _ in range(height)]
        self.formulas = {}

    def set(self, row: int, column: str, val: int) -> None:
        pos = column + str(row)
        if pos in self.formulas:
            del self.formulas[pos]
        self.mat[row - 1][ord(column) - ord('A')] = val

    def get(self, row: int, column: str) -> int:
        pos = column + str(row)
        if pos in self.formulas:
            return self.sum(row, column, self.formulas[pos])
        return self.mat[row - 1][ord(column) - ord('A')]

    def sum(self, row: int, column: str, numbers) -> int:
        total = 0
        for num in numbers:
            if ':' in num:
                start, end = num.split(':')
                start_row, end_row = int(start[1:]), int(end[1:])
                start_col, end_col = start[0], end[0]
                for r in range(start_row, end_row + 1):
                    for c in range(ord(start_col), ord(end_col) + 1):
                        total += self.get(r, chr(c))
            else:
                total += self.get(int(num[1:]), num[0])
        self.set(row, column, total)
        self.formulas[column + str(row)] = numbers
        return total


-----
class Excel:
    # Your code here


************************************
Question ID: 635
class LogSystem:

    def __init__(self):
        self.logs = {}
        self.time_granularity = {
            "Year": 0, "Month": 1, "Day": 2, "Hour": 3, "Minute": 4, "Second": 5
        }
        self.size_map = [4, 7, 10, 13, 16, 19]

    def put(self, id: int, timestamp: str) -> None:
        self.logs[timestamp] = id

    def retrieve(self, start: str, end: str, granularity: str) -> list[int]:
        size_substring = self.size_map[self.time_granularity[granularity]]
        res = []

        for k, v in self.logs.items():
            if start[:size_substring] <= k[:size_substring] <= end[:size_substring]:
                res.append(v)

        return res


-----
class LogSystem:
    # Your code here


************************************
Question ID: 637
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def averageOfLevels(root: TreeNode):
    result = []
    queue = [root]

    while queue:
        sum_ = 0
        count = 0
        temp = []
        while queue:
            node = queue.pop(0)
            sum_ += node.val
            count += 1
            if node.left: temp.append(node.left)
            if node.right: temp.append(node.right)
        queue = temp
        result.append(sum_ / count)

    return result

-----
class TreeNode:
    # Your code here


************************************
Question ID: 641
class MyCircularDeque:

    def __init__(self, k: int):
        self.buffer = [0] * k
        self.front = -1
        self.rear = 0
        self.capacity = k

    def insertFront(self, value: int) -> bool:
        if self.isFull():
            return False
        if self.front == -1:
            self.front = 0
        else:
            self.front = (self.front - 1 + self.capacity) % self.capacity
        self.buffer[self.front] = value
        return True

    def insertLast(self, value: int) -> bool:
        if self.isFull():
            return False
        self.buffer[self.rear] = value
        self.rear = (self.rear + 1) % self.capacity
        if self.front == -1:
            self.front = 0
        return True

    def deleteFront(self) -> bool:
        if self.isEmpty():
            return False
        if self.front == self.rear - 1:
            self.front = -1
        else:
            self.front = (self.front + 1) % self.capacity
        return True

    def deleteLast(self) -> bool:
        if self.isEmpty():
            return False
        if self.front == self.rear - 1:
            self.rear = 0
            self.front = -1
        else:
            self.rear = (self.rear - 1 + self.capacity) % self.capacity
        return True

    def getFront(self) -> int:
        if self.isEmpty():
            return -1
        return self.buffer[self.front]

    def getRear(self) -> int:
        if self.isEmpty():
            return -1
        return self.buffer[(self.rear - 1 + self.capacity) % self.capacity]

    def isEmpty(self) -> bool:
        return self.front == -1

    def isFull(self) -> bool:
        return self.front == self.rear

-----
class MyCircularDeque:
    # Your code here


************************************
Question ID: 652
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def findDuplicateSubtrees(root):
    tree_count = {}
    result = []
    findDuplicateSubtreesHelper(root, tree_count, result)
    return result

def findDuplicateSubtreesHelper(root, tree_count, result):
    if root is None:
        return ""
    subtree = "{},{},{}".format(root.val, findDuplicateSubtreesHelper(root.left, tree_count, result), findDuplicateSubtreesHelper(root.right, tree_count, result))
    tree_count[subtree] = tree_count.get(subtree, 0) + 1
    if tree_count[subtree] == 2:
        result.append(root)
    return subtree


-----
class TreeNode:
    # Your code here


************************************
Question ID: 654
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def constructMaximumBinaryTree(nums):
    def helper(nums, left, right):
        if left > right:
            return None

        maxIdx = left
        for i in range(left + 1, right + 1):
            if nums[i] > nums[maxIdx]:
                maxIdx = i

        root = TreeNode(nums[maxIdx])
        root.left = helper(nums, left, maxIdx - 1)
        root.right = helper(nums, maxIdx + 1, right)
        return root

    return helper(nums, 0, len(nums) - 1)


-----
class TreeNode:
    # Your code here


************************************
Question ID: 663
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def checkEqualTree(self, root: TreeNode) -> bool:
        def _sum(node, seen):
            if not node:
                return 0
            s = node.val + _sum(node.left, seen) + _sum(node.right, seen)
            seen.add(s)
            return s

        seen = set()
        total = _sum(root, seen)
        return total % 2 == 0 and (total // 2) in seen


-----
class TreeNode:
    # Your code here


************************************
Question ID: 669
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def trimBST(self, root: TreeNode, low: int, high: int) -> TreeNode:
    if not root:
        return None

    if root.val < low:
        return self.trimBST(root.right, low, high)
    elif root.val > high:
        return self.trimBST(root.left, low, high)
    else:
        root.left = self.trimBST(root.left, low, high)
        root.right = self.trimBST(root.right, low, high)

    return root

-----
class TreeNode:
    # Your code here


************************************
Question ID: 671
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def find_second_minimum_value(root, current=-1):
    if root is None:
        return current
    if current == -1 or root.val < current:
        current = root.val
    if root.left is not None and root.right is not None:
        if root.val == root.left.val:
            current = find_second_minimum_value(root.left, current)
            if root.val != root.right.val:
                current = root.right.val if current == -1 else min(current, root.right.val)
        else:
            current = find_second_minimum_value(root.right, current)
            if root.val != root.left.val:
                current = root.left.val if current == -1 else min(current, root.left.val)
    return current

-----
class TreeNode:
    # Your code here


************************************
Question ID: 676
class MagicDictionary:

    def __init__(self):
        self.word_list = {}

    def buildDict(self, dictionary: List[str]) -> None:
        for word in dictionary:
            if len(word) not in self.word_list:
                self.word_list[len(word)] = []
            self.word_list[len(word)].append(word)

    def search(self, searchWord: str) -> bool:
        if len(searchWord) in self.word_list:
            for word in self.word_list[len(searchWord)]:
                diff = sum(c1 != c2 for c1, c2 in zip(searchWord, word))
                if diff == 1: return True
        return False

-----
class MagicDictionary:
    # Your code here


************************************
Question ID: 677
class MapSum:
    def __init__(self):
        self.map = {}

    def insert(self, key: str, val: int) -> None:
        self.map[key] = val

    def sum(self, prefix: str) -> int:
        total = 0
        for key, value in self.map.items():
            if key.startswith(prefix):
                total += value
        return total

-----
class MapSum:
    # Your code here


************************************
Question ID: 690
class Employee:
    def __init__(self, id: int, importance: int, subordinates: list):
        self.id = id
        self.importance = importance
        self.subordinates = subordinates

def getTotalImportance(employees, id):
    emap = {emp.id: emp for emp in employees}
    return dfs(emap, id)

def dfs(emap, id):
    emp = emap[id]
    return emp.importance + sum(dfs(emap, sub_id) for sub_id in emp.subordinates)

-----
class Employee:
    # Your code here


************************************
Question ID: 700
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def searchBST(root: TreeNode, val: int) -> TreeNode:
    if not root or root.val == val:
        return root
    return searchBST(root.right, val) if root.val < val else searchBST(root.left, val)


-----
class TreeNode:
    # Your code here


************************************
Question ID: 701
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def insertIntoBST(root, val):
    if root is None:
        return TreeNode(val)

    if val < root.val:
        root.left = insertIntoBST(root.left, val)
    else:
        root.right = insertIntoBST(root.right, val)

    return root

-----
class TreeNode:
    # Your code here


************************************
Question ID: 705
class MyHashSet:

    def __init__(self):
        self.storage = [False] * 1000001

    def add(self, key: int):
        self.storage[key] = True

    def remove(self, key: int):
        self.storage[key] = False

    def contains(self, key: int) -> bool:
        return self.storage[key]


-----
class MyHashSet:
    # Your code here


************************************
Question ID: 706
class MyHashMap:
    def __init__(self):
        self.size = 10007
        self.data = [[] for _ in range(self.size)]

    def put(self, key: int, value: int) -> None:
        bucket = self.data[key % self.size]
        for pair in bucket:
            if pair[0] == key:
                pair[1] = value
                return
        bucket.append([key, value])

    def get(self, key: int) -> int:
        bucket = self.data[key % self.size]
        for pair in bucket:
            if pair[0] == key:
                return pair[1]
        return -1

    def remove(self, key: int) -> None:
        bucket = self.data[key % self.size]
        for i, pair in enumerate(bucket):
            if pair[0] == key:
                bucket.pop(i)
                return

-----
class MyHashMap:
    # Your code here


************************************
Question ID: 707
class Node:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class MyLinkedList:
    def __init__(self):
        self.head = None
        self.size = 0

    def get(self, index: int) -> int:
        if index < 0 or index >= self.size:
            return -1
        cur = self.head
        for _ in range(index):
            cur = cur.next
        return cur.val

    def addAtHead(self, val: int) -> None:
        self.head = Node(val, self.head)
        self.size += 1

    def addAtTail(self, val: int) -> None:
        if self.size == 0:
            self.addAtHead(val)
        else:
            cur = self.head
            while cur.next:
                cur = cur.next
            cur.next = Node(val)
            self.size += 1

    def addAtIndex(self, index: int, val: int) -> None:
        if index < 0 or index > self.size:
            return
        if index == 0:
            self.addAtHead(val)
        else:
            cur = self.head
            for _ in range(index - 1):
                cur = cur.next
            cur.next = Node(val, cur.next)
            self.size += 1

    def deleteAtIndex(self, index: int) -> None:
        if index < 0 or index >= self.size:
            return
        if index == 0:
            self.head = self.head.next
        else:
            cur = self.head
            for _ in range(index - 1):
                cur = cur.next
            cur.next = cur.next.next
        self.size -= 1

-----
class Node:
    # Your code here


************************************
Question ID: 708
class Node:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def insert(head, insertVal):
    if head is None:
        newNode = Node(insertVal)
        newNode.next = newNode
        return newNode

    prev, curr = head, head.next
    inserted = False

    while True:
        if prev.val <= insertVal <= curr.val:
            prev.next = Node(insertVal, curr)
            inserted = True
        elif prev.val > curr.val:
            if insertVal >= prev.val or insertVal <= curr.val:
                prev.next = Node(insertVal, curr)
                inserted = True
        prev, curr = curr, curr.next

        if prev == head or inserted:
            break

    if not inserted:
        prev.next = Node(insertVal, curr)

    return head


-----
class Node:
    # Your code here


************************************
Question ID: 711
class Solution:
    def numDistinctIslands(self, grid: List[List[int]]) -> int:
        def dfs(r, c, r0, c0):
            if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c]:
                grid[r][c] = 0
                island.append((r - r0, c - c0))
                dfs(r + 1, c, r0, c0)
                dfs(r - 1, c, r0, c0)
                dfs(r, c + 1, r0, c0)
                dfs(r, c - 1, r0, c0)

        def normalize(island):
            ret = []
            for p in island:
                x, y = p
                ret += [(x, y), (x, -y), (-x, y), (-x, -y), (y, x), (y, -x), (-y, x), (-y, -x)]
            ret.sort()
            return tuple(ret)

        distinctIslands = set()
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c]:
                    island = []
                    dfs(r, c, r, c)
                    distinctIslands.add(normalize(island))
        return len(distinctIslands)


-----
class Solution:
    # Your code here


************************************
Question ID: 725
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def splitListToParts(root, k):
    result = [None] * k
    list_size = 0
    current_node = root
    while current_node:
        list_size += 1
        current_node = current_node.next

    base_size = list_size // k
    extra = list_size % k

    current_node = root
    for i in range(k):
        if not current_node:
            break
        result[i] = current_node
        current_part_size = base_size + (1 if i < extra else 0)
        for _ in range(current_part_size - 1):
            current_node = current_node.next
        next_node = current_node.next
        current_node.next = None
        current_node = next_node

    return result

-----
class ListNode:
    # Your code here


************************************
Question ID: 731
class MyCalendarTwo:
    def __init__(self):
        self.singles = []
        self.doubles = []

    def book(self, start: int, end: int) -> bool:
        for d_start, d_end in self.doubles:
            if start < d_end and end > d_start:
                return False
        for s_start, s_end in self.singles:
            if start < s_end and end > s_start:
                self.doubles.append((max(start, s_start), min(end, s_end)))
        self.singles.append((start, end))
        return True


-----
class MyCalendarTwo:
    # Your code here


************************************
Question ID: 746
class WordFilter:

    def __init__(self, words):
        self.dict = {}
        for i, word in enumerate(words):
            for j in range(len(word) + 1):
                self.dict[word[:j] + "#" + word[j:]] = i

    def f(self, prefix, suffix):
        return self.dict.get(prefix + "#" + suffix, -1)


-----
class WordFilter:
    # Your code here


************************************
Question ID: 766
class Node:
    def __init__(self, val=0, prev=None, next=None, child=None):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child

def flatten(head: Node) -> Node:
    if not head:
        return None
    
    curr = head
    while curr:
        if curr.child:
            insert = curr.child
            next_node = curr.next
            
            insert.prev = curr
            curr.next = insert
            curr.child = None
            
            while insert.next:
                insert = insert.next
                
            if next_node:
                next_node.prev = insert
                insert.next = next_node
                
        curr = curr.next
        
    return head


-----
class Node:
    # Your code here


************************************
Question ID: 772
class Node:
    def __init__(self, val: bool, isLeaf: bool, topLeft: 'Node', topRight: 'Node', bottomLeft: 'Node', bottomRight: 'Node'):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight

def construct(grid):
    def helper(x, y, length):
        if length == 1:
            return Node(grid[x][y] == 1, True, None, None, None, None)

        tl = helper(x, y, length // 2)
        tr = helper(x, y + length // 2, length // 2)
        bl = helper(x + length // 2, y, length // 2)
        br = helper(x + length // 2, y + length // 2, length // 2)

        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val and tr.val == bl.val and bl.val == br.val:
            return Node(tl.val, True, None, None, None, None)
        else:
            return Node(False, False, tl, tr, bl, br)

    return helper(0, 0, len(grid))

-----
class Node:
    # Your code here


************************************
Question ID: 773
class TreeNode:
    def __init__(self, isLeaf, val, topLeft=None, topRight=None, bottomLeft=None, bottomRight=None):
        self.isLeaf = isLeaf
        self.val = val
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight

def intersect(quadTree1, quadTree2):    
    if quadTree1.isLeaf:
        return quadTree1 if quadTree1.val else quadTree2
    if quadTree2.isLeaf:
        return quadTree2 if quadTree2.val else quadTree1

    quadTree1.topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft)
    quadTree1.topRight = intersect(quadTree1.topRight, quadTree2.topRight)
    quadTree1.bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)
    quadTree1.bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight)

    if quadTree1.topLeft.isLeaf and quadTree1.topRight.isLeaf and quadTree1.bottomLeft.isLeaf and quadTree1.bottomRight.isLeaf and quadTree1.topLeft.val == quadTree1.topRight.val == quadTree1.bottomLeft.val == quadTree1.bottomRight.val:
        quadTree1.isLeaf = True
        quadTree1.val = quadTree1.topLeft.val

    return quadTree1


-----
class TreeNode:
    # Your code here


************************************
Question ID: 774
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []
 
def max_depth(root):
    if root is None:
        return 0
    depth = 0
    for child in root.children:
        depth = max(depth, max_depth(child))
    return 1 + depth

-----
class Node:
    # Your code here


************************************
Question ID: 775
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []

def helper(root, result):
    if not root:
        return
    result.append(root.val)
    for child in root.children:
        helper(child, result)

def preorder(root):
    result = []
    helper(root, result)
    return result

-----
class Node:
    # Your code here


************************************
Question ID: 776
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []

def postorder(root: 'Node'):
    if root is None:
        return []
    
    result = []
    stack = [root]

    while stack:
        curr = stack.pop()
        result.append(curr.val)
        stack.extend(curr.children)

    return result[::-1]

-----
class Node:
    # Your code here


************************************
Question ID: 783
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def searchBST(root: TreeNode, val: int) -> TreeNode:
    if not root or root.val == val:
        return root
    return searchBST(root.left, val) if root.val > val else searchBST(root.right, val)

-----
class TreeNode:
    # Your code here


************************************
Question ID: 784
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def insertIntoBST(root, val):
    if root is None:
        return TreeNode(val)

    if val < root.val:
        root.left = insertIntoBST(root.left, val)
    else:
        root.right = insertIntoBST(root.right, val)

    return root


-----
class TreeNode:
    # Your code here


************************************
Question ID: 799
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def __init__(self):
        self.min_diff = float("inf")
        self.prev = None

    def minDiffInBST(self, root: TreeNode) -> int:
        self.in_order_traversal(root)
        return self.min_diff

    def in_order_traversal(self, node: TreeNode) -> None:
        if not node: return
        self.in_order_traversal(node.left)
        if self.prev:
            self.min_diff = min(self.min_diff, node.val - self.prev.val)
        self.prev = node
        self.in_order_traversal(node.right)


-----
class TreeNode:
    # Your code here


************************************
Question ID: 816
class MyHashSet:

    def __init__(self):
        self.storage = [False] * 1000001

    def add(self, key: int):
        self.storage[key] = True

    def remove(self, key: int):
        self.storage[key] = False

    def contains(self, key: int) -> bool:
        return self.storage[key]


-----
class MyHashSet:
    # Your code here


************************************
Question ID: 817
class MyHashMap:

    def __init__(self):
        self.data = [-1] * 1000001

    def put(self, key: int, value: int) -> None:
        self.data[key] = value

    def get(self, key: int) -> int:
        return self.data[key]

    def remove(self, key: int) -> None:
        self.data[key] = -1


-----
class MyHashMap:
    # Your code here


************************************
Question ID: 831
class Solution:
    def largestSumOfAverages(self, nums: List[int], k: int) -> float:
        memo = {}
        
        def max_partition_sum(start: int, k: int) -> float:
            if k == 1:
                return sum(nums[start:]) / (len(nums) - start)
            if (start, k) in memo:
                return memo[start, k]
            
            ans, curr_sum = 0, 0
            for i in range(start, len(nums) - k + 1):
                curr_sum += nums[i]
                ans = max(ans, curr_sum / (i - start + 1) + max_partition_sum(i + 1, k - 1))
            
            memo[start, k] = ans
            return ans
        
        return max_partition_sum(0, k)

-----
class Solution:
    # Your code here


************************************
Question ID: 835
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def numComponents(head: ListNode, nums: List[int]) -> int:
    num_set = set(nums)
    result = 0
    connected = False

    while head:
        if head.val in num_set:
            if not connected:
                connected = True
                result += 1
        else:
            connected = False
        head = head.next

    return result


-----
class ListNode:
    # Your code here


************************************
Question ID: 860
class MyCircularQueue:

    def __init__(self, k: int):
        self.data = [0] * k
        self.head = 0
        self.tail = -1
        self.size = 0
        self.capacity = k

    def enQueue(self, value: int) -> bool:
        if self.isFull():
            return False
        self.tail = (self.tail + 1) % self.capacity
        self.data[self.tail] = value
        self.size += 1
        return True

    def deQueue(self) -> bool:
        if self.isEmpty():
            return False
        self.head = (self.head + 1) % self.capacity
        self.size -= 1
        return True

    def Front(self) -> int:
        if self.isEmpty():
            return -1
        return self.data[self.head]

    def Rear(self) -> int:
        if self.isEmpty():
            return -1
        return self.data[self.tail]

    def isEmpty(self) -> bool:
        return self.size == 0

    def isFull(self) -> bool:
        return self.size == self.capacity

-----
class MyCircularQueue:
    # Your code here


************************************
Question ID: 865
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
        def find_deepest(node):
            if not node:
                return None, 0
            left, left_height = find_deepest(node.left)
            right, right_height = find_deepest(node.right)
            if left_height == right_height:
                return node, left_height + 1
            return (left, left_height + 1) if left_height > right_height else (right, right_height + 1)

        return find_deepest(root)[0]

-----
class TreeNode:
    # Your code here


************************************
Question ID: 896
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def maxDepth(node):
    if node is None:
        return 0
    else:
        return max(maxDepth(node.left), maxDepth(node.right)) + 1

def subtreeWithAllDeepest(root):
    if root is None:
        return None

    leftDepth = maxDepth(root.left)
    rightDepth = maxDepth(root.right)

    if leftDepth == rightDepth:
        return root

    if leftDepth > rightDepth:
        return subtreeWithAllDeepest(root.left)
    else:
        return subtreeWithAllDeepest(root.right)

-----
class TreeNode:
    # Your code here


************************************
Question ID: 906
class Solution:
    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:
        dx = [0, 1, 0, -1]
        dy = [1, 0, -1, 0]
        x = y = di = 0
        obstacleSet = set(map(tuple, obstacles))

        ans = 0
        for cmd in commands:
            if cmd == -2:
                di = (di - 1) % 4
            elif cmd == -1:
                di = (di + 1) % 4
            else:
                for k in range(cmd):
                    nx = x + dx[di]
                    ny = y + dy[di]
                    if (nx, ny) not in obstacleSet:
                        x = nx
                        y = ny
                        ans = max(ans, x * x + y * y)

        return ans


-----
class Solution:
    # Your code here


************************************
Question ID: 908
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def middleNode(head):
    slow = head
    fast = head

    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

    return slow

-----
class ListNode:
    # Your code here


************************************
Question ID: 925
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def constructFromPrePost(self, pre, post):
        def buildTree(preStart, preEnd, postStart, postEnd):
            if preStart == preEnd:
                return None

            root = TreeNode(pre[preStart])

            if preStart + 1 == preEnd:
                return root

            leftRoot = pre[preStart + 1]

            leftSize = 0
            for i in range(postStart, postEnd):
                if post[i] == leftRoot:
                    leftSize = i - postStart + 1
                    break

            root.left = buildTree(preStart + 1, preStart + 1 + leftSize, postStart, postStart + leftSize)
            root.right = buildTree(preStart + 1 + leftSize, preEnd, postStart + leftSize, postEnd - 1)

            return root

        return buildTree(0, len(pre), 0, len(post))

-----
class TreeNode:
    # Your code here


************************************
Question ID: 930
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def all_possible_FBT(n):
    if n % 2 == 0:
        return []
    if n == 1:
        return [TreeNode(0)]

    result = []
    for i in range(1, n, 2):
        left = all_possible_FBT(i)
        right = all_possible_FBT(n - i - 1)
        for l in left:
            for r in right:
                root = TreeNode(0)
                root.left = l
                root.right = r
                result.append(root)
    return result

-----
class TreeNode:
    # Your code here


************************************
Question ID: 933
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def increasingBST(root):
    def inorder(node):
        nonlocal prev
        if not node: return

        inorder(node.left)
        prev.right = node
        prev = node
        node.left = None
        inorder(node.right)

    dummy = TreeNode(0)
    prev = dummy
    inorder(root)
    return dummy.right


-----
class TreeNode:
    # Your code here


************************************
Question ID: 936
class RLEIterator:
    def __init__(self, encoding):
        self.encoding = encoding
        self.index = 0

    def next(self, n):
        while self.index < len(self.encoding):
            if n <= self.encoding[self.index]:
                self.encoding[self.index] -= n
                return self.encoding[self.index + 1]
            n -= self.encoding[self.index]
            self.index += 2
        return -1

-----
class RLEIterator:
    # Your code here


************************************
Question ID: 937
class StockSpanner:

    def __init__(self):
        self.prices = []
        self.index_stack = []

    def next(self, price: int) -> int:
        while self.index_stack and self.prices[self.index_stack[-1]] <= price:
            self.index_stack.pop()
        span = len(self.prices) + 1 if not self.index_stack else len(self.prices) - self.index_stack[-1]
        self.index_stack.append(len(self.prices))
        self.prices.append(price)
        return span

-----
class StockSpanner:
    # Your code here


************************************
Question ID: 988
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def flipEquiv(root1, root2):
    if not root1 and not root2: return True
    if not root1 or not root2: return False
    if root1.val != root2.val: return False
    return (flipEquiv(root1.left, root2.left) and flipEquiv(root1.right, root2.right)) or \
           (flipEquiv(root1.left, root2.right) and flipEquiv(root1.right, root2.left))


-----
class TreeNode:
    # Your code here


************************************
Question ID: 992
class Solution:
    def minDeletionSize(self, strs: List[str]) -> int:
        n = len(strs)
        m = len(strs[0])
        dp = [1] * m

        for j in range(m):
            for i in range(j):
                flag = all(strs[k][i] <= strs[k][j] for k in range(n - 1))
                dp[j] = max(dp[j], dp[i] + 1) if flag else dp[j]

        return m - max(dp)


-----
class Solution:
    # Your code here


************************************
Question ID: 998
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def is_complete_tree(root: TreeNode) -> bool:
    if not root:
        return True
    
    queue = [root]
    while queue[0]:
        node = queue.pop(0)
        queue.append(node.left)
        queue.append(node.right)
    while queue and not queue[0]:
        queue.pop(0)
    return not queue

-----
class TreeNode:
    # Your code here


************************************
Question ID: 1026
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def maxAncestorDiff(root: TreeNode) -> int:
    def helper(node, mn, mx):
        if node is None:
            return mx - mn

        mx = max(mx, node.val)
        mn = min(mn, node.val)

        left_diff = helper(node.left, mn, mx)
        right_diff = helper(node.right, mn, mx)

        return max(left_diff, right_diff)

    return helper(root, root.val, root.val)

-----
class TreeNode:
    # Your code here


************************************
Question ID: 1030
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def smallestFromLeaf(self, root: TreeNode) -> str:
        if not root:
            return "|"
        s = chr(root.val + 97)
        if not root.left and not root.right:
            return s
        left = self.smallestFromLeaf(root.left)
        right = self.smallestFromLeaf(root.right)
        return min(left, right) + s

-----
class TreeNode:
    # Your code here


************************************
Question ID: 1035
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isCousins(self, root, x, y):
        def findDepth(node, search_val, depth):
            if not node:
                return -1
            if node.val == search_val:
                return depth
            left_depth = findDepth(node.left, search_val, depth + 1)
            if left_depth != -1:
                return left_depth
            return findDepth(node.right, search_val, depth + 1)

        def findParent(node, search_val):
            if not node or not (node.left or node.right):
                return None
            if (node.left and node.left.val == search_val) or (node.right and node.right.val == search_val):
                return node
            left_parent = findParent(node.left, search_val)
            if left_parent:
                return left_parent
            return findParent(node.right, search_val)

        x_depth = findDepth(root, x, 0)
        y_depth = findDepth(root, y, 0)
        x_parent = findParent(root, x)
        y_parent = findParent(root, y)
        return (x_depth == y_depth) and (x_parent != y_parent)

-----
class TreeNode:
    # Your code here


************************************
Question ID: 1072
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def nextGreaterNodes(head):
    result = []
    stack = []
    while head:
        while stack and stack[-1] < head.val:
            stack[-1] = head.val
            stack.pop()
        result.append(head.val)
        stack.append(len(result) - 1)
        head = head.next

    while stack:
        result[stack.pop()] = 0

    return result

-----
class ListNode:
    # Your code here


************************************
Question ID: 1092
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def dfs(node):
    if not node:
        return 0, float('inf'), float('-inf')
    left_diff, left_min, left_max = dfs(node.left)
    right_diff, right_min, right_max = dfs(node.right)
    mn = min(node.val, left_min, right_min)
    mx = max(node.val, left_max, right_max)
    return max(max(left_diff, right_diff), max(abs(node.val - left_min), abs(node.val - right_max))), mn, mx

def maxAncestorDiff(root):
    diff, _, _ = dfs(root)
    return diff

-----
class TreeNode:
    # Your code here


************************************
Question ID: 1093
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def recoverFromPreorder(S: str) -> TreeNode:
    def helper() -> TreeNode:
        nonlocal depth, index
        num_dashes = 0
        while index < len(S) and S[index] == '-':
            num_dashes += 1
            index += 1
        if num_dashes != depth:
            index -= num_dashes
            return None
        val = 0
        while index < len(S) and S[index].isdigit():
            val = val * 10 + int(S[index])
            index += 1
        node = TreeNode(val)
        depth += 1
        node.left = helper()
        node.right = helper()
        depth -= 1
        return node

    depth, index = 0, 0
    return helper()

-----
class TreeNode:
    # Your code here


************************************
Question ID: 1096
class Solution:
    def braceExpansionII(self, expression: str) -> List[str]:
        def parse(expr: str, i: int) -> Set[str]:
            result, current = set(), {""}
            while i < len(expr):
                if expr[i] == '{':
                    update = set()
                    for postfix in parse(expr, i + 1):
                        for prefix in current:
                            update.add(prefix + postfix)
                    current = update
                    i = expr.index('}', i)
                elif expr[i] == '}':
                    break
                elif expr[i] == ',':
                    result |= current
                    current = {""}
                else:
                    current = {s + expr[i] for s in current}
                i += 1
            return result | current
        
        return sorted(parse(expression, 0))

-----
class Solution:
    # Your code here


************************************
Question ID: 1110
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def delNodes(root: TreeNode, to_delete):
    to_delete_set = set(to_delete)
    remaining_trees = []

    def removeNodes(node):
        if node is None:
            return None
        node.left = removeNodes(node.left)
        node.right = removeNodes(node.right)
        if node.val in to_delete_set:
            if node.left:
                remaining_trees.append(node.left)
            if node.right:
                remaining_trees.append(node.right)
            return None
        return node

    if removeNodes(root):
        remaining_trees.append(root)
    return remaining_trees


-----
class TreeNode:
    # Your code here


************************************
Question ID: 1123
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def find_lca_util(root):
    if root is None:
        return None, 0

    left_lca, left_depth = find_lca_util(root.left)
    right_lca, right_depth = find_lca_util(root.right)

    if left_depth > right_depth:
        return left_lca, left_depth + 1
    elif left_depth < right_depth:
        return right_lca, right_depth + 1
    else:
        return root, left_depth + 1

def lca_deepest_leaves(root):
    return find_lca_util(root)[0]


-----
class TreeNode:
    # Your code here


************************************
Question ID: 1145
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def btree_game_winning_move(root: TreeNode, n: int, x: int) -> bool:
    def count_nodes(node: TreeNode) -> int:
        if not node:
            return 0
        return count_nodes(node.left) + count_nodes(node.right) + 1

    def find_node(node: TreeNode, x: int) -> TreeNode:
        if not node:
            return None
        if node.val == x:
            return node
        left_search = find_node(node.left, x)
        if left_search:
            return left_search
        return find_node(node.right, x)

    x_node = find_node(root, x)
    left_nodes = count_nodes(x_node.left)
    right_nodes = count_nodes(x_node.right)
    parent_nodes = n - left_nodes - right_nodes - 1

    return max(max(left_nodes, right_nodes), parent_nodes) > n // 2

-----
class TreeNode:
    # Your code here


************************************
Question ID: 1157
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_insufficient(node, limit, current_sum):
    if not node:
        return True

    current_sum += node.val
    if not node.left and not node.right:
        return current_sum < limit

    left_insufficient = is_insufficient(node.left, limit, current_sum)
    right_insufficient = is_insufficient(node.right, limit, current_sum)

    if left_insufficient:
        node.left = None
    if right_insufficient:
        node.right = None

    return left_insufficient and right_insufficient

def sufficient_subset(root, limit):
    if is_insufficient(root, limit, 0):
        return None
    return root


-----
class TreeNode:
    # Your code here


************************************
Question ID: 1161
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def maxLevelSum(root):
    if not root: return 0

    q = [root]
    level, max_sum, result_level = 0, float('-inf'), 0
    
    while q:
        qlen, sum = len(q), 0
        level += 1

        for i in range(qlen):
            temp = q.pop(0)
            sum += temp.val

            if temp.left: q.append(temp.left)
            if temp.right: q.append(temp.right)

        if sum > max_sum:
            max_sum = sum
            result_level = level
    
    return result_level

-----
class TreeNode:
    # Your code here


************************************
Question ID: 1166
class FileSystem:
    def __init__(self):
        self.path_map = {}

    def create_path(self, path: str, value: int) -> bool:
        if path in self.path_map:
            return False
        parent_path = path[:path.rfind('/')]
        if parent_path and parent_path not in self.path_map:
            return False
        self.path_map[path] = value
        return True

    def get(self, path: str) -> int:
        return self.path_map.get(path, -1)

-----
class FileSystem:
    # Your code here


************************************
Question ID: 1172
class DinnerPlates:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.stacks = []

    def push(self, val: int) -> None:
        for stack in self.stacks:
            if len(stack) < self.capacity:
                stack.append(val)
                return
        self.stacks.append([val])

    def pop(self) -> int:
        while self.stacks and not self.stacks[-1]:
            self.stacks.pop()
        if not self.stacks:
            return -1
        return self.stacks[-1].pop()

    def popAtStack(self, index: int) -> int:
        if index >= len(self.stacks) or not self.stacks[index]:
            return -1
        return self.stacks[index].pop()


-----
class DinnerPlates:
    # Your code here


************************************
Question ID: 1207
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def delNodes(root, to_delete):
    forest = []
    to_delete_set = set(to_delete)
    helper(root, True, to_delete_set, forest)
    return forest

def helper(node, isRoot, to_delete, forest):
    if not node:
        return None
    deleted = node.val in to_delete
    if isRoot and not deleted:
        forest.append(node)
    node.left = helper(node.left, deleted, to_delete, forest)
    node.right = helper(node.right, deleted, to_delete, forest)
    return None if deleted else node


-----
class TreeNode:
    # Your code here


************************************
Question ID: 1214
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def twoSumBSTs(root1, root2, target):
    def build_set(node, s):
        if node:
            s.add(node.val)
            build_set(node.left, s)
            build_set(node.right, s)

    def find_pair(node, target, s):
        if node:
            if target - node.val in s:
                return True
            return find_pair(node.left, target, s) or find_pair(node.right, target, s)
        return False

    s = set()
    build_set(root1, s)
    return find_pair(root2, target, s)

-----
class TreeNode:
    # Your code here


************************************
Question ID: 1218
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:
        def dfs(node):
            if not node:
                return (None, 0)
            left, right = dfs(node.left), dfs(node.right)
            if left[1] > right[1]:
                return (left[0], left[1] + 1)
            elif left[1] < right[1]:
                return (right[0], right[1] + 1)
            else:
                return (node, left[1] + 1)
        
        return dfs(root)[0]


-----
class TreeNode:
    # Your code here


************************************
Question ID: 1248
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def can_win(root, x):
    if not root:
        return False
    if root.val == x:
        left_nodes = 1 + can_win(root.left, x) if root.left else 0
        right_nodes = 1 + can_win(root.right, x) if root.right else 0
        return left_nodes % 2 != 0 or right_nodes % 2 != 0
    return can_win(root.left, x) or can_win(root.right, x)

-----
class TreeNode:
    # Your code here


************************************
Question ID: 1261
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class FindElements:
    def __init__(self, root: TreeNode):
        self.values = set()
        self.recoverTree(root, 0)

    def find(self, target: int) -> bool:
        return target in self.values

    def recoverTree(self, node: TreeNode, val: int):
        if node is None:
            return

        node.val = val
        self.values.add(val)

        self.recoverTree(node.left, val * 2 + 1)
        self.recoverTree(node.right, val * 2 + 2)

-----
class TreeNode:
    # Your code here


************************************
Question ID: 1296
class TreeAncestor:

    def __init__(self, n: int, parent: List[int]):
        self.dp = [[0] * 20 for _ in range(n)]
        for i in range(n):
            self.dp[i][0] = parent[i]
        for k in range(1, 20):
            for i in range(n):
                if self.dp[i][k - 1] != -1:
                    self.dp[i][k] = self.dp[self.dp[i][k - 1]][k - 1]
                else:
                    self.dp[i][k] = -1

    def getKthAncestor(self, node: int, k: int) -> int:
        for i in range(20):
            if k & (1 << i):
                node = self.dp[node][i]
                if node == -1:
                    return -1
        return node

-----
class TreeAncestor:
    # Your code here


************************************
Question ID: 1315
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def sumEvenGrandparent(root, parent=None, grandparent=None):
    if root is None:
        return 0
    sum = root.val if grandparent and grandparent.val % 2 == 0 else 0
    return sum + sumEvenGrandparent(root.left, root, parent) + sumEvenGrandparent(root.right, root, parent)

-----
class TreeNode:
    # Your code here


************************************
Question ID: 1339
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def sum_subtrees(self, root, sums):
        if not root: return 0
        s = root.val + self.sum_subtrees(root.left, sums) + self.sum_subtrees(root.right, sums)
        sums.append(s)
        return s

    def maxProduct(self, root):
        sums = []
        total = self.sum_subtrees(root, sums)
        max_product = max(s * (total - s) for s in sums)
        return max_product % 1000000007

-----
class TreeNode:
    # Your code here


************************************
Question ID: 1357
class Cashier:

    def __init__(self, n: int, discount: int, products: List[int], prices: List[int]):
        self.n = n
        self.discount = discount
        self.customer_count = 0
        self.prices_map = {products[i]: prices[i] for i in range(len(products))}

    def getBill(self, product: List[int], amount: List[int]) -> float:
        self.customer_count += 1
        total = sum(self.prices_map[product[i]] * amount[i] for i in range(len(product)))
        if self.customer_count % self.n == 0:
            total *= (100 - self.discount) / 100
        return total

-----
class Cashier:
    # Your code here


************************************
Question ID: 1373
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def maxSumBST(self, root: TreeNode) -> int:
        max_sum = [0]

        def dfs(node):
            if not node:
                return 1, 0, float("inf"), float("-inf")

            l = dfs(node.left)
            r = dfs(node.right)

            if not l[0] or not r[0] or node.val <= l[3] or node.val >= r[2]:
                return 0, 0, 0, 0

            curr_sum = node.val + l[1] + r[1]
            max_sum[0] = max(max_sum[0], curr_sum)

            return 1, curr_sum, min(node.val, l[2]), max(node.val, r[3])

        dfs(root)
        return max_sum[0]


-----
class TreeNode:
    # Your code here


************************************
Question ID: 1382
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def balanceBST(self, root: TreeNode) -> TreeNode:
        sortedNodes = []
        self.inorderTraversal(root, sortedNodes)
        return self.sortedArrayToBST(sortedNodes, 0, len(sortedNodes) - 1)

    def inorderTraversal(self, node: TreeNode, sortedNodes: list):
        if node is None: return
        self.inorderTraversal(node.left, sortedNodes)
        sortedNodes.append(node)
        self.inorderTraversal(node.right, sortedNodes)

    def sortedArrayToBST(self, sortedNodes: list, start: int, end: int) -> TreeNode:
        if start > end: return None
        mid = start + (end - start) // 2
        newNode = sortedNodes[mid]
        newNode.left = self.sortedArrayToBST(sortedNodes, start, mid - 1)
        newNode.right = self.sortedArrayToBST(sortedNodes, mid + 1, end)
        return newNode


-----
class TreeNode:
    # Your code here


************************************
Question ID: 1396
class UndergroundSystem:

    def __init__(self):
        self.check_in_info = dict()
        self.journey_data = dict()

    def check_in(self, id: int, station_name: str, t: int) -> None:
        self.check_in_info[id] = (station_name, t)

    def check_out(self, id: int, station_name: str, t: int) -> None:
        start_station, start_time = self.check_in_info[id]
        route = (start_station, station_name)
        duration = t - start_time
        if route not in self.journey_data:
            self.journey_data[route] = (0, 0)
        prev_duration, count = self.journey_data[route]
        self.journey_data[route] = (prev_duration + duration, count + 1)

    def get_average_time(self, start_station: str, end_station: str) -> float:
        route = (start_station, end_station)
        duration, count = self.journey_data[route]
        return duration / count

-----
class UndergroundSystem:
    # Your code here


************************************
Question ID: 1411
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def getDecimalValue(head: ListNode) -> int:
    num = 0
    while head:
        num = (num << 1) | head.val
        head = head.next
    return num

-----
class ListNode:
    # Your code here


************************************
Question ID: 1415
class Solution:
    def generate_strings(self, n: int, current: str, strings: list) -> None:
        if n == 0:
            strings.append(current)
            return
        for c in "abc":
            if not current or current[-1] != c:
                self.generate_strings(n - 1, current + c, strings)

    def getHappyString(self, n: int, k: int) -> str:
        strings = []
        self.generate_strings(n, "", strings)
        return strings[k - 1] if k <= len(strings) else ""

-----
class Solution:
    # Your code here


************************************
Question ID: 1427
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def inorder(root):
    output = []
    stack = []
    current = root

    while current or stack:
        while current:
            stack.append(current)
            current = current.left
        current = stack.pop()
        output.append(current.val)
        current = current.right

    return output

def getAllElements(root1, root2):
    tree1 = inorder(root1)
    tree2 = inorder(root2)
    result = []
    i, j = 0, 0

    while i < len(tree1) or j < len(tree2):
        if i < len(tree1) and (j >= len(tree2) or tree1[i] <= tree2[j]):
            result.append(tree1[i])
            i += 1
        else:
            result.append(tree2[j])
            j += 1

    return result

-----
class TreeNode:
    # Your code here


************************************
Question ID: 1430
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def isValidSequence(root, arr, index=0):
    if not root or index >= len(arr) or arr[index] != root.val:
        return False
    if not root.left and not root.right:
        return index == len(arr) - 1
    return isValidSequence(root.left, arr, index + 1) or isValidSequence(root.right, arr, index + 1)

-----
class TreeNode:
    # Your code here


************************************
Question ID: 1433
class Encrypter:
    def __init__(self, keys, values, dictionary):
        self.encrypt_map = dict(zip(keys, values))
        self.decrypt_map = dict(zip(values, keys))
        self.dictionary = set(dictionary)
    
    def encrypt(self, original):
        result = []
        for c in original:
            if c not in self.encrypt_map:
                return ""
            result.append(self.encrypt_map[c])
        return "".join(result)

    def decrypt(self, encrypted):
        result = []
        for i in range(0, len(encrypted), 2):
            temp = encrypted[i:i+2]
            if temp not in self.decrypt_map:
                return ""
            result.append(self.decrypt_map[temp])
        
        decrypted = "".join(result)
        if decrypted not in self.dictionary:
            return ""
        return decrypted

-----
class Encrypter:
    # Your code here


************************************
Question ID: 1465
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def maxProduct(self, root: TreeNode) -> int:
        def dfs(node):
            if not node:
                return 0
            return node.val + dfs(node.left) + dfs(node.right)

        def dfs2(node, half):
            nonlocal result

            if not node:
                return 0
            cur_sum = node.val + dfs2(node.left, half) + dfs2(node.right, half)
            result = max(result, (total - cur_sum) * cur_sum)
            return cur_sum

        total = dfs(root)
        result = 0
        dfs2(root, total / 2)
        return result % (10**9 + 7)

-----
class TreeNode:
    # Your code here


************************************
Question ID: 1474
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def longestZigZag(root: TreeNode) -> int:
    maxLen = [0]
    
    def longestZigZagUtil(root, left):
        if not root:
            return -1

        leftZig = longestZigZagUtil(root.left, True)
        rightZig = longestZigZagUtil(root.right, False)

        maxLen[0] = max(maxLen[0], max(leftZig, rightZig) + 1)
        return rightZig + 1 if left else leftZig + 1

    longestZigZagUtil(root, True)
    longestZigZagUtil(root, False)
    return maxLen[0]


-----
class TreeNode:
    # Your code here


************************************
Question ID: 1475
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def maxSumBST(root):
    def helper(node):
        if not node:
            return float('inf'), float('-inf'), 0, True

        left_min, left_max, left_sum, is_left_bst = helper(node.left)
        right_min, right_max, right_sum, is_right_bst = helper(node.right)

        if is_left_bst and is_right_bst and node.val > left_max and node.val < right_min:
            sum_ = node.val + left_sum + right_sum
            max_sum[0] = max(max_sum[0], sum_)
            return min(node.val, left_min), max(node.val, right_max), sum_, True

        return 0, 0, 0, False

    max_sum = [0]
    helper(root)
    return max_sum[0]

-----
class TreeNode:
    # Your code here


************************************
Question ID: 1477
class ProductOfNumbers:
    def __init__(self):
        self.products = [1]

    def add(self, num: int) -> None:
        if num == 0:
            self.products = [1]
        else:
            self.products.append(self.products[-1] * num)

    def getProduct(self, k: int) -> int:
        if k >= len(self.products):
            return 0
        else:
            return self.products[-1] // self.products[-k - 1]


-----
class ProductOfNumbers:
    # Your code here


************************************
Question ID: 1506
class Solution:
    def findRoot(self, nodes: List['Node']) -> 'Node':
        value_sum = 0
        
        for node in nodes:
            value_sum += node.val
            
            for child in node.children:
                value_sum -= child.val
        
        for node in nodes:
            if node.val == value_sum:
                return node
                
        return None


-----
class Solution:
    # Your code here


************************************
Question ID: 1512
class UndergroundSystem:
    def __init__(self):
        self.check_in_data = {}
        self.travel_data = {}

    def checkIn(self, id: int, stationName: str, t: int) -> None:
        self.check_in_data[id] = (stationName, t)

    def checkOut(self, id: int, stationName: str, t: int) -> None:
        start_station, start_time = self.check_in_data[id]
        route = (start_station, stationName)
        if route not in self.travel_data:
            self.travel_data[route] = [0, 0]
        self.travel_data[route][0] += t - start_time
        self.travel_data[route][1] += 1

    def getAverageTime(self, startStation: str, endStation: str) -> float:
        route = (startStation, endStation)
        total_time, num_trips = self.travel_data[route]
        return total_time / num_trips

-----
class UndergroundSystem:
    # Your code here


************************************
Question ID: 1572
class SubrectangleQueries:
    def __init__(self, rectangle: List[List[int]]):
        self.rectangle = rectangle

    def updateSubrectangle(self, row1: int, col1: int, row2: int, col2: int, newValue: int) -> None:
        for i in range(row1, row2 + 1):
            for j in range(col1, col2 + 1):
                self.rectangle[i][j] = newValue

    def getValue(self, row: int, col: int) -> int:
        return self.rectangle[row][col]

-----
class SubrectangleQueries:
    # Your code here


************************************
Question ID: 1577
class Solution:
    def getProbability(self, balls: List[int]) -> float:
        pre_sum = [0]
        dp = [[[0]*62 for _ in range(10)] for _ in range(35)]
        k = len(balls)

        for b in balls:
            pre_sum.append(pre_sum[-1] + b)

        dp[0][0][0] = 1
        for i in range(k):
            for j in reversed(range(i + 1)):
                for x in reversed(range(pre_sum[i+1] + 1)):
                    for y in reversed(range(0, pre_sum[i+1] - x + 1)):
                        if x + y <= balls[i]:
                            for d in range(max(0, balls[i] - 2 * y), x + 1):
                                tmp = 1
                                for z in range(1, d + 1):
                                    tmp *= (x + y + 1 - z) / z
                                for z in range(1, y + 1):
                                    tmp *= (x + y + d + 1 - z) / z
                                for z in range(1, balls[i] - y - y - d + 1):
                                    tmp *= (x + y + d + 1 - z) / z
                                dp[i+1][j+1][x + d] += dp[i][j][x] * tmp
                                dp[i+1][j][x + d] += dp[i][j][x] * tmp

        sum_ = sum(balls)
        return (dp[k][k >> 1][sum_ >> 1] - (1e-5 > dp[k][k >> 1][sum_ >> 1])) / (1 if sum_ % 2 else (1 << (sum_ >> 1)))


-----
class Solution:
    # Your code here


************************************
Question ID: 1579
class UnionFind:
    def __init__(self, size):
        self.parent = list(range(size))
        self.components = size

    def find(self, x):
        if x != self.parent[x]:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def unite(self, x, y):
        root_x, root_y = self.find(x), self.find(y)
        if root_x != root_y:
            self.parent[root_x] = root_y
            self.components -= 1
            return True
        return False

def max_num_edges_to_remove(n, edges):
    ufA, ufB = UnionFind(n + 1), UnionFind(n + 1)
    common_edges = 0

    for t, u, v in edges:
        if t == 3:
            if ufA.unite(u, v):
                ufB.unite(u, v)
                common_edges += 1

    removed_edges = 0
    for t, u, v in edges:
        uf = ufA if t == 1 else ufB if t == 2 else None
        if uf and not uf.unite(u, v):
            removed_edges += 1

    return -1 if ufA.components != 2 or ufB.components != 2 else removed_edges - common_edges

-----
class UnionFind:
    # Your code here


************************************
Question ID: 1582
class BrowserHistory:

    def __init__(self, homepage: str):
        self.history = [homepage]
        self.current_index = 0

    def visit(self, url: str):
        self.history = self.history[:self.current_index + 1]
        self.history.append(url)
        self.current_index += 1

    def back(self, steps: int) -> str:
        self.current_index -= min(steps, self.current_index)
        return self.history[self.current_index]

    def forward(self, steps:int) -> str:
        self.current_index += min(steps, len(self.history) - 1 - self.current_index)
        return self.history[self.current_index]


-----
class BrowserHistory:
    # Your code here


************************************
Question ID: 1597
class Solution:
    def expTree(self, s: str) -> 'Node':
        def precedence(a, b):
            if a == '(':
                return False
            if b == '(' or b == ')':
                return True
            if (a in {'*', '/'}) and (b in {'+', '-'}):
                return True
            return False
        
        def process(nodes, ops):
            right = nodes.pop()
            left = nodes.pop()
            oper = Node(ops.pop())
            oper.left = left
            oper.right = right
            nodes.append(oper)
            
        nodes = []
        ops = []
        for i in s:
            if i.isdigit():
                nodes.append(Node(i))
            elif i == '(':
                ops.append(i)
            elif i == ')':
                while ops[-1] != '(':
                    process(nodes, ops)
                ops.pop()
            else:
                while ops and precedence(ops[-1], i):
                    process(nodes, ops)
                ops.append(i)
        while ops:
            process(nodes, ops)
        return nodes[0]

-----
class Solution:
    # Your code here


************************************
Question ID: 1600
class ThroneInheritance:

    def __init__(self, kingName: str):
        self.king = kingName
        self.family = {}
        self.dead = set()

    def birth(self, parentName: str, childName: str) -> None:
        if parentName not in self.family:
            self.family[parentName] = []
        self.family[parentName].append(childName)

    def death(self, name: str) -> None:
        self.dead.add(name)

    def getInheritanceOrder(self) -> List[str]:
        order = []
        self.dfs(self.king, order)
        return order

    def dfs(self, name: str, order: List[str]) -> None:
        if name not in self.dead:
            order.append(name)
        if name in self.family:
            for child in self.family[name]:
                self.dfs(child, order)


-----
class ThroneInheritance:
    # Your code here


************************************
Question ID: 1602
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def find_nearest_right_node(root, u):
    if not root:
        return None
    
    q = [root]
    
    while q:
        n = len(q)
        
        for i in range(n):
            current = q.pop(0)
            
            if current == u:
                return q[0] if i < n - 1 else None
            
            if current.left:
                q.append(current.left)
            if current.right:
                q.append(current.right)
    
    return None

-----
class TreeNode:
    # Your code here


************************************
Question ID: 1634
class PolyNode:
    def __init__(self, c: int, p: int, next: 'PolyNode' = None):
        self.coefficient = c
        self.power = p
        self.next = next

def addPoly(poly1: PolyNode, poly2: PolyNode) -> PolyNode:
    dummy = PolyNode(0, 0)
    current = dummy

    while poly1 and poly2:
        if poly1.power > poly2.power:
            current.next = poly1
            poly1 = poly1.next
        elif poly1.power < poly2.power:
            current.next = poly2
            poly2 = poly2.next
        else:
            sum = poly1.coefficient + poly2.coefficient
            if sum != 0:
                current.next = PolyNode(sum, poly1.power)
                current = current.next
            poly1 = poly1.next
            poly2 = poly2.next
        current = current.next

    current.next = poly1 if poly1 else poly2
    return dummy.next


-----
class PolyNode:
    # Your code here


************************************
Question ID: 1650
class Node:
    def __init__(self, val=0, left=None, right=None, parent=None):
        self.val = val
        self.left = left
        self.right = right
        self.parent = parent

def lowest_common_ancestor(p, q):
    a, b = p, q
    while a != b:
        a = a.parent if a.parent else q
        b = b.parent if b.parent else p
    return a

-----
class Node:
    # Your code here


************************************
Question ID: 1676
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def lowestCommonAncestor(root, nodes):
    if root is None or root in nodes:
        return root
    left = lowestCommonAncestor(root.left, nodes)
    right = lowestCommonAncestor(root.right, nodes)
    if left is not None and right is not None:
        return root
    return left if left is not None else right


-----
class TreeNode:
    # Your code here


************************************
Question ID: 1708
class ParkingSystem:

    def __init__(self, big: int, medium: int, small: int):
        self.slots = [big, medium, small]

    def addCar(self, carType: int) -> bool:
        if self.slots[carType - 1] > 0:
            self.slots[carType - 1] -= 1
            return True
        else:
            return False

-----
class ParkingSystem:
    # Your code here


************************************
Question ID: 1718
class Solution:
    def constructDistancedSequence(self, n: int) -> List[int]:
        res = [0] * (2 * n - 1)

        def backtrack(i, unused):
            if i == len(res):
                return True
            if res[i]:
                return backtrack(i + 1, unused)
            for num in range(n, 0, -1):
                if (unused >> num) & 1:
                    if num == 1 or (i + num < len(res) and not res[i + num]):
                        res[i] = num
                        if num > 1:
                            res[i + num] = num
                        if backtrack(i + 1, unused ^ (1 << num)):
                            return True
                        res[i] = 0
                        if num > 1:
                            res[i + num] = 0
            return False

        backtrack(0, (1 << (n + 1)) - 2)
        return res

-----
class Solution:
    # Your code here


************************************
Question ID: 1722
class ThroneInheritance:
    def __init__(self, kingName: str):
        self.children = {}
        self.alive = {kingName: True}
        self.king = kingName

    def birth(self, parentName: str, childName: str):
        if parentName not in self.children:
            self.children[parentName] = []
        self.children[parentName].append(childName)
        self.alive[childName] = True

    def death(self, name: str):
        self.alive[name] = False

    def getInheritanceOrder(self):
        order = []
        self.getSuccessor(self.king, order)
        return order

    def getSuccessor(self, name: str, order: list):
        if self.alive[name]:
            order.append(name)
        for child in self.children.get(name, []):
            self.getSuccessor(child, order)

-----
class ThroneInheritance:
    # Your code here


************************************
Question ID: 1724
class DistanceLimitedPathsExist:
    def __init__(self, n: int, edgeList: List[List[int]]):
        self.id = list(range(n))
        edgeList.sort(key=lambda x: x[2])
        self.mst = []
        for edge in edgeList:
            p, q = self.find(edge[0]), self.find(edge[1])
            if p != q:
                self.id[p] = self.id[q]
                self.mst.append(edge)

    def query(self, p: int, q: int, limit: int) -> bool:
        for edge in self.mst:
            if edge[2] >= limit:
                break
            p, q = self.union_set(edge[0], p), self.union_set(edge[1], q)
            if p == q:
                return True
        return False

    def find(self, x: int) -> int:
        if self.id[x] != x:
            self.id[x] = self.find(self.id[x])
        return self.id[x]

    def union_set(self, x: int, y: int) -> int:
        px, py = self.find(x), self.find(y)
        if px != py:
            self.id[px] = py
        return py

-----
class DistanceLimitedPathsExist:
    # Your code here


************************************
Question ID: 1728
class Fancy:
    def __init__(self):
        self.sequence = []

    def append(self, val):
        self.sequence.append(val)

    def addAll(self, inc):
        self.sequence = [num + inc for num in self.sequence]

    def multAll(self, m):
        self.sequence = [num * m for num in self.sequence]

    def getIndex(self, idx):
        if idx >= len(self.sequence):
            return -1
        return self.sequence[idx]


-----
class Fancy:
    # Your code here


************************************
Question ID: 1765
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeInBetween(list1, a, b, list2):
    prev, curr = None, list1
    index = 0
    
    while curr:
        if index == a:
            last = list2
            while last.next:
                last = last.next
            prev.next = list2
            last.next = curr.next
            break
            
        if index > a and index < b:
            curr = curr.next
        else:
            prev = curr
            curr = curr.next

        index += 1

    return list1

-----
class ListNode:
    # Your code here


************************************
Question ID: 1775
class OrderedStream:
    def __init__(self, n: int):
        self.ptr = 1
        self.data = {}

    def insert(self, idKey: int, value: str):
        self.data[idKey] = value
        result = []
        while self.ptr in self.data:
            result.append(self.data[self.ptr])
            self.ptr += 1
        return result


-----
class OrderedStream:
    # Your code here


************************************
Question ID: 1810
class Solution:
    def findShortestPath(self, master: 'GridMaster') -> int:
        def dfs(master, x, y):
            nonlocal target
            if master.isTarget():
                target = (x, y)
            for i in range(4):
                nx, ny = x + dirs[i], y + dirs[i + 1]
                if (nx, ny) in grid:
                    continue
                if master.canMove(DIR_CHAR[i]):
                    cost = master.move(DIR_CHAR[i])
                    grid[(nx, ny)] = cost
                    dfs(master, nx, ny)
                    master.move(OPPOSITE_DIR_CHAR[i])
                    
        def bfs():
            q = deque([(0, 0)])
            grid[(0, 0)] = 0
            while q:
                x, y = q.popleft()
                for i in range(4):
                    nx, ny = x + dirs[i], y + dirs[i + 1]
                    cost = grid[(x, y)] + grid.get((nx, ny), 0)
                    if (nx, ny) in grid and grid[(nx, ny)] > cost:
                        grid[(nx, ny)] = cost
                        if (nx, ny) != target:
                            q.append((nx, ny))
            return grid.get(target, -1)
        
        dirs = [-1, 0, 1, 0, -1]
        DIR_CHAR = "URDL"
        OPPOSITE_DIR_CHAR = "DLUR"
        grid = {}
        target = None
        
        dfs(master, 0, 0)
        if target is None:
            return -1
        
        return bfs()

-----
class Solution:
    # Your code here


************************************
Question ID: 1905
class AuthenticationManager {
    constructor(timeToLive) {
        this.timeToLive = timeToLive;
        this.tokens = new Map();
    }

    generate(tokenId, currentTime) {
        this.tokens.set(tokenId, currentTime + this.timeToLive);
    }

    renew(tokenId, currentTime) {
        if (this.tokens.has(tokenId) && this.tokens.get(tokenId) > currentTime) {
            this.tokens.set(tokenId, currentTime + this.timeToLive);
        }
    }

    countUnexpiredTokens(currentTime) {
        let count = 0;
        for (const expirationTime of this.tokens.values()) {
            if (expirationTime > currentTime) count++;
        }
        return count;
    }
}


-----
class AuthenticationManager {
    # Your code here


************************************
Question ID: 1932
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def canMerge(trees):
    leaf_count = {}
    root_map = {}
    
    for tree in trees:
        if tree.left:
            leaf_count[tree.left.val] = leaf_count.get(tree.left.val, 0) + 1
        if tree.right:
            leaf_count[tree.right.val] = leaf_count.get(tree.right.val, 0) + 1
        root_map[tree.val] = tree

    def is_valid_bst(node, min_val, max_val):
        if not node:
            return True
        if node.val <= min_val or node.val >= max_val:
            return False
        if node.left and node.left.val in root_map:
            left_child = root_map.pop(node.left.val)
            leaf_count[tree.left.val] -= 1
            tree.left = left_child
        if node.right and node.right.val in root_map:
            right_child = root_map.pop(node.right.val)
            leaf_count[tree.right.val] -= 1
            tree.right = right_child
        return is_valid_bst(node.left, min_val, node.val) and is_valid_bst(node.right, node.val, max_val)
            

    for tree in trees:
        if leaf_count.get(tree.val, 0) == 0:
            if is_valid_bst(tree, 0, 5e4 + 1):
                return tree
            break

    return None

-----
class TreeNode:
    # Your code here


************************************
