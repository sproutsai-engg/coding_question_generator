Question ID: 1

import java.util.HashMap;
import java.util.Map;

public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement)) {
            return new int[]{map.get(complement), i};
        }
        map.put(nums[i], i);
    }
    throw new IllegalArgumentException("No two sum solution");
}

-----
import java.util.HashMap;
import java.util.Map;

public int[] twoSum(int[] nums, int target) 
    // Your code here
}

************************************
Question ID: 3

import java.util.HashSet;
import java.util.Set;

public int lengthOfLongestSubstring(String s) {
    int left = 0, right = 0, maxLength = 0;
    Set<Character> characters = new HashSet<>();

    while (right < s.length()) {
        if (!characters.contains(s.charAt(right))) {
            characters.add(s.charAt(right));
            maxLength = Math.max(maxLength, right - left + 1);
            right++;
        } else {
            characters.remove(s.charAt(left));
            left++;
        }
    }

    return maxLength;
}

-----
import java.util.HashSet;
import java.util.Set;

public int lengthOfLongestSubstring(String s) 
    // Your code here
}

************************************
Question ID: 4

public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    if (nums1.length > nums2.length) {
        return findMedianSortedArrays(nums2, nums1);
    }
    
    int x = nums1.length;
    int y = nums2.length;
    int low = 0;
    int high = x;
    
    while (low <= high) {
        int partitionX = (low + high) / 2;
        int partitionY = (x + y + 1) / 2 - partitionX;
        
        int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];
        int minRightX = (partitionX == x) ? Integer.MAX_VALUE : nums1[partitionX];
        
        int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : nums2[partitionY - 1];
        int minRightY = (partitionY == y) ? Integer.MAX_VALUE : nums2[partitionY];
        
        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {
            if ((x + y) % 2 == 0) {
                return (double)(Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;
            } else {
                return (double)Math.max(maxLeftX, maxLeftY);
            }
        } else if (maxLeftX > minRightY) {
            high = partitionX - 1;
        } else {
            low = partitionX + 1;
        }
    }    
    return 0;
}

-----
public double findMedianSortedArrays(int[] nums1, int[] nums2) 
    // Your code here
}

************************************
Question ID: 5

public String longestPalindromicSubstring(String s) {
    int n = s.length();
    if (n == 0) return "";

    int start = 0, maxLength = 1;

    for (int i = 0; i < n; ++i) {
        int l = i, r = i;

        while (r < n - 1 && s.charAt(r) == s.charAt(r + 1))
            r++;
        i = r;

        while (l > 0 && r < n - 1 && s.charAt(l - 1) == s.charAt(r + 1)) {
            l--;
            r++;
        }

        int length = r - l + 1;
        if (length > maxLength) {
            start = l;
            maxLength = length;
        }
    }

    return s.substring(start, start + maxLength);
}

-----
public String longestPalindromicSubstring(String s) 
    // Your code here
}

************************************
Question ID: 6

public class ZigzagConversion {
    public String convert(String s, int numRows) {
        if (numRows == 1 || numRows >= s.length()) return s;

        StringBuilder[] rows = new StringBuilder[numRows];
        for (int i = 0; i < numRows; i++) rows[i] = new StringBuilder();
        
        int curRow = 0;
        boolean goingDown = false;

        for (char c : s.toCharArray()) {
            rows[curRow].append(c);
            if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;
            curRow += goingDown ? 1 : -1;
        }

        StringBuilder result = new StringBuilder();
        for (StringBuilder row : rows) result.append(row);
        return result.toString();
    }
}

-----
public class ZigzagConversion 
    // Your code here
}

************************************
Question ID: 7

public int reverse(int x) {
    long res = 0;
    while (x != 0) {
        res = res * 10 + x % 10;
        x /= 10;
    }
    return (res < Integer.MIN_VALUE || res > Integer.MAX_VALUE) ? 0 : (int)res;
}

-----
public int reverse(int x) 
    // Your code here
}

************************************
Question ID: 8

public int myAtoi(String s) {
    long result = 0;
    int i = 0, sign = 1;
    while (i < s.length() && s.charAt(i) == ' ') i++;
    if (i < s.length() && (s.charAt(i) == '-' || s.charAt(i) == '+')) {
        sign = (s.charAt(i++) == '+') ? 1 : -1;
    }
    while (i < s.length() && Character.isDigit(s.charAt(i))) {
        result = result * 10 + (s.charAt(i++) - '0');
        if (result * sign > Integer.MAX_VALUE) return Integer.MAX_VALUE;
        if (result * sign < Integer.MIN_VALUE) return Integer.MIN_VALUE;
    }
    return (int) (result * sign);
}

-----
public int myAtoi(String s) 
    // Your code here
}

************************************
Question ID: 9

public boolean isPalindrome(int x) {
    if (x < 0) return false;
    int original = x, reversed = 0;
    while (x > 0) {
        reversed = reversed * 10 + x % 10;
        x /= 10;
    }
    return original == reversed;
}


-----
public boolean isPalindrome(int x) 
    // Your code here
}


************************************
Question ID: 10

public boolean isMatch(String s, String p) {
    int m = s.length(), n = p.length();
    boolean[][] dp = new boolean[m + 1][n + 1];
    dp[0][0] = true;

    for (int j = 1; j <= n; j++) {
        if (p.charAt(j - 1) == '*' && dp[0][j - 2]) {
            dp[0][j] = true;
        }
    }

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (p.charAt(j - 1) == s.charAt(i - 1) || p.charAt(j - 1) == '.') {
                dp[i][j] = dp[i - 1][j - 1];
            } else if (p.charAt(j - 1) == '*') {
                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'));
            }
        }
    }

    return dp[m][n];
}

-----
public boolean isMatch(String s, String p) 
    // Your code here
}

************************************
Question ID: 11

public int maxArea(int[] height) {
    int max_area = 0, left = 0, right = height.length - 1;
    while (left < right) {
        max_area = Math.max(max_area, Math.min(height[left], height[right]) * (right - left));
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }
    return max_area;
}

-----
public int maxArea(int[] height) 
    // Your code here
}

************************************
Question ID: 12

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class RomanNumerals {
    public static String intToRoman(int num) {
        List<Pair> romans = Arrays.asList(
            new Pair(1000, "M"), new Pair(900, "CM"), new Pair(500, "D"), 
            new Pair(400, "CD"), new Pair(100, "C"), new Pair(90, "XC"),
            new Pair(50, "L"), new Pair(40, "XL"), new Pair(10, "X"), 
            new Pair(9, "IX"), new Pair(5, "V"), new Pair(4, "IV"),
            new Pair(1, "I")
        );
        StringBuilder roman = new StringBuilder();
        for (Pair p : romans) {
            while (num >= p.num) {
                roman.append(p.symbol);
                num -= p.num;
            }
        }
        return roman.toString();
    }
    
    private static class Pair {
        final int num;
        final String symbol;
        
        Pair(int num, String symbol) {
            this.num = num;
            this.symbol = symbol;
        }
    }
}

-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class RomanNumerals 
    // Your code here
}

************************************
Question ID: 13

public int romanToInt(String s) {
    Map<Character, Integer> romanValues = new HashMap<>();
    romanValues.put('I', 1);
    romanValues.put('V', 5);
    romanValues.put('X', 10);
    romanValues.put('L', 50);
    romanValues.put('C', 100);
    romanValues.put('D', 500);
    romanValues.put('M', 1000);

    int total = 0;
    int prevValue = 0;

    for (char c : s.toCharArray()) {
        int currValue = romanValues.get(c);
        total += currValue > prevValue ? currValue - 2 * prevValue : currValue;
        prevValue = currValue;
    }

    return total;
}


-----
public int romanToInt(String s) 
    // Your code here
}


************************************
Question ID: 14

public String longestCommonPrefix(String[] strs) {
    if (strs.length == 0) return "";

    for (int i = 0; i < strs[0].length(); ++i) {
        char c = strs[0].charAt(i);
        for (int j = 1; j < strs.length; ++j) {
            if (i == strs[j].length() || strs[j].charAt(i) != c) {
                return strs[0].substring(0, i);
            }
        }
    }
    return strs[0];
}

-----
public String longestCommonPrefix(String[] strs) 
    // Your code here
}

************************************
Question ID: 15

import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> threeSum(int[] nums) {
    Arrays.sort(nums);
    List<List<Integer>> result = new ArrayList<>();

    for (int i = 0; i < nums.length - 2; i++) {
        if (i == 0 || nums[i] != nums[i - 1]) {
            int j = i + 1, k = nums.length - 1;
            while (j < k) {
                int sum = nums[i] + nums[j] + nums[k];
                if (sum == 0) {
                    result.add(Arrays.asList(nums[i], nums[j], nums[k]));
                    while (j < k && nums[j] == nums[j + 1]) j++;
                    while (j < k && nums[k] == nums[k - 1]) k--;
                    j++;
                    k--;
                } else if (sum < 0) {
                    j++;
                } else {
                    k--;
                }                    
            }
        }
    }

    return result;
}

-----
import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> threeSum(int[] nums) 
    // Your code here
}

************************************
Question ID: 16

import java.util.Arrays;

public int threeSumClosest(int[] nums, int target) {
    Arrays.sort(nums);
    int closest = nums[0] + nums[1] + nums[2];
    for (int i = 0; i < nums.length - 2; ++i) {
        int left = i + 1;
        int right = nums.length - 1;
        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];
            if (sum == target) {
                return sum;
            }
            if (Math.abs(target - sum) < Math.abs(target - closest)) {
                closest = sum;
            }
            if (sum < target) {
                left++;
            } else {
                right--;
            }
        }
    }
    return closest;
}

-----
import java.util.Arrays;

public int threeSumClosest(int[] nums, int target) 
    // Your code here
}

************************************
Question ID: 17

public List<String> letterCombinations(String digits) {
    LinkedList<String> output = new LinkedList<>();
    if(digits.isEmpty()) return output;
    
    String[] phone = new String[] {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    output.add("");
    
    for(char d : digits.toCharArray()){
        while(output.peek().length() == digits.indexOf(d)){
            String perm = output.remove();
            for(char c : phone[d - '2'].toCharArray()){
                output.add(perm + c);
            }
        }
    }
    
    return output;
}

-----
public List<String> letterCombinations(String digits) 
    // Your code here
}

************************************
Question ID: 18

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<List<Integer>> fourSum(int[] nums, int target) {
    List<List<Integer>> result = new ArrayList<>();
    if(nums == null || nums.length < 4)
        return result;

    Arrays.sort(nums);
    for(int i = 0; i < nums.length - 3; i++) {
        if(i > 0 && nums[i] == nums[i-1])
            continue;

        for(int j = i + 1; j < nums.length - 2; j++) {
            if(j > i + 1 && nums[j] == nums[j-1])
                continue;

            int left = j + 1;
            int right = nums.length - 1;
            while(left < right) {
                int sum = nums[i] + nums[j] + nums[left] + nums[right];
                if(sum == target) {
                    result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));
                    ++left;
                    --right;
                    while(left < right && nums[left] == nums[left - 1]) ++left;
                    while(left < right && nums[right] == nums[right + 1]) --right;
                } else if(sum < target) {
                    ++left;
                } else {
                    --right;
                }
            }
        }
    }
    return result;
}


-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<List<Integer>> fourSum(int[] nums, int target) 
    // Your code here
}


************************************
Question ID: 20

boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();

    for (char c : s.toCharArray()) {
        if (c == '(' || c == '{' || c == '[') {
            stack.push(c);
        } else {
            if (stack.empty()) return false;
            if (c == ')' && stack.peek() != '(') return false;
            if (c == '}' && stack.peek() != '{') return false;
            if (c == ']' && stack.peek() != '[') return false;
            stack.pop();
        }
    }

    return stack.empty();
}

-----
boolean isValid(String s) 
    // Your code here
}

************************************
Question ID: 22

import java.util.ArrayList;
import java.util.List;

public List<String> generateParenthesis(int n) {
    List<String> result = new ArrayList<>();
    generateParenthesisHelper(n, 0, "", result);
    return result;
}

private void generateParenthesisHelper(int open, int close, String current, List<String> result) {
    if (open == 0 && close == 0) {
        result.add(current);
        return;
    }
    if (open > 0) {
        generateParenthesisHelper(open - 1, close + 1, current + '(', result);
    }
    if (close > 0) {
        generateParenthesisHelper(open, close - 1, current + ')', result);
    }
}


-----
import java.util.ArrayList;
import java.util.List;

public List<String> generateParenthesis(int n) 
    // Your code here
}


************************************
Question ID: 24

public ListNode swapPairs(ListNode head) {
    if (head == null || head.next == null) return head;
    
    ListNode second = head.next;
    head.next = swapPairs(second.next);
    second.next = head;
    
    return second;
}

-----
public ListNode swapPairs(ListNode head) 
    // Your code here
}

************************************
Question ID: 26

public int removeDuplicates(int[] nums) {
    if (nums.length == 0) return 0;
    int i = 0;
    for (int j = 1; j < nums.length; j++) {
        if (nums[j] != nums[i]) {
            i++;
            nums[i] = nums[j];
        }
    }
    return i + 1;
}


-----
public int removeDuplicates(int[] nums) 
    // Your code here
}


************************************
Question ID: 27

public int removeElement(int[] nums, int val) {
    int i = 0;
    for (int j = 0; j < nums.length; j++) {
        if (nums[j] != val) {
            nums[i] = nums[j];
            i++;
        }
    }
    return i;
}

-----
public int removeElement(int[] nums, int val) 
    // Your code here
}

************************************
Question ID: 28

public int strStr(String haystack, String needle) {
    if (needle.isEmpty()) return 0;
    
    int index = haystack.indexOf(needle);
    return index;
}

-----
public int strStr(String haystack, String needle) 
    // Your code here
}

************************************
Question ID: 29

public int divide(int dividend, int divisor) {
    if (dividend == Integer.MIN_VALUE && divisor == -1) {
        return Integer.MAX_VALUE;
    }

    int sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;

    long dvd = Math.abs((long) dividend);
    long dvs = Math.abs((long) divisor);
    int ans = 0;

    while (dvd >= dvs) {
        long temp = dvs, multiple = 1;
        while (dvd >= (temp << 1)) {
            temp <<= 1;
            multiple <<= 1;
        }
        dvd -= temp;
        ans += multiple;
    }

    return ans * sign;
}

-----
public int divide(int dividend, int divisor) 
    // Your code here
}

************************************
Question ID: 30

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public List<Integer> findSubstring(String s, String[] words) {
    if (s == null || s.length() == 0 || words == null || words.length == 0) return new ArrayList<>();
    
    Map<String, Integer> word_count = new HashMap<>();
    for (String word : words) {
        word_count.put(word, word_count.getOrDefault(word, 0) + 1);
    }
    
    int word_length = words[0].length();
    int total_words = words.length;
    int total_length = word_length * total_words;
    List<Integer> result = new ArrayList<>();
    
    for (int i = 0; i <= s.length() - total_length; i++) {
        Map<String, Integer> temp_word_count = new HashMap<>();
        for (int j = 0; j < total_words; j++) {
            String current_word = s.substring(i + j * word_length, i + (j + 1) * word_length);
            if (!word_count.containsKey(current_word)) break;
            temp_word_count.put(current_word, temp_word_count.getOrDefault(current_word, 0) + 1);
            if (temp_word_count.get(current_word) > word_count.get(current_word)) break;
            if (j + 1 == total_words) result.add(i);
        }
    }
    
    return result;
}

-----
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public List<Integer> findSubstring(String s, String[] words) 
    // Your code here
}

************************************
Question ID: 31

public void nextPermutation(int[] nums) {
    int n = nums.length, k = n - 2, l;
    while(k >= 0 && nums[k] >= nums[k + 1]) k--;

    if(k < 0) {
        Arrays.sort(nums);
    } else {
        for (l = n - 1; l > k; l--) {
            if (nums[l] > nums[k]) break;
        }
        int temp = nums[k];
        nums[k] = nums[l];
        nums[l] = temp;
        Arrays.sort(nums, k + 1, n);
    }
}

-----
public void nextPermutation(int[] nums) 
    // Your code here
}

************************************
Question ID: 32

import java.util.Stack;

public int longestValidParentheses(String s) {
    int n = s.length();
    int result = 0;
    Stack<Integer> st = new Stack<>();

    for (int i = 0; i < n; ++i) {
        if (s.charAt(i) == '(') {
            st.push(i);
        } else {
            if (!st.empty() && s.charAt(st.peek()) == '(') {
                st.pop();
            } else {
                st.push(i);
            }
        }
    }

    if (st.empty()) {
        result = n;
    } else {
        int right = n, left = 0;
        while (!st.empty()) {
            left = st.pop();
            result = Math.max(result, right - left - 1);
            right = left;
        }
        result = Math.max(result, right);
    }

    return result;
}

-----
import java.util.Stack;

public int longestValidParentheses(String s) 
    // Your code here
}

************************************
Question ID: 33

public int search(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        }
        if (nums[mid] >= nums[left]) {
            if (target >= nums[left] && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            if (target > nums[mid] && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    return -1;
}

-----
public int search(int[] nums, int target) 
    // Your code here
}

************************************
Question ID: 34

public int[] searchRange(int[] nums, int target) {
    int start = -1, end = -1;
    int left = 0, right = nums.length - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
            if (nums[mid] == target) {
                start = mid;
            }
        }
    }
    
    left = 0;
    right = nums.length - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
            if (nums[mid] == target) {
                end = mid;
            }
        }
    }
    
    return new int[] {start, end};
}

-----
public int[] searchRange(int[] nums, int target) 
    // Your code here
}

************************************
Question ID: 35

public int searchInsert(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) return mid;
        if (nums[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return left;
}

-----
public int searchInsert(int[] nums, int target) 
    // Your code here
}

************************************
Question ID: 36

public boolean isValidSudoku(char[][] board) {
    HashSet<String> seen = new HashSet<>();
    
    for(int i = 0; i < 9; i++) {
        for(int j = 0; j < 9; j++) {
            char current_val = board[i][j];
            if(current_val != '.') {
                String row = current_val + " in row " + i;
                String col = current_val + " in col " + j;
                String box = current_val + " in box " + i / 3 + "-" + j / 3;
                if(seen.contains(row) || seen.contains(col) || seen.contains(box)) {
                    return false;
                }
                seen.add(row);
                seen.add(col);
                seen.add(box);
            }
        }
    }
    return true;
}


-----
public boolean isValidSudoku(char[][] board) 
    // Your code here
}


************************************
Question ID: 37

import java.util.*;

class Solution {
    public boolean isValid(char[][] board, int row, int col, char c) {
        for (int i = 0; i < 9; i++) {
            if (board[i][col] == c) return false;
            if (board[row][i] == c) return false;
            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false;
        }
        return true;
    }

    public boolean solveSudokuHelper(char[][] board) {
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] == '.') {
                    for (char c = '1'; c <= '9'; c++) {
                        if (isValid(board, i, j, c)) {
                            board[i][j] = c;

                            if (solveSudokuHelper(board)) {
                                return true;
                            }

                            board[i][j] = '.';
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }

    public void solveSudoku(char[][] board) {
        solveSudokuHelper(board);
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 38

public String countAndSay(int n) {
    if (n == 1) return "1";
    String previous = countAndSay(n-1);
    StringBuilder result = new StringBuilder();
    int count = 1;
    for (int i = 1; i < previous.length(); i++) {
        if (previous.charAt(i) == previous.charAt(i-1)) {
            count++;
        } else {
            result.append(count).append(previous.charAt(i-1));
            count = 1;
        }
    }
    result.append(count).append(previous.charAt(previous.length()-1));
    return result.toString();
}

-----
public String countAndSay(int n) 
    // Your code here
}

************************************
Question ID: 39

import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> combinationSum(int[] candidates, int target) {
    List<List<Integer>> result = new ArrayList<>();
    findCombinations(candidates, target, 0, new ArrayList<>(), result);
    return result;
}

private void findCombinations(int[] candidates, int target, int startIndex, List<Integer> current, List<List<Integer>> result) {
    if (target == 0) {
        result.add(new ArrayList<>(current));
        return;
    }
    if (startIndex == candidates.length || target < 0) {
        return;
    }

    findCombinations(candidates, target, startIndex + 1, current, result);

    current.add(candidates[startIndex]);
    findCombinations(candidates, target - candidates[startIndex], startIndex, current, result);
    current.remove(current.size() - 1);
}


-----
import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> combinationSum(int[] candidates, int target) 
    // Your code here
}


************************************
Question ID: 40

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<List<Integer>> combinationSum2(int[] candidates, int target) {
    List<List<Integer>> result = new ArrayList<>();
    Arrays.sort(candidates);
    combine(candidates, target, 0, result, new ArrayList<Integer>());
    return result;
}

private void combine(int[] candidates, int target, int start, List<List<Integer>> result, List<Integer> current) {
    if (target == 0) {
        result.add(new ArrayList<>(current));
        return;
    }

    for (int i = start; i < candidates.length && target >= candidates[i]; i++) {
        if (i == start || candidates[i] != candidates[i - 1]) {
            current.add(candidates[i]);
            combine(candidates, target - candidates[i], i + 1, result, current);
            current.remove(current.size() - 1);
        }
    }
}


-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<List<Integer>> combinationSum2(int[] candidates, int target) 
    // Your code here
}


************************************
Question ID: 41

public int firstMissingPositive(int[] nums) {
    int n = nums.length;
    for(int i = 0; i < n; i++) {
        while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
            int temp = nums[i];
            nums[i] = nums[temp - 1];
            nums[temp - 1] = temp;
        }
    }

    for(int i = 0; i < n; i++) {
        if(nums[i] != i + 1) {
            return i + 1;
        }
    }
    return n + 1;
}

-----
public int firstMissingPositive(int[] nums) 
    // Your code here
}

************************************
Question ID: 42

public int trap(int[] height) {
    int n = height.length, left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;

    while (left < right) {
        if (height[left] <= height[right]) {
            maxLeft = Math.max(maxLeft, height[left]);
            water += maxLeft - height[left];
            left++;
        } else {
            maxRight = Math.max(maxRight, height[right]);
            water += maxRight - height[right];
            right--;
        }
    }

    return water;
}

-----
public int trap(int[] height) 
    // Your code here
}

************************************
Question ID: 43

public String multiply(String num1, String num2) {
    int m = num1.length(), n = num2.length();
    int[] pos = new int[m + n];
    
    for (int i = m - 1; i >= 0; i--) {
        for (int j = n - 1; j >= 0; j--) {
            int mult = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');
            int p1 = i + j, p2 = i + j + 1;
            int sum = mult + pos[p2];
            pos[p1] += sum / 10;
            pos[p2] = sum % 10;
        }
    }
    
    StringBuilder res = new StringBuilder();
    for (int p : pos) if (!(res.length() == 0 && p == 0)) res.append(p);
    return res.length() == 0 ? "0" : res.toString();
}

-----
public String multiply(String num1, String num2) 
    // Your code here
}

************************************
Question ID: 44

public boolean isMatch(String s, String p) {
    int m = s.length(), n = p.length();
    int i = 0, j = 0, asterisk = -1, match = 0;
    while (i < m) {
        if (j < n && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')) {
            i++; j++;
        } else if (j < n && p.charAt(j) == '*') {
            match = i;
            asterisk = j++;
        } else if (asterisk != -1) {
            i = ++match;
            j = asterisk + 1;
        } else {
            return false;
        }
    }
    while (j < n && p.charAt(j) == '*') j++;
    return j == n;
}

-----
public boolean isMatch(String s, String p) 
    // Your code here
}

************************************
Question ID: 45

public int jump(int[] nums) {
    int jumps = 0, currentEnd = 0, currentFarthest = 0;
    
    for (int i = 0; i < nums.length - 1; i++) {
        currentFarthest = Math.max(currentFarthest, i + nums[i]);
        if (i == currentEnd) {
            jumps++;
            currentEnd = currentFarthest;
        }
    }
    return jumps;
}

-----
public int jump(int[] nums) 
    // Your code here
}

************************************
Question ID: 46

import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> results = new ArrayList<>();
    helper(nums, 0, results);
    return results;
}

private void helper(int[] nums, int index, List<List<Integer>> results) {
    if (index == nums.length - 1) {
        List<Integer> tempList = new ArrayList<>();
        for (int n : nums) {
            tempList.add(n);
        }
        results.add(tempList);
        return;
    }

    for (int i = index; i < nums.length; i++) {
        swap(nums, index, i);
        helper(nums, index + 1, results);
        swap(nums, index, i);
    }
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> permute(int[] nums) 
    // Your code here
}

************************************
Question ID: 47

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<List<Integer>> permuteUnique(int[] nums) {
    Arrays.sort(nums);
    List<List<Integer>> result = new ArrayList<>();
    boolean[] visited = new boolean[nums.length];
    backtrack(result, new ArrayList<>(), nums, visited);
    return result;
}

private void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums, boolean[] visited) {
    if (tempList.size() == nums.length) {
        result.add(new ArrayList<>(tempList));
    } else {
        for (int i = 0; i < nums.length; i++) {
            if (visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])) continue;
            visited[i] = true;
            tempList.add(nums[i]);
            backtrack(result, tempList, nums, visited);
            tempList.remove(tempList.size() - 1);
            visited[i] = false;
        }
    }
}


-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<List<Integer>> permuteUnique(int[] nums) 
    // Your code here
}


************************************
Question ID: 48

public void rotate(int[][] matrix) {
    int n = matrix.length;
    for (int i = 0; i < n / 2; i++) {
        for (int j = i; j < n - i - 1; j++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[n - j - 1][i];
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
            matrix[j][n - i - 1] = temp;
        }
    }
}

-----
public void rotate(int[][] matrix) 
    // Your code here
}

************************************
Question ID: 49

import java.util.*;

public List<List<String>> groupAnagrams(String[] strs) {
    Map<String, List<String>> anagramMap = new HashMap<>();

    for (String str : strs) {
        char[] keyChars = str.toCharArray();
        Arrays.sort(keyChars);
        String key = new String(keyChars);

        anagramMap.putIfAbsent(key, new ArrayList<>());
        anagramMap.get(key).add(str);
    }

    return new ArrayList<>(anagramMap.values());
}

-----
import java.util.*;

public List<List<String>> groupAnagrams(String[] strs) 
    // Your code here
}

************************************
Question ID: 50

double myPow(double x, int n) {
    if (n == 0) return 1;
    if (n < 0) {
        x = 1 / x;
        n = -n;
    }
    double result = 1;
    double currentProduct = x;
    for (long i = n; i > 0; i /= 2) {
        if ((i % 2) == 1) {
            result *= currentProduct;
        }
        currentProduct *= currentProduct;
    }
    return result;
}

-----
double myPow(double x, int n) 
    // Your code here
}

************************************
Question ID: 51

import java.util.ArrayList;
import java.util.List;

public List<List<String>> solveNQueens(int n) {
    List<List<String>> result = new ArrayList<>();
    solve(result, new ArrayList<>(), n, 0);
    return result;
}

private void solve(List<List<String>> result, List<Integer> current, int n, int col) {
    if (col == n) {
        result.add(generateBoard(current, n));
        return;
    }
    for (int row = 0; row < n; row++) {
        if(isSafe(current, row, col)) {
            current.add(row);
            solve(result, current, n, col + 1);
            current.remove(col);
        }
    }
}

private boolean isSafe(List<Integer> current, int row, int col) {
    for (int i = 0; i < col; i++) {
        int prevRow = current.get(i);
        if (prevRow == row || (Math.abs(col - i) == Math.abs(row - prevRow))) {
            return false;
        }
    }
    return true;
}

private List<String> generateBoard(List<Integer> current, int n) {
    List<String> board = new ArrayList<>();
    for (int row : current) {
        StringBuilder sb = new StringBuilder();
        for (int col = 0; col < n; col++)
            sb.append((col == row) ? "Q" : ".");
        board.add(sb.toString());
    }
    return board;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<List<String>> solveNQueens(int n) 
    // Your code here
}

************************************
Question ID: 52

import java.util.ArrayList;

public int totalNQueens(int n) {
    ArrayList<Integer> cols = new ArrayList<>();
    return backtrack(n, cols);
}

public int backtrack(int n, ArrayList<Integer> cols) {
    if (cols.size() == n) {
        return 1;
    }

    int count = 0;
    for (int i = 0; i < n; i++) {
        if (isSafe(cols, i)) {
            cols.add(i);
            count += backtrack(n, cols);
            cols.remove(cols.size() - 1);
        }
    }
    return count;
}

public boolean isSafe(ArrayList<Integer> cols, int row) {
    int col = cols.size();
    for (int i = 0; i < cols.size(); i++) {
        if (cols.get(i) == row || Math.abs(i - col) == Math.abs(cols.get(i) - row)) {
            return false;
        }
    }
    return true;
}


-----
import java.util.ArrayList;

public int totalNQueens(int n) 
    // Your code here
}


************************************
Question ID: 53

public int maxSubArray(int[] nums) {
    int max_sum = nums[0];
    int current_sum = max_sum;

    for (int i = 1; i < nums.length; i++) {
        current_sum = Math.max(current_sum + nums[i], nums[i]);
        max_sum = Math.max(max_sum, current_sum);
    }

    return max_sum;
}

-----
public int maxSubArray(int[] nums) 
    // Your code here
}

************************************
Question ID: 54

import java.util.ArrayList;
import java.util.List;

public List<Integer> spiralOrder(int[][] matrix) {
    List<Integer> result = new ArrayList<>();
    if (matrix == null || matrix.length == 0) return result;
    int m = matrix.length, n = matrix[0].length;
    int rowStart = 0, colStart = 0, rowEnd = m - 1, colEnd = n - 1;

    while (rowStart <= rowEnd && colStart <= colEnd) {
        for (int i = colStart; i <= colEnd; i++) {
            result.add(matrix[rowStart][i]);
        }
        rowStart++;
        for (int i = rowStart; i <= rowEnd; i++) {
            result.add(matrix[i][colEnd]);
        }
        colEnd--;
        if (rowStart <= rowEnd) {
            for (int i = colEnd; i >= colStart; i--) {
                result.add(matrix[rowEnd][i]);
            }
        }
        rowEnd--;
        if (colStart <= colEnd) {
            for (int i = rowEnd; i >= rowStart; i--) {
                result.add(matrix[i][colStart]);
            }
        }
        colStart++;
    }
    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<Integer> spiralOrder(int[][] matrix) 
    // Your code here
}

************************************
Question ID: 55

public boolean canJump(int[] nums) {
    int maxReach = 0;
    for (int i = 0; i < nums.length; ++i) {
        if (i > maxReach) return false;
        maxReach = Math.max(maxReach, i + nums[i]);
    }
    return true;
}

-----
public boolean canJump(int[] nums) 
    // Your code here
}

************************************
Question ID: 56

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<int[]> merge(int[][] intervals) {
    if (intervals.length == 0) return new ArrayList<>();

    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
    List<int[]> result = new ArrayList<>();
    result.add(intervals[0]);

    for (int i = 1; i < intervals.length; i++) {
        if (result.get(result.size() - 1)[1] >= intervals[i][0]) {
            result.get(result.size() - 1)[1] = Math.max(result.get(result.size() - 1)[1], intervals[i][1]);
        } else {
            result.add(intervals[i]);
        }
    }

    return result;
}

-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<int[]> merge(int[][] intervals) 
    // Your code here
}

************************************
Question ID: 57

import java.util.ArrayList;
import java.util.List;

public List<int[]> insert(int[][] intervals, int[] newInterval) {
    List<int[]> result = new ArrayList<>();
    int start_pos = 0;

    while (start_pos < intervals.length && intervals[start_pos][1] < newInterval[0]) {
        result.add(intervals[start_pos]);
        start_pos++;
    }

    while (start_pos < intervals.length && intervals[start_pos][0] <= newInterval[1]) {
        newInterval[0] = Math.min(newInterval[0], intervals[start_pos][0]);
        newInterval[1] = Math.max(newInterval[1], intervals[start_pos][1]);
        start_pos++;
    }

    result.add(newInterval);

    while (start_pos < intervals.length) {
        result.add(intervals[start_pos]);
        start_pos++;
    }

    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<int[]> insert(int[][] intervals, int[] newInterval) 
    // Your code here
}

************************************
Question ID: 58

public int lengthOfLastWord(String s) {
    int length = 0;
    int tail = s.length() - 1;
    while (tail >= 0 && s.charAt(tail) == ' ') tail--;
    while (tail >= 0 && s.charAt(tail) != ' ') {
        length++;
        tail--;
    }
    return length;
}

-----
public int lengthOfLastWord(String s) 
    // Your code here
}

************************************
Question ID: 59

import java.util.ArrayList;
import java.util.Arrays;

public int[][] generateMatrix(int n) {
    int[][] matrix = new int[n][n];
    int value = 1, top = 0, bottom = n - 1, left = 0, right = n - 1;

    while (value <= n * n) {
        for (int i = left; i <= right; i++) {
            matrix[top][i] = value++;
        }

        for (int i = top + 1; i <= bottom; i++) {
            matrix[i][right] = value++;
        }

        if (top < bottom && left < right) {
            for (int i = right - 1; i >= left; i--) {
                matrix[bottom][i] = value++;
            }

            for (int i = bottom - 1; i > top; i--) {
                matrix[i][left] = value++;
            }
        }

        top++; bottom--; left++; right--;
    }

    return matrix;
}

-----
import java.util.ArrayList;
import java.util.Arrays;

public int[][] generateMatrix(int n) 
    // Your code here
}

************************************
Question ID: 60

import java.util.ArrayList;
import java.util.List;

public String getPermutation(int n, int k) {
    List<Integer> nums = new ArrayList<>();
    int[] factorials = new int[n];
    StringBuilder sb = new StringBuilder();
    int index;

    factorials[0] = 1;
    for (int i = 1; i <= n; ++i) {
        nums.add(i);
        factorials[i - 1] = i * factorials[i - 1];
    }

    k--;

    for (int i = n; i >= 1; --i) {
        index = k / factorials[i - 1];
        k %= factorials[i - 1];
        sb.append(nums.get(index));
        nums.remove(index);
    }

    return sb.toString();
}

-----
import java.util.ArrayList;
import java.util.List;

public String getPermutation(int n, int k) 
    // Your code here
}

************************************
Question ID: 62

public int uniquePaths(int m, int n) {
    int[][] dp = new int[m][n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (i == 0 || j == 0) {
                dp[i][j] = 1;
            } else {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
    }
    return dp[m - 1][n - 1];
}

-----
public int uniquePaths(int m, int n) 
    // Your code here
}

************************************
Question ID: 63

public int uniquePathsWithObstacles(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    if (grid[0][0] == 1) return 0;
    
    grid[0][0] = 1;
    for (int i = 1; i < m; ++i)
        grid[i][0] = (grid[i][0] == 0 && grid[i - 1][0] == 1) ? 1 : 0;
    for (int i = 1; i < n; ++i)
        grid[0][i] = (grid[0][i] == 0 && grid[0][i - 1] == 1) ? 1 : 0;

    for (int i = 1; i < m; ++i)
        for (int j = 1; j < n; ++j)
            if (grid[i][j] == 0)
                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];
            else
                grid[i][j] = 0;

    return grid[m - 1][n - 1];
}

-----
public int uniquePathsWithObstacles(int[][] grid) 
    // Your code here
}

************************************
Question ID: 64

public int minPathSum(int[][] grid) {
    int m = grid.length, n = grid[0].length;
        
    for(int i = 1; i < m; i++)
        grid[i][0] += grid[i - 1][0];
        
    for(int i = 1; i < n; i++)
        grid[0][i] += grid[0][i - 1];
        
    for(int i = 1; i < m; i++){
        for(int j = 1; j < n; j++){
            grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
        }
    }
    return grid[m - 1][n - 1];
}

-----
public int minPathSum(int[][] grid) 
    // Your code here
}

************************************
Question ID: 65

import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class Solution {
    public boolean isNumber(String s) {
        String pattern = "^[-+]?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(e[-+]?[0-9]+)?$";
        return Pattern.matches(pattern, s);
    }
}


-----
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class Solution 
    // Your code here
}


************************************
Question ID: 66

public int[] plusOne(int[] digits) {
    int n = digits.length;

    for(int i = n - 1; i >= 0; i--) {
        if(digits[i] < 9) {
            digits[i]++;
            return digits;
        }
        digits[i] = 0;
    }

    int[] newDigits = new int[n + 1];
    newDigits[0] = 1;
    return newDigits;
}


-----
public int[] plusOne(int[] digits) 
    // Your code here
}


************************************
Question ID: 67

public String addBinary(String a, String b) {
    StringBuilder result = new StringBuilder();
    int i = a.length() - 1, j = b.length() - 1, carry = 0;
    while (i >= 0 || j >= 0 || carry != 0) {
        if (i >= 0) carry += a.charAt(i--) - '0';
        if (j >= 0) carry += b.charAt(j--) - '0';
        result.insert(0, carry % 2);
        carry /= 2;
    }
    return result.toString();
}

-----
public String addBinary(String a, String b) 
    // Your code here
}

************************************
Question ID: 68

import java.util.ArrayList;
import java.util.List;

public List<String> fullJustify(String[] words, int maxWidth) {
    List<String> result = new ArrayList<>();
    int idx = 0;
    while (idx < words.length) {
        int totalChars = words[idx].length();
        int last = idx + 1;
        while (last < words.length) {
            if (totalChars + 1 + words[last].length() > maxWidth) break;
            totalChars += 1 + words[last].length();
            last++;
        }
        int gaps = last - idx - 1;
        StringBuilder line = new StringBuilder();
        if (last == words.length || gaps == 0) {
            for (int i = idx; i < last; i++) {
                line.append(words[i]);
                if (i < last - 1) line.append(" ");
            }
            while (line.length() < maxWidth) line.append(" ");
        } else {
            int evenSpaces = (maxWidth - totalChars) / gaps;
            int extraSpaces = (maxWidth - totalChars) % gaps;
            for (int i = idx; i < last; i++) {
                line.append(words[i]);
                if (i < last - 1) {
                    line.append(" ".repeat(evenSpaces + (i - idx < extraSpaces ? 1 : 0)));
                }
            }
        }
        idx = last;
        result.add(line.toString());
    }
    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<String> fullJustify(String[] words, int maxWidth) 
    // Your code here
}

************************************
Question ID: 69

public int mySqrt(int x) {
    if (x == 0 || x == 1) return x;
    int start = 1, end = x, ans = 0;
    while (start <= end) {
        int mid = (start + end) / 2;
        if (mid * mid == x) return mid;
        if (mid <= x / mid) {
            start = mid + 1;
            ans = mid;
        } else {
            end = mid - 1;
        }
    }
    return ans;
}

-----
public int mySqrt(int x) 
    // Your code here
}

************************************
Question ID: 70

public int climbStairs(int n) {
    if(n <= 2) return n;
    int a = 1, b = 2, c;
    for(int i = 3; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    return c;
}


-----
public int climbStairs(int n) 
    // Your code here
}


************************************
Question ID: 71

import java.util.LinkedList;

public String simplifyPath(String path) {
    String[] parts = path.split("/");
    LinkedList<String> stack = new LinkedList<>();

    for (String part : parts) {
        if (part.isEmpty() || part.equals(".")) continue;
        if (part.equals("..")) {
            if (!stack.isEmpty()) stack.removeLast();
        } else {
            stack.addLast(part);
        }
    }

    StringBuilder canonicalPath = new StringBuilder();
    for (String piece : stack) {
        canonicalPath.append('/').append(piece);
    }
    return stack.isEmpty() ? "/" : canonicalPath.toString();
}

-----
import java.util.LinkedList;

public String simplifyPath(String path) 
    // Your code here
}

************************************
Question ID: 72

public int minDistance(String word1, String word2) {
    int m = word1.length();
    int n = word2.length();
    int[][] dp = new int[m + 1][n + 1];
    
    for (int i = 0; i <= m; i++) {
        for (int j = 0; j <= n; j++) {
            if (i == 0) {
                dp[i][j] = j;
            } else if (j == 0) {
                dp[i][j] = i;
            } else if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
            }
        }
    }
    
    return dp[m][n];
}

-----
public int minDistance(String word1, String word2) 
    // Your code here
}

************************************
Question ID: 73

public void setZeroes(int[][] matrix) {
    int rows = matrix.length;
    int cols = matrix[0].length;
    boolean firstRow = false, firstCol = false;

    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (matrix[i][j] == 0) {
                if (i == 0) firstRow = true;
                if (j == 0) firstCol = true;
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }

    for (int i = 1; i < rows; i++) {
        for (int j = 1; j < cols; j++) {
            if (matrix[i][0] == 0 || matrix[0][j] == 0)
                matrix[i][j] = 0;
        }
    }

    if (firstRow) {
        for (int j = 0; j < cols; j++)
            matrix[0][j] = 0;
    }

    if (firstCol) {
        for (int i = 0; i < rows; i++)
            matrix[i][0] = 0;
    }
}

-----
public void setZeroes(int[][] matrix) 
    // Your code here
}

************************************
Question ID: 74

public boolean searchMatrix(int[][] matrix, int target) {
    int m = matrix.length;
    int n = matrix[0].length;
    int l = 0, r = m * n - 1;

    while (l <= r) {
        int mid = l + (r - l) / 2;
        int midVal = matrix[mid / n][mid % n];

        if (midVal == target) {
            return true;
        } else if (midVal < target) {
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }

    return false;
}

-----
public boolean searchMatrix(int[][] matrix, int target) 
    // Your code here
}

************************************
Question ID: 75

public void sortColors(int[] nums) {
    int red = 0, white = 0, blue = nums.length - 1;
    while (white <= blue) {
        if (nums[white] == 0) {
            int temp = nums[red];
            nums[red++] = nums[white];
            nums[white++] = temp;
        } else if (nums[white] == 1) {
            white++;
        } else {
            int temp = nums[white];
            nums[white] = nums[blue];
            nums[blue--] = temp;
        }
    }
}

-----
public void sortColors(int[] nums) 
    // Your code here
}

************************************
Question ID: 76

import java.util.HashMap;

public String minWindow(String s, String t) {
    HashMap<Character, Integer> need = new HashMap<>();
    HashMap<Character, Integer> window = new HashMap<>();
    for (char c : t.toCharArray()) need.put(c, need.getOrDefault(c, 0) + 1);
    
    int left = 0, right = 0;
    int valid = 0;
    int start = 0, length = Integer.MAX_VALUE;

    while (right < s.length()) {
        char c = s.charAt(right);
        right++;
        if (need.containsKey(c)) {
            window.put(c, window.getOrDefault(c, 0) + 1);
            if (window.get(c) <= need.get(c)) valid++;
        }

        while (valid == t.length()) {
            if (right - left < length) {
                start = left;
                length = right - left;
            }

            char d = s.charAt(left);
            left++;
            if (need.containsKey(d)) {
                if (window.get(d) <= need.get(d)) valid--;
                window.put(d, window.get(d) - 1);
            }
        }
    }
    return length == Integer.MAX_VALUE ? "" : s.substring(start, start + length);
}


-----
import java.util.HashMap;

public String minWindow(String s, String t) 
    // Your code here
}


************************************
Question ID: 77

import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> combine(int n, int k) {
    List<List<Integer>> result = new ArrayList<>();
    backtrack(n, k, 1, new ArrayList<>(), result);
    return result;
}

private void backtrack(int n, int k, int start, List<Integer> current, List<List<Integer>> result) {
    if (current.size() == k) {
        result.add(new ArrayList<>(current));
        return;
    }

    for (int i = start; i <= n; i++) {
        current.add(i);
        backtrack(n, k, i + 1, current, result);
        current.remove(current.size() - 1);
    }
}

-----
import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> combine(int n, int k) 
    // Your code here
}

************************************
Question ID: 78

import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    int n = nums.length;
    int num_subsets = 1 << n;

    for (int i = 0; i < num_subsets; ++i) {
        List<Integer> subset = new ArrayList<>();
        for (int j = 0; j < n; ++j) {
            if ((i & (1 << j)) != 0) {
                subset.add(nums[j]);
            }
        }
        result.add(subset);
    }
    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> subsets(int[] nums) 
    // Your code here
}

************************************
Question ID: 79

public boolean exist(char[][] board, String word) {
    int m = board.length;
    int n = board[0].length;

    boolean[][] visited = new boolean[m][n];

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (dfs(board, i, j, 0, word, visited)) {
                return true;
            }
        }
    }
    return false;
}

private boolean dfs(char[][] board, int i, int j, int k, String word, boolean[][] visited) {
    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != word.charAt(k) || visited[i][j]) {
        return false;
    }

    if (k == word.length() - 1) {
        return true;
    }

    visited[i][j] = true;
    boolean result = dfs(board, i + 1, j, k + 1, word, visited)
            || dfs(board, i - 1, j, k + 1, word, visited)
            || dfs(board, i, j + 1, k + 1, word, visited)
            || dfs(board, i, j - 1, k + 1, word, visited);
    visited[i][j] = false;

    return result;
}


-----
public boolean exist(char[][] board, String word) 
    // Your code here
}


************************************
Question ID: 80

public int removeDuplicates(int[] nums) {
    int i = 0;
    for (int num : nums) {
        if (i < 2 || num > nums[i - 2]) {
            nums[i++] = num;
        }
    }
    return i;
}

-----
public int removeDuplicates(int[] nums) 
    // Your code here
}

************************************
Question ID: 81

public boolean search(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) return true;

        if (nums[mid] == nums[left]) {
            left++;
        } else if (nums[mid] > nums[left]) {
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    return false;
}

-----
public boolean search(int[] nums, int target) 
    // Your code here
}

************************************
Question ID: 84

public int largestRectangleArea(int[] heights) {
    Stack<Integer> stack = new Stack<>();
    int max_area = 0;
    for (int i = 0; i <= heights.length; i++) {
        int height = (i == heights.length) ? 0 : heights[i];
        while (!stack.isEmpty() && heights[stack.peek()] > height) {
            int h = heights[stack.pop()];
            int w = stack.isEmpty() ? i : i - stack.peek() - 1;
            max_area = Math.max(max_area, h * w);
        }
        stack.push(i);
    }
    return max_area;
}

-----
public int largestRectangleArea(int[] heights) 
    // Your code here
}

************************************
Question ID: 85

import java.util.Stack;

public int maximalRectangle(char[][] matrix) {
    if (matrix.length == 0) return 0;

    int m = matrix.length;
    int n = matrix[0].length;
    int[] height = new int[n + 1];
    int maxArea = 0;

    for (int i = 0; i < m; ++i) {
        Stack<Integer> s = new Stack<>();
        for (int j = 0; j <= n; ++j) {
            if (j < n) {
                height[j] = matrix[i][j] == '1' ? height[j] + 1 : 0;
            }
            while (!s.empty() && height[j] < height[s.peek()]) {
                int h = height[s.pop()];
                int w = s.empty() ? j : j - s.peek() - 1;
                maxArea = Math.max(maxArea, h * w);
            }
            s.push(j);
        }
    }

    return maxArea;
}


-----
import java.util.Stack;

public int maximalRectangle(char[][] matrix) 
    // Your code here
}


************************************
Question ID: 87

public boolean isScramble(String s1, String s2) {
    if (s1.equals(s2)) return true;
    if (sorted(s1).equals(sorted(s2)) == false) return false;

    for (int i = 1; i < s1.length(); i++) {
        if (isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i)))
            return true;
        if (isScramble(s1.substring(0, i), s2.substring(s2.length() - i)) && isScramble(s1.substring(i), s2.substring(0, s2.length() - i)))
            return true;
    }
    return false;
}

private String sorted(String s) {
    char[] chars = s.toCharArray();
    Arrays.sort(chars);
    return new String(chars);
}

-----
public boolean isScramble(String s1, String s2) 
    // Your code here
}

************************************
Question ID: 88

public void merge(int[] nums1, int m, int[] nums2, int n) {
    int i = m - 1, j = n - 1, k = m + n - 1;
    while (i >= 0 && j >= 0) {
        if (nums1[i] > nums2[j])
            nums1[k--] = nums1[i--];
        else
            nums1[k--] = nums2[j--];
    }
    while (j >= 0) {
        nums1[k--] = nums2[j--];
    }
}

-----
public void merge(int[] nums1, int m, int[] nums2, int n) 
    // Your code here
}

************************************
Question ID: 89

import java.util.ArrayList;
import java.util.List;

public List<Integer> grayCode(int n) {
    List<Integer> result = new ArrayList<>();
    for (int i = 0; i < (1 << n); i++) {
        result.add(i ^ (i >> 1));
    }
    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<Integer> grayCode(int n) 
    // Your code here
}

************************************
Question ID: 90

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public List<List<Integer>> subsetsWithDup(int[] nums) {
    Set<List<Integer>> result = new HashSet<>();
    Arrays.sort(nums);
    backtrack(nums, 0, new ArrayList<Integer>(), result);
    return new ArrayList<>(result);
}

private void backtrack(int[] nums, int index, List<Integer> subset, Set<List<Integer>> result) {
    result.add(new ArrayList<>(subset));
    for (int i = index; i < nums.length; i++) {
        subset.add(nums[i]);
        backtrack(nums, i + 1, subset, result);
        subset.remove(subset.size() - 1);
    }
}

-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public List<List<Integer>> subsetsWithDup(int[] nums) 
    // Your code here
}

************************************
Question ID: 91

public int numDecodings(String s) {
    int n = s.length();
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = s.charAt(0) != '0' ? 1 : 0;

    for (int i = 2; i <= n; i++) {
        int oneDigit = Integer.parseInt(s.substring(i - 1, i));
        int twoDigits = Integer.parseInt(s.substring(i - 2, i));

        if (oneDigit >= 1)
            dp[i] += dp[i - 1];
        if (twoDigits >= 10 && twoDigits <= 26)
            dp[i] += dp[i - 2];
    }
    return dp[n];
}


-----
public int numDecodings(String s) 
    // Your code here
}


************************************
Question ID: 92

public ListNode reverseBetween(ListNode head, int left, int right) {
    if (head == null || left == right) return head;
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode pre = dummy;
    for (int i = 1; i < left; ++i) pre = pre.next;
    ListNode cur = pre.next;
    for (int i = left; i < right; ++i) {
        ListNode t = cur.next;
        cur.next = t.next;
        t.next = pre.next;
        pre.next = t;
    }
    return dummy.next;
}

-----
public ListNode reverseBetween(ListNode head, int left, int right) 
    // Your code here
}

************************************
Question ID: 93

import java.util.ArrayList;
import java.util.List;

public List<String> restoreIpAddresses(String s) {
    List<String> result = new ArrayList<>();
    dfs(s, 0, "", result, 0);
    return result;
}

private void dfs(String s, int start, String ip, List<String> result, int part) {
    if (part == 4 && start == s.length()) {
        result.add(ip.substring(0, ip.length() - 1));
        return;
    }
    if (part == 4 || start >= s.length()) return;

    int num = 0;
    for (int i = start; i < s.length(); i++) {
        num = num * 10 + (s.charAt(i) - '0');
        if (num > 255) break;
        dfs(s, i + 1, ip + s.charAt(i) + ".", result, part + 1);
        if (num == 0) break;
    }
}


-----
import java.util.ArrayList;
import java.util.List;

public List<String> restoreIpAddresses(String s) 
    // Your code here
}


************************************
Question ID: 96

public int numTrees(int n) {
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        for (int j = 0; j < i; j++) {
            dp[i] += dp[j] * dp[i - j - 1];
        }
    }
    return dp[n];
}

-----
public int numTrees(int n) 
    // Your code here
}

************************************
Question ID: 97

public boolean isInterleave(String s1, String s2, String s3) {
    int m = s1.length(), n = s2.length();
    if (m + n != s3.length()) return false;

    boolean[][] dp = new boolean[m + 1][n + 1];
    dp[0][0] = true;
    for (int i = 1; i <= m; i++)
        dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1);
    for (int j = 1; j <= n; j++)
        dp[0][j] = dp[0][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            dp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) ||
                       (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));
        }
    }

    return dp[m][n];
}

-----
public boolean isInterleave(String s1, String s2, String s3) 
    // Your code here
}

************************************
Question ID: 99

void inorder(TreeNode node, TreeNode[] nodes) {
    if (node == null) return;
    inorder(node.left, nodes);
    if (nodes[1] != null && nodes[1].val > node.val) {
        if (nodes[0] == null) nodes[0] = nodes[1];
        nodes[2] = node;
    }
    nodes[1] = node;
    inorder(node.right, nodes);
}

public void recoverTree(TreeNode root) {
    TreeNode[] nodes = new TreeNode[3];
    inorder(root, nodes);
    int temp = nodes[0].val;
    nodes[0].val = nodes[2].val;
    nodes[2].val = temp;
}

-----
void inorder(TreeNode node, TreeNode[] nodes) 
    // Your code here
}

************************************
Question ID: 101

public boolean isSymmetric(TreeNode root) {
    return checkSymmetry(root, root);
}

public boolean checkSymmetry(TreeNode node1, TreeNode node2) {
    if (node1 == null && node2 == null) return true;
    if (node1 == null || node2 == null) return false;
    return (node1.val == node2.val) && checkSymmetry(node1.right, node2.left) && checkSymmetry(node1.left, node2.right);
}

-----
public boolean isSymmetric(TreeNode root) 
    // Your code here
}

************************************
Question ID: 104

public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}

-----
public int maxDepth(TreeNode root) 
    // Your code here
}

************************************
Question ID: 107

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

public List<List<Integer>> levelOrderBottom(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) return result;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);

    while (!queue.isEmpty()) {
        List<Integer> level = new ArrayList<>();
        int size = queue.size();

        for (int i = 0; i < size; i++) {
            TreeNode current = queue.poll();
            level.add(current.val);

            if (current.left != null) queue.add(current.left);
            if (current.right != null) queue.add(current.right);
        }
        result.add(0, level);
    }

    return result;
}

-----
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class TreeNode 
    // Your code here
}

************************************
Question ID: 111

public int minDepth(TreeNode root) {
    if (root == null) return 0;
    int left = minDepth(root.left);
    int right = minDepth(root.right);
    return (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1;
}

-----
public int minDepth(TreeNode root) 
    // Your code here
}

************************************
Question ID: 114

public void flatten(TreeNode root) {
    if (root == null) return;
    flatten(root.left);
    flatten(root.right);
    if (root.left != null) {
        TreeNode temp = root.right;
        root.right = root.left;
        root.left = null;
        while (root.right != null) root = root.right;
        root.right = temp;
    }
}

-----
public void flatten(TreeNode root) 
    // Your code here
}

************************************
Question ID: 115

public int numDistinct(String s, String t) {
    int m = s.length(), n = t.length();
    int[][] dp = new int[m + 1][n + 1];

    for (int i = 0; i <= m; i++) {
        dp[i][0] = 1;
    }

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s.charAt(i - 1) == t.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }

    return dp[m][n];
}

-----
public int numDistinct(String s, String t) 
    // Your code here
}

************************************
Question ID: 116

public void connect(TreeLinkNode root) {
    if (root == null || root.left == null) return;
    root.left.next = root.right;
    if (root.next != null) {
        root.right.next = root.next.left;
    }
    connect(root.left);
    connect(root.right);
}


-----
public void connect(TreeLinkNode root) 
    // Your code here
}


************************************
Question ID: 118

public List<List<Integer>> generate(int numRows) {
    List<List<Integer>> pascalsTriangle = new ArrayList<>();
    for (int i = 0; i < numRows; i++) {
        List<Integer> row = new ArrayList<>();
        row.add(1);
        for (int j = 1; j < i; j++) {
            row.add(pascalsTriangle.get(i - 1).get(j - 1) + pascalsTriangle.get(i - 1).get(j));
        }
        if (i > 0) row.add(1);
        pascalsTriangle.add(row);
    }
    return pascalsTriangle;
}

-----
public List<List<Integer>> generate(int numRows) 
    // Your code here
}

************************************
Question ID: 119

import java.util.ArrayList;
import java.util.List;

public List<Integer> getRow(int rowIndex) {
    List<Integer> row = new ArrayList<>();
    for (int i = 0; i <= rowIndex; i++) {
        row.add(1);
        for (int j = i - 1; j > 0; j--) {
            row.set(j, row.get(j) + row.get(j - 1));
        }
    }
    return row;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<Integer> getRow(int rowIndex) 
    // Your code here
}

************************************
Question ID: 120

public int minimumTotal(List<List<Integer>> triangle) {
    for (int row = triangle.size() - 2; row >= 0; row--) {
        for (int col = 0; col < triangle.get(row).size(); col++) {
            int minSum = Math.min(triangle.get(row + 1).get(col), triangle.get(row + 1).get(col + 1));
            triangle.get(row).set(col, triangle.get(row).get(col) + minSum);
        }
    }
    return triangle.get(0).get(0);
}

-----
public int minimumTotal(List<List<Integer>> triangle) 
    // Your code here
}

************************************
Question ID: 121

public int maxProfit(int[] prices) {
    int minPrice = Integer.MAX_VALUE;
    int maxProfit = 0;
    for (int price : prices) {
        minPrice = Math.min(minPrice, price);
        maxProfit = Math.max(maxProfit, price - minPrice);
    }
    return maxProfit;
}

-----
public int maxProfit(int[] prices) 
    // Your code here
}

************************************
Question ID: 122

public int maxProfit(int[] prices) {
    int max_profit = 0;
    for (int i = 1; i < prices.length; i++) {
        if (prices[i] > prices[i - 1]) {
            max_profit += prices[i] - prices[i - 1];
        }
    }
    return max_profit;
}

-----
public int maxProfit(int[] prices) 
    // Your code here
}

************************************
Question ID: 123

public int maxProfit(int[] prices) {
    int buy1 = Integer.MAX_VALUE, buy2 = Integer.MAX_VALUE;
    int profit1 = 0, profit2 = 0;
    
    for (int price : prices) {
        buy1 = Math.min(buy1, price);
        profit1 = Math.max(profit1, price - buy1);
        buy2 = Math.min(buy2, price - profit1);
        profit2 = Math.max(profit2, price - buy2);
    }
    
    return profit2;
}

-----
public int maxProfit(int[] prices) 
    // Your code here
}

************************************
Question ID: 125

public boolean isPalindrome(String s) {
    StringBuilder cleaned = new StringBuilder();
    for (char c : s.toCharArray()) {
        if (Character.isLetterOrDigit(c)) {
            cleaned.append(Character.toLowerCase(c));
        }
    }
    int left = 0, right = cleaned.length() - 1;
    while (left < right) {
        if (cleaned.charAt(left++) != cleaned.charAt(right--)) return false;
    }
    return true;
}

-----
public boolean isPalindrome(String s) 
    // Your code here
}

************************************
Question ID: 126

import java.util.*;

public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
    Set<String> dict = new HashSet<>(wordList);
    if (!dict.contains(endWord)) {
        return Collections.emptyList();
    }

    Map<String, List<String>> adjacent = new HashMap<>();
    Map<String, Integer> distance = new HashMap<>();
    Queue<String> queue = new LinkedList<>();
    queue.offer(beginWord);
    distance.put(beginWord, 0);

    while (!queue.isEmpty()) {
        String current = queue.poll();
        if (current.equals(endWord)) {
            break;
        }
        for (String neighbor : neighbors(current)) {
            if (!dict.contains(neighbor)) {
                continue;
            }
            if (!distance.containsKey(neighbor)) {
                distance.put(neighbor, distance.get(current) + 1);
                queue.offer(neighbor);
            }
            if (distance.get(neighbor).equals(distance.get(current) + 1)) {
                adjacent.computeIfAbsent(current, k -> new ArrayList<>()).add(neighbor);
            }
        }
    }

    List<List<String>> result = new ArrayList<>();
    List<String> path = new ArrayList<>();
    path.add(beginWord);
    backtrack(beginWord, endWord, path, adjacent, result);
    return result;
}

private void backtrack(String current, String endWord, List<String> path, Map<String, List<String>> adjacent, List<List<String>> result) {
    if (current.equals(endWord)) {
        result.add(new ArrayList<>(path));
        return;
    }
    for (String next : adjacent.getOrDefault(current, Collections.emptyList())) {
        path.add(next);
        backtrack(next, endWord, path, adjacent, result);
        path.remove(path.size() - 1);
    }
}

private List<String> neighbors(String word) {
    List<String> result = new ArrayList<>();
    char[] chars = word.toCharArray();
    for (int i = 0; i < chars.length; i++) {
        char original = chars[i];
        for (char j = 'a'; j <= 'z'; j++) {
            if (j == original) {
                continue;
            }
            chars[i] = j;
            result.add(new String(chars));
        }
        chars[i] = original;
    }
    return result;
}


-----
import java.util.*;

public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) 
    // Your code here
}


************************************
Question ID: 127

import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Set;

public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    Set<String> dict = new HashSet<>(wordList);
    if (!dict.contains(endWord)) return 0;

    Queue<String> q = new LinkedList<>();
    q.offer(beginWord);
    int steps = 1;

    while (!q.isEmpty()) {
        int size = q.size();
        for (int i = 0; i < size; ++i) {
            String currentWord = q.poll();
            if (currentWord.equals(endWord)) return steps;

            char[] charArray = currentWord.toCharArray();
            for (int j = 0; j < charArray.length; ++j) {
                char originalChar = charArray[j];
                for (int k = 0; k < 26; ++k) {
                    charArray[j] = (char) ('a' + k);
                    String newWord = new String(charArray);
                    if (dict.remove(newWord)) {
                        q.offer(newWord);
                    }
                }
                charArray[j] = originalChar;
            }
        }
        ++steps;
    }
    return 0;
}

-----
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Set;

public int ladderLength(String beginWord, String endWord, List<String> wordList) 
    // Your code here
}

************************************
Question ID: 128

public int longestConsecutive(int[] nums) {
    Set<Integer> elements = new HashSet<>();
    for (int num : nums) {
        elements.add(num);
    }
    
    int longestSeq = 0;
    
    for (int num : nums) {
        if (!elements.contains(num - 1)) {
            int currentNum = num;
            int currentSeq = 1;
            
            while (elements.contains(currentNum + 1)) {
                currentNum++;
                currentSeq++;
            }
            
            longestSeq = Math.max(longestSeq, currentSeq);
        }
    }
    return longestSeq;
}

-----
public int longestConsecutive(int[] nums) 
    // Your code here
}

************************************
Question ID: 129

public int sumNumbers(TreeNode root) {
    return sumNumbersHelper(root, 0);
}

private int sumNumbersHelper(TreeNode root, int cur) {
    if (root == null) return 0;
    cur = cur * 10 + root.val;
    if (root.left == null && root.right == null) return cur;
    return sumNumbersHelper(root.left, cur) + sumNumbersHelper(root.right, cur);
}


-----
public int sumNumbers(TreeNode root) 
    // Your code here
}


************************************
Question ID: 131

import java.util.ArrayList;
import java.util.List;

public class Solution {
    private boolean isPalindrome(String s, int start, int end) {
        while (start < end) {
            if (s.charAt(start++) != s.charAt(end--)) return false;
        }
        return true;
    }

    private void dfs(String s, int start, List<List<String>> results, List<String> current) {
        if (start == s.length()) {
            results.add(new ArrayList<>(current));
            return;
        }
        
        for (int end = start; end < s.length(); end++) {
            if (isPalindrome(s, start, end)) {
                current.add(s.substring(start, end + 1));
                dfs(s, end + 1, results, current);
                current.remove(current.size() - 1);
            }
        }
    }

    public List<List<String>> partition(String s) {
        List<List<String>> results = new ArrayList<>();
        List<String> current = new ArrayList<>();
        dfs(s, 0, results, current);
        return results;
    }
}

-----
import java.util.ArrayList;
import java.util.List;

public class Solution 
    // Your code here
}

************************************
Question ID: 132

public int minCut(String s) {
    int n = s.length();
    int[] dp = new int[n + 1];
    boolean[][] isPalindrome = new boolean[n][n];
    
    for (int i=0; i <= n; i++) {
        dp[i] = i - 1;
    }
    
    for (int j=1; j < n; j++) {
        for (int i=j; i >= 0; i--) {
            if (s.charAt(i) == s.charAt(j) && (j - i < 2 || isPalindrome[i + 1][j - 1])) {
                isPalindrome[i][j] = true;
                dp[j + 1] = Math.min(dp[j + 1], dp[i] + 1);
            }
        }
    }
    
    return dp[n];
}

-----
public int minCut(String s) 
    // Your code here
}

************************************
Question ID: 134

public int canCompleteCircuit(int[] gas, int[] cost) {
    int totalGas = 0, totalCost = 0, start = 0, gasTank = 0;
    for (int i = 0; i < gas.length; i++) {
        totalGas += gas[i];
        totalCost += cost[i];
        gasTank += gas[i] - cost[i];
        if (gasTank < 0) {
            start = i + 1;
            gasTank = 0;
        }
    }
    return (totalGas < totalCost) ? -1 : start;
}

-----
public int canCompleteCircuit(int[] gas, int[] cost) 
    // Your code here
}

************************************
Question ID: 135

public int minCandies(int[] ratings) {
    int n = ratings.length;
    int[] candies = new int[n];
    for (int i = 0; i < n; i++) candies[i] = 1;

    for (int i = 1; i < n; i++) {
        if (ratings[i] > ratings[i - 1]) candies[i] = candies[i - 1] + 1;
    }
    for (int i = n - 2; i >= 0; i--) {
        if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], candies[i + 1] + 1);
    }

    int sum = 0;
    for (int candy : candies) sum += candy;

    return sum;
}

-----
public int minCandies(int[] ratings) 
    // Your code here
}

************************************
Question ID: 136

public int singleNumber(int[] nums) {
    int result = 0;
    for (int num : nums) {
        result ^= num;
    }
    return result;
}

-----
public int singleNumber(int[] nums) 
    // Your code here
}

************************************
Question ID: 137

public int singleNumber(int[] nums) {
    int ones = 0, twos = 0;
    for (int n : nums) {
        ones = (ones ^ n) & ~twos;
        twos = (twos ^ n) & ~ones;
    }
    return ones;
}

-----
public int singleNumber(int[] nums) 
    // Your code here
}

************************************
Question ID: 139

import java.util.List;
import java.util.Set;
import java.util.HashSet;

public boolean wordBreak(String s, List<String> wordDict) {
    Set<String> dict = new HashSet<>(wordDict);
    boolean[] dp = new boolean[s.length() + 1];
    dp[0] = true;
    for (int i = 1; i <= s.length(); i++) {
        for (int j = 0; j < i; j++) {
            if (dp[j] && dict.contains(s.substring(j, i))) {
                dp[i] = true;
                break;
            }
        }
    }
    return dp[s.length()];
}


-----
import java.util.List;
import java.util.Set;
import java.util.HashSet;

public boolean wordBreak(String s, List<String> wordDict) 
    // Your code here
}


************************************
Question ID: 140

import java.util.*;

public List<String> wordBreak(String s, List<String> wordDict) {
    HashSet<String> dict = new HashSet<>(wordDict);
    HashMap<String, List<String>> memo = new HashMap<>();
    return helper(s, dict, memo);
}

private List<String> helper(String s, HashSet<String> dict, HashMap<String, List<String>> memo) {
    if (memo.containsKey(s)) {
        return memo.get(s);
    }
    
    List<String> res = new ArrayList<>();
    if (dict.contains(s)) {
        res.add(s);
    }
    
    for (int i = 1; i < s.length(); ++i) {
        String prefix = s.substring(0, i);
        if (!dict.contains(prefix)) continue;
        String suffix = s.substring(i);
        List<String> temp = helper(suffix, dict, memo);
        for (String t : temp) {
            res.add(prefix + " " + t);
        }
    }

    memo.put(s, res);
    return res;
}

-----
import java.util.*;

public List<String> wordBreak(String s, List<String> wordDict) 
    // Your code here
}

************************************
Question ID: 141

public boolean hasCycle(ListNode head) {
    ListNode slow = head, fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast) {
            return true;
        }
    }
    return false;
}

-----
public boolean hasCycle(ListNode head) 
    // Your code here
}

************************************
Question ID: 146

import java.util.HashMap;

public class LRUCache {
    int capacity;
    private HashMap<Integer, Node> cache;
    private Node head, tail;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        cache = new HashMap<>();
        head = new Node();
        tail = new Node();
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) return -1;
        moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        Node node = cache.get(key);
        if (node != null) {
            node.value = value;
            moveToHead(node);
        } else {
            node = new Node(key, value);
            cache.put(key, node);
            addToHead(node);
            if (cache.size() > capacity) {
                cache.remove(removeTail().key);
            }
        }
    }

    private void addToHead(Node node) {
        node.next = head.next;
        node.prev = head;
        head.next.prev = node;
        head.next = node;
    }

    private void moveToHead(Node node) {
        removeFromList(node);
        addToHead(node);
    }

    private void removeFromList(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private Node removeTail() {
        Node res = tail.prev;
        removeFromList(res);
        return res;
    }

    class Node {
        int key;
        int value;
        Node prev;
        Node next;

        public Node() {
        }

        public Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
}


-----
import java.util.HashMap;

public class LRUCache 
    // Your code here
}


************************************
Question ID: 149

import java.util.HashMap;

public int maxPoints(int[][] points) {
    int n = points.length;
    if (n <= 2) return n;
    int maxCount = 0;

    for (int i = 0; i < n-1; i++) {
        HashMap<String, Integer> slopeMap = new HashMap<>();
        int duplicates = 0, localMax = 0;

        for (int j = i+1; j < n; j++) {
            int deltaX = points[j][0] - points[i][0];
            int deltaY = points[j][1] - points[i][1];

            if (deltaX == 0 && deltaY == 0) {
                duplicates++;
                continue;
            }

            int gcd = gcd(deltaX, deltaY);
            deltaX /= gcd;
            deltaY /= gcd;

            String key = deltaX + "_" + deltaY;
            slopeMap.put(key, slopeMap.getOrDefault(key, 0) + 1);
            localMax = Math.max(localMax, slopeMap.get(key));
        }
        maxCount = Math.max(maxCount, localMax + duplicates + 1);
    }

    return maxCount;
}

private int gcd(int a, int b) {
    if(b == 0) return a;
    return gcd(b, a % b);
}


-----
import java.util.HashMap;

public int maxPoints(int[][] points) 
    // Your code here
}


************************************
Question ID: 150

import java.util.Stack;

public int evalRPN(String[] tokens) {
    Stack<Integer> stack = new Stack<>();
    for (String token : tokens) {
        if (token.equals("+") || token.equals("-") || token.equals("*") || token.equals("/")) {
            int b = stack.pop();
            int a = stack.pop();
            if (token.equals("+")) stack.push(a + b);
            else if (token.equals("-")) stack.push(a - b);
            else if (token.equals("*")) stack.push(a * b);
            else stack.push(a / b);
        } else {
            stack.push(Integer.parseInt(token));
        }
    }
    return stack.pop();
}

-----
import java.util.Stack;

public int evalRPN(String[] tokens) 
    // Your code here
}

************************************
Question ID: 151

import java.util.*;

public String reverseWords(String s) {
    String[] words = s.trim().split("\\s+");
    Collections.reverse(Arrays.asList(words));
    return String.join(" ", words);
}

-----
import java.util.*;

public String reverseWords(String s) 
    // Your code here
}

************************************
Question ID: 152

public int maxProduct(int[] nums) {
    int max_so_far = nums[0];
    int min_so_far = nums[0];
    int result = nums[0];
    
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] < 0) {
            int temp = max_so_far;
            max_so_far = min_so_far;
            min_so_far = temp;
        }
        
        max_so_far = Math.max(nums[i], max_so_far * nums[i]);
        min_so_far = Math.min(nums[i], min_so_far * nums[i]);
        result = Math.max(result, max_so_far);
    }
    return result;
}


-----
public int maxProduct(int[] nums) 
    // Your code here
}


************************************
Question ID: 153

public int findMin(int[] nums) {
    int left = 0, right = nums.length - 1;

    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] > nums[right]) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return nums[left];
}

-----
public int findMin(int[] nums) 
    // Your code here
}

************************************
Question ID: 154

public int findMin(int[] nums) {
    int low = 0, high = nums.length - 1;
    
    while (low < high) {
        int mid = low + (high - low) / 2;
        if (nums[mid] > nums[high]) {
            low = mid + 1;
        } else if (nums[mid] < nums[high]) {
            high = mid;
        } else {
            high--;
        }
    }
    return nums[low];
}

-----
public int findMin(int[] nums) 
    // Your code here
}

************************************
Question ID: 157

public int read4(char[] buf4);

public int read(char[] buf, int n) {
    int totalRead = 0;
    char[] buf4 = new char[4];

    while (totalRead < n) {
        int read4Count = read4(buf4);
        for (int i = 0; i < read4Count && totalRead < n; i++) {
            buf[totalRead++] = buf4[i];
        }
        if (read4Count < 4) break;
    }

    return totalRead;
}

-----
public int read4(char[] buf4);

public int read(char[] buf, int n) 
    // Your code here
}

************************************
Question ID: 159

public int lengthOfLongestSubstringTwoDistinct(String s) {
    int l = 0, r = 0, max_len = 0, cur_len = 0;
    HashMap<Character, Integer> char_count = new HashMap<>();

    while (r < s.length()) {
        char_count.put(s.charAt(r), char_count.getOrDefault(s.charAt(r), 0) + 1);
        if (char_count.size() <= 2) {
            cur_len++;
        } else {
            while (char_count.size() > 2 && l <= r) {
                char_count.put(s.charAt(l), char_count.get(s.charAt(l)) - 1);
                if (char_count.get(s.charAt(l)) == 0) {
                    char_count.remove(s.charAt(l));
                }
                l++;
                cur_len--;
            }
            cur_len++;
        }
        max_len = Math.max(max_len, cur_len);
        r++;
    }
    return max_len;
}

-----
public int lengthOfLongestSubstringTwoDistinct(String s) 
    // Your code here
}

************************************
Question ID: 161

public boolean isOneEditDistance(String s, String t) {
    int m = s.length();
    int n = t.length();
    if (m > n) {
        return isOneEditDistance(t, s);
    }
    if (n - m > 1) {
        return false;
    }
    for (int i = 0; i < m; ++i) {
        if (s.charAt(i) != t.charAt(i)) {
            if (m < n) {
                return s.substring(i).equals(t.substring(i + 1));
            } else {
                return s.substring(i + 1).equals(t.substring(i + 1));
            }
        }
    }
    return m + 1 == n;
}

-----
public boolean isOneEditDistance(String s, String t) 
    // Your code here
}

************************************
Question ID: 162

public int findPeakElement(int[] nums) {
    int left = 0, right = nums.length - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < nums[mid + 1]) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}

-----
public int findPeakElement(int[] nums) 
    // Your code here
}

************************************
Question ID: 163

import java.util.ArrayList;
import java.util.List;

public List<String> findMissingRanges(int[] nums, int lower, int upper) {
    List<String> result = new ArrayList<>();
    long prev = (long) lower - 1;

    for (int i = 0; i <= nums.length; ++i) {
        long cur = (i == nums.length) ? (long) upper + 1 : nums[i];
        if (cur - prev >= 2) {
            result.add(Long.toString(prev + 1) + (cur - prev == 2 ? "" : "->") + Long.toString(cur - 1));
        }
        prev = cur;
    }

    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<String> findMissingRanges(int[] nums, int lower, int upper) 
    // Your code here
}

************************************
Question ID: 164

public int maximumGap(int[] nums) {
    if (nums.length < 2) return 0;

    int min_val = Arrays.stream(nums).min().getAsInt();
    int max_val = Arrays.stream(nums).max().getAsInt();
    int len = nums.length;
    int bucket_size = Math.max(1, (max_val - min_val) / (len - 1));
    int bucket_num = (max_val - min_val) / bucket_size + 1;
    int[][] buckets = new int[bucket_num][2];
    for (int i = 0; i < bucket_num; i++) {
        buckets[i] = new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE};
    }

    for (int num : nums) {
        int idx = (num - min_val) / bucket_size;
        buckets[idx][0] = Math.min(buckets[idx][0], num);
        buckets[idx][1] = Math.max(buckets[idx][1], num);
    }

    int max_gap = 0, prev_max = min_val;
    for (int[] bucket : buckets) {
        if (bucket[0] == Integer.MAX_VALUE) continue;
        max_gap = Math.max(max_gap, bucket[0] - prev_max);
        prev_max = bucket[1];
    }
    return max_gap;
}

-----
public int maximumGap(int[] nums) 
    // Your code here
}

************************************
Question ID: 165

public int compareVersion(String version1, String version2) {
    int i = 0, j = 0;
    while (i < version1.length() || j < version2.length()) {
        int num1 = 0, num2 = 0;
        while (i < version1.length() && version1.charAt(i) != '.') {
            num1 = num1 * 10 + (version1.charAt(i++) - '0');
        }
        while (j < version2.length() && version2.charAt(j) != '.') {
            num2 = num2 * 10 + (version2.charAt(j++) - '0');
        }
        if (num1 < num2) return -1;
        if (num1 > num2) return 1;
        i++; j++;
    }
    return 0;
}

-----
public int compareVersion(String version1, String version2) 
    // Your code here
}

************************************
Question ID: 166

import java.util.HashMap;

public String fractionToDecimal(int numerator, int denominator) {
    if (numerator == 0) return "0";
    StringBuilder res = new StringBuilder();
    if ((numerator > 0) ^ (denominator > 0)) res.append('-');
    long num = Math.abs((long)numerator), den = Math.abs((long)denominator);
    res.append(num / den);
    num %= den;
    if (num == 0) return res.toString();
    res.append('.');
    HashMap<Long, Integer> map = new HashMap<>();
    while (num != 0) {
        if (map.containsKey(num)) {
            res.insert(map.get(num), "(");
            res.append(")");
            break;
        }
        map.put(num, res.length());
        num *= 10;
        res.append(num / den);
        num %= den;
    }
    return res.toString();
}


-----
import java.util.HashMap;

public String fractionToDecimal(int numerator, int denominator) 
    // Your code here
}


************************************
Question ID: 167

public int[] twoSum(int[] numbers, int target) {
    int left = 0, right = numbers.length - 1;
    while (left < right) {
        int current_sum = numbers[left] + numbers[right];
        if (current_sum == target) {
            return new int[]{left + 1, right + 1};
        } else if (current_sum < target) {
            left++;
        } else {
            right--;
        }
    }
    return new int[]{};
}

-----
public int[] twoSum(int[] numbers, int target) 
    // Your code here
}

************************************
Question ID: 168

public String convertToTitle(int columnNumber) {
    StringBuilder result = new StringBuilder();
    while (columnNumber > 0) {
        columnNumber--;
        result.insert(0, (char) ('A' + columnNumber % 26));
        columnNumber /= 26;
    }
    return result.toString();
}


-----
public String convertToTitle(int columnNumber) 
    // Your code here
}


************************************
Question ID: 169

public int majorityElement(int[] nums) {
    int count = 0;
    Integer candidate = null;

    for (int num : nums) {
        if (count == 0) {
            candidate = num;
        }
        count += (num == candidate) ? 1 : -1;
    }

    return candidate;
}

-----
public int majorityElement(int[] nums) 
    // Your code here
}

************************************
Question ID: 171

public int titleToNumber(String columnTitle) {
    int result = 0;
    for (char c : columnTitle.toCharArray()) {
        result = result * 26 + (c - 'A' + 1);
    }
    return result;
}

-----
public int titleToNumber(String columnTitle) 
    // Your code here
}

************************************
Question ID: 172

public int trailingZeroes(int n) {
    int count = 0;
    while (n > 0) {
        n = n / 5;
        count += n;
    }
    return count;
}


-----
public int trailingZeroes(int n) 
    // Your code here
}


************************************
Question ID: 174

public int calculateMinimumHP(int[][] dungeon) {
    int m = dungeon.length, n = dungeon[0].length;
    int[][] dp = new int[m][n];

    for (int i = m - 1; i >= 0; i--) {
        for (int j = n - 1; j >= 0; j--) {
            if(i == m-1 && j == n-1)
                dp[i][j] = Math.min(0, dungeon[i][j]);
            else if (i == m - 1)
                dp[i][j] = Math.min(0, dp[i][j + 1] + dungeon[i][j]);
            else if (j == n - 1)
                dp[i][j] = Math.min(0, dp[i + 1][j] + dungeon[i][j]);
            else
                dp[i][j] = Math.min(0, Math.max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);
        }
    }

    return Math.abs(dp[0][0]) + 1;
}

-----
public int calculateMinimumHP(int[][] dungeon) 
    // Your code here
}

************************************
Question ID: 179

import java.util.Arrays;
import java.util.Comparator;

public class Solution {
    public String largestNumber(int[] nums) {
        String[] strNums = new String[nums.length];
        for (int i = 0; i < nums.length; i++) {
            strNums[i] = String.valueOf(nums[i]);
        }
        Arrays.sort(strNums, (a, b) -> (b + a).compareTo(a + b));
        if (strNums[0].equals("0")) {
            return "0";
        }
        StringBuilder sb = new StringBuilder();
        for (String str : strNums) sb.append(str);
        return sb.toString();
    }
}

-----
import java.util.Arrays;
import java.util.Comparator;

public class Solution 
    // Your code here
}

************************************
Question ID: 186

public void reverseWords(char[] s) {
    reverse(s, 0, s.length - 1);
    int start = 0;
    for (int i = 0; i <= s.length; i++) {
        if (i == s.length || s[i] == ' ') {
            reverse(s, start, i - 1);
            start = i + 1;
        }
    }
}

private void reverse(char[] s, int start, int end) {
    while (start < end) {
        char temp = s[start];
        s[start++] = s[end];
        s[end--] = temp;
    }
}

-----
public void reverseWords(char[] s) 
    // Your code here
}

************************************
Question ID: 187

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public List<String> findRepeatedDnaSequences(String s) {
    List<String> result = new ArrayList<>();
    HashMap<String, Integer> dnaCounter = new HashMap<>();

    for (int i = 0; i <= s.length() - 10; i++) {
        String sequence = s.substring(i, i + 10);
        dnaCounter.put(sequence, dnaCounter.getOrDefault(sequence, 0) + 1);
        if (dnaCounter.get(sequence) == 2) {
            result.add(sequence);
        }
    }

    return result;
}

-----
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public List<String> findRepeatedDnaSequences(String s) 
    // Your code here
}

************************************
Question ID: 188

public int maxProfit(int k, int[] prices) {
    int n = prices.length;
    if (k > n / 2) {
        int maxProfit = 0;
        for (int i = 1; i < n; ++i)
            maxProfit += Math.max(prices[i] - prices[i - 1], 0);
        return maxProfit;  
    }

    int[][] dp = new int[k + 1][n];
    for (int i = 1; i <= k; ++i) {
        int maxDiff = -prices[0];
        for (int j = 1; j < n; ++j) {
            dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);
            maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);
        }
    }
    return dp[k][n - 1];
}

-----
public int maxProfit(int k, int[] prices) 
    // Your code here
}

************************************
Question ID: 189

public void rotate(int[] nums, int k) {
    int n = nums.length;
    k %= n;
    reverse(nums, 0, n - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, n - 1);
}

private void reverse(int[] nums, int start, int end) {
    while (start < end) {
        int temp = nums[start];
        nums[start++] = nums[end];
        nums[end--] = temp;
    }
}

-----
public void rotate(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 190

public int reverseBits(int n) {
    int res = 0;
    for (int i = 0; i < 32; ++i) {
        res <<= 1;
        res |= n & 1;
        n >>= 1;
    }
    return res;
}

-----
public int reverseBits(int n) 
    // Your code here
}

************************************
Question ID: 191

public int hammingWeight(int n) {
    int count = 0;
    while (n != 0) {
        count += n & 1;
        n >>>= 1;
    }
    return count;
}

-----
public int hammingWeight(int n) 
    // Your code here
}

************************************
Question ID: 194

import java.util.*;

public List<String> transpose(List<String> content) {
    List<List<String>> data = new ArrayList<>();
    for (String line : content) {
        List<String> row = new ArrayList<>(Arrays.asList(line.split(" ")));
        data.add(row);
    }

    List<String> result = new ArrayList<>(Collections.nCopies(data.get(0).size(), ""));
    for (int i = 0; i < data.get(0).size(); i++) {
        for (int j = 0; j < data.size(); j++) {
            result.set(i, result.get(i) + (j > 0 ? " " : "") + data.get(j).get(i));
        }
    }

    return result;
}


-----
import java.util.*;

public List<String> transpose(List<String> content) 
    // Your code here
}


************************************
Question ID: 198

public int rob(int[] nums) {
    int prev1 = 0, prev2 = 0;
    for (int num : nums) {
        int temp = prev1;
        prev1 = Math.max(prev2 + num, prev1);
        prev2 = temp;
    }
    return prev1;
}

-----
public int rob(int[] nums) 
    // Your code here
}

************************************
Question ID: 200

class Solution {
    private void dfs(char[][] grid, int i, int j) {
        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == '0')
            return;

        grid[i][j] = '0';
        dfs(grid, i + 1, j);
        dfs(grid, i - 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i, j - 1);
    }

    public int numIslands(char[][] grid) {
        int count = 0;
        for(int i = 0; i < grid.length; i++) {
            for(int j = 0; j < grid[0].length; j++) {
                if(grid[i][j] == '1') {
                    count++;
                    dfs(grid, i, j);
                }
            }
        }
        return count;
    }
}

-----
class Solution 
    // Your code here
}

************************************
Question ID: 201

public int rangeBitwiseAnd(int left, int right) {
    int shift = 0;
    while (left != right) {
        left >>= 1;
        right >>= 1;
        shift++;
    }
    return left << shift;
}

-----
public int rangeBitwiseAnd(int left, int right) 
    // Your code here
}

************************************
Question ID: 202

public int getNext(int n) {
    int sum = 0;
    while (n > 0) {
        int digit = n % 10;
        sum += digit * digit;
        n /= 10;
    }
    return sum;
}

public boolean isHappy(int n) {
    int slow = n, fast = getNext(n);
    while (fast != 1 && slow != fast) {
        slow = getNext(slow);
        fast = getNext(getNext(fast));
    }
    return fast == 1;
}

-----
public int getNext(int n) 
    // Your code here
}

************************************
Question ID: 204

public int countPrimes(int n) {
    if (n <= 2) return 0;
    boolean[] isPrime = new boolean[n];
    Arrays.fill(isPrime, true);
    isPrime[0] = isPrime[1] = false;
    for (int i = 2; i * i < n; i++) {
        if (isPrime[i]) {
            for (int j = i * i; j < n; j += i) {
                isPrime[j] = false;
            }
        }
    }
    int count = 0;
    for (boolean prime : isPrime) {
        if (prime) count++;
    }
    return count;
}

-----
public int countPrimes(int n) 
    // Your code here
}

************************************
Question ID: 205

import java.util.HashMap;

public boolean isIsomorphic(String s, String t) {
    HashMap<Character, Character> map1 = new HashMap<>();
    HashMap<Character, Character> map2 = new HashMap<>();
    
    for (int i = 0; i < s.length(); i++) {
        char sChar = s.charAt(i);
        char tChar = t.charAt(i);
        
        if (!map1.containsKey(sChar)) {
            map1.put(sChar, tChar);
        }
        if (!map2.containsKey(tChar)) {
            map2.put(tChar, sChar);
        }
        
        if (map1.get(sChar) != tChar || map2.get(tChar) != sChar) {
           return false;
        }
    }
    return true;
}

-----
import java.util.HashMap;

public boolean isIsomorphic(String s, String t) 
    // Your code here
}

************************************
Question ID: 207

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public boolean canFinish(int numCourses, int[][] prerequisites) {
    List<List<Integer>> adj = new ArrayList<>(numCourses);
    int[] inDegree = new int[numCourses];
    
    for (int i = 0; i < numCourses; i++)
        adj.add(new ArrayList<>());
    
    for (int[] p : prerequisites) {
        adj.get(p[1]).add(p[0]);
        inDegree[p[0]]++;
    }
    
    Queue<Integer> q = new LinkedList<>();
    for (int i = 0; i < numCourses; i++) {
        if (inDegree[i] == 0) q.add(i);
    }
    
    while (!q.isEmpty()) {
        int currCourse = q.poll();
        numCourses--;
        
        for (int nextCourse : adj.get(currCourse)) {
            inDegree[nextCourse]--;
            if (inDegree[nextCourse] == 0) q.add(nextCourse);
        }
    }
    
    return numCourses == 0;
}


-----
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public boolean canFinish(int numCourses, int[][] prerequisites) 
    // Your code here
}


************************************
Question ID: 209

public int minSubArrayLen(int target, int[] nums) {
    int left = 0, cur_sum = 0, min_len = Integer.MAX_VALUE;
    for (int right = 0; right < nums.length; right++) {
        cur_sum += nums[right];
        while (cur_sum >= target) {
            min_len = Math.min(min_len, right - left + 1);
            cur_sum -= nums[left++];
        }
    }
    return min_len == Integer.MAX_VALUE ? 0 : min_len;
}

-----
public int minSubArrayLen(int target, int[] nums) 
    // Your code here
}

************************************
Question ID: 210

import java.util.*;

public int[] findOrder(int numCourses, int[][] prerequisites) {
    int[] inDegree = new int[numCourses];
    List<List<Integer>> adjList = new ArrayList<>();
    
    for (int i = 0; i < numCourses; i++) {
        adjList.add(new ArrayList<>());
    }
    
    for (int[] p : prerequisites) {
        adjList.get(p[1]).add(p[0]);
        inDegree[p[0]]++;
    }
    
    Queue<Integer> q = new LinkedList<>();
    for (int i = 0; i < numCourses; i++) {
        if (inDegree[i] == 0) {
            q.offer(i);
        }
    }
    
    int[] order = new int[numCourses];
    int index = 0;
    
    while (!q.isEmpty()) {
        int curr = q.poll();
        order[index++] = curr;
        for (int next : adjList.get(curr)) {
            if (--inDegree[next] == 0) {
                q.offer(next);
            }
        }
    }
    
    return (index == numCourses) ? order : new int[0];
}


-----
import java.util.*;

public int[] findOrder(int numCourses, int[][] prerequisites) 
    // Your code here
}


************************************
Question ID: 212

import java.util.ArrayList;
import java.util.List;

public List<String> findWords(char[][] board, String[] words) {
    List<String> result = new ArrayList<>();
    for (String word : words) {
        if (exist(board, word)) {
            result.add(word);
        }
    }
    return result;
}

private boolean exist(char[][] board, String word) {
    int m = board.length;
    int n = board[0].length;
    boolean[][] visited = new boolean[m][n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (dfs(board, word, 0, i, j, visited)) {
                return true;
            }
        }
    }
    return false;
}

private boolean dfs(char[][] board, String word, int index, int i, int j, boolean[][] visited) {
    if (index == word.length()) {
        return true;
    }
    if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j] || board[i][j] != word.charAt(index)) {
        return false;
    }
    visited[i][j] = true;
    boolean found =
            dfs(board, word, index + 1, i - 1, j, visited) ||
            dfs(board, word, index + 1, i + 1, j, visited) ||
            dfs(board, word, index + 1, i, j - 1, visited) ||
            dfs(board, word, index + 1, i, j + 1, visited);
    visited[i][j] = false;
    return found;
}


-----
import java.util.ArrayList;
import java.util.List;

public List<String> findWords(char[][] board, String[] words) 
    // Your code here
}


************************************
Question ID: 213

public int rob(int[] nums) {
    if (nums.length == 1) return nums[0];
    int prev = 0, curr = 0;
    for (int i = 0; i < nums.length - 1; i++) {
        int temp = Math.max(curr, prev + nums[i]);
        prev = curr;
        curr = temp;
    }
    int res = curr;
    prev = 0;
    curr = 0;
    for (int i = 1; i < nums.length; i++) {
        int temp = Math.max(curr, prev + nums[i]);
        prev = curr;
        curr = temp;
    }
    return Math.max(res, curr);
}

-----
public int rob(int[] nums) 
    // Your code here
}

************************************
Question ID: 214

public String shortestPalindrome(String s) {
    int n = s.length();
    String rev_s = new StringBuilder(s).reverse().toString();
    
    for (int i = 0; i < n; ++i) {
        if(s.substring(0, n - i).equals(rev_s.substring(i)))
            return rev_s.substring(0, i) + s;
    }
    return "";
}


-----
public String shortestPalindrome(String s) 
    // Your code here
}


************************************
Question ID: 215

import java.util.PriorityQueue;

public int findKthLargest(int[] nums, int k) {
    PriorityQueue<Integer> minHeap = new PriorityQueue<>();
    for (int num : nums) {
        minHeap.add(num);
        if (minHeap.size() > k) {
            minHeap.poll();
        }
    }
    return minHeap.poll();
}

-----
import java.util.PriorityQueue;

public int findKthLargest(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 216

import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> combinationSum3(int k, int n) {
    List<List<Integer>> result = new ArrayList<>();
    helper(k, n, 0, new ArrayList<>(), result);
    return result;
}

private void helper(int k, int n, int current, List<Integer> currentComb, List<List<Integer>> result) {
    if (k == 0 && n == 0) {
        result.add(new ArrayList<>(currentComb));
    } else if (k > 0 && n > 0) {
        for (int i = current + 1; i <= 9; i++) {
            currentComb.add(i);
            helper(k - 1, n - i, i, currentComb, result);
            currentComb.remove(currentComb.size() - 1);
        }
    }
}


-----
import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> combinationSum3(int k, int n) 
    // Your code here
}


************************************
Question ID: 217

public boolean containsDuplicate(int[] nums) {
    Set<Integer> set = new HashSet<Integer>();
    for (int num : nums) {
        if (!set.add(num)) {
            return true;
        }
    }
    return false;
}


-----
public boolean containsDuplicate(int[] nums) 
    // Your code here
}


************************************
Question ID: 218

import java.util.*;

class Solution {
    public List<List<Integer>> getSkyline(int[][] buildings) {
        List<int[]> points = new ArrayList<>();
        for (int[] b : buildings) {
            points.add(new int[]{b[0], -b[2]});
            points.add(new int[]{b[1], b[2]});
        }
        Collections.sort(points, (a, b) -> a[0] - b[0]);
        TreeSet<Integer> heights = new TreeSet<>(Collections.reverseOrder());
        heights.add(0);
        int prev = 0;
        List<List<Integer>> skyline = new ArrayList<>();
        for (int[] point : points) {
            int x = point[0], h = point[1];
            if (h < 0)
                heights.add(-h);
            else
                heights.remove(h);
            int cur = heights.first();
            if (cur != prev) {
                skyline.add(Arrays.asList(x, cur));
                prev = cur;
            }
        }
        return skyline;
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 219

public boolean containsNearbyDuplicate(int[] nums, int k) {
    HashMap<Integer, Integer> valueIndexMap = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        if (valueIndexMap.containsKey(nums[i]) && i - valueIndexMap.get(nums[i]) <= k) {
            return true;
        }
        valueIndexMap.put(nums[i], i);
    }
    return false;
}

-----
public boolean containsNearbyDuplicate(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 220

import java.util.TreeSet;

public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
    TreeSet<Long> window = new TreeSet<>();
    for(int i = 0; i < nums.length; i++) {
        if(i > k) {
            window.remove((long)nums[i - k - 1]);
        }
        Long ceil = window.ceiling((long)nums[i] - t);
        if(ceil != null && ceil - nums[i] <= t) {
            return true;
        }
        window.add((long)nums[i]);
    }
    return false;
}

-----
import java.util.TreeSet;

public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) 
    // Your code here
}

************************************
Question ID: 221

public int maximalSquare(char[][] matrix) {
    int m = matrix.length;
    int n = matrix[0].length;
    int[][] dp = new int[m + 1][n + 1];
    int maxSize = 0;

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (matrix[i - 1][j - 1] == '1') {
                dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                maxSize = Math.max(maxSize, dp[i][j]);
            }
        }
    }

    return maxSize * maxSize;
}

-----
public int maximalSquare(char[][] matrix) 
    // Your code here
}

************************************
Question ID: 223

public int totalArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {
    int area1 = (ax2 - ax1) * (ay2 - ay1);
    int area2 = (bx2 - bx1) * (by2 - by1);

    int overlapWidth = Math.min(ax2, bx2) - Math.max(ax1, bx1);
    int overlapHeight = Math.min(ay2, by2) - Math.max(ay1, by1);

    int overlapArea = Math.max(overlapWidth, 0) * Math.max(overlapHeight, 0);

    return area1 + area2 - overlapArea;
}


-----
public int totalArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) 
    // Your code here
}


************************************
Question ID: 224

public int calculate(String s) {
    int result = 0, sign = 1, num = 0;
    Stack<Integer> st = new Stack<>();
    for (char c : s.toCharArray()) {
        if (Character.isDigit(c)) {
            num = num * 10 + (c - '0');
        } else {
            result += sign * num;
            num = 0;
            if (c == '+') {
                sign = 1;
            } else if (c == '-') {
                sign = -1;
            } else if (c == '(') {
                st.push(result);
                st.push(sign);
                result = 0;
                sign = 1;
            } else if (c == ')') {
                int prev_sign = st.pop();
                int prev_result = st.pop();
                result = prev_result + prev_sign * result;
            }
        }
    }
    result += sign * num;
    return result;
}

-----
public int calculate(String s) 
    // Your code here
}

************************************
Question ID: 225

import java.util.*;

class MyStack {
    Queue<Integer> q1 = new LinkedList<>();
    Queue<Integer> q2 = new LinkedList<>();

    public void push(int x) {
        q2.add(x);
        while (!q1.isEmpty()) {
            q2.add(q1.remove());
        }
        Queue<Integer> temp = q1;
        q1 = q2;
        q2 = temp;
    }

    public int pop() {
        return q1.remove();
    }

    public int top() {
        return q1.peek();
    }

    public boolean empty() {
        return q1.isEmpty();
    }
}

-----
import java.util.*;

class MyStack 
    // Your code here
}

************************************
Question ID: 227

public int calculate(String s) {
    int result = 0, num = 0, sign = 1;
    Stack<Integer> stack = new Stack<>();

    for (char c : s.toCharArray()) {
        if (Character.isDigit(c)) {
            num = num * 10 + (c - '0');
        } else if (c == '+') {
            result += sign * num;
            num = 0;
            sign = 1;
        } else if (c == '-') {
            result += sign * num;
            num = 0;
            sign = -1;
        } else if (c == '(') {
            stack.push(result);
            stack.push(sign);
            result = 0;
            sign = 1;
        } else if (c == ')') {
            result += sign * num;
            num = 0;
            result *= stack.pop();
            result += stack.pop();
        }
    }
    if (num != 0) result += sign * num;
    return result;
}

-----
public int calculate(String s) 
    // Your code here
}

************************************
Question ID: 228

import java.util.ArrayList;
import java.util.List;

public List<String> findRanges(int[] nums) {
    List<String> result = new ArrayList<>();
    int n = nums.length;
    if (n == 0) return result;

    int start = nums[0];
    for (int i = 1; i < n; i++) {
        if (nums[i] > nums[i-1] + 1) {
            if (start == nums[i-1])
                result.add(Integer.toString(start));
            else
                result.add(start + "->" + nums[i-1]);
            start = nums[i];
        }
    }

    if (start == nums[n-1])
        result.add(Integer.toString(start));
    else
        result.add(start + "->" + nums[n-1]);

    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<String> findRanges(int[] nums) 
    // Your code here
}

************************************
Question ID: 229

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public List<Integer> majorityElement(int[] nums) {
    int n = nums.length;
    HashMap<Integer, Integer> count = new HashMap<>();
    ArrayList<Integer> result = new ArrayList<>();

    for (int num : nums) {
        count.put(num, count.getOrDefault(num, 0) + 1);
        if (count.get(num) > n / 3 && !result.contains(num)) {
            result.add(num);
        }
    }
    return result;
}

-----
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public List<Integer> majorityElement(int[] nums) 
    // Your code here
}

************************************
Question ID: 231

boolean isPowerOfTwo(int n) {
    if (n <= 0) {
        return false;
    }
    return (n & (n - 1)) == 0;
}

-----
boolean isPowerOfTwo(int n) 
    // Your code here
}

************************************
Question ID: 233

public int countDigitOne(int n) {
    int count = 0;
    for(long i = 1; i <= n; i *= 10){
        long divider = i * 10;
        count += (n / divider) * i + Math.min(Math.max(n % divider - i + 1, 0), i);
    }
    return count;
}

-----
public int countDigitOne(int n) 
    // Your code here
}

************************************
Question ID: 237

public void deleteNode(ListNode node) {
    ListNode nextNode = node.next;
    node.val = nextNode.val;
    node.next = nextNode.next;
}

-----
public void deleteNode(ListNode node) 
    // Your code here
}

************************************
Question ID: 238

public int[] productExceptSelf(int[] nums) {
    int n = nums.length;
    int[] answer = new int[n];
    
    Arrays.fill(answer, 1);
    
    int left = 1;
    for (int i = 0; i < n; i++) {
        answer[i] *= left;
        left *= nums[i];
    }
    
    int right = 1;
    for (int i = n - 1; i >= 0; i--) {
        answer[i] *= right;
        right *= nums[i];
    }
    
    return answer;
}

-----
public int[] productExceptSelf(int[] nums) 
    // Your code here
}

************************************
Question ID: 239

import java.util.LinkedList;
import java.util.Deque;

public int[] maxSlidingWindow(int[] nums, int k) {
    if (nums == null || nums.length == 0) return new int[0];
    int[] result = new int[nums.length - k + 1];
    int idx = 0;
    Deque<Integer> deque = new LinkedList<Integer>();
    
    for (int i = 0; i < nums.length; i++) {
        if (!deque.isEmpty() && deque.peekFirst() == i - k) deque.poll();
            
        while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
            deque.removeLast();
        }    
            
        deque.offer(i);
        if (i >= k - 1) {
            result[idx++] = nums[deque.peek()];
        }
    }
    return result;
}


-----
import java.util.LinkedList;
import java.util.Deque;

public int[] maxSlidingWindow(int[] nums, int k) 
    // Your code here
}


************************************
Question ID: 240

public boolean searchMatrix(int[][] matrix, int target) {
    int row = matrix.length - 1, col = 0;
    while (row >= 0 && col < matrix[0].length) {
        if (matrix[row][col] > target) {
            row--;
        } else if (matrix[row][col] < target) {
            col++;
        } else {
            return true;
        }
    }
    return false;
}

-----
public boolean searchMatrix(int[][] matrix, int target) 
    // Your code here
}

************************************
Question ID: 241

import java.util.ArrayList;
import java.util.List;

public List<Integer> diffWaysToCompute(String input) {
    List<Integer> result = new ArrayList<>();
    for (int i = 0; i < input.length(); i++) {
        char c = input.charAt(i);
        if (c == '+' || c == '-' || c == '*') {
            List<Integer> left = diffWaysToCompute(input.substring(0, i));
            List<Integer> right = diffWaysToCompute(input.substring(i + 1));
            for (int l : left) {
                for (int r : right) {
                    if (c == '+') result.add(l + r);
                    else if (c == '-') result.add(l - r);
                    else if (c == '*') result.add(l * r);
                }
            }
        }
    }
    if (result.isEmpty()) result.add(Integer.parseInt(input));
    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<Integer> diffWaysToCompute(String input) 
    // Your code here
}

************************************
Question ID: 242

public boolean isAnagram(String s, String t) {
    if(s.length() != t.length())
        return false;

    int[] counts = new int[26];
    for(char c : s.toCharArray())
        counts[c - 'a']++;

    for(char c : t.toCharArray()) {
        if(counts[c - 'a'] == 0)
            return false;
        counts[c - 'a']--;
    }

    return true;
}

-----
public boolean isAnagram(String s, String t) 
    // Your code here
}

************************************
Question ID: 243

public int shortestDistance(String[] wordsDict, String word1, String word2) {
    int idx1 = -1, idx2 = -1, minDistance = Integer.MAX_VALUE;
    for (int i = 0; i < wordsDict.length; i++) {
        if (word1.equals(wordsDict[i])) idx1 = i;
        if (word2.equals(wordsDict[i])) idx2 = i;
        if (idx1 != -1 && idx2 != -1)
            minDistance = Math.min(minDistance, Math.abs(idx1 - idx2));
    }
    return minDistance;
}

-----
public int shortestDistance(String[] wordsDict, String word1, String word2) 
    // Your code here
}

************************************
Question ID: 245

public int shortestDistance(String[] wordsDict, String word1, String word2) {
    int index1 = -1, index2 = -1, minDistance = Integer.MAX_VALUE;
    for (int i = 0; i < wordsDict.length; ++i) {
        if (wordsDict[i].equals(word1)) { index1 = i; }
        if (wordsDict[i].equals(word2)) { index2 = i; }
        if (index1 != -1 && index2 != -1) {
            minDistance = Math.min(minDistance, Math.abs(index1 - index2));
        }
    }
    return minDistance;
}

-----
public int shortestDistance(String[] wordsDict, String word1, String word2) 
    // Your code here
}

************************************
Question ID: 246

public boolean isStrobogrammatic(String num) {
    HashMap<Character, Character> lookup = new HashMap<Character, Character>() {{
        put('0', '0');
        put('1', '1');
        put('6', '9');
        put('8', '8');
        put('9', '6');
    }};
    int left = 0, right = num.length() - 1;
    while(left <= right) {
        if(!lookup.containsKey(num.charAt(left)) || lookup.get(num.charAt(left)) != num.charAt(right)) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}

-----
public boolean isStrobogrammatic(String num) 
    // Your code here
}

************************************
Question ID: 247

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<String> findStrobogrammatic(int n) {
    return helper(n, n);
}

private List<String> helper(int n, int m) {
    if (n == 0) return new ArrayList<>(Arrays.asList(""));
    if (n == 1) return new ArrayList<>(Arrays.asList("0", "1", "8"));
    
    List<String> list = helper(n - 2, m);
    List<String> res = new ArrayList<>();

    for (int i = 0; i < list.size(); i++) {
        String s = list.get(i);
        
        if (n != m) res.add("0" + s + "0");

        res.add("1" + s + "1");
        res.add("6" + s + "9");
        res.add("8" + s + "8");
        res.add("9" + s + "6");
    }

    return res;
}

-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<String> findStrobogrammatic(int n) 
    // Your code here
}

************************************
Question ID: 248

public int strobogrammaticInRange(String low, String high) {
    int count = 0;
    for(int len = low.length(); len <= high.length(); ++len)
        count += withinRange(helper(len, len), low, high) ? 1 : 0;
    return count;
}

private String helper(int m, int n) {
    if(m == 0) return "";
    if(m == 1) return "0 1 8";
    if(n == 0) return "11 69 88 96";
    String res = "";
    for(String a : helper(m - 2, n).split(" ")) {
        if(m != n) res += a + "0" + a + " ";
        res += a + "1" + a + " ";
        res += a + "6" + a + " ";
        res += a + "8" + a + " ";
        res += a + "9" + a + " ";
    }
    return res;
}

private boolean withinRange(String num, String low, String high) {
    if(num.length() > low.length()) return num.compareTo(high) <= 0;
    if(num.length() < low.length()) return num.compareTo(low) >= 0;
    return num.compareTo(low) >= 0 && num.compareTo(high) <= 0;
}


-----
public int strobogrammaticInRange(String low, String high) 
    // Your code here
}


************************************
Question ID: 249

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public List<List<String>> groupStrings(String[] strings) {
    Map<String, List<String>> map = new HashMap<>();

    for (String s : strings) {
        StringBuilder key = new StringBuilder();
        for (char c : s.toCharArray()) {
            key.append((c - s.charAt(0) + 26) % 26).append(",");
        }
        String keyStr = key.toString();
        map.putIfAbsent(keyStr, new ArrayList<>());
        map.get(keyStr).add(s);
    }

    return new ArrayList<>(map.values());
}

-----
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public List<List<String>> groupStrings(String[] strings) 
    // Your code here
}

************************************
Question ID: 252

import java.util.Arrays;

public boolean canAttendMeetings(int[][] intervals) {
    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
    
    for (int i = 1; i < intervals.length; ++i) {
        if (intervals[i][0] < intervals[i - 1][1])
            return false;
    }
    
    return true;
}

-----
import java.util.Arrays;

public boolean canAttendMeetings(int[][] intervals) 
    // Your code here
}

************************************
Question ID: 253

import java.util.Arrays;
import java.util.PriorityQueue;

public int minMeetingRooms(int[][] intervals) {
    if (intervals == null || intervals.length == 0) return 0;
    
    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
    PriorityQueue<Integer> minHeap = new PriorityQueue<>();
    
    minHeap.add(intervals[0][1]);
    for (int i = 1; i < intervals.length; i++) {
        if (intervals[i][0] >= minHeap.peek()) {
            minHeap.poll();
        }
        minHeap.add(intervals[i][1]);
    }
    
    return minHeap.size();
}

-----
import java.util.Arrays;
import java.util.PriorityQueue;

public int minMeetingRooms(int[][] intervals) 
    // Your code here
}

************************************
Question ID: 254

import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> getFactors(int n) {
    List<List<Integer>> result = new ArrayList<>();
    helper(n, 2, new ArrayList<Integer>(), result);
    return result;
}

private void helper(int n, int start, List<Integer> path, List<List<Integer>> result) {
    if (n == 1) {
        if (path.size() > 1) {
            result.add(new ArrayList<>(path));
        }
        return;
    }

    for (int i = start; i <= n; i++) {
        if (n % i == 0) {
            path.add(i);
            helper(n / i, i, path, result);
            path.remove(path.size() - 1);
        }
    }
}

-----
import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> getFactors(int n) 
    // Your code here
}

************************************
Question ID: 255

public boolean isValidPreorder(int[] preorder) {
    Stack<Integer> stack = new Stack<>();
    int lowerBound = Integer.MIN_VALUE;
    for (int num : preorder) {
        if (num < lowerBound) return false;
        while (!stack.isEmpty() && num > stack.peek()) {
            lowerBound = stack.pop();
        }
        stack.push(num);
    }
    return true;
}

-----
public boolean isValidPreorder(int[] preorder) 
    // Your code here
}

************************************
Question ID: 256

public int minCost(int[][] costs) {
    if (costs.length == 0) return 0;
    for (int i = 1; i < costs.length; i++) {
        costs[i][0] += Math.min(costs[i - 1][1], costs[i - 1][2]);
        costs[i][1] += Math.min(costs[i - 1][0], costs[i - 1][2]);
        costs[i][2] += Math.min(costs[i - 1][0], costs[i - 1][1]);
    }
    return Math.min(costs[costs.length - 1][0], Math.min(costs[costs.length - 1][1], costs[costs.length - 1][2]));
}

-----
public int minCost(int[][] costs) 
    // Your code here
}

************************************
Question ID: 258

public int addDigits(int num) {
    return 1 + (num - 1) % 9;
}

-----
public int addDigits(int num) 
    // Your code here
}

************************************
Question ID: 259

public int threeSumSmaller(int[] nums, int target) {
    int count = 0;
    Arrays.sort(nums);
    for (int i = 0; i < nums.length; ++i) {
        int j = i + 1, k = nums.length - 1;
        while (j < k) {
            if (nums[i] + nums[j] + nums[k] < target) {
                count += k - j;
                ++j;
            } else {
                --k;
            }
        }
    }
    return count;
}

-----
public int threeSumSmaller(int[] nums, int target) 
    // Your code here
}

************************************
Question ID: 260

public int[] singleNumber(int[] nums) {
    int xor_all = 0;
    for (int num : nums) {
        xor_all ^= num;
    }

    int bit = xor_all & -xor_all;
    int n1 = 0;
    int n2 = 0;
    for (int num : nums) {
        if ((num & bit) != 0) {
            n1 ^= num;
        } else {
            n2 ^= num;
        }
    }

    return new int[]{n1, n2};
}

-----
public int[] singleNumber(int[] nums) 
    // Your code here
}

************************************
Question ID: 261

import java.util.ArrayList;
import java.util.List;

public boolean isTree(int n, int[][] edges) {
    List<List<Integer>> neighbors = new ArrayList<>(n);
    for (int i = 0; i < n; i++) neighbors.add(new ArrayList<>());
    for (int[] edge : edges) {
        neighbors.get(edge[0]).add(edge[1]);
        neighbors.get(edge[1]).add(edge[0]);
    }
    boolean[] visited = new boolean[n];
    if(hasCycle(neighbors, visited, -1, 0)) return false;
    for (boolean visit : visited)
        if (!visit) return false;
    return true;
}

private boolean hasCycle(List<List<Integer>> neighbors, boolean[] visited, int parent, int node) {
    visited[node] = true;
    for (int neighbor : neighbors.get(node))
        if ((neighbor != parent && visited[neighbor]) || (!visited[neighbor] && hasCycle(neighbors, visited, node, neighbor))) return true;
    return false;
}

-----
import java.util.ArrayList;
import java.util.List;

public boolean isTree(int n, int[][] edges) 
    // Your code here
}

************************************
Question ID: 263

public boolean isUgly(int n) {
    if (n <= 0) return false;
    while (n % 2 == 0) n /= 2;
    while (n % 3 == 0) n /= 3;
    while (n % 5 == 0) n /= 5;
    return n == 1;
}

-----
public boolean isUgly(int n) 
    // Your code here
}

************************************
Question ID: 264

public int nthUglyNumber(int n) {
    int[] uglyNumbers = new int[n];
    uglyNumbers[0] = 1;
    int i2 = 0, i3 = 0, i5 = 0;

    for (int i = 1; i < n; i++) {
        uglyNumbers[i] = Math.min(Math.min(uglyNumbers[i2] * 2, uglyNumbers[i3] * 3), uglyNumbers[i5] * 5);
        if (uglyNumbers[i] == uglyNumbers[i2] * 2) i2++;
        if (uglyNumbers[i] == uglyNumbers[i3] * 3) i3++;
        if (uglyNumbers[i] == uglyNumbers[i5] * 5) i5++;
    }

    return uglyNumbers[n - 1];
}


-----
public int nthUglyNumber(int n) 
    // Your code here
}


************************************
Question ID: 265

public int minCost(int[][] costs) {
    if (costs == null || costs.length == 0) return 0;

    int n = costs.length;
    int k = costs[0].length;

    for (int i = 1; i < n; i++) {
        for (int j = 0; j < k; j++) {
            int minCost = Integer.MAX_VALUE;
            for (int l = 0; l < k; l++) {
                if (l == j) continue;
                minCost = Math.min(minCost, costs[i - 1][l]);
            }
            costs[i][j] += minCost;
        }
    }
    return Arrays.stream(costs[n - 1]).min().getAsInt();
}


-----
public int minCost(int[][] costs) 
    // Your code here
}


************************************
Question ID: 266

public boolean canPermutePalindrome(String s) {
    HashMap<Character, Integer> count = new HashMap<>();
    for(char c : s.toCharArray()) {
        count.put(c, count.getOrDefault(c, 0) + 1);
    }
    int odd_count = 0;
    for(int value : count.values()) {
        if (value % 2 != 0) {
            odd_count++;
        }
    }
    return odd_count <= 1;
}

-----
public boolean canPermutePalindrome(String s) 
    // Your code here
}

************************************
Question ID: 267

import java.util.*;

public class Solution {
    public List<String> generatePalindromes(String s) {
        List<String> result = new ArrayList<>();
        Map<Character, Integer> charCount = new HashMap<>();
        for (char c : s.toCharArray()) {
            charCount.put(c, charCount.getOrDefault(c, 0) + 1);
        }

        String midChar = "";
        List<Character> halfChars = new ArrayList<>();
        int numOdds = 0;
        for (Map.Entry<Character, Integer> entry : charCount.entrySet()) {
            if (entry.getValue() % 2 == 1) {
                numOdds++;
                midChar = String.valueOf(entry.getKey());
            }
            for (int i = 0; i < entry.getValue() / 2; i++) {
                halfChars.add(entry.getKey());
            }

            if (numOdds > 1) {
                return result;
            }
        }

        permute(0, halfChars, midChar, new ArrayList<>(), result);
        return result;
    }

    private void permute(int idx, List<Character> halfChars, String midChar, List<Character> current, List<String> result) {
        if (idx == halfChars.size()) {
            String firstHalf = "".valueOf(current.toArray(new Character[0]));
            result.add(firstHalf + midChar + new StringBuilder(firstHalf).reverse());
            return;
        }

        for (int i = 0; i < halfChars.size(); i++) {
            if (i > 0 && halfChars.get(i) == halfChars.get(i - 1)) {
                continue;
            }
            Character c = halfChars.remove(i);
            current.add(c);
            permute(idx + 1, halfChars, midChar, current, result);
            current.remove(current.size() - 1);
            halfChars.add(i, c);
        }
    }
}

-----
import java.util.*;

public class Solution 
    // Your code here
}

************************************
Question ID: 268

public int missingNumber(int[] nums) {
    int n = nums.length;
    int expectedSum = (n * (n + 1)) / 2;
    int actualSum = 0;
    for (int num : nums) {
        actualSum += num;
    }
    return expectedSum - actualSum;
}

-----
public int missingNumber(int[] nums) 
    // Your code here
}

************************************
Question ID: 269

import java.util.*;

public String alienOrder(String[] words) {
    Map<Character, Set<Character>> graph = new HashMap<>();
    Map<Character, Integer> inDegree = new HashMap<>();
    
    for (String word : words) {
        for (char c : word.toCharArray())
            inDegree.put(c, 0);
    }
    
    for (int i = 0; i < words.length - 1; i++) {
        String word1 = words[i], word2 = words[i + 1];
        
        boolean found = false;
        for (int j = 0; j < Math.min(word1.length(), word2.length()); j++) {
            char c1 = word1.charAt(j), c2 = word2.charAt(j);
            if (c1 != c2) {
                graph.putIfAbsent(c1, new HashSet<>());
                if (!graph.get(c1).contains(c2)) {
                    graph.get(c1).add(c2);
                    inDegree.put(c2, inDegree.get(c2) + 1);
                }
                found = true;
                break;
            }
        }
        
        if (!found && word1.length() > word2.length())
            return "";
    }

    Queue<Character> q = new LinkedList<>();
    for (Map.Entry<Character, Integer> entry : inDegree.entrySet())
        if (entry.getValue() == 0)
            q.offer(entry.getKey());
    
    StringBuilder result = new StringBuilder();
    while (!q.isEmpty()) {
        char c = q.poll();
        result.append(c);
        
        if (graph.containsKey(c)) {
            for (char neigh : graph.get(c)) {
                inDegree.put(neigh, inDegree.get(neigh) - 1);
                if (inDegree.get(neigh) == 0)
                    q.offer(neigh);
            }
        }
    }
    
    if (result.length() < inDegree.size())
        return "";
    
    return result.toString();
}

-----
import java.util.*;

public String alienOrder(String[] words) 
    // Your code here
}

************************************
Question ID: 271

import java.util.ArrayList;
import java.util.List;

public String encode(List<String> strs) {
    StringBuilder encodedString = new StringBuilder();
    for (String s : strs) {
        encodedString.append(s.length()).append('#').append(s);
    }
    return encodedString.toString();
}

public List<String> decode(String s) {
    List<String> strs = new ArrayList<>();
    int i = 0;
    while (i < s.length()) {
        int delimiterPos = s.indexOf('#', i);
        int length = Integer.parseInt(s.substring(i, delimiterPos));
        strs.add(s.substring(delimiterPos + 1, delimiterPos + 1 + length));
        i = delimiterPos + 1 + length;
    }
    return strs;
}

-----
import java.util.ArrayList;
import java.util.List;

public String encode(List<String> strs) 
    // Your code here
}

************************************
Question ID: 272

import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
}

public List<Integer> closestKValues(TreeNode root, double target, int k) {
    PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> Double.compare(b[1], a[1]));
    List<Integer> values = new ArrayList<>();

    inorderTraversal(root, target, k, maxHeap);

    while (!maxHeap.isEmpty()) {
        values.add(maxHeap.poll()[0]);
    }
    return values;
}

void inorderTraversal(TreeNode node, double target, int k, PriorityQueue<int[]> maxHeap) {
    if (node == null) return;

    inorderTraversal(node.left, target, k, maxHeap);
    maxHeap.offer(new int[]{node.val, Math.abs(node.val - target)});
    if (maxHeap.size() > k) maxHeap.poll();
    inorderTraversal(node.right, target, k, maxHeap);
}

-----
import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;

class TreeNode 
    // Your code here
}

************************************
Question ID: 274

public int hIndex(int[] citations) {
    Arrays.sort(citations);
    int h = 0;
    for (int i = citations.length - 1; i >= 0; i--) {
        int rank = citations.length - i;
        if (citations[i] >= rank) {
            h = rank;
        } else {
            break;
        }
    }
    return h;
}

-----
public int hIndex(int[] citations) 
    // Your code here
}

************************************
Question ID: 275

public int hIndex(int[] citations) {
    int n = citations.length;
    int left = 0, right = n - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (citations[mid] == n - mid) {
            return n - mid;
        } else if (citations[mid] < n - mid) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return n - left;
}

-----
public int hIndex(int[] citations) 
    // Your code here
}

************************************
Question ID: 276

public int numWays(int n, int k) {
    if (n == 0) return 0;
    if (n == 1) return k;
    int same = k;
    int different = k * (k - 1);
    for (int i = 2; i < n; ++i) {
        int temp = different;
        different = (same + different) * (k - 1);
        same = temp;
    }
    return same + different;
}

-----
public int numWays(int n, int k) 
    // Your code here
}

************************************
Question ID: 277

public boolean knows(int a, int b);

public int findCelebrity(int n) {
    int candidate = 0;
    for (int i = 1; i < n; i++) {
        if (knows(candidate, i)) {
            candidate = i;
        }
    }
    
    for (int i = 0; i < n; i++) {
        if (i != candidate && (knows(candidate, i) || !knows(i, candidate))) {
            return -1;
        }
    }
    return candidate;
}

-----
public boolean knows(int a, int b);

public int findCelebrity(int n) 
    // Your code here
}

************************************
Question ID: 278

public int firstBadVersion(int n) {
    int left = 1;
    int right = n;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (isBadVersion(mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}


-----
public int firstBadVersion(int n) 
    // Your code here
}


************************************
Question ID: 279

public int numSquares(int n) {
    int[] dp = new int[n + 1];
    Arrays.fill(dp, Integer.MAX_VALUE);
    dp[0] = 0;
    
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j * j <= i; j++) {
            dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
        }
    }
    
    return dp[n];
}

-----
public int numSquares(int n) 
    // Your code here
}

************************************
Question ID: 280

public void wiggleSort(int[] nums) {
    for (int i = 1; i < nums.length; i++) {
        if (i % 2 == 0 && nums[i] > nums[i-1] || i % 2 == 1 && nums[i] < nums[i-1]) {
            int temp = nums[i];
            nums[i] = nums[i-1];
            nums[i-1] = temp;
        }
    }
}

-----
public void wiggleSort(int[] nums) 
    // Your code here
}

************************************
Question ID: 282

import java.util.ArrayList;
import java.util.List;

public List<String> addOperators(String num, int target) {
    List<String> res = new ArrayList<>();
    helper(num, target, 0, 0, 0, "", res);
    return res;
}

private void helper(String num, int target, int pos, long currVal, long prevVal, String currExpr, List<String> res) {
    if (pos == num.length()) {
        if (currVal == target) {
            res.add(currExpr);
        }
        return;
    }

    for (int i = pos; i < num.length(); ++i) {
        if (i != pos && num.charAt(pos) == '0') break;
        long val = Long.parseLong(num.substring(pos, i + 1));
        if (pos == 0) {
            helper(num, target, i + 1, val, val, currExpr + num.substring(pos, i + 1), res);
        } else {
            helper(num, target, i + 1, currVal + val, val, currExpr + "+" + num.substring(pos, i + 1), res);
            helper(num, target, i + 1, currVal - val, -val, currExpr + "-" + num.substring(pos, i + 1), res);
            helper(num, target, i + 1, currVal - prevVal + prevVal * val, prevVal * val, currExpr + "*" + num.substring(pos, i + 1), res);
        }
    }
}


-----
import java.util.ArrayList;
import java.util.List;

public List<String> addOperators(String num, int target) 
    // Your code here
}


************************************
Question ID: 283

public void moveZeroes(int[] nums) {
    int index = 0;
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] != 0) {
            nums[index++] = nums[i];
        }
    }
    for (int i = index; i < nums.length; i++) {
        nums[i] = 0;
    }
}

-----
public void moveZeroes(int[] nums) 
    // Your code here
}

************************************
Question ID: 286

import java.util.Queue;
import java.util.LinkedList;

public void wallsAndGates(int[][] rooms) {
    int m = rooms.length;
    int n = rooms[0].length;
    Queue<int[]> q = new LinkedList<>();
    int INF = 2147483647;

    for(int i = 0; i < m; i++) {
        for(int j = 0; j < n; j++) {
            if(rooms[i][j] == 0) {
                q.offer(new int[]{i, j});
            }
        }
    }
    
    int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    while(!q.isEmpty()) {
        int[] cur = q.poll();
        int i = cur[0];
        int j = cur[1];

        for(int[] d : directions) {
            int ni = i + d[0];
            int nj = j + d[1];

            if(ni >= 0 && ni < m && nj >= 0 && nj < n && rooms[ni][nj] == INF) {
                rooms[ni][nj] = rooms[i][j] + 1;
                q.offer(new int[]{ni, nj});
            }
        }
    }
}

-----
import java.util.Queue;
import java.util.LinkedList;

public void wallsAndGates(int[][] rooms) 
    // Your code here
}

************************************
Question ID: 287

public int findDuplicate(int[] nums) {
    int slow = nums[0];
    int fast = nums[0];

    do {
        slow = nums[slow];
        fast = nums[nums[fast]];
    } while (slow != fast);

    slow = nums[0];

    while (slow != fast) {
        slow = nums[slow];
        fast = nums[fast];
    }

    return slow;
}


-----
public int findDuplicate(int[] nums) 
    // Your code here
}


************************************
Question ID: 289

public int[][] gameOfLife(int[][] board) {
    int m = board.length;
    int n = board[0].length;
    int[][] result = new int[m][n];
    int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};
    
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            int liveNeighbors = 0;
            
            for (int[] dir : dirs) {
                int newRow = i + dir[0];
                int newCol = j + dir[1];
                
                if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && board[newRow][newCol] == 1) {
                    liveNeighbors++;
                }
            }
            
            if (board[i][j] == 1 && (liveNeighbors == 2 || liveNeighbors == 3)) {
                result[i][j] = 1;
            } else if (board[i][j] == 0 && liveNeighbors == 3) {
                result[i][j] = 1;
            }
        }
    }
    
    return result;
}

-----
public int[][] gameOfLife(int[][] board) 
    // Your code here
}

************************************
Question ID: 290

import java.util.HashMap;
import java.util.Map;

public boolean wordPattern(String pattern, String s) {
    String[] words = s.split(" ");
    if (pattern.length() != words.length) return false;

    Map<Character, String> charMap = new HashMap<>();
    Map<String, Character> wordMap = new HashMap<>();

    for (int i = 0; i < pattern.length(); i++) {
        char c = pattern.charAt(i);
        String word = words[i];
        if (!charMap.containsKey(c) && !wordMap.containsKey(word)) {
            charMap.put(c, word);
            wordMap.put(word, c);
        } else {
            if (!word.equals(charMap.get(c)) || c != wordMap.get(word)) return false;
        }
    }

    return true;
}


-----
import java.util.HashMap;
import java.util.Map;

public boolean wordPattern(String pattern, String s) 
    // Your code here
}


************************************
Question ID: 291

public boolean wordPatternMatch(String pattern, String s) {
    Map<Character, String> patternMap = new HashMap<>();
    Set<String> words = new HashSet<>();
    return backtrack(pattern, 0, s, 0, patternMap, words);
}

private boolean backtrack(String pattern, int pIndex, String s, int sIndex, Map<Character, String> patternMap, Set<String> words) {
    if (pIndex == pattern.length() && sIndex == s.length()) return true;
    if (pIndex == pattern.length() || sIndex == s.length()) return false;

    char p = pattern.charAt(pIndex);
    if (patternMap.containsKey(p)) {
        String word = patternMap.get(p);
        if (!s.startsWith(word, sIndex)) return false;
        return backtrack(pattern, pIndex + 1, s, sIndex + word.length(), patternMap, words);
    } else {
        for (int length = 1; length <= s.length() - sIndex; length++) {
            String word = s.substring(sIndex, sIndex + length);
            if (words.contains(word)) continue;
            patternMap.put(p, word);
            words.add(word);
            if (backtrack(pattern, pIndex + 1, s, sIndex + length, patternMap, words)) return true;
            patternMap.remove(p);
            words.remove(word);
        }
    }
    return false;
}

-----
public boolean wordPatternMatch(String pattern, String s) 
    // Your code here
}

************************************
Question ID: 292

public boolean canWinNim(int n) {
    return n % 4 != 0;
}

-----
public boolean canWinNim(int n) 
    // Your code here
}

************************************
Question ID: 293

import java.util.ArrayList;
import java.util.List;

public List<String> generatePossibleNextMoves(String currentState) {
    List<String> result = new ArrayList<>();
    for (int i = 1; i < currentState.length(); i++) {
        if (currentState.charAt(i) == '+' && currentState.charAt(i - 1) == '+') {
            result.add(currentState.substring(0, i - 1) + "--" + currentState.substring(i + 1));
        }
    }
    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<String> generatePossibleNextMoves(String currentState) 
    // Your code here
}

************************************
Question ID: 294

public boolean canWin(String currentState) {
    for (int i = 0; i < currentState.length() - 1; ++i) {
        if (currentState.charAt(i) == '+' && currentState.charAt(i + 1) == '+') {
            String temp = currentState.substring(0, i) + "--" + currentState.substring(i + 2);
            if (!canWin(temp)) return true;
        }
    }
    return false;
}

-----
public boolean canWin(String currentState) 
    // Your code here
}

************************************
Question ID: 295

import java.util.*;

class MedianFinder {
    PriorityQueue<Integer> left;
    PriorityQueue<Integer> right;

    public MedianFinder() {
        left = new PriorityQueue<>((a, b) -> b.compareTo(a));
        right = new PriorityQueue<>();
    }
    
    public void addNum(int num) {
        if (left.isEmpty() || num <= left.peek()) {
            left.offer(num);
        } else {
            right.offer(num);
        }
        
        if (left.size() < right.size()) {
            left.offer(right.poll());
        } else if (left.size() > right.size() + 1) {
            right.offer(left.poll());
        }
    }
    
    public double findMedian() {
        if (left.size() == right.size()) {
            return (left.peek() + right.peek()) / 2.0;
        } else {
            return left.peek();
        }
    }
}


-----
import java.util.*;

class MedianFinder 
    // Your code here
}


************************************
Question ID: 296

public int minTotalDistance(int[][] grid) {
    List<Integer> rows = new ArrayList<Integer>();
    List<Integer> cols = new ArrayList<Integer>();
    int m = grid.length, n = grid[0].length;
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (grid[i][j] == 1) {
                rows.add(i);
                cols.add(j);
            }
        }
    }
    Collections.sort(cols);
    int row_median = rows.get(rows.size() / 2), col_median = cols.get(cols.size() / 2);
    int distance = 0;
    for (int i : rows) distance += Math.abs(i - row_median);
    for (int j : cols) distance += Math.abs(j - col_median);
    return distance;
}

-----
public int minTotalDistance(int[][] grid) 
    // Your code here
}

************************************
Question ID: 299

public String getHint(String secret, String guess) {
    int bulls = 0, cows = 0;
    int[] secretCount = new int[10];
    int[] guessCount = new int[10];

    for (int i = 0; i < secret.length(); i++) {
        if (secret.charAt(i) == guess.charAt(i)) {
            bulls++;
        } else {
            secretCount[secret.charAt(i) - '0']++;
            guessCount[guess.charAt(i) - '0']++;
        }
    }

    for (int i = 0; i < 10; i++) {
        cows += Math.min(secretCount[i], guessCount[i]);
    }

    return bulls + "A" + cows + "B";
}


-----
public String getHint(String secret, String guess) 
    // Your code here
}


************************************
Question ID: 300

public int lengthOfLIS(int[] nums) {
    int[] dp = new int[nums.length];
    int max_length = 1;
    Arrays.fill(dp, 1);
    for (int i = 1; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
        max_length = Math.max(max_length, dp[i]);
    }
    return max_length;
}

-----
public int lengthOfLIS(int[] nums) 
    // Your code here
}

************************************
Question ID: 301

import java.util.*;

class Solution {
    public List<String> removeInvalidParentheses(String s) {
        Set<String> visited = new HashSet<>();
        Queue<String> queue = new LinkedList<>();
        List<String> result = new ArrayList<>();
        boolean found = false;

        visited.add(s);
        queue.offer(s);

        while (!queue.isEmpty()) {
            String current = queue.poll();

            if (isValid(current)) {
                found = true;
                result.add(current);
            }

            if (found) continue;

            for (int i = 0; i < current.length(); i++) {
                if (current.charAt(i) == '(' || current.charAt(i) == ')') {
                    String next = current.substring(0, i) + current.substring(i + 1);
                    if (!visited.contains(next)) {
                        visited.add(next);
                        queue.offer(next);
                    }
                }
            }
        }
        return result;
    }

    private boolean isValid(String s) {
        int count = 0;
        for (char c : s.toCharArray()) {
            if (c == '(') count++;
            if (c == ')') count--;
            if (count < 0) return false;
        }
        return count == 0;
    }
}


-----
import java.util.*;

class Solution 
    // Your code here
}


************************************
Question ID: 302

public int minArea(char[][] image, int x, int y) {
    int top = x, bottom = x, left = y, right = y;
    for (int i = 0; i < image.length; ++i) {
        for (int j = 0; j < image[i].length; ++j) {
            if (image[i][j] == '1') {
                top = Math.min(top, i);
                bottom = Math.max(bottom, i);
                left = Math.min(left, j);
                right = Math.max(right, j);
            }
        }
    }
    return (bottom - top + 1) * (right - left + 1);
}

-----
public int minArea(char[][] image, int x, int y) 
    // Your code here
}

************************************
Question ID: 305

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<Integer> numIslands2(int m, int n, int[][] positions) {
    int[] roots = new int[m * n];
    Arrays.fill(roots, -1);
    int[][] dirs = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};
    int islandCount = 0;
    List<Integer> result = new ArrayList<>();

    for (int[] position : positions) {
        int i = position[0], j = position[1], index = i * n + j;
        if (roots[index] != -1) {
            result.add(islandCount);
            continue;
        }
        islandCount++;
        roots[index] = index;
        for (int[] dir : dirs) {
            int ni = i + dir[0], nj = j + dir[1], neighbor = ni * n + nj;
            if (ni >= 0 && ni < m && nj >= 0 && nj < n && roots[neighbor] != -1) {
                int rootNb = find(roots, neighbor);
                if (index != rootNb) {
                    roots[rootNb] = index;
                    islandCount--;
                }
            }
        }
        result.add(islandCount);
    }
    return result;
}

private int find(int[] roots, int x) {
    if (roots[x] != x) roots[x] = find(roots, roots[x]);
    return roots[x];
}


-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<Integer> numIslands2(int m, int n, int[][] positions) 
    // Your code here
}


************************************
Question ID: 306

public boolean isAdditiveNumber(String num) {
    for (int i = 1; i <= num.length() / 2; i++) {
        for (int j = 1; j <= (num.length() - i) / 2; j++) {
            if (check(num.substring(0, i), num.substring(i, i + j), num.substring(i + j))) {
                return true;
            }
        }
    }
    return false;
}

private boolean check(String num1, String num2, String remaining) {
    if ((num1.length() > 1 && num1.charAt(0) == '0') || (num2.length() > 1 && num2.charAt(0) == '0')) {
        return false;
    }
    String sum = add(num1, num2);
    if (remaining.equals(sum)) {
        return true;
    }
    if (!remaining.startsWith(sum)) {
        return false;
    }
    return check(num2, sum, remaining.substring(sum.length()));
}

private String add(String num1, String num2) {
    int carry = 0;
    StringBuilder result = new StringBuilder();
    for (int i = num1.length() - 1, j = num2.length() - 1;
         i >= 0 || j >= 0 || carry > 0; i--, j--) {
        int n1 = i >= 0 ? num1.charAt(i) - '0' : 0;
        int n2 = j >= 0 ? num2.charAt(j) - '0' : 0;
        int sum = n1 + n2 + carry;
        carry = sum / 10;
        result.append((char) ('0' + sum % 10));
    }
    return result.reverse().toString();
}

-----
public boolean isAdditiveNumber(String num) 
    // Your code here
}

************************************
Question ID: 309

public int maxProfit(int[] prices) {
    int profit = 0;
    for (int i = 1; i < prices.length; i++) {
        profit += Math.max(prices[i] - prices[i - 1], 0);
    }
    return profit;
}

-----
public int maxProfit(int[] prices) 
    // Your code here
}

************************************
Question ID: 310

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public List<Integer> findMinHeightTrees(int n, int[][] edges) {
    if (n == 1) {
        List<Integer> result = new ArrayList<>();
        result.add(0);
        return result;
    }

    int[] degrees = new int[n];
    List<List<Integer>> adjList = new ArrayList<>(n);
    for (int i = 0; i < n; i++) {
        adjList.add(new ArrayList<>());
    }

    for (int[] edge : edges) {
        adjList.get(edge[0]).add(edge[1]);
        adjList.get(edge[1]).add(edge[0]);
        degrees[edge[0]]++;
        degrees[edge[1]]++;
    }

    Queue<Integer> queue = new LinkedList<>();
    for (int i = 0; i < n; i++) {
        if (degrees[i] == 1) queue.add(i);
    }

    while (n > 2) {
        int leavesSize = queue.size();
        n -= leavesSize;
        for (int i = 0; i < leavesSize; i++) {
            int leaf = queue.poll();
            for (int neighbor : adjList.get(leaf)) {
                if (--degrees[neighbor] == 1) queue.add(neighbor);
            }
        }
    }

    return new ArrayList<>(queue);
}

-----
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public List<Integer> findMinHeightTrees(int n, int[][] edges) 
    // Your code here
}

************************************
Question ID: 311

public int[][] multiply(int[][] mat1, int[][] mat2) {
    int m = mat1.length;
    int k = mat1[0].length;
    int n = mat2[0].length;
    int[][] result = new int[m][n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < k; j++) {
            if (mat1[i][j] != 0) {
                for (int l = 0; l < n; l++) {
                    result[i][l] += mat1[i][j] * mat2[j][l];
                }
            }
        }
    }
    return result;
}

-----
public int[][] multiply(int[][] mat1, int[][] mat2) 
    // Your code here
}

************************************
Question ID: 312

public int maxCoins(int[] nums) {
    int n = nums.length;
    int[] newNums = new int[n + 2];
    newNums[0] = 1;
    newNums[n + 1] = 1;
    for (int i = 1; i <= n; i++) {
        newNums[i] = nums[i - 1];
    }

    int[][] dp = new int[n + 2][n + 2];
    for (int len = 1; len <= n; len++) {
        for (int left = 1; left <= n - len + 1; left++) {
            int right = left + len - 1;
            for (int i = left; i <= right; i++) {
                dp[left][right] = Math.max(dp[left][right], newNums[left - 1] * newNums[i] * newNums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);
            }
        }
    }

    return dp[1][n];
}

-----
public int maxCoins(int[] nums) 
    // Your code here
}

************************************
Question ID: 313

public int nthSuperUglyNumber(int n, int[] primes) {
    int[] ugly = new int[n];
    ugly[0] = 1;
    int[] indices = new int[primes.length];

    for (int i = 1; i < n; i++) {
        int minVal = Integer.MAX_VALUE;

        for (int j = 0; j < primes.length; j++)
            minVal = Math.min(minVal, ugly[indices[j]] * primes[j]);

        ugly[i] = minVal;

        for (int j = 0; j < primes.length; j++)
            if (ugly[i] == ugly[indices[j]] * primes[j])
                indices[j]++;
    }

    return ugly[n - 1];
}

-----
public int nthSuperUglyNumber(int n, int[] primes) 
    // Your code here
}

************************************
Question ID: 314

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    public List<List<Integer>> verticalOrder(TreeNode root) {
        if (root == null) return new ArrayList<>();

        HashMap<Integer, List<Integer>> columnTable = new HashMap<>();
        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();
        q.offer(new Pair<>(root, 0));

        while (!q.isEmpty()) {
            TreeNode curNode = q.peek().getKey();
            int column = q.peek().getValue();
            q.poll();

            if (curNode != null) {
                columnTable.putIfAbsent(column, new ArrayList<>());
                columnTable.get(column).add(curNode.val);
                q.offer(new Pair<>(curNode.left, column - 1));
                q.offer(new Pair<>(curNode.right, column + 1));
            }
        }

        return new ArrayList<>(columnTable.values());
    }
}

-----
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class TreeNode 
    // Your code here
}

************************************
Question ID: 315

import java.util.List;
import java.util.ArrayList;

public List<Integer> countSmaller(int[] nums) {
    int n = nums.length;
    int[] indices = new int[n];
    int[] counts = new int[n];
    
    for (int i = 0; i < n; i++) {
        indices[i] = i;
    }
    
    mergeSort(nums, indices, counts, 0, n - 1);
    List<Integer> result = new ArrayList<>();
    for (int count : counts) {
        result.add(count);
    }
    return result;
}

private void mergeSort(int[] nums, int[] indices, int[] counts, int left, int right) {
    if (left >= right) {
        return;
    }
    
    int mid = left + (right - left) / 2;
    mergeSort(nums, indices, counts, left, mid);
    mergeSort(nums, indices, counts, mid + 1, right);
    
    int[] temp = new int[right - left + 1];
    int i = left, j = mid + 1, k = 0;
    while (i <= mid && j <= right) {
        if (nums[indices[i]] <= nums[indices[j]]) {
            counts[indices[i]] += j - mid - 1;
            temp[k++] = indices[i++];
        } else {
            temp[k++] = indices[j++];
        }
    }
    
    while (i <= mid) {
        counts[indices[i]] += j - mid - 1;
        temp[k++] = indices[i++];
    }
    
    while (j <= right) {
        temp[k++] = indices[j++];
    }
    
    System.arraycopy(temp, 0, indices, left, right - left + 1);
}

-----
import java.util.List;
import java.util.ArrayList;

public List<Integer> countSmaller(int[] nums) 
    // Your code here
}

************************************
Question ID: 316

import java.util.*;

public class Solution {
    public String removeDuplicateLetters(String s) {
        int[] count = new int[256];
        boolean[] visited = new boolean[256];
        Stack<Character> st = new Stack<>();
        
        for (char ch : s.toCharArray()) {
            count[ch]++;
        }
        
        for (char ch : s.toCharArray()) {
            count[ch]--;
            if (visited[ch]) continue;
            while (!st.isEmpty() && ch < st.peek() && count[st.peek()] > 0) {
                visited[st.pop()] = false;
            }
            st.push(ch);
            visited[ch] = true;
        }
        
        StringBuilder result = new StringBuilder();
        while (!st.empty()) {
            result.append(st.pop());
        }
        return result.reverse().toString();
    }
}

-----
import java.util.*;

public class Solution 
    // Your code here
}

************************************
Question ID: 317

import java.util.LinkedList;
import java.util.Queue;

public int shortestDistance(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    
    int[][] total_count = new int[m][n];
    int[][] dist_sum = new int[m][n];
    int house_count = 0;
    
    int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 1) {
                house_count++;
                Queue<int[]> q = new LinkedList<>();
                q.offer(new int[]{i, j});
                boolean[][] visited = new boolean[m][n];
                int level = 1;
                while (!q.isEmpty()) {
                    int sz = q.size();
                    for (int q_i = 0; q_i < sz; q_i++) {
                        int[] cur = q.poll();
                        int x = cur[0];
                        int y = cur[1];
                        for (int[] dir : dirs) {
                            int x_new = x + dir[0];
                            int y_new = y + dir[1];
                            if (x_new >= 0 && x_new < m && y_new >= 0 && y_new < n && !visited[x_new][y_new] && grid[x_new][y_new] == 0) {
                                visited[x_new][y_new] = true;
                                q.offer(new int[]{x_new, y_new});
                                dist_sum[x_new][y_new] += level;
                                total_count[x_new][y_new]++;
                            }
                        }
                    }
                    level++;
                }
            }
        }
    }
                                         
    int min_dist = Integer.MAX_VALUE;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (total_count[i][j] == house_count) {
                min_dist = Math.min(min_dist, dist_sum[i][j]);
            }
        }
    }
    
    return min_dist == Integer.MAX_VALUE ? -1 : min_dist;
}


-----
import java.util.LinkedList;
import java.util.Queue;

public int shortestDistance(int[][] grid) 
    // Your code here
}


************************************
Question ID: 318

import java.util.*;

class Solution {
    public int maxProduct(String[] words) {
        int n = words.length;
        int[] mask = new int[n];
        for (int i = 0; i < n; i++) {
            for (char c : words[i].toCharArray()) {
                mask[i] |= (1 << (c - 'a'));
            }
        }

        int maxProduct = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if ((mask[i] & mask[j]) == 0) {
                    maxProduct = Math.max(maxProduct, words[i].length() * words[j].length());
                }
            }
        }

        return maxProduct;
    }
}


-----
import java.util.*;

class Solution 
    // Your code here
}


************************************
Question ID: 319

public int bulbSwitch(int n) {
    return (int)Math.sqrt(n);
}

-----
public int bulbSwitch(int n) 
    // Your code here
}

************************************
Question ID: 320

import java.util.ArrayList;
import java.util.List;

public List<String> generateAbbreviations(String word) {
    List<String> res = new ArrayList<>();
    res.add(word.isEmpty() ? "" : Integer.toString(word.length()));
    for (int i = 0; i < word.length(); ++i) {
        String pre = word.substring(0, i);
        for (String abbr : generateAbbreviations(word.substring(i + 1))) {
            int num = abbr.chars().findFirst_NEG_INT().getAsInt();
            if (abbr.isEmpty() || num > 0) {
                res.add(pre + '1' + abbr);
            }
            if (i == 0 || abbr.isEmpty() || abbr.charAt(0) > '9') {
                res.add(word.substring(0, i + 1) + abbr);
            }
        }
    }
    return res;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<String> generateAbbreviations(String word) 
    // Your code here
}

************************************
Question ID: 321


```java
public int[] maxNumber(int[] nums1, int[] nums2, int k) {
    int[] ans = new int[k];
    int m = nums1.length, n = nums2.length;
    
    for (int i = Math.max(0, k - n); i <= k && i <= m; i++) {
        int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);
        if (greater(candidate, 0, ans, 0)) ans = candidate;
    }
    return ans;
}

private int[] maxArray(int[] nums, int k) {
    int n = nums.length;
    int[] ans = new int[k];
    for (int i = 0, j = 0; i < n; i++) {
        while (n - i > k - j && j > 0 && ans[j - 1] < nums[i]) j--;
        if (j < k) ans[j++] = nums[i];
    }
    return ans;
}

private int[] merge(int[] nums1, int[] nums2, int k) {
    int[] ans = new int[k];
    for (int i = 0, j = 0, r = 0; r < k; r++)
        ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];
    return ans;
}

private boolean greater(int[] nums1, int i, int[] nums2, int j) {
    while (i < nums1.length && j < nums2.length && nums1[i] == nums2[j]) {
        i++;
        j++;
    }
    return j == nums2.length || (i < nums1.length && nums1[i] > nums2[j]);
}
```


-----

```java
public int[] maxNumber(int[] nums1, int[] nums2, int k) 
    // Your code here
}
```


************************************
Question ID: 322

public int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, amount + 1);
    dp[0] = 0;
    
    for (int coin : coins) {
        for (int i = coin; i <= amount; i++) {
            dp[i] = Math.min(dp[i], dp[i - coin] + 1);
        }
    }

    return dp[amount] <= amount ? dp[amount] : -1;
}

-----
public int coinChange(int[] coins, int amount) 
    // Your code here
}

************************************
Question ID: 323

import java.util.ArrayList;
import java.util.List;

public int countComponents(int n, int[][] edges) {
    List<List<Integer>> adjList = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        adjList.add(new ArrayList<>());
    }
    for (int[] edge : edges) {
        adjList.get(edge[0]).add(edge[1]);
        adjList.get(edge[1]).add(edge[0]);
    }

    boolean[] visited = new boolean[n];
    int connectedComponents = 0;

    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            dfs(i, visited, adjList);
            connectedComponents++;
        }
    }
    return connectedComponents;
}

void dfs(int node, boolean[] visited, List<List<Integer>> adjList) {
    visited[node] = true;
    for (int neighbor : adjList.get(node)) {
        if (!visited[neighbor]) {
            dfs(neighbor, visited, adjList);
        }
    }
}


-----
import java.util.ArrayList;
import java.util.List;

public int countComponents(int n, int[][] edges) 
    // Your code here
}


************************************
Question ID: 324

import java.util.Arrays;
public void wiggleSort(int[] nums) {
    Arrays.sort(nums);
    for (int i = 1; i < nums.length - 1; i += 2) {
        int temp = nums[i];
        nums[i] = nums[i + 1];
        nums[i + 1] = temp;
    }
}


-----
import java.util.Arrays;
public void wiggleSort(int[] nums) 
    // Your code here
}


************************************
Question ID: 325

public int maxSubArrayLen(int[] nums, int k) {
    Map<Integer, Integer> sumIndex = new HashMap<>();
    int maxLength = 0, sum = 0;
    for(int i = 0; i < nums.length; i++) {
        sum += nums[i];
        if (sum == k) maxLength = i + 1;
        if (sumIndex.containsKey(sum - k)) maxLength = Math.max(maxLength, i - sumIndex.get(sum - k));
        if (!sumIndex.containsKey(sum)) sumIndex.put(sum, i);
    }
    return maxLength;
}


-----
public int maxSubArrayLen(int[] nums, int k) 
    // Your code here
}


************************************
Question ID: 326

public boolean isPowerOfThree(int n) {
    if (n < 1) {
        return false;
    }
    
    while (n % 3 == 0) {
        n /= 3;
    }
    
    return n == 1;
}

-----
public boolean isPowerOfThree(int n) 
    // Your code here
}

************************************
Question ID: 327

public int countRangeSum(int[] nums, int lower, int upper) {
    long[] sums = new long[nums.length + 1];
    for (int i = 0; i < nums.length; ++i)
        sums[i + 1] = sums[i] + nums[i];

    return countWhileMergeSort(sums, lower, upper, 0, nums.length);
}

private int countWhileMergeSort(long[] sums, int lower, int upper, int start, int end) {
    if (start >= end)
        return 0;

    int mid = start + (end - start) / 2;
    int count = countWhileMergeSort(sums, lower, upper, start, mid) + countWhileMergeSort(sums, lower, upper, mid + 1, end);

    int j = mid + 1, k = mid + 1;
    for (int i = start; i <= mid; ++i) {
        while (j <= end && sums[j] - sums[i] < lower) ++j;
        while (k <= end && sums[k] - sums[i] <= upper) ++k;
        count += k - j;
    }

    Arrays.sort(sums, start, end + 1);
    return count;
}

-----
public int countRangeSum(int[] nums, int lower, int upper) 
    // Your code here
}

************************************
Question ID: 329

int[] dx = {0, 0, 1, -1};
int[] dy = {1, -1, 0, 0};

public int dfs(int[][] matrix, int[][] memo, int i, int j) {
    if (memo[i][j] != 0) return memo[i][j];
    
    int max_len = 0;
    for (int k = 0; k < 4; ++k) {
        int ni = i + dx[k], nj = j + dy[k];
        if (ni >= 0 && ni < matrix.length && nj >= 0 && nj < matrix[0].length && matrix[ni][nj] > matrix[i][j]) {
            max_len = Math.max(max_len, dfs(matrix, memo, ni, nj));
        }
    }
    
    memo[i][j] = max_len + 1;
    return memo[i][j];
}

public int longestIncreasingPath(int[][] matrix) {
    int m = matrix.length, n = matrix[0].length;
    
    int[][] memo = new int[m][n];
    
    int ans = 0;
    for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j)
            ans = Math.max(ans, dfs(matrix, memo, i, j));
    
    return ans;
}


-----
int[] dx = 
    // Your code here
}


************************************
Question ID: 330

public int minPatches(int[] nums, int n) {
    long maxSum = 0;
    int patches = 0, i = 0;
    
    while (maxSum < n) {
        if (i < nums.length && nums[i] <= maxSum + 1) {
            maxSum += nums[i];
            i++;
        } else {
            maxSum += maxSum + 1;
            patches++;
        }
    }
    return patches;
}

-----
public int minPatches(int[] nums, int n) 
    // Your code here
}

************************************
Question ID: 331

public boolean isValidSerialization(String preorder) {
    String[] nodes = preorder.split(",");
    int node_count = 1;

    for (String node : nodes) {
        node_count--;

        if (node_count < 0) return false;
        if (!node.equals("#")) node_count += 2;
    }

    return node_count == 0;
}

-----
public boolean isValidSerialization(String preorder) 
    // Your code here
}

************************************
Question ID: 332

import java.util.*;

class Solution {
    public List<String> findItinerary(List<List<String>> tickets) {
        HashMap<String, PriorityQueue<String>> flights = new HashMap<>();
        LinkedList<String> itinerary = new LinkedList<>();
        
        for (List<String> ticket : tickets) {
            flights.putIfAbsent(ticket.get(0), new PriorityQueue<>());
            flights.get(ticket.get(0)).offer(ticket.get(1));
        }
        
        Stack<String> dfs = new Stack<>();
        dfs.push("JFK");
        
        while (!dfs.isEmpty()) {
            String nextAirport = dfs.peek();
            if (flights.get(nextAirport) == null || flights.get(nextAirport).isEmpty()) {
                itinerary.addFirst(dfs.pop());
            } else {
                dfs.push(flights.get(nextAirport).poll());
            }
        }
        
        return itinerary;
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 334

public boolean findTriplets(int[] nums) {
    int first = Integer.MAX_VALUE;
    int second = Integer.MAX_VALUE;

    for (int num : nums) {
        if (num <= first) {
            first = num;
        } else if (num <= second) {
            second = num;
        } else {
            return true;
        }
    }
    return false;
}

-----
public boolean findTriplets(int[] nums) 
    // Your code here
}

************************************
Question ID: 335

public boolean isPathCrossing(int[] distance) {
    Set<Pair<Integer, Integer>> visited = new HashSet<>();
    int x = 0, y = 0;
    visited.add(new Pair<>(x, y));
    int[] dx = {0, -1, 0, 1};
    int[] dy = {1, 0, -1, 0};
    
    for (int i = 0; i < distance.length; i++) {
        int direction = i % 4;
        for (int j = 0; j < distance[i]; j++) {
            x += dx[direction];
            y += dy[direction];
            Pair<Integer, Integer> point = new Pair<>(x, y);
            if (!visited.add(point)) {
                return true;
            }
        }
    }
    return false;
}


-----
public boolean isPathCrossing(int[] distance) 
    // Your code here
}


************************************
Question ID: 336

import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> palindromePairs(String[] words) {
    List<List<Integer>> result = new ArrayList<>();

    for (int i = 0; i < words.length; i++) {
        for (int j = 0; j < words.length; j++) {
            if (i == j) continue;
            String concat = words[i] + words[j];

            boolean isPalindrome = true;
            for (int left = 0, right = concat.length() - 1; left < right; left++, right--) {
                if (concat.charAt(left) != concat.charAt(right)) {
                    isPalindrome = false;
                    break;
                }
            }

            if (isPalindrome) {
                List<Integer> pair = new ArrayList<>();
                pair.add(i);
                pair.add(j);
                result.add(pair);
            }
        }
    }

    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> palindromePairs(String[] words) 
    // Your code here
}

************************************
Question ID: 337

public int rob(TreeNode root) {
    int[] result = robHelper(root);
    return Math.max(result[0], result[1]);
}

private int[] robHelper(TreeNode node) {
    if (node == null) return new int[2];

    int[] left = robHelper(node.left);
    int[] right = robHelper(node.right);
    int[] result = new int[2];

    result[0] = node.val + left[1] + right[1];
    result[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
    return result;
}

-----
public int rob(TreeNode root) 
    // Your code here
}

************************************
Question ID: 338

public int[] countBits(int n) {
    int[] ans = new int[n + 1];
    for (int i = 1; i <= n; ++i) {
        ans[i] = ans[i & (i - 1)] + 1;
    }
    return ans;
}

-----
public int[] countBits(int n) 
    // Your code here
}

************************************
Question ID: 339

import java.util.List;

public int depthSum(List<?> nestedList) {
    return depthSumHelper(nestedList, 1);
}

private int depthSumHelper(List<?> nestedList, int depth) {
    int sum = 0;
    for (Object element : nestedList) {
        if (element instanceof Integer) {
            sum += (int) element * depth;
        } else {
            sum += depthSumHelper((List<?>) element, depth + 1);
        }
    }
    return sum;
}


-----
import java.util.List;

public int depthSum(List<?> nestedList) 
    // Your code here
}


************************************
Question ID: 340

import java.util.HashMap;

public int lengthOfLongestSubstringKDistinct(String s, int k) {
    HashMap<Character, Integer> charCount = new HashMap<>();
    int left = 0, maxLength = 0;

    for (int right = 0; right < s.length(); ++right) {
        charCount.put(s.charAt(right), charCount.getOrDefault(s.charAt(right), 0) + 1);

        while (charCount.size() > k) {
            charCount.put(s.charAt(left), charCount.get(s.charAt(left)) - 1);
            if (charCount.get(s.charAt(left)) == 0) {
                charCount.remove(s.charAt(left));
            }
            left++;
        }

        maxLength = Math.max(maxLength, right - left + 1);
    }
    return maxLength;
}

-----
import java.util.HashMap;

public int lengthOfLongestSubstringKDistinct(String s, int k) 
    // Your code here
}

************************************
Question ID: 342

public boolean isPowerOfFour(int n) {
    if (n <= 0) return false;
    while (n % 4 == 0) {
        n /= 4;
    }
    return n == 1;
}

-----
public boolean isPowerOfFour(int n) 
    // Your code here
}

************************************
Question ID: 343

public int integerBreak(int n) {
    if (n <= 3) return n - 1;
    int product = 1;
    while (n > 4) {
        product *= 3;
        n -= 3;
    }
    return product * n;
}

-----
public int integerBreak(int n) 
    // Your code here
}

************************************
Question ID: 344

public void reverseString(char[] s) {
    int left = 0, right = s.length - 1;
    while (left < right) {
        char temp = s[left];
        s[left++] = s[right];
        s[right--] = temp;
    }
}

-----
public void reverseString(char[] s) 
    // Your code here
}

************************************
Question ID: 345

import java.util.HashSet;
import java.util.Set;

public String reverseVowels(String s) {
    int i = 0, j = s.length() - 1;
    char[] result = new char[s.length()];
    Set<Character> vowels = new HashSet<>();
    for (char c : "aeiouAEIOU".toCharArray()) {
        vowels.add(c);
    }
    while (i <= j) {
        char ci = s.charAt(i);
        char cj = s.charAt(j);
        if (!vowels.contains(ci)) {
            result[i++] = ci;
        } else if (!vowels.contains(cj)) {
            result[j--] = cj;
        } else {
            result[i++] = cj;
            result[j--] = ci;
        }
    }
    return new String(result);
}

-----
import java.util.HashSet;
import java.util.Set;

public String reverseVowels(String s) 
    // Your code here
}

************************************
Question ID: 346

import java.util.LinkedList;
import java.util.Queue;

class MovingAverage {
    private Queue<Integer> queue;
    private int maxSize;
    private double sum;

    public MovingAverage(int size) {
        queue = new LinkedList<>();
        maxSize = size;
        sum = 0.0;
    }

    public double next(int val) {
        if (queue.size() == maxSize) {
            sum -= queue.remove();
        }
        queue.add(val);
        sum += val;
        return sum / queue.size();
    }
}

-----
import java.util.LinkedList;
import java.util.Queue;

class MovingAverage 
    // Your code here
}

************************************
Question ID: 347

import java.util.*;

public List<Integer> kMostFrequent(int[] nums, int k) {
    Map<Integer, Integer> frequency = new HashMap<>();
    for (int num : nums) {
        frequency.put(num, frequency.getOrDefault(num, 0) + 1);
    }

    PriorityQueue<Map.Entry<Integer, Integer>> min_heap = new PriorityQueue<>(Comparator.comparingInt(Map.Entry::getValue));
    for (Map.Entry<Integer, Integer> entry : frequency.entrySet()) {
        min_heap.offer(entry);
        if (min_heap.size() > k) {
            min_heap.poll();
        }
    }

    List<Integer> result = new ArrayList<>();
    while (!min_heap.isEmpty()) {
        result.add(min_heap.poll().getKey());
    }
    return result;
}


-----
import java.util.*;

public List<Integer> kMostFrequent(int[] nums, int k) 
    // Your code here
}


************************************
Question ID: 349

import java.util.HashSet;
import java.util.Set;

public int[] intersection(int[] nums1, int[] nums2) {
    Set<Integer> set1 = new HashSet<>();
    for (int num : nums1) {
        set1.add(num);
    }
    
    Set<Integer> resultSet = new HashSet<>();
    for (int num : nums2) {
        if (set1.contains(num)) {
            resultSet.add(num);
        }
    }
    
    int[] result = new int[resultSet.size()];
    int i = 0;
    for (int num : resultSet) {
        result[i++] = num;
    }
    return result;
}

-----
import java.util.HashSet;
import java.util.Set;

public int[] intersection(int[] nums1, int[] nums2) 
    // Your code here
}

************************************
Question ID: 350

import java.util.ArrayList;
import java.util.HashMap;

public int[] intersect(int[] nums1, int[] nums2) {
    HashMap<Integer, Integer> countMap = new HashMap<>();
    ArrayList<Integer> result = new ArrayList<>();
    
    for (int num : nums1) {
        countMap.put(num, countMap.getOrDefault(num, 0) + 1);
    }
    
    for (int num : nums2) {
        if (countMap.getOrDefault(num, 0) > 0) {
            result.add(num);
            countMap.put(num, countMap.get(num) - 1);
        }
    }

    return result.stream().mapToInt(i -> i).toArray();
}


-----
import java.util.ArrayList;
import java.util.HashMap;

public int[] intersect(int[] nums1, int[] nums2) 
    // Your code here
}


************************************
Question ID: 351

public int numberOfPatterns(int m, int n) {
    int[][] jumps = new int[10][10];
    jumps[1][3] = jumps[3][1] = 2;
    jumps[1][7] = jumps[7][1] = 4;
    jumps[3][9] = jumps[9][3] = 6;
    jumps[7][9] = jumps[9][7] = 8;
    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5;

    boolean[] visited = new boolean[10];

    int cnt = 0;
    for (int i = m; i <= n; ++i) {
        cnt += dfs(jumps, visited, 1, i - 1) * 4; // 1, 3, 7, 9
        cnt += dfs(jumps, visited, 2, i - 1) * 4; // 2, 4, 6, 8
        cnt += dfs(jumps, visited, 5, i - 1);     // 5
    }

    return cnt;
}

private int dfs(int[][] jumps, boolean[] visited, int curr, int remaining) {
    if (remaining < 0) return 0;
    if (remaining == 0) return 1;

    visited[curr] = true;
    int cnt = 0;
    for (int next = 1; next <= 9; ++next) {
        if (!visited[next] && (jumps[curr][next] == 0 || visited[jumps[curr][next]])) {
            cnt += dfs(jumps, visited, next, remaining - 1);
        }
    }
    visited[curr] = false;

    return cnt;
}


-----
public int numberOfPatterns(int m, int n) 
    // Your code here
}


************************************
Question ID: 352

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

public class SummaryRanges {

    private TreeMap<Integer, Integer> intervals = new TreeMap<>();

    public void addNum(int val) {
        if (intervals.isEmpty() || intervals.firstKey() > val + 1) {
            intervals.put(val, val);
            return;
        }
        Integer lower = intervals.lowerKey(val);
        Integer upper = intervals.higherKey(val);
        if (lower != null && intervals.get(lower) + 1 == val) {
            intervals.put(lower, intervals.get(lower) + 1);

            if (upper != null && val + 1 == upper) {
                intervals.put(lower, intervals.get(upper));
                intervals.remove(upper);
            }
        } else if (upper != null && val + 1 == upper) {
            intervals.put(val, intervals.get(upper));
            intervals.remove(upper);
        } else {
            intervals.put(val, val);
        }
    }

    public List<List<Integer>> getIntervals() {
        List<List<Integer>> result = new ArrayList<>();
        for (Integer key : intervals.keySet()) {
            List<Integer> range = new ArrayList<>();
            range.add(key);
            range.add(intervals.get(key));
            result.add(range);
        }
        return result;
    }
}


-----
import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

public class SummaryRanges 
    // Your code here
}


************************************
Question ID: 353

import java.util.*;

class SnakeGame {
    private int width, height, pos, score;
    private int[][] food;
    private LinkedList<int[]> snake;
    private Set<String> occupied;

    public SnakeGame(int width, int height, int[][] food) {
        this.width = width;
        this.height = height;
        this.food = food;
        pos = 0;
        score = 0;
        snake = new LinkedList<>();
        occupied = new HashSet<>();
        snake.add(new int[]{0, 0});
        occupied.add("0_0");
    }

    public int move(String direction) {
        int newX = snake.peekLast()[0] + dx.get(direction);
        int newY = snake.peekLast()[1] + dy.get(direction);

        if (newX < 0 || newX >= height || newY < 0 || newY >= width) {
            return -1;
        }

        int[] newHead = new int[]{newX, newY};
        int[] tail = snake.poll();

        if (pos < food.length && food[pos][0] == newX && food[pos][1] == newY) {
            score++;
            pos++;
        } else {
            occupied.remove(tail[0] + "_" + tail[1]);
        }

        if (occupied.contains(newX + "_" + newY)) {
            return -1;
        }

        snake.add(newHead);
        occupied.add(newX + "_" + newY);
        return score;
    }

    private static final Map<String, Integer> dx = Map.of("U", -1, "D", 1, "L", 0, "R", 0);
    private static final Map<String, Integer> dy = Map.of("U", 0, "D", 0, "L", -1, "R", 1);
}

-----
import java.util.*;

class SnakeGame 
    // Your code here
}

************************************
Question ID: 354

import java.util.Arrays;
import java.util.Comparator;

public int maxEnvelopes(int[][] envelopes) {
    Arrays.sort(envelopes, new Comparator<int[]>() {
        public int compare(int[] a, int[] b) {
            return a[0] == b[0] ? b[1] - a[1] : a[0] - b[0];
        }
    });

    int[] dp = new int[envelopes.length];
    int len = 0;
    for (int[] envelope : envelopes) {
        int idx = Arrays.binarySearch(dp, 0, len, envelope[1]);
        if (idx < 0) {
            idx = -(idx + 1);
        }
        dp[idx] = envelope[1];
        if (idx == len) {
            len++;
        }
    }

    return len;
}

-----
import java.util.Arrays;
import java.util.Comparator;

public int maxEnvelopes(int[][] envelopes) 
    // Your code here
}

************************************
Question ID: 355

import java.util.*;

class Twitter {
    class Tweet {
        int time;
        int tweetId;

        Tweet(int t, int id) {
            time = t;
            tweetId = id;
        }
    }

    private Map<Integer, List<Tweet>> tweets;
    private Map<Integer, Set<Integer>> following;
    private int timeStamp;

    public Twitter() {
        tweets = new HashMap<>();
        following = new HashMap<>();
        timeStamp = 0;
    }

    public void postTweet(int userId, int tweetId) {
        tweets.putIfAbsent(userId, new ArrayList<>());
        tweets.get(userId).add(new Tweet(timeStamp++, tweetId));
    }

    public List<Integer> getNewsFeed(int userId) {
        List<Tweet> feed = new ArrayList<>();
        if (tweets.containsKey(userId)) {
            feed.addAll(tweets.get(userId));
        }
        if (following.containsKey(userId)) {
            for (int user : following.get(userId)) {
                if (tweets.containsKey(user)) {
                    feed.addAll(tweets.get(user));
                }
            }
        }

        feed.sort((a, b) -> b.time - a.time);

        List<Integer> result = new ArrayList<>();
        for (int i = 0; i < feed.size() && i < 10; ++i) {
            result.add(feed.get(i).tweetId);
        }
        return result;
    }

    public void follow(int followerId, int followeeId) {
        if (followerId != followeeId) {
            following.putIfAbsent(followerId, new HashSet<>());
            following.get(followerId).add(followeeId);
        }
    }

    public void unfollow(int followerId, int followeeId) {
        if (following.containsKey(followerId)) {
            following.get(followerId).remove(followeeId);
        }
    }
}


-----
import java.util.*;

class Twitter 
    // Your code here
}


************************************
Question ID: 356

public boolean isReflected(int[][] points) {
    int minX = Integer.MAX_VALUE;
    int maxX = Integer.MIN_VALUE;
    Set<String> pointSet = new HashSet<>();

    for (int[] point : points) {
        minX = Math.min(minX, point[0]);
        maxX = Math.max(maxX, point[0]);
        pointSet.add(point[0] + "," + point[1]);
    }

    int sum = minX + maxX;
    for (int[] point : points) {
        if (!pointSet.contains((sum - point[0]) + "," + point[1])) {
            return false;
        }
    }

    return true;
}

-----
public boolean isReflected(int[][] points) 
    // Your code here
}

************************************
Question ID: 357

public int countNumbersWithUniqueDigits(int n) {
    if (n == 0) return 1;

    int total = 10;
    int uniqueDigits = 9;
    int currentAvailableDigits = 9;

    while (n-- > 1 && currentAvailableDigits > 0) {
        uniqueDigits *= currentAvailableDigits;
        total += uniqueDigits;
        currentAvailableDigits--;
    }

    return total;
}


-----
public int countNumbersWithUniqueDigits(int n) 
    // Your code here
}


************************************
Question ID: 358

import java.util.*;

public class Solution {
    public String rearrangeString(String s, int k) {
        if (k == 0) return s;

        Map<Character, Integer> freqMap = new HashMap<>();
        for (char c : s.toCharArray()) {
            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);
        }

        PriorityQueue<Map.Entry<Character, Integer>> maxHeap =
                new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());
        maxHeap.addAll(freqMap.entrySet());

        StringBuilder result = new StringBuilder();
        while (!maxHeap.isEmpty()) {
            List<Map.Entry<Character, Integer>> temp = new ArrayList<>();

            for (int i = 0; i < k && !maxHeap.isEmpty(); i++) {
                Map.Entry<Character, Integer> curr = maxHeap.poll();

                result.append(curr.getKey());
                if (curr.getValue() - 1 > 0) {
                    curr.setValue(curr.getValue() - 1);
                    temp.add(curr);
                }
            }

            maxHeap.addAll(temp);

            if (maxHeap.isEmpty()) break;
            if (result.length() < s.length()) {
                int spaces = k - temp.size();
                while (spaces-- > 0) result.append(" ");
            }
        }

        if (result.length() < s.length()) return "";
        return result.toString();
    }
}


-----
import java.util.*;

public class Solution 
    // Your code here
}


************************************
Question ID: 360

public int[] sortTransformedArray(int[] nums, int a, int b, int c) {
    int[] result = new int[nums.length];
    int i = 0, j = nums.length - 1, index = (a >= 0) ? nums.length - 1 : 0;
    
    while (i <= j) {
        int left = nums[i] * nums[i] * a + nums[i] * b + c;
        int right = nums[j] * nums[j] * a + nums[j] * b + c;
        
        if (a >= 0) {
            if (left >= right) {
                result[index--] = left;
                i++;
            } else {
                result[index--] = right;
                j--;
            }
        } else {
            if (left <= right) {
                result[index++] = left;
                i++;
            } else {
                result[index++] = right;
                j--;
            }
        }
    }
    return result;
}

-----
public int[] sortTransformedArray(int[] nums, int a, int b, int c) 
    // Your code here
}

************************************
Question ID: 361

public int maxKilledEnemies(char[][] grid) {
    if (grid.length == 0) return 0;
    int m = grid.length, n = grid[0].length, result = 0, rowhits;
    int[] colhits = new int[n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (j == 0 || grid[i][j-1] == 'W') {
                rowhits = 0;
                for (int k = j; k < n && grid[i][k] != 'W'; k++)
                    rowhits += grid[i][k] == 'E' ? 1 : 0;
            }
            if (i == 0 || grid[i-1][j] == 'W') {
                colhits[j] = 0;
                for (int k = i; k < m && grid[k][j] != 'W'; k++)
                    colhits[j] += grid[k][j] == 'E' ? 1 : 0;
            }
            if (grid[i][j] == '0') result = Math.max(result, rowhits + colhits[j]);
        }
    }
    return result;
}

-----
public int maxKilledEnemies(char[][] grid) 
    // Your code here
}

************************************
Question ID: 362

import java.util.LinkedList;
import java.util.Queue;

public class HitCounter {
    private Queue<Integer> queue;

    public HitCounter() {
        queue = new LinkedList<>();
    }

    public void hit(int timestamp) {
        queue.offer(timestamp);
    }

    public int getHits(int timestamp) {
        while (!queue.isEmpty() && queue.peek() <= (timestamp - 300)) {
            queue.poll();
        }
        return queue.size();
    }
}

-----
import java.util.LinkedList;
import java.util.Queue;

public class HitCounter 
    // Your code here
}

************************************
Question ID: 363

import java.util.TreeSet;

public int maxSumSubmatrix(int[][] matrix, int k) {
    int rows = matrix.length;
    int cols = matrix[0].length;
    int maxSum = Integer.MIN_VALUE;

    for (int l = 0; l < cols; ++l) {
        int[] sums = new int[rows];
        for (int r = l; r < cols; ++r) {
            for (int i = 0; i < rows; ++i) {
                sums[i] += matrix[i][r];
            }

            TreeSet<Integer> sortedSums = new TreeSet<>();
            sortedSums.add(0);
            int currSum = 0;
            for (int sum : sums) {
                currSum += sum;
                Integer it = sortedSums.ceiling(currSum - k);
                if (it != null)
                    maxSum = Math.max(maxSum, currSum - it);
                sortedSums.add(currSum);
            }
        }
    }

    return maxSum;
}


-----
import java.util.TreeSet;

public int maxSumSubmatrix(int[][] matrix, int k) 
    // Your code here
}


************************************
Question ID: 364

import java.util.*;

public int depthSumInverse(List<NestedInteger> nestedList) {
    int maxDepth = maxDepth(nestedList);
    return sumHelper(nestedList, maxDepth);
}

private int maxDepth(List<NestedInteger> nestedList) {
    int depth = 1;
    for (NestedInteger nested : nestedList) {
        if (!nested.isInteger()) {
            depth = Math.max(depth, 1 + maxDepth(nested.getList()));
        }
    }
    return depth;
}

private int sumHelper(List<NestedInteger> nestedList, int depth) {
    int sum = 0;
    for (NestedInteger nested : nestedList) {
        if (nested.isInteger()) {
            sum += depth * nested.getInteger();
        } else {
            sum += sumHelper(nested.getList(), depth - 1);
        }
    }
    return sum;
}

-----
import java.util.*;

public int depthSumInverse(List<NestedInteger> nestedList) 
    // Your code here
}

************************************
Question ID: 365

public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {
    if (targetCapacity > jug1Capacity + jug2Capacity) return false;
    if (jug1Capacity == targetCapacity || jug2Capacity == targetCapacity 
        || jug1Capacity + jug2Capacity == targetCapacity) return true;
    return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0;
}

private int gcd(int a, int b) {
    while (b != 0) {
        int tmp = a % b;
        a = b;
        b = tmp;
    }
    return a;
}


-----
public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) 
    // Your code here
}


************************************
Question ID: 367

boolean isPerfectSquare(int num) {
    if (num < 2) return true;
    long left = 2, right = num / 2, mid, square;
    while (left <= right) {
        mid = left + (right - left) / 2;
        square = mid * mid;
        if (square == num) return true;
        if (square > num) right = mid - 1;
        else left = mid + 1;
    }
    return false;
}

-----
boolean isPerfectSquare(int num) 
    // Your code here
}

************************************
Question ID: 368

import java.util.*;

public List<Integer> largestDivisibleSubset(int[] nums) {
    Arrays.sort(nums);
    int n = nums.length;
    int[] count = new int[n];
    int[] prev = new int[n];
    int max_idx = 0;
    Arrays.fill(prev, -1);
    Arrays.fill(count, 1);

    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] % nums[j] == 0 && count[i] < count[j] + 1) {
                count[i] = count[j] + 1;
                prev[i] = j;
            }
        }
        if (count[max_idx] < count[i]) max_idx = i;
    }

    List<Integer> res = new ArrayList<>();
    for (int i = max_idx; i >= 0; i = prev[i]) {
        res.add(nums[i]);
    }

    return res;
}

-----
import java.util.*;

public List<Integer> largestDivisibleSubset(int[] nums) 
    // Your code here
}

************************************
Question ID: 370

public int[] getUpdatedArray(int length, int[][] updates) {
    int[] arr = new int[length];

    for (int[] update : updates) {
        arr[update[0]] += update[2];
        if (update[1] + 1 < length) {
            arr[update[1] + 1] -= update[2];
        }
    }
    
    for (int i = 1; i < length; i++) {
        arr[i] += arr[i - 1];
    }
    
    return arr;
}

-----
public int[] getUpdatedArray(int length, int[][] updates) 
    // Your code here
}

************************************
Question ID: 371

public int add(int a, int b) {
    while (b != 0) {
        int carry = a & b;
        a = a ^ b;
        b = carry << 1;
    }
    return a;
}

-----
public int add(int a, int b) 
    // Your code here
}

************************************
Question ID: 372

public int powmod(int a, int b) {
    if (b == 0) return 1;
    int res = powmod(a, b / 2);
    if (b % 2 == 0) return res * res % 1337;
    return res * res % 1337 * a % 1337;
}

public int superPow(int a, int[] b) {
    int n = 0;
    for (int bi : b) n = (n * 10 + bi) % 1140;
    return powmod(a % 1337, n + 1140);
}

-----
public int powmod(int a, int b) 
    // Your code here
}

************************************
Question ID: 373

public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {
    PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> (a[0] + a[1]) - (b[0] + b[1]));
    List<int[]> result = new ArrayList<>();

    if (nums1.length == 0 || nums2.length == 0 || k == 0) {
        return result;
    }

    for (int i = 0; i < nums1.length && i < k; i++) {
        minHeap.offer(new int[]{nums1[i], nums2[0], 0});
    }

    while (k-- > 0 && !minHeap.isEmpty()) {
        int[] curr = minHeap.poll();
        result.add(new int[]{curr[0], curr[1]});
        if (curr[2] == nums2.length - 1) {
            continue;
        }
        minHeap.offer(new int[]{curr[0], nums2[curr[2] + 1], curr[2] + 1});
    }

    return result;
}

-----
public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) 
    // Your code here
}

************************************
Question ID: 374

public int guessNumber(int n) {
    int low = 1, high = n;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        int result = guess(mid);
        if (result == 0) {
            return mid;
        } else if (result < 0) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return -1;
}

-----
public int guessNumber(int n) 
    // Your code here
}

************************************
Question ID: 375

public int getMoneyAmount(int n) {
    int[][] dp = new int[n + 1][n + 1];
    for (int i = n - 1; i >= 1; i--) {
        for (int j = i + 1; j <= n; j++) {
            int min_cost = Integer.MAX_VALUE;
            for (int k = i; k < j; k++) {
                int cost = k + Math.max(dp[i][k - 1], dp[k + 1][j]);
                min_cost = Math.min(min_cost, cost);
            }
            dp[i][j] = min_cost;
        }
    }
    return dp[1][n];
}

-----
public int getMoneyAmount(int n) 
    // Your code here
}

************************************
Question ID: 376

public int wiggleMaxLength(int[] nums) {
    int len = nums.length;
    if (len < 2) return len;

    int up = 1, down = 1;
    for (int i = 1; i < len; ++i) {
        if (nums[i] > nums[i - 1])
            up = down + 1;
        else if (nums[i] < nums[i - 1])
            down = up + 1;
    }
    return Math.max(up, down);
}

-----
public int wiggleMaxLength(int[] nums) 
    // Your code here
}

************************************
Question ID: 377

public int combinationSum(int[] nums, int target) {
    int[] dp = new int[target + 1];
    dp[0] = 1;

    for(int num : nums) {
        for(int i = num; i <= target; i++) {
            dp[i] += dp[i - num];
        }
    }

    return dp[target];
}


-----
public int combinationSum(int[] nums, int target) 
    // Your code here
}


************************************
Question ID: 378

import java.util.PriorityQueue;

public int kthSmallest(int[][] matrix, int k) {
    int n = matrix.length;
    PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[0] - b[0]);

    for (int i = 0; i < n; i++) {
        minHeap.offer(new int[]{matrix[i][0], i, 0});
    }

    while (--k > 0) {
        int[] element = minHeap.poll();
        int row = element[1];
        int col = element[2];

        if (col + 1 < n) {
            minHeap.offer(new int[]{matrix[row][col + 1], row, col + 1});
        }
    }

    return minHeap.peek()[0];
}


-----
import java.util.PriorityQueue;

public int kthSmallest(int[][] matrix, int k) 
    // Your code here
}


************************************
Question ID: 379

import java.util.*;

class PhoneDirectory {
    boolean[] available;
    Queue<Integer> released;

    public PhoneDirectory(int maxNumbers) {
        available = new boolean[maxNumbers];
        Arrays.fill(available, true);
        released = new LinkedList<>();
    }
    
    public int get() {
        if (!released.isEmpty()) {
            int number = released.poll();
            available[number] = false;
            return number;
        }
        for (int i = 0; i < available.length; i++) {
            if (available[i]) {
                available[i] = false;
                return i;
            }
        }
        return -1;
    }
    
    public boolean check(int number) {
        return available[number];
    }
    
    public void release(int number) {
        if (!available[number]) {
            available[number] = true;
            released.offer(number);
        }
    }
}


-----
import java.util.*;

class PhoneDirectory 
    // Your code here
}


************************************
Question ID: 380

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;

public class RandomizedSet {
    private Map<Integer, Integer> indexMap;
    private List<Integer> nums;
    private Random rand;

    public RandomizedSet() {
        indexMap = new HashMap<>();
        nums = new ArrayList<>();
        rand = new Random();
    }

    public boolean insert(int val) {
        if (indexMap.containsKey(val)) return false;

        indexMap.put(val, nums.size());
        nums.add(val);
        return true;
    }

    public boolean remove(int val) {
        if (!indexMap.containsKey(val)) return false;

        int last = nums.get(nums.size() - 1);
        indexMap.put(last, indexMap.get(val));
        nums.set(indexMap.get(val), last);

        nums.remove(nums.size() - 1);
        indexMap.remove(val);
        return true;
    }

    public int getRandom() {
        return nums.get(rand.nextInt(nums.size()));
    }
}

-----
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;

public class RandomizedSet 
    // Your code here
}

************************************
Question ID: 381

import java.util.*;

class RandomizedCollection {
    Map<Integer, Set<Integer>> indices;
    List<Integer> nums;

    public RandomizedCollection() {
        indices = new HashMap<>();
        nums = new ArrayList<>();
    }
    
    public boolean insert(int val) {
        nums.add(val);
        indices.putIfAbsent(val, new HashSet<>());
        indices.get(val).add(nums.size() - 1);
        return indices.get(val).size() == 1;
    }
    
    public boolean remove(int val) {
        if (!indices.containsKey(val) || indices.get(val).isEmpty()) return false;
        int idx = indices.get(val).iterator().next();
        indices.get(val).remove(idx);

        if (idx < nums.size() - 1) {
            int last = nums.get(nums.size() - 1);
            nums.set(idx, last);
            indices.get(last).remove(nums.size() - 1);
            indices.get(last).add(idx);
        }
        nums.remove(nums.size() - 1);
        return true;
    }
    
    public int getRandom() {
        int index = (int) (Math.random() * nums.size());
        return nums.get(index);
    }
}


-----
import java.util.*;

class RandomizedCollection 
    // Your code here
}


************************************
Question ID: 382

import java.util.Random;

class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}

public class Solution {
    ListNode head;
    Random random;

    public Solution(ListNode head) {
        this.head = head;
        random = new Random();
    }

    public int getRandom() {
        ListNode current = head;
        int result = current.val, i;
        for (i = 1; current != null; i++) {
            if (random.nextInt(i) == 0) {
                result = current.val;
            }
            current = current.next;
        }
        return result;
    }
}

-----
import java.util.Random;

class ListNode 
    // Your code here
}

************************************
Question ID: 383

import java.util.HashMap;

public boolean canConstruct(String ransomNote, String magazine) {
    HashMap<Character, Integer> letterCount = new HashMap<>();
    
    for (char c : magazine.toCharArray()) {
        letterCount.put(c, letterCount.getOrDefault(c, 0) + 1);
    }
    
    for (char c : ransomNote.toCharArray()) {
        if (!letterCount.containsKey(c) || letterCount.get(c) == 0) {
            return false;
        }
        letterCount.put(c, letterCount.get(c) - 1);
    }

    return true;
}

-----
import java.util.HashMap;

public boolean canConstruct(String ransomNote, String magazine) 
    // Your code here
}

************************************
Question ID: 384

import java.util.Random;
import java.util.Arrays;

class Solution {
    private int[] original;
    private Random rand;
    
    public Solution(int[] nums) {
        original = nums;
        rand = new Random();
    }
    
    public int[] reset() {
        return original;
    }
    
    public int[] shuffle() {
        int[] shuffled = Arrays.copyOf(original, original.length);
        for (int i = shuffled.length - 1; i > 0; i--) {
            int j = rand.nextInt(i + 1);
            int temp = shuffled[i];
            shuffled[i] = shuffled[j];
            shuffled[j] = temp;
        }
        return shuffled;
    }
}


-----
import java.util.Random;
import java.util.Arrays;

class Solution 
    // Your code here
}


************************************
Question ID: 386

import java.util.ArrayList;
import java.util.List;

public static void lexicographicalOrderHelper(int current, int n, List<Integer> result) {
    if (current > n) return;

    result.add(current);
    for (int i = 0; i <= 9; ++i) {
        lexicographicalOrderHelper(current * 10 + i, n, result);
    }
}

public static List<Integer> lexicalOrder(int n) {
    List<Integer> result = new ArrayList<>();
    for (int i = 1; i <= 9; ++i) {
        lexicographicalOrderHelper(i, n, result);
    }
    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public static void lexicographicalOrderHelper(int current, int n, List<Integer> result) 
    // Your code here
}

************************************
Question ID: 387

public int firstUniqChar(String s) {
    HashMap<Character, Integer> charCount = new HashMap<>();
    for (char c : s.toCharArray())
        charCount.put(c, charCount.getOrDefault(c, 0) + 1);
    for (int i = 0; i < s.length(); i++)
        if (charCount.get(s.charAt(i)) == 1)
            return i;
    return -1;
}


-----
public int firstUniqChar(String s) 
    // Your code here
}


************************************
Question ID: 388

import java.util.Stack;

public int lengthLongestPath(String input) {
    Stack<Integer> dirLengthStack = new Stack<>();
    String[] lines = input.split("\n");
    int maxFileLength = 0;

    for (String line : lines) {
        int level = line.lastIndexOf('\t') + 1;
        line = line.substring(level);

        while (dirLengthStack.size() > level) {
            dirLengthStack.pop();
        }

        int length = (dirLengthStack.isEmpty()) ? line.length() : dirLengthStack.peek() + line.length() + 1;
        dirLengthStack.push(length);

        if (line.contains(".")) {
            maxFileLength = Math.max(maxFileLength, length);
        }
    }

    return maxFileLength;
}


-----
import java.util.Stack;

public int lengthLongestPath(String input) 
    // Your code here
}


************************************
Question ID: 389

public char findTheDifference(String s, String t) {
    int sum_s = 0, sum_t = 0;
    for(char c : s.toCharArray()) sum_s += c;
    for(char c : t.toCharArray()) sum_t += c;
    return (char)(sum_t - sum_s);
}

-----
public char findTheDifference(String s, String t) 
    // Your code here
}

************************************
Question ID: 390

public int lastRemaining(int n) {
    boolean direction = true;
    int head = 1, remaining = n, step = 1;

    while (remaining > 1) {
        if (direction || remaining % 2 == 1) {
            head += step;
        }
        remaining /= 2;
        step *= 2;
        direction = !direction;
    }

    return head;
}

-----
public int lastRemaining(int n) 
    // Your code here
}

************************************
Question ID: 391

import java.util.HashSet;
import java.util.Set;
import java.awt.Point;

public class RectCover {
    public boolean isRectangleCover(int[][] rectangles) {
        int area = 0;
        Set<Point> points = new HashSet<>();
        int lx = Integer.MAX_VALUE, ly = Integer.MAX_VALUE, rx = Integer.MIN_VALUE, ry = Integer.MIN_VALUE;

        for (int[] rect : rectangles) {
            lx = Math.min(lx, rect[0]);
            ly = Math.min(ly, rect[1]);
            rx = Math.max(rx, rect[2]);
            ry = Math.max(ry, rect[3]);

            area += (rect[2] - rect[0]) * (rect[3] - rect[1]);

            Point p1 = new Point(rect[0], rect[1]);
            Point p2 = new Point(rect[0], rect[3]);
            Point p3 = new Point(rect[2], rect[1]);
            Point p4 = new Point(rect[2], rect[3]);

            if (!points.remove(p1)) points.add(p1);
            if (!points.remove(p2)) points.add(p2);
            if (!points.remove(p3)) points.add(p3);
            if (!points.remove(p4)) points.add(p4);
        }

        if (points.contains(new Point(lx, ly)) && points.contains(new Point(lx, ry)) &&
            points.contains(new Point(rx, ly)) && points.contains(new Point(rx, ry)) &&
            points.size() == 4)
            return area == (rx - lx) * (ry - ly);

        return false;
    }
}

-----
import java.util.HashSet;
import java.util.Set;
import java.awt.Point;

public class RectCover 
    // Your code here
}

************************************
Question ID: 392

boolean isSubsequence(String s, String t) {
    int si = 0, ti = 0;

    while (si < s.length() && ti < t.length()) {
        if (s.charAt(si) == t.charAt(ti))
            si++;
        ti++;
    }

    return si == s.length();
}


-----
boolean isSubsequence(String s, String t) 
    // Your code here
}


************************************
Question ID: 393

public boolean validUtf8(int[] data) {
    int count = 0;
    for (int byteValue : data) {
        if (count == 0) {
            if ((byteValue >> 5) == 0b110) count = 1;
            else if ((byteValue >> 4) == 0b1110) count = 2;
            else if ((byteValue >> 3) == 0b11110) count = 3;
            else if ((byteValue >> 7) == 1) return false;
        } else {
            if ((byteValue >> 6) != 0b10) return false;
            count--;
        }
    }
    return count == 0;
}

-----
public boolean validUtf8(int[] data) 
    // Your code here
}

************************************
Question ID: 394

import java.util.*;

class Solution {
    public String decodeString(String s) {
        Stack<Integer> counts = new Stack<>();
        Stack<String> results = new Stack<>();
        String current = "";
        int ptr = 0;

        while (ptr < s.length()) {
            if (Character.isDigit(s.charAt(ptr))) {
                int count = 0;
                while (Character.isDigit(s.charAt(ptr))) {
                    count = count * 10 + (s.charAt(ptr) - '0');
                    ptr++;
                }
                counts.push(count);
            } else if (s.charAt(ptr) == '[') {
                results.push(current);
                current = "";
                ptr++;
            } else if (s.charAt(ptr) == ']') {
                String prev = results.pop();
                int count = counts.pop();
                for (int i = 0; i < count; i++) {
                    prev += current;
                }
                current = prev;
                ptr++;
            } else {
                current += s.charAt(ptr);
                ptr++;
            }
        }

        return current;
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 395

import java.util.*;

public int longestSubstring(String s, int k) {
    if (s == null || s.length() == 0 || k <= 0) return 0;

    Map<Character, Integer> charCount = new HashMap<>();
    for (char ch : s.toCharArray())
        charCount.put(ch, charCount.getOrDefault(ch, 0) + 1);

    for (Map.Entry<Character, Integer> entry : charCount.entrySet()) {
        if (entry.getValue() < k) {
            int res = 0;
            for (String str : s.split(Character.toString(entry.getKey())))
                res = Math.max(res, longestSubstring(str, k));
            return res;
        }
    }
    return s.length();
}

-----
import java.util.*;

public int longestSubstring(String s, int k) 
    // Your code here
}

************************************
Question ID: 396

public int maxRotateFunction(int[] nums) {
    int n = nums.length;
    int total_sum = 0;
    int f = 0;

    for (int i = 0; i < n; i++) {
        total_sum += nums[i];
        f += i * nums[i];
    }

    int max_f = f;
    for (int i = 1; i < n; i++) {
        f += total_sum - (n * nums[n - i]);
        max_f = Math.max(max_f, f);
    }

    return max_f;
}


-----
public int maxRotateFunction(int[] nums) 
    // Your code here
}


************************************
Question ID: 397

int minOperations(int n) {
    int steps = 0;
    while(n > 1) {
        n = (n % 2 == 0) ? n / 2 : n - 1;
        steps++;
    }
    return steps;
}

-----
int minOperations(int n) 
    // Your code here
}

************************************
Question ID: 398

import java.util.Random;

class Solution {
    int[] nums;
    Random rand;
    
    public Solution(int[] nums) {
        this.nums = nums;
        this.rand = new Random();
    }
    
    public int pick(int target) {
        int count = 0, res = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == target) {
                count++;
                if (rand.nextInt(count) == 0) {
                    res = i;
                }
            }
        }
        return res;
    }
}

-----
import java.util.Random;

class Solution 
    // Your code here
}

************************************
Question ID: 399

import java.util.*;

public class Solution {     
    public double dfs(String s1, String s2, Map<String, List<Pair<String, Double>>> graph) {
        if (!graph.containsKey(s1) || !graph.containsKey(s2)) return -1.0;
        if (s1.equals(s2)) return 1.0;
      
        for (Pair<String, Double> p : graph.get(s1)) {
            double temp = dfs(p.getKey(), s2, graph);
            if (temp > 0) return p.getValue() * temp;
        }
        return -1.0;
    }

    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        Map<String, List<Pair<String, Double>>> graph = new HashMap<>();
        for (int i = 0; i < equations.size(); i++) {
            String s1 = equations.get(i).get(0);
            String s2 = equations.get(i).get(1);
          
            if (!graph.containsKey(s1)) graph.put(s1, new ArrayList<>());
            if (!graph.containsKey(s2)) graph.put(s2, new ArrayList<>());

            graph.get(s1).add(new Pair<>(s2, values[i]));
            graph.get(s2).add(new Pair<>(s1, 1 / values[i]));
        }

        double[] ans = new double[queries.size()];
        for (int i = 0; i < queries.size(); i++) {
            ans[i] = dfs(queries.get(i).get(0), queries.get(i).get(1), graph);
        }
        return ans;
    }
}

-----
import java.util.*;

public class Solution 
    // Your code here
}

************************************
Question ID: 400

public int findNthDigit(int n) {
    int size = 1;
    long length = 9;
    int start = 1;

    while (n > length * size) {
        n -= length * size;
        size++;
        length *= 10;
        start *= 10;
    }

    start += (n - 1) / size;
    String s = Integer.toString(start);
    return Character.getNumericValue(s.charAt((n - 1) % size));
}

-----
public int findNthDigit(int n) 
    // Your code here
}

************************************
Question ID: 401

import java.util.ArrayList;
import java.util.List;

public List<String> readBinaryWatch(int turnedOn) {
    List<String> times = new ArrayList<>();
    for (int h = 0; h < 12; h++) {
        for (int m = 0; m < 60; m++) {
            if (Integer.bitCount(h) + Integer.bitCount(m) == turnedOn) {
                times.add(String.format("%d:%02d", h, m));
            }
        }
    }
    return times;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<String> readBinaryWatch(int turnedOn) 
    // Your code here
}

************************************
Question ID: 402

public String removeKDigits(String num, int k) {
    StringBuilder result = new StringBuilder();
    for (char c : num.toCharArray()) {
        while (k > 0 && result.length() > 0 && result.charAt(result.length() - 1) > c) {
            result.setLength(result.length() - 1);
            k--;
        }
        result.append(c);
    }
    result.setLength(result.length() - k);
    while (result.length() > 0 && result.charAt(0) == '0') {
        result.deleteCharAt(0);
    }
    return result.length() == 0 ? "0" : result.toString();
}

-----
public String removeKDigits(String num, int k) 
    // Your code here
}

************************************
Question ID: 403

import java.util.*;

public boolean canCross(int[] stones) {
    Map<Integer, Set<Integer>> dp = new HashMap<>();
    for (int stone : stones)
        dp.put(stone, new HashSet<>());
    dp.get(0).add(0);

    for (int stone : stones) {
        for (int k : dp.get(stone)) {
            for (int jump : new int[]{k - 1, k, k + 1}) {
                if (jump > 0 && dp.containsKey(stone + jump))
                    dp.get(stone + jump).add(jump);
            }
        }
    }
    return !dp.get(stones[stones.length - 1]).isEmpty();
}


-----
import java.util.*;

public boolean canCross(int[] stones) 
    // Your code here
}


************************************
Question ID: 405

public String toHex(int num) {
    if (num == 0) return "0";
    String hex = "";
    char[] hexDigits = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
    for (int i = 0; num != 0 && i < 8; ++i) {
        hex = hexDigits[num & 0xf] + hex;
        num >>>= 4;
    }
    return hex;
}

-----
public String toHex(int num) 
    // Your code here
}

************************************
Question ID: 406

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public int[][] reconstructQueue(int[][] people) {
    Arrays.sort(people, (a, b) -> a[0] == b[0] ? a[1] - b[1] : b[0] - a[0]);

    List<int[]> result = new ArrayList<>();
    for (int[] p : people) {
        result.add(p[1], p);
    }
    return result.toArray(new int[people.length][2]);
}


-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public int[][] reconstructQueue(int[][] people) 
    // Your code here
}


************************************
Question ID: 407

import java.util.PriorityQueue;

public int trapRainWater(int[][] heightMap) {
    int m = heightMap.length, n = heightMap[0].length;
    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
    boolean[][] visited = new boolean[m][n];

    for (int i = 0; i < m; i++) {
        pq.offer(new int[]{heightMap[i][0], i, 0});
        pq.offer(new int[]{heightMap[i][n - 1], i, n - 1});
        visited[i][0] = visited[i][n - 1] = true;
    }

    for (int i = 1; i < n - 1; i++) {
        pq.offer(new int[]{heightMap[0][i], 0, i});
        pq.offer(new int[]{heightMap[m - 1][i], m - 1, i});
        visited[0][i] = visited[m - 1][i] = true;
    }

    int water = 0, maxHeight = 0;
    int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    while (!pq.isEmpty()) {
        int[] t = pq.poll();
        int h = t[0], r = t[1], c = t[2];
        maxHeight = Math.max(maxHeight, h);
        for (int[] dir : dirs) {
            int x = r + dir[0], y = c + dir[1];
            if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) continue;
            if (heightMap[x][y] < maxHeight) water += maxHeight - heightMap[x][y];
            pq.offer(new int[]{heightMap[x][y], x, y});
            visited[x][y] = true;
        }
    }

    return water;
}

-----
import java.util.PriorityQueue;

public int trapRainWater(int[][] heightMap) 
    // Your code here
}

************************************
Question ID: 408

public boolean validWordAbbreviation(String word, String abbr) {
    int i = 0, j = 0;
    while (i < word.length() && j < abbr.length()) {
        if (Character.isDigit(abbr.charAt(j))) {
            if (abbr.charAt(j) == '0') return false; // leading zero
            int num = 0;
            while (j < abbr.length() && Character.isDigit(abbr.charAt(j)))
                num = num * 10 + (abbr.charAt(j++) - '0');
            i += num;
        } else {
            if (word.charAt(i++) != abbr.charAt(j++)) return false;
        }
    }
    return i == word.length() && j == abbr.length();
}

-----
public boolean validWordAbbreviation(String word, String abbr) 
    // Your code here
}

************************************
Question ID: 409

public int longestPalindrome(String s) {
    int[] charCount = new int[128];
    int result = 0;
    for (char c : s.toCharArray())
        charCount[c]++;
    for (int count : charCount) {
        result += count / 2 * 2;
        if (result % 2 == 0 && count % 2 == 1)
            result++;
    }
    return result;
}

-----
public int longestPalindrome(String s) 
    // Your code here
}

************************************
Question ID: 410

public int splitArray(int[] nums, int m) {
    long left = 0, right = 0;
    for (int num : nums) {
        left = Math.max(left, num);
        right += num;
    }

    while (left < right) {
        long mid = (left + right) / 2;
        int count = 1;
        long curSum = 0;
        for (int num : nums) {
            curSum += num;
            if (curSum > mid) {
                curSum = num;
                count++;
            }
        }

        if (count > m) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return (int)left;
}

-----
public int splitArray(int[] nums, int m) 
    // Your code here
}

************************************
Question ID: 411

import java.util.List;

public class Solution {
    private static String abbreviate(String s, int k, int i) {
        if (i == s.length()) {
            return (k > 0) ? String.valueOf(k) : "";
        }
        if (k == 0) {
            return s.substring(i) + (i + 1 < s.length() ? abbreviate(s, 1, i + 1) : "");
        }
        return String.valueOf(k) + s.charAt(i) + (i + 1 < s.length() ? abbreviate(s, 1, i + 1) : "");
    }

    private static boolean isAbbreviation(String target, String word) {
        int i = 0, j = 0;
        while (i < target.length() && j < word.length()) {
            if (target.charAt(i) == word.charAt(j)) {
                i++; j++;
            } else if (Character.isDigit(target.charAt(i))) {
                int k = 0;
                while (i < target.length() && Character.isDigit(target.charAt(i))) {
                    k = k * 10 + target.charAt(i++) - '0';
                }
                j += k;
            } else {
                return false;
            }
        }
        return (i == target.length() && j == word.length());
    }

    public static String minAbbreviation(String target, List<String> dictionary) {
        String ans = target;
        for (int k = 0; k <= target.length(); k++) {
            for (int i = 0; i <= target.length() - k; i++) {
                String current = abbreviate(target, k, i);
                if (current.length() < ans.length()) {
                    boolean valid = true;
                    for (String word : dictionary) {
                        if (isAbbreviation(current, word)) {
                            valid = false;
                            break;
                        }
                    }
                    if (valid) {
                        ans = current;
                    }
                }
            }
        }
        return ans;
    }
}


-----
import java.util.List;

public class Solution 
    // Your code here
}


************************************
Question ID: 412

import java.util.ArrayList;

public ArrayList<String> fizzBuzz(int n) {
    ArrayList<String> result = new ArrayList<>();
    for (int i = 1; i <= n; i++) {
        if (i % 15 == 0) result.add("FizzBuzz");
        else if (i % 3 == 0) result.add("Fizz");
        else if (i % 5 == 0) result.add("Buzz");
        else result.add(Integer.toString(i));
    }
    return result;
}

-----
import java.util.ArrayList;

public ArrayList<String> fizzBuzz(int n) 
    // Your code here
}

************************************
Question ID: 413

public int numberOfArithmeticSlices(int[] nums) {
    int n = nums.length, count = 0, cur = 0;
    for (int i = 2; i < n; ++i) {
        if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {
            cur++;
            count += cur;
        } else {
            cur = 0;
        }
    }
    return count;
}

-----
public int numberOfArithmeticSlices(int[] nums) 
    // Your code here
}

************************************
Question ID: 414

import java.util.TreeSet;

public int thirdMax(int[] nums) {
    TreeSet<Integer> top3 = new TreeSet<>();
    for (int num : nums) {
        top3.add(num);
        if (top3.size() > 3) {
            top3.remove(top3.first());
        }
    }
    return top3.size() == 3 ? top3.first() : top3.last();
}

-----
import java.util.TreeSet;

public int thirdMax(int[] nums) 
    // Your code here
}

************************************
Question ID: 415

public String addStrings(String num1, String num2) {
    int i = num1.length() - 1, j = num2.length() - 1, carry = 0;
    StringBuilder result = new StringBuilder();

    while (i >= 0 || j >= 0 || carry != 0) {
        int sum = carry;

        if (i >= 0) {
            sum += num1.charAt(i) - '0';
            --i;
        }
        if (j >= 0) {
            sum += num2.charAt(j) - '0';
            --j;
        }

        carry = sum / 10;
        result.append(sum % 10);
    }

    return result.reverse().toString();
}


-----
public String addStrings(String num1, String num2) 
    // Your code here
}


************************************
Question ID: 416

public boolean canPartition(int[] nums) {
    int sum = 0;
    for (int num : nums) sum += num;
    
    if (sum % 2 != 0) return false;
    
    int target = sum / 2;
    boolean[] dp = new boolean[target + 1];
    dp[0] = true;
    
    for (int num : nums) {
        for (int i = target; i >= num; i--) {
            dp[i] = dp[i] || dp[i - num];
        }
    }
    return dp[target];
}

-----
public boolean canPartition(int[] nums) 
    // Your code here
}

************************************
Question ID: 417

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<int[]> pacificAtlantic(int[][] heights) {
    int m = heights.length;
    int n = heights[0].length;
    boolean[][] pacific = new boolean[m][n];
    boolean[][] atlantic = new boolean[m][n];

    for (int r = 0; r < m; ++r) {
        dfs(heights, r, 0, -1, pacific);
        dfs(heights, r, n - 1, -1, atlantic);
    }
    for (int c = 0; c < n; ++c) {
        dfs(heights, 0, c, -1, pacific);
        dfs(heights, m - 1, c, -1, atlantic);
    }
    List<int[]> result = new ArrayList<>();
    for (int r = 0; r < m; ++r) {
        for (int c = 0; c < n; ++c) {
            if (pacific[r][c] && atlantic[r][c]) {
                result.add(new int[]{r, c});
            }
        }
    }
    return result;
}

private void dfs(int[][] heights, int r, int c, int prevHeight, boolean[][] visited) {
    if (r < 0 || r >= heights.length || c < 0 || c >= heights[0].length) return;
    if (heights[r][c] >= prevHeight && !visited[r][c]) {
        visited[r][c] = true;
        dfs(heights, r - 1, c, heights[r][c], visited);
        dfs(heights, r + 1, c, heights[r][c], visited);
        dfs(heights, r, c - 1, heights[r][c], visited);
        dfs(heights, r, c + 1, heights[r][c], visited);
    }
}


-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<int[]> pacificAtlantic(int[][] heights) 
    // Your code here
}


************************************
Question ID: 418

public int wordsTyping(String[] sentence, int rows, int cols) {
    int totalChars = 0;
    for (String word : sentence) {
        totalChars += word.length() + 1;
    }

    int result = 0;
    int index = 0;
    for (int r = 0; r < rows; ++r) {
        int remainingCols = cols;
        while (true) {
            int wordLen = sentence[index].length();
            if (remainingCols >= wordLen) {
                remainingCols -= wordLen + 1;
                index = (index + 1) % sentence.length;
                if (index == 0) result++;
            } else {
                break;
            }
        }
    }

    return result;
}

-----
public int wordsTyping(String[] sentence, int rows, int cols) 
    // Your code here
}

************************************
Question ID: 419

public int countBattleships(char[][] board) {
    int count = 0;
    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[i].length; j++) {
            if (board[i][j] == 'X' &&
                (i == 0 || board[i - 1][j] == '.') &&
                (j == 0 || board[i][j - 1] == '.')) {
                count++;
            }
        }
    }
    return count;
}

-----
public int countBattleships(char[][] board) 
    // Your code here
}

************************************
Question ID: 420

int strongPassword(String password) {
    int missingLower = 1, missingUpper = 1, missingDigit = 1;
    int total = password.length();
    for (char c : password.toCharArray()) {
        if (Character.isLowerCase(c)) missingLower = 0;
        if (Character.isUpperCase(c)) missingUpper = 0;
        if (Character.isDigit(c)) missingDigit = 0;
    }
    int missing = missingLower + missingUpper + missingDigit;
    if (total < 6) return Math.max(missing, 6 - total);
    if (total > 20) return missing + total - 20;
    return missing;
}

-----
int strongPassword(String password) 
    // Your code here
}

************************************
Question ID: 421

public int findMaximumXOR(int[] nums) {
    int max_xor = 0, mask = 0;
    
    for (int i = 31; i >= 0; i--) {
        mask |= (1 << i);
        HashSet<Integer> prefixes = new HashSet<>();
        
        for (int num : nums) {
            prefixes.add(num & mask);
        }
        
        int possible_max = max_xor | (1 << i);
        
        for (int prefix : prefixes) {
            if (prefixes.contains(prefix ^ possible_max)) {
                max_xor = possible_max;
                break;
            }
        }
    }
    
    return max_xor;
}

-----
public int findMaximumXOR(int[] nums) 
    // Your code here
}

************************************
Question ID: 422

public boolean validWordSquare(List<String> words) {
    for (int i = 0; i < words.size(); i++) {
        for (int j = 0; j < words.get(i).length(); j++) {
            if (j >= words.size() || i >= words.get(j).length() || words.get(i).charAt(j) != words.get(j).charAt(i)) {
                return false;
            }
        }
    }
    return true;
}


-----
public boolean validWordSquare(List<String> words) 
    // Your code here
}


************************************
Question ID: 423

public String findDigitsInAscendingOrder(String s) {
    int[] count = new int[10];
    for (char c : s.toCharArray()) {
        if (c == 'z') count[0]++;
        if (c == 'w') count[2]++;
        if (c == 'u') count[4]++;
        if (c == 'x') count[6]++;
        if (c == 'g') count[8]++;
        if (c == 'o') count[1]++;
        if (c == 'h') count[3]++;
        if (c == 'f') count[5]++;
        if (c == 's') count[7]++;
        if (c == 'i') count[9]++;
    }
    count[1] -= count[0] + count[2] + count[4];
    count[3] -= count[8];
    count[5] -= count[4];
    count[7] -= count[6];
    count[9] -= count[5] + count[6] + count[8];
    
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < count[i]; j++) {
            sb.append(i);
        }
    }
    return sb.toString();
}


-----
public String findDigitsInAscendingOrder(String s) 
    // Your code here
}


************************************
Question ID: 424

public int characterReplacement(String s, int k) {
    int n = s.length();
    int left = 0, right = 0, maxFreq = 0, result = 0;
    int[] freq = new int[26];
    
    for (right = 0; right < n; right++) {
        freq[s.charAt(right) - 'A']++;
        maxFreq = Math.max(maxFreq, freq[s.charAt(right) - 'A']);
        
        if (right - left + 1 - maxFreq > k) {
            freq[s.charAt(left) - 'A']--;
            left++;
        }
        
        result = Math.max(result, right - left + 1);
    }
    
    return result;
}


-----
public int characterReplacement(String s, int k) 
    // Your code here
}


************************************
Question ID: 425

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public List<List<String>> wordSquares(String[] words) {
    Map<String, List<String>> prefixMap = buildPrefixMap(words);
    List<List<String>> squares = new ArrayList<>();
    for (String word : words) {
        List<String> square = new ArrayList<>();
        square.add(word);
        searchSquares(1, words[0].length(), square, prefixMap, squares);
    }
    return squares;
}

private void searchSquares(int index, int length, List<String> square, Map<String, List<String>> prefixMap, List<List<String>> squares) {
    if (index == length) {
        squares.add(new ArrayList<>(square));
        return;
    }
    String prefix = buildPrefix(square, index);
    for (String word : prefixMap.getOrDefault(prefix, new ArrayList<>())) {
        square.add(word);
        searchSquares(index + 1, length, square, prefixMap, squares);
        square.remove(square.size() - 1);
    }
}

private String buildPrefix(List<String> square, int index) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < index; i++) {
        sb.append(square.get(i).charAt(index));
    }
    return sb.toString();
}

private Map<String, List<String>> buildPrefixMap(String[] words) {
    Map<String, List<String>> prefixMap = new HashMap<>();
    for (String word : words) {
        for (int i = 0; i <= word.length(); i++) {
            String prefix = word.substring(0, i);
            if (!prefixMap.containsKey(prefix)) {
                prefixMap.put(prefix, new ArrayList<>());
            }
            prefixMap.get(prefix).add(word);
        }
    }
    return prefixMap;
}

-----
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public List<List<String>> wordSquares(String[] words) 
    // Your code here
}

************************************
Question ID: 433

import java.util.*;

public int minMutation(String start, String end, String[] bank) {
    Queue<String> q = new LinkedList<>();
    q.offer(start);
    Set<String> visited = new HashSet<>();
    visited.add(start);
    int depth = 0;
    
    while (!q.isEmpty()) {
        int levelSize = q.size();
        for (int i = 0; i < levelSize; i++) {
            String current = q.poll();
            if (current.equals(end)) return depth;
            
            for (String gene : bank) {
                if (!visited.contains(gene)) {
                    int diff = 0;
                    for (int j = 0; j < 8; j++) {
                        if (current.charAt(j) != gene.charAt(j)) diff++;
                        if (diff > 1) break;
                    }
                    
                    if (diff == 1) {
                        q.offer(gene);
                        visited.add(gene);
                    }
                }
            }
        }
        depth++;
    }
    return -1;
}


-----
import java.util.*;

public int minMutation(String start, String end, String[] bank) 
    // Your code here
}


************************************
Question ID: 434

public int countSegments(String s) {
    if (s == null || s.trim().length() == 0) {
        return 0;
    }
    String[] segments = s.trim().split("\\s+");
    return segments.length;
}

-----
public int countSegments(String s) 
    // Your code here
}

************************************
Question ID: 435

import java.util.Arrays;

public int eraseOverlapIntervals(int[][] intervals) {
    if (intervals.length == 0) return 0;

    Arrays.sort(intervals, (a, b) -> a[1] - b[1]);

    int count = 0;
    int prev_end = intervals[0][1];

    for (int i = 1; i < intervals.length; i++) {
        if (intervals[i][0] < prev_end) {
            count++;
        } else {
            prev_end = intervals[i][1];
        }
    }

    return count;
}

-----
import java.util.Arrays;

public int eraseOverlapIntervals(int[][] intervals) 
    // Your code here
}

************************************
Question ID: 436

import java.util.TreeMap;
import java.util.Map;

public int[] findRightInterval(int[][] intervals) {
    int[] res = new int[intervals.length];
    TreeMap<Integer, Integer> starts = new TreeMap<>();

    for(int i = 0; i < intervals.length; i++) {
        starts.put(intervals[i][0], i);
    }

    for(int i = 0; i < intervals.length; i++) {
        Map.Entry<Integer, Integer> right = starts.ceilingEntry(intervals[i][1]);
        res[i] = right == null ? -1 : right.getValue();
    }

    return res;
}

-----
import java.util.TreeMap;
import java.util.Map;

public int[] findRightInterval(int[][] intervals) 
    // Your code here
}

************************************
Question ID: 437

public int pathSumHelper(TreeNode node, int targetSum, int currentSum) {
    if (node == null) {
        return 0;
    }
    
    currentSum += node.val;
    int totalPaths = currentSum == targetSum ? 1 : 0;
    totalPaths += pathSumHelper(node.left, targetSum, currentSum);
    totalPaths += pathSumHelper(node.right, targetSum, currentSum);
    return totalPaths;
}

public int pathSum(TreeNode root, int targetSum) {
    if (root == null) {
        return 0;
    }

    return pathSumHelper(root, targetSum, 0) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum);
}


-----
public int pathSumHelper(TreeNode node, int targetSum, int currentSum) 
    // Your code here
}


************************************
Question ID: 438

import java.util.List;
import java.util.ArrayList;

public List<Integer> findAnagrams(String s, String p) {
    List<Integer> result = new ArrayList<>();
    if (s.length() < p.length()) return result;

    int[] s_count = new int[26];
    int[] p_count = new int[26];
    for (char c : p.toCharArray()) p_count[c - 'a']++;

    for (int i = 0; i < s.length(); i++) {
        s_count[s.charAt(i) - 'a']++;
        if (i >= p.length()) s_count[s.charAt(i - p.length()) - 'a']--;
        if (java.util.Arrays.equals(s_count, p_count)) result.add(i - p.length() + 1);
    }

    return result;
}

-----
import java.util.List;
import java.util.ArrayList;

public List<Integer> findAnagrams(String s, String p) 
    // Your code here
}

************************************
Question ID: 439

import java.util.Stack;

public String parseTernary(String expression) {
    Stack<Character> stk = new Stack<>();
    for (int i = expression.length() - 1; i >= 0; --i) {
        char c = expression.charAt(i);
        if (!stk.isEmpty() && stk.peek() == '?') {
            stk.pop(); // Pop '?'
            char first = stk.pop();
            stk.pop(); // Pop ':'
            char second = stk.pop();
            stk.push(c == 'T' ? first : second);
        } else {
            stk.push(c);
        }
    }
    return String.valueOf(stk.peek());
}


-----
import java.util.Stack;

public String parseTernary(String expression) 
    // Your code here
}


************************************
Question ID: 440

import java.util.*;
public class Solution {
    public int findKthNumber(int n, int k) {
        List<Integer> nums = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            nums.add(i);
        }
        nums.sort((a, b) -> String.valueOf(a).compareTo(String.valueOf(b)));
        return nums.get(k - 1);
    }
}


-----
import java.util.*;
public class Solution 
    // Your code here
}


************************************
Question ID: 441

public int arrangeCoins(int n) {
    int k = 0;
    while (n > k) {
        k++;
        n -= k;
    }
    return k;
}

-----
public int arrangeCoins(int n) 
    // Your code here
}

************************************
Question ID: 442

import java.util.ArrayList;
import java.util.List;

public List<Integer> findDuplicates(int[] nums) {
    List<Integer> duplicates = new ArrayList<>();
    for (int i = 0; i < nums.length; i++) {
        int index = Math.abs(nums[i]) - 1;
        if (nums[index] < 0) {
            duplicates.add(Math.abs(nums[i]));
        } else {
            nums[index] *= -1;
        }
    }
    return duplicates;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<Integer> findDuplicates(int[] nums) 
    // Your code here
}

************************************
Question ID: 443

public int compress(char[] chars) {
    int index = 0, count;
    for(int i = 0; i < chars.length; i += count) {
        count = 1;
        while(i + count < chars.length && chars[i] == chars[i + count]) {
            count++;
        }
        chars[index++] = chars[i];
        if(count > 1) {
            for(char c : Integer.toString(count).toCharArray()) {
                chars[index++] = c;
            }
        }
    }
    return index;
}

-----
public int compress(char[] chars) 
    // Your code here
}

************************************
Question ID: 444

public boolean isShortestAndUniqueSupersequence(int[] nums, int[][] sequences) {
    Map<Integer, Integer> pos = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        pos.put(nums[i], i);
    }

    for (int[] seq : sequences) {
        if (pos.get(seq[0]) > pos.get(seq[seq.length - 1])) {
            return false;
        }
    }
    return true;
}

-----
public boolean isShortestAndUniqueSupersequence(int[] nums, int[][] sequences) 
    // Your code here
}

************************************
Question ID: 446

import java.util.HashMap;
import java.util.Map;

public int numberOfArithmeticSlices(int[] nums) {
    int res = 0;
    int n = nums.length;
    Map<Integer, Integer>[] dp = new HashMap[n];

    for (int i = 0; i < n; ++i) {
        dp[i] = new HashMap<>();
        for (int j = 0; j < i; ++j) {
            long diff = (long)nums[i] - (long)nums[j];
            if (diff <= Integer.MIN_VALUE || diff > Integer.MAX_VALUE) continue;

            int delta = (int)diff;
            dp[i].put(delta, dp[i].getOrDefault(delta, 0) + 1);

            if (dp[j].containsKey(delta)) {
                res += dp[j].get(delta);
                dp[i].put(delta, dp[i].get(delta) + dp[j].get(delta));
            }
        }
    }
    return res;
}


-----
import java.util.HashMap;
import java.util.Map;

public int numberOfArithmeticSlices(int[] nums) 
    // Your code here
}


************************************
Question ID: 447

import java.util.HashMap;

public int numberOfBoomerangs(int[][] points) {
    int count = 0;

    for (int[] i : points) {
        HashMap<Integer, Integer> group_count = new HashMap<>();
        for (int[] j : points) {
            int dx = i[0] - j[0], dy = i[1] - j[1];
            int dist = dx * dx + dy * dy;

            group_count.put(dist, group_count.getOrDefault(dist, 0) + 1);
        }

        for (int g : group_count.values()) {
            count += g * (g - 1);
        }
    }

    return count;
}

-----
import java.util.HashMap;

public int numberOfBoomerangs(int[][] points) 
    // Your code here
}

************************************
Question ID: 448

import java.util.ArrayList;
import java.util.List;

public List<Integer> findDisappearedNumbers(int[] nums) {
    List<Integer> result = new ArrayList<>();
    
    for (int i = 0; i < nums.length; i++) {
        int index = Math.abs(nums[i]) - 1;
        nums[index] = -Math.abs(nums[index]);
    }

    for (int i = 0; i < nums.length; i++) {
        if (nums[i] > 0) {
            result.add(i + 1);
        }
    }

    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<Integer> findDisappearedNumbers(int[] nums) 
    // Your code here
}

************************************
Question ID: 451

import java.util.*;

public String sortByFrequency(String s) {
    Map<Character, Integer> freq = new HashMap<>();
    Character[] chars = new Character[m.length()];
    
    for (int i = 0; i < m.length(); i++) {
        chars[i] = m.charAt(i);
        freq.put(chars[i], freq.getOrDefault(chars[i], 0) + 1);
    }
    
    Arrays.sort(chars, (a, b) -> freq.get(b).compareTo(freq.get(a)));
    
    StringBuilder sb = new StringBuilder();
    for (Character c : chars) {
        sb.append(c);
    }
    return sb.toString();
}

-----
import java.util.*;

public String sortByFrequency(String s) 
    // Your code here
}

************************************
Question ID: 452

import java.util.Arrays;
import java.util.Comparator;

public int findMinArrowShots(int[][] points) {
    if (points.length == 0) return 0;
    Arrays.sort(points, Comparator.comparingInt(a -> a[1]));

    int arrows = 1;
    int end = points[0][1];

    for (int i = 1; i < points.length; i++) {
        if (points[i][0] > end) {
            arrows++;
            end = points[i][1];
        }
    }

    return arrows;
}

-----
import java.util.Arrays;
import java.util.Comparator;

public int findMinArrowShots(int[][] points) 
    // Your code here
}

************************************
Question ID: 453

public int minMoves(int[] nums) {
    int min_element = nums[0];
    for (int num : nums) {
        min_element = Math.min(min_element, num);
    }
    int moves = 0;
    for (int num : nums) {
        moves += (num - min_element);
    }
    return moves;
}


-----
public int minMoves(int[] nums) 
    // Your code here
}


************************************
Question ID: 454

import java.util.HashMap;

public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
    HashMap<Integer, Integer> hashMap = new HashMap<>();
    int count = 0;

    for (int i : nums1) {
        for (int j : nums2) {
            hashMap.put(i + j, hashMap.getOrDefault(i + j, 0) + 1);
        }
    }

    for (int k : nums3) {
        for (int l : nums4) {
            count += hashMap.getOrDefault(-(k + l), 0);
        }
    }

    return count;
}

-----
import java.util.HashMap;

public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) 
    // Your code here
}

************************************
Question ID: 455

import java.util.Arrays;

public int findContentChildren(int[] g, int[] s) {
    Arrays.sort(g);
    Arrays.sort(s);
    int i = 0, j = 0;

    while (i < g.length && j < s.length) {
        if (s[j] >= g[i]) {
            i++;
        }

        j++;
    }

    return i;
}


-----
import java.util.Arrays;

public int findContentChildren(int[] g, int[] s) 
    // Your code here
}


************************************
Question ID: 456

public boolean find132pattern(int[] nums) {
    int n = nums.length;
    int[] min = new int[n];
    min[0] = nums[0];
    for (int i = 1; i < n; ++i) {
        min[i] = Math.min(min[i - 1], nums[i]);
    }
    Stack<Integer> stack = new Stack<>();
    for (int j = n - 1; j >= 0; --j) {
        if (nums[j] > min[j]) {
            while (!stack.isEmpty() && stack.peek() <= min[j]) {
                stack.pop();
            }
            if (!stack.isEmpty() && stack.peek() < nums[j]) {
                return true;
            }
            stack.push(nums[j]);
        }
    }
    return false;
}

-----
public boolean find132pattern(int[] nums) 
    // Your code here
}

************************************
Question ID: 457

public boolean circularArrayLoop(int[] nums) {
    int N = nums.length;
    for (int i = 0; i < N; i++) {
        int slow = i, fast = i;
        do {
            slow = getNextIndex(slow, nums);
            fast = getNextIndex(getNextIndex(fast, nums), nums);
        } while (slow != fast && nums[slow] * nums[fast] > 0);

        if (slow != fast) continue;
        boolean cycle = false;
        int start = slow;
        do {
            cycle |= getNextIndex(start, nums) == start;
            start = getNextIndex(start, nums);
        } while (start != slow);
        if (!cycle) return true;
    }
    return false;
}

int getNextIndex(int idx, int[] nums) {
    int N = nums.length;
    return ((idx + nums[idx]) % N + N) % N;
}


-----
public boolean circularArrayLoop(int[] nums) 
    // Your code here
}


************************************
Question ID: 458

public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {
    int pigs = 0;
    while (Math.pow((minutesToTest / minutesToDie) + 1, pigs) < buckets) {
        pigs++;
    }
    return pigs;
}


-----
public int poorPigs(int buckets, int minutesToDie, int minutesToTest) 
    // Your code here
}


************************************
Question ID: 459

public boolean canConstruct(String s) {
    int n = s.length();
    for (int i = n / 2; i > 0; --i) {
        if (n % i == 0) {
            String substr = s.substring(0, i);
            boolean flag = true;
            for (int j = i; j < n; j += i) {
                if (!s.substring(j, j + i).equals(substr)) {
                    flag = false;
                    break;
                }
            }

            if (flag) return true;
        }
    }
    return false;
}


-----
public boolean canConstruct(String s) 
    // Your code here
}


************************************
Question ID: 461

public int hammingDistance(int x, int y) {
    int dist = 0, xorResult = x ^ y;
    while (xorResult != 0) {
        dist += xorResult & 1;
        xorResult >>= 1;
    }
    return dist;
}

-----
public int hammingDistance(int x, int y) 
    // Your code here
}

************************************
Question ID: 462

public int minMoves2(int[] nums) {
    Arrays.sort(nums);
    int mid = nums[nums.length / 2];
    int moves = 0;
    for (int num : nums) {
        moves += Math.abs(num - mid);
    }
    return moves;
}

-----
public int minMoves2(int[] nums) 
    // Your code here
}

************************************
Question ID: 463

public int islandPerimeter(int[][] grid) {
    int perimeter = 0;
    for (int row = 0; row < grid.length; row++) {
        for (int col = 0; col < grid[row].length; col++) {
            if (grid[row][col] == 1) {
                perimeter += 4;
                if (row > 0 && grid[row - 1][col] == 1) perimeter -= 2;
                if (col > 0 && grid[row][col - 1] == 1) perimeter -= 2;
            }
        }
    }
    return perimeter;
}

-----
public int islandPerimeter(int[][] grid) 
    // Your code here
}

************************************
Question ID: 464

import java.util.HashMap;

public class Solution {
    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {
        if (maxChoosableInteger >= desiredTotal) return true;
        if ((maxChoosableInteger * (maxChoosableInteger + 1)) / 2 < desiredTotal) return false;
        
        HashMap<Integer, Boolean> memo = new HashMap<>();
        int state = 0;
        return canWin(maxChoosableInteger, desiredTotal, state, memo);
    }
    
    private boolean canWin(int maxChoosableInteger, int desiredTotal, int state, HashMap<Integer, Boolean> memo) {
        if (desiredTotal <= 0) return false;
        if (memo.containsKey(state)) return memo.get(state);
        
        for (int i = 1; i <= maxChoosableInteger; i++) {
            int bitCheck = 1 << i;
            if ((state & bitCheck) == 0) {
                if (!canWin(maxChoosableInteger, desiredTotal - i, state | bitCheck, memo)) {
                    memo.put(state, true);
                    return true;
                }
            }
        }
        
        memo.put(state, false);
        return false;
    }
}


-----
import java.util.HashMap;

public class Solution 
    // Your code here
}


************************************
Question ID: 465

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public int minTransfers(int[][] transactions) {
    Map<Integer, Integer> balances = new HashMap<>();
    for (int[] transaction : transactions) {
        balances.put(transaction[0], balances.getOrDefault(transaction[0], 0) - transaction[2]);
        balances.put(transaction[1], balances.getOrDefault(transaction[1], 0) + transaction[2]);
    }

    List<Integer> debts = new ArrayList<>();
    for (int balance : balances.values()) {
        if (balance != 0) {
            debts.add(balance);
        }
    }
    return dfs(debts, 0);
}

private int dfs(List<Integer> debts, int start) {
    while (start < debts.size() && debts.get(start) == 0) {
        start++;
    }
    if (start == debts.size()) {
        return 0;
    }
    int result = Integer.MAX_VALUE;
    for (int i = start + 1; i < debts.size(); ++i) {
        if ((debts.get(start) > 0) != (debts.get(i) > 0)) {
            debts.set(i, debts.get(i) + debts.get(start));
            result = Math.min(result, 1 + dfs(debts, start + 1));
            debts.set(i, debts.get(i) - debts.get(start));
        }
    }
    return result;
}


-----
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public int minTransfers(int[][] transactions) 
    // Your code here
}


************************************
Question ID: 466

public int getMaxRepetitions(String s1, int n1, String s2, int n2) {
    int count1 = 0, count2 = 0, i = 0, j = 0;
    while (count1 < n1) {
        if (s1.charAt(i) == s2.charAt(j)) {
            j++;
            if (j == s2.length()) {
                j = 0;
                count2++;
            }
        }
        i++;
        if (i == s1.length()) {
            i = 0;
            count1++;
        }
    }
    return count2 / n2;
}


-----
public int getMaxRepetitions(String s1, int n1, String s2, int n2) 
    // Your code here
}


************************************
Question ID: 467

public int findSubstringInWraproundString(String p) {
    int[] cnt = new int[26];
    int length = 0;

    for (int i = 0; i < p.length(); i++) {
        if (i > 0 && (p.charAt(i) == p.charAt(i - 1) + 1 || p.charAt(i - 1) - p.charAt(i) == 25)) {
            length++;
        } else {
            length = 1;
        }
        cnt[p.charAt(i) - 'a'] = Math.max(cnt[p.charAt(i) - 'a'], length);
    }

    int sum = 0;
    for (int v : cnt) {
        sum += v;
    }
    return sum;
}


-----
public int findSubstringInWraproundString(String p) 
    // Your code here
}


************************************
Question ID: 468

public String validateIP(String queryIP) {
    String[] ipv4Parts = queryIP.split("\\.", -1);
    String[] ipv6Parts = queryIP.split(":", -1);

    if (ipv4Parts.length == 4) {
        if (isValidIPv4(ipv4Parts)) return "IPv4";
    } else if (ipv6Parts.length == 8) {
        if (isValidIPv6(ipv6Parts)) return "IPv6";
    }

    return "Neither";
}

private boolean isValidIPv4(String[] parts) {
    for (String part : parts) {
        if (part.length() == 0 || part.length() > 3 || (part.length() > 1 && part.charAt(0) == '0')) return false;

        int num = 0;
        for (char ch : part.toCharArray()) {
            if (!Character.isDigit(ch)) return false;
            num = num * 10 + (ch - '0');
        }

        if (num < 0 || num > 255) return false;
    }

    return true;
}

private boolean isValidIPv6(String[] parts) {
    for (String part : parts) {
        if (part.length() == 0 || part.length() > 4) return false;

        for (char ch : part.toCharArray()) {
            if (!Character.isDigit(ch) && !(ch >= 'a' && ch <= 'f') && !(ch >= 'A' && ch <= 'F')) return false;
        }
    }

    return true;
}

-----
public String validateIP(String queryIP) 
    // Your code here
}

************************************
Question ID: 469

public boolean isConvex(int[][] points) {
    int n = points.length;
    int pre = 0, cur = 0;
    
    for (int i = 0; i < n; ++i) {
        int x1 = points[(i + 1) % n][0] - points[i][0];
        int y1 = points[(i + 1) % n][1] - points[i][1];
        int x2 = points[(i + 2) % n][0] - points[(i + 1) % n][0];
        int y2 = points[(i + 2) % n][1] - points[(i + 1) % n][1];
        cur = x1 * y2 - x2 * y1;
        
        if (cur == 0)
            continue;
        if (cur * pre < 0)
            return false;
        pre = cur;
    }

    return true;
}

-----
public boolean isConvex(int[][] points) 
    // Your code here
}

************************************
Question ID: 470

public int rand7() ; // Provided API

public int rand10() {
    int result;
    do {
        result = (rand7() - 1) * 7 + rand7();
    } while (result > 40);
    return result % 10 + 1;
}

-----
public int rand7() ; // Provided API

public int rand10() 
    // Your code here
}

************************************
Question ID: 471

String encode(String s) {
    int n = s.length();
    for (int i = n / 2; i > 0; i--) {
        if (n % i == 0) {
            int reps = n / i;
            String sub = s.substring(0, i);
            StringBuilder composed = new StringBuilder();
            for (int j = 0; j < reps; j++) {
                composed.append(sub);
            }
            if (s.equals(composed.toString())) {
                return reps + "[" + sub + "]";
            }
        }
    }
    return s;
}

-----
String encode(String s) 
    // Your code here
}

************************************
Question ID: 472

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class Solution {
    public boolean isConcatenated(String word, Set<String> wordDict) {
        int n = word.length();
        boolean[] dp = new boolean[n + 1];
        dp[0] = true;

        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j < i; ++j) {
                if (dp[j] && wordDict.contains(word.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[n];
    }

    public List<String> findAllConcatenatedWords(String[] words) {
        Set<String> wordDict = new HashSet<>();
        for (String word : words) {
            wordDict.add(word);
        }

        List<String> result = new ArrayList<>();
        for (String word : words) {
            if (isConcatenated(word, wordDict)) {
                result.add(word);
            }
        }

        return result;
    }
}

-----
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class Solution 
    // Your code here
}

************************************
Question ID: 473

import java.util.Arrays;

public class Solution {
    public boolean makesquare(int[] matchsticks) {
        if (matchsticks == null || matchsticks.length < 4) return false;
        int sum = 0;
        for (int matchstick : matchsticks) sum += matchstick;
        if (sum % 4 != 0) return false;
        int target = sum / 4;
        Arrays.sort(matchsticks);
        reverse(matchsticks);
        int[] sums = new int[4];
        return dfs(matchsticks, sums, target, 0);
    }

    private void reverse(int[] nums) {
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;
            left++;
            right--;
        }
    }

    private boolean dfs(int[] matchsticks, int[] sums, int target, int index) {
        if (index == matchsticks.length) {
            return sums[0] == target && sums[1] == target && sums[2] == target;
        }
        for (int i = 0; i < 4; i++) {
            if (sums[i] + matchsticks[index] <= target) {
                sums[i] += matchsticks[index];
                if (dfs(matchsticks, sums, target, index + 1)) return true;
                sums[i] -= matchsticks[index];
            }
        }
        return false;
    }
}


-----
import java.util.Arrays;

public class Solution 
    // Your code here
}


************************************
Question ID: 474

import java.util.Arrays;

public int findMaxForm(String[] strs, int m, int n) {
    int[][] dp = new int[m + 1][n + 1];
    
    for (String str: strs) {
        int ones = (int) str.chars().filter(ch -> ch == '1').count();
        int zeros = str.length() - ones;
        
        for (int i = m; i >= zeros; --i) {
            for (int j = n; j >= ones; --j) {
                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);
            }
        }
    }
    return dp[m][n];
}

-----
import java.util.Arrays;

public int findMaxForm(String[] strs, int m, int n) 
    // Your code here
}

************************************
Question ID: 475

public int findRadius(int[] houses, int[] heaters) {
    Arrays.sort(houses);
    Arrays.sort(heaters);
    int result = 0;
    int i = 0;

    for (int house : houses) {
        while (i < heaters.length - 1 &&
               Math.abs(heaters[i + 1] - house) <= Math.abs(heaters[i] - house)) {
            i++;
        }
        result = Math.max(result, Math.abs(heaters[i] - house));
    }
    return result;
}

-----
public int findRadius(int[] houses, int[] heaters) 
    // Your code here
}

************************************
Question ID: 476

public int findComplement(int num) {
    int bitLength = 0;
    int mask = num;
    while (mask > 0) {
        mask >>= 1;
        bitLength++;
    }
    int allOnes = (1 << bitLength) - 1;

    return num ^ allOnes;
}

-----
public int findComplement(int num) 
    // Your code here
}

************************************
Question ID: 477

public int totalHammingDistance(int[] nums) {
    int totalDistance = 0, n = nums.length;
    
    for (int i = 0; i < 32; ++i) {
        int bitCount = 0;
        for (int num : nums) {
            bitCount += (num >> i) & 1;
        }
        totalDistance += bitCount * (n - bitCount);
    }
    
    return totalDistance;
}

-----
public int totalHammingDistance(int[] nums) 
    // Your code here
}

************************************
Question ID: 478

import java.util.Random;

public class Solution {
    private double radius;
    private double x_center;
    private double y_center;
    private Random random;

    public Solution(double radius, double x_center, double y_center) {
        this.radius = radius;
        this.x_center = x_center;
        this.y_center = y_center;
        random = new Random();
    }

    public double[] randPoint() {
        double r = Math.sqrt(random.nextDouble()) * radius;
        double theta = random.nextDouble() * 2 * Math.PI;
        return new double[]{x_center + r * Math.cos(theta), y_center + r * Math.sin(theta)};
    }
}

-----
import java.util.Random;

public class Solution 
    // Your code here
}

************************************
Question ID: 479

int largestPalindrome(int n) {
    if (n == 1) return 9;
    int upper_limit = (int) Math.pow(10, n) - 1;
    int lower_limit = upper_limit / 10;
    for (int i = upper_limit; i > lower_limit; --i) {
        long temp = i;
        long reverse = 0;
        while (temp != 0) {
            reverse = reverse * 10 + temp % 10;
            temp /= 10;
        }
        long palindrome = i * (long) Math.pow(10, n) + reverse;
        for (long j = upper_limit; j > lower_limit; --j) {
            long product = palindrome / j;
            if (palindrome % j == 0 && product <= upper_limit) {
                return (int) (palindrome % 1337);
            }
        }
    }
    return -1;
}

-----
int largestPalindrome(int n) 
    // Your code here
}

************************************
Question ID: 480

import java.util.TreeMap;

public double[] medianSlidingWindow(int[] nums, int k) {
    TreeMap<Integer, Integer> window = new TreeMap<>();
    int n = nums.length;
    double[] result = new double[n - k + 1];

    for (int i = 0; i < k; i++) {
        window.put(nums[i], window.getOrDefault(nums[i], 0) + 1);
    }

    for (int i = k; i <= n; i++) {
        int cnt = 0, mid1 = 0, mid2 = 0;
        for (Integer num : window.keySet()) {
            cnt += window.get(num);
            if (cnt >= (k + 1) / 2 && mid1 == 0) {
                mid1 = num;
            }
            if (cnt >= (k + 2) / 2) {
                mid2 = num;
                break;
            }
        }

        result[i - k] = ((double) mid1 + mid2) / 2;

        if (i < n) {
            window.put(nums[i], window.getOrDefault(nums[i], 0) + 1);
            window.put(nums[i - k], window.get(nums[i - k]) - 1);
            if (window.get(nums[i - k]) == 0) {
                window.remove(nums[i - k]);
            }
        }
    }

    return result;
}


-----
import java.util.TreeMap;

public double[] medianSlidingWindow(int[] nums, int k) 
    // Your code here
}


************************************
Question ID: 481

public int magicalString(int n) {
    if (n == 0) return 0;
    if (n <= 3) return 1;
    
    int[] magic = new int[n + 1];
    magic[0] = 1;
    magic[1] = 2;
    magic[2] = 2;
    int count_ones = 1;
    int index = 2;
    int value = 1;
    
    while (index < n) {
        for (int i = 0; i < magic[index] && index < n; i++) {
            magic[++index] = value;
            if (value == 1) count_ones++;
        }
        value = 3 - value;
    }
    
    return count_ones;
}


-----
public int magicalString(int n) 
    // Your code here
}


************************************
Question ID: 482

public String licenseKeyFormatting(String s, int k) {
    StringBuilder result = new StringBuilder();
    int count = 0;
    for (int i = s.length() - 1; i >= 0; i--) {
        if (s.charAt(i) != '-') {
            if (count == k) {
                result.append('-');
                count = 0;
            }
            result.append(Character.toUpperCase(s.charAt(i)));
            count++;
        }
    }
    return result.reverse().toString();
}

-----
public String licenseKeyFormatting(String s, int k) 
    // Your code here
}

************************************
Question ID: 483

public class SmallestGoodBase {
    public String smallestGoodBase(String n) {
        long num_n = Long.parseLong(n);
        
        for(int m = (int)(Math.log(num_n)/Math.log(2)) + 1; m >= 1; m--) {
            long k = (long)Math.pow((double)num_n, 1.0 / m);
            long sum = 0;
            for(int i=0; i <= m; i++) {
                sum = sum * k + 1;
            }
            if(sum == num_n) {
                return String.valueOf(k);
            }
        }
        
        return "-1";
    }
}

-----
public class SmallestGoodBase 
    // Your code here
}

************************************
Question ID: 484

import java.util.*;

class Solution {
    public int[] findPermutation(String s) {
        int[] perm = new int[s.length() + 1];
        int left = 1;
        for(int i = 0; i < s.length(); i++) {
            if(s.charAt(i) == 'I') {
                perm[i] = left++;
                while(i + 1 < s.length() && s.charAt(i + 1) == 'D')
                    i++;
            }
        }
        perm[s.length()] = left++;
        for(int i = s.length() - 1; i >= 0; i--)
            if(s.charAt(i) == 'D')
                perm[i] = left++;
        return perm;
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 485

public int findMaxConsecutiveOnes(int[] nums) {
    int maxConsecutive = 0, currentConsecutive = 0;
    for (int num : nums) {
        currentConsecutive = (num == 1) ? currentConsecutive + 1 : 0;
        maxConsecutive = Math.max(maxConsecutive, currentConsecutive);
    }
    return maxConsecutive;
}

-----
public int findMaxConsecutiveOnes(int[] nums) 
    // Your code here
}

************************************
Question ID: 486

public boolean canWin(int[] nums) {
    int n = nums.length;
    int[][] dp = new int[n][n];
    for (int i = 0; i < n; i++) {
        dp[i][i] = nums[i];
    }
    for (int len = 1; len < n; len++) {
        for (int i = 0; i < n - len; i++) {
            int j = i + len;
            dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);
        }
    }
    return dp[0][n - 1] >= 0;
}


-----
public boolean canWin(int[] nums) 
    // Your code here
}


************************************
Question ID: 487

public int findMaxConsecutiveOnes(int[] nums) {
    int maxCount = 0, countZeros = 0, left = 0;
    for (int right = 0; right < nums.length; ++right) {
        if (nums[right] == 0) countZeros++;
        while (countZeros > 1) {
            if (nums[left++] == 0) countZeros--;
        }
        maxCount = Math.max(maxCount, right - left + 1);
    }
    return maxCount;
}

-----
public int findMaxConsecutiveOnes(int[] nums) 
    // Your code here
}

************************************
Question ID: 488

import java.util.*;

class Solution {
    public int findMinStep(String board, String hand) {
        HashMap<Character, Integer> handMap = new HashMap<>();
        for (char c : hand.toCharArray()) handMap.put(c, handMap.getOrDefault(c, 0) + 1);

        return findMinStepHelper(board, new HashMap<String, Integer>(), handMap);
    }

    private int findMinStepHelper(String board, HashMap<String, Integer> memo, HashMap<Character, Integer> hand) {
        if (board.isEmpty()) return 0;
        if (memo.containsKey(board)) return memo.get(board);

        int result = Integer.MAX_VALUE;
        for (int i = 0, j = 0; i < board.length(); i = j) {
            while (j < board.length() && board.charAt(i) == board.charAt(j)) ++j;
            char color = board.charAt(i);
            int required = 3 - (j - i);
            if (hand.getOrDefault(color, 0) >= required) {
                hand.put(color, hand.get(color) - required);
                String nextBoard = board.substring(0, i) + board.substring(j);
                int tmp = findMinStepHelper(nextBoard, memo, hand);
                if (tmp != -1) result = Math.min(result, tmp + required);
                hand.put(color, hand.get(color) + required);
            }
        }

        int res = (result == Integer.MAX_VALUE) ? -1 : result;
        memo.put(board, res);
        return res;
    }
}


-----
import java.util.*;

class Solution 
    // Your code here
}


************************************
Question ID: 489

public class Solution {
    private int comb(int n, int r) {
        if(r > n - r) r = n - r;
        long res = 1;
        for(int i = 1; i <= r; i++) {
            res *= n - r + i;
            res /= i;
        }
        return (int)res;
    }

    public String kthSmallestPath(int[] destination, int k) {
        int row = destination[0];
        int col = destination[1];
        StringBuilder ans = new StringBuilder();

        for(int i = 0; i < row + col; i++) {
            if(row == 0) {
                ans.append('H');
                col--;
            } else if(col == 0) {
                ans.append('V');
                row--;
            } else if(k <= comb(row + col - 1, row - 1)) {
                ans.append('H');
                col--;
            } else {
                ans.append('V');
                k -= comb(row + col - 1, row - 1);
                row--;
            }
        }

        return ans.toString();
    }
}


-----
public class Solution 
    // Your code here
}


************************************
Question ID: 490

public boolean hasPath(int[][] maze, int[] start, int[] destination) {
    int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    Queue<int[]> q = new LinkedList<>();
    q.add(start);
    while (!q.isEmpty()) {
        int[] curr = q.poll();
        int x = curr[0], y = curr[1];
        if (x == destination[0] && y == destination[1]) return true;
        for (int[] dir : dirs) {
            int i = x, j = y;
            while (i + dir[0] >= 0 && i + dir[0] < maze.length && j + dir[1] >= 0 && j + dir[1] < maze[0].length && maze[i + dir[0]][j + dir[1]] == 0) {
                i += dir[0];
                j += dir[1];
            }
            if (maze[i][j] == 0) {
                maze[i][j] = 1;
                q.add(new int[]{i, j});
            }
        }
    }
    return false;
}

-----
public boolean hasPath(int[][] maze, int[] start, int[] destination) 
    // Your code here
}

************************************
Question ID: 491

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public List<List<Integer>> findSubsequences(int[] nums) {
    Set<List<Integer>> res = new HashSet<>();
    List<Integer> path = new ArrayList<>();
    dfs(nums, 0, path, res);
    return new ArrayList<>(res);
}

private void dfs(int[] nums, int start, List<Integer> path, Set<List<Integer>> res) {
    if (path.size() >= 2) {
        res.add(new ArrayList<>(path));
    }
    for (int i = start; i < nums.length; i++) {
        if (!path.isEmpty() && path.get(path.size() - 1) > nums[i]) {
            continue;
        }
        path.add(nums[i]);
        dfs(nums, i + 1, path, res);
        path.remove(path.size() - 1);
    }
}

-----
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public List<List<Integer>> findSubsequences(int[] nums) 
    // Your code here
}

************************************
Question ID: 492

public int[] constructRectangle(int area) {
    int width = (int)Math.sqrt(area);
    while(area % width != 0) {
        width--;
    }
    int length = area / width;
    return new int[]{length, width};
}

-----
public int[] constructRectangle(int area) 
    // Your code here
}

************************************
Question ID: 493

public int reversePairs(int[] nums) {
    return mergeSort(nums, 0, nums.length - 1, new int[nums.length]);
}

private int mergeSort(int[] nums, int left, int right, int[] temp) {
    if (left >= right) {
        return 0;
    }
    int mid = left + (right - left) / 2;
    int count = mergeSort(nums, left, mid, temp) + mergeSort(nums, mid + 1, right, temp);
    count += merge(nums, left, mid, right, temp);
    
    return count;
}

private int merge(int[] nums, int left, int mid, int right, int[] temp) {
    int count = 0;
    System.arraycopy(nums, left, temp, left, right - left + 1);
    int j = mid + 1;
    for (int i = left; i <= mid; i++) {
        while (j <= right && (long) nums[i] > 2L * nums[j]) {
            j++;
        }
        count += j - (mid + 1);
    }
    int i = left;
    j = mid + 1;
    int k = left;
    while (i <= mid && j <= right) {
        if (temp[i] <= temp[j]) {
            nums[k++] = temp[i++];
        } else {
            nums[k++] = temp[j++];
        }
    }
    while (i <= mid) {
        nums[k++] = temp[i++];
    }
    while (j <= right) {
        nums[k++] = temp[j++];
    }
    
    return count;
}

-----
public int reversePairs(int[] nums) 
    // Your code here
}

************************************
Question ID: 494

public int findTargetSumWays(int[] nums, int target) {
    int sum = 0;
    for (int num : nums) sum += num;
    if (sum < target || (sum + target) % 2 != 0) return 0;
    int target_sum = (sum + target) / 2;
    int[] dp = new int[target_sum + 1];
    dp[0] = 1;
    for (int num : nums) {
        for (int j = target_sum; j >= num; j--) {
            dp[j] += dp[j - num];
        }
    }
    return dp[target_sum];
}


-----
public int findTargetSumWays(int[] nums, int target) 
    // Your code here
}


************************************
Question ID: 495

public int findPoisonedDuration(int[] timeSeries, int duration) {
    if (timeSeries.length == 0) return 0;
    int total = 0;
    for (int i = 1; i < timeSeries.length; ++i) {
        total += Math.min(timeSeries[i] - timeSeries[i - 1], duration);
    }
    return total + duration;
}

-----
public int findPoisonedDuration(int[] timeSeries, int duration) 
    // Your code here
}

************************************
Question ID: 496

import java.util.HashMap;
import java.util.Stack;

public int[] nextGreaterElement(int[] nums1, int[] nums2) {
    HashMap<Integer, Integer> nextGreater = new HashMap<>();
    Stack<Integer> stack = new Stack<>();

    for (int num : nums2) {
        while (!stack.isEmpty() && stack.peek() < num) {
            nextGreater.put(stack.pop(), num);
        }
        stack.push(num);
    }

    int[] result = new int[nums1.length];
    for (int i = 0; i < nums1.length; i++) {
        result[i] = nextGreater.getOrDefault(nums1[i], -1);
    }

    return result;
}

-----
import java.util.HashMap;
import java.util.Stack;

public int[] nextGreaterElement(int[] nums1, int[] nums2) 
    // Your code here
}

************************************
Question ID: 497

import java.util.Random;
import java.util.List;

class Solution {
    int[][] rects;
    int[] areas;
    int totalArea;
    Random random;

    public Solution(int[][] rects) {
        this.rects = rects;
        this.areas = new int[rects.length];
        this.totalArea = 0;
        this.random = new Random();

        for (int i = 0; i < rects.length; i++) {
            int area = (rects[i][2] - rects[i][0] + 1) * (rects[i][3] - rects[i][1] + 1);
            areas[i] = area;
            totalArea += area;
        }
    }

    public int[] pick() {
        int rnd = random.nextInt(totalArea);

        int idx = 0;
        while (rnd >= areas[idx]) {
            rnd -= areas[idx];
            idx++;
        }

        int x = rects[idx][0] + random.nextInt(rects[idx][2] - rects[idx][0] + 1);
        int y = rects[idx][1] + random.nextInt(rects[idx][3] - rects[idx][1] + 1);
        
        return new int[] {x, y};
    }
}


-----
import java.util.Random;
import java.util.List;

class Solution 
    // Your code here
}


************************************
Question ID: 498

import java.util.Arrays;

public int[] findDiagonalOrder(int[][] mat) {
    int m = mat.length;
    int n = mat[0].length;
    int[] result = new int[m * n];
    int row = 0, col = 0;
    for (int i = 0; i < m * n; i++) {
        result[i] = mat[row][col];
        if ((row + col) % 2 == 0) {
            if (col == n - 1) {
                row++;
            } else if (row == 0) {
                col++;
            } else {
                row--;
                col++;
            }
        } else {
            if (row == m - 1) {
                col++;
            } else if (col == 0) {
                row++;
            } else {
                row++;
                col--;
            }
        }
    }
    return result;
}

-----
import java.util.Arrays;

public int[] findDiagonalOrder(int[][] mat) 
    // Your code here
}

************************************
Question ID: 499

import java.util.*;

class Solution {
    public String findShortestWay(int[][] maze, int[] ball, int[] hole) {
        int m = maze.length, n = maze[0].length;
        int[][] dist = new int[m][n];
        for (int i = 0; i < m; ++i) Arrays.fill(dist[i], Integer.MAX_VALUE);
        String[] dirs = {"d", "l", "r", "u"};
        int[][] dirs_vector = {{1, 0}, {0, -1}, {0, 1}, {-1, 0}};
        dist[ball[0]][ball[1]] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((p1, p2) -> p1[0] != p2[0] ? p1[0] - p2[0] : p1[1] - p2[1]);
        pq.offer(new int[]{0, 0});
        
        while (!pq.isEmpty()) {
            int cur_dist = pq.peek()[0], cur_d = pq.peek()[1];
            String cur_path = pq.poll()[2];
            int x = ball[0], y = ball[1];
            for (char c : cur_path.toCharArray()) {
                if (c == 'd') x += dirs_vector[0][0];
                if (c == 'l') y += dirs_vector[1][1];
                if (c == 'r') y += dirs_vector[2][1];
                if (c == 'u') x += dirs_vector[3][0];
            }
            if (x == hole[0] && y == hole[1]) return cur_path;

            for (int k = 0; k < 4; ++k) {
                int dist_move = 0, r = x, c = y;
                while (r >= 0 && r < m && c >= 0 && c < n && maze[r][c] == 0 && (r != hole[0] || c != hole[1])) {
                    r += dirs_vector[k][0];
                    c += dirs_vector[k][1];
                    ++dist_move;
                }
                r -= dirs_vector[k][0];
                c -= dirs_vector[k][1];
                --dist_move;
                
                if (dist[x][y] + dist_move < dist[r][c]) {
                    dist[r][c] = dist[x][y] + dist_move;
                    pq.offer(new int[]{cur_dist + dist_move, cur_d * 4 + k, cur_path + dirs[k]});
                }
            }
        }
        
        return "impossible";
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 500

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;

public class Solution {
    public String[] findWords(String[] words) {
        HashSet<Character>[] rows = new HashSet[] {
            new HashSet<Character>() {{
                add('q'); add('w'); add('e'); add('r'); add('t');
                add('y'); add('u'); add('i'); add('o'); add('p');
            }},
            new HashSet<Character>() {{
                add('a'); add('s'); add('d'); add('f'); add('g');
                add('h'); add('j'); add('k'); add('l');
            }},
            new HashSet<Character>() {{
                add('z'); add('x'); add('c'); add('v'); add('b');
                add('n'); add('m');
            }}
        };
        List<String> res = new ArrayList<>();
        
        for (String word : words) {
            int row = -1;
            for (int i = 0; i < 3; i++) {
                if (rows[i].contains(Character.toLowerCase(word.charAt(0)))) {
                    row = i;
                    break;
                }
            }
            
            boolean isOneRow = true;
            for (char letter : word.toCharArray()) {
                if (!rows[row].contains(Character.toLowerCase(letter))) {
                    isOneRow = false;
                    break;
                }
            }
            
            if (isOneRow)
                res.add(word);
        }
        
        return res.toArray(new String[0]);
    }
}


-----
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;

public class Solution 
    // Your code here
}


************************************
Question ID: 501

public List<Integer> findMode(TreeNode root) {
    List<Integer> modes = new ArrayList<>();
    if (root == null) return modes;
    
    Map<Integer, Integer> frequencyMap = new HashMap<>();
    Stack<TreeNode> stack = new Stack<>();
    TreeNode currentNode = root;
    int maxFrequency = 0;
    
    while (currentNode != null || !stack.isEmpty()) {
        while (currentNode != null) {
            stack.add(currentNode);
            currentNode = currentNode.left;
        }
        currentNode = stack.pop();
        frequencyMap.put(currentNode.val, frequencyMap.getOrDefault(currentNode.val, 0) + 1);
        maxFrequency = Math.max(maxFrequency, frequencyMap.get(currentNode.val));
        currentNode = currentNode.right;
    }
    
    for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {
        if (entry.getValue() == maxFrequency) modes.add(entry.getKey());
    }
    
    return modes;
}

-----
public List<Integer> findMode(TreeNode root) 
    // Your code here
}

************************************
Question ID: 502

import java.util.PriorityQueue;
import java.util.Arrays;

public class Solution {
    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
        int[][] project_pool = new int[profits.length][2];
        
        for (int i = 0; i < profits.length; i++) {
            project_pool[i] = new int[] {capital[i], profits[i]};
        }
        
        Arrays.sort(project_pool, (a, b) -> a[0] - b[0]);
        
        PriorityQueue<Integer> profit_pool = new PriorityQueue<>((a, b) -> b - a);
        int index = 0;
        
        for (int i = 0; i < k; i++) {
            while (index < project_pool.length &&
                   project_pool[index][0] <= w) {
                profit_pool.add(project_pool[index++][1]);
            }
            
            if (!profit_pool.isEmpty()) {
                w += profit_pool.poll();
            } else {
                break;
            }
        }
        
        return w;
    }
}

-----
import java.util.PriorityQueue;
import java.util.Arrays;

public class Solution 
    // Your code here
}

************************************
Question ID: 503

import java.util.Stack;

public int[] nextGreaterElements(int[] nums) {
    int n = nums.length;
    int[] result = new int[n];
    Stack<Integer> stack = new Stack<>();
    
    for (int i = 0; i < n * 2; i++) {
        int index = i % n;
        while (!stack.isEmpty() && nums[stack.peek()] < nums[index]) {
            result[stack.pop()] = nums[index];
        }
        if (i < n) {
            stack.push(index);
        }
    }
    return result;
}

-----
import java.util.Stack;

public int[] nextGreaterElements(int[] nums) 
    // Your code here
}

************************************
Question ID: 504

public String convertToBase7(int num) {
    if (num == 0) return "0";
    StringBuilder result = new StringBuilder();
    boolean negative = num < 0;
    if (negative) num *= -1;
    while (num > 0) {
        result.insert(0, num % 7);
        num /= 7;
    }
    return negative ? "-" + result.toString() : result.toString();
}

-----
public String convertToBase7(int num) 
    // Your code here
}

************************************
Question ID: 505

import java.util.PriorityQueue;

public int shortestDistance(int[][] maze, int[] start, int[] destination) {
    int m = maze.length, n = maze[0].length;
    int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    int[][] dist = new int[m][n];

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            dist[i][j] = -1;
        }
    }

    PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> a[2] - b[2]);

    dist[start[0]][start[1]] = 0;
    q.offer(new int[]{start[0], start[1], 0});

    while (!q.isEmpty()) {
        int[] cur = q.poll();
        int x = cur[0], y = cur[1];

        for (int[] dir : directions) {
            int newX = x + dir[0];
            int newY = y + dir[1];
            int step = 0;

            while (newX >= 0 && newX < m && newY >= 0 && newY < n && maze[newX][newY] == 0) {
                newX += dir[0];
                newY += dir[1];
                step++;
            }

            newX -= dir[0];
            newY -= dir[1];

            if (dist[newX][newY] == -1 || dist[x][y] + step < dist[newX][newY]) {
                dist[newX][newY] = dist[x][y] + step;
                q.offer(new int[]{newX, newY, dist[newX][newY]});
            }
        }
    }

    return dist[destination[0]][destination[1]];
}


-----
import java.util.PriorityQueue;

public int shortestDistance(int[][] maze, int[] start, int[] destination) 
    // Your code here
}


************************************
Question ID: 506

import java.util.Arrays;

public int[] findRelativeRanks(int[] score) {
    Integer[] rank_sort = new Integer[score.length];
    for(int i = 0; i < score.length; ++i) rank_sort[i] = i;
    Arrays.sort(rank_sort, (i1, i2) -> Integer.compare(score[i2], score[i1]));
    int[] result = new int[score.length];
    for(int i = 0; i < rank_sort.length; ++i) result[rank_sort[i]] = i + 1;
    return result;
}


-----
import java.util.Arrays;

public int[] findRelativeRanks(int[] score) 
    // Your code here
}


************************************
Question ID: 507

boolean checkPerfectNumber(int num) {
    if (num <= 1) return false;
    int sum = 1;
    for (int i = 2; i * i <= num; i++) {
        if (num % i == 0) {
            sum += i;
            if (i * i != num) sum += num / i;
        }
    }
    return sum == num;
}

-----
boolean checkPerfectNumber(int num) 
    // Your code here
}

************************************
Question ID: 508

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;

public int helper(TreeNode root, HashMap<Integer, Integer> counts) {
    if (root == null) return 0;
    int sum = root.val + helper(root.left, counts) + helper(root.right, counts);
    counts.put(sum, counts.getOrDefault(sum, 0) + 1);
    return sum;
}

public int[] findFrequentTreeSum(TreeNode root) {
    if (root == null) return new int[0];
    HashMap<Integer, Integer> counts = new HashMap<>();
    helper(root, counts);
    int maxCount = 0;
    for (int count : counts.values()) {
        maxCount = Math.max(count, maxCount);
    }
    List<Integer> list = new LinkedList<>();
    for (int key : counts.keySet()) {
        if (counts.get(key) == maxCount) list.add(key);
    }
    return list.stream().mapToInt(i -> i).toArray();
}


-----
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;

public int helper(TreeNode root, HashMap<Integer, Integer> counts) 
    // Your code here
}


************************************
Question ID: 509

public int fib(int n) {
    if(n < 2) {
        return n;
    }
    int a = 0, b = 1, c;
    for(int i = 2; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    return b;
}

-----
public int fib(int n) 
    // Your code here
}

************************************
Question ID: 513

public int findBottomLeftValue(TreeNode root) {
    int[] maxDepth = new int[1];
    int[] result = new int[1];
    helper(root, 1, maxDepth, result);
    return result[0];
}

private void helper(TreeNode node, int depth, int[] maxDepth, int[] result) {
    if (node == null) return;
    if (depth > maxDepth[0]) {
        maxDepth[0] = depth;
        result[0] = node.val;
    }
    helper(node.left, depth+1, maxDepth, result);
    helper(node.right, depth+1, maxDepth, result);
}


-----
public int findBottomLeftValue(TreeNode root) 
    // Your code here
}


************************************
Question ID: 514

public int findRotateSteps(String ring, String key) {
    int n = ring.length(), m = key.length();
    int[][] dp = new int[m + 1][n];

    for (int i = m - 1; i >= 0; --i) {
        for (int j = 0; j < n; ++j) {
            dp[i][j] = Integer.MAX_VALUE;
            for (int k = 0; k < n; ++k) {
                if (ring.charAt(k) == key.charAt(i)) {
                    int diff = Math.abs(j - k);
                    int step = Math.min(diff, n - diff);
                    dp[i][j] = Math.min(dp[i][j], step + dp[i + 1][k]);
                }
            }
        }
    }

    return dp[0][0] + m;
}


-----
public int findRotateSteps(String ring, String key) 
    // Your code here
}


************************************
Question ID: 515

import java.util.*;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
}

public List<Integer> largestValues(TreeNode root) {
    if (root == null) return new ArrayList<>();
    List<Integer> result = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        int size = queue.size();
        int max_val = Integer.MIN_VALUE;
        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            max_val = Math.max(max_val, node.val);

            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        result.add(max_val);
    }
    return result;
}

-----
import java.util.*;

class TreeNode 
    // Your code here
}

************************************
Question ID: 516

public int longestPalindromeSubseq(String s) {
    int n = s.length();
    int[][] dp = new int[n][n];
    
    for (int i = n - 1; i >= 0; i--) {
        dp[i][i] = 1;
        for (int j = i + 1; j < n; j++) {
            if (s.charAt(i) == s.charAt(j)) {
                dp[i][j] = 2 + dp[i + 1][j - 1];
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[0][n - 1];
}

-----
public int longestPalindromeSubseq(String s) 
    // Your code here
}

************************************
Question ID: 517

public int findMinMoves(int[] machines) {
    int n = machines.length;
    int totalDresses = 0;
    for (int m : machines) totalDresses += m;
    if (totalDresses % n != 0) return -1;
    int average = totalDresses / n;
    int moves = 0, imbalance = 0;
    
    for (int i = 0; i < n; i++) {
        imbalance += machines[i] - average;
        moves = Math.max(moves, Math.max(Math.abs(imbalance), machines[i] - average));
    }
    
    return moves;
}

-----
public int findMinMoves(int[] machines) 
    // Your code here
}

************************************
Question ID: 518

public int change(int amount, int[] coins) {
    int[] dp = new int[amount + 1];
    dp[0] = 1;
    for (int coin : coins) {
        for (int i = coin; i <= amount; i++) {
            dp[i] += dp[i - coin];
        }
    }
    return dp[amount];
}

-----
public int change(int amount, int[] coins) 
    // Your code here
}

************************************
Question ID: 519

import java.util.Random;

class Solution {
    int m, n, total;
    int[][] matrix;
    Random random;

    public Solution(int m, int n) {
        this.m = m;
        this.n = n;
        total = m * n;
        matrix = new int[m][n];
        random = new Random();
    }

    public int[] flip() {
        int idx = random.nextInt(total);
        total--;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    if (idx == 0) {
                        matrix[i][j] = 1;
                        return new int[] { i, j };
                    }
                    idx--;
                }
            }
        }
        return new int[] { -1, -1 }; // This line should never be reached
    }

    public void reset() {
        total = m * n;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = 0;
            }
        }
    }
}


-----
import java.util.Random;

class Solution 
    // Your code here
}


************************************
Question ID: 520

public boolean detectCapitalUse(String word) {
    int numCapital = 0;
    for (char c : word.toCharArray()) {
        if (Character.isUpperCase(c)) numCapital++;
    }
    return numCapital == 0 || numCapital == word.length() || (numCapital == 1 && Character.isUpperCase(word.charAt(0)));
}


-----
public boolean detectCapitalUse(String word) 
    // Your code here
}


************************************
Question ID: 521

public int findLUSlength(String a, String b) {
    if (a.equals(b)) {
        return -1;
    }
    return Math.max(a.length(), b.length());
}

-----
public int findLUSlength(String a, String b) 
    // Your code here
}

************************************
Question ID: 522

import java.util.List;

public int findLUSlength(List<String> strs) {
    int maxLength = -1;
    for(int i = 0; i < strs.size(); ++i) {
        boolean isUncommon = true;
        for(int j = 0; j < strs.size(); ++j) {
            if(i != j && strs.get(j).contains(strs.get(i))) {
                isUncommon = false;
                break;
            }
        }
        if(isUncommon) {
            maxLength = Math.max(maxLength, strs.get(i).length());
        }
    }
    return maxLength;
}


-----
import java.util.List;

public int findLUSlength(List<String> strs) 
    // Your code here
}


************************************
Question ID: 523

import java.util.HashMap;

public boolean checkSubarraySum(int[] nums, int k) {
    int n = nums.length, sum = 0;
    HashMap<Integer, Integer> map = new HashMap<>();
    map.put(0, -1);
    for (int i = 0; i < n; i++) {
        sum += nums[i];
        if (k != 0) sum %= k;
        if (map.containsKey(sum)) {
            if (i - map.get(sum) > 1) return true;
        } else {
            map.put(sum, i);
        }
    }
    return false;
}

-----
import java.util.HashMap;

public boolean checkSubarraySum(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 524

import java.util.Arrays;

public String findLongestWord(String s, String[] dictionary) {
    String longest = "";
    Arrays.sort(dictionary);
    for (String word : dictionary) {
        if (isSubsequence(s, word)) {
            if (word.length() > longest.length()) {
                longest = word;
            }
        }
    }
    return longest;
}

private boolean isSubsequence(String s, String word) {
    int i = 0, j = 0;
    while (i < s.length() && j < word.length()) {
        if (s.charAt(i) == word.charAt(j)) {
            j++;
        }
        i++;
    }
    return j == word.length();
}


-----
import java.util.Arrays;

public String findLongestWord(String s, String[] dictionary) 
    // Your code here
}


************************************
Question ID: 525

public int findMaxLength(int[] nums) {
    HashMap<Integer, Integer> counts = new HashMap<>();
    counts.put(0, -1);
    int max_len = 0, count = 0;
    for (int i = 0; i < nums.length; i++) {
        count += (nums[i] == 1) ? 1 : -1;
        if (counts.containsKey(count))
            max_len = Math.max(max_len, i - counts.get(count));
        else
            counts.put(count, i);
    }
    return max_len;
}


-----
public int findMaxLength(int[] nums) 
    // Your code here
}


************************************
Question ID: 526

int countArrangement(int n) {
    int[] res = new int[]{0};
    boolean[] visited = new boolean[n+1];
    helper(n, 1, visited, res);
    return res[0];
}

void helper(int n, int idx, boolean[] visited, int[] res) {
    if (idx > n) {
        res[0]++;
    }

    for(int i=1; i<=n; i++){
        if (!visited[i] && (idx % i == 0 || i % idx == 0)) {
            visited[i] = true;
            helper(n, idx+1, visited, res);
            visited[i] = false;
        }
    }
}

-----
int countArrangement(int n) 
    // Your code here
}

************************************
Question ID: 527

import java.util.HashMap;
import java.util.Map;
import java.util.Arrays;

public String[] wordsAbbreviation(String[] words) {
    int n = words.length;
    String[] abbr = new String[n];
    int[] prefixLen = new int[n];

    for (int i = 0; i < n; i++) {
        abbr[i] = abbrev(words[i], 1);
        prefixLen[i] = 1;
    }

    for (int i = 0; i < n; i++) {
        while (true) {
            Map<String, int[]> groups = new HashMap<>();
            for (int j = 0; j < n; j++) {
                if (abbr[i].equals(abbr[j])) {
                    if (!groups.containsKey(abbr[j])) {
                        groups.put(abbr[j], new int[]{0, 0});
                    }
                    groups.get(abbr[j])[0]++;
                    groups.get(abbr[j])[1] = j;
                }
            }
            if (groups.get(abbr[i])[0] == 1) {
                break;
            }
            abbr[groups.get(abbr[i])[1]] = abbrev(words[groups.get(abbr[i])[1]], ++prefixLen[groups.get(abbr[i])[1]]);
            abbr[i] = abbrev(words[i], ++prefixLen[i]);
        }
    }

    return abbr;
}

private String abbrev(String s, int k) {
    int n = s.length();
    if (k >= n - 2) {
        return s;
    }
    return s.substring(0, k + 1) + Integer.toString(n - k - 2) + s.charAt(n - 1);
}

-----
import java.util.HashMap;
import java.util.Map;
import java.util.Arrays;

public String[] wordsAbbreviation(String[] words) 
    // Your code here
}

************************************
Question ID: 529


-----

    // Your code here

************************************
Question ID: 531

public int findLonelyPixel(char[][] picture) {
    int m = picture.length, n = picture[0].length;
    int[] row = new int[m], col = new int[n];
    
    for(int i = 0; i < m; ++i) {
        for(int j = 0; j < n; ++j) {
            if(picture[i][j] == 'B') {
                row[i]++;
                col[j]++;
            }
        }
    }
    
    int lonely = 0;
    for(int i = 0; i < m; ++i) {
        for(int j = 0; j < n; ++j) {
            if(picture[i][j] == 'B' && row[i] == 1 && col[j] == 1) {
                lonely++;
            }
        }
    }
    
    return lonely;
}

-----
public int findLonelyPixel(char[][] picture) 
    // Your code here
}

************************************
Question ID: 532

import java.util.HashMap;
import java.util.HashSet;

public int findPairs(int[] nums, int k) {
    if (k < 0) return 0;
    HashSet<Integer> starters = new HashSet<>();
    HashMap<Integer, Integer> occurrences = new HashMap<>();
    for (int num : nums) {
        if (occurrences.containsKey(num + k)) starters.add(num);
        if (occurrences.containsKey(num - k)) starters.add(num - k);
        occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);
    }
    return starters.size();
}

-----
import java.util.HashMap;
import java.util.HashSet;

public int findPairs(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 533

public int findBlackPixel(char[][] picture, int target) {
    int m = picture.length;
    int n = picture[0].length;
    int[] rows = new int[m];
    int[] cols = new int[n];
    Map<String, Integer> rowCounts = new HashMap<>();
    for (int i = 0; i < m; ++i) {
        StringBuilder row = new StringBuilder();
        for (int j = 0; j < n; ++j) {
            if (picture[i][j] == 'B') {
                rows[i]++;
                cols[j]++;
            }
            row.append(picture[i][j]);
        }
        String rowStr = row.toString();
        if (rows[i] == target)
            rowCounts.put(rowStr, rowCounts.getOrDefault(rowStr, 0) + 1);
    }
    int ans = 0;
    for (Map.Entry<String, Integer> entry : rowCounts.entrySet()) {
        String row = entry.getKey();
        int count = entry.getValue();
        if (count == target) {
            for (int j = 0; j < n; ++j) {
                if (row.charAt(j) == 'B' && cols[j] == target)
                    ans += count;
            }
        }
    }
    return ans;
}

-----
public int findBlackPixel(char[][] picture, int target) 
    // Your code here
}

************************************
Question ID: 535

import java.util.HashMap;
import java.util.Random;

public class Solution {
    HashMap<String, String> urlMap = new HashMap<>();
    String alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    public String encode(String longUrl) {
        StringBuilder keyBuilder;
        String key;

        do {
            keyBuilder = new StringBuilder();

            for (int i = 0; i < 6; i++) {
                keyBuilder.append(alphabet.charAt(new Random().nextInt(alphabet.length())));
            }

            key = keyBuilder.toString();
        } while (urlMap.containsKey(key));

        urlMap.put(key, longUrl);
        return "http://tinyurl.com/" + key;
    }

    public String decode(String shortUrl) {
        return urlMap.get(shortUrl.substring(19));
    }
}

-----
import java.util.HashMap;
import java.util.Random;

public class Solution 
    // Your code here
}

************************************
Question ID: 537

public String complexNumberMultiply(String num1, String num2) {
    String[] tokens1 = num1.split("\\+|i");
    String[] tokens2 = num2.split("\\+|i");
    int real1 = Integer.parseInt(tokens1[0]);
    int imag1 = Integer.parseInt(tokens1[1]);
    int real2 = Integer.parseInt(tokens2[0]);
    int imag2 = Integer.parseInt(tokens2[1]);

    int real = real1 * real2 - imag1 * imag2;
    int imag = real1 * imag2 + real2 * imag1;

    return real + "+" + imag + "i";
}

-----
public String complexNumberMultiply(String num1, String num2) 
    // Your code here
}

************************************
Question ID: 539

import java.util.Collections;
import java.util.List;
import java.util.ArrayList;

public int findMinDifference(List<String> timePoints) {
    Collections.sort(timePoints);
    int minDifference = Integer.MAX_VALUE;

    for (int i = 0; i < timePoints.size(); ++i) {
        int curDifference = Math.abs((Integer.parseInt(timePoints.get(i).substring(0, 2)) * 60 + Integer.parseInt(timePoints.get(i).substring(3, 5))) - (Integer.parseInt(timePoints.get((i + 1) % timePoints.size()).substring(0, 2)) * 60 + Integer.parseInt(timePoints.get((i + 1) % timePoints.size()).substring(3, 5))));
        minDifference = Math.min(minDifference, curDifference > 720 ? 1440 - curDifference : curDifference);
    }

    return minDifference;
}

-----
import java.util.Collections;
import java.util.List;
import java.util.ArrayList;

public int findMinDifference(List<String> timePoints) 
    // Your code here
}

************************************
Question ID: 540

public int singleNonDuplicate(int[] nums) {
    int low = 0, high = nums.length - 1;
    while (low < high) {
        int mid = low + (high - low) / 2;
        if (mid % 2 == 1)
            mid--;
        if (nums[mid] == nums[mid + 1])
            low = mid + 2;
        else
            high = mid;
    }
    return nums[low];
}

-----
public int singleNonDuplicate(int[] nums) 
    // Your code here
}

************************************
Question ID: 541

public String reverseStr(String s, int k) {
    char[] chars = s.toCharArray();
    for (int i = 0; i < chars.length; i += 2 * k) {
        int left = i;
        int right = Math.min(i + k - 1, chars.length - 1);
        while (left < right) {
            char temp = chars[left];
            chars[left++] = chars[right];
            chars[right--] = temp;
        }
    }
    return new String(chars);
}

-----
public String reverseStr(String s, int k) 
    // Your code here
}

************************************
Question ID: 542

import java.util.Queue;
import java.util.LinkedList;

public int[][] updateMatrix(int[][] mat) {
    int m = mat.length;
    int n = mat[0].length;
    int[][] distance = new int[m][n];
    Queue<int[]> queue = new LinkedList<>();

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (mat[i][j] == 0) {
                distance[i][j] = 0;
                queue.add(new int[]{i, j});
            } else {
                distance[i][j] = Integer.MAX_VALUE;
            }
        }
    }

    int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    while (!queue.isEmpty()) {
        int[] current = queue.poll();
        int x = current[0];
        int y = current[1];

        for (int[] dir : directions) {
            int newX = x + dir[0];
            int newY = y + dir[1];
            if (newX >= 0 && newY >= 0 && newX < m && newY < n && distance[newX][newY] > distance[x][y] + 1) {
                distance[newX][newY] = distance[x][y] + 1;
                queue.add(new int[]{newX, newY});
            }
        }
    }
    return distance;
}


-----
import java.util.Queue;
import java.util.LinkedList;

public int[][] updateMatrix(int[][] mat) 
    // Your code here
}


************************************
Question ID: 544

public String findContestMatch(int n) {
    String[] matches = new String[n];
    for (int i = 1; i <= n; i++) {
        matches[i - 1] = Integer.toString(i);
    }

    while (n > 1) {
        for (int i = 0; i < n / 2; i++) {
            matches[i] = "(" + matches[i] + "," + matches[n - 1 - i] + ")";
        }
        n /= 2;
    }

    return matches[0];
}


-----
public String findContestMatch(int n) 
    // Your code here
}


************************************
Question ID: 546

public int removeBoxes(int[] boxes) {
    int[][][] dp = new int[100][100][100];
    return dfs(boxes, dp, 0, boxes.length - 1, 0);
}

private int dfs(int[] boxes, int[][][] dp, int l, int r, int k) {
    if (l > r) return 0;
    if (dp[l][r][k] != 0) return dp[l][r][k];

    while (r > l && boxes[r] == boxes[r - 1]) {r--; k++;}

    dp[l][r][k] = (k + 1) * (k + 1) + dfs(boxes, dp, l, r - 1, 0);

    for (int i = l; i < r; i++) {
        if (boxes[i] == boxes[r]) {
            dp[l][r][k] = Math.max(dp[l][r][k], dfs(boxes, dp, l, i, k + 1) + dfs(boxes, dp, i + 1, r - 1, 0));
        }
    }

    return dp[l][r][k];
}

-----
public int removeBoxes(int[] boxes) 
    // Your code here
}

************************************
Question ID: 547

public int findCircleNum(int[][] isConnected) {
    int provinces = 0;
    boolean[] visited = new boolean[isConnected.length];
    for (int i = 0; i < isConnected.length; i++) {
        if (!visited[i]) {
            dfs(isConnected, visited, i);
            provinces++;
        }
    }
    return provinces;
}

private void dfs(int[][] isConnected, boolean[] visited, int i) {
    visited[i] = true;
    for (int j = 0; j < isConnected.length; j++) {
        if (isConnected[i][j] == 1 && !visited[j]) {
            dfs(isConnected, visited, j);
        }
    }
}

-----
public int findCircleNum(int[][] isConnected) 
    // Your code here
}

************************************
Question ID: 548

boolean find_triplet_equal_sum(int[] nums) {
    int n = nums.length;
    int[] prefix_sum = new int[n + 1];

    for (int i = 0; i < n; ++i) {
        prefix_sum[i + 1] = prefix_sum[i] + nums[i];
    }

    for (int i = 1; i + 2 < n; ++i) {
        for (int j = i + 2; j + 1 < n; ++j) {
            for (int k = j + 2; k < n; ++k) {
                int s1 = prefix_sum[i];
                int s2 = prefix_sum[j] - prefix_sum[i + 1];
                int s3 = prefix_sum[k] - prefix_sum[j + 1];
                int s4 = prefix_sum[n] - prefix_sum[k + 1];
                if (s1 == s2 && s2 == s3 && s3 == s4) {
                    return true;
                }
            }
        }
    }
    return false;
}

-----
boolean find_triplet_equal_sum(int[] nums) 
    // Your code here
}

************************************
Question ID: 551

public boolean checkRecord(String s) {
    int late = 0, absent = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == 'A') {
            absent++;
            late = 0;
        } else if (s.charAt(i) == 'L') {
            late++;
        } else {
            late = 0;
        }

        if (absent >= 2 || late >= 3) return false;
    }
    return true;
}

-----
public boolean checkRecord(String s) 
    // Your code here
}

************************************
Question ID: 552

public int checkRecord(int n) {
    int M = 1000000007;
    long[] dp = new long[6];  // {latent state 0, latent state 1, ..., latent state 5}
    Arrays.fill(dp, 1);
    while (n-- > 0) {
        long[] next_dp = new long[6];
        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M;
        next_dp[1] = dp[0];
        next_dp[2] = dp[1];
        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M;
        next_dp[4] = dp[3];
        next_dp[5] = dp[4];
        dp = next_dp;
    }
    return (int) ((dp[0] + dp[1] + dp[2] +
                   dp[3] + dp[4] + dp[5]) % M);
}


-----
public int checkRecord(int n) 
    // Your code here
}


************************************
Question ID: 553

public String optimalDivision(int[] nums) {
    int n = nums.length;
    if (n == 1) return Integer.toString(nums[0]);
    if (n == 2) return Integer.toString(nums[0]) + "/" + Integer.toString(nums[1]);
    StringBuilder res = new StringBuilder(Integer.toString(nums[0]) + "/(");
    for (int i = 1; i < n - 1; ++i) {
        res.append(Integer.toString(nums[i])).append("/");
    }
    res.append(Integer.toString(nums[n - 1])).append(")");
    return res.toString();
}


-----
public String optimalDivision(int[] nums) 
    // Your code here
}


************************************
Question ID: 554

import java.util.List;
import java.util.HashMap;

public int leastBricks(List<List<Integer>> wall) {
    HashMap<Integer, Integer> edgeCount = new HashMap<>();
    int maxCount = 0;

    for (List<Integer> row : wall) {
        int edgePosition = 0;
        for (int i = 0; i < row.size() - 1; ++i) {
            edgePosition += row.get(i);
            edgeCount.put(edgePosition, edgeCount.getOrDefault(edgePosition, 0) + 1);
            maxCount = Math.max(maxCount, edgeCount.get(edgePosition));
        }
    }

    return wall.size() - maxCount;
}


-----
import java.util.List;
import java.util.HashMap;

public int leastBricks(List<List<Integer>> wall) 
    // Your code here
}


************************************
Question ID: 555

import java.util.*;

public String splitLoopedString(String[] strs) {
    String ans = "", cur = "";
    for (String s : strs) {
        String rev = new StringBuilder(s).reverse().toString();
        cur += (s.compareTo(rev) > 0) ? s : rev;
    }

    for (int i = 0, k = 0; i < strs.length; i++) {
        String rev = new StringBuilder(strs[i]).reverse().toString();
        for (String xstr : Arrays.asList(strs[i], rev)) {
            for (int j = 0; j < xstr.length(); j++) {
                String t = xstr.substring(j) + cur.substring(k + xstr.length()) + cur.substring(0, k) + xstr.substring(0, j);
                ans = ans.compareTo(t) > 0 ? ans : t;
            }
        }
        k += strs[i].length();
    }
    return ans;
}

-----
import java.util.*;

public String splitLoopedString(String[] strs) 
    // Your code here
}

************************************
Question ID: 556

import java.util.Arrays;

public class Main {
    public int nextGreaterElement(int n) {
        char[] number = String.valueOf(n).toCharArray();
        int i, j;
        for (i = number.length - 1; i > 0; i--) {
            if (number[i - 1] < number[i]) {
                break;
            }
        }

        if (i == 0) {
            return -1;
        }

        int x = number[i - 1], smallest = i;
        for (j = i + 1; j < number.length; j++) {
            if (number[j] > x && number[j] < number[smallest]) {
                smallest = j;
            }
        }

        char temp = number[i - 1];
        number[i - 1] = number[smallest];
        number[smallest] = temp;

        Arrays.sort(number, i, number.length);

        long result = Long.parseLong(new String(number));

        return (result <= Integer.MAX_VALUE) ? (int) result : -1;
    }
}

-----
import java.util.Arrays;

public class Main 
    // Your code here
}

************************************
Question ID: 557

import java.util.StringJoiner;

public String reverseWordsInString(String s) {
    String[] words = s.split(" ");
    for (int i = 0; i < words.length; i++) {
        words[i] = new StringBuilder(words[i]).reverse().toString();
    }
    return String.join(" ", words);
}

-----
import java.util.StringJoiner;

public String reverseWordsInString(String s) 
    // Your code here
}

************************************
Question ID: 560

public int subarraySum(int[] nums, int k) {
    Map<Integer, Integer> prefixSumFrequency = new HashMap<>();
    prefixSumFrequency.put(0, 1);
    int prefixSum = 0, result = 0;
    
    for (int num : nums) {
        prefixSum += num;
        result += prefixSumFrequency.getOrDefault(prefixSum - k, 0);
        prefixSumFrequency.put(prefixSum, prefixSumFrequency.getOrDefault(prefixSum, 0) + 1);
    }
    
    return result;
}

-----
public int subarraySum(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 561

import java.util.Arrays;

public int arrayPairSum(int[] nums) {
    Arrays.sort(nums);
    int sum = 0;
    for (int i = 0; i < nums.length; i += 2) {
        sum += nums[i];
    }
    return sum;
}

-----
import java.util.Arrays;

public int arrayPairSum(int[] nums) 
    // Your code here
}

************************************
Question ID: 562

public int longestLine(int[][] mat) {
    int rows = mat.length;
    int cols = mat[0].length;
    int max_length = 0;
    int[][][] dp = new int[rows][cols][4];

    for (int r = 0; r < rows; ++r) {
        for (int c = 0; c < cols; ++c) {
            if (mat[r][c] == 1) {
                dp[r][c][0] = r > 0 ? dp[r - 1][c][0] + 1 : 1;
                dp[r][c][1] = c > 0 ? dp[r][c - 1][1] + 1 : 1;
                dp[r][c][2] = (r > 0 && c > 0) ? dp[r - 1][c - 1][2] + 1 : 1;
                dp[r][c][3] = (r > 0 && c < cols - 1) ? dp[r - 1][c + 1][3] + 1 : 1;
                max_length = Math.max(max_length, Math.max(dp[r][c][0], Math.max(dp[r][c][1], Math.max(dp[r][c][2], dp[r][c][3]))));
            }
        }
    }
    return max_length;
}


-----
public int longestLine(int[][] mat) 
    // Your code here
}


************************************
Question ID: 563

public int findTilt(TreeNode root) {
    int[] tiltSum = new int[] {0};
    findTiltUtil(root, tiltSum);
    return tiltSum[0];
}

private int findTiltUtil(TreeNode root, int[] tiltSum) {
    if (root == null) {
        return 0;
    }

    int leftSum = findTiltUtil(root.left, tiltSum);
    int rightSum = findTiltUtil(root.right, tiltSum);

    tiltSum[0] += Math.abs(leftSum - rightSum);
    return root.val + leftSum + rightSum;
}


-----
public int findTilt(TreeNode root) 
    // Your code here
}


************************************
Question ID: 564

public class ClosestPalindrome {
    public static boolean isPalindrome(String str) {
        int left = 0;
        int right = str.length() - 1;
        while (left < right) {
            if (str.charAt(left) != str.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }

    public static int closestPalindrome(String n) {
        int num = Integer.parseInt(n);
        int left = num - 1;
        int right = num + 1;

        while (true) {
            if (isPalindrome(Integer.toString(left))) {
                return left;
            }
            if (isPalindrome(Integer.toString(right))) {
                return right;
            }
            left--;
            right++;
        }
    }
}

-----
public class ClosestPalindrome 
    // Your code here
}

************************************
Question ID: 565

public int arrayNesting(int[] nums) {
    int n = nums.length;
    int max_len = 0;
    for (int i = 0; i < n; ++i) {
        if (nums[i] != -1) {       
            int start = nums[i];
            int count = 0;
            while (nums[start] != -1) {
                int temp = start;
                start = nums[start];
                count++;
                nums[temp]=-1;
            }
            max_len = Math.max(max_len, count);
        }
    }
    return max_len;
}

-----
public int arrayNesting(int[] nums) 
    // Your code here
}

************************************
Question ID: 566

public int[][] matrixReshape(int[][] mat, int r, int c) {
    int m = mat.length;
    int n = mat[0].length;
    if (m * n != r * c) {
        return mat;
    }

    int[][] reshaped = new int[r][c];
    for (int i = 0; i < m * n; ++i) {
        reshaped[i / c][i % c] = mat[i / n][i % n];
    }

    return reshaped;
}

-----
public int[][] matrixReshape(int[][] mat, int r, int c) 
    // Your code here
}

************************************
Question ID: 567

public boolean checkInclusion(String s1, String s2) {
    if (s1.length() > s2.length()) return false;
    int[] s1_map = new int[26];
    int[] s2_map = new int[26];

    for (int i = 0; i < s1.length(); i++) {
        s1_map[s1.charAt(i) - 'a']++;
        s2_map[s2.charAt(i) - 'a']++;
    }

    for (int i = 0; i < s2.length() - s1.length(); i++) {
        if (Arrays.equals(s1_map, s2_map)) return true;
        s2_map[s2.charAt(i) - 'a']--;
        s2_map[s2.charAt(i + s1.length()) - 'a']++;
    }

    return Arrays.equals(s1_map, s2_map);
}


-----
public boolean checkInclusion(String s1, String s2) 
    // Your code here
}


************************************
Question ID: 568

public int maxVacationDays(int[][] flights, int[][] days) {
    int n = flights.length;
    int k = days[0].length;
    int[][] memo = new int[n][k];
    for (int i = 0; i < n; i++) {
        Arrays.fill(memo[i], -1);
    }
    return dfs(flights, days, 0, 0, memo);
}

private int dfs(int[][] flights, int[][] days, int week, int city, int[][] memo) {
    int numCities = flights.length;
    int numWeeks = days[0].length;

    if (week == numWeeks) {
        return 0;
    }

    if (memo[city][week] != -1) {
        return memo[city][week];
    }

    int maxVacation = days[city][week] + dfs(flights, days, week + 1, city, memo);

    for (int i = 0; i < numCities; i++) {
        if (flights[city][i] == 1) {
            maxVacation = Math.max(maxVacation, days[i][week] + dfs(flights, days, week + 1, i, memo));
        }
    }

    memo[city][week] = maxVacation;
    return maxVacation;
}


-----
public int maxVacationDays(int[][] flights, int[][] days) 
    // Your code here
}


************************************
Question ID: 572


```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
}

public boolean isSubtree(TreeNode root, TreeNode subRoot) {
    if (root == null) return false;
    if (isIdentical(root, subRoot)) return true;
    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);
}

public boolean isIdentical(TreeNode n1, TreeNode n2) {
    if (n1 == null || n2 == null) return n1 == n2;
    if (n1.val != n2.val) return false;
    return isIdentical(n1.left, n2.left) && isIdentical(n1.right, n2.right);
}
```


-----

```java
public class TreeNode 
    // Your code here
}
```


************************************
Question ID: 573

public int minDistance(int height, int width, int[] tree, int[] squirrel, int[][] nuts) {
    int totalDist = 0;
    int minDiff = Integer.MAX_VALUE;
    
    for (int[] nut : nuts) {
        int treeDist = Math.abs(tree[0] - nut[0]) + Math.abs(tree[1] - nut[1]);
        int squirrelDist = Math.abs(squirrel[0] - nut[0]) + Math.abs(squirrel[1] - nut[1]);
        
        totalDist += 2 * treeDist;
        minDiff = Math.min(minDiff, squirrelDist - treeDist);
    }
    
    return totalDist + minDiff;
}


-----
public int minDistance(int height, int width, int[] tree, int[] squirrel, int[][] nuts) 
    // Your code here
}


************************************
Question ID: 575

import java.util.HashSet;
import java.util.Set;

public int maxNumberOfCandies(int[] candyType) {
    Set<Integer> uniqueCandies = new HashSet<>();
    for (int type : candyType) {
        uniqueCandies.add(type);
    }
    return Math.min(uniqueCandies.size(), candyType.length / 2);
}


-----
import java.util.HashSet;
import java.util.Set;

public int maxNumberOfCandies(int[] candyType) 
    // Your code here
}


************************************
Question ID: 576

public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
    int MOD = 1000000007;
    int[][][] dp = new int[maxMove + 1][m][n];
    int[][] moves = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

    for (int k = 1; k <= maxMove; k++) {
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int[] move : moves) {
                    int ni = i + move[0], nj = j + move[1];
                    if (ni < 0 || ni >= m || nj < 0 || nj >= n) {
                        dp[k][i][j] = (dp[k][i][j] + 1) % MOD;
                    } else {
                        dp[k][i][j] = (dp[k][i][j] + dp[k - 1][ni][nj]) % MOD;
                    }
                }
            }
        }
    }
    return dp[maxMove][startRow][startColumn];
}

-----
public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) 
    // Your code here
}

************************************
Question ID: 581

import java.util.Arrays;

public int findUnsortedSubarray(int[] nums) {
    int[] sortedNums = nums.clone();
    Arrays.sort(sortedNums);
    int start = 0, end = nums.length - 1;
    while (start < nums.length && nums[start] == sortedNums[start]) start++;
    while (end > start && nums[end] == sortedNums[end]) end--;
    return end - start + 1;
}

-----
import java.util.Arrays;

public int findUnsortedSubarray(int[] nums) 
    // Your code here
}

************************************
Question ID: 582

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public List<Integer> killProcess(List<Integer> pid, List<Integer> ppid, int kill) {
    Map<Integer, List<Integer>> children = new HashMap<>();
    for (int i = 0; i < pid.size(); i++) {
        children.computeIfAbsent(ppid.get(i), k -> new ArrayList<>()).add(pid.get(i));
    }

    List<Integer> killed = new ArrayList<>();
    dfs(kill, children, killed);
    return killed;
}

private void dfs(int id, Map<Integer, List<Integer>> children, List<Integer> killed) {
    killed.add(id);
    for (int child : children.getOrDefault(id, new ArrayList<>())) {
        dfs(child, children, killed);
    }
}

-----
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public List<Integer> killProcess(List<Integer> pid, List<Integer> ppid, int kill) 
    // Your code here
}

************************************
Question ID: 583

public int minDistance(String word1, String word2) {
    int m = word1.length(), n = word2.length();
    int[][] dp = new int[m+1][n+1];

    for(int i = 0; i <= m; i++) {
        for(int j = 0; j <= n; j++) {
            if(i == 0 || j == 0)
                dp[i][j] = i + j;
            else if(word1.charAt(i-1) == word2.charAt(j-1))
                dp[i][j] = dp[i-1][j-1];
            else
                dp[i][j] = 1 + Math.min(dp[i-1][j], dp[i][j-1]);
        }
    }

    return dp[m][n];
}

-----
public int minDistance(String word1, String word2) 
    // Your code here
}

************************************
Question ID: 587

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Solution {
    private static int[][] fence(int[][] trees) {
        Arrays.sort(trees, (p, q) -> p[0] == q[0] ? p[1] - q[1] : p[0] - q[0]);
        List<int[]> hull = new ArrayList<>();
        for (int[] p : trees) {
            while (hull.size() >= 2 && crossProduct(hull.get(hull.size() - 2), hull.get(hull.size() - 1), p) > 0) {
                hull.remove(hull.size() - 1);
            }
            hull.add(p);
        }
        for (int i = trees.length - 1; i >= 0; i--) {
            int[] p = trees[i];
            while (hull.size() >= 2 && crossProduct(hull.get(hull.size() - 2), hull.get(hull.size() - 1), p) > 0) {
                hull.remove(hull.size() - 1);
            }
            hull.add(p);
        }
        return hull.toArray(new int[hull.size()][]);
    }

    private static int crossProduct(int[] p, int[] q, int[] r) {
        return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);
    }
}

-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Solution 
    // Your code here
}

************************************
Question ID: 591

private static boolean isValid(String code, int[] i) {
    if (i[0] >= code.length()) return false;
    if (code.charAt(i[0]) != '<') return false;
    int nameLength = 0;
    for (++i[0]; i[0] < code.length() && nameLength < 9 && Character.isUpperCase(code.charAt(i[0])); ++i[0]) ++nameLength;
    if (nameLength < 1 || nameLength > 9 || code.charAt(i[0]++) != '>') return false;

    while (i[0] < code.length() && code.charAt(i[0]) != '<') ++i[0];
    if (i[0] >= code.length()) return false;

    if (!code.substring(i[0], i[0] + nameLength + 3).equals("</" + code.substring(i[0] - nameLength - 1, i[0] - 1) + ">"))
        return false;
    i[0] += nameLength + 3;
    return true;
}

public static boolean validateCodeSnippet(String code) {
    int[] i = {0};
    return isValid(code, i) && i[0] == code.length();
}

-----
private static boolean isValid(String code, int[] i) 
    // Your code here
}

************************************
Question ID: 592

public class Solution {
    public String fractionAddition(String expression) {
        int A = 0, B = 1;
        int i = 0;
        while(i < expression.length()) {
            int sign = expression.charAt(i++) == '+' ? 1 : -1;
            int num = 0, den = 0;
            while (i < expression.length() && Character.isDigit(expression.charAt(i))) {
                num = num * 10 + (expression.charAt(i++) - '0');
            }
            i++; // skip '/'
            while (i < expression.length() && Character.isDigit(expression.charAt(i))) {
                den = den * 10 + (expression.charAt(i++) - '0');
            }
            A = A * den + B * num * sign;
            B *= den;
            int GCD = gcd(Math.abs(A), Math.abs(B));
            A /= GCD;
            B /= GCD;
        }
        return A + "/" + B;
    }

    private int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
}

-----
public class Solution 
    // Your code here
}

************************************
Question ID: 593

public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {
    Set<Integer> dist = new HashSet<>();
    int[][] points = {p1, p2, p3, p4};

    for (int i = 0; i < 4; i++) {
        for (int j = i + 1; j < 4; j++) {
            dist.add((points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]));
        }
    }

    return dist.size() == 2 && !dist.contains(0);
}

-----
public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) 
    // Your code here
}

************************************
Question ID: 594

import java.util.HashMap;

public int findLHS(int[] nums) {
    HashMap<Integer, Integer> count = new HashMap<>();
    for (int num : nums)
        count.put(num, count.getOrDefault(num, 0) + 1);

    int longest_sequence = 0;
    for (int key : count.keySet()) {
        if (count.containsKey(key + 1))
            longest_sequence = Math.max(longest_sequence, count.get(key) + count.get(key + 1));
    }
    
    return longest_sequence;
}

-----
import java.util.HashMap;

public int findLHS(int[] nums) 
    // Your code here
}

************************************
Question ID: 598

public int maxCount(int m, int n, int[][] ops) {
    for (int[] op : ops) {
        m = Math.min(m, op[0]);
        n = Math.min(n, op[1]);
    }
    return m * n;
}

-----
public int maxCount(int m, int n, int[][] ops) 
    // Your code here
}

************************************
Question ID: 599

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public List<String> findRestaurant(String[] list1, String[] list2) {
    HashMap<String, Integer> restaurantMap = new HashMap<>();
    for (int i = 0; i < list1.length; i++) {
        restaurantMap.put(list1[i], i);
    }

    int minSum = Integer.MAX_VALUE;
    List<String> result = new ArrayList<>();
    for (int j = 0; j < list2.length; j++) {
        Integer index = restaurantMap.get(list2[j]);
        if (index != null) {
            int sum = j + index;
            if (sum < minSum) {
                result.clear();
                result.add(list2[j]);
                minSum = sum;
            } else if (sum == minSum) {
                result.add(list2[j]);
            }
        }
    }
    return result;
}


-----
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public List<String> findRestaurant(String[] list1, String[] list2) 
    // Your code here
}


************************************
Question ID: 600

public int findIntegers(int n) {
    int[][] dp = new int[32][2];
    dp[0][0] = 1;
    dp[0][1] = 1;

    for (int i = 1; i < 32; i++) {
        dp[i][0] = dp[i - 1][0] + dp[i - 1][1];
        dp[i][1] = dp[i - 1][0];
    }

    int ans = 0, prev_bit = 0;
    for (int i = 30; i >= 0; i--) {
        if ((n & (1 << i)) != 0) {
            ans += dp[i][0];
            if (prev_bit == 1) break;
            prev_bit = 1;
        } else {
            prev_bit = 0;
        }
    }

    return ans + 1;
}


-----
public int findIntegers(int n) 
    // Your code here
}


************************************
Question ID: 605

public boolean canPlaceFlowers(int[] flowerbed, int n) {
    int count = 0;
    for(int i = 0; i < flowerbed.length; i++) {
        if(flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) && (i == flowerbed.length - 1 || flowerbed[i + 1] == 0)) {
            flowerbed[i] = 1;
            count++;
        }
        if(count >= n) return true;
    }
    return count >= n;
}


-----
public boolean canPlaceFlowers(int[] flowerbed, int n) 
    // Your code here
}


************************************
Question ID: 609

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public List<List<String>> findDuplicate(String[] paths) {
    HashMap<String, List<String>> contentMap = new HashMap<>();
    for (String path : paths) {
        String[] parts = path.split(" ");
        String directory = parts[0];
        for (int i = 1; i < parts.length; i++) {
            int start = parts[i].indexOf('(');
            int end = parts[i].indexOf(')');
            String content = parts[i].substring(start + 1, end);
            String filePath = directory + "/" + parts[i].substring(0, start);
            contentMap.computeIfAbsent(content, k -> new ArrayList<>()).add(filePath);
        }
    }
    List<List<String>> result = new ArrayList<>();
    for (List<String> filePaths : contentMap.values()) {
        if (filePaths.size() > 1) {
            result.add(filePaths);
        }
    }
    return result;
}

-----
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public List<List<String>> findDuplicate(String[] paths) 
    // Your code here
}

************************************
Question ID: 611

public int triangleNumber(int[] nums) {
    Arrays.sort(nums);
    int count = 0;
    for (int i = 0; i < nums.length; ++i) {
        for (int j = i + 1; j < nums.length; ++j) {
            for (int k = j + 1; k < nums.length; ++k) {
                if (nums[i] + nums[j] > nums[k]) {
                    count++;
                }
                else {
                    break;
                }
            }
        }
    }
    return count;
}

-----
public int triangleNumber(int[] nums) 
    // Your code here
}

************************************
Question ID: 616

import java.util.ArrayList;
import java.util.Arrays;

public String addBoldTag(String s, String[] words) {
    int n = s.length();
    boolean[] marked = new boolean[n];
    for (String word : words) {
        int pos = s.indexOf(word, 0);
        while (pos != -1) {
            Arrays.fill(marked, pos, pos + word.length(), true);
            pos = s.indexOf(word, pos + 1);
        }
    }
    StringBuilder result = new StringBuilder();
    for (int i = 0; i < n; i++) {
        if (marked[i] && (i == 0 || !marked[i - 1])) {
            result.append("<b>");
        }
        result.append(s.charAt(i));
        if (marked[i] && (i == n - 1 || !marked[i + 1])) {
            result.append("</b>");
        }
    }
    return result.toString();
}

-----
import java.util.ArrayList;
import java.util.Arrays;

public String addBoldTag(String s, String[] words) 
    // Your code here
}

************************************
Question ID: 621

import java.util.HashMap;
import java.util.PriorityQueue;

public int leastInterval(char[] tasks, int n) {
    HashMap<Character, Integer> taskFreq = new HashMap<>();
    for (char task : tasks) {
        taskFreq.put(task, taskFreq.getOrDefault(task, 0) + 1);
    }

    PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);
    maxHeap.addAll(taskFreq.values());

    int cycles = 0;

    while (!maxHeap.isEmpty()) {
        List<Integer> temp = new ArrayList<>();
        for (int i = 0; i < n + 1; i++) {
            if (!maxHeap.isEmpty()) {
                temp.add(maxHeap.remove());
            }
        }

        for (int freq : temp) {
            if (--freq > 0) {
                maxHeap.add(freq);
            }
        }

        cycles += maxHeap.isEmpty() ? temp.size() : n + 1;
    }

    return cycles;
}


-----
import java.util.HashMap;
import java.util.PriorityQueue;

public int leastInterval(char[] tasks, int n) 
    // Your code here
}


************************************
Question ID: 623

public void addOneRowHelper(TreeNode node, int val, int depth, int currentDepth) {
    if (node == null) return;
    if (currentDepth == depth - 1) {
        TreeNode left = node.left;
        TreeNode right = node.right;
        node.left = new TreeNode(val);
        node.left.left = left;
        node.right = new TreeNode(val);
        node.right.right = right;
    } else {
        addOneRowHelper(node.left, val, depth, currentDepth + 1);
        addOneRowHelper(node.right, val, depth, currentDepth + 1);
    }
}

public TreeNode addOneRow(TreeNode root, int val, int depth) {
    if (depth == 1) {
        TreeNode newRoot = new TreeNode(val);
        newRoot.left = root;
        return newRoot;
    }
    addOneRowHelper(root, val, depth, 1);
    return root;
}

-----
public void addOneRowHelper(TreeNode node, int val, int depth, int currentDepth) 
    // Your code here
}

************************************
Question ID: 624

public int maxDistance(List<List<Integer>> arrays) {
    int max_dist = 0, min_val = arrays.get(0).get(0), max_val = arrays.get(0).get(arrays.get(0).size() - 1);
    for (int i = 1; i < arrays.size(); i++) {
        max_dist = Math.max(max_dist, Math.max(
                Math.abs(arrays.get(i).get(arrays.get(i).size() - 1) - min_val),
                Math.abs(max_val - arrays.get(i).get(0))
        ));
        min_val = Math.min(min_val, arrays.get(i).get(0));
        max_val = Math.max(max_val, arrays.get(i).get(arrays.get(i).size() - 1));
    }
    return max_dist;
}

-----
public int maxDistance(List<List<Integer>> arrays) 
    // Your code here
}

************************************
Question ID: 625

public int smallestFactorization(int num) {
    if (num == 1) return 1;
    long result = 0, factor = 1;
    for (int i = 9; i > 1; --i) {
        while (num % i == 0) {
            num /= i;
            result += i * factor;
            factor *= 10;
            if (result > Integer.MAX_VALUE) return 0;
        }
    }
    return num == 1 ? (int) result : 0;
}

-----
public int smallestFactorization(int num) 
    // Your code here
}

************************************
Question ID: 628

public int maximumProduct(int[] nums) {
    Arrays.sort(nums);
    int n = nums.length;
    return Math.max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3]);
}

-----
public int maximumProduct(int[] nums) 
    // Your code here
}

************************************
Question ID: 629

public int kInversePairs(int n, int k) {
    int mod = 1000000007;
    int[][] dp = new int[n + 1][k + 1];
    for (int i = 1; i <= n; i++) {
        dp[i][0] = 1;
        for (int j = 1; j <= k; j++) {
            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod;
            if (j - i >= 0) {
                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;
            }
        }
    }
    return dp[n][k];
}

-----
public int kInversePairs(int n, int k) 
    // Your code here
}

************************************
Question ID: 630

import java.util.Arrays;
import java.util.PriorityQueue;

public int scheduleCourse(int[][] courses) {
    Arrays.sort(courses, (a, b) -> a[1] - b[1]);

    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);
    int time = 0;

    for (int[] course : courses) {
        time += course[0];
        pq.offer(course[0]);

        if (time > course[1]) {
            time -= pq.poll();
        }
    }

    return pq.size();
}

-----
import java.util.Arrays;
import java.util.PriorityQueue;

public int scheduleCourse(int[][] courses) 
    // Your code here
}

************************************
Question ID: 632

import java.util.PriorityQueue;
import java.util.List;
import java.util.ArrayList;
import java.util.Comparator;

public int[] smallestRange(List<List<Integer>> nums) {
    PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));

    int maxVal = Integer.MIN_VALUE;
    for (int i = 0; i < nums.size(); i++) {
        minHeap.offer(new int[] {nums.get(i).get(0), i});
        maxVal = Math.max(maxVal, nums.get(i).get(0));
    }

    List<Integer> listIndices = new ArrayList<>();
    for (int i = 0; i < nums.size(); i++) {
        listIndices.add(0);
    }
    int minRange = Integer.MAX_VALUE;
    int start = -1, end = -1;

    while (minHeap.size() == nums.size()) {
        int[] entry = minHeap.poll();
        int val = entry[0];
        int listIdx = entry[1];
        int range = maxVal - val;

        if (range < minRange) {
            minRange = range;
            start = val;
            end = maxVal;
        }

        listIndices.set(listIdx, listIndices.get(listIdx) + 1);
        if (listIndices.get(listIdx) < nums.get(listIdx).size()) {
            int newVal = nums.get(listIdx).get(listIndices.get(listIdx));
            minHeap.offer(new int[] {newVal, listIdx});
            maxVal = Math.max(maxVal, newVal);
        }
    }

    return new int[] {start, end};
}

-----
import java.util.PriorityQueue;
import java.util.List;
import java.util.ArrayList;
import java.util.Comparator;

public int[] smallestRange(List<List<Integer>> nums) 
    // Your code here
}

************************************
Question ID: 633

class Solution {
    public boolean judgeSquareSum(int c) {
        for (int a = 0; a <= Math.sqrt(c); ++a) {
            int b = (int) Math.sqrt(c - a * a);
            if (a * a + b * b == c) {
                return true;
            }
        }
        return false;
    }
}

-----
class Solution 
    // Your code here
}

************************************
Question ID: 634

public int findDerangement(int n) {
    final int MOD = 1000000007;
    long[] dp = new long[n + 1];
    dp[2] = 1;
    for (int i = 3; i <= n; ++i) {
        dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD;
    }
    return (int)dp[n];
}

-----
public int findDerangement(int n) 
    // Your code here
}

************************************
Question ID: 636

import java.util.List;
import java.util.Stack;

public int[] exclusiveTime(int n, List<String> logs) {
    int[] res = new int[n];
    Stack<Integer> stack = new Stack<>();
    int prevTime = 0;

    for (String log : logs) {
        String[] parts = log.split(":");
        int id = Integer.parseInt(parts[0]);
        String type = parts[1];
        int time = Integer.parseInt(parts[2]);

        if (type.equals("start")) {
            if (!stack.isEmpty()) {
                res[stack.peek()] += time - prevTime;
            }
            stack.push(id);
            prevTime = time;
        } else {
            res[stack.pop()] += time - prevTime + 1;
            prevTime = time + 1;
        }
    }

    return res;
}

-----
import java.util.List;
import java.util.Stack;

public int[] exclusiveTime(int n, List<String> logs) 
    // Your code here
}

************************************
Question ID: 638

import java.util.List;
import java.util.ArrayList;

public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {
    return shoppingOffersHelper(price, special, needs, 0);
}

private int shoppingOffersHelper(List<Integer> price, List<List<Integer>> special, List<Integer> needs, int index) {
    if (index == special.size()) {
        int sum = 0;
        for (int i = 0; i < needs.size(); ++i) {
            sum += price.get(i) * needs.get(i);
        }
        return sum;
    }

    int no_offer = shoppingOffersHelper(price, special, needs, index + 1);
    boolean can_apply_offer = true;
    for (int i = 0; i < needs.size(); ++i) {
        needs.set(i, needs.get(i) - special.get(index).get(i));
        if (needs.get(i) < 0) can_apply_offer = false;
    }

    int with_offer = Integer.MAX_VALUE;
    if (can_apply_offer) {
        int offer_cost = special.get(index).get(needs.size()) + shoppingOffersHelper(price, special, needs, index);
        with_offer = Math.min(no_offer, offer_cost);
    }

    for (int i = 0; i < needs.size(); ++i) {
        needs.set(i, needs.get(i) + special.get(index).get(i));
    }

    return can_apply_offer ? with_offer : no_offer;
}


-----
import java.util.List;
import java.util.ArrayList;

public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) 
    // Your code here
}


************************************
Question ID: 639

public int numDecodings(String s) {
    final int MOD = 1_000_000_007;
    int n = s.length();
    long[] dp = new long[n + 1];
    dp[0] = 1;
    dp[1] = s.charAt(0) == '*' ? 9 : (s.charAt(0) == '0' ? 0 : 1);

    for (int i = 2; i <= n; ++i) {
        char c = s.charAt(i - 1);
        char prevC = s.charAt(i - 2);

        if (c == '*') {
            dp[i] = 9 * dp[i - 1];
            if (prevC == '1') dp[i] += 9 * dp[i - 2];
            else if (prevC == '2') dp[i] += 6 * dp[i - 2];
            else if (prevC == '*') dp[i] += 15 * dp[i - 2];
        } else {
            dp[i] = (c != '0') ? dp[i - 1] : 0;
            int num = Integer.parseInt(s.substring(i - 2, i));
            if (prevC == '1' || (prevC == '2' && num <= 26)) dp[i] += dp[i - 2];
            else if (prevC == '*') dp[i] += (num <= 26 && num >= 10) ? 2 * dp[i - 2] : dp[i - 2];
        }
        dp[i] %= MOD;
    }
    return (int) dp[n];
}

-----
public int numDecodings(String s) 
    // Your code here
}

************************************
Question ID: 640

public String solveEquation(String equation) {
    int coefficient = 0, value = 0, left = 1, operator = 1;
    String[] parts = (equation + "+").split("(?<=[+-])");
    for (String part : parts) {
        if (part.equals("=")) {
            left = -1;
            operator = 1;
        } else {
            String[] nums = part.split("x");
            int n = Integer.parseInt(nums[0]);
            (nums.length == 1 ? value : coefficient) += left * operator * n;
            operator = nums.length;
        }
    }

    if (coefficient == 0) {
        return value == 0 ? "Infinite solutions" : "No solution";
    }
    return "x=" + -value / coefficient;
}


-----
public String solveEquation(String equation) 
    // Your code here
}


************************************
Question ID: 642

import java.util.*;

class AutocompleteSystem {
    class TrieNode {
        HashMap<Character, TrieNode> children = new HashMap<>();
        String sentence;
        int times;

        TrieNode() {
            sentence = null;
            times = 0;
        }
    }

    private void insert(String sentence, int times) {
        TrieNode curr = root;
        for (char c : sentence.toCharArray()) {
            curr.children.putIfAbsent(c, new TrieNode());
            curr = curr.children.get(c);
        }
        curr.sentence = sentence;
        curr.times += times;
    }

    private class NodeComparator implements Comparator<TrieNode> {
        public int compare(TrieNode a, TrieNode b) {
            if (a.times == b.times) {
                return a.sentence.compareTo(b.sentence);
            }
            return b.times - a.times;
        }
    }

    TrieNode root, curr;
    String search;

    public AutocompleteSystem(String[] sentences, int[] times) {
        root = new TrieNode();
        curr = root;
        search = "";
        for (int i = 0; i < sentences.length; ++i) {
            insert(sentences[i], times[i]);
        }
    }
    
    public List<String> input(char c) {
        List<String> res = new ArrayList<>();
        if (c == '#') {
            insert(search, 1);
            search = "";
            curr = root;
            return res;
        }
        search += c;
        if (!curr.children.containsKey(c)) {
            curr = null;
            return res;
        }
        curr = curr.children.get(c);
        PriorityQueue<TrieNode> pq = new PriorityQueue<>(new NodeComparator());
        for (TrieNode node : curr.children.values()) {
            if (node.times > 0) {
                pq.add(node);
            }
        }
        while (!pq.isEmpty() && res.size() < 3) {
            res.add(pq.poll().sentence);
        }
        return res;
    }
}


-----
import java.util.*;

class AutocompleteSystem 
    // Your code here
}


************************************
Question ID: 643

public double findMaxAverage(int[] nums, int k) {
    int n = nums.length;
    double sum = 0;
    for (int i = 0; i < k; i++) {
        sum += nums[i];
    }
    double max_avg = sum / k;
    for (int i = k; i < n; i++) {
        sum = sum - nums[i - k] + nums[i];
        max_avg = Math.max(max_avg, sum / k);
    }
    return max_avg;
}

-----
public double findMaxAverage(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 644

public double findMaxAverage(int[] nums, int k) {
    long sum = 0;
    for(int i = 0; i < k; i++) {
        sum += nums[i];
    }

    double max_avg = (double) sum / k;
    
    for(int i = k; i < nums.length; i++) {
        sum += nums[i] - nums[i - k];
        max_avg = Math.max(max_avg, (double) sum / k);
    }
    
    return max_avg;
}

-----
public double findMaxAverage(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 645

public int[] findErrorNums(int[] nums) {
    int[] result = new int[2];
    for (int num : nums) {
        int index = Math.abs(num) - 1;
        if (nums[index] > 0) {
            nums[index] = -nums[index];
        } else {
            result[0] = index + 1;
        }
    }
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] > 0) {
            result[1] = i + 1;
            break;
        }
    }
    return result;
}

-----
public int[] findErrorNums(int[] nums) 
    // Your code here
}

************************************
Question ID: 646

import java.util.Arrays;
import java.util.Comparator;

public int findLongestChain(int[][] pairs) {
    Arrays.sort(pairs, Comparator.comparingInt(a -> a[1]));

    int max_chain_length = 0, last_right = Integer.MIN_VALUE;
    for (int[] pair : pairs) {
        if (pair[0] > last_right) {
            last_right = pair[1];
            max_chain_length++;
        }
    }
    
    return max_chain_length;
}


-----
import java.util.Arrays;
import java.util.Comparator;

public int findLongestChain(int[][] pairs) 
    // Your code here
}


************************************
Question ID: 647

public int countSubstrings(String s) {
    int n = s.length(), count = 0;
    for (int center = 0; center < 2 * n - 1; ++center) {
        int left = center / 2;
        int right = left + center % 2;
        while (left >= 0 && right < n && s.charAt(left) == s.charAt(right)) {
            ++count;
            --left;
            ++right;
        }
    }
    return count;
}

-----
public int countSubstrings(String s) 
    // Your code here
}

************************************
Question ID: 648

import java.util.List;
import java.util.Set;
import java.util.HashSet;
import java.util.Arrays;

public String replaceWords(List<String> dict, String sentence) {
    Set<String> roots = new HashSet<>(dict);
    String[] words = sentence.split(" ");
    StringBuilder result = new StringBuilder();

    for (String word : words) {
        String prefix = "";
        for (int i = 1; i <= word.length(); ++i) {
            prefix = word.substring(0, i);
            if (roots.contains(prefix)) {
                break;
            }
        }
        result.append(prefix).append(" ");
    }

    return result.toString().trim();
}

-----
import java.util.List;
import java.util.Set;
import java.util.HashSet;
import java.util.Arrays;

public String replaceWords(List<String> dict, String sentence) 
    // Your code here
}

************************************
Question ID: 649

import java.util.Queue;
import java.util.LinkedList;

public String predictPartyVictory(String senate) {
    Queue<Integer> radiant = new LinkedList<>();
    Queue<Integer> dire = new LinkedList<>();
    int n = senate.length();
    
    for (int i = 0; i < n; i++) {
        if (senate.charAt(i) == 'R')
            radiant.add(i);
        else
            dire.add(i);
    }

    while (!radiant.isEmpty() && !dire.isEmpty()) {
        int r = radiant.poll();
        int d = dire.poll();

        if (r < d)
            radiant.add(r + n);
        else
            dire.add(d + n);
    }

    return radiant.isEmpty() ? "Dire" : "Radiant";
}


-----
import java.util.Queue;
import java.util.LinkedList;

public String predictPartyVictory(String senate) 
    // Your code here
}


************************************
Question ID: 650

public int minSteps(int n) {
    int result = 0;
    for (int i = 2; i <= n; i++) {
        while (n % i == 0) {
            result += i;
            n /= i;
        }
    }
    return result;
}

-----
public int minSteps(int n) 
    // Your code here
}

************************************
Question ID: 651

public int maxA(int n) {
    int[] dp = new int[n + 1];
    for(int i = 1; i <= n; ++i) {
        dp[i] = i;
        for(int j = 1; j <= i - 3; ++j)
            dp[i] = Math.max(dp[i], dp[j] * (i - j - 1));
    }
    return dp[n];
}

-----
public int maxA(int n) 
    // Your code here
}

************************************
Question ID: 653

public boolean findTarget(TreeNode root, int k) {
    Set<Integer> nodes = new HashSet<>();
    return findNode(root, k, nodes);
}

public boolean findNode(TreeNode root, int k, Set<Integer> nodes) {
    if (root == null) return false;
    if (nodes.contains(k - root.val)) return true;
    nodes.add(root.val);
    return findNode(root.left, k, nodes) || findNode(root.right, k, nodes);
}

-----
public boolean findTarget(TreeNode root, int k) 
    // Your code here
}

************************************
Question ID: 655

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

public List<List<String>> printTree(TreeNode root) {
    if (root == null) {
        return new ArrayList<>();
    }

    // Calculate Depth
    int depth = 0;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        depth++;
        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
    }

    List<List<String>> res = new ArrayList<>();
    for (int i = 0; i < depth; i++) {
        List<String> row = new ArrayList<>();
        for (int j = 0; j < (1 << depth) - 1; j++) {
            row.add("");
        }
        res.add(row);
    }

    // Fill in matrix
    queue.offer(root);
    int level = 0;
    int step = (1 << (depth - 1));
    while (!queue.isEmpty()) {
        int size = queue.size();
        int curPos = step - 1;
        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            res.get(level).set(curPos, String.valueOf(node.val));
            curPos += (step << 1);
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
        step >>= 1;
        level++;
    }

    return res;
}


-----
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class TreeNode 
    // Your code here
}


************************************
Question ID: 656

import java.util.*;
class Solution {
    public int[] cheapestJump(int[] coins, int maxJump) {
        int n = coins.length;
        int[] dp = new int[n];
        int[] parent = new int[n];
        Arrays.fill(dp, Integer.MAX_VALUE);
        Arrays.fill(parent, -1);
        dp[0] = coins[0];
        for (int i = 0; i < n; ++i) {
            if (coins[i] == -1) continue;
            for (int j = 1; j <= maxJump && i + j < n; ++j) {
                int next = i + j;
                int cost = coins[next] + dp[i];
                if (cost < dp[next]) {
                    dp[next] = cost;
                    parent[next] = i;
                }
            }
        }
        List<Integer> ansList = new ArrayList<>();
        if (dp[n - 1] == Integer.MAX_VALUE) return new int[0];
        int cur = n - 1;
        while (cur != -1) {
            ansList.add(cur + 1);
            cur = parent[cur];
        }
        Collections.reverse(ansList);
        int[] ans = new int[ansList.size()];
        for (int i = 0; i < ansLIST.size(); i++) {
            ans[i] = ansList.get(i);
        }
        return ans;
    }
}

-----
import java.util.*;
class Solution 
    // Your code here
}

************************************
Question ID: 657

public boolean judgeCircle(String moves) {
    int x = 0, y = 0;
    for(char move : moves.toCharArray()) {
        if(move == 'U') y++;
        else if(move == 'D') y--;
        else if(move == 'R') x++;
        else if(move == 'L') x--;
    }
    return x == 0 && y == 0;
}

-----
public boolean judgeCircle(String moves) 
    // Your code here
}

************************************
Question ID: 658

import java.util.List;
import java.util.ArrayList;

public List<Integer> findClosestElements(int[] arr, int k, int x) {
    int left = 0;
    int right = arr.length - k;

    while (left < right) {
        int mid = left + (right - left) / 2;
        if (x - arr[mid] > arr[mid + k] - x) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    List<Integer> result = new ArrayList<>();
    for (int i = left; i < left + k; i++) {
        result.add(arr[i]);
    }

    return result;
}

-----
import java.util.List;
import java.util.ArrayList;

public List<Integer> findClosestElements(int[] arr, int k, int x) 
    // Your code here
}

************************************
Question ID: 659

public boolean canSplit(int[] nums) {
    int[] freq = new int[20001], needed = new int[20001];
    for (int n : nums)
        freq[n]++;
    for (int n : nums) {
        if (freq[n] == 0) continue;
        if (needed[n - 1] == 0) {
            if (freq[n + 1] > 0 && freq[n + 2] > 0) {
                freq[n]--; freq[n + 1]--; freq[n + 2]--;
                needed[n + 2]++;
            } else return false;
        } else {
            freq[n]--; needed[n - 1]--;
            needed[n]++;
        }
    }
    return true;
}

-----
public boolean canSplit(int[] nums) 
    // Your code here
}

************************************
Question ID: 660

public int newInteger(int n) {
    int result = 0, base = 1;
    while (n>0) {
        result += n % 9 * base;
        n /= 9;
        base *= 10;
    }
    return result;
}

-----
public int newInteger(int n) 
    // Your code here
}

************************************
Question ID: 661

public int[][] imageSmoother(int[][] img) {
    int m = img.length, n = img[0].length;
    int[][] result = new int[m][n];

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            int count = 0, sum = 0;
            for (int x = i - 1; x <= i + 1; x++) {
                for (int y = j - 1; y <= j + 1; y++) {
                    if (x >= 0 && x < m && y >= 0 && y < n) {
                        sum += img[x][y];
                        count++;
                    }
                }
            }
            result[i][j] = sum / count;
        }
    }

    return result;
}

-----
public int[][] imageSmoother(int[][] img) 
    // Your code here
}

************************************
Question ID: 662

import java.util.LinkedList;
import java.util.Queue;

public int widthOfBinaryTree(TreeNode root) {
    if (root == null) return 0;
    int maxWidth = 0;
    Queue<Pair> q = new LinkedList<>();
    q.offer(new Pair(root, 1));

    while (!q.isEmpty()) {
        int levelSize = q.size();
        int left = q.peek().pos;
        int right = left;
        for (int i = 0; i < levelSize; i++) {
            Pair pair = q.poll();
            TreeNode node = pair.node;
            right = pair.pos;

            if (node.left != null) {
                q.offer(new Pair(node.left, 2 * right));
            }
            if (node.right != null) {
                q.offer(new Pair(node.right, 2 * right + 1));
            }
        }
        maxWidth = Math.max(maxWidth, right - left + 1);
    }

    return maxWidth;
}

class Pair {
    TreeNode node;
    int pos;

    public Pair(TreeNode node, int pos) {
        this.node = node;
        this.pos = pos;
    }
}

-----
import java.util.LinkedList;
import java.util.Queue;

public int widthOfBinaryTree(TreeNode root) 
    // Your code here
}

************************************
Question ID: 664

int strangePrinter(String s) {
    int n = s.length();
    if(n == 0) return 0;
    int[][] dp = new int[n][n];
    for(int i = 0; i < n; i++) dp[i][i] = 1;
    for(int len = 1; len < n; len++) {
        for(int i = 0; i < n - len; i++) {
            int j = i + len;
            dp[i][j] = dp[i+1][j] + 1;
            for(int k = i + 1; k <= j; k++) {
                if(s.charAt(i) == s.charAt(k)) {
                    dp[i][j] = Math.min(dp[i][j], dp[i+1][k-1] + dp[k][j]);
                }
            }
        }
    }
    return dp[0][n-1];
}

-----
int strangePrinter(String s) 
    // Your code here
}

************************************
Question ID: 665

public boolean checkPossibility(int[] nums) {
    int cnt = 0;
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] < nums[i - 1]) {
            cnt++;
            if (i == 1 || nums[i] >= nums[i - 2]) {
                nums[i-1] = nums[i];
            } else {
                nums[i] = nums[i - 1];
            }
            if (cnt > 1) return false;
        }
    }
    return true;
}

-----
public boolean checkPossibility(int[] nums) 
    // Your code here
}

************************************
Question ID: 666

public int sum(TreeNode root, int val) {
    if (root == null) return 0;
    val = val * 10 + root.val;
    if (root.left == null && root.right == null) return val;
    return sum(root.left, val) + sum(root.right, val);
}

public int pathSum(int[] nums) {
    TreeNode root = new TreeNode(nums[0] % 10);
    for (int num : nums) {
        int depth = num / 100;
        int pos = num % 100 / 10;
        int val = num % 10;
        TreeNode cur = root;
        for (int d = depth - 2; d >= 0; --d) {
            if ((pos >> d) & 1) {
                if (cur.right == null) cur.right = new TreeNode(val);
                cur = cur.right;
            } else {
                if (cur.left == null) cur.left = new TreeNode(val);
                cur = cur.left;
            }
        }
    }
    return sum(root, 0);
}

-----
public int sum(TreeNode root, int val) 
    // Your code here
}

************************************
Question ID: 667

import java.util.ArrayList;

class Solution {
    public List<Integer> constructArray(int n, int k) {
        ArrayList<Integer> answer = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) {
                answer.add(i / 2 + 1);
            } else {
                answer.add(n - (i - 1) / 2);
                k--;
            }
        }
        if (k > 0) {
            for (int i = n - 2; i >= 0 && k > 0; i--) {
                answer.set(i, answer.get(i + 1) - answer.get(i));
                k--;
            }
        }
        return answer;
    }
}

-----
import java.util.ArrayList;

class Solution 
    // Your code here
}

************************************
Question ID: 668

public int findKthNumber(int m, int n, int k) {
    int low = 1, high = m * n;
    while (low < high) {
        int mid = low + (high - low) / 2;
        int count = 0;
        for (int i = 1; i <= m; i++) {
            count += Math.min(mid / i, n);
        }
        if (count < k) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    return low;
}

-----
public int findKthNumber(int m, int n, int k) 
    // Your code here
}

************************************
Question ID: 670

public int maximumSwap(int num) {
    char[] num_str = Integer.toString(num).toCharArray();
    int[] last = new int[10];
    
    for (int i = 0; i < num_str.length; i++) {
        last[num_str[i] - '0'] = i;
    }
    
    for (int i = 0; i < num_str.length; i++) {
        for (int d = 9; d > num_str[i] - '0'; d--) {
            if (last[d] > i) {
                swap(num_str, i, last[d]);
                return Integer.parseInt(new String(num_str));
            }
        }
    }
    
    return num;
}

private void swap(char[] arr, int i, int j) {
    char temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

-----
public int maximumSwap(int num) 
    // Your code here
}

************************************
Question ID: 672

public int numLightConfiguration(int n, int presses) {
    int[][] dp = new int[n + 1][presses + 1];
    dp[0][0] = 1;

    for (int i = 0; i <= n; ++i) {
        for (int j = 1; j <= presses; ++j) {
            dp[i][j] = dp[i][j - 1] * (i + 1) + (i > 0 ? dp[i - 1][j - 1] : 0);
        }
    }

    return dp[n][presses];
}

-----
public int numLightConfiguration(int n, int presses) 
    // Your code here
}

************************************
Question ID: 673

public int findNumberOfLIS(int[] nums) {
    int n = nums.length, maxLength = 0, ans = 0;
    int[] length = new int[n];
    int[] count = new int[n];

    for (int i = 0; i < n; ++i) {
        length[i] = count[i] = 1;
        for (int j = 0; j < i; ++j) {
            if (nums[i] > nums[j]) {
                if (length[i] == length[j] + 1) {
                    count[i] += count[j];
                } else if (length[i] < length[j] + 1) {
                    length[i] = length[j] + 1;
                    count[i] = count[j];
                }
            }
        }
        if (maxLength == length[i]) {
            ans += count[i];
        } else if (maxLength < length[i]) {
            maxLength = length[i];
            ans = count[i];
        }
    }

    return ans;
}


-----
public int findNumberOfLIS(int[] nums) 
    // Your code here
}


************************************
Question ID: 674

public int findLengthOfLCIS(int[] nums) {
    if (nums.length == 0) return 0;
    int result = 1, current = 1;
    for (int i = 1; i < nums.length; ++i) {
        current = nums[i] > nums[i - 1] ? current + 1 : 1;
        result = Math.max(result, current);
    }
    return result;
}

-----
public int findLengthOfLCIS(int[] nums) 
    // Your code here
}

************************************
Question ID: 675

import java.util.*;

public int cutOffTree(List<List<Integer>> forest) {
    if(forest.isEmpty() || forest.get(0).isEmpty()) return 0;
    int m = forest.size(), n = forest.get(0).size();
    List<int[]> trees = new ArrayList<>();
    
    for(int i = 0; i < m; i++)
        for(int j = 0; j < n; j++)
            if(forest.get(i).get(j) > 1)
                trees.add(new int[]{i, j});
    
    trees.sort((a, b) -> forest.get(a[0]).get(a[1]) - forest.get(b[0]).get(b[1]));

    int startX = 0, startY = 0;
    int totalSteps = 0;
    for(int[] tree : trees){
        int x = tree[0], y = tree[1];
        int steps = bfs(forest, startX, startY, x, y);
        if(steps == -1) return -1;
        totalSteps += steps;
        startX = x;
        startY = y;
    }
    
    return totalSteps;
}

private int bfs(List<List<Integer>> forest, int startX, int startY, int endX, int endY) {
    int m = forest.size(), n = forest.get(0).size();
    int[][] visited = new int[m][n];
    Queue<int[]> q = new LinkedList<>();
    q.offer(new int[]{startX, startY});
    visited[startX][startY] = 1;
    int steps = 0;
    int[] dirs = {-1, 0, 1, 0, -1};
    
    while(!q.isEmpty()) {
        int size = q.size();
        for(int i = 0; i < size; i++) {
            int[] cur = q.poll();
            int x = cur[0], y = cur[1];

            if(x == endX && y == endY) return steps;
            
            for(int k = 0; k < 4; k++) {
                int newX = x + dirs[k];
                int newY = y + dirs[k+1];
                if(newX >= 0 && newX < m && newY >= 0 && newY < n && visited[newX][newY] == 0 && forest.get(newX).get(newY) != 0) {
                    q.offer(new int[]{ newX, newY });
                    visited[newX][newY] = 1;
                }
            }
        }
        steps++;
    }
    
    return -1;
}

-----
import java.util.*;

public int cutOffTree(List<List<Integer>> forest) 
    // Your code here
}

************************************
Question ID: 678

public boolean checkValidString(String s) {
    int left_balance = 0, right_balance = 0;

    for (int i = 0; i < s.length(); i++) {
        left_balance += (s.charAt(i) == '(' || s.charAt(i) == '*') ? 1 : -1;
        right_balance += (s.charAt(s.length() - 1 - i) == ')' || s.charAt(s.length() - 1 - i) == '*') ? 1 : -1;

        if (left_balance < 0 || right_balance < 0)
            return false;
    }

    return true;
}


-----
public boolean checkValidString(String s) 
    // Your code here
}


************************************
Question ID: 679

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public boolean helper(List<Double> cards) {
    if (cards.size() == 1) {
        return Math.abs(cards.get(0) - 24) < 1e-6;
    }

    for (int i = 0; i < cards.size(); ++i) {
        for (int j = i + 1; j < cards.size(); ++j) {
            double a = cards.get(i), b = cards.get(j);
            List<Double> next = Arrays.asList(a + b, a - b, a * b, a / b);

            cards.remove(j);
            cards.remove(i);

            for (Double e : next) {
                cards.add(e);
                if (helper(cards)) {
                    return true;
                }
                cards.remove(cards.size() - 1);
            }

            cards.add(i, a);
            cards.add(j, b);
        }
    }
    return false;
}

public boolean canGet24(int[] cards) {
    List<Double> doubleCards = new ArrayList<>();
    for (int card : cards) {
        doubleCards.add((double) card);
    }
    return helper(doubleCards);
}


-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public boolean helper(List<Double> cards) 
    // Your code here
}


************************************
Question ID: 680

public boolean validPalindrome(String s) {
    for (int i = 0, j = s.length() - 1; i < j; i++, j--) {
        if (s.charAt(i) != s.charAt(j)) {
            int temp1 = i + 1, temp2 = j;
            while (temp1 < temp2 && s.charAt(temp1) == s.charAt(temp2)) { temp1++; temp2--; }
            if (temp1 >= temp2) return true;

            temp1 = i; temp2 = j - 1;
            while (temp1 < temp2 && s.charAt(temp1) == s.charAt(temp2)) { temp1++; temp2--; }
            if (temp1 >= temp2) return true;
            
            return false;
        }
    }
    return true;
}

-----
public boolean validPalindrome(String s) 
    // Your code here
}

************************************
Question ID: 681

public String nextClosestTime(String time) {
    String digits = time.substring(0, 2) + time.substring(3);
    String next_time = time;
    int elapsed = Integer.MAX_VALUE;

    for (char a : digits.toCharArray()) {
    for (char b : digits.toCharArray()) {
    for (char c : digits.toCharArray()) {
    for (char d : digits.toCharArray()) {
        String candidate_time = new StringBuilder().append(a).append(b).append(':').append(c).append(d).toString();
        int cand_elapsed = (Integer.parseInt(candidate_time.substring(0, 2)) * 60 + Integer.parseInt(candidate_time.substring(3)) -
                            Integer.parseInt(time.substring(0, 2)) * 60 - Integer.parseInt(time.substring(3)) + 1440) % 1440;
        if (0 < cand_elapsed && cand_elapsed < elapsed) {
          elapsed = cand_elapsed;
          next_time = candidate_time;
        }
    }}}}

    return next_time;
}

-----
public String nextClosestTime(String time) 
    // Your code here
}

************************************
Question ID: 682

import java.util.*;

class Solution {
    public int calPoints(String[] ops) {
        LinkedList<Integer> record = new LinkedList<>();
        for (String op : ops) {
            if (op.equals("+")) {
                record.add(record.getLast() + record.get(record.size() - 2));
            } else if (op.equals("D")) {
                record.add(record.getLast() * 2);
            } else if (op.equals("C")) {
                record.removeLast();
            } else {
                record.add(Integer.parseInt(op));
            }
        }
        return record.stream().mapToInt(Integer::intValue).sum();
    }
}


-----
import java.util.*;

class Solution 
    // Your code here
}


************************************
Question ID: 683

public int kEmptySlots(int[] bulbs, int k) {
    int[] days = new int[bulbs.length];
    for(int i = 0; i < bulbs.length; i++) {
        days[bulbs[i] - 1] = i;
    }
    
    int ans = Integer.MAX_VALUE;
    int left = 0;
    int right = k + 1;
    while (right < days.length) {
        int i = left + 1;
        for (; i < right; i++) {
            if (days[i] < days[left] || days[i] < days[right]) {
                left = i;
                break;
            }
        }
        if (i == right) {
            ans = Math.min(ans, Math.max(days[left], days[right]));
            left++;
            right++;
        }
    }
    
    return ans == Integer.MAX_VALUE ? -1 : ans + 1;
}


-----
public int kEmptySlots(int[] bulbs, int k) 
    // Your code here
}


************************************
Question ID: 684

import java.util.*;

class Solution {
    public int[] findRedundantConnection(int[][] edges) {
        int[] parent = new int[edges.length + 1];
        for (int i = 1; i <= edges.length; i++) {
            parent[i] = i;
        }

        for (int[] edge : edges) {
            int root1 = find(parent, edge[0]);
            int root2 = find(parent, edge[1]);
            if (root1 == root2) {
                return edge;
            }
            parent[root1] = root2;
        }

        return new int[0];
    }

    private int find(int[] parent, int x) {
        if (parent[x] != x) {
            parent[x] = find(parent, parent[x]);
        }
        return parent[x];
    }
}


-----
import java.util.*;

class Solution 
    // Your code here
}


************************************
Question ID: 685

class Solution {
    public int[] findRedundantDirectedConnection(int[][] edges) {
        int[] parent = new int[edges.length + 1];
        int[] candidateA = null, candidateB = null;
        
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1];
            if (parent[v] > 0) {
                candidateA = new int[] {parent[v], v};
                candidateB = edge;
            } else {
                parent[v] = u;
            }
        }
        
        for (int i = 1; i <= edges.length; ++i) {
            int cycle = i, steps = edges.length;
            while (parent[cycle] != 0 && steps-- > 0) {
                cycle = parent[cycle];
            }
            if (steps == -1) {
                if (candidateA == null) return new int[] {parent[i], i};
                else return candidateA;
            }
        }
        
        return candidateB;
    }
}


-----
class Solution 
    // Your code here
}


************************************
Question ID: 686

public int minRepeatsToSubstring(String a, String b) {
    int times = (b.length() + a.length() - 1) / a.length();

    for (int i = 0; i < 2; i++) {
        StringBuilder repeated_a = new StringBuilder();
        for (int j = 0; j < times + i; j++) {
            repeated_a.append(a);
        }

        if (repeated_a.toString().contains(b)) return times + i;
    }

    return -1;
}

-----
public int minRepeatsToSubstring(String a, String b) 
    // Your code here
}

************************************
Question ID: 687

public int longestUnivaluePath(TreeNode root) {
    int[] maxLen = new int[1];
    findUnivaluePath(root, maxLen);
    return maxLen[0];
}

private int findUnivaluePath(TreeNode node, int[] maxLen) {
    if (node == null) return 0;
    int left = findUnivaluePath(node.left, maxLen);
    int right = findUnivaluePath(node.right, maxLen);
    left = (node.left != null && node.left.val == node.val) ? left + 1 : 0;
    right = (node.right != null && node.right.val == node.val) ? right + 1 : 0;
    maxLen[0] = Math.max(maxLen[0], left + right);
    return Math.max(left, right);
}


-----
public int longestUnivaluePath(TreeNode root) 
    // Your code here
}


************************************
Question ID: 688

public double knightProbability(int n, int k, int row, int column) {
    double[][][] memo = new double[n][n][k + 1];
    for (double[][] m : memo)
        for (double[] l : m)
            Arrays.fill(l, -1.0);
    return helper(n, k, row, column, memo);
}

double helper(int n, int k, int row, int column, double[][][] memo) {
    if (row < 0 || row >= n || column < 0 || column >= n) return 0.0;
    if (k == 0) return 1.0;
    if (memo[row][column][k] >= 0) return memo[row][column][k];

    double result = 0.0;
    int[][] moves = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};
    for (int i = 0; i < 8; ++i)
        result += helper(n, k - 1, row + moves[i][0], column + moves[i][1], memo) / 8;

    memo[row][column][k] = result;
    return result;
}

-----
public double knightProbability(int n, int k, int row, int column) 
    // Your code here
}

************************************
Question ID: 689

import java.util.Arrays;

public int[] max_sum_of_three_subarrays(int[] nums, int k) {
    int n = nums.length;
    int[] sums = new int[n - k + 1];
    int[] left = new int[n], right = new int[n], ans = new int[3];
    int acc_sum = 0;

    for (int i = 0; i < n; ++i) {
        acc_sum += nums[i];
        if (i >= k) {
            acc_sum -= nums[i - k];
        }
        if (i >= k - 1) {
            sums[i - k + 1] = acc_sum;
        }
    }

    left[0] = 0;
    right[n - k] = n - k;

    for (int i = 1; i < n - k + 1; ++i) {
        left[i] = sums[i] > sums[left[i - 1]] ? i : left[i - 1];
    }

    for (int i = n - k - 1; i >= 0; --i) {
        right[i] = sums[i] >= sums[right[i + 1]] ? i : right[i + 1];
    }

    int max_sum = 0;

    for (int i = k; i < n - 2 * k + 1; ++i) {
        int left_idx = left[i - k], right_idx = right[i + k], total_sum = sums[left_idx] + sums[i] + sums[right_idx];
        if (total_sum > max_sum) {
            max_sum = total_sum;
            ans = new int[] {left_idx, i, right_idx};
        }
    }

    return ans;
}

-----
import java.util.Arrays;

public int[] max_sum_of_three_subarrays(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 691

import java.util.HashMap;
import java.util.Map;

class Solution {
    public int minStickers(String[] stickers, String target) {
        Map<String, Integer> memo = new HashMap<>();
        int[] targetCount = new int[26];
        for (char c : target.toCharArray()) targetCount[c - 'a']++;
        
        for (String s : stickers) {
            int[] stickerCount = new int[26];
            StringBuilder sb = new StringBuilder();
            for (char c : s.toCharArray()) {
                if (targetCount[c - 'a'] == 0) continue;
                stickerCount[c - 'a']++;
            }
            for (int i = 0; i < 26; ++i) {
                sb.append(String.valueOf((char) ('a' + i)).repeat(stickerCount[i]));
            }
            memo.put(sb.toString(), 1);
        }
        
        return dp(memo, targetCount, target);
    }
    
    private int dp(Map<String, Integer> memo, int[] targetCount, String target) {
        if (memo.containsKey(target)) return memo.get(target);
        int[] counts = new int[26];
        for (char c : target.toCharArray()) counts[c - 'a']++;
        int ans = Integer.MAX_VALUE;
        for (Map.Entry<String, Integer> kv : memo.entrySet()) {
            boolean ok = true;
            for (int i = 0; i < 26 && ok; ++i)
                ok = counts[i] >= kv.getKey().charAt(i) - 'a';
            if (!ok) continue;
            ans = Math.min(ans, dp(memo, targetCount, target.substring(kv.getKey().length())) + kv.getValue());
        }
        memo.put(target, ans == Integer.MAX_VALUE ? -1 : ans);
        return memo.get(target);
    }
}

-----
import java.util.HashMap;
import java.util.Map;

class Solution 
    // Your code here
}

************************************
Question ID: 692

import java.util.*;

public class Solution {
    public List<String> kFrequentWords(String[] words, int k) {
        Map<String, Integer> wordCount = new HashMap<>();
        for (String word : words) {
            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
        }

        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(
                (a, b) -> a.getValue() == b.getValue()
                        ? a.getKey().compareTo(b.getKey())
                        : b.getValue() - a.getValue()
        );
        pq.addAll(wordCount.entrySet());

        List<String> result = new ArrayList<>();
        for (int i = 0; i < k; i++) {
            result.add(pq.poll().getKey());
        }
        return result;
    }
}

-----
import java.util.*;

public class Solution 
    // Your code here
}

************************************
Question ID: 693

public boolean hasAlternatingBits(int n) {
    int prevBit = n % 2;
    n /= 2;
    while (n > 0) {
        int currBit = n % 2;
        if (currBit == prevBit) return false;
        prevBit = currBit;
        n /= 2;
    }
    return true;
}


-----
public boolean hasAlternatingBits(int n) 
    // Your code here
}


************************************
Question ID: 694

import java.util.HashSet;
import java.util.ArrayList;
import java.util.Collections;

public int numDistinctIslands(int[][] grid) {
    HashSet<ArrayList<ArrayList<Integer>>> uniqueIslands = new HashSet<>();
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[0].length; j++) {
            if (grid[i][j] == 1) {
                ArrayList<ArrayList<Integer>> islandShape = new ArrayList<>();
                dfs(grid, i, j, i, j, islandShape);
                Collections.sort(islandShape, (shape1, shape2) -> {
                    int cmp = shape1.get(0).compareTo(shape2.get(0));
                    if (cmp != 0) return cmp;
                    return shape1.get(1).compareTo(shape2.get(1));
                });
                uniqueIslands.add(islandShape);
            }
        }
    }
    return uniqueIslands.size();
}

private void dfs(int[][] grid, int i, int j, int i0, int j0, ArrayList<ArrayList<Integer>> shape) {
    if (i >= 0 && i < grid.length && j >= 0 && j < grid[0].length && grid[i][j] == 1) {
        grid[i][j] = 2;
        ArrayList<Integer> current = new ArrayList<>();
        current.add(i - i0);
        current.add(j - j0);
        shape.add(current);
        dfs(grid, i - 1, j, i0, j0, shape);
        dfs(grid, i + 1, j, i0, j0, shape);
        dfs(grid, i, j - 1, i0, j0, shape);
        dfs(grid, i, j + 1, i0, j0, shape);
    }
}

-----
import java.util.HashSet;
import java.util.ArrayList;
import java.util.Collections;

public int numDistinctIslands(int[][] grid) 
    // Your code here
}

************************************
Question ID: 695

public int maxAreaOfIsland(int[][] grid) {
    int maxArea = 0;

    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[0].length; j++) {
            if (grid[i][j] == 1) {
                maxArea = Math.max(maxArea, dfs(grid, i, j));
            }
        }
    }
    return maxArea;
}

private int dfs(int[][] grid, int i, int j) {
    if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) {
        return 0;
    }
    grid[i][j] = 0;
    return 1 + dfs(grid, i - 1, j) + dfs(grid, i + 1, j) + dfs(grid, i, j - 1) + dfs(grid, i, j + 1);
}

-----
public int maxAreaOfIsland(int[][] grid) 
    // Your code here
}

************************************
Question ID: 696

public int countBinarySubstrings(String s) {
    int prev = 0, curr = 1, result = 0;
    for (int i = 1; i < s.length(); i++) {
        if (s.charAt(i) == s.charAt(i - 1)) {
            curr++;
        } else {
            result += Math.min(prev, curr);
            prev = curr;
            curr = 1;
        }
    }
    return result + Math.min(prev, curr);
}

-----
public int countBinarySubstrings(String s) 
    // Your code here
}

************************************
Question ID: 697

import java.util.HashMap;

class Solution {
    public int findShortestSubArray(int[] nums) {
        HashMap<Integer, Integer> freq_map = new HashMap<>(), start_map = new HashMap<>();
        int max_freq = 0, min_length = nums.length;
        
        for (int i = 0; i < nums.length; ++i) {
            if (!start_map.containsKey(nums[i])) {
                start_map.put(nums[i], i);
            }
            freq_map.put(nums[i], freq_map.getOrDefault(nums[i], 0) + 1);
            
            int freq = freq_map.get(nums[i]);
            if (freq > max_freq) {
                max_freq = freq;
                min_length = i - start_map.get(nums[i]) + 1;
            } else if (freq == max_freq) {
                min_length = Math.min(min_length, i - start_map.get(nums[i]) + 1);
            }
        }
        
        return min_length;
    }
}

-----
import java.util.HashMap;

class Solution 
    // Your code here
}

************************************
Question ID: 698

public boolean canPartitionKSubsets(int[] nums, int k) {
  int sum = 0;
  for (int num : nums) sum += num;
  if (sum % k != 0) return false;
  int target = sum / k;
  boolean[] visited = new boolean[nums.length];
  return dfs(nums, visited, 0, target, 0, k);
}

private boolean dfs(int[] nums, boolean[] visited, int start, int target, int curr_sum, int k) {
  if (k == 1) return true;
  if (curr_sum == target) return dfs(nums, visited, 0, target, 0, k - 1);
  for (int i = start; i < nums.length; i++) {
    if (!visited[i] && curr_sum + nums[i] <= target) {
      visited[i] = true;
      if (dfs(nums, visited, i + 1, target, curr_sum + nums[i], k)) return true;
      visited[i] = false;
    }
  }
  return false;
}

-----
public boolean canPartitionKSubsets(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 699

import java.util.ArrayList;
import java.util.List;

public int[] fallingSquares(int[][] positions) {
    int[] ans = new int[positions.length];
    List<int[]> intervals = new ArrayList<>();

    for (int i = 0; i < positions.length; i++) {
        int L = positions[i][0];
        int R = positions[i][0] + positions[i][1];
        int h = positions[i][1];
        for (int[] interval : intervals) {
            if (interval[1] > L && R > interval[1]) {
                h = Math.max(h, positions[i][1] + interval[0]);
            }
        }

        int maxHeight = h;
        for (int[] interval : intervals) {
            maxHeight = Math.max(maxHeight, interval[0]);
        }

        ans[i] = maxHeight;
        intervals.add(new int[]{h, R});
    }
    
    return ans;
}

-----
import java.util.ArrayList;
import java.util.List;

public int[] fallingSquares(int[][] positions) 
    // Your code here
}

************************************
Question ID: 702

public int search(ArrayReader reader, int target) {
    int left = 0, right = 1;
    while (reader.get(right) < target) {
        left = right;
        right <<= 1;
    }

    while (left <= right) {
        int mid = left + ((right - left) >> 1);
        int val = reader.get(mid);
        if (val == target)
            return mid;
        if (val > target)
            right = mid - 1;
        else
            left = mid + 1;
    }
    return -1;
}

-----
public int search(ArrayReader reader, int target) 
    // Your code here
}

************************************
Question ID: 703

import java.util.PriorityQueue;

class KthLargest {
    int k;
    PriorityQueue<Integer> minHeap;

    public KthLargest(int k, int[] nums) {
        this.k = k;
        minHeap = new PriorityQueue<>(k);
        for (int num : nums) {
            add(num);
        }
    }

    public int add(int val) {
        minHeap.offer(val);
        if (minHeap.size() > k) {
            minHeap.poll();
        }
        return minHeap.peek();
    }
}

-----
import java.util.PriorityQueue;

class KthLargest 
    // Your code here
}

************************************
Question ID: 704

public int search(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) return mid;
        if (nums[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}


-----
public int search(int[] nums, int target) 
    // Your code here
}


************************************
Question ID: 709

public String toLowerCase(String s) {
    char[] chars = s.toCharArray();
    for (int i = 0; i < chars.length; i++) {
        if (chars[i] >= 'A' && chars[i] <= 'Z') {
            chars[i] = (char)(chars[i] - 'A' + 'a');
        }
    }
    return new String(chars);
}

-----
public String toLowerCase(String s) 
    // Your code here
}

************************************
Question ID: 710

import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;

class Solution {
    private HashMap<Integer, Integer> mapping;
    private int last;
    private Random random;

    public Solution(int n, int[] blacklist) {
        Arrays.sort(blacklist);
        mapping = new HashMap<>();
        int idx = 0;
        for (int i = 0; i < blacklist.length; ++i) {
            int black = blacklist[i];
            while (idx < black) {
                mapping.put(idx++, --n);
            }
            idx++;
            n--;
        }
        last = n;
        random = new Random();
    }

    public int pick() {
        int num = random.nextInt(last);
        return mapping.getOrDefault(num, num);
    }
}

-----
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;

class Solution 
    // Your code here
}

************************************
Question ID: 712

public int minimumDeleteSum(String s1, String s2) {
    int[][] dp = new int[s1.length() + 1][s2.length() + 1];
    for (int i = 1; i <= s1.length(); i++) {
        dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1);
    }
    for (int j = 1; j <= s2.length(); j++) {
        dp[0][j] = dp[0][j - 1] + s2.charAt(j - 1);
    }
    for (int i = 1; i <= s1.length(); i++) {
        for (int j = 1; j <= s2.length(); j++) {
            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.min(dp[i - 1][j] + s1.charAt(i - 1), dp[i][j - 1] + s2.charAt(j - 1));
            }
        }
    }
    return dp[s1.length()][s2.length()];
}

-----
public int minimumDeleteSum(String s1, String s2) 
    // Your code here
}

************************************
Question ID: 713

public int numSubarrayProductLessThanK(int[] nums, int k) {
    if (k <= 1) return 0;
    int prod = 1, count = 0, left = 0;
    for (int right = 0; right < nums.length; right++) {
        prod *= nums[right];
        while (prod >= k) prod /= nums[left++];
        count += right - left + 1;
    }
    return count;
}

-----
public int numSubarrayProductLessThanK(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 714

public int maxProfit(int[] prices, int fee) {
    int cash = 0, hold = -prices[0];
    for (int price : prices) {
        int temp = cash;
        cash = Math.max(cash, hold + price - fee);
        hold = Math.max(hold, temp - price);
    }
    return cash;
}

-----
public int maxProfit(int[] prices, int fee) 
    // Your code here
}

************************************
Question ID: 716

import java.util.Stack;
import java.util.TreeSet;

class MaxStack {
    Stack<Integer> mainStack;
    TreeSet<Integer> maxSet;

    public MaxStack() {
        mainStack = new Stack<>();
        maxSet = new TreeSet<>();
    }

    public void push(int x) {
        mainStack.push(x);
        maxSet.add(x);
    }

    public int pop() {
        int top = mainStack.pop();
        maxSet.remove(top);
        return top;
    }

    public int top() {
        return mainStack.peek();
    }

    public int peekMax() {
        return maxSet.last();
    }

    public int popMax() {
        int max = maxSet.last();
        maxSet.remove(max);

        Stack<Integer> tempStack = new Stack<>();
        while (mainStack.peek() != max) {
            tempStack.push(mainStack.pop());
        }
        mainStack.pop();
        while (!tempStack.isEmpty()) {
            mainStack.push(tempStack.pop());
        }

        return max;
    }
}

-----
import java.util.Stack;
import java.util.TreeSet;

class MaxStack 
    // Your code here
}

************************************
Question ID: 717

boolean isOneBitCharacter(int[] bits) {
    int i;
    for (i = 0; i < bits.length - 1; i++) {
        i += bits[i];
    }
    return i == bits.length - 1;
}

-----
boolean isOneBitCharacter(int[] bits) 
    // Your code here
}

************************************
Question ID: 718

public int findLength(int[] nums1, int[] nums2) {
    int m = nums1.length;
    int n = nums2.length;
    int[][] dp = new int[m + 1][n + 1];
    int maxLength = 0;

    for (int i = m - 1; i >= 0; i--) {
        for (int j = n - 1; j >= 0; j--) {
            if (nums1[i] == nums2[j]) {
                dp[i][j] = dp[i + 1][j + 1] + 1;
                maxLength = Math.max(maxLength, dp[i][j]);
            }
        }
    }

    return maxLength;
}

-----
public int findLength(int[] nums1, int[] nums2) 
    // Your code here
}

************************************
Question ID: 719

import java.util.Arrays;

public int smallestDistancePair(int[] nums, int k) {
    Arrays.sort(nums);
    int low = 0, high = nums[nums.length - 1] - nums[0];
    
    while (low < high) {
        int mid = (low + high) / 2;
        int count = 0, left = 0;

        for (int right = 0; right < nums.length; ++right) {
            while (nums[right] - nums[left] > mid) {
                ++left;
            }
            count += (right - left);
        }

        if (count < k) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    
    return low;
}


-----
import java.util.Arrays;

public int smallestDistancePair(int[] nums, int k) 
    // Your code here
}


************************************
Question ID: 720

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

class Solution {
    public String longestWord(String[] words) {
        Arrays.sort(words);
        Set<String> builtWords = new HashSet<>();
        String result = "";

        for (String word : words) {
            if (word.length() == 1 || builtWords.contains(word.substring(0, word.length() - 1))) {
                result = (word.length() > result.length()) ? word : result;
                builtWords.add(word);
            }
        }

        return result;
    }
}


-----
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

class Solution 
    // Your code here
}


************************************
Question ID: 721

import java.util.*;

public List<List<String>> accountsMerge(List<List<String>> accounts) {
    Map<String, Integer> emailToId = new HashMap<>();
    for (int i = 0; i < accounts.size(); ++i) {
        for (int j = 1; j < accounts.get(i).size(); ++j) {
            emailToId.put(accounts.get(i).get(j), i);
        }
    }

    List<List<String>> result = new ArrayList<>();
    boolean[] visited = new boolean[accounts.size()];
    for (int i = 0; i < accounts.size(); ++i) {
        if (!visited[i]) {
            Set<String> mergedEmails = new HashSet<>();
            dfs(i, accounts, visited, mergedEmails, emailToId);
            List<String> mergedAccount = new ArrayList<>(mergedEmails);
            Collections.sort(mergedAccount);
            mergedAccount.add(0, accounts.get(i).get(0));
            result.add(mergedAccount);
        }
    }
    return result;
}

private void dfs(int id, List<List<String>> accounts, boolean[] visited, Set<String> mergedEmails, Map<String, Integer> emailToId) {
    if (visited[id]) return;
    visited[id] = true;
    for (int j = 1; j < accounts.get(id).size(); ++j) {
        String email = accounts.get(id).get(j);
        mergedEmails.add(email);
        int nextId = emailToId.get(email);
        dfs(nextId, accounts, visited, mergedEmails, emailToId);
    }
}


-----
import java.util.*;

public List<List<String>> accountsMerge(List<List<String>> accounts) 
    // Your code here
}


************************************
Question ID: 722

public List<String> removeComments(String[] source) {
    List<String> result = new ArrayList<>();
    StringBuilder buffer = new StringBuilder();
    boolean inBlockComment = false;

    for (String line : source) {
        for (int i = 0; i < line.length(); ++i) {
            if (inBlockComment) {
                if (i < line.length() - 1 && line.charAt(i) == '*' && line.charAt(i + 1) == '/') {
                    inBlockComment = false;
                    ++i;
                }
            } else {
                if (i < line.length() - 1 && line.charAt(i) == '/' && line.charAt(i + 1) == '*') {
                    inBlockComment = true;
                    ++i;
                } else if (i < line.length() - 1 && line.charAt(i) == '/' && line.charAt(i + 1) == '/') {
                    break;
                } else {
                    buffer.append(line.charAt(i));
                }
            }
        }
        if (!inBlockComment && buffer.length() > 0) {
            result.add(buffer.toString());
            buffer.setLength(0);
        }
    }
    return result;
}


-----
public List<String> removeComments(String[] source) 
    // Your code here
}


************************************
Question ID: 723

public int[][] candyCrush(int[][] board) {
    int rows = board.length, cols = board[0].length;
    boolean toDo = false;
    
    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols - 2; c++) {
            int val = Math.abs(board[r][c]);
            if (val != 0 && val == Math.abs(board[r][c + 1]) && val == Math.abs(board[r][c + 2])) {
                board[r][c] = board[r][c + 1] = board[r][c + 2] = -val;
                toDo = true;
            }
        }
    }
    
    for (int r = 0; r < rows - 2; r++) {
        for (int c = 0; c < cols; c++) {
            int val = Math.abs(board[r][c]);
            if (val != 0 && val == Math.abs(board[r + 1][c]) && val == Math.abs(board[r + 2][c])) {
                board[r][c] = board[r + 1][c] = board[r + 2][c] = -val;
                toDo = true;
            }
        }
    }
    
    for (int c = 0; c < cols; c++) {
        int wr = rows - 1;
        for (int r = rows - 1; r >= 0; r--)
            if (board[r][c] > 0)
                board[wr--][c] = board[r][c];
        while (wr >= 0)
            board[wr--][c] = 0;
    }
    
    return toDo ? candyCrush(board) : board;
}

-----
public int[][] candyCrush(int[][] board) 
    // Your code here
}

************************************
Question ID: 724

public int pivotIndex(int[] nums) {
    int total_sum = 0, left_sum = 0;
    for (int num : nums)
        total_sum += num;
    for (int i = 0; i < nums.length; ++i) {
        if (left_sum == total_sum - left_sum - nums[i])
            return i;
        left_sum += nums[i];
    }
    return -1;
}


-----
public int pivotIndex(int[] nums) 
    // Your code here
}


************************************
Question ID: 726

import java.util.Map;
import java.util.TreeMap;

public String countOfAtoms(String formula) {
    int[] i = {0};
    Map<String, Integer> counts = parse(formula, i);
    StringBuilder ans = new StringBuilder();
    for (Map.Entry<String, Integer> entry : counts.entrySet()) {
        ans.append(entry.getKey());
        if (entry.getValue() > 1) ans.append(entry.getValue());
    }
    return ans.toString();
}

private Map<String, Integer> parse(String formula, int[] i) {
    Map<String, Integer> counts = new TreeMap<>();
    while (i[0] < formula.length()) {
        if (formula.charAt(i[0]) == '(') {
            Map<String, Integer> temp = parse(formula, new int[]{++i[0]});
            int count = 0;
            while (i[0] < formula.length() && Character.isDigit(formula.charAt(i[0]))) {
                count = count * 10 + (formula.charAt(i[0]++) - '0');
            }
            if (count == 0) count = 1;
            for (Map.Entry<String, Integer> entry : temp.entrySet()) {
                counts.put(entry.getKey(), counts.getOrDefault(entry.getKey(), 0) + entry.getValue() * count);
            }
        } else if (formula.charAt(i[0]) == ')') {
            ++i[0];
            return counts;
        } else {
            StringBuilder name = new StringBuilder().append(formula.charAt(i[0]++));
            while (i[0] < formula.length() && Character.isLowerCase(formula.charAt(i[0]))) {
                name.append(formula.charAt(i[0]++));
            }
            int count = 0;
            while (i[0] < formula.length() && Character.isDigit(formula.charAt(i[0]))) {
                count = count * 10 + (formula.charAt(i[0]++) - '0');
            }
            if (count == 0) count = 1;
            counts.put(name.toString(), counts.getOrDefault(name.toString(), 0) + count);
        }
    }
    return counts;
}


-----
import java.util.Map;
import java.util.TreeMap;

public String countOfAtoms(String formula) 
    // Your code here
}


************************************
Question ID: 727

public String minWindowSubSequence(String s1, String s2) {
    int m = s1.length(), n = s2.length();
    int[][] dp = new int[n + 1][m + 1];

    for (int j = 0; j <= m; ++j) {
        dp[0][j] = j;
    }

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (s1.charAt(j - 1) == s2.charAt(i - 1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = dp[i][j - 1];
            }
        }
    }
    
    int start = 0, length = m + 1;
    for (int j = 1; j <= m; ++j) {
        if (dp[n][j] != 0 && j - dp[n][j] < length) {
            start = dp[n][j];
            length = j - start;
        }
    }

    return length == m + 1 ? "" : s1.substring(start, start + length);
}

-----
public String minWindowSubSequence(String s1, String s2) 
    // Your code here
}

************************************
Question ID: 728

import java.util.ArrayList;
import java.util.List;

public class Solution {
    public static boolean isSelfDividing(int num) {
        int n = num;
        while (n != 0) {
            int digit = n % 10;
            if (digit == 0 || num % digit != 0)
                return false;
            n /= 10;
        }
        return true;
    }

    public static List<Integer> selfDividingNumbers(int left, int right) {
        List<Integer> result = new ArrayList<>();
        for (int i = left; i <= right; ++i) {
            if (isSelfDividing(i))
                result.add(i);
        }
        return result;
    }
}

-----
import java.util.ArrayList;
import java.util.List;

public class Solution 
    // Your code here
}

************************************
Question ID: 729

import java.util.TreeMap;

class MyCalendar {
    private TreeMap<Integer, Integer> calendar;

    public MyCalendar() {
        calendar = new TreeMap<>();
    }

    public boolean book(int start, int end) {
        Integer prevStart = calendar.floorKey(start);
        Integer nextStart = calendar.ceilingKey(start);

        if ((prevStart == null || calendar.get(prevStart) <= start) &&
            (nextStart == null || end <= nextStart)) {
            calendar.put(start, end);
            return true;
        }
        return false;
    }
}

-----
import java.util.TreeMap;

class MyCalendar 
    // Your code here
}

************************************
Question ID: 730

public int countPalindromicSubsequences(String S) {
    int n = S.length();
    int mod = 1000000007;
    int[][] dp = new int[4][n + 1];

    for (int i = n - 1; i >= 0; i--) {
        for (int j = i + 1; j <= n; j++) {
            int c = S.charAt(i) - 'a';
            dp[c][j] = dp[0][j - 1] + dp[1][j - 1] + dp[2][j - 1] + dp[3][j - 1] - dp[c][i] + 2;
            if (dp[c][j] < 0) dp[c][j] += mod;
        }
    }

    return (dp[0][n] + dp[1][n] + dp[2][n] + dp[3][n]) % mod;
}


-----
public int countPalindromicSubsequences(String S) 
    // Your code here
}


************************************
Question ID: 732

import java.util.TreeMap;

class MyCalendarThree {
    private TreeMap<Integer, Integer> timeline = new TreeMap<>();

    public int book(int start, int end) {
        timeline.put(start, timeline.getOrDefault(start, 0) + 1);
        timeline.put(end, timeline.getOrDefault(end, 0) - 1);
        int ongoing = 0, k = 0;
        for (int value : timeline.values()) {
            k = Math.max(k, ongoing += value);
        }
        return k;
    }
}


-----
import java.util.TreeMap;

class MyCalendarThree 
    // Your code here
}


************************************
Question ID: 733

public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
    int startColor = image[sr][sc];
    fill(image, sr, sc, newColor, startColor);
    return image;
}

private void fill(int[][] image, int sr, int sc, int newColor, int startColor) {
    if (sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length || image[sr][sc] != startColor || image[sr][sc] == newColor) return;
    image[sr][sc] = newColor;
    fill(image, sr - 1, sc, newColor, startColor);
    fill(image, sr + 1, sc, newColor, startColor);
    fill(image, sr, sc - 1, newColor, startColor);
    fill(image, sr, sc + 1, newColor, startColor);
}


-----
public int[][] floodFill(int[][] image, int sr, int sc, int newColor) 
    // Your code here
}


************************************
Question ID: 734

import java.util.*;

public boolean areSentencesSimilar(String[] sentence1, String[] sentence2, List<List<String>> similarPairs) {
    if (sentence1.length != sentence2.length) return false;
    Map<String, Set<String>> similarityMap = new HashMap<>();
    for (List<String> pair : similarPairs) {
        similarityMap.putIfAbsent(pair.get(0), new HashSet<>());
        similarityMap.putIfAbsent(pair.get(1), new HashSet<>());
        similarityMap.get(pair.get(0)).add(pair.get(1));
        similarityMap.get(pair.get(1)).add(pair.get(0));
    }
    for (int i = 0; i < sentence1.length; ++i) {
        if (!sentence1[i].equals(sentence2[i]) && !similarityMap.getOrDefault(sentence1[i], Collections.emptySet()).contains(sentence2[i]))
            return false;
    }
    return true;
}


-----
import java.util.*;

public boolean areSentencesSimilar(String[] sentence1, String[] sentence2, List<List<String>> similarPairs) 
    // Your code here
}


************************************
Question ID: 735

import java.util.*;
class Solution {
    public int[] asteroidCollision(int[] asteroids) {
        Stack<Integer> s = new Stack<>();
        for (int i = 0; i < asteroids.length; i++) {
            if (asteroids[i] > 0 || s.isEmpty() || s.peek() < 0) {
                s.push(asteroids[i]);
            } else if (s.peek() <= -asteroids[i]) {
                if (s.peek() < -asteroids[i]) i--;
                s.pop();
            }
        }
        int[] ans = new int[s.size()];
        for (int i = ans.length - 1; i >= 0; i--) {
            ans[i] = s.pop();
        }
        return ans;
    }
}


-----
import java.util.*;
class Solution 
    // Your code here
}


************************************
Question ID: 736

import java.util.HashMap;

public class Solution {
    public int evaluate(String expression) {
        return calculate(expression, 0, expression.length(), new HashMap<>());
    }

    private int calculate(String expression, int start, int end, HashMap<String, Integer> variables) {
        if (expression.charAt(start) == '(') {
            if (expression.startsWith("add", start + 1)) {
                int first = start + 5;
                int[] second = new int[]{first};
                int value1 = calculate(expression, first, end, variables, second);
                int value2 = calculate(expression, second[0] + 1, end, variables, null);
                return value1 + value2;
            } else if (expression.startsWith("mult", start + 1)) {
                int first = start + 6;
                int[] second = new int[]{first};
                int value1 = calculate(expression, first, end, variables, second);
                int value2 = calculate(expression, second[0] + 1, end, variables, null);
                return value1 * value2;
            } else {
                HashMap<String, Integer> inner = variables;
                for (int idx = start + 5; idx < end - 1 && expression.charAt(idx) != '('; ) {
                    int temp = idx;
                    idx = expression.indexOf(' ', idx + 1);
                    String var = expression.substring(temp, idx);
                    temp = idx + 1;
                    if (expression.charAt(temp) == '(') {
                        idx++;
                    } else {
                        idx = expression.indexOf(' ', idx + 1);
                    }
                    int result = calculate(expression, temp, idx, variables, null);
                    inner = new HashMap<>(variables);
                    inner.put(var, result);
                }
                return calculate(expression, end - 1, end, inner, null);
            }
        } else {
            if (Character.isDigit(expression.charAt(start)) || expression.charAt(start) == '-') {
                end = expression.indexOf(' ', start);
                if (end == -1) {
                    end = expression.length();
                }
                return Integer.parseInt(expression.substring(start, end));
            } else {
                end = expression.indexOf(' ', start);
                if (end == -1) {
                    end = expression.length();
                }
                return variables.get(expression.substring(start, end));
            }
        }
    }

    private int calculate(String expression, int start, int end, HashMap<String, Integer> variables, int[] nextStart) {
        int temp = end;
        int result = calculate(expression, start, end, variables);
        if (nextStart != null) {
            nextStart[0] = temp;
        }
        return result;
    }
}

-----
import java.util.HashMap;

public class Solution 
    // Your code here
}

************************************
Question ID: 737

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public boolean areSentencesSimilar(String[] sentence1, String[] sentence2, List<List<String>> pairs) {
    if (sentence1.length != sentence2.length) return false;
    
    Map<String, Set<String>> graph = new HashMap<>();
    for (List<String> p : pairs) {
        graph.putIfAbsent(p.get(0), new HashSet<>());
        graph.putIfAbsent(p.get(1), new HashSet<>());
        graph.get(p.get(0)).add(p.get(1));
        graph.get(p.get(1)).add(p.get(0));
    }
    
    for (int i = 0; i < sentence1.length; ++i) {
        if (sentence1[i].equals(sentence2[i])) continue;
        if (!graph.getOrDefault(sentence1[i], new HashSet<>()).contains(sentence2[i])) return false;
    }
    return true;
}

-----
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public boolean areSentencesSimilar(String[] sentence1, String[] sentence2, List<List<String>> pairs) 
    // Your code here
}

************************************
Question ID: 738

public int monotoneIncreasingDigits(int n) {
    char[] n_str = String.valueOf(n).toCharArray();
    int n_len = n_str.length;

    int i = n_len - 1;
    while (i > 0) {
        if (n_str[i] < n_str[i - 1]) {
            n_str[i - 1] -= 1;
            for (int j = i; j < n_len; ++j) {
                n_str[j] = '9';
            }
        }
        --i;
    }

    return Integer.parseInt(new String(n_str));
}

-----
public int monotoneIncreasingDigits(int n) 
    // Your code here
}

************************************
Question ID: 739

import java.util.Stack;

public int[] dailyTemperatures(int[] temperatures) {
    int[] result = new int[temperatures.length];
    Stack<Integer> stack = new Stack<>();

    for (int i = 0; i < temperatures.length; i++) {
        while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
            int idx = stack.pop();
            result[idx] = i - idx;
        }
        stack.push(i);
    }

    return result;
}

-----
import java.util.Stack;

public int[] dailyTemperatures(int[] temperatures) 
    // Your code here
}

************************************
Question ID: 740

public int maxPoints(int[] nums) {
    int[] dp = new int[100001];
    int max_points = 0;
    for (int num : nums) {
        dp[num]++;
    }
    for (int i = 2; i < dp.length; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + i * dp[i]);
        max_points = Math.max(max_points, dp[i]);
    }
    return max_points;
}

-----
public int maxPoints(int[] nums) 
    // Your code here
}

************************************
Question ID: 741

public int cherryPickup(int[][] grid) {
    int N = grid.length;
    int[][][] dp = new int[N][N][N];
    for (int[][] layer: dp)
        for (int[] row: layer)
            Arrays.fill(row, Integer.MIN_VALUE);

    return Math.max(0, dp(0, 0, 0, grid, dp));
}

public int dp(int r1, int c1, int c2, int[][] grid, int[][][] memo) {
    int r2 = r1 + c1 - c2;
    if (r1 == grid.length || r2 == grid.length || c1 == grid.length || c2 == grid.length ||
            grid[r1][c1] == -1 || grid[r2][c2] == -1) {
        return Integer.MIN_VALUE;
    } else if (r1 == grid.length - 1 && c1 == grid.length - 1) {
        return grid[r1][c1];
    } else if (memo[r1][c1][c2] != Integer.MIN_VALUE) {
        return memo[r1][c1][c2];
    } else {
        memo[r1][c1][c2] = grid[r1][c1] + (r1 != r2 ? grid[r2][c2] : 0);
        int tempMax = Math.max(Math.max(dp(r1+1, c1, c2+1, grid, memo), dp(r1, c1+1, c2+1, grid, memo)),
                        Math.max(dp(r1+1, c1, c2, grid, memo), dp(r1, c1+1, c2, grid, memo)));
        memo[r1][c1][c2] += tempMax;
    }
    return memo[r1][c1][c2];
}


-----
public int cherryPickup(int[][] grid) 
    // Your code here
}


************************************
Question ID: 742

public String toLowerCase(String s) {
    return s.toLowerCase();
}

-----
public String toLowerCase(String s) 
    // Your code here
}

************************************
Question ID: 743

import java.util.*;

public int networkDelayTime(int[][] times, int n, int k) {
    Map<Integer, List<int[]>> graph = new HashMap<>();
    for (int[] edge : times) {
        graph.putIfAbsent(edge[0], new ArrayList<>());
        graph.get(edge[0]).add(new int[]{edge[1], edge[2]});
    }

    int[] dist = new int[n+1];
    Arrays.fill(dist, Integer.MAX_VALUE);
    dist[k] = 0;

    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);
    pq.offer(new int[]{k, 0});

    while (!pq.isEmpty()) {
        int[] curr = pq.poll();
        int u = curr[0], currDist = curr[1];

        List<int[]> neighbors = graph.get(u);
        if (neighbors == null) continue;

        for (int[] neighbor : neighbors) {
            int v = neighbor[0], weight = neighbor[1];
            if (currDist + weight < dist[v]) {
                dist[v] = currDist + weight;
                pq.offer(new int[]{v, dist[v]});
            }
        }
    }

    int maxTime = 0;
    for (int i = 1; i <= n; ++i) {
        if (dist[i] == Integer.MAX_VALUE) return -1;
        maxTime = Math.max(maxTime, dist[i]);
    }

    return maxTime;
}

-----
import java.util.*;

public int networkDelayTime(int[][] times, int n, int k) 
    // Your code here
}

************************************
Question ID: 744

import java.util.*;

class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        List<List<int[]>> graph = new ArrayList<>();
        for (int i = 0; i <= n; i++)
            graph.add(new ArrayList<>());
        for (int[] edge : times)
            graph.get(edge[0]).add(new int[]{edge[1], edge[2]});
        
        int[] dist = new int[n + 1];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[k] = 0;
        
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        pq.add(new int[]{0, k});
        
        while (!pq.isEmpty()) {
            int[] curr = pq.poll();
            int time = curr[0], node = curr[1];
            
            if (time > dist[node]) continue;
            for (int[] neighbour : graph.get(node)) {
                int neighbourNode = neighbour[0], neighbourTime = neighbour[1];
                if (time + neighbourTime < dist[neighbourNode]) {
                    dist[neighbourNode] = time + neighbourTime;
                    pq.add(new int[]{dist[neighbourNode], neighbourNode});
                }
            }
        }
        
        int maxTime = Arrays.stream(dist).skip(1).max().getAsInt();
        return maxTime == Integer.MAX_VALUE ? -1 : maxTime;
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 745

public char nextGreatestLetter(char[] letters, char target) {
    for (char letter : letters) {
        if (letter > target) {
            return letter;
        }
    }
    return letters[0];
}

-----
public char nextGreatestLetter(char[] letters, char target) 
    // Your code here
}

************************************
Question ID: 747

public int minCostClimbingStairs(int[] cost) {
    for(int i=2; i<cost.length; i++)
        cost[i] += Math.min(cost[i-1], cost[i-2]);
    return Math.min(cost[cost.length-1], cost[cost.length-2]);
}

-----
public int minCostClimbingStairs(int[] cost) 
    // Your code here
}

************************************
Question ID: 748

import java.util.HashMap;

public String shortestCompletingWord(String licensePlate, String[] words) {
    HashMap<Character, Integer> lpCount = new HashMap<>();
    for (char c : licensePlate.toCharArray()) {
        if (Character.isLetter(c)) {
            char lower = Character.toLowerCase(c);
            lpCount.put(lower, lpCount.getOrDefault(lower, 0) + 1);
        }
    }

    String result = "";
    for (String word : words) {
        HashMap<Character, Integer> wordCount = new HashMap<>();
        for (char c : word.toCharArray()) {
            wordCount.put(c, wordCount.getOrDefault(c, 0) + 1);
        }

        boolean valid = true;
        for (char ch : lpCount.keySet()) {
            if (wordCount.getOrDefault(ch, 0) < lpCount.get(ch)) {
                valid = false;
                break;
            }
        }

        if (valid && (result.isEmpty() || word.length() < result.length())) {
            result = word;
        }
    }
    return result;
}


-----
import java.util.HashMap;

public String shortestCompletingWord(String licensePlate, String[] words) 
    // Your code here
}


************************************
Question ID: 749

import java.util.HashMap;

public String shortestCompletingWord(String licensePlate, String[] words) {
    HashMap<Character, Integer> target = new HashMap<>();
    for (char c : licensePlate.toCharArray()) {
        if (Character.isLetter(c)) {
            char lower_c = Character.toLowerCase(c);
            target.put(lower_c, target.getOrDefault(lower_c, 0) + 1);
        }
    }

    String result = null;
    for (String word : words) {
        HashMap<Character, Integer> current = new HashMap<>();
        for (char c : word.toCharArray())
            if (Character.isLetter(c)) {
                char lower_c = Character.toLowerCase(c);
                current.put(lower_c, current.getOrDefault(lower_c, 0) + 1);
            }

        boolean valid = true;
        for (char c : target.keySet()) {
            if (current.getOrDefault(c, 0) < target.get(c)) {
                valid = false;
                break;
            }
        }

        if (valid && (result == null || word.length() < result.length())) result = word;
    }

    return result;
}

-----
import java.util.HashMap;

public String shortestCompletingWord(String licensePlate, String[] words) 
    // Your code here
}

************************************
Question ID: 750

public int countCornerRectangles(int[][] grid) {
    int count = 0;
    int m = grid.length;
    int n = grid[0].length;
    
    for (int i = 0; i < m - 1; i++) {
        for (int j = 0; j < n - 1; j++) {
            if (grid[i][j] == 1) {
                for (int k = i + 1; k < m; k++) {
                    for (int l = j + 1; l < n; l++) {
                        if (grid[k][l] == 1 && grid[i][l] == 1 && grid[k][j] == 1) {
                            count++;
                        }
                    }
                }
            }
        }
    }
    return count;
}

-----
public int countCornerRectangles(int[][] grid) 
    // Your code here
}

************************************
Question ID: 751

import java.util.ArrayList;
import java.util.List;

public List<String> ipToCIDR(String ip, int n) {
    String[] parts = ip.split("\\.");
    int start = (Integer.parseInt(parts[0]) << 24) + (Integer.parseInt(parts[1]) << 16) + (Integer.parseInt(parts[2]) << 8) + Integer.parseInt(parts[3]);
    int end = start + n - 1;
    
    List<String> ans = new ArrayList<>();
    while (start <= end) {
        int samePrefixBits = Integer.numberOfTrailingZeros(~(start & -start));
        while (((end - start) >> samePrefixBits) < 1)
            --samePrefixBits;
        int range = 1 << samePrefixBits;
        ans.add((start >> 24) + "." + ((start >> 16) & 255) + "." + ((start >> 8) & 255) + "." + (start & 255) + "/" + (32 - samePrefixBits));
        start += range;
    }
    
    return ans;
}


-----
import java.util.ArrayList;
import java.util.List;

public List<String> ipToCIDR(String ip, int n) 
    // Your code here
}


************************************
Question ID: 752

import java.util.*;

public int openLock(String[] deadends, String target) {
    Set<String> dead = new HashSet<>(Arrays.asList(deadends));
    Set<String> visited = new HashSet<>();
    Queue<String> q = new LinkedList<>();
    String start = "0000";

    if (dead.contains(start)) return -1;
    q.offer(start);
    visited.add(start);

    int moves = 0;
    while (!q.isEmpty()) {
        int levelSize = q.size();
        for (int i = 0; i < levelSize; i++) {
            String cur = q.poll();

            if (cur.equals(target)) return moves;

            for (int j = 0; j < 4; j++) {
                for (int k = -1; k <= 1; k += 2) {
                    String next = cur.substring(0, j) + (char)((cur.charAt(j) - '0' + k + 10) % 10 + '0') + cur.substring(j + 1);

                    if (!visited.contains(next) && !dead.contains(next)) {
                        visited.add(next);
                        q.offer(next);
                    }
                }
            }
        }
        moves++;
    }

    return -1;
}


-----
import java.util.*;

public int openLock(String[] deadends, String target) 
    // Your code here
}


************************************
Question ID: 753

import java.util.*;

public int openLock(String[] deadends, String target) {
    Set<String> dead = new HashSet<>(Arrays.asList(deadends));
    Set<String> visited = new HashSet<>();
    Queue<String[]> wheelStates = new LinkedList<>();

    if (dead.contains("0000")) return -1;
    wheelStates.add(new String[]{"0000", "0"});
    visited.add("0000");

    while (!wheelStates.isEmpty()) {
        String[] currentStateTurn = wheelStates.poll();
        String currentState = currentStateTurn[0];
        int turns = Integer.parseInt(currentStateTurn[1]);

        if (currentState.equals(target)) return turns;

        for (int i = 0; i < 4; ++i) {
            char[] upStateArr = currentState.toCharArray();
            char[] downStateArr = currentState.toCharArray();
            upStateArr[i] = (char)(((upStateArr[i] - '0' + 1) % 10) + '0');
            downStateArr[i] = (char)(((downStateArr[i] - '0' + 9) % 10) + '0');
            String upState = new String(upStateArr);
            String downState = new String(downStateArr);

            if (!visited.contains(upState) && !dead.contains(upState)) {
                wheelStates.add(new String[]{upState, String.valueOf(turns + 1)});
                visited.add(upState);
            }

            if (!visited.contains(downState) && !dead.contains(downState)) {
                wheelStates.add(new String[]{downState, String.valueOf(turns + 1)});
                visited.add(downState);
            }
        }
    }
    return -1;
}

-----
import java.util.*;

public int openLock(String[] deadends, String target) 
    // Your code here
}

************************************
Question ID: 754

public int reachNumber(int target) {
    target = Math.abs(target);
    int step = 0, sum = 0;
    while (sum < target) {
        step++;
        sum += step;
    }
    while ((sum - target) % 2 != 0) {
        step++;
        sum += step;
    }
    return step;
}


-----
public int reachNumber(int target) 
    // Your code here
}


************************************
Question ID: 755

public int minMoves(int target) {
    target = Math.abs(target);
    int step = 0;
    int sum = 0;
    while (sum < target || (sum - target) % 2 != 0) {
        step++;
        sum += step;
    }
    return step;
}


-----
public int minMoves(int target) 
    // Your code here
}


************************************
Question ID: 756

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public boolean pyramidTransition(String bottom, List<String> allowed) {
    Map<String, List<Character>> mapping = new HashMap<>();
    for (String s : allowed) {
        mapping.computeIfAbsent(s.substring(0, 2), k -> new ArrayList<>()).add(s.charAt(2));
    }
    return pyramidTransitionHelper(bottom, "", 0, mapping);
}

private boolean pyramidTransitionHelper(String bottom, String top, int idx, Map<String, List<Character>> mapping) {
    if (bottom.length() == 1) return true;
    if (idx == bottom.length() - 1) return pyramidTransitionHelper(top, "", 0, mapping);
    String key = bottom.substring(idx, idx + 2);
    if (!mapping.containsKey(key)) return false;
    for (Character c : mapping.get(key)) {
        if (pyramidTransitionHelper(bottom, top + c, idx + 1, mapping)) return true;
    }
    return false;
}


-----
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public boolean pyramidTransition(String bottom, List<String> allowed) 
    // Your code here
}


************************************
Question ID: 757

import java.util.*;

public boolean pyramidTransition(String bottom, List<String> allowed) {
    Map<String, List<Character>> mapping = new HashMap<>();
    for (String s : allowed) {
        String key = s.substring(0, 2);
        if (!mapping.containsKey(key)) {
            mapping.put(key, new ArrayList<>());
        }
        mapping.get(key).add(s.charAt(2));
    }
    return dfs("", bottom, mapping);
}

public boolean dfs(String curr, String bottom, Map<String, List<Character>> mapping) {
    if (bottom.length() == 1) return true;
    for (int i = 0; i < bottom.length() - 1; ++i) {
        if (!mapping.containsKey(bottom.substring(i, i + 2))) return false;
    }
    curr = "";
    for (int i = 0; i < bottom.length() - 1; ++i) {
        curr += mapping.get(bottom.substring(i, i + 2)).get(0);
    }
    return dfs(curr, curr, mapping);
}


-----
import java.util.*;

public boolean pyramidTransition(String bottom, List<String> allowed) 
    // Your code here
}


************************************
Question ID: 758

import java.util.List;

public String addBoldTag(List<String> words, String s) {
    boolean[] bold = new boolean[s.length()];
    for (String word : words) {
        int pos = s.indexOf(word);
        while (pos != -1) {
            for (int i = pos; i < pos + word.length(); i++) {
                bold[i] = true;
            }
            pos = s.indexOf(word, pos + 1);
        }
    }

    StringBuilder result = new StringBuilder();
    for (int i = 0; i < s.length(); i++) {
        if (bold[i] && (i == 0 || !bold[i - 1])) result.append("<b>");
        result.append(s.charAt(i));
        if (bold[i] && (i == s.length() - 1 || !bold[i + 1])) result.append("</b>");
    }

    return result.toString();
}

-----
import java.util.List;

public String addBoldTag(List<String> words, String s) 
    // Your code here
}

************************************
Question ID: 759

import java.util.Arrays;
import java.util.Comparator;

public int minSetSize(int[][] intervals) {
    Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));
    int n = intervals.length;
    int end = intervals[0][1];
    int count = 1;

    for (int i = 1; i < n; i++) {
        if (end < intervals[i][0]) {
            end = intervals[i][1];
            count++;
        } else {
            end = Math.min(end, intervals[i][1]);
        }
    }
    return count * 2;
}

-----
import java.util.Arrays;
import java.util.Comparator;

public int minSetSize(int[][] intervals) 
    // Your code here
}

************************************
Question ID: 760

import java.util.*;

public int[] anagramMappings(int[] nums1, int[] nums2) {
    HashMap<Integer, Integer> num_map = new HashMap<>();
    for (int i = 0; i < nums2.length; i++) {
        num_map.put(nums2[i], i);
    }
    int[] mapping = new int[nums1.length];
    for (int i = 0; i < nums1.length; i++) {
        mapping[i] = num_map.get(nums1[i]);
    }
    return mapping;
}


-----
import java.util.*;

public int[] anagramMappings(int[] nums1, int[] nums2) 
    // Your code here
}


************************************
Question ID: 761

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public String makeLargestSpecial(String s) {
    int count = 0;
    int i = 0;
    List<String> subs = new ArrayList<>();

    for (int j = 0; j < s.length(); j++) {
        if (s.charAt(j) == '1') count++;
        else count--;

        if (count == 0) {
            subs.add("1" + makeLargestSpecial(s.substring(i+1, j)) + "0");
            i = j + 1;
        }
    }

    Collections.sort(subs, Collections.reverseOrder());
    StringBuilder res = new StringBuilder();
    for (String sub : subs) {
        res.append(sub);
    }
    return res.toString();
}


-----
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public String makeLargestSpecial(String s) 
    // Your code here
}


************************************
Question ID: 762

class Solution {
    boolean isPrime(int n) {
        if (n <= 1) return false;
        if (n <= 3) return true;
        if (n % 2 == 0 || n % 3 == 0) return false;
        for (int i = 5; i * i <= n; i += 6)
            if (n % i == 0 || n % (i + 2) == 0) return false;
        return true;
    }
    
    public int countPrimeSetBits(int left, int right) {
        int count = 0;
        for (int i = left; i <= right; ++i)
            count += isPrime(Integer.bitCount(i)) ? 1 : 0;
        return count;
    }
}


-----
class Solution 
    // Your code here
}


************************************
Question ID: 763

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public List<Integer> partitionLabels(String s) {
    Map<Character, Integer> last = new HashMap<>();
    for (int i = 0; i < s.length(); i++) {
        last.put(s.charAt(i), i);
    }
    List<Integer> ans = new ArrayList<>();
    int j = 0, anchor = 0;
    for (int i = 0; i < s.length(); i++) {
        j = Math.max(j, last.get(s.charAt(i)));
        if (i == j) {
            ans.add(i - anchor + 1);
            anchor = i + 1;
        }
    }
    return ans;
}

-----
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public List<Integer> partitionLabels(String s) 
    // Your code here
}

************************************
Question ID: 764

import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.LinkedList;

class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val,List<Node> _children) {
        val = _val;
        children = _children;
    }
}

public List<List<Integer>> levelOrder(Node root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) return result;

    Queue<Node> toVisit = new LinkedList<>();
    toVisit.offer(root);

    while (!toVisit.isEmpty()) {
        int size = toVisit.size();
        List<Integer> level = new ArrayList<>();

        for (int i = 0; i < size; i++) {
            Node currentNode = toVisit.poll();
            level.add(currentNode.val);

            for (Node child : currentNode.children) {
                toVisit.offer(child);
            }
        }
        result.add(level);
    }

    return result;
}

-----
import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.LinkedList;

class Node 
    // Your code here
}

************************************
Question ID: 765

public int minSwapsCouples(int[] row) {
    int n = row.length;
    int[] position = new int[n];
    for (int i = 0; i < n; ++i)
        position[row[i]] = i;

    int swaps = 0;
    for (int i = 0; i < n; i += 2) {
        int partner = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1;
        if (row[i + 1] != partner) {
            int temp = row[position[partner]];
            row[position[partner]] = row[i + 1];
            row[i + 1] = temp;
            
            temp = position[row[i + 1]];
            position[row[i + 1]] = position[partner];
            position[partner] = temp;
            
            swaps++;
        }
    }
    return swaps;
}


-----
public int minSwapsCouples(int[] row) 
    // Your code here
}


************************************
Question ID: 767

public boolean isPrime(int n) {
    if (n <= 1) return false;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) return false;
    }
    return true;
}

public int countPrimeSetBits(int left, int right) {
    int count = 0;
    for (int i = left; i <= right; i++) {
        int bits = Integer.bitCount(i);
        if (isPrime(bits)) count++;
    }
    return count;
}

-----
public boolean isPrime(int n) 
    // Your code here
}

************************************
Question ID: 768

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public List<Integer> partitionLabels(String s) {
    HashMap<Character, Integer> lastPos = new HashMap<>();
    for (int i = 0; i < s.length(); i++) {
        lastPos.put(s.charAt(i), i);
    }

    List<Integer> partitions = new ArrayList<>();
    int start = 0, end = 0;
    for (int i = 0; i < s.length(); i++) {
        end = Math.max(end, lastPos.get(s.charAt(i)));
        if (i == end) {
            partitions.add(end - start + 1);
            start = i + 1;
        }
    }
    return partitions;
}


-----
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public List<Integer> partitionLabels(String s) 
    // Your code here
}


************************************
Question ID: 769

public int orderOfLargestPlusSign(int n, int[][] mines) {
    int[][] grid = new int[n][n];
    for (int[] row : grid) Arrays.fill(row, 1);
    for (int[] mine : mines) grid[mine[0]][mine[1]] = 0;
    
    int[][][] dp = new int[n][n][4];
    for (int i=0; i<n; ++i)
        for (int j=0; j<n; ++j)
            if (grid[i][j] > 0) {
                dp[i][j][0] = i > 0 ? dp[i - 1][j][0] + 1 : 1;
                dp[i][j][1] = j > 0 ? dp[i][j - 1][1] + 1 : 1;
            }
                
    int ans = 0;
    for (int i=n-1; i>=0; --i)
        for (int j=n-1; j>=0; --j)
            if (grid[i][j] > 0) {
                dp[i][j][2] = i < n - 1 ? dp[i + 1][j][2] + 1 : 1;
                dp[i][j][3] = j < n - 1 ? dp[i][j + 1][3] + 1 : 1;
                int cur = Collections.min(Arrays.asList(dp[i][j]));
                ans = Math.max(ans, cur);
            }
                
    return ans;
}


-----
public int orderOfLargestPlusSign(int n, int[][] mines) 
    // Your code here
}


************************************
Question ID: 770

import java.util.HashMap;
import java.util.Map;

public int minSwapsCouples(int[] row) {
    int n = row.length / 2;
    int swaps = 0;
    Map<Integer, Integer> position = new HashMap<>();

    for (int i = 0; i < row.length; i++) {
        position.put(row[i], i);
    }

    for (int i = 0; i < row.length; i += 2) {
        int couple = (row[i] % 2 == 0) ? row[i] + 1 : row[i] - 1;
        if (row[i + 1] != couple) {
            int temp = row[i + 1];
            row[i + 1] = row[position.get(couple)];
            row[position.get(couple)] = temp;
            position.put(temp, position.get(couple));
            position.put(couple, i + 1);
            swaps++;
        }
    }
    return swaps;
}

-----
import java.util.HashMap;
import java.util.Map;

public int minSwapsCouples(int[] row) 
    // Your code here
}

************************************
Question ID: 771

public int numJewelsInStones(String jewels, String stones) {
    int count = 0;
    for (char stone : stones.toCharArray()) {
        if (jewels.indexOf(stone) != -1) {
            count++;
        }
    }
    return count;
}

-----
public int numJewelsInStones(String jewels, String stones) 
    // Your code here
}

************************************
Question ID: 777

public boolean isToeplitzMatrix(int[][] matrix) {
    int rows = matrix.length;
    int cols = matrix[0].length;
    for(int i = 0; i < rows - 1; i++) {
        for(int j = 0; j < cols - 1; j++) {
            if(matrix[i][j] != matrix[i+1][j+1]) return false;
        }
    }
    return true;
}


-----
public boolean isToeplitzMatrix(int[][] matrix) 
    // Your code here
}


************************************
Question ID: 778

import java.util.PriorityQueue;
import java.util.HashMap;

public String rearrangeString(String s) {
    HashMap<Character, Integer> counts = new HashMap<>();
    for (char c : s.toCharArray()) {
        counts.put(c, counts.getOrDefault(c, 0) + 1);
    }
    
    PriorityQueue<Character> pq = new PriorityQueue<>((a, b) -> counts.get(b) - counts.get(a));
    pq.addAll(counts.keySet());
    
    StringBuilder result = new StringBuilder();
    Character previous = null;
    
    while (!pq.isEmpty()) {
        char current = pq.remove();
        result.append(current);
        
        if (previous != null && counts.get(previous) > 0) {
            pq.add(previous);
        }
        
        counts.put(current, counts.get(current) - 1);
        previous = current;
    }
    
    return result.length() == s.length() ? result.toString() : "";
}


-----
import java.util.PriorityQueue;
import java.util.HashMap;

public String rearrangeString(String s) 
    // Your code here
}


************************************
Question ID: 779

public int maxChunksToSorted(int[] arr) {
    int max_val = 0, chunks = 0;
    for (int i = 0; i < arr.length; i++) {
        max_val = Math.max(max_val, arr[i]);
        if (max_val == i) {
            chunks++;
        }
    }
    return chunks;
}

-----
public int maxChunksToSorted(int[] arr) 
    // Your code here
}

************************************
Question ID: 780

public int maxChunksToSorted(int[] arr) {
    int max_so_far = 0, count = 0;
    for (int i = 0; i < arr.length; i++) {
        max_so_far = Math.max(max_so_far, arr[i]);
        if (max_so_far == i) {
            count++;
        }
    }
    return count;
}


-----
public int maxChunksToSorted(int[] arr) 
    // Your code here
}


************************************
Question ID: 781

import java.util.HashMap;

public int numRabbits(int[] answers) {
    HashMap<Integer, Integer> count = new HashMap<>();
    int rabbits = 0;
    for(int ans : answers) {
        count.put(ans, count.getOrDefault(ans, 0) + 1);
    }
    for(int key : count.keySet()) {
        int cnt = count.get(key);
        rabbits += (key + cnt) / (key + 1) * (key + 1);
    }
    return rabbits;
}


-----
import java.util.HashMap;

public int numRabbits(int[] answers) 
    // Your code here
}


************************************
Question ID: 782

public int numJewelsInStones(String jewels, String stones) {
    int count = 0;
    for (char s : stones.toCharArray()) {
        if (jewels.indexOf(s) != -1) {
            count++;
        }
    }
    return count;
}

-----
public int numJewelsInStones(String jewels, String stones) 
    // Your code here
}

************************************
Question ID: 785

import java.util.Arrays;

class Solution {
    public boolean isBipartite(int[][] graph) {
        int n = graph.length;
        int[] colors = new int[n];
        Arrays.fill(colors, 0);

        for (int i = 0; i < n; ++i) {
            if (colors[i] == 0 && !dfs(i, 1, colors, graph)) {
                return false;
            }
        }

        return true;
    }

    private boolean dfs(int node, int color, int[] colors, int[][] graph) {
        if (colors[node] != 0) {
            return colors[node] == color;
        }

        colors[node] = color;
        for (int neighbor : graph[node]) {
            if (!dfs(neighbor, 3 - color, colors, graph)) {
                return false;
            }
        }

        return true;
    }
}

-----
import java.util.Arrays;

class Solution 
    // Your code here
}

************************************
Question ID: 786

import java.util.PriorityQueue;

public int[] kthSmallestPrimeFraction(int[] arr, int k) {
    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> arr[a[0]] * arr[b[1]] - arr[a[1]] * arr[b[0]]);
    for (int i = 0; i < arr.length - 1; i++) {
        pq.offer(new int[]{i, arr.length - 1});
    }
    while (--k > 0) {
        int[] tmp = pq.poll();
        if (--tmp[1] > tmp[0]) {
            pq.offer(tmp);
        }
    }
    return new int[]{arr[pq.peek()[0]], arr[pq.peek()[1]]};
}

-----
import java.util.PriorityQueue;

public int[] kthSmallestPrimeFraction(int[] arr, int k) 
    // Your code here
}

************************************
Question ID: 787

import java.util.*;

class Solution {
    public int slidingPuzzle(int[][] board) {
        int m = 2, n = 3;
        String target = "123450";
        String start = "";
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                start += board[i][j];
            }
        }
        int[][] dirs = {{1, 3}, {0, 2, 4}, {1, 5}, {0, 4}, {1, 3, 5}, {2, 4}};
        Queue<String> q = new LinkedList<>(Arrays.asList(A));
        int res = 0;
        Set<String> visited = new HashSet<>(q);
        while (!q.isEmpty()) {
            for (int k = q.size(); k > 0; --k) {
                String cur = q.poll();
                if (cur.equals(target)) return res;
                int zero_idx = cur.indexOf('0');
                for (int dir : dirs[zero_idx]) {
                    String neighbor = cur;
                    neighbor = neighbor.substring(0, zero_idx) + neighbor.charAt(dir) + neighbor.substring(zero_idx + 1);
                    neighbor = neighbor.substring(0, dir) + '0' + neighbor.substring(dir+1);
                    if (!visited.contains(neighbor)) {
                        visited.add(neighbor);
                        q.add(neighbor);
                    }
                }
            }
            ++res;
        }
        return -1;
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 788

public int rotatedDigits(int n) {
    int count = 0;
    for (int i = 1; i <= n; i++) {
        if (isGood(i))
            count++;
    }
    return count;
}

private boolean isGood(int num) {
    boolean changed = false;
    while (num != 0) {
        int digit = num % 10;
        if (digit == 3 || digit == 4 || digit == 7) return false;
        if (digit == 2 || digit == 5 || digit == 6 || digit == 9) changed = true;
        num /= 10;
    }
    return changed;
}

-----
public int rotatedDigits(int n) 
    // Your code here
}

************************************
Question ID: 789

import java.util.PriorityQueue;

public class KthLargest {
    private PriorityQueue<Integer> minHeap;
    private int k;

    public KthLargest(int k, int[] nums) {
        this.k = k;
        minHeap = new PriorityQueue<>();
        for (int num : nums) {
            add(num);
        }
    }

    public int add(int val) {
        minHeap.offer(val);
        if (minHeap.size() > k) {
            minHeap.poll();
        }
        return minHeap.peek();
    }
}

-----
import java.util.PriorityQueue;

public class KthLargest 
    // Your code here
}

************************************
Question ID: 790

public boolean isIdealPermutation(int[] nums) {
    for (int i = 0; i < nums.length; ++i) {
        if (Math.abs(nums[i] - i) > 1) {
            return false;
        }
    }
    return true;
}


-----
public boolean isIdealPermutation(int[] nums) 
    // Your code here
}


************************************
Question ID: 791

import java.util.HashMap;

public String customSortString(String order, String s) {
    HashMap<Character, Integer> priority = new HashMap<>();
    for (int i = 0; i < order.length(); i++) {
        priority.put(order.charAt(i), i);
    }

    Character[] sChars = s.chars().mapToObj(c -> (char) c).toArray(Character[]::new);
    Arrays.sort(sChars, (a, b) -> priority.getOrDefault(a, 0) - priority.getOrDefault(b, 0));
    return Arrays.stream(sChars).map(String::valueOf).collect(Collectors.joining());
}

-----
import java.util.HashMap;

public String customSortString(String order, String s) 
    // Your code here
}

************************************
Question ID: 792

public int search(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;
}


-----
public int search(int[] nums, int target) 
    // Your code here
}


************************************
Question ID: 793

public boolean canTransform(String start, String end) {
    if (start.length() != end.length()) return false;

    int i = 0, j = 0;
    int n = start.length();
    while (i < n && j < n) {
        while (i < n && start.charAt(i) == 'X') i++;
        while (j < n && end.charAt(j) == 'X') j++;

        if (start.charAt(i) != end.charAt(j)) return false;

        if ((start.charAt(i) == 'R' && i > j) || (start.charAt(i) == 'L' && i < j)) return false;

        i++; j++;
    }
    return true;
}

-----
public boolean canTransform(String start, String end) 
    // Your code here
}

************************************
Question ID: 794

import java.util.Comparator;
import java.util.PriorityQueue;

public int swim(int n, int[][] grid) {
    PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));
    boolean[][] visited = new boolean[n][n];
    
    pq.offer(new int[]{grid[0][0], 0, 0});

    int[] dr = {-1, 0, 1, 0};
    int[] dc = {0, 1, 0, -1};

    while (!pq.isEmpty()) {
        int[] cur = pq.poll();
        int curT = cur[0], curR = cur[1], curC = cur[2];

        if (curR == n - 1 && curC == n - 1) return curT;

        for (int d = 0; d < 4; d++) {
            int newRow = curR + dr[d];
            int newCol = curC + dc[d];
            if (0 <= newRow && newRow < n && 0 <= newCol && newCol < n && !visited[newRow][newCol]) {
                visited[newRow][newCol] = true;
                pq.offer(new int[]{Math.max(curT, grid[newRow][newCol]), newRow, newCol});
            }
        }
    }
    return -1;
}

-----
import java.util.Comparator;
import java.util.PriorityQueue;

public int swim(int n, int[][] grid) 
    // Your code here
}

************************************
Question ID: 795

public int kthSymbolInGrammar(int n, int k) {
    if (n == 1) return 0;
    if (k % 2 == 0) return 1 - kthSymbolInGrammar(n - 1, k / 2);
    else return kthSymbolInGrammar(n - 1, (k + 1) / 2);
}

-----
public int kthSymbolInGrammar(int n, int k) 
    // Your code here
}

************************************
Question ID: 796

boolean canTransform(int sx, int sy, int tx, int ty) {
    while (sx != tx || sy != ty) {
        if (sx > tx || sy > ty) return false;
        if (sx < tx) {
            tx -= ty;
        } else {
            ty -= sx;
        }
    }
    return true;
}

-----
boolean canTransform(int sx, int sy, int tx, int ty) 
    // Your code here
}

************************************
Question ID: 797

import java.util.HashMap;
public int numRabbits(int[] answers) {
    HashMap<Integer, Integer> count = new HashMap<>();
    int res = 0;
    for (int a : answers) {
        count.put(a, count.getOrDefault(a, 0) + 1);
        if (count.get(a) == 1) {
            res += (a + 1);
        } else if (count.get(a) > a + 1) {
            count.put(a, 1);
            res += (a + 1);
        }
    }
    return res;
}


-----
import java.util.HashMap;
public int numRabbits(int[] answers) 
    // Your code here
}


************************************
Question ID: 798

public int movesToChessboard(int[][] board) {
    int N = board.length;
    int row = 0, col = 0, rowCount = 0, colCount = 0;

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (((board[0][0] ^ board[i][0] ^ board[0][j]) ^ board[i][j]) != 0) return -1;
        }
    }

    for (int i = 0; i < N; i++) {
        row ^= board[0][i];
        col ^= board[i][0];
        rowCount += board[0][i] == 1 ? 1 : 0;
        colCount += board[i][0] == 1 ? 1 : 0;
    }

    if (row != 0 && rowCount * 2 != N) return -1;
    if (col != 0 && colCount * 2 != N) return -1;

    if (N % 2 == 1) {
        if (rowCount % 2 == 1) rowCount = N - rowCount;
        if (colCount % 2 == 1) colCount = N - colCount;
    } else {
        rowCount = Math.min(rowCount, N - rowCount);
        colCount = Math.min(colCount, N - colCount);
    }

    return (rowCount + colCount) / 2;
}

-----
public int movesToChessboard(int[][] board) 
    // Your code here
}

************************************
Question ID: 800

import java.util.*;

public List<String> letterCasePermutation(String s) {
    List<String> result = new ArrayList<>();
    backtrack(s.toCharArray(), 0, result);
    return result;
}

private void backtrack(char[] s, int index, List<String> result) {
    if (index == s.length) {
        result.add(new String(s));
        return;
    }
    backtrack(s, index + 1, result);
    if (Character.isLetter(s[index])) {
        s[index] ^= (1 << 5);
        backtrack(s, index + 1, result);
        s[index] ^= (1 << 5);
    }
}

-----
import java.util.*;

public List<String> letterCasePermutation(String s) 
    // Your code here
}

************************************
Question ID: 801

import java.util.Queue;
import java.util.LinkedList;

public boolean isBipartite(int[][] graph) {
    int[] colors = new int[graph.length];
    for(int i = 0; i < graph.length; i++){
        if(colors[i] != 0) continue;
        colors[i] = 1;
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(i);
        while(!queue.isEmpty()){
            int node = queue.poll();
            for(int neighbor : graph[node]){
                if(colors[neighbor] == 0){
                    colors[neighbor] = -colors[node];
                    queue.offer(neighbor);
                } else if(colors[neighbor] == colors[node]){
                    return false;
                }
            }
        }
    }
    return true;
}


-----
import java.util.Queue;
import java.util.LinkedList;

public boolean isBipartite(int[][] graph) 
    // Your code here
}


************************************
Question ID: 802

import java.util.PriorityQueue;

public int[] kthSmallestPrimeFraction(int[] arr, int k) {
    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> arr[a[0]] * arr[b[1]] - arr[a[1]] * arr[b[0]]);

    for (int i = 0; i < arr.length - 1; i++) {
        pq.offer(new int[]{i, arr.length - 1});
    }

    for (int i = 1; i < k; i++) {
        int[] curr = pq.poll();
        curr[1]--;
        if (curr[0] < curr[1]) {
            pq.offer(curr);
        }
    }

    return new int[]{arr[pq.peek()[0]], arr[pq.peek()[1]]};
}

-----
import java.util.PriorityQueue;

public int[] kthSmallestPrimeFraction(int[] arr, int k) 
    // Your code here
}

************************************
Question ID: 803

import java.util.*;

public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
    List<List<int[]>> graph = new ArrayList<>();
    for (int i = 0; i < n; i++)
        graph.add(new ArrayList<>());
    for (int[] flight : flights)
        graph.get(flight[0]).add(new int[]{ flight[1], flight[2] });

    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
    pq.offer(new int[]{0, src, k + 1});
    
    while (!pq.isEmpty()) {
        int[] info = pq.poll();
        int price = info[0], city = info[1], stops = info[2];
        
        if (city == dst)
            return price;
        
        if (stops > 0) {
            for (int[] neighbor : graph.get(city))
                pq.offer(new int[]{ price + neighbor[1], neighbor[0], stops - 1 });
        }
    }

    return -1;
}


-----
import java.util.*;

public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) 
    // Your code here
}


************************************
Question ID: 804

int rotatedDigits(int n) {
    int count = 0;
    for (int i = 1; i <= n; ++i) {
        boolean isValidAfterRotation = true;
        boolean isDifferentAfterRotation = false;
        int num = i;
        while (num != 0) {
            int digit = num % 10;
            if (digit == 3 || digit == 4 || digit == 7) {
                isValidAfterRotation = false;
                break;
            }
            if (digit == 2 || digit == 5 || digit == 6 || digit == 9) {
                isDifferentAfterRotation = true;
            }
            num /= 10;
        }
        if (isValidAfterRotation && isDifferentAfterRotation) {
            count++;
        }
    }
    return count;
}

-----
int rotatedDigits(int n) 
    // Your code here
}

************************************
Question ID: 805

import java.util.Arrays;

public class Solution {
    public boolean escapeGhosts(int[][] ghosts, int[] target) {
        int maxDist = Math.abs(target[0]) + Math.abs(target[1]);
        for (int[] ghost : ghosts) {
            int ghostDist = Math.abs(ghost[0] - target[0]) + Math.abs(ghost[1] - target[1]);
            if (ghostDist <= maxDist) {
                return false;
            }
        }
        return true;
    }
}


-----
import java.util.Arrays;

public class Solution 
    // Your code here
}


************************************
Question ID: 806

public int numberOfWays(int n) {
    int MOD = 1000000007;
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = 1;

    for (int i = 2; i <= n; i++)
        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD;

    return dp[n];
}


-----
public int numberOfWays(int n) 
    // Your code here
}


************************************
Question ID: 807

import java.util.Arrays;

public class Solution {
    public String customSortString(String order, String s) {
        Character[] sArray = s.chars().mapToObj(c -> (char)c).toArray(Character[]::new);
        Arrays.sort(sArray, (a, b) -> order.indexOf(a) - order.indexOf(b));
        return Arrays.stream(sArray).map(String::valueOf).collect(Collectors.joining());
    }
}


-----
import java.util.Arrays;

public class Solution 
    // Your code here
}


************************************
Question ID: 808

import java.util.ArrayList;
import java.util.Arrays;

public int numMatchingSubseq(String s, String[] words) {
    ArrayList<Integer>[] positions = new ArrayList[26];

    for (int i = 0; i < s.length(); ++i) {
        int index = s.charAt(i) - 'a';
        if (positions[index] == null) {
            positions[index] = new ArrayList<>();
        }
        positions[index].add(i);
    }

    int count = 0;

    for (String word : words) {
        int index = -1;
        boolean isSubsequence = true;

        for (char c : word.toCharArray()) {
            var list = positions[c - 'a'];
            if (list == null || list.size() == 0) {
                isSubsequence = false;
                break;
            }
            int pos = -1;
            for (int num : list) {
                if (num > index) {
                    pos = num;
                    break;
                }
            }
            if (pos == -1) {
                isSubsequence = false;
                break;
            } else {
                list.remove((Integer) pos);
                index = pos;
            }
        }

        if (isSubsequence) {
            ++count;
        }
    }

    return count;
}

-----
import java.util.ArrayList;
import java.util.Arrays;

public int numMatchingSubseq(String s, String[] words) 
    // Your code here
}

************************************
Question ID: 809

int num_zeros(int k) {
    int x = 0;
    for (int i = 5; k / i >= 1; i *= 5) {
        x += k / i;
    }
    return x;
}

-----
int num_zeros(int k) 
    // Your code here
}

************************************
Question ID: 810

public boolean validTicTacToe(String[] board) {
    int xCount = 0, oCount = 0;
    for (String row : board) {
        for (char c : row.toCharArray()) {
            if (c == 'X') xCount++;
            else if (c == 'O') oCount++;
        }
    }
    if (xCount != oCount && xCount != oCount + 1) return false;

    boolean xWin = false, oWin = false;
    for (int i = 0; i < 3; ++i) {
        if (board[i].charAt(0) == board[i].charAt(1) && board[i].charAt(1) == board[i].charAt(2))
            xWin = board[i].charAt(0) == 'X' ? true : (board[i].charAt(0) == 'O' ? oWin = true : oWin);
        if (board[0].charAt(i) == board[1].charAt(i) && board[1].charAt(i) == board[2].charAt(i))
            xWin = board[0].charAt(i) == 'X' ? true : (board[0].charAt(i) == 'O' ? oWin = true : oWin);
    }
    if (board[0].charAt(0) == board[1].charAt(1) && board[1].charAt(1) == board[2].charAt(2))
        xWin = board[0].charAt(0) == 'X' ? true : (board[0].charAt(0) == 'O' ? oWin = true : oWin);
    if (board[0].charAt(2) == board[1].charAt(1) && board[1].charAt(1) == board[2].charAt(0))
        xWin = board[0].charAt(2) == 'X' ? true : (board[0].charAt(2) == 'O' ? oWin = true : oWin);

    if (xWin && oWin) return false;
    if (xWin && xCount == oCount) return false;
    if (oWin && xCount > oCount) return false;

    return true;
}

-----
public boolean validTicTacToe(String[] board) 
    // Your code here
}

************************************
Question ID: 811

int numSubarrayBoundedMax(int[] nums, int left, int right) {
    int result = 0, prev = 0, start = -1;
    for (int i = 0; i < nums.length; ++i) {
        if (nums[i] >= left && nums[i] <= right) {
            prev = i - start;
            result += prev;
        } else if (nums[i] < left) {
            result += prev;
        } else {
            start = i;
            prev = 0;
        }
    }
    return result;
}


-----
int numSubarrayBoundedMax(int[] nums, int left, int right) 
    // Your code here
}


************************************
Question ID: 812

public boolean isShifted(String s, String goal) {
    if(s.length() != goal.length()) return false;
    
    s = s + s;
    return s.contains(goal);
}

-----
public boolean isShifted(String s, String goal) 
    // Your code here
}

************************************
Question ID: 813

import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
    List<List<Integer>> result = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    DFS(graph, result, path, 0);
    return result;
}

private void DFS(int[][] graph, List<List<Integer>> result, List<Integer> path, int currentNode) {
    path.add(currentNode);
    if (currentNode == graph.length - 1) {
        result.add(new ArrayList<>(path));
    } else {
        for (int neighbor : graph[currentNode]) {
            DFS(graph, result, path, neighbor);
        }
    }
    path.remove(path.size() - 1);
}

-----
import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> allPathsSourceTarget(int[][] graph) 
    // Your code here
}

************************************
Question ID: 814

public int best_rotation(int[] nums) {
    int n = nums.length;
    int[] change = new int[n];

    for (int i = 0; i < n; i++) {
        change[(i - nums[i] + 1 + n) % n] -= 1;
        change[(i + 1) % n] += 1;
    }

    int max_score = 0;
    for (int i = 1, cur_score = change[0]; i < n; i++) {
        cur_score += change[i];
        if (cur_score > max_score) {
            max_score = cur_score;
        }
    }
    return max_score;
}


-----
public int best_rotation(int[] nums) 
    // Your code here
}


************************************
Question ID: 815

import java.util.*;

public int numBusesToDestination(int[][] routes, int source, int target) {
    if (source == target) return 0;

    Map<Integer, Set<Integer>> stopRouteMap = new HashMap<>();
    for (int i = 0; i < routes.length; i++) {
        for (int stop : routes[i]) {
            stopRouteMap.computeIfAbsent(stop, x -> new HashSet<>()).add(i);
        }
    }

    Queue<Integer> queue = new LinkedList<>();
    Set<Integer> visitedSources = new HashSet<>();

    queue.offer(source);
    visitedSources.add(source);
    int transfers = 0;

    while (!queue.isEmpty()) {
        int size = queue.size();
        while (size-- > 0) {
            int curr = queue.poll(); // Pop from the queue.
            if (curr == target) return transfers;

            for (int route : stopRouteMap.get(curr)) {
                for (int stop : routes[route]) {
                    if (!visitedSources.contains(stop)) {
                        queue.offer(stop);
                        visitedSources.add(stop);
                    }
                }
                // Remove the route from the stop.
                stopRouteMap.get(curr).remove(route);
            }
        }
        transfers++;
    }
    return -1;
}

-----
import java.util.*;

public int numBusesToDestination(int[][] routes, int source, int target) 
    // Your code here
}

************************************
Question ID: 818

public int racecar(int target) {
    return dp(0, 1, target, new HashMap<>());
}

private int dp(int position, int speed, int target, Map<String, Integer> memo) {
    if (Math.abs(position) > 2 * target) {
        return target + 1;
    }
    if (position == target) {
        return speed == 1 ? 0 : 1;
    }
    String key = position + "," + speed;
    if (memo.containsKey(key)) {
        return memo.get(key);
    }
    int result = (speed > 0 ? dp(position + speed / 2, -speed / 2, target, memo) : dp(position - speed / 2, -speed / 2, target, memo)) + 1;
    result = Math.min(result, dp(position + speed, speed * 2, target, memo) + 1);
    memo.put(key, result);
    return result;
}

-----
public int racecar(int target) 
    // Your code here
}

************************************
Question ID: 819

public int minSwaps(int[] nums1, int[] nums2) {
    int n = nums1.length;
    int[] noSwap = new int[n];
    int[] doSwap = new int[n];
    Arrays.fill(noSwap, Integer.MAX_VALUE);
    Arrays.fill(doSwap, Integer.MAX_VALUE);
    noSwap[0] = 0;
    doSwap[0] = 1;

    for (int i = 1; i < n; i++) {
        if (nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) {
            noSwap[i] = noSwap[i - 1];
            doSwap[i] = doSwap[i - 1] + 1;
        }
        if (nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1]) {
            noSwap[i] = Math.min(noSwap[i], doSwap[i - 1]);
            doSwap[i] = Math.min(doSwap[i], noSwap[i - 1] + 1);
        }
    }

    return Math.min(noSwap[n - 1], doSwap[n - 1]);
}

-----
public int minSwaps(int[] nums1, int[] nums2) 
    // Your code here
}

************************************
Question ID: 820

import java.util.ArrayList;
import java.util.List;

public List<Integer> eventualSafeNodes(int[][] graph) {
    int n = graph.length;
    int[] color = new int[n];
    List<Integer> ans = new ArrayList<>();

    boolean hasCycle(int node, int[] color, int[][] graph) {
        if (color[node] > 0)
            return color[node] == 1;
        color[node] = 1;
        for (int neighbor : graph[node]) {
            if (hasCycle(neighbor, color, graph))
                return true;
        }
        color[node] = 2;
        return false;
    }

    for (int i = 0; i < n; ++i) {
        if (!hasCycle(i, color, graph))
            ans.add(i);
    }
    return ans;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<Integer> eventualSafeNodes(int[][] graph) 
    // Your code here
}

************************************
Question ID: 821

import java.util.ArrayList;
import java.util.List;

public int[] hitBricks(int[][] grid, int[][] hits) {
    for (int[] hit : hits) {
        grid[hit[0]][hit[1]]--;
    }

    int m = grid.length, n = grid[0].length;
    int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

    int dfs(int x, int y) {
        if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] <= 0) {
            return 0;
        }
        grid[x][y] = -1;
        int sum = 1;
        for (int[] d : directions) {
            sum += dfs(x + d[0], y + d[1]);
        }
        return sum;
    }

    for (int i = 0; i < n; ++i) {
        if (grid[0][i] == 1) {
            dfs(0, i);
        }
    }

    List<Integer> result = new ArrayList<>();
    for (int[] hit : hits) {
        grid[hit[0]][hit[1]]++;
        if (grid[hit[0]][hit[1]] != 1) {
            result.add(0);
            continue;
        }
        for (int[] d : directions) {
            if (dfs(hit[0] + d[0], hit[1] + d[1]) != 0) {
                result.add(dfs(hit[0], hit[1]) - 1);
                break;
            }
        }
    }

    return result.stream().mapToInt(i -> i).toArray();
}

-----
import java.util.ArrayList;
import java.util.List;

public int[] hitBricks(int[][] grid, int[][] hits) 
    // Your code here
}

************************************
Question ID: 822

import java.util.HashSet;
import java.util.Set;

public int uniqueMorseRepresentations(String[] words) {
    String[] morse = {".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};
    Set<String> transformations = new HashSet<>();

    for (String word : words) {
        StringBuilder morseCode = new StringBuilder();
        for (char c : word.toCharArray()) {
            morseCode.append(morse[c - 'a']);
        }
        transformations.add(morseCode.toString());
    }

    return transformations.size();
}

-----
import java.util.HashSet;
import java.util.Set;

public int uniqueMorseRepresentations(String[] words) 
    // Your code here
}

************************************
Question ID: 823

public boolean isPossibleToSplit(int[] nums) {
    int n = nums.length;
    int total_sum = 0;
    for (int num : nums) {
        total_sum += num;
    }

    if (total_sum % n != 0) return false;

    int target_sum = total_sum * (n / 2) / n;
    boolean[][] dp = new boolean[n / 2 + 1][target_sum + 1];
    dp[0][0] = true;

    for (int num : nums) {
        for (int count = n / 2; count >= 1; --count) {
            for (int sum = target_sum; sum >= num; --sum) {
                dp[count][sum] = dp[count][sum] || dp[count - 1][sum - num];
            }
        }
        if (dp[n / 2][target_sum]) return true;
    }

    return false;
}


-----
public boolean isPossibleToSplit(int[] nums) 
    // Your code here
}


************************************
Question ID: 824

public int[] numberOfLines(int[] widths, String s) {
    int lines = 1;
    int currentPixel = 0;
    for (char c : s.toCharArray()) {
        int letterPixels = widths[c - 'a'];
        if (currentPixel + letterPixels > 100) {
            lines++;
            currentPixel = 0;
        }
        currentPixel += letterPixels;
    }
    return new int[]{lines, currentPixel};
}


-----
public int[] numberOfLines(int[] widths, String s) 
    // Your code here
}


************************************
Question ID: 825

public int maxIncreaseKeepingSkyline(int[][] grid) {
    int n = grid.length;
    int[] row_max = new int[n];
    int[] col_max = new int[n];
    
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            row_max[i] = Math.max(row_max[i], grid[i][j]);
            col_max[j] = Math.max(col_max[j], grid[i][j]);
        }
    }
    
    int total_sum = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            total_sum += Math.min(row_max[i], col_max[j]) - grid[i][j];
        }
    }
    
    return total_sum;
}

-----
public int maxIncreaseKeepingSkyline(int[][] grid) 
    // Your code here
}

************************************
Question ID: 826

import java.util.Arrays;

public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {
    int n = difficulty.length;
    int[][] jobs = new int[n][2];

    for (int i = 0; i < n; ++i) {
        jobs[i] = new int[]{difficulty[i], profit[i]};
    }

    Arrays.sort(jobs, (a, b) -> a[0] - b[0]);
    Arrays.sort(worker);

    int max_profit = 0;
    int total_profit = 0;
    int job_idx = 0;

    for (int w : worker) {
        while (job_idx < n && w >= jobs[job_idx][0]) {
            max_profit = Math.max(max_profit, jobs[job_idx][1]);
            job_idx++;
        }
        total_profit += max_profit;
    }

    return total_profit;
}

-----
import java.util.Arrays;

public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) 
    // Your code here
}

************************************
Question ID: 827

public int maxAreaOfIsland(int[][] grid) {
    int ans = 0;
    for (int i = 0; i < grid.length; ++i)
        for (int j = 0; j < grid[i].length; ++j)
            if (grid[i][j] == 0) {
                grid[i][j] = 1;
                ans = Math.max(ans, dfs(grid, i, j));
                grid[i][j] = 0;
            }
    return ans;
}

private int dfs(int[][] grid, int x, int y) {
    if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] == 0) {
        return 0;
    }
    grid[x][y] = 0;
    return dfs(grid, x - 1, y) + dfs(grid, x + 1, y) + dfs(grid, x, y - 1) + dfs(grid, x, y + 1) + 1;
}

-----
public int maxAreaOfIsland(int[][] grid) 
    // Your code here
}

************************************
Question ID: 828

public boolean xorGame(int[] nums) {
    int xorSum = 0;
    for (int num : nums) {
        xorSum ^= num;
    }
    return xorSum == 0 || nums.length % 2 == 0;
}

-----
public boolean xorGame(int[] nums) 
    // Your code here
}

************************************
Question ID: 829

import java.util.*;

public List<String> subdomainVisits(String[] cpdomains) {
    Map<String, Integer> counts = new HashMap<>();
    List<String> result = new ArrayList<>();

    for (String cpdomain : cpdomains) {
        String[] info = cpdomain.split(" ");
        int count = Integer.valueOf(info[0]);
        String domain = info[1];

        for (int i = 0; i < domain.length(); ++i) {
            if (domain.charAt(i) == '.') {
                counts.put(domain.substring(i + 1), counts.getOrDefault(domain.substring(i + 1), 0) + count);
            }
        }
        counts.put(domain, counts.getOrDefault(domain, 0) + count);
    }

    for (String sub : counts.keySet()) {
        result.add("" + counts.get(sub) + " " + sub);
    }

    return result;
}


-----
import java.util.*;

public List<String> subdomainVisits(String[] cpdomains) 
    // Your code here
}


************************************
Question ID: 830

class Solution {
    public double largestTriangleArea(int[][] points) {
        double max_area = 0.0;
        for (int i = 0; i < points.length; ++i) {
            for (int j = i + 1; j < points.length; ++j) {
                for (int k = j + 1; k < points.length; ++k) {
                    max_area = Math.max(max_area, 0.5 * Math.abs(points[i][0] * (points[j][1] - points[k][1])
                                                              + points[j][0] * (points[k][1] - points[i][1])
                                                              + points[k][0] * (points[i][1] - points[j][1])));
                }
            }
        }
        return max_area;
    }
}

-----
class Solution 
    // Your code here
}

************************************
Question ID: 832

public TreeNode pruneTree(TreeNode root) {
    if (root == null) return null;
    root.left = pruneTree(root.left);
    root.right = pruneTree(root.right);
    if (root.val == 0 && root.left == null && root.right == null) return null;
    return root;
}

-----
public TreeNode pruneTree(TreeNode root) 
    // Your code here
}

************************************
Question ID: 833

import java.util.*;

public int numBusesToDestination(int[][] routes, int source, int target) {
    if (source == target) return 0;

    Map<Integer, Set<Integer>> stopToBuses = new HashMap<>();
    for (int i = 0; i < routes.length; ++i) {
        for (int stop : routes[i]) {
            stopToBuses.computeIfAbsent(stop, k -> new HashSet<Integer>()).add(i);
        }
    }

    Queue<Integer> q = new LinkedList<>();
    Set<Integer> visitedBuses = new HashSet<>();
    int numBuses = 0;
    q.add(source);

    while (!q.isEmpty()) {
        int size = q.size();
        while (size-- > 0) {
            int stop = q.poll();
            for (int bus : stopToBuses.get(stop)) {
                if (visitedBuses.contains(bus)) continue;
                visitedBuses.add(bus);
                for (int nextStop : routes[bus]) {
                    if (nextStop == target) return numBuses + 1;
                    q.add(nextStop);
                }
            }
        }
        numBuses++;
    }

    return -1;
}

-----
import java.util.*;

public int numBusesToDestination(int[][] routes, int source, int target) 
    // Your code here
}

************************************
Question ID: 834

import java.util.ArrayList;
import java.util.List;

public List<String> ambiguousCoordinates(String s) {
    int n = s.length();
    List<String> res = new ArrayList<>();
    
    for (int i = 2; i < n - 1; i++) {
        List<String> first = generateNumber(s.substring(1, i));
        List<String> second = generateNumber(s.substring(i, n - 1));
        
        for (String f : first) {
            for (String sec : second) {
                res.add("(" + f + ", " + sec + ")");
            }
        }
    }
    return res;
}

private List<String> generateNumber(String s) {
    int n = s.length();
    List<String> res = new ArrayList<>();
    
    if (n == 0 || (n > 1 && s.charAt(0) == '0' && s.charAt(n - 1) == '0')) return res;
    if (n > 1 && s.charAt(0) == '0') {
        res.add("0." + s.substring(1));
        return res;
    }
    res.add(s);
    if (n == 1 || s.charAt(n - 1) == '0') return res;
    
    for (int i = 1; i < n; i++) {
        res.add(s.substring(0, i) + "." + s.substring(i));
    }
    return res;
}


-----
import java.util.ArrayList;
import java.util.List;

public List<String> ambiguousCoordinates(String s) 
    // Your code here
}


************************************
Question ID: 836

public int racecar(int target) {
    return racecar(target, new HashMap<>());
}

public int racecar(int target, Map<String, Integer> memo) {
    return dp(0, 1, target, memo);
}

public int dp(int pos, int speed, int target, Map<String, Integer> memo) {
    if (Math.abs(pos) > 2 * target)
        return Integer.MAX_VALUE - 1;

    if (pos == target)
        return 0;

    String key = pos + "," + speed;
    if (memo.containsKey(key))
        return memo.get(key);

    int op1 = dp(pos + speed, speed * 2, target, memo) + 1;
    int op2 = dp(pos, -speed, target, memo) + 2;

    int ans = Math.min(op1, op2);
    memo.put(key, ans);
    return ans;
}

-----
public int racecar(int target) 
    // Your code here
}

************************************
Question ID: 837

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public String mostCommonWord(String paragraph, String[] banned) {
    String lowerPara = paragraph.toLowerCase();
    String[] words = lowerPara.split("\\W+");
    Map<String, Integer> wordCount = new HashMap<>();
    Set<String> bannedSet = new HashSet<>();
    
    for (String ban : banned) {
        bannedSet.add(ban.toLowerCase());
    }
    
    for (String word : words) {
        if (!bannedSet.contains(word)) {
            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
        }
    }
    
    return wordCount.entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .orElseThrow()
            .getKey();
}


-----
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public String mostCommonWord(String paragraph, String[] banned) 
    // Your code here
}


************************************
Question ID: 838

public String pushDominoes(String dominoes) {
    int n = dominoes.length();
    int[] forces = new int[n];

    int force = 0;
    for (int i = 0; i < n; ++i) {
        if (dominoes.charAt(i) == 'R') force = n;
        else if (dominoes.charAt(i) == 'L') force = 0;
        else force = Math.max(force - 1, 0);
        forces[i] += force;
    }

    force = 0;
    for (int i = n - 1; i >= 0; --i) {
        if (dominoes.charAt(i) == 'L') force = n;
        else if (dominoes.charAt(i) == 'R') force = 0;
        else force = Math.max(force - 1, 0);
        forces[i] -= force;
    }

    StringBuilder result = new StringBuilder();
    for (int f : forces) {
        if (f > 0) result.append('R');
        else if (f < 0) result.append('L');
        else result.append('.');
    }

    return result.toString();
}


-----
public String pushDominoes(String dominoes) 
    // Your code here
}


************************************
Question ID: 839

import java.util.HashSet;
import java.util.Set;

public int minimalLengthEncoding(String[] words) {
    Set<String> wordSet = new HashSet<>();
    for (String word : words) {
        wordSet.add(word);
    }

    for (String word : words) {
        for (int i = 1; i < word.length(); i++) {
            wordSet.remove(word.substring(i));
        }
    }

    int len = 0;
    for (String word : wordSet) {
        len += word.length() + 1;
    }
    return len;
}

-----
import java.util.HashSet;
import java.util.Set;

public int minimalLengthEncoding(String[] words) 
    // Your code here
}

************************************
Question ID: 840

public int numMagicSquaresInside(int[][] grid) {
    int count = 0;
    for (int i = 0; i < grid.length - 2; ++i) {
        for (int j = 0; j < grid[0].length - 2; ++j) {
            if (grid[i][j] <= 9 && grid[i + 1][j + 1] == 5 && isMagic(grid, i, j)) {
                count++;
            }
        }
    }
    return count;
}

private boolean isMagic(int[][] grid, int x, int y) {
    int[] temp = new int[16];
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            int num = grid[x + i][y + j];
            temp[num]++;
            if (num > 9 || temp[num] > 1) {
                return false;
            }
        }
    }
    int sum = grid[x][y] + grid[x][y+1] + grid[x][y+2];
    for (int i = 0; i < 3; ++i) {
        int rowSum = 0, colSum = 0;
        for (int j = 0; j < 3; ++j) {
            rowSum += grid[x + i][y + j];
            colSum += grid[x + j][y + i];
        }
        if (rowSum != sum || colSum != sum)
            return false;
    }
    if (grid[x][y] + grid[x + 1][y + 1] + grid[x + 2][y + 2] != sum)
        return false;
    if (grid[x][y + 2] + grid[x + 1][y + 1] + grid[x + 2][y] != sum)
        return false;

    return true;
}


-----
public int numMagicSquaresInside(int[][] grid) 
    // Your code here
}


************************************
Question ID: 841

public int[] shortestToChar(String s, char c) {
    int n = s.length();
    int[] result = new int[n];
    
    int pos = -n;
    for (int i = 0; i < n; ++i) {
        if (s.charAt(i) == c)
            pos = i;
        result[i] = i - pos;
    }
    
    for (int i = pos - 1; i >= 0; --i) {
        if (s.charAt(i) == c)
            pos = i;
        result[i] = Math.min(result[i], pos - i);
    }
    
    return result;
}


-----
public int[] shortestToChar(String s, char c) 
    // Your code here
}


************************************
Question ID: 842

import java.util.HashSet;
import java.util.Set;

public int smallestGoodInteger(int[] fronts, int[] backs) {
    Set<Integer> notGood = new HashSet<>();
    int n = fronts.length;
    for (int i = 0; i < n; ++i)
        if (fronts[i] == backs[i]) notGood.add(fronts[i]);
    
    int result = Integer.MAX_VALUE;
    for (int i = 0; i < n; ++i) {
        if (!notGood.contains(fronts[i])) result = Math.min(result, fronts[i]);
        if (!notGood.contains(backs[i])) result = Math.min(result, backs[i]);
    }
    return result == Integer.MAX_VALUE ? 0 : result;
}

-----
import java.util.HashSet;
import java.util.Set;

public int smallestGoodInteger(int[] fronts, int[] backs) 
    // Your code here
}

************************************
Question ID: 843

public int numFactoredBinaryTrees(int[] arr) {
    int MOD = 1_000_000_007;
    int n = arr.length;
    Arrays.sort(arr);
    HashMap<Integer, Long> dp = new HashMap<>();
    for (int i = 0; i < n; ++i) {
        dp.put(arr[i], 1L);
        for (int j = 0; j < i; ++j) {
            if (arr[i] % arr[j] == 0 && dp.containsKey(arr[i] / arr[j]))
                dp.put(arr[i], (dp.get(arr[i]) + dp.get(arr[j]) * dp.get(arr[i] / arr[j])) % MOD);
        }
    }
    long ans = 0;
    for (Long value : dp.values()) ans = (ans + value) % MOD;
    return (int) ans;
}

-----
public int numFactoredBinaryTrees(int[] arr) 
    // Your code here
}

************************************
Question ID: 844

public boolean backspaceCompare(String s, String t) {
    int i = s.length() - 1, j = t.length() - 1;
    while (true) {
        int back;
        for (back = 0; i >= 0 && (back > 0 || s.charAt(i) == '#'); --i)
            back += s.charAt(i) == '#' ? 1 : -1;
        for (back = 0; j >= 0 && (back > 0 || t.charAt(j) == '#'); --j)
            back += t.charAt(j) == '#' ? 1 : -1;
        if (i >= 0 && j >= 0 && s.charAt(i) == t.charAt(j))
            i--, j--;
        else
            return i == -1 && j == -1;
    }
}

-----
public boolean backspaceCompare(String s, String t) 
    // Your code here
}

************************************
Question ID: 845

public int longestMountain(int[] arr) {
    int n = arr.length;
    int res = 0, up = 0, down = 0;

    for (int i = 1; i < n; ++i) {
        if ((down != 0 && arr[i - 1] < arr[i]) || arr[i - 1] == arr[i]) {
            up = down = 0;
        }

        if (arr[i - 1] < arr[i]) up++;
        if (arr[i - 1] > arr[i]) down++;

        if (up != 0 && down != 0) {
            res = Math.max(res, up + down + 1);
        }
    }
    return res;
}

-----
public int longestMountain(int[] arr) 
    // Your code here
}

************************************
Question ID: 846

import java.util.Map;
import java.util.TreeMap;

public boolean isPossibleDivide(int[] hand, int groupSize) {
    Map<Integer, Integer> cardCount = new TreeMap<>();
    for (int card : hand) {
        cardCount.put(card, cardCount.getOrDefault(card, 0) + 1);
    }

    for (int card : cardCount.keySet()) {
        int count = cardCount.get(card);
        if (count > 0) {
            for (int i = 1; i < groupSize; ++i) {
                int tmp = cardCount.getOrDefault(card + i, 0) - count;
                if (tmp < 0) {
                    return false;
                }
                cardCount.put(card + i, tmp);
            }
        }
    }

    return true;
}


-----
import java.util.Map;
import java.util.TreeMap;

public boolean isPossibleDivide(int[] hand, int groupSize) 
    // Your code here
}


************************************
Question ID: 847

import java.util.LinkedList;
import java.util.Queue;

public int shortestPathLength(int[][] graph) {
    int n = graph.length;
    Queue<int[]> queue = new LinkedList<>();
    boolean[][] visited = new boolean[n][1 << n];

    for (int i = 0; i < n; i++) {
        queue.offer(new int[]{i, 1 << i, 0});
        visited[i][1 << i] = true;
    }

    while (!queue.isEmpty()) {
        int[] cur = queue.poll();
        int node = cur[0], bitmask = cur[1], length = cur[2];

        if (bitmask == (1 << n) - 1) return length;

        for (int nei : graph[node]) {
            int next_bitmask = bitmask | (1 << nei);
            if (!visited[nei][next_bitmask]) {
                visited[nei][next_bitmask] = true;
                queue.offer(new int[]{nei, next_bitmask, length + 1});
            }
        }
    }

    return 0;
}

-----
import java.util.LinkedList;
import java.util.Queue;

public int shortestPathLength(int[][] graph) 
    // Your code here
}

************************************
Question ID: 848

public String shiftingLetters(String s, int[] shifts) {
    for (int i = shifts.length - 2; i >= 0; i--) {
        shifts[i] = (shifts[i] + shifts[i + 1] % 26) % 26;
    }
    
    char[] result = s.toCharArray();
    for (int i = 0; i < s.length(); i++) {
        result[i] = (char) ((result[i] - 'a' + shifts[i] % 26) % 26 + 'a');
    }
    
    return new String(result);
}

-----
public String shiftingLetters(String s, int[] shifts) 
    // Your code here
}

************************************
Question ID: 849

public int maxDistToClosest(int[] seats) {
    int n = seats.length;
    int maxDist = 0, lastPerson = -1;

    for (int i = 0; i < n; ++i) {
        if (seats[i] == 1) {
            if (lastPerson == -1)
                maxDist = i;
            else
                maxDist = Math.max(maxDist, (i - lastPerson) / 2);
            lastPerson = i;
        }
    }
    maxDist = Math.max(maxDist, n - 1 - lastPerson);
    return maxDist;
}

-----
public int maxDistToClosest(int[] seats) 
    // Your code here
}

************************************
Question ID: 850

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public int rectangleArea(int[][] rectangles) {
    final int mod = 1000000007;
    int n = rectangles.length;
    Set<Integer> X = new HashSet<>();
    Set<Integer> Y = new HashSet<>();
    for (int[] rect : rectangles) {
        X.add(rect[0]);
        X.add(rect[2]);
        Y.add(rect[1]);
        Y.add(rect[3]);
    }
    Integer[] sortedX = X.toArray(new Integer[0]);
    Integer[] sortedY = Y.toArray(new Integer[0]);
    Arrays.sort(sortedX);
    Arrays.sort(sortedY);

...
(Java code is similar to C++, with minor adjustments to use Java Collections)


-----
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public int rectangleArea(int[][] rectangles) 
    // Your code here
}
    Integer[] sortedX = X.toArray(new Integer[0]);
    Integer[] sortedY = Y.toArray(new Integer[0]);
    Arrays.sort(sortedX);
    Arrays.sort(sortedY);

...
(Java code is similar to C++, with minor adjustments to use Java Collections)


************************************
Question ID: 851

import java.util.Set;
import java.util.HashSet;
import java.util.StringJoiner;

public String toGoatLatin(String sentence) {
    String[] words = sentence.split(" ");
    String vowels = "AEIOUaeiou";
    Set<Character> vowelSet = new HashSet<>();

    for (char c : vowels.toCharArray()) {
        vowelSet.add(c);
    }

    StringJoiner result = new StringJoiner(" ");
    StringBuilder suffix = new StringBuilder("a");

    for (String word : words) {
        if (!vowelSet.contains(word.charAt(0))) {
            word = word.substring(1) + word.charAt(0);
        }
        result.add(word + "ma" + suffix);
        suffix.append("a");
    }

    return result.toString();
}

-----
import java.util.Set;
import java.util.HashSet;
import java.util.StringJoiner;

public String toGoatLatin(String sentence) 
    // Your code here
}

************************************
Question ID: 852

public int numFriendRequests(int[] ages) {
    int[] count = new int[121];
    int total_requests = 0;

    for (int age : ages) count[age]++;

    for (int a = 1; a <= 120; a++) {
        for (int b = 1; b <= 120; b++) {
            if (a * 0.5 + 7 >= b) continue;
            if (a < b) continue;
            if (a < b * 2) {
                total_requests += count[a] * count[b];
                if (a == b) total_requests -= count[a];
            }
        }
    }

    return total_requests;
}

-----
public int numFriendRequests(int[] ages) 
    // Your code here
}

************************************
Question ID: 853

import java.util.Arrays;
import java.util.Comparator;

public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {
    Integer[] jobIdx = new Integer[difficulty.length];
    for (int i = 0; i < difficulty.length; i++) {
        jobIdx[i] = i;
    }
    Arrays.sort(jobIdx, Comparator.comparingInt(i -> difficulty[i]));
    Arrays.sort(worker);

    int i = 0, maxProfit = 0, totalProfit = 0;
    for (int ability : worker) {
        while (i < difficulty.length && ability >= difficulty[jobIdx[i]]) {
            maxProfit = Math.max(maxProfit, profit[jobIdx[i]]);
            i++;
        }
        totalProfit += maxProfit;
    }
    return totalProfit;
}

-----
import java.util.Arrays;
import java.util.Comparator;

public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) 
    // Your code here
}

************************************
Question ID: 854

int kSimilarity(String s1, String s2) {
    int k = 0;
    StringBuilder sb = new StringBuilder(s1);

    for (int i = 0; i < sb.length(); i++) {
        if (sb.charAt(i) != s2.charAt(i)) {
            int j = i + 1;
            while (sb.charAt(j) != s2.charAt(i) || s2.charAt(j) == sb.charAt(j)) {
                j++;
            }
            sb.setCharAt(j, sb.charAt(i));
            sb.setCharAt(i, s2.charAt(i));
            k++;
        }
    }
    return k;
}

-----
int kSimilarity(String s1, String s2) 
    // Your code here
}

************************************
Question ID: 855

import java.util.HashSet;

public int countUniqueChars(String s) {
    HashSet<Character> uniqueChars = new HashSet<>();
    for (char c : s.toCharArray()) {
        uniqueChars.add(c);
    }
    return uniqueChars.size();
}

public int sumCountUniqueChars(String s) {
    int sum = 0;
    for (int i = 0; i < s.length(); ++i) {
        for (int j = i + 1; j <= s.length(); ++j) {
            sum += countUniqueChars(s.substring(i, j));
        }
    }
    return sum;
}

-----
import java.util.HashSet;

public int countUniqueChars(String s) 
    // Your code here
}

************************************
Question ID: 856

public int consecutiveNumbersSum(int n) {
    int count = 0;
    for (int i = 1; i * (i - 1) / 2 < n; i++) {
        if ((n - i * (i - 1) / 2) % i == 0) {
            count++;
        }
    }
    return count;
}


-----
public int consecutiveNumbersSum(int n) 
    // Your code here
}


************************************
Question ID: 857

import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> largeGroupPositions(String s) {
    List<List<Integer>> result = new ArrayList<>();
    int start = 0;
    for (int i = 1; i < s.length(); ++i) {
        if (s.charAt(i) != s.charAt(start)) {
            if (i - start >= 3) {
                List<Integer> interval = new ArrayList<>();
                interval.add(start);
                interval.add(i - 1);
                result.add(interval);
            }
            start = i;
        }
    }
    if (s.length() - start >= 3) {
        List<Integer> interval = new ArrayList<>();
        interval.add(start);
        interval.add(s.length() - 1);
        result.add(interval);
    }
    return result;
}


-----
import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> largeGroupPositions(String s) 
    // Your code here
}


************************************
Question ID: 858

public String maskInformation(String s) {
    if (s.contains("@")) {
        s = s.toLowerCase();
        return s.charAt(0) + "*****" + s.substring(s.indexOf('@') - 1);
    } else {
        String digits = s.replaceAll("\\D", "");
        if (digits.length() == 10)
            return "***-***-" + digits.substring(6);
        String prefix = "*" + new String(new char[digits.length() - 10]).replace("\0", "*") + "-";
        return '+' + prefix + "***-***-" + digits.substring(digits.length() - 4);
    }
}

-----
public String maskInformation(String s) 
    // Your code here
}

************************************
Question ID: 859

#

public class MyCircularDeque {
    private int[] buffer;
    private int front, rear, size;

    public MyCircularDeque(int k) {
        buffer = new int[k];
        front = 0;
        rear = 0;
        size = 0;
    }

    public boolean insertFront(int value) {
        if (size == buffer.length) return false;
        front = (front - 1 + buffer.length) % buffer.length;
        buffer[front] = value;
        size++;
        return true;
    }

    public boolean insertLast(int value) {
        if (size == buffer.length) return false;
        buffer[rear] = value;
        rear = (rear + 1) % buffer.length;
        size++;
        return true;
    }

    public boolean deleteFront() {
        if (size == 0) return false;
        front = (front + 1) % buffer.length;
        size--;
        return true;
    }

    public boolean deleteLast() {
        if (size == 0) return false;
        rear = (rear - 1 + buffer.length) % buffer.length;
        size--;
        return true;
    }

    public int getFront() {
        if (size == 0) return -1;
        return buffer[front];
    }

    public int getRear() {
        if (size == 0) return -1;
        return buffer[(rear - 1 + buffer.length) % buffer.length];
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == buffer.length;
    }
}

#
-----
#

public class MyCircularDeque 
    // Your code here
}

#
************************************
Question ID: 861

class Solution {
    public int[][] flipAndInvertImage(int[][] image) {
        for (int[] row : image) {
            int n = row.length;
            for (int i = 0; i < (n + 1) / 2; i++) {
                int temp = 1 - row[i];
                row[i] = 1 - row[n - 1 - i];
                row[n - 1 - i] = temp;
            }
        }
        return image;
    }
}

-----
class Solution 
    // Your code here
}

************************************
Question ID: 862

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public String findReplaceString(String s, int[] indices, String[] sources, String[] targets) {
    List<int[]> indexMapping = new ArrayList<>();

    for (int i = 0; i < indices.length; i++) {
        if (s.startsWith(sources[i], indices[i])) {
            indexMapping.add(new int[]{indices[i], i});
        }
    }

    indexMapping.sort((a, b) -> a[0] - b[0]);
    StringBuilder result = new StringBuilder();
    int lastIdx = 0;

    for (int[] p : indexMapping) {
        result.append(s, lastIdx, p[0]);
        result.append(targets[p[1]]);
        lastIdx = p[0] + sources[p[1]].length();
    }

    result.append(s.substring(lastIdx));
    return result.toString();
}

-----
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public String findReplaceString(String s, int[] indices, String[] sources, String[] targets) 
    // Your code here
}

************************************
Question ID: 863

import java.util.ArrayList;
import java.util.List;

public int[] sumOfDistancesInTree(int n, int[][] edges) {
    List<List<Integer>> tree = new ArrayList<>();

    for (int i = 0; i < n; i++) {
        tree.add(new ArrayList<>());
    }

    for (int[] edge : edges) {
        tree.get(edge[0]).add(edge[1]);
        tree.get(edge[1]).add(edge[0]);
    }

    int[] count = new int[n];
    int[] res = new int[n];

    dfs(tree, 0, -1, count, res);
    dfs2(tree, 0, -1, count, res, n);

    return res;
}

private void dfs(List<List<Integer>> tree, int node, int parent, int[] count, int[] res) {
    for (int child : tree.get(node)) {
        if (child != parent) {
            dfs(tree, child, node, count, res);
            count[node] += count[child];
            res[node] += res[child] + count[child];
        }
    }
    count[node]++;
}

private void dfs2(List<List<Integer>> tree, int node, int parent, int[] count, int[] res, int n) {
    for (int child : tree.get(node)) {
        if (child != parent) {
            res[child] = res[node] - count[child] + n - count[child];
            dfs2(tree, child, node, count, res, n);
        }
    }
}


-----
import java.util.ArrayList;
import java.util.List;

public int[] sumOfDistancesInTree(int n, int[][] edges) 
    // Your code here
}


************************************
Question ID: 864

public int largestOverlap(int[][] img1, int[][] img2) {
    int n = img1.length;
    List<int[]> onesImg1 = new ArrayList<>();
    List<int[]> onesImg2 = new ArrayList<>();
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (img1[i][j] == 1) onesImg1.add(new int[]{i, j});
            if (img2[i][j] == 1) onesImg2.add(new int[]{i, j});
        }
    }

    Map<String, Integer> overlaps = new HashMap<>();
    for (int[] pt1 : onesImg1) {
        for (int[] pt2 : onesImg2) {
            int dx = pt2[0] - pt1[0];
            int dy = pt2[1] - pt1[1];
            String key = dx + "," + dy;
            overlaps.put(key, overlaps.getOrDefault(key, 0) + 1);
        }
    }

    int maxOverlap = 0;
    for (Integer count : overlaps.values()) {
        maxOverlap = Math.max(maxOverlap, count);
    }
    return maxOverlap;
}

-----
public int largestOverlap(int[][] img1, int[][] img2) 
    // Your code here
}

************************************
Question ID: 866

public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
    return rec1[2] > rec2[0] && rec1[3] > rec2[1] && rec1[0] < rec2[2] && rec1[1] < rec2[3];
}

-----
public boolean isRectangleOverlap(int[] rec1, int[] rec2) 
    // Your code here
}

************************************
Question ID: 867

public double new21Game(int n, int k, int maxPts) {
    if (k == 0 || n >= k + maxPts) {
        return 1;
    }
    
    double[] dp = new double[n + 1];
    dp[0] = 1;
    double sum = 1, ans = 0;
    
    for (int i = 1; i <= n; i++) {
        dp[i] = sum / maxPts;
        if (i < k) {
            sum += dp[i];
        } else {
            ans += dp[i];
        }
        if (i >= maxPts) {
            sum -= dp[i - maxPts];
        }
    }
    
    return ans;
}


-----
public double new21Game(int n, int k, int maxPts) 
    // Your code here
}


************************************
Question ID: 868

public String pushDominoes(String dominoes) {
    int n = dominoes.length();
    String prev;
    String cur = dominoes;
    do {
        prev = cur;
        StringBuilder sb = new StringBuilder(prev);
        for (int i = 0; i < n; ++i) {
            if (prev.charAt(i) == 'L' && i > 0 && prev.charAt(i - 1) == '.')
                sb.setCharAt(i - 1, 'L');
            else if (prev.charAt(i) == 'R' && i < n - 1 && prev.charAt(i + 1) == '.')
                sb.setCharAt(i + 1, 'R');
        }
        cur = sb.toString();
    } while (!prev.equals(cur));
    return cur;
}

-----
public String pushDominoes(String dominoes) 
    // Your code here
}

************************************
Question ID: 869

import java.util.Arrays;

public class SimilarGroups {
    public static boolean isSimilar(String a, String b) {
        int diffCount = 0;
        for (int i = 0; i < a.length(); i++) {
            if (a.charAt(i) != b.charAt(i)) {
                diffCount++;
                if (diffCount > 2) {
                    return false;
                }
            }
        }
        return true;
    }

    public static int countGroups(String[] strs) {
        int count = 0;
        boolean[] visited = new boolean[strs.length];
        Arrays.fill(visited, false);
        for (int i = 0; i < strs.length; i++) {
            if (!visited[i]) {
                count++;
                visited[i] = true;
                for (int j = i + 1; j < strs.length; j++) {
                    if (isSimilar(strs[i], strs[j])) {
                        visited[j] = true;
                    }
                }
            }
        }
        return count;
    }
}


-----
import java.util.Arrays;

public class SimilarGroups 
    // Your code here
}


************************************
Question ID: 870

import java.util.*;

class Solution {
    public int[] advantageCount(int[] nums1, int[] nums2) {
        int n = nums1.length;
        int[] result = new int[n];
        TreeSet<Integer> set = new TreeSet<>();
        for (int num : nums1) set.add(num);
        for (int i = 0; i < n; i++) {
            Integer greater = set.higher(nums2[i]);
            if (greater == null) {
                greater = set.first();
            }
            set.remove(greater);
            result[i] = greater;
        }
        return result;
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 871

import java.util.HashSet;
import java.util.List;
import java.util.Stack;

public boolean canVisitAllRooms(List<List<Integer>> rooms) {
    HashSet<Integer> visited = new HashSet<>();
    Stack<Integer> stack = new Stack<>();
    stack.push(0);

    while (!stack.isEmpty()) {
        int currentRoom = stack.pop();

        visited.add(currentRoom);

        for (int key : rooms.get(currentRoom)) {
            if (!visited.contains(key)) {
                stack.push(key);
            }
        }
    }

    return visited.size() == rooms.size();
}

-----
import java.util.HashSet;
import java.util.List;
import java.util.Stack;

public boolean canVisitAllRooms(List<List<Integer>> rooms) 
    // Your code here
}

************************************
Question ID: 872

import java.util.ArrayList;
import java.util.List;

public List<Integer> splitIntoFibonacci(String num) {
    List<Integer> ans = new ArrayList<>();
    backtrack(num, ans, 0, 0, 0);
    return ans;
}

private boolean backtrack(String num, List<Integer> ans, int index, int prev1, int prev2) {
    if (index == num.length()) {
        return ans.size() >= 3;
    }
    long curr = 0;
    for (int i = index; i < num.length(); ++i) {
        if (i > index && num.charAt(index) == '0') {
            break;
        }
        curr = curr * 10 + num.charAt(i) - '0';
        if (curr > Integer.MAX_VALUE) {
            break;
        }

        if (ans.size() >= 2) {
            long sum = (long) prev1 + prev2;
            if (curr < sum) {
                continue;
            } else if (curr > sum) {
                break;
            }
        }

        ans.add((int) curr);
        if (backtrack(num, ans, i + 1, prev2, (int) curr)) {
            return true;
        }
        ans.remove(ans.size() - 1);
    }
    return false;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<Integer> splitIntoFibonacci(String num) 
    // Your code here
}

************************************
Question ID: 873

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

class Solution {
    private int match(String a, String b) {
        int matches = 0;
        for (int i = 0; i < 6; ++i)
            if (a.charAt(i) == b.charAt(i)) matches++;
        return matches;
    }

    public void findSecretWord(String[] wordlist, Master master) {
        List<String> words = new ArrayList<>();
        for (String word : wordlist) words.add(word);
        Random rand = new Random();

        for (int i = 0, matchCnt = 0; i < 10 && matchCnt < 6; ++i) {
            String guess = words.get(rand.nextInt(words.size()));
            matchCnt = master.guess(guess);
            List<String> candidates = new ArrayList<>();
            for (String word : words)
                if (match(word, guess) == matchCnt)
                    candidates.add(word);
            words = candidates;
        }
    }
}

-----
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

class Solution 
    // Your code here
}

************************************
Question ID: 874

import java.util.Stack;

public class Solution {
    public boolean backspaceCompare(String s, String t) {
        Stack<Character> sStack = processBackspaces(s);
        Stack<Character> tStack = processBackspaces(t);

        return sStack.equals(tStack);
    }

    private Stack<Character> processBackspaces(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if (c != '#') {
                stack.push(c);
            } else if (!stack.isEmpty()) {
                stack.pop();
            }
        }
        return stack;
    }
}

-----
import java.util.Stack;

public class Solution 
    // Your code here
}

************************************
Question ID: 875

public int longestMountain(int[] arr) {
    int n = arr.length;
    int maxLength = 0;
    int i = 1;
    while (i < n - 1) {
        if (arr[i - 1] < arr[i] && arr[i] > arr[i + 1]) {
            int left = i - 1;
            int right = i + 1;
            while (left > 0 && arr[left - 1] < arr[left]) {
                left--;
            }
            while (right < n - 1 && arr[right] > arr[right + 1]) {
                right++;
            }
            maxLength = Math.max(maxLength, right - left + 1);
            i = right;
        } else {
            i++;
        }
    }
    return maxLength;
}

-----
public int longestMountain(int[] arr) 
    // Your code here
}

************************************
Question ID: 876

import java.util.*;

public boolean isNStraightHand(int[] hand, int groupSize) {
    TreeMap<Integer, Integer> counts = new TreeMap<>();

    for (int card : hand) {
        counts.put(card, counts.getOrDefault(card, 0) + 1);
    }

    for (Integer key : counts.keySet()) {
        if (counts.get(key) > 0) {
            for (int i = groupSize - 1; i >= 0; --i) {
                if (counts.getOrDefault(key + i, 0) < counts.get(key)) {
                    return false;
                }
                counts.put(key + i, counts.get(key + i) - counts.get(key));
            }
        }
    }
    
    return true;
}


-----
import java.util.*;

public boolean isNStraightHand(int[] hand, int groupSize) 
    // Your code here
}


************************************
Question ID: 877

import java.util.*;

class Solution {
    public int shortestPathLength(int[][] graph) {
        int n = graph.length;
        Queue<int[]> q = new LinkedList<>();
        
        for(int i = 0; i < n; i++) {
            q.add(new int[]{i, 1 << i});
        }
        int steps = -1;
        boolean[][] visited = new boolean[n][1 << n];
        
        while(!q.isEmpty()) {
            steps++;
            int size = q.size();
            
            for(int k = 0; k < size; k++) {
                int[] curr = q.poll();
                int currNode = curr[0];
                int currVisits = curr[1];

                if(Integer.bitCount(currVisits) == n) return steps;
                
                for(int nextNode: graph[currNode]) {
                    int nextVisits = currVisits | (1 << nextNode);
                    
                    if(!visited[nextNode][nextVisits]) {
                        visited[nextNode][nextVisits] = true;
                        q.add(new int[]{nextNode, nextVisits});
                    }
                }
            }
        }
        
        return -1;
    }
}


-----
import java.util.*;

class Solution 
    // Your code here
}


************************************
Question ID: 878

public class Solution {
    public String shiftingLetters(String s, int[] shifts) {
        int n = s.length();
        for (int i = n - 2; i >= 0; i--) {
            shifts[i] = (shifts[i] + shifts[i + 1]) % 26;
        }
        
        char[] result = new char[n];
        for (int i = 0; i < n; i++) {
            result[i] = (char)(((s.charAt(i) - 'a') + shifts[i]) % 26 + 'a');
        }
        
        return new String(result);
    }
}

-----
public class Solution 
    // Your code here
}

************************************
Question ID: 879

public int maxDistToClosest(int[] seats) {
    int maxDist = 0, lastPerson = -1;
    for (int i = 0; i < seats.length; ++i) {
        if (seats[i] == 1) {
            maxDist = lastPerson < 0 ? i : Math.max(maxDist, (i - lastPerson) / 2);
            lastPerson = i;
        }
    }
    return Math.max(maxDist, seats.length - 1 - lastPerson);
}

-----
public int maxDistToClosest(int[] seats) 
    // Your code here
}

************************************
Question ID: 880

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

class Solution {
    public int rectangleArea(int[][] rectangles) {
        int mod = 1000000007;
        ArrayList<Integer> X = new ArrayList<>();
        HashMap<Integer, Integer> Xcompress = new HashMap<>();
        for(int[] rect : rectangles){
            X.add(rect[0]);
            X.add(rect[2]);
        }
        Collections.sort(X);
        int idx = 0;
        for(int x : X){
            if(!Xcompress.containsKey(x))
                Xcompress.put(x, idx++);
        }

        ArrayList<int[]> events = new ArrayList<>();
        for(int[] rect : rectangles){
            events.add(new int[]{Xcompress.get(rect[0]), 1, rect[1], rect[3]});
            events.add(new int[]{Xcompress.get(rect[2]), -1, rect[1], rect[3]});
        }
        events.sort((a, b) -> Integer.compare(a[0], b[0]));

        int area = 0;
        int[] cnt = new int[idx];
        int active = 0;
        for(int[] e : events){
            int index = e[0], type = e[1], y1 = e[2], y2 = e[3];
            area = (int) ((area + (long)(X.get(index+1) - X.get(index)) * active % mod) % mod);
            cnt[y1] += type;
            cnt[y2] -= type;
            active = 0;
            for(int i = 0; i < index; ++i){
                if(cnt[i] > 0)
                    active += X.get(i+1) - X.get(i);
            }
        }
        return area;
    }
}

-----
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

class Solution 
    // Your code here
}

************************************
Question ID: 881

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public int[] loudAndRich(int[][] richer, int[] quiet) {
    int n = quiet.length;
    List<Integer>[] graph = new ArrayList[n];
    for (int i = 0; i < n; ++i)
        graph[i] = new ArrayList<>();

    for (int[] entry : richer)
        graph[entry[1]].add(entry[0]);

    int[] answer = new int[n];
    Arrays.fill(answer, -1);
    for (int i = 0; i < n; ++i)
        dfs(i, graph, quiet, answer);

    return answer;
}

private void dfs(int x, List<Integer>[] graph, int[] quiet, int[] answer) {
    if (answer[x] != -1) return;
    answer[x] = x;
    for (int y : graph[x]) {
        dfs(y, graph, quiet, answer);
        if (quiet[answer[y]] < quiet[answer[x]])
            answer[x] = answer[y];
    }
}


-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public int[] loudAndRich(int[][] richer, int[] quiet) 
    // Your code here
}


************************************
Question ID: 882

public int peakIndexInMountainArray(int[] arr) {
    int low = 0, high = arr.length - 1;
    while (low < high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] < arr[mid + 1])
            low = mid + 1;
        else
            high = mid;
    }
    return low;
}

-----
public int peakIndexInMountainArray(int[] arr) 
    // Your code here
}

************************************
Question ID: 883

public int carFleet(int target, int[] position, int[] speed) {
    int n = position.length;
    Integer[] indices = new Integer[n];
    for (int i = 0; i < n; i++) {
        indices[i] = i;
    }

    Arrays.sort(indices, (a, b) -> position[b] - position[a]);

    int fleets = 0;
    double lastArrival = -1;
    for (int i : indices) {
        double arrival = (double) (target - position[i]) / speed[i];
        if (arrival > lastArrival) {
            fleets++;
            lastArrival = arrival;
        }
    }

    return fleets;
}


-----
public int carFleet(int target, int[] position, int[] speed) 
    // Your code here
}


************************************
Question ID: 884

public int kSimilarity(String s1, String s2) {
    int k = 0;
    StringBuilder a = new StringBuilder(s1);
    StringBuilder b = new StringBuilder(s2);
    for (int i = 0; i < a.length(); ++i) {
        if (a.charAt(i) != b.charAt(i)) {
            for (int j = i + 1; j < b.length(); ++j) {
                if (a.charAt(i) == b.charAt(j) && a.charAt(j) != b.charAt(j)) {
                    a.setCharAt(i, a.charAt(j));
                    a.setCharAt(j, b.charAt(j));
                    k++;
                    break;
                }
            }
        }
    }
    return k;
}

-----
public int kSimilarity(String s1, String s2) 
    // Your code here
}

************************************
Question ID: 885

import java.util.TreeSet;

class ExamRoom {
    TreeSet<Integer> students;
    int n;

    public ExamRoom(int n) {
        this.students = new TreeSet<>();
        this.n = n;
    }

    public int seat() {
        if (students.isEmpty()) {
            students.add(0);
            return 0;
        }
        
        int distance = students.first(), seatIndex = 0;
        
        Integer prev = students.first();
        for (Integer current : students) {
            if (current != prev) {
                int d = (current - prev) / 2;

                if (d > distance) {
                    distance = d;
                    seatIndex = prev + d;
                }
                prev = current;
            }
        }

        if (n - 1 - students.last() > distance)
            seatIndex = n - 1;

        students.add(seatIndex);
        return seatIndex;
    }

    public void leave(int p) {
        students.remove(p);
    }
}


-----
import java.util.TreeSet;

class ExamRoom 
    // Your code here
}


************************************
Question ID: 886

int scoreOfParentheses(String s) {
    int score = 0, depth = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '(')
            depth++;
        else {
            depth--;
            if (s.charAt(i - 1) == '(')
                score += 1 << depth;
        }
    }
    return score;
}

-----
int scoreOfParentheses(String s) 
    // Your code here
}

************************************
Question ID: 887

import java.util.PriorityQueue;
import java.util.Arrays;

public double mincostToHireWorkers(int[] quality, int[] wage, int K) {
    int N = quality.length;
    double[][] workers = new double[N][2];
    for (int i = 0; i < N; ++i)
        workers[i] = new double[] {(double) wage[i] / quality[i], (double) quality[i]};

    Arrays.sort(workers, (a, b) -> Double.compare(a[0], b[0]));

    double ans = 1e60;
    int sumq = 0;
    PriorityQueue<Integer> pool = new PriorityQueue<>((a, b) -> -Integer.compare(a, b));
    for (double[] worker: workers) {
        pool.offer((int) worker[1]);
        sumq += worker[1];

        if (pool.size() > K)
            sumq -= pool.poll();

        if (pool.size() == K)
            ans = Math.min(ans, worker[0] * sumq);
    }

    return ans;
}

-----
import java.util.PriorityQueue;
import java.util.Arrays;

public double mincostToHireWorkers(int[] quality, int[] wage, int K) 
    // Your code here
}

************************************
Question ID: 888

public int mirrorReflection(int p, int q) {
    int m = p, n = q;
    int gcd;
    while (n != 0) {
        gcd = m % n;
        m = n;
        n = gcd;
    }

    if ((p / m) % 2 == 0) return 2;
    if ((q / m) % 2 == 0) return 0;
    return 1;
}

-----
public int mirrorReflection(int p, int q) 
    // Your code here
}

************************************
Question ID: 889

public boolean areAlmostEqual(String s, String goal) {
    if (s.equals(goal)) return true;
    int count = 0;
    int index1 = -1, index2 = -1;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) != goal.charAt(i)) {
            count++;
            if (index1 == -1) index1 = i;
            else index2 = i;
            if (count > 2) return false;
        }
    }
    return (count == 2 && s.charAt(index1) == goal.charAt(index2) && s.charAt(index2) == goal.charAt(index1));
}

-----
public boolean areAlmostEqual(String s, String goal) 
    // Your code here
}

************************************
Question ID: 890

public boolean lemonadeChange(int[] bills) {
    int five = 0, ten = 0;
    for (int bill : bills) {
        if (bill == 5)
            five++;
        else if (bill == 10) {
            if (five == 0) return false;
            five--;
            ten++;
        } else {
            if (ten > 0 && five > 0) {
                ten--;
                five--;
            } else if (five >= 3)
                five -= 3;
            else
                return false;
        }
    }
    return true;
}


-----
public boolean lemonadeChange(int[] bills) 
    // Your code here
}


************************************
Question ID: 891

public int matrixScore(int[][] grid) {
    int m = grid.length, n = grid[0].length;
    for (int i = 0; i < m; i++) {
        if (grid[i][0] == 0) {
            for (int j = 0; j < n; j++) {
                grid[i][j] = 1 - grid[i][j];
            }
        }
    }
    for (int j = 1; j < n; j++) {
        int count = 0;
        for (int i = 0; i < m; i++) {
            count += grid[i][j];
        }
        if (count <= m / 2) {
            for (int i = 0; i < m; i++) {
                grid[i][j] = 1 - grid[i][j];
            }
        }
    }
    int sum = 0;
    for (int i = 0; i < m; i++) {
        int num = 0;
        for (int j = 0; j < n; j++) {
            num = num * 2 + grid[i][j];
        }
        sum += num;
    }
    return sum;
}

-----
public int matrixScore(int[][] grid) 
    // Your code here
}

************************************
Question ID: 892

import java.util.ArrayDeque;
import java.util.Deque;

public int shortestSubarray(int[] nums, int k) {
    int n = nums.length;
    int[] prefixSum = new int[n + 1];
    for (int i = 0; i < n; i++) prefixSum[i + 1] = prefixSum[i] + nums[i];

    int res = n + 1;
    Deque<Integer> dq = new ArrayDeque<>();
    for (int i = 0; i < n + 1; i++) {
        while (!dq.isEmpty() && prefixSum[i] - prefixSum[dq.peek()] >= k) {
            res = Math.min(res, i - dq.poll());
        }
        while (!dq.isEmpty() && prefixSum[i] <= prefixSum[dq.peekLast()]) {
            dq.pollLast();
        }
        dq.offer(i);
    }
    return res <= n ? res : -1;
}

-----
import java.util.ArrayDeque;
import java.util.Deque;

public int shortestSubarray(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 893

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

public List<Integer> findNodesAtDistanceK(TreeNode root, int targetVal, int k) {
    if (k < 0) return new ArrayList<>();
    Map<TreeNode, TreeNode> parentMap = new HashMap<>();
    Set<TreeNode> visited = new HashSet<>();
    TreeNode targetNode = initializeParentMap(root, null, targetVal, parentMap);

    List<Integer> result = new ArrayList<>();
    findNodesAtDistanceKHelper(targetNode, k, visited, parentMap, result);
    return result;
}

private TreeNode initializeParentMap(TreeNode node, TreeNode parent, int targetVal, Map<TreeNode, TreeNode> parentMap) {
    if (node == null) return null;
    if (node.val == targetVal) return node;
    parentMap.put(node, parent);
    TreeNode left = initializeParentMap(node.left, node, targetVal, parentMap);
    TreeNode right = initializeParentMap(node.right, node, targetVal, parentMap);
    return left != null ? left : right;
}

private void findNodesAtDistanceKHelper(TreeNode node, int k, Set<TreeNode> visited, Map<TreeNode, TreeNode> parentMap, List<Integer> result) {
    if (node == null || visited.contains(node)) return;
    visited.add(node);
    if (k == 0) {
        result.add(node.val);
        return;
    }
    
    findNodesAtDistanceKHelper(node.left, k-1, visited, parentMap, result);
    findNodesAtDistanceKHelper(node.right, k-1, visited, parentMap, result);
    findNodesAtDistanceKHelper(parentMap.get(node), k-1, visited, parentMap, result);
}


-----
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;

class TreeNode 
    // Your code here
}


************************************
Question ID: 894

import java.util.HashMap;
import java.util.Random;

class Solution {
    HashMap<Integer, Integer> blacklistMap;
    int reducedN;
    Random rand = new Random();

    public Solution(int n, int[] blacklist) {
        blacklistMap = new HashMap<>();
        for (int b : blacklist) {
            if (b < n) {
                blacklistMap.put(b, -1);
            }
        }
        reducedN = n - blacklistMap.size();

        for (int b : blacklist) {
            if (b >= reducedN) continue;
            while (blacklistMap.containsKey(--n)) {}
            blacklistMap.put(b, n);
        }
    }

    public int pick() {
        int randomInt = rand.nextInt(reducedN);
        return blacklistMap.getOrDefault(randomInt, randomInt);
    }
}

-----
import java.util.HashMap;
import java.util.Random;

class Solution 
    // Your code here
}

************************************
Question ID: 895

import java.util.*;

public int shortestPathAllKeys(String[] grid) {
    int m = grid.length, n = grid[0].length(), steps = 0, k = 0, x = -1, y = -1, mask = 0;
    Queue<int[]> q = new LinkedList<>();
    
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i].charAt(j) == '@') {
                x = i;
                y = j;
            } else if (grid[i].charAt(j) >= 'a' && grid[i].charAt(j) <= 'f') {
                k = Math.max(k, grid[i].charAt(j) - 'a' + 1);
            }
        }
    }
    
    q.add(new int[]{ x, y, 0 });
    Set<String> visited = new HashSet<>();
    visited.add(x + "," + y + "," + mask);
    
    int[][] dirs = { {-1, 0}, {1, 0}, {0, 1}, {0, -1} };
    
    while (!q.isEmpty()) {
        int qs = q.size();
        
        for (int sz = 0; sz < qs; sz++) {
            int[] cur = q.poll();
            int x = cur[0], y = cur[1], mask = cur[2];
            
            if (mask == (1 << k) - 1) return steps;
            
            for (int[] dir : dirs) {
                int nx = x + dir[0], ny = y + dir[1], nmask = mask;
                
                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                    char c = grid[nx].charAt(ny);
                    if (c >= 'A' && c <= 'F' && (nmask & (1 << (c - 'A'))) == 0) continue;
                    if (c >= 'a' && c <= 'f') nmask |= (1 << (c - 'a'));
                    
                    String key = nx + "," + ny + "," + nmask;
                    
                    if (visited.contains(key)) continue;
                    
                    visited.add(key);
                    q.add(new int[]{ nx, ny, nmask });
                }
            }
        }
        
        steps++;
    }
    
    return -1;
}


-----
import java.util.*;

public int shortestPathAllKeys(String[] grid) 
    // Your code here
}


************************************
Question ID: 897

boolean isPrime(int n) {
    if (n <= 1) return false;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) return false;
    }
    return true;
}

boolean isPalindrome(int n) {
    int rev = 0, orig = n;
    while (n > 0) {
        rev = rev * 10 + n % 10;
        n /= 10;
    }
    return orig == rev;
}

int primePalindrome(int n) {
    while (true) {
        if (isPrime(n) && isPalindrome(n)) return n;
        n++;
    }
}

-----
boolean isPrime(int n) 
    // Your code here
}

************************************
Question ID: 898

public int[][] transpose(int[][] matrix) {
    int rows = matrix.length;
    int cols = matrix[0].length;
    int[][] result = new int[cols][rows];
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            result[j][i] = matrix[i][j];
        }
    }
    return result;
}

-----
public int[][] transpose(int[][] matrix) 
    // Your code here
}

************************************
Question ID: 899

int longestDistance(int n) {
    int last = -1, longest = 0;
    for (int i = 0; n > 0; n >>= 1, i++) {
        if ((n & 1) == 1) {
            if (last >= 0)
                longest = Math.max(longest, i - last);
            last = i;
        }
    }
    return longest;
}

-----
int longestDistance(int n) 
    // Your code here
}

************************************
Question ID: 900

import java.util.Arrays;

public boolean reorderedPowerOf2(int n) {
    char[] s = String.valueOf(n).toCharArray();
    Arrays.sort(s);
    do {
        if (s[0] != '0' && Integer.bitCount(Integer.parseInt(new String(s))) == 1) {
            return true;
        }
    } while (nextPermutation(s));
    return false;
}

private boolean nextPermutation(char[] s) {
    int i = s.length - 2;
    while (i >= 0 && s[i] >= s[i + 1]) {
        i--;
    }
    if (i == -1) {
        return false;
    }
    int j = s.length - 1;
    while (s[j] <= s[i]) {
        j--;
    }
    char temp = s[i];
    s[i] = s[j];
    s[j] = temp;

    int left = i + 1;
    int right = s.length - 1;
    while (left < right) {
        temp = s[left];
        s[left++] = s[right];
        s[right--] = temp;
    }
    return true;
}


-----
import java.util.Arrays;

public boolean reorderedPowerOf2(int n) 
    // Your code here
}


************************************
Question ID: 901

import java.util.*;

public int[] advantageCount(int[] nums1, int[] nums2) {
    int[] res = new int[nums1.length];
    TreeMap<Integer, Integer> map = new TreeMap<>();
    
    for (int num : nums1) {
        map.put(num, map.getOrDefault(num, 0) + 1);
    }
    
    for (int i = 0; i < nums2.length; i++) {
        Integer key = map.higherKey(nums2[i]);
        if (key == null) {
            key = map.firstKey();
        }
        
        res[i] = key;
        map.put(key, map.get(key) - 1);
        if (map.get(key) == 0) {
            map.remove(key);
        }
    }
    
    return res;
}

-----
import java.util.*;

public int[] advantageCount(int[] nums1, int[] nums2) 
    // Your code here
}

************************************
Question ID: 902

import java.util.PriorityQueue;

public int minRefuelStops(int target, int startFuel, int[][] stations) {
    int i = 0, stops = 0, curFuel = startFuel;
    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);
    while (curFuel < target) {
        while (i < stations.length && stations[i][0] <= curFuel) {
            pq.offer(stations[i][1]);
            i++;
        }
        if (pq.isEmpty()) return -1;
        curFuel += pq.poll();
        stops++;
    }
    return stops;
}


-----
import java.util.PriorityQueue;

public int minRefuelStops(int target, int startFuel, int[][] stations) 
    // Your code here
}


************************************
Question ID: 903

public int rand7(); // Given API

public int rand10() {
    int result;
    do {
        result = (rand7() - 1) * 7 + rand7();
    } while (result > 40);
    return result % 10 + 1;
}

-----
public int rand7(); // Given API

public int rand10() 
    // Your code here
}

************************************
Question ID: 904

public boolean leafSimilar(TreeNode root1, TreeNode root2) {
    List<Integer> leaves1 = new ArrayList<>();
    List<Integer> leaves2 = new ArrayList<>();
    getLeaves(root1, leaves1);
    getLeaves(root2, leaves2);
    return leaves1.equals(leaves2);
}

private void getLeaves(TreeNode node, List<Integer> leaves) {
    if (node == null) return;
    if (node.left == null && node.right == null) leaves.add(node.val);
    getLeaves(node.left, leaves);
    getLeaves(node.right, leaves);
}

-----
public boolean leafSimilar(TreeNode root1, TreeNode root2) 
    // Your code here
}

************************************
Question ID: 905

import java.util.HashMap;
import java.util.Map;

public int lenLongestFibSubseq(int[] arr) {
    int n = arr.length;
    Map<Integer, Integer> index = new HashMap<>();
    for (int i = 0; i < n; ++i)
        index.put(arr[i], i);

    Map<Integer, Integer> longest = new HashMap<>();
    int ans = 0;

    for (int k = 0; k < n; ++k)
        for (int j = 0; j < k; ++j) {
            int i = index.getOrDefault(arr[k] - arr[j], -1);
            if (i >= 0 && i < j) {
                longest.put(j * n + k, longest.getOrDefault(i * n + j, 1) + 1);
                ans = Math.max(ans, longest.get(j * n + k) + 1);
            }
        }

    return ans >= 3 ? ans : 0;
}

-----
import java.util.HashMap;
import java.util.Map;

public int lenLongestFibSubseq(int[] arr) 
    // Your code here
}

************************************
Question ID: 907

public int minEatingSpeed(int[] piles, int h) {
    int left = 1, right = 1;
    for (int pile : piles)
        right = Math.max(right, pile);
    while (left < right) {
        int mid = left + (right - left) / 2;
        int totalHours = 0;
        for (int pile : piles)
            totalHours += (pile + mid - 1) / mid;
        if (totalHours > h)
            left = mid + 1;
        else
            right = mid;
    }
    return left;
}

-----
public int minEatingSpeed(int[] piles, int h) 
    // Your code here
}

************************************
Question ID: 909

public boolean aliceWins(int[] piles) {
    int n = piles.length;
    int[][] dp = new int[n][n];
    for (int gap = 0; gap < n; ++gap) {
        for (int i = 0, j = gap; j < n; ++i, ++j) {
            int x = (i + 2) <= j ? dp[i + 2][j] : 0;
            int y = (i + 1) <= (j - 1) ? dp[i + 1][j - 1] : 0;
            int z = i <= (j - 2) ? dp[i][j - 2] : 0;
            dp[i][j] = Math.max(piles[i] + Math.min(x, y), piles[j] + Math.min(y, z));
        }
    }
    int sum = Arrays.stream(piles).sum();
    return dp[0][n - 1] > (sum - dp[0][n - 1]);
}

-----
public boolean aliceWins(int[] piles) 
    // Your code here
}

************************************
Question ID: 910

public int nthMagicalNumber(int n, int a, int b) {
    long mod = 1000000007;
    long lcm = a * b / gcd(a, b);
    long left = 1, right = (long)1e14, mid;
    while(left < right) {
        mid = left + (right - left) / 2;
        if ((mid / a + mid / b - mid / lcm) < n) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return (int)(left % mod);
}

public int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}

-----
public int nthMagicalNumber(int n, int a, int b) 
    // Your code here
}

************************************
Question ID: 911

public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {
    int[][] dp = new int[n + 1][minProfit + 1];
    int mod = (int) 1e9 + 7;
    dp[0][0] = 1;
    for (int i = 0; i < group.length; ++i) {
        for (int j = n; j >= group[i]; --j) {
            for (int k = minProfit; k >= 0; --k) {
                dp[j][k] = (dp[j][k] + dp[j - group[i]][Math.max(0, k - profit[i])]) % mod;
            }
        }
    }
    int res = 0;
    for (int i = 1; i <= n; ++i) {
        res = (res + dp[i][minProfit]) % mod;
    }
    return res;
}

-----
public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) 
    // Your code here
}

************************************
Question ID: 912

import java.util.Random;

class Solution {
    private int[] prefixSum;
    private Random random;
    
    public Solution(int[] w) {
        prefixSum = new int[w.length];
        prefixSum[0] = w[0];
        for (int i = 1; i < w.length; i++) {
            prefixSum[i] = prefixSum[i - 1] + w[i];
        }
        random = new Random();
    }
    
    public int pickIndex() {
        int num = random.nextInt(prefixSum[prefixSum.length - 1]) + 1;
        int idx = 0;
        while (num > prefixSum[idx]) {
            idx++;
        }
        return idx;
    }
}

-----
import java.util.Random;

class Solution 
    // Your code here
}

************************************
Question ID: 913

import java.util.Random;

class Solution {
    private int[][] grid;
    private int zeroCount;
    private final Random rng = new Random();

    public Solution(int m, int n) {
        this.grid = new int[m][n];
        this.zeroCount = m * n;
    }

    public int[] pick() {
        int index = rng.nextInt(zeroCount);

        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 0) {
                    if (index == 0) {
                        grid[i][j] = 1;
                        zeroCount--;
                        return new int[]{i, j};
                    }
                    index--;
                }
            }
        }
        return new int[]{-1, -1};  // Should not happen
    }
}

-----
import java.util.Random;

class Solution 
    // Your code here
}

************************************
Question ID: 914

import java.util.Random;
import java.util.ArrayList;

class Solution {
    private int[][] rects;
    private ArrayList<Integer> areas;
    private int totalArea;
    private Random random;

    public Solution(int[][] rects) {
        this.rects = rects;
        areas = new ArrayList<Integer>();
        totalArea = 0;
        for (int[] rect : rects) {
            int area = (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1);
            totalArea += area;
            areas.add(totalArea);
        }
        random = new Random();
    }

    public int[] pick() {
        int randomArea = random.nextInt(totalArea);
        int rectIndex = 0;
        while (areas.get(rectIndex) <= randomArea) {
            rectIndex++;
        }

        int x = rects[rectIndex][0] + random.nextInt(rects[rectIndex][2] - rects[rectIndex][0] + 1);
        int y = rects[rectIndex][1] + random.nextInt(rects[rectIndex][3] - rects[rectIndex][1] + 1);

        return new int[] {x, y};
    }
}


-----
import java.util.Random;
import java.util.ArrayList;

class Solution 
    // Your code here
}


************************************
Question ID: 915

import java.util.Random;

class Solution {
    private double radius, x_center, y_center;
    private Random random;

    public Solution(double radius, double x_center, double y_center) {
        this.radius = radius;
        this.x_center = x_center;
        this.y_center = y_center;
        this.random = new Random();
    }
    
    public double[] randPoint() {
        double angle = random.nextDouble() * 2 * Math.PI;
        double r = Math.sqrt(random.nextDouble()) * radius;
        return new double[]{x_center + r * Math.cos(angle), y_center + r * Math.sin(angle)};
    }
}

-----
import java.util.Random;

class Solution 
    // Your code here
}

************************************
Question ID: 916

public char findKthCharacter(String s, int k) {
    int n = s.length();
    long size = 0;

    for (char c : s.toCharArray()) {
        if (Character.isDigit(c)) {
            size = size * (c - '0');
        } else {
            size++;
        }
    }

    for (int i = n - 1; i >= 0; i--) {
        char c = s.charAt(i);
        k %= size;
        if (k == 0 && !Character.isDigit(c)) {
            return c;
        }

        if (Character.isDigit(c)) {
            size /= (c - '0');
        } else {
            size--;
        }
    }

    return '-';
}

-----
public char findKthCharacter(String s, int k) 
    // Your code here
}

************************************
Question ID: 917

import java.util.Arrays;

public int numRescueBoats(int[] people, int limit) {
    Arrays.sort(people);
    int left = 0, right = people.length - 1;
    int boats = 0;
    while (left <= right) {
        if (people[left] + people[right] <= limit) {
            left++;
        }
        right--;
        boats++;
    }
    return boats;
}

-----
import java.util.Arrays;

public int numRescueBoats(int[] people, int limit) 
    // Your code here
}

************************************
Question ID: 918

import java.util.*;

class Solution {
    public int reachableNodes(int[][] edges, int maxMoves, int n) {
        List<List<int[]>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            graph.add(new ArrayList<>());
        }
        
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1], cnt = edge[2];
            graph.get(u).add(new int[]{v, cnt + 1});
            graph.get(v).add(new int[]{u, cnt + 1});
        }

        Set<Integer> visited = new HashSet<>();
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);
        pq.offer(new int[]{maxMoves, 0});

        while (!pq.isEmpty()) {
            int[] top = pq.poll();
            int moves_left = top[0];
            int node = top[1];

            if (visited.contains(node)) continue;
            visited.add(node);

            for (int[] neighbor : graph.get(node)) {
                int next_node = neighbor[0];
                int moves_needed = neighbor[1];
                int moves_left_after = moves_left - moves_needed;

                if (!visited.contains(next_node) && moves_left_after > 0) {
                    pq.offer(new int[]{moves_left_after, next_node});
                }
            }
        }

        return visited.size();
    }
}


-----
import java.util.*;

class Solution 
    // Your code here
}


************************************
Question ID: 919

public int projectionArea(int[][] grid) {
    int n = grid.length;
    int top = 0, front = 0, side = 0;
    for (int i = 0; i < n; i++) {
        int maxFront = 0, maxSide = 0;
        for (int j = 0; j < n; j++) {
            if (grid[i][j] > 0) {
                top++;
            }
            maxFront = Math.max(maxFront, grid[i][j]);
            maxSide = Math.max(maxSide, grid[j][i]);
        }
        front += maxFront;
        side += maxSide;
    }
    return top + front + side;
}

-----
public int projectionArea(int[][] grid) 
    // Your code here
}

************************************
Question ID: 920

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public List<String> uncommonFromSentences(String s1, String s2) {
    Map<String, Integer> wordCount = new HashMap<>();
    for (String word : (s1 + " " + s2).split(" ")) {
        wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
    }

    List<String> result = new ArrayList<>();
    for (Map.Entry<String, Integer> entry : wordCount.entrySet()) {
        if (entry.getValue() == 1) {
            result.add(entry.getKey());
        }
    }

    return result;
}

-----
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public List<String> uncommonFromSentences(String s1, String s2) 
    // Your code here
}

************************************
Question ID: 921

import java.util.ArrayList;
import java.util.Arrays;

public ArrayList<int[]> spiral_walk(int rows, int cols, int rStart, int cStart) {
    ArrayList<int[]> result = new ArrayList<>();
    int[] dr = {0, 1, 0, -1};
    int[] dc = {1, 0, -1, 0};
    int moves = rows * cols;
    int r = rStart, c = cStart, dir = 0;
    
    while (result.size() < moves) {
        result.add(new int[]{r, c});
        r += dr[dir];
        c += dc[dir];
        
        if (r < 0 || r >= rows || c < 0 || c >= cols) {
            r -= dr[dir];
            c -= dc[dir];
            dir = (dir + 1) % 4;
            r += dr[dir];
            c += dc[dir];
        }
    }

    return result;
}

-----
import java.util.ArrayList;
import java.util.Arrays;

public ArrayList<int[]> spiral_walk(int rows, int cols, int rStart, int cStart) 
    // Your code here
}

************************************
Question ID: 922

import java.util.ArrayList;
import java.util.List;

public class Solution {
    public boolean possibleBipartition(int n, int[][] dislikes) {
        int[] groups = new int[n + 1];
        List<List<Integer>> dislikeList = new ArrayList<>();
        for (int i = 0; i <= n; i++) {
            dislikeList.add(new ArrayList<>());
        }
        for (int[] dislikePair : dislikes) {
            dislikeList.get(dislikePair[0]).add(dislikePair[1]);
            dislikeList.get(dislikePair[1]).add(dislikePair[0]);
        }
        for (int person = 1; person <= n; person++) {
            if (groups[person] == 0 && !dfs(person, 1, groups, dislikeList)) {
                return false;
            }
        }
        return true;
    }
    
    private boolean dfs(int person, int group, int[] groups, List<List<Integer>> dislikeList) {
        if (groups[person] != 0) {
            return groups[person] == group;
        }
        groups[person] = group;
        for (int other : dislikeList.get(person)) {
            if (!dfs(other, -group, groups, dislikeList)) {
                return false;
            }
        }
        return true;
    }
}


-----
import java.util.ArrayList;
import java.util.List;

public class Solution 
    // Your code here
}


************************************
Question ID: 923

int minMoves(int k, int n) {
    if (k == 1 || n == 0 || n == 1) {
        return n;
    }
    int res = Integer.MAX_VALUE;
    for (int i = 1; i <= n; i++) {
        int temp = Math.max(minMoves(k - 1, i - 1), minMoves(k, n - i));
        res = Math.min(res, temp);
    }
    return res + 1;
}

-----
int minMoves(int k, int n) 
    // Your code here
}

************************************
Question ID: 924

public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {
    int aliceTotal = 0, bobTotal = 0;
    for (int candy : aliceSizes) aliceTotal += candy;
    for (int candy : bobSizes) bobTotal += candy;

    int delta = (bobTotal - aliceTotal) / 2;
    for (int a : aliceSizes) {
        for (int b : bobSizes) {
            if (a + delta == b) {
                return new int[]{a, b};
            }
        }
    }
    return new int[]{};
}

-----
public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) 
    // Your code here
}

************************************
Question ID: 926

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public List<String> findAndReplacePatterns(String[] words, String pattern) {
    List<String> result = new ArrayList<>();
    for (String word : words) {
        if (word.length() != pattern.length()) continue;

        Map<Character, Character> w2p = new HashMap<>();
        Map<Character, Character> p2w = new HashMap<>();
        boolean matches = true;
        for (int i = 0; i < word.length(); ++i) {
            char cWord = word.charAt(i);
            char cPattern = pattern.charAt(i);

            if (!w2p.containsKey(cWord)) w2p.put(cWord, cPattern);
            if (!p2w.containsKey(cPattern)) p2w.put(cPattern, cWord);

            if (w2p.get(cWord) != cPattern || p2w.get(cPattern) != cWord) {
                matches = false;
                break;
            }
        }
        if (matches) result.add(word);
    }
    return result;
}


-----
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public List<String> findAndReplacePatterns(String[] words, String pattern) 
    // Your code here
}


************************************
Question ID: 927

import java.util.Arrays;

public class Solution {
    private static final int MOD = 1000000007;

    public int sumOfWidths(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        long res = 0, c = 1;
        
        for (int i = 0; i < n; i++, c = c * 2 % MOD)
            res = (res + (nums[i] - nums[n - i - 1]) * c) % MOD;
            
        return (int) res;
    }
}

-----
import java.util.Arrays;

public class Solution 
    // Your code here
}

************************************
Question ID: 928

public int surfaceArea(int[][] grid) {
    int n = grid.length;
    int area = 0;

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] > 0) {
                area += 4 * grid[i][j] + 2;
                if (i > 0) area -= 2 * Math.min(grid[i][j], grid[i - 1][j]);
                if (j > 0) area -= 2 * Math.min(grid[i][j], grid[i][j - 1]);
            }
        }
    }

    return area;
}

-----
public int surfaceArea(int[][] grid) 
    // Your code here
}

************************************
Question ID: 929

import java.util.Set;
import java.util.HashSet;
import java.util.Arrays;

public int numSpecialEquivalentGroups(String[] words) {
    Set<String> groups = new HashSet<>();

    for (String word : words) {
        StringBuilder evens = new StringBuilder();
        StringBuilder odds = new StringBuilder();

        for (int i = 0; i < word.length(); ++i) {
            if (i % 2 == 0) evens.append(word.charAt(i));
            else odds.append(word.charAt(i));
        }

        char[] evenArr = evens.toString().toCharArray();
        Arrays.sort(evenArr);
        char[] oddArr = odds.toString().toCharArray();
        Arrays.sort(oddArr);

        groups.add(new String(evenArr) + new String(oddArr));
    }

    return groups.size();
}


-----
import java.util.Set;
import java.util.HashSet;
import java.util.Arrays;

public int numSpecialEquivalentGroups(String[] words) 
    // Your code here
}


************************************
Question ID: 931

import java.util.*;

class FreqStack {
    private Map<Integer, Integer> freq;
    private Map<Integer, Stack<Integer>> group;

    public FreqStack() {
        freq = new HashMap<>();
        group = new TreeMap<>(Collections.reverseOrder());
    }

    public void push(int x) {
        int f = freq.getOrDefault(x, 0) + 1;
        freq.put(x, f);
        group.computeIfAbsent(f, k -> new Stack<>()).push(x);
    }

    public int pop() {
        int x = group.get(group.keySet().iterator().next()).pop();
        int f = freq.get(x) - 1;
        freq.put(x, f);
        
        if (group.get(f + 1).empty()) {
            group.remove(f + 1);
        }
        
        return x;
    }
}


-----
import java.util.*;

class FreqStack 
    // Your code here
}


************************************
Question ID: 932

public boolean isMonotonic(int[] nums) {
    boolean increasing = true, decreasing = true;
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] > nums[i - 1]) decreasing = false;
        if (nums[i] < nums[i - 1]) increasing = false;
    }
    return increasing || decreasing;
}

-----
public boolean isMonotonic(int[] nums) 
    // Your code here
}

************************************
Question ID: 934

import java.util.HashSet;
import java.util.Set;

public int subarrayBitwiseORs(int[] arr) {
    Set<Integer> result = new HashSet<>(), current, temp;
    for (int num : arr) {
        temp = new HashSet<>();
        temp.add(num);
        for (int c : current) {
            temp.add(num | c);
        }
        current = temp;
        result.addAll(current);
    }
    return result.size();
}

-----
import java.util.HashSet;
import java.util.Set;

public int subarrayBitwiseORs(int[] arr) 
    // Your code here
}

************************************
Question ID: 935

public String lexSmallestString(String s, int k) {
    String res = s;
    for (int i = 0; i < k; i++) {
        String tmp = s.substring(i) + s.substring(0, i);
        if (tmp.compareTo(res) < 0) {
            res = tmp;
        }
    }
    return res;
}

-----
public String lexSmallestString(String s, int k) 
    // Your code here
}

************************************
Question ID: 938

import java.util.Arrays;

public int numDigitsLessThanN(int[] digits, int n) {
    int ans = 0, factor = 1;
    String nStr = Integer.toString(n);
    for (int i = nStr.length() - 1; i >= 0; --i) {
        ans += (Arrays.binarySearch(digits, nStr.charAt(i) - '0') + 1) * factor;
        factor *= digits.length;
    }
    return ans;
}

-----
import java.util.Arrays;

public int numDigitsLessThanN(int[] digits, int n) 
    // Your code here
}

************************************
Question ID: 939

public int findValidPermutations(String s) {
    int n = s.length();
    long[] dp = new long[n + 2];
    dp[0] = 1;
    int MOD = 1000000007;

    for (char c : s.toCharArray()) {
        long[] new_dp = new long[n + 2];
        if (c == 'I') {
            for (int i = 0; i < n; ++i) {
                new_dp[i + 1] = (new_dp[i + 1] + dp[i]) % MOD;
            }
        } else {
            for (int i = n - 1; i >= 0; --i) {
                new_dp[i] = (new_dp[i + 1] + dp[i + 1]) % MOD;
            }
        }
        dp = new_dp;
    }
    return (int) dp[0];
}

-----
public int findValidPermutations(String s) 
    // Your code here
}

************************************
Question ID: 940

import java.util.HashMap;

public int totalFruit(int[] fruits) {
    int left = 0, right = 0, max_count = 0, n = fruits.length;
    HashMap<Integer, Integer> count = new HashMap<>();

    while (right < n) {
        count.put(fruits[right], count.getOrDefault(fruits[right], 0) + 1);
        while (count.size() > 2) {
            count.put(fruits[left], count.get(fruits[left]) - 1);
            if (count.get(fruits[left]) == 0) {
                count.remove(fruits[left]);
            }
            left++;
        }
        max_count = Math.max(max_count, right - left + 1);
        right++;
    }
    return max_count;
}

-----
import java.util.HashMap;

public int totalFruit(int[] fruits) 
    // Your code here
}

************************************
Question ID: 941

public void moveEvenOdd(int[] nums) {
    int evenIndex = 0;
    int oddIndex = nums.length - 1;

    while (evenIndex < oddIndex) {
        if (nums[evenIndex] % 2 == 0) {
            evenIndex++;
        } else {
            int temp = nums[evenIndex];
            nums[evenIndex] = nums[oddIndex];
            nums[oddIndex] = temp;
            oddIndex--;
        }
    }
}

-----
public void moveEvenOdd(int[] nums) 
    // Your code here
}

************************************
Question ID: 942

boolean isPalindrome(long num) {
    String str = Long.toString(num);
    String revStr = new StringBuilder(str).reverse().toString();
    return str.equals(revStr);
}

int superpalindromesInRange(String left, String right) {
    long l = Long.parseLong(left);
    long r = Long.parseLong(right);
    int cnt = 0;
    for (long base = 1; base * base <= r; ++base) {
        if (isPalindrome(base) && isPalindrome(base * base)) {
            if (base * base >= l) {
                cnt++;
            }
        }
    }
    return cnt;
}


-----
boolean isPalindrome(long num) 
    // Your code here
}


************************************
Question ID: 943

public int sumOfMins(int[] arr) {
    int mod = (int)1e9 + 7;
    int n = arr.length;
    int[] left = new int[n], right = new int[n];
    Stack<Integer> st = new Stack<>();

    for (int i = 0; i < n; i++) {
        while (!st.isEmpty() && arr[st.peek()] > arr[i]) {
            st.pop();
        }
        left[i] = st.isEmpty() ? -1 : st.peek();
        st.push(i);
    }

    st.clear();
    for (int i = n - 1; i >= 0; i--) {
        while (!st.isEmpty() && arr[st.peek()] > arr[i]) {
            st.pop();
        }
        right[i] = st.isEmpty() ? n : st.peek();
        st.push(i);
    }

    int ans = 0;
    for (int i = 0; i < n; i++) {
        ans = (int)((ans + (long)arr[i] * (i - left[i]) * (right[i] - i)) % mod);
    }
    return ans;
}

-----
public int sumOfMins(int[] arr) 
    // Your code here
}

************************************
Question ID: 944

public int minDifference(int[] nums, int k) {
    if(nums.length <= 1) return 0;
    Arrays.sort(nums);
    int min_diff = nums[nums.length - 1] - nums[0];
    for(int i = 1; i < nums.length; i++) {
        int high = Math.max(nums[i - 1] + k, nums[nums.length - 1] - k);
        int low = Math.min(nums[i] - k, nums[0] + k);
        min_diff = Math.min(min_diff, high - low);
    }
    return min_diff;
}

-----
public int minDifference(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 945

public int snakesAndLadders(int[][] board) {
    int n = board.length;
    int[] flattenedBoard = new int[n * n + 1];
    boolean isRight = true;
    int idx = 1;
    for (int i = n - 1; i >= 0; i--) {
        if (isRight) {
            for (int j = 0; j < n; j++) {
                flattenedBoard[idx++] = board[i][j];
            }
        } else {
            for (int j = n - 1; j >= 0; j--) {
                flattenedBoard[idx++] = board[i][j];
            }
        }
        isRight = !isRight;
    }

    int[] moves = new int[n * n + 1];
    Arrays.fill(moves, -1);
    moves[1] = 0;
    for (int i = 0; i < moves.length; i++) {
        if (moves[i] != -1) {
            for (int j = 1; j <= 6 && i + j < moves.length; j++) {
                int nextPos = i + j;
                int value = flattenedBoard[nextPos];
                if (value == -1) {
                    value = nextPos;
                }
                if (moves[value] == -1) {
                    moves[value] = moves[i] + 1;
                }
            }
        }
    }
    return moves[n * n];
}


-----
public int snakesAndLadders(int[][] board) 
    // Your code here
}


************************************
Question ID: 946

public int minimumScore(int[] nums, int k) {
    Arrays.sort(nums);
    int n = nums.length;
    int res = nums[n - 1] - nums[0];

    for (int i = 0; i < n - 1; i++) {
        int high = Math.max(nums[i] + k, nums[n - 1] - k);
        int low = Math.min(nums[i + 1] - k, nums[0] + k);
        res = Math.min(res, high - low);
    }

    return res;
}

-----
public int minimumScore(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 947

import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;

class TopVotedCandidate {
    TreeMap<Integer, Integer> leaderMap;

    public TopVotedCandidate(int[] persons, int[] times) {
        leaderMap = new TreeMap<>();
        Map<Integer, Integer> votes = new HashMap<>();
        int leader = -1;
        for (int i = 0; i < times.length; i++) {
            votes.put(persons[i], votes.getOrDefault(persons[i], 0) + 1);
            if (votes.get(persons[i]) >= votes.getOrDefault(leader, 0)) {
                leader = persons[i];
            }
            leaderMap.put(times[i], leader);
        }
    }

    public int q(int t) {
        return leaderMap.floorEntry(t).getValue();
    }
}

-----
import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;

class TopVotedCandidate 
    // Your code here
}

************************************
Question ID: 948

import java.util.Arrays;

public void sortArray(int[] nums) {
    Arrays.sort(nums);
}

-----
import java.util.Arrays;

public void sortArray(int[] nums) 
    // Your code here
}

************************************
Question ID: 949

import java.util.*;

class Solution {
    public int catMouseGame(int[][] graph) {
        int n = graph.length;
        int[][][] status = new int[n][n][3];
        Queue<Status> queue = new LinkedList<>();
        
        for (int i = 1; i < n; ++i) {
            Arrays.fill(status[i][i], 2);
            queue.add(new Status(i, i, 2, 2));
            queue.add(new Status(i, i, 1, 2));
        }

        while (!queue.isEmpty()) {
            Status t = queue.poll();
            int pos_m = t.mouse, pos_c = t.cat, t_type = t.type, t_result = t.result;
            
            for (int prev : t_type == 1 ? graph[pos_m] : graph[pos_c]) {
                if (t_type == 2 && prev == 0 || t_result == 2 && status[prev][pos_c][3 - t_type] != 0) continue;
                if (status[prev][pos_c][3 - t_type] != 0) continue;
                queue.add(new Status(pos_c, prev, 3 - t_type, 3 - t_result));
                status[prev][pos_c][3 - t_type] = 3 - t_result;
            }
        }
        return status[1][2][1];
    }

    private class Status {
        int mouse, cat, type, result;
        Status(int mouse, int cat, int type, int result) {
            this.mouse = mouse;
            this.cat = cat;
            this.type = type;
            this.result = result;
        }
    }
}


-----
import java.util.*;

class Solution 
    // Your code here
}


************************************
Question ID: 950

import java.util.HashMap;
import java.util.Map;

class Solution {
    public boolean hasGroupsSizeX(int[] deck) {
        HashMap<Integer, Integer> counts = new HashMap<>();
        for (int card : deck) {
            counts.put(card, counts.getOrDefault(card, 0) + 1);
        }
        int gcd_result = 0;
        for (Map.Entry<Integer, Integer> count : counts.entrySet()) {
            gcd_result = gcd(gcd_result, count.getValue());
        }
        return gcd_result > 1;
    }
    private int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
}

-----
import java.util.HashMap;
import java.util.Map;

class Solution 
    // Your code here
}

************************************
Question ID: 951

public int partitionDisjoint(int[] nums) {
    int leftMax = nums[0], globalMax = nums[0], leftLength = 1;
    for (int i = 1; i < nums.length; ++i) {
        if (nums[i] < leftMax) {
            leftMax = globalMax;
            leftLength = i + 1;
        } else {
            globalMax = Math.max(globalMax, nums[i]);
        }
    }
    return leftLength;
}

-----
public int partitionDisjoint(int[] nums) 
    // Your code here
}

************************************
Question ID: 952

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public List<String> wordSubsets(String[] words1, String[] words2) {
    Map<Character, Integer> maxChars = new HashMap<>();
    for (String word : words2) {
        Map<Character, Integer> chars = new HashMap<>();
        for (char c : word.toCharArray()) {
            chars.put(c, chars.getOrDefault(c, 0) + 1);
        }
        for (Map.Entry<Character, Integer> entry : chars.entrySet()) {
            maxChars.put(entry.getKey(), Math.max(maxChars.getOrDefault(entry.getKey(), 0), entry.getValue()));
        }
    }

    List<String> result = new ArrayList<>();
    for (String word : words1) {
        Map<Character, Integer> wordChars = new HashMap<>();
        for (char c : word.toCharArray()) {
            wordChars.put(c, wordChars.getOrDefault(c, 0) + 1);
        }

        boolean universal = true;
        for (Map.Entry<Character, Integer> entry : maxChars.entrySet()) {
            if (wordChars.getOrDefault(entry.getKey(), 0) < entry.getValue()) {
                universal = false;
                break;
            }
        }

        if (universal) {
            result.add(word);
        }
    }

    return result;
}


-----
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public List<String> wordSubsets(String[] words1, String[] words2) 
    // Your code here
}


************************************
Question ID: 953

public String reverseString(String s) {
    StringBuilder result = new StringBuilder(s);
    return result.reverse().toString();
}


-----
public String reverseString(String s) 
    // Your code here
}


************************************
Question ID: 954

public boolean canReorderDoubled(int[] arr) {
    Map<Integer, Integer> count = new TreeMap<>();
    for (int a : arr) {
        count.put(a, count.getOrDefault(a, 0) + 1);
    }
    
    for (int a : count.keySet()) {
        if (count.get(a) > 0) {
            int target = a < 0 ? a / 2 : a * 2;
            if (count.getOrDefault(target, 0) < count.get(a)) return false;
            count.put(target, count.get(target) - count.get(a));
        }
    }

    return true;
}

-----
public boolean canReorderDoubled(int[] arr) 
    // Your code here
}

************************************
Question ID: 955

import java.util.LinkedList;
import java.util.Queue;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

class CBTInserter {
    TreeNode root;
    Queue<TreeNode> q;

    public CBTInserter(TreeNode root) {
        this.root = root;
        q = new LinkedList<>();
        q.add(root);
        while (true) {
            TreeNode node = q.peek();
            if (node.left == null || node.right == null) break;
            q.add(node.left);
            q.add(node.right);
            q.poll();
        }
    }

    public int insert(int v) {
        TreeNode newNode = new TreeNode(v);
        TreeNode parentNode = q.peek();
        if (parentNode.left == null) {
            parentNode.left = newNode;
        } else {
            parentNode.right = newNode;
            q.add(parentNode.left);
            q.add(parentNode.right);
            q.poll();
        }
        return parentNode.val;
    }

    public TreeNode get_root() {
        return root;
    }
}


-----
import java.util.LinkedList;
import java.util.Queue;

class TreeNode 
    // Your code here
}


************************************
Question ID: 956

public int numMusicPlaylists(int n, int goal, int k) {
    long MOD = 1000000007;
    long[][] dp = new long[goal + 1][n + 1];
    dp[0][0] = 1;
    for (int i = 1; i <= goal; i++) {
        for (int j = 1; j <= n; j++) {
            dp[i][j] = (dp[i - 1][j - 1] * (n - (j - 1)) % MOD + dp[i - 1][j] * Math.max(0, j - k) % MOD) % MOD;
        }
    }
    return (int) dp[goal][n];
}

-----
public int numMusicPlaylists(int n, int goal, int k) 
    // Your code here
}

************************************
Question ID: 957

public int minAddToMakeValid(String s) {
    int result = 0, balance = 0;
    for (char c : s.toCharArray()) {
        balance += (c == '(') ? 1 : -1;
        if (balance == -1) {
            result++;
            balance++;
        }
    }
    return result + balance;
}

-----
public int minAddToMakeValid(String s) 
    // Your code here
}

************************************
Question ID: 958

public int[] sortArrayByParityII(int[] nums) {
    int j = 1;
    for (int i = 0; i < nums.length; i += 2) {
        if (nums[i] % 2 != 0) {
            while (nums[j] % 2 != 0) {
                j += 2;
            }
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
    }
    return nums;
}

-----
public int[] sortArrayByParityII(int[] nums) 
    // Your code here
}

************************************
Question ID: 959

import java.util.Arrays;

public int threeSumMulti(int[] arr, int target) {
    int MOD = 1000000007;
    long ans = 0;

    Arrays.sort(arr);
    int n = arr.length;

    for (int i = 0; i < n - 2; ++i) {
        int j = i + 1, k = n - 1;
        while (j < k) {
            int sum = arr[i] + arr[j] + arr[k];
            if (sum > target) {
                k--;
            } else if (sum < target) {
                j++;
            } else {
                if (arr[j] != arr[k]) {
                    int left_count = 1, right_count = 1;

                    while (j < n-1 && arr[j] == arr[j + 1]){
                        left_count++; 
                        j++;
                    }
                    while (k > 0 && arr[k] == arr[k - 1]){
                        right_count++;
                        k--;
                    }

                    ans += (long) left_count * right_count;
                    ans %= MOD;
                    j++; k--;
                } else {
                    ans += (long) (k - j + 1) * (k - j) / 2;
                    ans %= MOD;
                    break;
                }
            }
        }
    }

    return (int) ans;
}

-----
import java.util.Arrays;

public int threeSumMulti(int[] arr, int target) 
    // Your code here
}

************************************
Question ID: 960

import java.util.*;

class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        Arrays.sort(initial);
        
        Set<Integer> malware = new HashSet<>();
        for (int i : initial) {
            malware.add(i);
        }
        
        int minNode = initial[0], minSpread = n + 1;
        for (int node : initial) {
            Queue<Integer> q = new LinkedList<>();
            boolean[] visited = new boolean[n];
            
            for (int otherNode : initial) {
                if (node != otherNode) {
                    q.offer(otherNode);
                    visited[otherNode] = true;
                }
            }

            while (!q.isEmpty()) {
                int cur = q.poll();
                for (int next = 0; next < n; ++next) {
                    if (graph[cur][next] == 1 && !visited[next] && !malware.contains(next)) {
                        visited[next] = true;
                        q.offer(next);
                    }
                }
            }
            
            int spread = 0;
            for (boolean v : visited) {
                spread += v ? 1 : 0;
            }

            if (spread < minSpread) {
                minNode = node;
                minSpread = spread;
            }
        }
        
        return minNode;
    }
}


-----
import java.util.*;

class Solution 
    // Your code here
}


************************************
Question ID: 961

boolean isLongPressedName(String name, String typed) {
    int i = 0, j = 0;
    while (j < typed.length()) {
        if (i < name.length() && name.charAt(i) == typed.charAt(j)) {
            i++;
        } else if (j == 0 || typed.charAt(j) != typed.charAt(j - 1)) {
            return false;
        }
        j++;
    }
    return i == name.length();
}

-----
boolean isLongPressedName(String name, String typed) 
    // Your code here
}

************************************
Question ID: 962

public int minFlipsMonoIncr(String s) {
    int flipCount = 0, oneCount = 0;
    for (char c : s.toCharArray()) {
        if (c == '1') {
            oneCount++;
        } else {
            flipCount = Math.min(flipCount + 1, oneCount);
        }
    }
    return flipCount;
}

-----
public int minFlipsMonoIncr(String s) 
    // Your code here
}

************************************
Question ID: 963

import java.util.Arrays;

public int[] findSameBinaryValueParts(int[] arr) {
    int ones = 0;
    for (int n : arr) ones += n;

    if (ones % 3 != 0) return new int[]{-1, -1};

    int target = ones / 3;
    if (target == 0) return new int[]{0, arr.length - 2};

    int count = 0, i = -1, j = -1;
    ones = 0;
    for (int idx = 0; idx < arr.length; ++idx) {
        if (arr[idx] == 1) {
            ones++;
            if (ones == target + 1) count++;
            if (count == 1 && i == -1) i = idx;
            if (count == 2 && j == -1) j = idx;
            if (count == 3) break;
        }
    }

    return new int[]{i, j};
}

-----
import java.util.Arrays;

public int[] findSameBinaryValueParts(int[] arr) 
    // Your code here
}

************************************
Question ID: 964

import java.util.*;

class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length, res = 0, minSize = Integer.MAX_VALUE;
        int[] color = new int[n];
        Arrays.fill(color, -1);
        int colors = 0;

        for (int i = 0; i < n; ++i) {
            if (color[i] == -1) {
                Queue<Integer> q = new LinkedList<>();
                q.offer(i);
                color[i] = colors;

                while (!q.isEmpty()) {
                    int t = q.poll();
                    for (int j = 0; j < n; ++j) {
                        if (graph[t][j] == 1 && color[j] == -1) {
                            q.offer(j);
                            color[j] = colors;
                        }
                    }
                }
                ++colors;
            }
        }

        int[] area = new int[colors], count = new int[colors];
        Set<Integer> initiallyInfected = new HashSet<>();
        for (int i : initial) {
            initiallyInfected.add(i);
        }
        for (int i = 0; i < n; ++i) {
            ++area[color[i]];
            if (initiallyInfected.contains(i)) {
                ++count[color[i]];
            }
        }

        for (int i : initial) {
            if (count[color[i]] == 1) {
                if (area[color[i]] < minSize) {
                    minSize = area[color[i]];
                    res = i;
                } else if (area[color[i]] == minSize && i < res) {
                    res = i;
                }
            }
        }

        return res;
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 965

import java.util.HashSet;
import java.util.Set;

public int numUniqueEmails(String[] emails) {
    Set<String> unique_emails = new HashSet<>();

    for (String email : emails) {
        String[] parts = email.split("@");
        String local_name = parts[0], domain_name = parts[1];

        local_name = local_name.replaceAll("\\+", "@").split("@")[0];
        local_name = local_name.replaceAll("\\.", "");

        unique_emails.add(local_name + "@" + domain_name);
    }

    return unique_emails.size();
}

-----
import java.util.HashSet;
import java.util.Set;

public int numUniqueEmails(String[] emails) 
    // Your code here
}

************************************
Question ID: 966

import java.util.HashMap;

public int numSubarraysWithSum(int[] nums, int goal) {
    HashMap<Integer, Integer> prefixSumCount = new HashMap<>();
    prefixSumCount.put(0, 1);
    int sum = 0, result = 0;
    
    for (int num : nums) {
        sum += num;
        result += prefixSumCount.getOrDefault(sum - goal, 0);
        prefixSumCount.put(sum, prefixSumCount.getOrDefault(sum, 0) + 1);
    }
    
    return result;
}

-----
import java.util.HashMap;

public int numSubarraysWithSum(int[] nums, int goal) 
    // Your code here
}

************************************
Question ID: 967

public int minFallingPathSum(int[][] matrix) {
    int n = matrix.length;
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            int min_val = matrix[i - 1][j];
            if (j > 0) min_val = Math.min(min_val, matrix[i - 1][j - 1]);
            if (j < n - 1) min_val = Math.min(min_val, matrix[i - 1][j + 1]);
            matrix[i][j] += min_val;
        }
    }
    return Arrays.stream(matrix[n - 1]).min().getAsInt();
}

-----
public int minFallingPathSum(int[][] matrix) 
    // Your code here
}

************************************
Question ID: 968

public int[] beautifulArray(int n) {
    List<Integer> result = new ArrayList<>();
    result.add(1);
    while (result.size() < n) {
        List<Integer> temp = new ArrayList<>();
        for (int i : result) {
            if (i * 2 - 1 <= n)
                temp.add(i * 2 - 1);
        }
        for (int i : result) {
            if (i * 2 <= n)
                temp.add(i * 2);
        }
        result = temp;
    }
    return result.stream().mapToInt(i->i).toArray();
}

-----
public int[] beautifulArray(int n) 
    // Your code here
}

************************************
Question ID: 969

import java.util.LinkedList;
import java.util.Queue;

class RecentCounter {
    Queue<Integer> requests;

    public RecentCounter() {
        requests = new LinkedList<>();
    }

    public int ping(int t) {
        requests.add(t);
        while (requests.peek() < t - 3000) {
            requests.poll();
        }
        return requests.size();
    }
}

-----
import java.util.LinkedList;
import java.util.Queue;

class RecentCounter 
    // Your code here
}

************************************
Question ID: 970

import java.util.HashSet;
import java.util.ArrayList;
import java.util.List;

public List<Integer> powerfulIntegers(int x, int y, int bound) {
    int max_i = x == 1 ? 0 : (int) (Math.log(bound) / Math.log(x));
    int max_j = y == 1 ? 0 : (int) (Math.log(bound) / Math.log(y));
    HashSet<Integer> resultSet = new HashSet<>();
    
    for (int i = 0; i <= max_i; i++) {
        for (int j = 0; j <= max_j; j++) {
            int powerfulNum = (int) (Math.pow(x, i) + Math.pow(y, j));
            if (powerfulNum <= bound) {
                resultSet.add(powerfulNum);
            }
        }
    }
    
    return new ArrayList<>(resultSet);
}

-----
import java.util.HashSet;
import java.util.ArrayList;
import java.util.List;

public List<Integer> powerfulIntegers(int x, int y, int bound) 
    // Your code here
}

************************************
Question ID: 971

import java.util.*;

public int shortestBridge(int[][] grid) {
    int n = grid.length;
    Queue<int[]> q = new LinkedList<>();
    boolean[][] visited = new boolean[n][n];
    boolean found = false;

    for (int i = 0; i < n && !found; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 1) {
                dfs(grid, q, visited, i, j);
                found = true;
                break;
            }
        }
    }

    int steps = 0;
    int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

    while (!q.isEmpty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            int[] coord = q.poll();
            for (int[] d : dirs) {
                int newx = coord[0] + d[0];
                int newy = coord[1] + d[1];

                if (newx >= 0 && newx < n && newy >= 0 && newy < n && !visited[newx][newy]) {
                    if (grid[newx][newy] == 1) return steps;
                    visited[newx][newy] = true;
                    q.add(new int[]{newx, newy});
                }
            }
        }
        steps++;
    }

    return -1;
}

private void dfs(int[][] grid, Queue<int[]> q, boolean[][] visited, int x, int y) {
    int n = grid.length;

    if (x < 0 || x >= n || y < 0 || y >= n || visited[x][y] || grid[x][y] == 0) return;

    visited[x][y] = true;
    q.add(new int[]{x, y});
    dfs(grid, q, visited, x - 1, y);
    dfs(grid, q, visited, x + 1, y);
    dfs(grid, q, visited, x, y - 1);
    dfs(grid, q, visited, x, y + 1);
}


-----
import java.util.*;

public int shortestBridge(int[][] grid) 
    // Your code here
}


************************************
Question ID: 972

public int knightDialer(int n) {
    if (n == 1) return 10;
    final int MOD = 1000000007;
    int[][] moves = {
        {4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9},
        {}, {1, 7, 0}, {2, 6}, {1, 3}, {2, 4}
    };
    int[] dp = new int[10];
    Arrays.fill(dp, 1);
    for (int i = 2; i <= n; ++i) {
        int[] new_dp = new int[10];
        for (int j = 0; j < 10; ++j)
            for (int move : moves[j])
                new_dp[j] = (new_dp[j] + dp[move]) % MOD;
        dp = new_dp;
    }
    return Arrays.stream(dp).reduce(0, (a, b) -> (a + b) % MOD);
}

-----
public int knightDialer(int n) 
    // Your code here
}

************************************
Question ID: 973

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public List<Integer> movesToStamp(String stamp, String target) {
    List<Integer> result = new ArrayList<>();
    boolean[] isStamped = new boolean[target.length()];
    int stampCount = 0;
    StringBuilder targetStr = new StringBuilder(target);
    
    while (stampCount < 10 * target.length()) {
        boolean foundStamp = false;
        for (int i = 0; i <= target.length() - stamp.length(); ++i) {
            if (isStamped[i]) continue;
            int j = 0;
            int overlap = 0;
            while (j < stamp.length() && (targetStr.charAt(i + j) == '?' || targetStr.charAt(i + j) == stamp.charAt(j))) {
                if (targetStr.charAt(i + j) == stamp.charAt(j)) overlap++;
                j++;
            }
            if (j == stamp.length() && overlap > 0) {
                for (j = 0; j < stamp.length(); ++j)
                    targetStr.setCharAt(i + j, '?');
                result.add(i);
                isStamped[i] = true;
                foundStamp = true;
            }
        }
        if (!foundStamp)
            break;
        
        stampCount++;
    }
    for (char c : targetStr.toString().toCharArray())
        if (c != '?') return List.of();
    
    Collections.reverse(result);
    return result;
}


-----
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public List<Integer> movesToStamp(String stamp, String target) 
    // Your code here
}


************************************
Question ID: 974

public int subarraysDivByK(int[] nums, int k) {
    int[] prefixSumsModK = new int[k];
    prefixSumsModK[0] = 1;
    int runningSum = 0;
    int count = 0;
    
    for (int i = 0; i < nums.length; ++i) {
        runningSum += nums[i];
        int mod = (runningSum % k + k) % k;
        count += prefixSumsModK[mod]++;
    }
    
    return count;
}

-----
public int subarraysDivByK(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 975

public int rangeSumBST(TreeNode root, int low, int high) {
    if (root == null) return 0;
    if (root.val < low) return rangeSumBST(root.right, low, high);
    if (root.val > high) return rangeSumBST(root.left, low, high);
    return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);
}

-----
public int rangeSumBST(TreeNode root, int low, int high) 
    // Your code here
}

************************************
Question ID: 976

import java.util.*;

class Solution {
    public int minAreaRect(int[][] points) {
        Set<Pair<Integer, Integer>> pointSet = new HashSet<>();
        for (int[] point : points) {
            pointSet.add(new Pair<>(point[0], point[1]));
        }

        int minArea = Integer.MAX_VALUE;
        for (int[] p1 : points) {
            for (int[] p2 : points) {
                if (p1[0] != p2[0] && p1[1] != p2[1]) {
                    if (pointSet.contains(new Pair<>(p1[0], p2[1])) && pointSet.contains(new Pair<>(p2[0], p1[1]))) {
                        minArea = Math.min(minArea, Math.abs((p1[0] - p2[0]) * (p1[1] - p2[1])));
                    }
                }
            }
        }

        return minArea == Integer.MAX_VALUE ? 0 : minArea;
    }
}


-----
import java.util.*;

class Solution 
    // Your code here
}


************************************
Question ID: 977

public int distinctSubseqII(String s) {
    int mod = (int) (1e9 + 7);
    int n = s.length();
    int[] dp = new int[n + 1];
    dp[0] = 1;
    int[] last = new int[26];
    Arrays.fill(last, -1);

    for (int i = 1; i <= n; ++i) {
        dp[i] = (dp[i - 1] * 2) % mod;
        if (last[s.charAt(i - 1) - 'a'] != -1) {
            dp[i] = (dp[i] - dp[last[s.charAt(i - 1) - 'a']] + mod) % mod;
        }
        last[s.charAt(i - 1) - 'a'] = i - 1;
    }

    dp[n] = (dp[n] - 1 + mod) % mod;
    return dp[n];
}

-----
public int distinctSubseqII(String s) 
    // Your code here
}

************************************
Question ID: 978

boolean validMountainArray(int[] arr) {
    int n = arr.length, i = 0, j = n - 1;
    while (i + 1 < n && arr[i] < arr[i + 1]) i++;
    while (j > 0 && arr[j - 1] > arr[j]) j--;
    return i > 0 && i == j && j < n - 1;
}

-----
boolean validMountainArray(int[] arr) 
    // Your code here
}

************************************
Question ID: 979

public int[] decode_permutation(String s) {
    int n = s.length();
    int[] perm = new int[n + 1];
    int next_zero = 0, next_one = n;

    for (char c : s.toCharArray()) {
        if (c == '0') {
            perm[next_zero++] = next_one--;
        } else {
            perm[next_one--] = next_zero++;
        }
    }
    perm[next_zero] = next_one;
    return perm;
}


-----
public int[] decode_permutation(String s) 
    // Your code here
}


************************************
Question ID: 980

import java.util.List;
import java.util.ArrayList;

public String smallestSuperstring(String[] words) {
    List<String> wordList = new ArrayList<>();
    for (String word : words) {
        wordList.add(word);
    }

    while (wordList.size() > 1) {
        int maxLength = -1, p1 = 0, p2 = 0;
        String temp = "";
        for (int i = 0; i < wordList.size(); ++i) {
            for (int j = i + 1; j < wordList.size(); ++j) {
                int sharedLength = Math.min(wordList.get(i).length(), wordList.get(j).length());
                for (; sharedLength > maxLength; --sharedLength) {
                    if (wordList.get(i).endsWith(wordList.get(j).substring(0, sharedLength))) {
                        maxLength = sharedLength;
                        p1 = i;
                        p2 = j;
                        temp = wordList.get(i) + wordList.get(j).substring(sharedLength);
                        break;
                    }
                }
            }
        }
        wordList.set(p1, temp);
        wordList.remove(p2);
    }
    return wordList.get(0);
}

-----
import java.util.List;
import java.util.ArrayList;

public String smallestSuperstring(String[] words) 
    // Your code here
}

************************************
Question ID: 981

public int minDeletionSize(String[] strs) {
    int numDeleted = 0;
    for (int col = 0; col < strs[0].length(); col++) {
        for (int row = 1; row < strs.length; row++) {
            if (strs[row].charAt(col) < strs[row - 1].charAt(col)) {
                numDeleted++;
                break;
            }
        }
    }
    return numDeleted;
}


-----
public int minDeletionSize(String[] strs) 
    // Your code here
}


************************************
Question ID: 982

import java.util.Arrays;

public int minMovesUnique(int[] nums) {
    Arrays.sort(nums);
    int moves = 0;
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] <= nums[i - 1]) {
            moves += nums[i - 1] - nums[i] + 1;
            nums[i] = nums[i - 1] + 1;
        }
    }
    return moves;
}

-----
import java.util.Arrays;

public int minMovesUnique(int[] nums) 
    // Your code here
}

************************************
Question ID: 983

import java.util.Stack;

public boolean validateStackSequences(int[] pushed, int[] popped) {
    Stack<Integer> stack = new Stack<>();
    int popIndex = 0;
    
    for (int pushValue : pushed) {
        stack.push(pushValue);
        while (!stack.isEmpty() && stack.peek() == popped[popIndex]) {
            stack.pop();
            popIndex++;
        }
    }
    
    return stack.isEmpty();
}


-----
import java.util.Stack;

public boolean validateStackSequences(int[] pushed, int[] popped) 
    // Your code here
}


************************************
Question ID: 984

import java.util.*;

class Solution {
    public int removeStones(int[][] stones) {
        int n = stones.length;
        Map<Integer, Integer> row_groups = new HashMap<>();
        Map<Integer, Integer> col_groups = new HashMap<>();
        int group_count = 0;

        int[][] groups = new int[n * 2][n];
        int[] group_sizes = new int[n * 2];

        for (int i = 0; i < n; i++) {
            int x = stones[i][0], y = stones[i][1];
            int groupId_x = row_groups.computeIfAbsent(x, (key) -> group_count++);
            int groupId_y = col_groups.computeIfAbsent(y + 10001, (key) -> group_count++); // Offset by max row index

            groups[groupId_x][group_sizes[groupId_x]++] = groupId_y;
            groups[groupId_y][group_sizes[groupId_y]++] = groupId_x;
        }

        boolean[] visited = new boolean[group_count];

        int max_stones = 0;
        for (int groupId = 0; groupId < group_count; groupId++) {
            if (!visited[groupId]) {
                Stack<Integer> stack = new Stack<>();
                stack.push(groupId);
                visited[groupId] = true;
                int size = 0;

                while (!stack.isEmpty()) {
                    int curr = stack.pop();
                    size++;
                    for (int i = 0; i < group_sizes[curr]; i++) {
                        int neighbor = groups[curr][i];
                        if (!visited[neighbor]) {
                            stack.push(neighbor);
                            visited[neighbor] = true;
                        }
                    }
                }

                max_stones += size - 1;
            }
        }

        return max_stones;
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 985

import java.util.Arrays;

public int bagOfTokensScore(int[] tokens, int power) {
    Arrays.sort(tokens);
    int score = 0, maxScore = 0;
    int left = 0, right = tokens.length - 1;

    while (left <= right) {
        if (power >= tokens[left]) {
            power -= tokens[left++];
            score++;
            maxScore = Math.max(maxScore, score);
        } else if (score > 0) {
            power += tokens[right--];
            score--;
        } else {
            break;
        }
    }
    return maxScore;
}

-----
import java.util.Arrays;

public int bagOfTokensScore(int[] tokens, int power) 
    // Your code here
}

************************************
Question ID: 986

import java.util.Arrays;

public String largestTimeFromDigits(int[] A) {
    Arrays.sort(A);
    for (int i = 3; i >= 0; i--) {
        if (A[i] <= 2) {
            for (int j = 3; j >= 0; j--) {
                if ((A[i] != 2 || A[j] <= 3) && A[j] != A[i]) {
                    for (int k = 3; k >= 0; k--) {
                        if (A[k] <= 5 && A[k] != A[i] && A[k] != A[j]) {
                            int l = 6 - i - j - k;
                            return String.format("%d%d:%d%d", A[i], A[j], A[k], A[l]);
                        }
                    }
                }
            }
        }
    }
    return "";
}

-----
import java.util.Arrays;

public String largestTimeFromDigits(int[] A) 
    // Your code here
}

************************************
Question ID: 987

import java.util.*;

public int[] deckRevealedIncreasing(int[] deck) {
    int n = deck.length;
    Queue<Integer> index = new LinkedList<>();
    for (int i = 0; i < n; i++)
        index.add(i);

    int[] ans = new int[n];
    Arrays.sort(deck);
    for (int card : deck) {
        ans[index.poll()] = card;
        if (!index.isEmpty()) {
            index.add(index.poll());
        }
    }
    return ans;
}

-----
import java.util.*;

public int[] deckRevealedIncreasing(int[] deck) 
    // Your code here
}

************************************
Question ID: 989

import java.util.*;

class Solution {
    public int largestComponentSize(int[] nums) {
        int count = 0;
        Map<Integer, Set<Integer>> graph = new HashMap<>();
        Set<Integer> visited = new HashSet<>();

        for (int num : nums) {
            int prime = primes(num);
            graph.computeIfAbsent(prime, k -> new HashSet<>()).add(num);
            if (num != prime) graph.computeIfAbsent(num, k -> new HashSet<>()).add(prime);
        }

        for (int num : nums) {
            count = Math.max(count, dfs(num, visited, graph));
        }
        return count;
    }

    private int dfs(int node, Set<Integer> visited, Map<Integer, Set<Integer>> graph) {
        if (!visited.add(node)) return 0;
        int res = 1;
        for (int neighbor : graph.getOrDefault(node, Collections.emptySet())) {
            res += dfs(neighbor, visited, graph);
        }
        return res;
    }

    private int primes(int n) {
        for (int i = 2; i * i <= n; ++i) {
            if (n % i == 0) return i;
        }
        return n;
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 990

public boolean isAlienSorted(String[] words, String order) {
    int[] alien_order = new int[26];
    for (int i = 0; i < 26; i++) {
        alien_order[order.charAt(i) - 'a'] = i;
    }

    for (int i = 1; i < words.length; i++) {
        for (int j = 0; j < words[i - 1].length(); j++) {
            if (j == words[i].length()) {
                return false;
            }

            if (words[i - 1].charAt(j) != words[i].charAt(j)) {
                if (alien_order[words[i - 1].charAt(j) - 'a'] > alien_order[words[i].charAt(j) - 'a']) {
                    return false;
                }
                break;
            }
        }
    }

    return true;
}

-----
public boolean isAlienSorted(String[] words, String order) 
    // Your code here
}

************************************
Question ID: 991

import java.util.Arrays;
import java.util.HashMap;

public boolean canReorderArray(int[] arr) {
    HashMap<Integer, Integer> count = new HashMap<>();
    for (int n : arr) {
        count.put(n, count.getOrDefault(n, 0) + 1);
    }
    Arrays.sort(arr);
    for (int x : arr) {
        if (count.get(x) == 0) {
            continue;
        }
        if (count.getOrDefault(2 * x, 0) > 0) {
            count.put(x, count.get(x) - 1);
            count.put(2 * x, count.get(2 * x) - 1);
        } else {
            return false;
        }
    }
    return true;
}

-----
import java.util.Arrays;
import java.util.HashMap;

public boolean canReorderArray(int[] arr) 
    // Your code here
}

************************************
Question ID: 993

public int tallestBillboard(int[] rods) {
    int n = rods.length;
    int totalLength = Arrays.stream(rods).sum();
    int[][] dp = new int[n + 1][totalLength + 1];
    for (int i = 0; i < n + 1; i++) {
        Arrays.fill(dp[i], -1);
    }
    dp[0][0] = 0;
    
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= totalLength; j++) {
            dp[i][j] = dp[i - 1][j];
            if (rods[i - 1] <= j) dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - rods[i - 1]] + rods[i - 1]);
            if (rods[i - 1] <= totalLength - j) dp[i][j] = Math.max(dp[i][j], dp[i - 1][j + rods[i - 1]]);
        }
    }
    
    return dp[n][0] / 2;
}


-----
public int tallestBillboard(int[] rods) 
    // Your code here
}


************************************
Question ID: 994

public int[] prisonAfterNDays(int[] cells, int n) {
    int[] temp = new int[8];
    n = n % 14 == 0 ? 14 : n % 14; // Pattern repeats every 14 days

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j < 7; ++j) {
            temp[j] = cells[j - 1] == cells[j + 1] ? 1 : 0;
        }
        cells = temp.clone();
    }

    return cells;
}

-----
public int[] prisonAfterNDays(int[] cells, int n) 
    // Your code here
}

************************************
Question ID: 995

public int minKBitFlips(int[] nums, int k) {
    int n = nums.length;
    int[] flipped = new int[n];
    int flips = 0, ans = 0;
    for (int i = 0; i < n; ++i) {
        if (i >= k) flips -= flipped[i - k];
        if ((flips + nums[i]) % 2 == 0) {
            if (i + k > n) return -1;
            flipped[i] = 1;
            flips++;
            ans++;
        }
    }
    return ans;
}

-----
public int minKBitFlips(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 996

import java.util.HashMap;
import java.util.Map;

public int numSquarefulPerms(int[] nums) {
    Map<Integer, Integer> counter = new HashMap<>();
    for (int num : nums)
        counter.put(num, counter.getOrDefault(num, 0) + 1);

    return dfs(nums, 0, counter);
}

private boolean isSquare(int n) {
    int root = (int) Math.sqrt(n);
    return root * root == n;
}

private int dfs(int[] nums, int idx, Map<Integer, Integer> counter) {
    if (idx == nums.length)
        return 1;

    int count = 0;
    for (int key : counter.keySet()) {
        if (counter.get(key) != 0 && (idx == 0 || isSquare(nums[idx - 1] + key))) {
            counter.put(key, counter.get(key) - 1);
            nums[idx] = key;
            count += dfs(nums, idx + 1, counter);
            counter.put(key, counter.get(key) + 1);
        }
    }

    return count;
}


-----
import java.util.HashMap;
import java.util.Map;

public int numSquarefulPerms(int[] nums) 
    // Your code here
}


************************************
Question ID: 997

public int findJudge(int n, int[][] trust) {
    int[] trustCounts = new int[n + 1];
    for (int[] t : trust) {
        trustCounts[t[0]]--;
        trustCounts[t[1]]++;
    }
    for (int i = 1; i <= n; i++) {
        if (trustCounts[i] == n - 1)
            return i;
    }
    return -1;
}

-----
public int findJudge(int n, int[][] trust) 
    // Your code here
}

************************************
Question ID: 999

public int regionsBySlashes(String[] grid) {
    int n = grid.length;
    int[][] graph = new int[n * 3][n * 3];

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i].charAt(j) == '/') {
                graph[i * 3][j * 3 + 2] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3] = 1;
            }
            if (grid[i].charAt(j) == '\\') {
                graph[i * 3][j * 3] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3 + 2] = 1;
            }
        }
    }

    int regions = 0;
    for (int i = 0; i < n * 3; i++) {
        for (int j = 0; j < n * 3; j++) {
            if (graph[i][j] == 0) {
                regions++;
                dfs(graph, i, j);
            }
        }
    }

    return regions;
}

private void dfs(int[][] graph, int i, int j) {
    int n = graph.length;
    if (i < 0 || j < 0 || i >= n || j >= n || graph[i][j] == 1) return;

    graph[i][j] = 1;
    dfs(graph, i - 1, j);
    dfs(graph, i + 1, j);
    dfs(graph, i, j - 1);
    dfs(graph, i, j + 1);
}

-----
public int regionsBySlashes(String[] grid) 
    // Your code here
}

************************************
Question ID: 1000

public int minDeletionSize(String[] strs) {
    int rows = strs.length, cols = strs[0].length();
    int count = 0;
    for (int c = 0; c < cols; ++c) {
        for (int r = 1; r < rows; ++r) {
            if (strs[r - 1].charAt(c) > strs[r].charAt(c)) {
                ++count;
                break;
            }
        }
    }
    return count;
}


-----
public int minDeletionSize(String[] strs) 
    // Your code here
}


************************************
Question ID: 1001

public int repeatedNTimes(int[] nums) {
    Map<Integer, Integer> hashMap = new HashMap<>();
    for (int num : nums) {
        hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);
        if (hashMap.get(num) > 1) return num;
    }
    return -1;
}


-----
public int repeatedNTimes(int[] nums) 
    // Your code here
}


************************************
Question ID: 1002


```java
import java.util.*;

public int maxWidthRamp(int[] nums) {
    Integer[] indices = new Integer[nums.length];
    for (int i = 0; i < nums.length; i++) {
        indices[i] = i;
    }
    
    Arrays.sort(indices, (i, j) -> nums[i] == nums[j] ? i - j : nums[i] - nums[j]);
    
    int maxWidth = 0;
    int minIndex = Integer.MAX_VALUE;
    for (int index : indices) {
        maxWidth = Math.max(maxWidth, index - minIndex);
        minIndex = Math.min(minIndex, index);
    }
    
    return maxWidth;
}
```


-----

```java
import java.util.*;

public int maxWidthRamp(int[] nums) 
    // Your code here
}
```


************************************
Question ID: 1003

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public double minAreaFreeRect(int[][] points) {
    double minArea = Double.POSITIVE_INFINITY;
    Map<Integer, Set<Integer>> xGroups = new HashMap<>();

    for (int[] point : points) {
        xGroups.computeIfAbsent(point[0], k -> new HashSet<>()).add(point[1]);
    }

    for (Map.Entry<Integer, Set<Integer>> x1Entry : xGroups.entrySet()) {
        for (Map.Entry<Integer, Set<Integer>> x2Entry : xGroups.entrySet()) {
            int x1 = x1Entry.getKey(), x2 = x2Entry.getKey();
            if (x1 == x2) continue;

            Set<Integer> ys1 = x1Entry.getValue(), ys2 = x2Entry.getValue();
            for (int y1 : ys1) {
                for (int y2 : ys2) {
                    if (ys1.contains(y2) && ys2.contains(y1)) {
                        double area = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)) * Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y1, 2));
                        minArea = Math.min(minArea, area);
                    }
                }
            }
        }
    }
    
    return minArea == Double.POSITIVE_INFINITY ? 0 : minArea;
}


-----
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public double minAreaFreeRect(int[][] points) 
    // Your code here
}


************************************
Question ID: 1004

public int leastOpsExpressTarget(int x, int target) {
    if (x == target) return 0;
    if (target == 1) return 1;
    if (x > target) return Math.min(2 * target - 1, 2 * (x - target));
    
    int k = 0;
    long p = x;
    while (p < target) {
        k++;
        p *= x;
    }
    
    int ans = Integer.MAX_VALUE;
    long d = 1;

    for (int i = k - 1; i >= 0; i--) {
        while (p >= target + d * (1 - x)) {
            p -= d;
            ans = Math.min(ans, i + (int) (Math.log(target / d) / Math.log(2) + 1) + (int) (d == 1 ? -1 : 0));
        }
        d = d * x + 1;
    }

    return ans;
}


-----
public int leastOpsExpressTarget(int x, int target) 
    // Your code here
}


************************************
Question ID: 1005

public boolean isUnivalued(TreeNode root) {
    return isUnivalued(root, -1);
}

private boolean isUnivalued(TreeNode root, int val) {
    if (root == null) return true;
    if (val == -1) val = root.val;
    return root.val == val && isUnivalued(root.left, val) && isUnivalued(root.right, val);
}

-----
public boolean isUnivalued(TreeNode root) 
    // Your code here
}

************************************
Question ID: 1006

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public List<String> spellchecker(String[] wordlist, String[] queries) {
    Map<String, String> wordMap = new HashMap<>();
    Map<String, String> wordMapLowerCase = new HashMap<>();
    Map<String, String> wordMapVowelReplaced = new HashMap<>();
    
    for (String word : wordlist) {
        String lowerWord = word.toLowerCase();
        String vowelReplacedWord = lowerWord.replaceAll("[aeiou]", "#");

        wordMap.putIfAbsent(word, word);
        wordMapLowerCase.putIfAbsent(lowerWord, word);
        wordMapVowelReplaced.putIfAbsent(vowelReplacedWord, word);
    }

    List<String> result = new ArrayList<>();
    for (String query : queries) {
        String lowerQuery = query.toLowerCase();
        String vowelReplacedQuery = lowerQuery.replaceAll("[aeiou]", "#");

        if (wordMap.containsKey(query)) {
            result.add(wordMap.get(query));
        } else if (wordMapLowerCase.containsKey(lowerQuery)) {
            result.add(wordMapLowerCase.get(lowerQuery));
        } else if (wordMapVowelReplaced.containsKey(vowelReplacedQuery)) {
            result.add(wordMapVowelReplaced.get(vowelReplacedQuery));
        } else {
            result.add("");
        }
    }

    return result;
}


-----
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public List<String> spellchecker(String[] wordlist, String[] queries) 
    // Your code here
}


************************************
Question ID: 1007

import java.util.ArrayList;
import java.util.List;

public List<Integer> numsSameConsecDiff(int n, int k) {
    List<Integer> result = new ArrayList<>();
    if (n == 1) result.add(0);

    void dfs(String current) {
        if (current.length() == n) {
            result.add(Integer.parseInt(current));
            return;
        }

        char last_digit = current.charAt(current.length() - 1);
        if (last_digit - k >= '0') dfs(current + (char) (last_digit - k));
        if (k != 0 && last_digit + k <= '9') dfs(current + (char) (last_digit + k));
    }

    for (char i = '1'; i <= '9'; ++i) {
        dfs(Character.toString(i));
    }

    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<Integer> numsSameConsecDiff(int n, int k) 
    // Your code here
}

************************************
Question ID: 1008

public int minCameraCover(TreeNode root) {
    int[] ans = new int[1];
    return (dfs(root, ans) < 1 ? 1 : 0) + ans[0];
}

private int dfs(TreeNode node, int[] ans) {
    if (node == null) return 2;
    int left = dfs(node.left, ans);
    int right = dfs(node.right, ans);
    if (left == 0 || right == 0) {
        ans[0]++;
        return 1;
    }
    return left == 1 || right == 1 ? 2 : 0;
}


-----
public int minCameraCover(TreeNode root) 
    // Your code here
}


************************************
Question ID: 1009

import java.util.ArrayList;
import java.util.List;

public List<Integer> pancakeSort(int[] arr) {
    List<Integer> flips = new ArrayList<>();
    for (int size = arr.length; size > 1; --size) {
        int maxIdx = getMaxIdx(arr, size);
        flips.add(maxIdx + 1);
        flips.add(size);
        reverse(arr, 0, maxIdx);
        reverse(arr, 0, size - 1);
    }
    return flips;
}

private int getMaxIdx(int[] arr, int size) {
    int maxIdx = 0;
    for (int i = 1; i < size; ++i) {
        if (arr[i] > arr[maxIdx]) {
            maxIdx = i;
        }
    }
    return maxIdx;
}

private void reverse(int[] arr, int start, int end) {
    while (start < end) {
        int temp = arr[start];
        arr[start++] = arr[end];
        arr[end--] = temp;
    }
}

-----
import java.util.ArrayList;
import java.util.List;

public List<Integer> pancakeSort(int[] arr) 
    // Your code here
}

************************************
Question ID: 1010

import java.util.HashSet;
import java.util.ArrayList;

public List<Integer> powerfulIntegers(int x, int y, int bound) {
    HashSet<Integer> resultSet = new HashSet<>();
    for (int i = 0; Math.pow(x, i) <= bound; ++i) {
        for (int j = 0; Math.pow(x, i) + Math.pow(y, j) <= bound; ++j) {
            resultSet.add((int)(Math.pow(x, i) + Math.pow(y, j)));
        }
    }
    return new ArrayList<>(resultSet);
}


-----
import java.util.HashSet;
import java.util.ArrayList;

public List<Integer> powerfulIntegers(int x, int y, int bound) 
    // Your code here
}


************************************
Question ID: 1011

class Solution {
    int idx;
    List<Integer> flipped;

    void flipRecur(TreeNode node, int[] voyage) {
        if (node == null) return;
        if (node.val != voyage[idx++]) {
            flipped.clear();
            flipped.add(-1);
            return;
        }
        if (idx < voyage.length && node.left != null && node.left.val != voyage[idx]) {
            flipped.add(node.val);
            flipRecur(node.right, voyage);
            flipRecur(node.left, voyage);
        } else {
            flipRecur(node.left, voyage);
            flipRecur(node.right, voyage);
        }
    }

    public List<Integer> flipMatchVoyage(TreeNode root, int[] voyage) {
        idx = 0;
        flipped = new ArrayList<>();
        flipRecur(root, voyage);
        return flipped;
    }
}


-----
class Solution 
    // Your code here
}


************************************
Question ID: 1012

public boolean isRationalEqual(String s, String t) {
    Double num1 = evaluateString(s);
    Double num2 = evaluateString(t);
    return Math.abs(num1 - num2) < 1e-12;
}

private double evaluateString(String s) {
    int i = s.indexOf('(');
    if (i != -1) {
        String base = s.substring(0, i);
        String rep = s.substring(i + 1, s.length() - 1);
        for (int k = 0; k < 20; ++k) {
            base += rep;
        }
        return Double.parseDouble(base);
    }
    return Double.parseDouble(s);
}

-----
public boolean isRationalEqual(String s, String t) 
    // Your code here
}

************************************
Question ID: 1013

public int fib(int n) {
    if (n <= 1)
        return n;
    int a = 0, b = 1, c;
    for (int i = 2; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    return b;
}

-----
public int fib(int n) 
    // Your code here
}

************************************
Question ID: 1014

import java.util.Arrays;

public int[][] kClosest(int[][] points, int k) {
    Arrays.sort(points, (a, b) -> (a[0] * a[0] + a[1] * a[1]) - (b[0] * b[0] + b[1] * b[1]));
    return Arrays.copyOfRange(points, 0, k);
}

-----
import java.util.Arrays;

public int[][] kClosest(int[][] points, int k) 
    // Your code here
}

************************************
Question ID: 1015

public int smallestRepunitDivByK(int k) {
    if (k % 2 == 0 || k % 5 == 0) return -1;
    int n = 0;
    for (int i = 1; i <= k; i++) {
        n = (n * 10 + 1) % k;
        if (n == 0) return i;
    }
    return -1;
}

-----
public int smallestRepunitDivByK(int k) 
    // Your code here
}

************************************
Question ID: 1016

public int subarraysDivByK(int[] nums, int k) {
    Map<Integer, Integer> counts = new HashMap<>();
    counts.put(0, 1);
    int sum = 0, result = 0;

    for (int num : nums) {
        sum += num;
        int mod = ((sum % k) + k) % k;
        result += counts.getOrDefault(mod, 0);
        counts.put(mod, counts.getOrDefault(mod, 0) + 1);
    }

    return result;
}

-----
public int subarraysDivByK(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 1017

import java.util.TreeMap;

public int oddEvenJumps(int[] arr) {
    int n = arr.length;
    boolean[] canReachOdd = new boolean[n], canReachEven = new boolean[n];
    canReachOdd[n - 1] = canReachEven[n - 1] = true;
    TreeMap<Integer, Integer> indexMap = new TreeMap<>();
    indexMap.put(arr[n - 1], n - 1);

    int goodIndices = 1;
    for (int i = n - 2; i >= 0; --i) {
        Integer oddJump = indexMap.ceilingKey(arr[i]);
        Integer evenJump = indexMap.floorKey(arr[i]);

        if (oddJump != null) canReachOdd[i] = canReachEven[indexMap.get(oddJump)];
        if (evenJump != null) canReachEven[i] = canReachOdd[indexMap.get(evenJump)];

        if (canReachOdd[i]) ++goodIndices;

        indexMap.put(arr[i], i);
    }

    return goodIndices;
}

-----
import java.util.TreeMap;

public int oddEvenJumps(int[] arr) 
    // Your code here
}

************************************
Question ID: 1018

import java.util.Arrays;

public int largestPerimeter(int[] nums) {
    Arrays.sort(nums);

    for (int i = nums.length - 1; i >= 2; --i) {
        if (nums[i] < nums[i - 1] + nums[i - 2]) {
            return nums[i] + nums[i - 1] + nums[i - 2];
        }
    }

    return 0;
}

-----
import java.util.Arrays;

public int largestPerimeter(int[] nums) 
    // Your code here
}

************************************
Question ID: 1019

import java.util.Arrays;

public int[] sortedSquares(int[] nums) {
    for(int i = 0; i < nums.length; i++) {
        nums[i] *= nums[i];
    }
    Arrays.sort(nums);
    return nums;
}

-----
import java.util.Arrays;

public int[] sortedSquares(int[] nums) 
    // Your code here
}

************************************
Question ID: 1020

public int maxTurbulenceSize(int[] arr) {
    int n = arr.length;
    int result = 1;
    int i = 0;

    while (i < n - 1) {
        if (arr[i] == arr[i + 1]) {
            i++;
            continue;
        }

        int j = i + 1;
        while (j < n - 1 && ((arr[j] > arr[j + 1]) != (arr[j - 1] > arr[j])))
            j++;
        
        result = Math.max(result, j - i + 1);
        i = j;
    }

    return result;
}


-----
public int maxTurbulenceSize(int[] arr) 
    // Your code here
}


************************************
Question ID: 1021

public int distributeCoins(TreeNode root) {
    int[] moves = new int[1];
    distributeCoins(root, moves);
    return moves[0];
}

private int distributeCoins(TreeNode root, int[] moves) {
    if (root == null) return 0;
    int left = distributeCoins(root.left, moves);
    int right = distributeCoins(root.right, moves);
    moves[0] += Math.abs(left) + Math.abs(right);
    return root.val + left + right - 1;
}

-----
public int distributeCoins(TreeNode root) 
    // Your code here
}

************************************
Question ID: 1022

public int uniquePathsIII(int[][] grid) {
    int x = 0, y = 0, empty = 1;
    for (int i = 0; i < grid.length; ++i) {
        for (int j = 0; j < grid[0].length; ++j) {
            if (grid[i][j] == 1) {
                x = i;
                y = j;
            } else if (grid[i][j] == 0) {
                empty++;
            }
        }
    }
    return dfs(grid, x, y, empty);
}

private int dfs(int[][] grid, int x, int y, int empty) {
    if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] == -1) {
        return 0;
    }
    if (grid[x][y] == 2) {
        return empty == -1 ? 1 : 0;
    }
    grid[x][y] = -1;
    int paths = dfs(grid, x + 1, y, empty - 1) + dfs(grid, x - 1, y, empty - 1) + dfs(grid, x, y + 1, empty - 1) + dfs(grid, x, y - 1, empty - 1);
    grid[x][y] = 0;
    return paths;
}

-----
public int uniquePathsIII(int[][] grid) 
    // Your code here
}

************************************
Question ID: 1023

import java.util.*;

class TimeMap {
    private Map<String, TreeMap<Integer, String>> data;

    public TimeMap() {
        data = new HashMap();
    }

    public void set(String key, String value, int timestamp) {
        data.putIfAbsent(key, new TreeMap<>());
        data.get(key).put(timestamp, value);
    }

    public String get(String key, int timestamp) {
        if (!data.containsKey(key)) return "";
        Integer prevTimeStamp = data.get(key).floorKey(timestamp);
        return prevTimeStamp == null ? "" : data.get(key).get(prevTimeStamp);
    }
}

-----
import java.util.*;

class TimeMap 
    // Your code here
}

************************************
Question ID: 1024

int countAndTriples(int[] nums) {
    int count = 0;
    for (int i = 0; i < nums.length; i++) {
        for (int j = i + 1; j < nums.length; j++) {
            for (int k = j + 1; k < nums.length; k++) {
                if ((nums[i] & nums[j] & nums[k]) != 0)
                    count++;
            }
        }
    }
    return count;
}

-----
int countAndTriples(int[] nums) 
    // Your code here
}

************************************
Question ID: 1025

import java.util.*;

public int mincostTickets(int[] days, int[] costs) {
  Set<Integer> travelDays = new HashSet<>();
  for (int day : days) travelDays.add(day);
  int[] dp = new int[366];

  for (int i = 1; i <= 365; ++i) {
    if (!travelDays.contains(i)) {
      dp[i] = dp[i - 1];
    } else {
      dp[i] = Math.min(dp[i - 1] + costs[0],
                   Math.min(dp[Math.max(0, i - 7)] + costs[1],
                            dp[Math.max(0, i - 30)] + costs[2]));
    }
  }

  return dp[365];
}

-----
import java.util.*;

public int mincostTickets(int[] days, int[] costs) 
    // Your code here
}

************************************
Question ID: 1027

import java.util.*;

public int[] sumEvenAfterQueries(int[] nums, int[][] queries) {
    int[] answer = new int[queries.length];
    int even_sum = 0;

    for (int num : nums) {
        if (num % 2 == 0) {
            even_sum += num;
        }
    }

    for (int i = 0; i < queries.length; i++) {
        int value = queries[i][0];
        int index = queries[i][1];

        if (nums[index] % 2 == 0) {
            even_sum -= nums[index];
        }
        nums[index] += value;
        if (nums[index] % 2 == 0) {
            even_sum += nums[index];
        }
        answer[i] = even_sum;
    }

    return answer;
}


-----
import java.util.*;

public int[] sumEvenAfterQueries(int[] nums, int[][] queries) 
    // Your code here
}


************************************
Question ID: 1028

import java.util.ArrayList;
import java.util.List;

public List<int[]> intervalIntersection(int[][] firstList, int[][] secondList) {
    List<int[]> result = new ArrayList<>();
    int i = 0, j = 0;
    
    while (i < firstList.length && j < secondList.length) {
        int start = Math.max(firstList[i][0], secondList[j][0]);
        int end = Math.min(firstList[i][1], secondList[j][1]);
        
        if (start <= end) {
            result.add(new int[]{start, end});
        }
        
        if (firstList[i][1] < secondList[j][1]) {
            i++;
        } else {
            j++;
        }
    }
    
    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<int[]> intervalIntersection(int[][] firstList, int[][] secondList) 
    // Your code here
}

************************************
Question ID: 1029

import java.util.*;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

public List<List<Integer>> verticalTraversal(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) return result;
    
    Map<Integer, TreeMap<Integer, PriorityQueue<Integer>>> columns = new TreeMap<>();
    Queue<TreeNode> nodeQueue = new LinkedList<>();
    Queue<int[]> posQueue = new LinkedList<>();

    nodeQueue.offer(root);
    posQueue.offer(new int[]{0, 0});

    while (!nodeQueue.isEmpty()) {
        TreeNode node = nodeQueue.poll();
        int[] pos = posQueue.poll();
        int row = pos[0], col = pos[1];

        columns.putIfAbsent(col, new TreeMap<>());
        columns.get(col).putIfAbsent(row, new PriorityQueue<>());
        columns.get(col).get(row).offer(node.val);

        if (node.left != null) {
            nodeQueue.offer(node.left);
            posQueue.offer(new int[]{row + 1, col - 1});
        }

        if (node.right != null) {
            nodeQueue.offer(node.right);
            posQueue.offer(new int[]{row + 1, col + 1});
        }
    }

    for (TreeMap<Integer, PriorityQueue<Integer>> columnData : columns.values()) {
        List<Integer> column = new ArrayList<>();
        for (PriorityQueue<Integer> nodes : columnData.values()) {
            while (!nodes.isEmpty()) {
                column.add(nodes.poll());
            }
        }
        result.add(column);
    }

    return result;
}

-----
import java.util.*;

class TreeNode 
    // Your code here
}

************************************
Question ID: 1031

import java.util.*;

public List<Integer> addToArrayForm(int[] num, int k) {
    List<Integer> result = new ArrayList<>();
    int carry = k, i = num.length - 1;
    while (i >= 0 || carry > 0) {
        if (i >= 0) {
            carry += num[i--];
        }
        result.add(carry % 10);
        carry /= 10;
    }
    Collections.reverse(result);
    return result;
}


-----
import java.util.*;

public List<Integer> addToArrayForm(int[] num, int k) 
    // Your code here
}


************************************
Question ID: 1032

public boolean equationsPossible(String[] equations) {
    int[] parent = new int[26];
    for (int i = 0; i < 26; ++i) {
        parent[i] = i;
    }

    for (String e : equations) {
        if (e.charAt(1) == '=') {
            int x = e.charAt(0) - 'a';
            int y = e.charAt(3) - 'a';
            parent[find(x, parent)] = find(y, parent);
        }
    }

    for (String e : equations) {
        if (e.charAt(1) == '!' && find(e.charAt(0) - 'a', parent) == find(e.charAt(3) - 'a', parent)) {
            return false;
        }
    }

    return true;
}

private int find(int x, int[] parent) {
    if (parent[x] != x) {
        parent[x] = find(parent[x], parent);
    }

    return parent[x];
}


-----
public boolean equationsPossible(String[] equations) 
    // Your code here
}


************************************
Question ID: 1033

public int brokenCalc(int startValue, int target) {
    int operations = 0;
    while (target > startValue) {
        target = (target % 2 == 0) ? target / 2 : target + 1;
        operations++;
    }
    return operations + startValue - target;
}

-----
public int brokenCalc(int startValue, int target) 
    // Your code here
}

************************************
Question ID: 1034

import java.util.HashMap;

public int good_subarrays(int[] nums, int k) {
    int count = 0;
    for (int i = 0; i < nums.length; i++) {
        HashMap<Integer, Integer> frequency = new HashMap<>();
        for (int j = i; j < nums.length; j++) {
            frequency.put(nums[j], frequency.getOrDefault(nums[j], 0) + 1);
            if (frequency.size() > k) break;
            if (frequency.size() == k) count++;
        }
    }
    return count;
}


-----
import java.util.HashMap;

public int good_subarrays(int[] nums, int k) 
    // Your code here
}


************************************
Question ID: 1036

import java.util.LinkedList;
import java.util.Queue;

public int orangesRotting(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    int freshOranges = 0;
    Queue<int[]> rotten = new LinkedList<>();

    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (grid[i][j] == 1)
                freshOranges++;
            else if (grid[i][j] == 2)
                rotten.offer(new int[]{i, j});
        }
    }
    
    int minutes = 0;
    int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    
    while (!rotten.isEmpty() && freshOranges != 0) {
        int size = rotten.size();
        for (int i = 0; i < size; ++i) {
            int[] current = rotten.poll();

            for (int[] direction : directions) {
                int x = current[0] + direction[0];
                int y = current[1] + direction[1];

                if (x < 0 || y < 0 || x >= m || y >= n || grid[x][y] != 1)
                    continue;

                grid[x][y] = 2;
                freshOranges--;
                rotten.offer(new int[]{x, y});
            }
        }
        minutes++;
    }
    
    return freshOranges == 0 ? minutes : -1;
}


-----
import java.util.LinkedList;
import java.util.Queue;

public int orangesRotting(int[][] grid) 
    // Your code here
}


************************************
Question ID: 1037

public int minKBitFlips(int[] nums, int k) {
    int n = nums.length, res = 0, flipped = 0;
    int[] change = new int[n];
    for (int i = 0; i <= n - k; i++) {
        flipped ^= change[i];
        if (nums[i] == flipped) {
            res++;
            flipped ^= 1;
            if (i + k < n) change[i + k] ^= 1;
        }
    }
    for (int i = n - k + 1; i < n; i++) {
        flipped ^= change[i];
        if (nums[i] == flipped) return -1;
    }
    return res;
}


-----
public int minKBitFlips(int[] nums, int k) 
    // Your code here
}


************************************
Question ID: 1038

import java.util.Arrays;

public int squareful_perms(int[] nums) {
    Arrays.sort(nums);
    return count_permutations(nums, 0);
}

private boolean is_squareful(int x, int y) {
    int s = (int) Math.sqrt(x + y);
    return s * s == x + y;
}

private int count_permutations(int[] nums, int start) {
    if (start == nums.length) {
        return 1;
    }

    int count = 0;

    for (int i = start; i < nums.length; i++) {
        if (i == start || nums[i] != nums[start]) {
            if (start == 0 || is_squareful(nums[start - 1], nums[i])) {
                swap(nums, i, start);
                count += count_permutations(nums, start + 1);
                swap(nums, i, start);
            }
        }
    }

    return count;
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}


-----
import java.util.Arrays;

public int squareful_perms(int[] nums) 
    // Your code here
}


************************************
Question ID: 1039

public int findJudge(int n, int[][] trust) {
    int[] trustCounts = new int[n + 1];
    for (int[] relation : trust) {
        trustCounts[relation[0]]--;
        trustCounts[relation[1]]++;
    }
    
    for (int i = 1; i <= n; i++) {
        if (trustCounts[i] == n - 1) {
            return i;
        }
    }
    return -1;
}

-----
public int findJudge(int n, int[][] trust) 
    // Your code here
}

************************************
Question ID: 1040

public TreeNode insertIntoMaxTree(TreeNode root, int val) {
    if (root == null || val > root.val) {
        TreeNode newNode = new TreeNode(val);
        newNode.left = root;
        return newNode;
    }
    root.right = insertIntoMaxTree(root.right, val);
    return root;
}


-----
public TreeNode insertIntoMaxTree(TreeNode root, int val) 
    // Your code here
}


************************************
Question ID: 1041

public int numRookCaptures(char[][] board) {
    int x = 0, y = 0, captures = 0;
    outer: for (x = 0; x < 8; x++) {
        for (y = 0; y < 8; y++) {
            if (board[x][y] == 'R') {
                break outer;
            }
        }
    }

    int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    for (int[] dir : dirs) {
        int nx = x + dir[0];
        int ny = y + dir[1];
        while (nx >= 0 && nx < 8 && ny >= 0 && ny < 8) {
            if (board[nx][ny] == 'p') {
                captures++;
                break;
            } else if (board[nx][ny] == 'B') {
                break;
            }
            nx += dir[0];
            ny += dir[1];
        }
    }
    
    return captures;
}


-----
public int numRookCaptures(char[][] board) 
    // Your code here
}


************************************
Question ID: 1042

public int mergeStones(int[] stones, int k) {
    int n = stones.length;
    if ((n - 1) % (k - 1) != 0) return -1;
    int[] prefixSum = new int[n + 1];
    int[][][] dp = new int[n][n][k + 1];

    for (int i = 0; i < n; ++i) {
        prefixSum[i + 1] = prefixSum[i] + stones[i];
    }

    for (int l = 2; l <= n; ++l) {
        for (int i = 0; i <= n - l; ++i) {
            int j = i + l - 1;
            for (int m = 2; m <= k; ++m) {
                for (int p = i; p + m <= j + 1; p += k - 1) {
                    dp[i][j][m] = (dp[i][p][1] + dp[p + 1][j][m - 1]) % (1_000_000_000 + 7);
                }
            }
            if ((j - i) % (k - 1) == 0) {
                dp[i][j][1] = (dp[i][j][k] + prefixSum[j + 1] - prefixSum[i]) % (1_000_000_000 + 7);
            }
        }
    }
    return dp[0][n - 1][1];
}

-----
public int mergeStones(int[] stones, int k) 
    // Your code here
}

************************************
Question ID: 1043

import java.util.*;

public int[] gridIllumination(int n, int[][] lamps, int[][] queries) {
    Set<Integer> lampCols = new HashSet<>();
    Set<Integer> lampRows = new HashSet<>();
    Set<Integer> lampLeftDiag = new HashSet<>();
    Set<Integer> lampRightDiag = new HashSet<>();

    for (int[] lamp : lamps) {
        lampRows.add(lamp[0]);
        lampCols.add(lamp[1]);
        lampLeftDiag.add(lamp[0] - lamp[1]);
        lampRightDiag.add(lamp[0] + lamp[1]);
    }

    int[] ans = new int[queries.length];

    for (int j = 0; j < queries.length; j++) {
        int row = queries[j][0];
        int col = queries[j][1];
        if (lampRows.contains(row) || lampCols.contains(col) || lampLeftDiag.contains(row - col) || lampRightDiag.contains(row + col)) {
            ans[j] = 1;
        } else {
            ans[j] = 0;
        }
        for (int i = -1; i <= 1; i++) {
            for (int k = -1; k <= 1; k++) {
                int newRow = row + i;
                int newCol = col + k;
                lampRows.remove(newRow);
                lampCols.remove(newCol);
                lampLeftDiag.remove(newRow - newCol);
                lampRightDiag.remove(newRow + newCol);
            }
        }
    }
    return ans;
}


-----
import java.util.*;

public int[] gridIllumination(int n, int[][] lamps, int[][] queries) 
    // Your code here
}


************************************
Question ID: 1044

import java.util.*;

public List<Character> commonChars(String[] words) {
    Map<Character, Integer> merged = new HashMap<>();

    for (String word : words) {
        Map<Character, Integer> wordMap = new HashMap<>();
        for (char c : word.toCharArray()) {
            wordMap.put(c, wordMap.getOrDefault(c, 0) + 1);
        }
        if (merged.isEmpty()) {
            merged = wordMap;
        } else {
            for (char c : merged.keySet()) {
                merged.put(c, Math.min(merged.get(c), wordMap.getOrDefault(c, 0)));
            }
        }
    }

    List<Character> result = new ArrayList<>();
    for (Map.Entry<Character, Integer> entry : merged.entrySet()) {
        for (int i = 0; i < entry.getValue(); i++) {
            result.add(entry.getKey());
        }
    }
    return result;
}

-----
import java.util.*;

public List<Character> commonChars(String[] words) 
    // Your code here
}

************************************
Question ID: 1046

public int longestOnes(int[] nums, int k) {
    int left = 0, right = 0, maxOnes = 0, zeroCount = 0;
    while (right < nums.length) {
        if (nums[right] == 0) zeroCount++;
        while (zeroCount > k) {
            if (nums[left] == 0) zeroCount--;
            left++;
        }
        maxOnes = Math.max(maxOnes, right - left + 1);
        right++;
    }
    return maxOnes;
}


-----
public int longestOnes(int[] nums, int k) 
    // Your code here
}


************************************
Question ID: 1047

public int maxSumAfterKOperations(int[] nums, int k) {
    PriorityQueue<Integer> pq = new PriorityQueue<>();
    for(int num : nums) pq.add(num);
    while(k-- > 0){
        int current = pq.poll();
        pq.add(-current);
    }
    int sum = 0;
    for(int num : pq) sum += num;
    return sum;
}

-----
public int maxSumAfterKOperations(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 1048

public int clumsy(int n) {
    if (n <= 2) {
        return n;
    }
    if (n == 3) {
        return 6;
    }
    int result = n * (n - 1) / (n - 2) + (n - 3);
    n -= 4;
    while (n >= 4) {
        result = result - (n * (n - 1) / (n - 2)) + (n - 3);
        n -= 4;
    }
    return result - clumsy(n);
}


-----
public int clumsy(int n) 
    // Your code here
}


************************************
Question ID: 1049

public int min_rotations(int[] tops, int[] bottoms) {
    int res = Integer.MAX_VALUE;

    for (int target : new int[] {tops[0], bottoms[0]}) {
        int top_rot = 0, bot_rot = 0;
        for (int i = 0; i < tops.length; ++i) {
            if (tops[i] != target && bottoms[i] != target) {
                top_rot = bot_rot = Integer.MAX_VALUE;
                break;
            }
            top_rot += tops[i] != target ? 1 : 0;
            bot_rot += bottoms[i] != target ? 1 : 0;
        }
        res = Math.min(res, Math.min(top_rot, bot_rot));
    }

    return res == Integer.MAX_VALUE ? -1 : res;
}

-----
public int min_rotations(int[] tops, int[] bottoms) 
    // Your code here
}

************************************
Question ID: 1051

import java.util.Arrays;

public int heightChecker(int[] heights) {
    int[] expected = heights.clone();
    Arrays.sort(expected);

    int count = 0;
    for (int i = 0; i < heights.length; ++i) {
        if (heights[i] != expected[i]) {
            ++count;
        }
    }

    return count;
}

-----
import java.util.Arrays;

public int heightChecker(int[] heights) 
    // Your code here
}

************************************
Question ID: 1052

public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {
    int total_customers = 0, max_extra_customers = 0, extra_customers = 0;
    for (int i = 0; i < customers.length; ++i) {
        if (grumpy[i] == 0) {
            total_customers += customers[i];
        }
        if (i < minutes) {
            extra_customers += customers[i] * grumpy[i];
        } else {
            extra_customers += (customers[i] * grumpy[i]) - (customers[i - minutes] * grumpy[i - minutes]);
        }
        max_extra_customers = Math.max(max_extra_customers, extra_customers);
    }
    return total_customers + max_extra_customers;
}


-----
public int maxSatisfied(int[] customers, int[] grumpy, int minutes) 
    // Your code here
}


************************************
Question ID: 1053

public int[] prevPermOpt1(int[] arr) {
    int n = arr.length;
    for (int i = n - 2; i >= 0; i--) {
        if (arr[i] > arr[i + 1]) {
            int j = i + 1;
            while (j < n && arr[j] < arr[i]) j++;
            int temp = arr[i];
            arr[i] = arr[j - 1];
            arr[j - 1] = temp;
            break;
        }
    }
    return arr;
}


-----
public int[] prevPermOpt1(int[] arr) 
    // Your code here
}


************************************
Question ID: 1054

public int bitwiseComplement(int n) {
    int x = 1;
    while (n > x) {
        x = x * 2 + 1;
    }
    return x - n;
}

-----
public int bitwiseComplement(int n) 
    // Your code here
}

************************************
Question ID: 1055

public int numPairsDivisibleBy60(int[] time) {
    int[] count = new int[60];
    int pairs = 0;

    for (int t : time) {
        int mod = t % 60;
        pairs += count[(60 - mod) % 60];
        count[mod]++;
    }

    return pairs;
}

-----
public int numPairsDivisibleBy60(int[] time) 
    // Your code here
}

************************************
Question ID: 1056


```java
import java.util.Arrays;

public int shipWithinDays(int[] weights, int days) {
    int left = Arrays.stream(weights).max().getAsInt();
    int right = Arrays.stream(weights).sum();
    while (left < right) {
        int mid = left + (right - left) / 2;
        int day_count = 1, curr_capacity = 0;
        for (int w : weights) {
            curr_capacity += w;
            if (curr_capacity > mid) {
                day_count++;
                curr_capacity = w;
            }
        }
        if (day_count > days) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}
```

-----

```java
import java.util.Arrays;

public int shipWithinDays(int[] weights, int days) 
    // Your code here
}
```

************************************
Question ID: 1057

import java.util.HashSet;

public int numDupDigitsAtMostN(int n) {
    int count = 0;
    for (int i = 1; i <= n; i++) {
        HashSet<Integer> digits = new HashSet<>();
        int num = i;
        while (num != 0) {
            int digit = num % 10;
            if (digits.contains(digit)) {
                count++;
                break;
            } else {
                digits.add(digit);
            }
            num /= 10;
        }
    }
    return count;
}

-----
import java.util.HashSet;

public int numDupDigitsAtMostN(int n) 
    // Your code here
}

************************************
Question ID: 1058

import java.text.DecimalFormat;
import java.math.BigDecimal;

public String findRoundingError(String[] prices, int target) {
    int n = prices.length;
    BigDecimal[] decimals = new BigDecimal[n];
    int roundedSum = 0;
    BigDecimal errorSum = BigDecimal.ZERO;

    for (int i = 0; i < n; i++) {
        BigDecimal price = new BigDecimal(prices[i]);
        decimals[i] = price.subtract(price.setScale(0, BigDecimal.ROUND_DOWN));
        roundedSum += price.setScale(0, BigDecimal.ROUND_DOWN).intValue();
        errorSum = errorSum.add(decimals[i]);
    }

    if (target < roundedSum || target > roundedSum + n) {
        return "-1 ";
    }

    int ceilCount = target - roundedSum;
    BigDecimal roundingError = BigDecimal.ZERO;

    for (int i = 0; i < n; i++) {
        if (ceilCount > 0) {
            roundingError = roundingError.add(BigDecimal.ONE.subtract(decimals[i]));
            ceilCount--;
        } else {
            roundingError = roundingError.add(decimals[i]);
        }
    }

    DecimalFormat df = new DecimalFormat("#.000");
    return df.format(roundingError) + " ";
}


-----
import java.text.DecimalFormat;
import java.math.BigDecimal;

public String findRoundingError(String[] prices, int target) 
    // Your code here
}


************************************
Question ID: 1059

import java.util.*;

public boolean leadsToDestination(int n, int[][] edges, int source, int destination) {
    Map<Integer, List<Integer>> graph = new HashMap<>();
    for (int[] edge : edges) {
        graph.computeIfAbsent(edge[0], k -> new ArrayList<>()).add(edge[1]);
    }

    int[] visited = new int[n];
    return dfs(source, graph, visited, destination);
}

private boolean dfs(int node, Map<Integer, List<Integer>> graph, int[] visited, int destination) {
    if (!graph.containsKey(node)) return node == destination;
    if (visited[node] != 0) return visited[node] == 2;

    visited[node] = 1;
    for (int neighbor : graph.get(node)) {
        if (!dfs(neighbor, graph, visited, destination)) return false;
    }

    visited[node] = 2;
    return true;
}

-----
import java.util.*;

public boolean leadsToDestination(int n, int[][] edges, int source, int destination) 
    // Your code here
}

************************************
Question ID: 1060

public int findKthPositive(int[] nums, int k) {
    int left = 0, right = nums.length;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] - mid - 1 < k) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left + k;
}

-----
public int findKthPositive(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 1061

import java.util.HashMap;
import java.util.Map;

public String lexSmallestEquivalent(String s1, String s2, String baseStr) {
    Map<Character, Character> parent = new HashMap<>();
    for (char ch = 'a'; ch <= 'z'; ch++) {
        parent.put(ch, ch);
    }

    for (int i = 0; i < s1.length(); i++) {
        char root1 = s1.charAt(i), root2 = s2.charAt(i);
        while (parent.get(root1) != root1) root1 = parent.get(root1);
        while (parent.get(root2) != root2) root2 = parent.get(root2);
        if (root1 != root2) {
            parent.put(root1, (char) Math.min(root1, root2));
            parent.put(root2, (char) Math.min(root1, root2));
        }
    }

    StringBuilder sb = new StringBuilder();
    for (char ch : baseStr.toCharArray()) {
        while (parent.get(ch) != ch) ch = parent.get(ch);
        sb.append(ch);
    }

    return sb.toString();
}

-----
import java.util.HashMap;
import java.util.Map;

public String lexSmallestEquivalent(String s1, String s2, String baseStr) 
    // Your code here
}

************************************
Question ID: 1062

public int findLongestRepeatingSubstring(String s) {
    int n = s.length();
    int maxSubstrLength = 0;
    for (int len = 1; len <= n / 2; ++len) {
        int maxRepeatCount = 0, repeatCount = 0;
        for (int i = 0; i < n - len; ++i) {
            if (s.substring(i, i + len).equals(s.substring(i + len, i + 2 * len))) {
                repeatCount++;
            } else {
                maxRepeatCount = Math.max(maxRepeatCount, repeatCount);
                repeatCount = 0;
            }
        }
        maxSubstrLength = Math.max(maxSubstrLength, maxRepeatCount * len);
    }
    return maxSubstrLength;
}

-----
public int findLongestRepeatingSubstring(String s) 
    // Your code here
}

************************************
Question ID: 1063

public int maxScoreSightseeingPair(int[] values) {
    int max_score = 0, max_score_left = values[0] + 0;
    for (int j = 1; j < values.length; ++j) {
        max_score = Math.max(max_score, max_score_left + values[j] - j);
        max_score_left = Math.max(max_score_left, values[j] + j);
    }
    return max_score;
}

-----
public int maxScoreSightseeingPair(int[] values) 
    // Your code here
}

************************************
Question ID: 1064

public int fixedPoint(int[] arr) {
    int left = 0, right = arr.length - 1;
    while (left < right) {
        int middle = left + (right - left) / 2;
        if (arr[middle] < middle) {
            left = middle + 1;
        } else {
            right = middle;
        }
    }
    return arr[left] == left ? left : -1;
}

-----
public int fixedPoint(int[] arr) 
    // Your code here
}

************************************
Question ID: 1065

public boolean hasAllCodesInRange(String s, int n) {
    Set<String> substrings = new HashSet<>();
    int length = Integer.toBinaryString(n).length();
    for (int i = 0; i < s.length() - length + 1; ++i) {
        substrings.add(s.substring(i, i + length));
    }
    return substrings.size() == n;
}


-----
public boolean hasAllCodesInRange(String s, int n) 
    // Your code here
}


************************************
Question ID: 1066

import java.util.*;

class Solution {
    public int manhattanDistance(int[] worker, int[] bike) {
        return Math.abs(worker[0] - bike[0]) + Math.abs(worker[1] - bike[1]);
    }

    private void dfs(int[][] workers, int[][] bikes, boolean[] used, int index, int dist, int[] minDist) {
        if (index == workers.length) {
            minDist[0] = Math.min(minDist[0], dist);
            return;
        }

        if (dist >= minDist[0]) {
            return;
        }

        for (int i = 0; i < bikes.length; i++) {
            if (used[i]) {
                continue;
            }
            used[i] = true;
            int curDist = manhattanDistance(workers[index], bikes[i]);
            dfs(workers, bikes, used, index+1, dist + curDist, minDist);
            used[i] = false;
        }
    }

    public int assignBikes(int[][] workers, int[][] bikes) {
        int[] minDist = new int[]{Integer.MAX_VALUE};
        boolean[] used = new boolean[bikes.length];
        dfs(workers, bikes, used, 0, 0, minDist);
        return minDist[0];
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 1067

public int countDigit(int d, int low, int high) {
    int count = 0;
    for (int i = low; i <= high; i++) {
        int num = i;
        while (num > 0) {
            if (num % 10 == d) {
                count++;
            }
            num /= 10;
        }
    }
    return count;
}

-----
public int countDigit(int d, int low, int high) 
    // Your code here
}

************************************
Question ID: 1071

import java.util.ArrayList;
import java.util.List;

public List<Boolean> prefixesDivBy5(int[] nums) {
    List<Boolean> result = new ArrayList<>();
    int current = 0;
    for (int num : nums) {
        current = ((current << 1) | num) % 5;
        result.add(current == 0);
    }
    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<Boolean> prefixesDivBy5(int[] nums) 
    // Your code here
}

************************************
Question ID: 1073

import java.util.*;

public class Solution {
    public int[] addNegabinary(int[] arr1, int[] arr2) {
        LinkedList<Integer> res = new LinkedList<>();
        int i = arr1.length - 1, j = arr2.length - 1, carry = 0;
        while (i >= 0 || j >= 0 || carry < 0 || carry > 0) {
            if (i >= 0) carry += arr1[i--];
            if (j >= 0) carry += arr2[j--];
            res.addFirst(carry & 1);
            carry = -(carry >> 1);
        }
        while (res.size() > 1 && res.peekFirst() == 0) res.pollFirst();
        return res.stream().mapToInt(Integer::intValue).toArray();
    }
}


-----
import java.util.*;

public class Solution 
    // Your code here
}


************************************
Question ID: 1074

public int numSubmatrixSumTarget(int[][] matrix, int target) {
    int rows = matrix.length, cols = matrix[0].length;
    for (int row = 0; row < rows; ++row)
        for (int col = 1; col < cols; ++col)
            matrix[row][col] += matrix[row][col-1];
    
    int count = 0;
    Map<Integer, Integer> counter = new HashMap<>();
    for (int col1 = 0; col1 < cols; ++col1) {
        for (int col2 = col1; col2 < cols; ++col2) {
            counter.clear();
            counter.put(0, 1);
            int cur_sum = 0;
            for (int row = 0; row < rows; ++row) {
                cur_sum += matrix[row][col2] - (col1 > 0 ? matrix[row][col1-1] : 0);
                count += counter.getOrDefault(cur_sum - target, 0);
                counter.put(cur_sum, counter.getOrDefault(cur_sum, 0) + 1);
            }
        }
    }
    return count;
}

-----
public int numSubmatrixSumTarget(int[][] matrix, int target) 
    // Your code here
}

************************************
Question ID: 1078

public String removeOuterParentheses(String s) {
    StringBuilder result = new StringBuilder();
    int opened = 0;

    for (char c : s.toCharArray()) {
        if (c == '(' && opened++ > 0) {
            result.append(c);
        }
        if (c == ')' && opened-- > 1) {
            result.append(c);
        }
    }
    return result.toString();
}


-----
public String removeOuterParentheses(String s) 
    // Your code here
}


************************************
Question ID: 1079

public int sumRootToLeaf(TreeNode root) {
    return sumHelper(root, 0);
}

private int sumHelper(TreeNode node, int value) {
    if (node == null) return 0;
    value = value * 2 + node.val;
    if (node.left == null && node.right == null) return value;
    return sumHelper(node.left, value) + sumHelper(node.right, value);
}

-----
public int sumRootToLeaf(TreeNode root) 
    // Your code here
}

************************************
Question ID: 1080

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode sufficientSubset(TreeNode root, int limit) {
        if(root == null) return null;
        if(root.left == null && root.right == null) {
            if(root.val < limit) return null;
            return root;
        }
        root.left = sufficientSubset(root.left, limit - root.val);
        root.right = sufficientSubset(root.right, limit - root.val);
        if(root.left == null && root.right == null) return null;
        
        return root;
    }
}


-----
/**
 * Definition for a binary tree node.
 * public class TreeNode 
    // Your code here
}


************************************
Question ID: 1081

import java.util.Arrays;

public int videoStitching(int[][] clips, int time) {
    int[] dp = new int[time + 1];
    Arrays.fill(dp, Integer.MAX_VALUE);
    dp[0] = 0;
    for (int i = 1; i <= time; ++i) {
        for (int[] clip : clips) {
            if (clip[0] < i && i <= clip[1]) {
                dp[i] = Math.min(dp[i], dp[clip[0]] + 1);
            }
        }
    }
    return dp[time] == Integer.MAX_VALUE ? -1 : dp[time];
}

-----
import java.util.Arrays;

public int videoStitching(int[][] clips, int time) 
    // Your code here
}

************************************
Question ID: 1085

public int sumOfDigits(int[] nums) {
    int minVal = Arrays.stream(nums).min().getAsInt();
    int digitSum = 0;
    while (minVal > 0) {
        digitSum += minVal % 10;
        minVal /= 10;
    }
    return digitSum % 2 == 0 ? 1 : 0;
}


-----
public int sumOfDigits(int[] nums) 
    // Your code here
}


************************************
Question ID: 1086

boolean aliceWin(int n) {
    return n % 2 == 0;
}


-----
boolean aliceWin(int n) 
    // Your code here
}


************************************
Question ID: 1087

import java.util.HashMap;
import java.util.Map;

public int longestArithSeqLength(int[] nums) {
    int n = nums.length;
    int longest = 0;
    Map<Integer, Integer>[] dp = new HashMap[n];
    
    for (int i = 0; i < n; i++) {
        dp[i] = new HashMap<Integer, Integer>();
        for (int j = 0; j < i; j++) {
            int diff = nums[i] - nums[j];
            dp[i].put(diff, dp[j].containsKey(diff) ? dp[j].get(diff) + 1 : 2);
            longest = Math.max(longest, dp[i].get(diff));
        }
    }
    
    return longest;
}

-----
import java.util.HashMap;
import java.util.Map;

public int longestArithSeqLength(int[] nums) 
    // Your code here
}

************************************
Question ID: 1088

public int confusingNumberII(int n) {
    return helper(n, 0, new int[]{0, 1, 6, 8, 9});
}

private int helper(int n, int current, int[] validNums) {
    int count = 0;
    for (int num : validNums) {
        long next = current * 10 + num;
        if (next > n) break;
        if (current == 0 && next == 0) continue;
        if (next != rotate(next)) count++;
        count += helper(n, (int) next, validNums);
    }
    return count;
}

private int rotate(int num) {
    int rotated = 0;
    while (num > 0) {
        int digit = num % 10;
        if (digit == 2 || digit == 3 || digit == 4 || digit == 5 || digit == 7)
            return -1;
        if (digit == 6) digit = 9;
        else if (digit == 9) digit = 6;
        rotated = rotated * 10 + digit;
        num /= 10;
    }
    return rotated;
}

-----
public int confusingNumberII(int n) 
    // Your code here
}

************************************
Question ID: 1089

public void duplicateZeros(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; ++i) {
        if (arr[i] == 0) {
            for (int j = n - 1; j > i + 1; --j) {
                arr[j] = arr[j - 1];
            }
            arr[++i] = 0;
        }
    }
}

-----
public void duplicateZeros(int[] arr) 
    // Your code here
}

************************************
Question ID: 1090

import java.util.*;

public int largestValsFromLabels(int[] values, int[] labels, int numWanted, int useLimit) {
    int n = values.length;
    int[][] items = new int[n][2];
    for (int i = 0; i < n; ++i) {
        items[i][0] = values[i];
        items[i][1] = labels[i];
    }

    Arrays.sort(items, (a, b) -> Integer.compare(b[0], a[0]));

    Map<Integer, Integer> labelCount = new HashMap<>();
    int ans = 0;

    for (int[] item : items) {
        labelCount.putIfAbsent(item[1], 0);
        if (labelCount.get(item[1]) < useLimit) {
            ans += item[0];
            labelCount.put(item[1], labelCount.get(item[1]) + 1);
            if (--numWanted == 0) break;
        }
    }

    return ans;
}


-----
import java.util.*;

public int largestValsFromLabels(int[] values, int[] labels, int numWanted, int useLimit) 
    // Your code here
}


************************************
Question ID: 1091

import java.util.*;

class Solution {
    public int shortestPathBinaryMatrix(int[][] grid) {
        int n = grid.length;
        if (grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;

        int[][] dir = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};
        Queue<int[]> q = new LinkedList<>();
        q.offer(new int[]{0, 0});
        grid[0][0] = 1;

        int pathLength = 1;

        while (!q.isEmpty()) {
            int qlen = q.size();
            for (int i = 0; i < qlen; i++) {
                int[] cur = q.poll();
                int x = cur[0], y = cur[1];

                if (x == n - 1 && y == n - 1) return pathLength;

                for (int[] d : dir) {
                    int newX = x + d[0];
                    int newY = y + d[1];

                    if (newX >= 0 && newX < n && newY >= 0 && newY < n && grid[newX][newY] == 0) {
                        q.offer(new int[]{newX, newY});
                        grid[newX][newY] = 1;
                    }
                }
            }
            pathLength++;
        }

        return -1;
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 1094

import java.util.Arrays;

public int[][] allCellsDistOrder(int rows, int cols, int rCenter, int cCenter) {
    int[][] coordinates = new int[rows * cols][2];

    int index = 0;
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            coordinates[index++] = new int[]{i, j};
        }
    }

    Arrays.sort(coordinates, (a, b) ->
        Math.abs(a[0] - rCenter) + Math.abs(a[1] - cCenter) - Math.abs(b[0] - rCenter) - Math.abs(b[1] - cCenter)
    );

    return coordinates;
}

-----
import java.util.Arrays;

public int[][] allCellsDistOrder(int rows, int cols, int rCenter, int cCenter) 
    // Your code here
}

************************************
Question ID: 1095

import java.util.Arrays;

public int twoCitySchedCost(int[][] costs) {
    Arrays.sort(costs, (a, b) -> (a[0] - a[1]) - (b[0] - b[1]));

    int totalCost = 0;
    int n = costs.length / 2;

    for (int i = 0; i < n; i++) {
        totalCost += costs[i][0] + costs[i + n][1];
    }

    return totalCost;
}

-----
import java.util.Arrays;

public int twoCitySchedCost(int[][] costs) 
    // Your code here
}

************************************
Question ID: 1099

public int maxSumUnderK(int[] nums, int k) {
    int maxSum = -1;
    for (int i = 0; i < nums.length; i++) {
        for (int j = i + 1; j < nums.length; j++) {
            int sum = nums[i] + nums[j];
            if (sum < k && sum > maxSum) {
                maxSum = sum;
            }
        }
    }
    return maxSum;
}

-----
public int maxSumUnderK(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 1100

public int numKLenSubstrNoRepeats(String s, int k) {
    int n = s.length();
    if (k > n) return 0;
    
    int result = 0;
    HashSet<Character> window = new HashSet<>();
    
    for (int i = 0, j = 0; j < n; ++j) {
        while (window.contains(s.charAt(j))) {
            window.remove(s.charAt(i++));
        }
        window.add(s.charAt(j));
        if (j - i + 1 == k) {
            ++result;
            window.remove(s.charAt(i++));
        }
    }
    return result;
}

-----
public int numKLenSubstrNoRepeats(String s, int k) 
    // Your code here
}

************************************
Question ID: 1101

import java.util.Arrays;
import java.util.List;

public int earliestAcq(int[][] logs, int n) {
    int[] parents = new int[n];
    for (int i = 0; i < n; i++) {
        parents[i] = i;
    }

    Arrays.sort(logs, (log1, log2) -> log1[0] - log2[0]);

    int groupCount = n;
    for (int[] log : logs) {
        int rootX = find(log[1], parents);
        int rootY = find(log[2], parents);
        if (rootX != rootY) {
            parents[rootX] = rootY;
            groupCount--;
        }
        if (groupCount == 1) {
            return log[0];
        }
    }
    return -1;
}

private int find(int x, int[] parents) {
    return x == parents[x] ? x : (parents[x] = find(parents[x], parents));
}

-----
import java.util.Arrays;
import java.util.List;

public int earliestAcq(int[][] logs, int n) 
    // Your code here
}

************************************
Question ID: 1102

public int maxScore(int[][] grid) {
    int m = grid.length, n = grid[0].length;

    for (int i = 1; i < n; ++i) {
        grid[0][i] = Math.min(grid[0][i], grid[0][i - 1]);
    }

    for (int i = 1; i < m; ++i) {
        grid[i][0] = Math.min(grid[i][0], grid[i - 1][0]);

        for (int j = 1; j < n; ++j) {
            grid[i][j] = Math.max(Math.min(grid[i - 1][j], grid[i][j]), 
                                  Math.min(grid[i][j - 1], grid[i][j]));
        }
    }

    return grid[m - 1][n - 1];
}



-----
public int maxScore(int[][] grid) 
    // Your code here
}



************************************
Question ID: 1103

public int[] distributeCandies(int candies, int num_people) {
    int[] result = new int[num_people];
    int i = 0, count = 1;

    while (candies > 0) {
        result[i % num_people] += Math.min(candies, count);
        candies -= count;
        count++;
        i++;
    }

    return result;
}


-----
public int[] distributeCandies(int candies, int num_people) 
    // Your code here
}


************************************
Question ID: 1104

public int[][] colorBorder(int[][] grid, int row, int col, int color) {
    int current = grid[row][col];
    if (current == color)
        return grid;

    dfs(grid, row, col, current, color + 1000);

    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[0].length; j++) {
            if (grid[i][j] > 1000)
                grid[i][j] -= 1000;
        }
    }

    return grid;
}

private void dfs(int[][] grid, int row, int col, int current, int color) {
    if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] != current)
        return;

    grid[row][col] = color;
    dfs(grid, row - 1, col, current, color);
    dfs(grid, row + 1, col, current, color);
    dfs(grid, row, col - 1, current, color);
    dfs(grid, row, col + 1, current, color);
}

-----
public int[][] colorBorder(int[][] grid, int row, int col, int color) 
    // Your code here
}

************************************
Question ID: 1105

public int maxUncrossedLines(int[] nums1, int[] nums2) {
    int m = nums1.length;
    int n = nums2.length;
    int[][] dp = new int[m + 1][n + 1];

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (nums1[i - 1] == nums2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}


-----
public int maxUncrossedLines(int[] nums1, int[] nums2) 
    // Your code here
}


************************************
Question ID: 1106

import java.util.HashSet;
import java.util.Set;
import java.util.List;

public boolean isEscapePossible(List<List<Integer>> blocked, List<Integer> source, List<Integer> target) {
    Set<String> blockedSet = new HashSet<>();
    Set<String> visited = new HashSet<>();
    int maxSteps = 200;

    for (List<Integer> block : blocked)
        blockedSet.add(block.get(0) + "_" + block.get(1));

    return dfs(source.get(0), source.get(1), target.get(0), target.get(1), blockedSet, visited, 0, maxSteps);
}

private boolean dfs(int x, int y, int tx, int ty, Set<String> blocked, Set<String> visited, int steps, int maxSteps) {
    String pos = x + "_" + y;
    if (x < 0 || x >= 1000000 || y < 0 || y >= 1000000 || steps >= maxSteps || blocked.contains(pos) || visited.contains(pos)) {
        return false;
    }

    if (x == tx && y == ty) {
        return true;
    }

    visited.add(pos);

    return dfs(x + 1, y, tx, ty, blocked, visited, steps + 1, maxSteps) ||
           dfs(x, y + 1, tx, ty, blocked, visited, steps + 1, maxSteps) ||
           dfs(x - 1, y, tx, ty, blocked, visited, steps + 1, maxSteps) ||
           dfs(x, y - 1, tx, ty, blocked, visited, steps + 1, maxSteps);
}


-----
import java.util.HashSet;
import java.util.Set;
import java.util.List;

public boolean isEscapePossible(List<List<Integer>> blocked, List<Integer> source, List<Integer> target) 
    // Your code here
}


************************************
Question ID: 1108

public String defangIPaddr(String address) {
    StringBuilder defanged = new StringBuilder();
    for (char c : address.toCharArray()) {
        if (c == '.')
            defanged.append("[.]");
        else
            defanged.append(c);
    }
    return defanged.toString();
}

-----
public String defangIPaddr(String address) 
    // Your code here
}

************************************
Question ID: 1109

public int[] corpFlightBookings(int[][] bookings, int n) {
    int[] seats = new int[n];
    for (int[] booking : bookings) {
        seats[booking[0] - 1] += booking[2];
        if (booking[1] < n) {
            seats[booking[1]] -= booking[2];
        }
    }
    for (int i = 1; i < n; ++i) {
        seats[i] += seats[i - 1];
    }
    return seats;
}

-----
public int[] corpFlightBookings(int[][] bookings, int n) 
    // Your code here
}

************************************
Question ID: 1111

public int minScoreTriangulation(int[] values) {
    int n = values.length;
    int[][] dp = new int[n][n];

    for (int len = 3; len <= n; ++len) {
        for (int i = 0; i + len - 1 < n; ++i) {
            int j = i + len - 1;
            dp[i][j] = Integer.MAX_VALUE;
            for (int k = i + 1; k < j; ++k) {
                dp[i][j] = Math.min(dp[i][j], values[i] * values[j] * values[k] + dp[i][k] + dp[k][j]);
            }
        }
    }

    return dp[0][n - 1];
}


-----
public int minScoreTriangulation(int[] values) 
    // Your code here
}


************************************
Question ID: 1118

int numberOfDays(int year, int month) {
    if (month == 2) {
        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)
            return 29;
        return 28;
    }
    if (month == 4 || month == 6 || month == 9 || month == 11)
        return 30;
    return 31;
}

-----
int numberOfDays(int year, int month) 
    // Your code here
}

************************************
Question ID: 1119

public boolean isRobotBounded(String instructions) {
    int x = 0, y = 0, dir = 0;
    int[][] moves = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

    for (char c : instructions.toCharArray()) {
        if (c == 'G') {
            x += moves[dir][0];
            y += moves[dir][1];
        } else if (c == 'L') {
            dir = (dir + 3) % 4;
        } else {
            dir = (dir + 1) % 4;
        }
    }

    return (x == 0 && y == 0) || dir != 0;
}

-----
public boolean isRobotBounded(String instructions) 
    // Your code here
}

************************************
Question ID: 1120

import java.util.*;

public int[] gardenNoAdj(int n, int[][] paths) {
    List<Set<Integer>> graph = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        graph.add(new HashSet<>());
    }
    for (int[] path : paths) {
        graph.get(path[0] - 1).add(path[1] - 1);
        graph.get(path[1] - 1).add(path[0] - 1);
    }
    int[] result = new int[n];
    for (int i = 0; i < n; i++) {
        Set<Integer> usedFlowers = new HashSet<>();
        for (int neighbor : graph.get(i)) {
            usedFlowers.add(result[neighbor]);
        }
        for (int flower = 1; flower <= 4; flower++) {
            if (!usedFlowers.contains(flower)) {
                result[i] = flower;
                break;
            }
        }
    }
    return result;
}


-----
import java.util.*;

public int[] gardenNoAdj(int n, int[][] paths) 
    // Your code here
}


************************************
Question ID: 1121

public int maxSumAfterPartitioning(int[] arr, int k) {
    int n = arr.length;
    int[] dp = new int[n + 1];
    for (int i = 1; i <= n; ++i) {
        int current_max = 0;
        for (int j = 1; j <= k && i - j >= 0; ++j) {
            current_max = Math.max(current_max, arr[i - j]);
            dp[i] = Math.max(dp[i], dp[i - j] + current_max * j);
        }
    }
    return dp[n];
}

-----
public int maxSumAfterPartitioning(int[] arr, int k) 
    // Your code here
}

************************************
Question ID: 1122

public String longestDupSubstring(String s) {
    int n = s.length();
    String longest_duplicate = "";
    for (int length = n - 1; length > 0; --length) {
        for (int i = 0; i <= n - length; ++i) {
            String substring = s.substring(i, i + length);
            if (s.indexOf(substring, i + 1) != -1) {
                longest_duplicate = substring;
                return longest_duplicate;
            }
        }
    }
    return longest_duplicate;
}


-----
public String longestDupSubstring(String s) 
    // Your code here
}


************************************
Question ID: 1124

import java.util.HashMap;

public int longestWellPerformingInterval(int[] hours) {
    int sum = 0;
    int longest = 0;
    HashMap<Integer, Integer> firstSumIndex = new HashMap<>();

    for (int i = 0; i < hours.length; i++) {
        sum += (hours[i] > 8) ? 1 : -1;
        if (sum > 0) {
            longest = i + 1;
        } else {
            if (firstSumIndex.containsKey(sum - 1)) {
                longest = Math.max(longest, i - firstSumIndex.get(sum - 1));
            }
            if (!firstSumIndex.containsKey(sum)) {
                firstSumIndex.put(sum, i);
            }
        }
    }
    return longest;
}


-----
import java.util.HashMap;

public int longestWellPerformingInterval(int[] hours) 
    // Your code here
}


************************************
Question ID: 1125

import java.util.*;

public List<Integer> smallestSufficientTeam(String[] req_skills, List<List<String>> people) {
    Map<String, Integer> skillToId = new HashMap<>();
    int idx = 0;
    for (String skill : req_skills) {
        skillToId.put(skill, idx++);
    }

    int n = people.size(), m = req_skills.length;
    int[] dp = new int[1 << m];
    int[] pre = new int[1 << m];
    int[] skillSet = new int[1 << m];

    Arrays.fill(dp, Integer.MAX_VALUE / 2);
    dp[0] = 0;

    for (int i = 0; i < n; ++i) {
        int skillMask = 0;
        for (String skill : people.get(i)) {
            skillMask |= 1 << skillToId.get(skill);
        }
        for (int j = (1 << m) - 1; j >= 0; --j) {
            if (dp[j | skillMask] > dp[j] + 1) {
                dp[j | skillMask] = dp[j] + 1;
                pre[j | skillMask] = j;
                skillSet[j | skillMask] = i;
            }
        }
    }

    List<Integer> res = new ArrayList<>();
    int mask = (1 << m) - 1;
    while (mask != 0) {
        res.add(skillSet[mask]);
        mask = pre[mask];
    }

    return res;
}


-----
import java.util.*;

public List<Integer> smallestSufficientTeam(String[] req_skills, List<List<String>> people) 
    // Your code here
}


************************************
Question ID: 1128

public String removeDuplicates(String s) {
    StringBuilder sb = new StringBuilder();
    for (char c : s.toCharArray()) {
        if (sb.length() > 0 && sb.charAt(sb.length() - 1) == c) {
            sb.setLength(sb.length() - 1);
        } else {
            sb.append(c);
        }
    }
    return sb.toString();
}

-----
public String removeDuplicates(String s) 
    // Your code here
}

************************************
Question ID: 1129

import java.util.Arrays;
import java.util.HashMap;

public int longestStrChain(String[] words) {
    Arrays.sort(words, (a, b) -> a.length() - b.length());
    HashMap<String, Integer> dp = new HashMap<>();

    int maxLen = 0;
    for (String word : words) {
        for (int i = 0; i < word.length(); ++i) {
            String pre = word.substring(0, i) + word.substring(i + 1);
            dp.put(word, Math.max(dp.getOrDefault(word, 0), dp.getOrDefault(pre, 0) + 1));
        }
        maxLen = Math.max(maxLen, dp.get(word));
    }

    return maxLen;
}

-----
import java.util.Arrays;
import java.util.HashMap;

public int longestStrChain(String[] words) 
    // Your code here
}

************************************
Question ID: 1130

public int lastStoneWeight(int[] stones) {
    PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
    for (int stone : stones) {
        pq.add(stone);
    }
    while (pq.size() > 1) {
        int x = pq.poll();
        int y = pq.poll();
        if (x != y) {
            pq.add(y - x);
        }
    }
    return pq.isEmpty() ? 0 : pq.peek();
}

-----
public int lastStoneWeight(int[] stones) 
    // Your code here
}

************************************
Question ID: 1131

public int maxAbsValExpr(int[] arr1, int[] arr2) {
    int result = 0;
    int[] max_sum = new int[]{Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE};

    for (int i = 0; i < arr1.length; ++i) {
        max_sum[0] = Math.max(max_sum[0], arr1[i] + arr2[i] + i);
        max_sum[1] = Math.max(max_sum[1], arr1[i] - arr2[i] + i);
        max_sum[2] = Math.max(max_sum[2], -arr1[i] + arr2[i] + i);
        max_sum[3] = Math.max(max_sum[3], -arr1[i] - arr2[i] + i);
    }

    for (int i = 0; i < arr1.length; ++i) {
        result = Math.max(result, max_sum[0] - arr1[i] - arr2[i] - i);
        result = Math.max(result, max_sum[1] - arr1[i] + arr2[i] - i);
        result = Math.max(result, max_sum[2] + arr1[i] - arr2[i] - i);
        result = Math.max(result, max_sum[3] + arr1[i] + arr2[i] - i);
    }

    return result;
}

-----
public int maxAbsValExpr(int[] arr1, int[] arr2) 
    // Your code here
}

************************************
Question ID: 1133

String lastSubstring(String s) {
    int i = 0, j = 1, k = 0, n = s.length();
    while (j + k < n) {
        if (s.charAt(i + k) == s.charAt(j + k)) {
            k++;
        } else if (s.charAt(i + k) < s.charAt(j + k)) {
            i = j;
            j++;
            k = 0;
        } else {
            j++;
            k = 0;
        }
    }
    return s.substring(i);
}

-----
String lastSubstring(String s) 
    // Your code here
}

************************************
Question ID: 1134

public boolean isArmstrong(int n) {
    int power_sum = 0;
    int original = n;
    int k = String.valueOf(n).length();
    while (n > 0) {
        int digit = n % 10;
        power_sum += Math.pow(digit, k);
        n /= 10;
    }
    return power_sum == original;
}

-----
public boolean isArmstrong(int n) 
    // Your code here
}

************************************
Question ID: 1135

import java.util.Arrays;
import java.util.Comparator;

public int find(int[] parent, int x) {
    if (parent[x] != x) {
        parent[x] = find(parent, parent[x]);
    }
    return parent[x];
}

public int minimumCost(int n, int[][] connections) {
    Arrays.sort(connections, Comparator.comparingInt(a -> a[2]));

    int[] parent = new int[n + 1];
    for (int i = 1; i <= n; ++i) {
        parent[i] = i;
    }

    int cost = 0;
    int edges = 0;
    for (int[] connection : connections) {
        int root_x = find(parent, connection[0]);
        int root_y = find(parent, connection[1]);

        if (root_x != root_y) {
            parent[root_y] = root_x;
            cost += connection[2];
            edges += 1;
        }

        if (edges == n - 1) {
            break;
        }
    }

    return edges == n - 1 ? cost : -1;
}

-----
import java.util.Arrays;
import java.util.Comparator;

public int find(int[] parent, int x) 
    // Your code here
}

************************************
Question ID: 1136

public int minimumSemesters(int n, int[][] relations) {
    int[] in_degree = new int[n + 1];
    List<List<Integer>> graph = new ArrayList<>();

    for (int i = 0; i <= n; i++) {
        graph.add(new ArrayList<>());
    }

    for (int[] relation : relations) {
        graph.get(relation[0]).add(relation[1]);
        in_degree[relation[1]]++;
    }

    Queue<Integer> q = new LinkedList<>();
    for (int i = 1; i <= n; i++) {
        if (in_degree[i] == 0) {
            q.offer(i);
        }
    }

    int semesters = 0;
    while (!q.isEmpty()) {
        int size = q.size();
        semesters++;
        for (int i = 0; i < size; i++) {
            int course = q.poll();
            n--;

            for (int next : graph.get(course)) {
                if (--in_degree[next] == 0) {
                    q.offer(next);
                }
            }
        }
    }

    return n == 0 ? semesters : -1;
}

-----
public int minimumSemesters(int n, int[][] relations) 
    // Your code here
}

************************************
Question ID: 1137

import java.util.Arrays;

public int heightChecker(int[] heights) {
    int[] expected = heights.clone();
    Arrays.sort(expected);
    int count = 0;
    for (int i = 0; i < heights.length; i++) {
        if (heights[i] != expected[i]) {
            count++;
        }
    }
    return count;
}

-----
import java.util.Arrays;

public int heightChecker(int[] heights) 
    // Your code here
}

************************************
Question ID: 1138

public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {
    int total = 0, maxIncrease = 0, windowIncrease = 0;
    for (int i = 0, j = 0; i < customers.length; ++i) {
        if (i - j == minutes) {
            windowIncrease -= customers[j] * grumpy[j];
            ++j;
        }
        windowIncrease += customers[i] * grumpy[i];
        total += customers[i] * (1 - grumpy[i]);
        maxIncrease = Math.max(maxIncrease, windowIncrease);
    }
    return total + maxIncrease;
}

-----
public int maxSatisfied(int[] customers, int[] grumpy, int minutes) 
    // Your code here
}

************************************
Question ID: 1139

public int[] prevPermOpt1(int[] arr) {
    int n = arr.length;
    for (int i = n - 2; i >= 0; i--) {
        if (arr[i] > arr[i + 1]) {
            int j = i + 1;
            while (j < n && arr[j] < arr[i]) j++;
            int temp = arr[i];
            arr[i] = arr[j - 1];
            arr[j - 1] = temp;
            return arr;
        }
    }
    return arr;
}

-----
public int[] prevPermOpt1(int[] arr) 
    // Your code here
}

************************************
Question ID: 1140

import java.util.*;

public int[] rearrangeBarcodes(int[] barcodes) {
    int n = barcodes.length;
    int[] count = new int[10001];
    for (int i = 0; i < n; i++) {
        count[barcodes[i]]++;
    }

    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[1] - a[1]);
    for (int i = 1; i <= 10000; i++) {
        if (count[i] > 0) {
            pq.offer(new int[]{i, count[i]});
        }
    }

    int index = 0;
    while (!pq.isEmpty()) {
        int[] curr = pq.poll();
        while (curr[1] > 0) {
            barcodes[index] = curr[0];
            curr[1]--;
            index += 2;
            if (index >= n) {
                index = 1;
            }
        }
    }
    return barcodes;
}

-----
import java.util.*;

public int[] rearrangeBarcodes(int[] barcodes) 
    // Your code here
}

************************************
Question ID: 1143

public int longestCommonSubsequence(String text1, String text2) {
    int m = text1.length();
    int n = text2.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}

-----
public int longestCommonSubsequence(String text1, String text2) 
    // Your code here
}

************************************
Question ID: 1144

public int movesToMakeZigzag(int[] nums) {
    int evenMoves = 0, oddMoves = 0;
    for (int i = 0; i < nums.length; i++) {
        int left = i > 0 ? nums[i - 1] : 1001;
        int right = i < nums.length - 1 ? nums[i + 1] : 1001;
        int minValue = Math.min(left, right);
        if (nums[i] >= minValue) {
            if (i % 2 == 0) {
                evenMoves += nums[i] - minValue + 1;
            } else {
                oddMoves += nums[i] - minValue + 1;
            }
        }
    }
    return Math.min(evenMoves, oddMoves);
}

-----
public int movesToMakeZigzag(int[] nums) 
    // Your code here
}

************************************
Question ID: 1146

public String gcdOfStrings(String str1, String str2) {
    if (!(str1 + str2).equals(str2 + str1)) {
        return "";
    }
    int gcd = gcd(str1.length(), str2.length());
    return str1.substring(0, gcd);
}

private int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}


-----
public String gcdOfStrings(String str1, String str2) 
    // Your code here
}


************************************
Question ID: 1147

import java.util.HashMap;
import java.util.Map;

public int maxEqualRowsAfterFlips(int[][] matrix) {
    Map<String, Integer> count = new HashMap<>();
    for (int[] row : matrix) {
        StringBuilder row_str = new StringBuilder();
        int first = row[0];
        for (int val : row) {
            row_str.append(first == 1 ? 1 - val : val);
        }
        count.put(row_str.toString(), count.getOrDefault(row_str.toString(), 0) + 1);
    }
    int res = 0;
    for (int value : count.values()) {
        res = Math.max(res, value);
    }
    return res;
}

-----
import java.util.HashMap;
import java.util.Map;

public int maxEqualRowsAfterFlips(int[][] matrix) 
    // Your code here
}

************************************
Question ID: 1150

boolean isMajorityElement(int[] nums, int target) {
    int count = 0;
    for (int num : nums) {
        if (num == target) count++;
        if (count > nums.length / 2) return true;
    }
    return false;
}

-----
boolean isMajorityElement(int[] nums, int target) 
    // Your code here
}

************************************
Question ID: 1151

public int minSwaps(int[] data) {
    int ones = 0;
    for (int d : data) {
        ones += d;
    }
    int cur_ones = 0, max_ones = 0;
    for (int i = 0; i < data.length; i++) {
        cur_ones += data[i];
        if (i >= ones) {
            cur_ones -= data[i - ones];
        }
        max_ones = Math.max(max_ones, cur_ones);
    }
    return ones - max_ones;
}


-----
public int minSwaps(int[] data) 
    // Your code here
}


************************************
Question ID: 1152

import java.util.*;

class Solution {
    public List<String> mostVisitedPattern(String[] username, int[] timestamp, String[] website) {
        int n = username.length;
        List<String[]> visitingOrder = new ArrayList<>();
        HashMap<String, List<Tuple<Integer, Integer>>> userVisits = new HashMap<>();

        for (int i = 0; i < n; i++) {
            userVisits.putIfAbsent(username[i], new ArrayList<>());
            userVisits.get(username[i]).add(new Tuple<>(timestamp[i], i));
        }
        
        for (Map.Entry<String, List<Tuple<Integer, Integer>>> entry : userVisits.entrySet()) {
            Collections.sort(entry.getValue(), (a, b) -> a.x - b.x);
            int m = entry.getValue().size();
            for (int i = 0; i < m; i++) {
                for (int j = i + 1; j < m; j++) {
                    for (int k = j + 1; k < m; k++) {
                        visitingOrder.add(new String[] {website[entry.getValue().get(i).y], website[entry.getValue().get(j).y], website[entry.getValue().get(k).y]});
                    }
                }
            }
        }
        
        Collections.sort(visitingOrder, (a, b) -> {
           for (int i = 0; i < 3; i++) {
               int cmp = a[i].compareTo(b[i]);
               if (cmp != 0) {
                   return cmp;
               }
           }
           return 0;
        });
        
        List<String> ans = Arrays.asList(visitingOrder.get(0));
        int maxScore = 0, score = 1;

        for (int i = 1; i < visitingOrder.size(); i++) {
            if (Arrays.equals(visitingOrder.get(i), visitingOrder.get(i - 1))) {
                score++;
            } else {
                score = 1;
            }
            
            if (score > maxScore) {
                maxScore = score;
                ans = Arrays.asList(visitingOrder.get(i));
            }
        }
        
        return ans;
    }

    private static class Tuple<X, Y> {
        X x;
        Y y;

        Tuple(X x, Y y) {
            this.x = x;
            this.y = y;
        }
    }
}


-----
import java.util.*;

class Solution 
    // Your code here
}


************************************
Question ID: 1153

boolean canConvert(String str1, String str2) {
    if (str1.equals(str2)) return true;
    HashMap<Character, Character> conversion = new HashMap<>();
    for (int i = 0; i < str1.length(); ++i) {
        if (conversion.containsKey(str1.charAt(i)) && conversion.get(str1.charAt(i)) != str2.charAt(i)) {
            return false;
        }
        conversion.put(str1.charAt(i), str2.charAt(i));
    }
    return new HashSet<Character>(Arrays.asList(str2.toCharArray())).size() < 26;
}


-----
boolean canConvert(String str1, String str2) 
    // Your code here
}


************************************
Question ID: 1154

public int dayOfYear(String date) {
    int[] daysInMonth = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
    int year = Integer.parseInt(date.substring(0, 4));
    int month = Integer.parseInt(date.substring(5, 7));
    int day = Integer.parseInt(date.substring(8, 10));

    if (isLeapYear(year)) {
        daysInMonth[1] = 29;
    }

    int result = 0;
    for (int i = 0; i < month - 1; ++i) {
        result += daysInMonth[i];
    }

    return result + day;
}

public boolean isLeapYear(int year) {
    return ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);
}


-----
public int dayOfYear(String date) 
    // Your code here
}


************************************
Question ID: 1155

public int numRollsToTarget(int n, int k, int target) {
    int MOD = 1000000007;
    int[][] dp = new int[n + 1][target + 1];
    dp[0][0] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = i; j <= target; j++) {
            for (int d = 1; d <= k && j - d >= 0; d++) {
                dp[i][j] = (dp[i][j] + dp[i - 1][j - d]) % MOD;
            }
        }
    }
    return dp[n][target];
}

-----
public int numRollsToTarget(int n, int k, int target) 
    // Your code here
}

************************************
Question ID: 1156

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<String> findThirdWords(String text, String first, String second) {
    List<String> result = new ArrayList<>();
    String[] words = text.split(" ");
    
    for (int i = 0; i < words.length - 2; i++) {
        if (words[i].equals(first) && words[i + 1].equals(second)) {
            result.add(words[i + 2]);
        }
    }
    
    return result;
}

-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<String> findThirdWords(String text, String first, String second) 
    // Your code here
}

************************************
Question ID: 1160

public int numTilePossibilities(String tiles) {
    int[] freq = new int[26];
    for (char c : tiles.toCharArray()) {
        freq[c - 'A']++;
    }

    return numTilePossibilities(freq);
}

private int numTilePossibilities(int[] freq) {
    int result = 0;
    for (int i = 0; i < 26; i++) {
        if (freq[i] > 0) {
            freq[i]--;
            result += 1 + numTilePossibilities(freq);
            freq[i]++;
        }
    }
    return result;
}

-----
public int numTilePossibilities(String tiles) 
    // Your code here
}

************************************
Question ID: 1162

import java.util.LinkedList;
import java.util.Queue;

public int maxDistance(int[][] grid) {
    int distance = -1;
    Queue<int[]> waterCells = new LinkedList<>();
    int n = grid.length;

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 1) {
                waterCells.add(new int[] {i, j});
            }
        }
    }

    if (waterCells.size() == 0 || waterCells.size() == n * n) {
        return distance;
    }

    int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    while (!waterCells.isEmpty()) {
        int size = waterCells.size();
        while (size-- > 0) {
            int[] cell = waterCells.poll();
            int x = cell[0], y = cell[1];
            for (int[] dir : directions) {
                int newX = x + dir[0], newY = y + dir[1];
                if (newX >= 0 && newX < n && newY >= 0 && newY < n && grid[newX][newY] == 0) {
                    grid[newX][newY] = 1;
                    waterCells.add(new int[] {newX, newY});
                }
            }
        }
        distance++;
    }

    return distance - 1;
}


-----
import java.util.LinkedList;
import java.util.Queue;

public int maxDistance(int[][] grid) 
    // Your code here
}


************************************
Question ID: 1163

public String lastSubstring(String s) {
    int maxIndex = 0;
    int curIndex = 1;
    while (curIndex < s.length()) {
        int i = 0;
        while (curIndex + i < s.length() && s.charAt(maxIndex + i) == s.charAt(curIndex + i)) {
            i++;
        }
        if (curIndex + i == s.length()) break;
        if (s.charAt(maxIndex + i) < s.charAt(curIndex + i)) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    return s.substring(maxIndex);
}

-----
public String lastSubstring(String s) 
    // Your code here
}

************************************
Question ID: 1165

public int calculateTime(String keyboard, String word) {
    int time = 0;
    int prevIndex = 0;
    Map<Character, Integer> charToIndex = new HashMap<>();

    for (int i = 0; i < keyboard.length(); i++) {
        charToIndex.put(keyboard.charAt(i), i);
    }

    for (char c : word.toCharArray()) {
        time += Math.abs(charToIndex.get(c) - prevIndex);
        prevIndex = charToIndex.get(c);
    }

    return time;
}

-----
public int calculateTime(String keyboard, String word) 
    // Your code here
}

************************************
Question ID: 1167

import java.util.PriorityQueue;

public int connectSticks(int[] sticks) {
    PriorityQueue<Integer> minHeap = new PriorityQueue<>();
    
    for (int stick : sticks) {
        minHeap.offer(stick);
    }
    
    int cost = 0;
    while (minHeap.size() > 1) {
        int first = minHeap.poll();
        int second = minHeap.poll();
        cost += first + second;
        minHeap.offer(first + second);
    }
    return cost;
}

-----
import java.util.PriorityQueue;

public int connectSticks(int[] sticks) 
    // Your code here
}

************************************
Question ID: 1168

public void duplicateZeros(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        if (arr[i] == 0) {
            for (int j = n - 2; j > i; j--) {
                arr[j + 1] = arr[j];
            }
            arr[i + 1] = 0;
            i++;
        }
    }
}

-----
public void duplicateZeros(int[] arr) 
    // Your code here
}

************************************
Question ID: 1169

import java.util.*;

class Solution {
    public int largestValsFromLabels(int[] values, int[] labels, int numWanted, int useLimit) {
        List<Item> items = new ArrayList<>();
        for (int i = 0; i < values.length; i++) {
            items.add(new Item(values[i], labels[i]));
        }
        Collections.sort(items, Collections.reverseOrder());

        Map<Integer, Integer> labelCount = new HashMap<>();
        int result = 0;
        for (Item item : items) {
            if (!labelCount.containsKey(item.label)) {
                labelCount.put(item.label, 0);
            }
            if (labelCount.get(item.label) < useLimit && numWanted > 0) {
                result += item.value;
                labelCount.put(item.label, labelCount.get(item.label) + 1);
                numWanted--;
            }
        }

        return result;
    }

    private static class Item implements Comparable<Item> {
        int value;
        int label;

        Item(int value, int label) {
            this.value = value;
            this.label = label;
        }

        @Override
        public int compareTo(Item o) {
            return Integer.compare(this.value, o.value);
        }
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 1170

public class Main {
    public static String shortestCommonSupersequence(String str1, String str2) {
        int m = str1.length();
        int n = str2.length();
        int[][] dp = new int[m + 1][n + 1];

        for (int i = 0; i <= m; i++) {
            for (int j = 0; j <= n; j++) {
                if (i == 0) {
                    dp[i][j] = j;
                } else if (j == 0) {
                    dp[i][j] = i;
                } else if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                } else {
                    dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        int i = m, j = n;
        StringBuilder result = new StringBuilder();

        while (i > 0 && j > 0) {
            if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
                result.append(str1.charAt(i - 1));
                i--;
                j--;
            } else if (dp[i - 1][j] > dp[i][j - 1]) {
                j--;
                result.append(str2.charAt(j));
            } else {
                i--;
                result.append(str1.charAt(i));
            }
        }

        while (i > 0) {
            result.append(str1.charAt(i - 1));
            i--;
        }

        while (j > 0) {
            result.append(str2.charAt(j - 1));
            j--;
        }

        return result.reverse().toString();
    }
}

-----
public class Main 
    // Your code here
}

************************************
Question ID: 1171

import java.util.*;

public int shortestPathBinaryMatrix(int[][] grid) {
    int n = grid.length;
    if (grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;
    Queue<int[]> q = new LinkedList<>();
    int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};
    q.offer(new int[]{0, 0});
    grid[0][0] = 1;
    int steps = 1;

    while (!q.isEmpty()) {
        int size = q.size();
        for (int i = 0; i < size; ++i) {
            int[] cell = q.poll();
            int x = cell[0];
            int y = cell[1];
            
            if (x == n - 1 && y == n - 1) return steps;
            
            for (int[] dir : dirs) {
                int newX = x + dir[0];
                int newY = y + dir[1];

                if (newX >= 0 && newX < n && newY >= 0 && newY < n && grid[newX][newY] == 0) {
                    q.offer(new int[]{newX, newY});
                    grid[newX][newY] = 1;
                }
            }
        }
        steps++;
    }

    return -1;
}

-----
import java.util.*;

public int shortestPathBinaryMatrix(int[][] grid) 
    // Your code here
}

************************************
Question ID: 1175

public int numPrimeArrangements(int n) {
    boolean[] isPrime = new boolean[n + 1];
    Arrays.fill(isPrime, true);
    isPrime[0] = false;
    isPrime[1] = false;
    for (int i = 2; i * i <= n; i++) {
        if (isPrime[i]) {
            for (int j = i * i; j <= n; j += i) {
                isPrime[j] = false;
            }
        }
    }
    
    int primeCount = 0;
    for (int i = 2; i <= n; i++) {
        if (isPrime[i]) primeCount++;
    }
    int compositeCount = n - primeCount;
    
    long res = 1;
    int MOD = 1000000007;
    for (int i = 1; i <= primeCount; i++) {
        res = res * i % MOD;
    }
    for (int i = 1; i <= compositeCount; i++) {
        res = res * i % MOD;
    }
    return (int) res;
}

-----
public int numPrimeArrangements(int n) 
    // Your code here
}

************************************
Question ID: 1176

public int dietPlanPerformance(int[] calories, int k, int lower, int upper) {
    int points = 0;
    int T = 0;

    for(int i = 0; i < calories.length; i++) {
        T += calories[i];
        if(i >= k) {
            T -= calories[i-k];
        }
        if(i >= k-1) {
            if(T < lower) points--;
            if(T > upper) points++;
        }
    }

    return points;
}

-----
public int dietPlanPerformance(int[] calories, int k, int lower, int upper) 
    // Your code here
}

************************************
Question ID: 1177

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<Boolean> canMakePaliQueries(String s, int[][] queries) {
    List<Boolean> answer = new ArrayList<>();
    int[] prefixSum = new int[s.length() + 1];

    for (int i = 0; i < s.length(); ++i) {
        prefixSum[i + 1] = prefixSum[i] ^ (1 << (s.charAt(i) - 'a'));
    }

    for (int[] query : queries) {
        int left = query[0], right = query[1], k = query[2];
        int diffCount = Integer.bitCount(prefixSum[right + 1] ^ prefixSum[left]);
        answer.add((diffCount / 2) <= k);
    }

    return answer;
}


-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<Boolean> canMakePaliQueries(String s, int[][] queries) 
    // Your code here
}


************************************
Question ID: 1178

import java.util.*;

public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {
    List<Integer> result = new ArrayList<>();
    for (String puzzle : puzzles) {
        int count = 0;
        Set<Character> puzzleSet = new HashSet<>();
        for (char c : puzzle.toCharArray()) {
            puzzleSet.add(c);
        }
        for (String word : words) {
            if (word.indexOf(puzzle.charAt(0)) >= 0) {
                if (word.chars().allMatch(c -> puzzleSet.contains((char) c))) {
                    count++;
                }
            }
        }
        result.add(count);
    }
    return result;
}


-----
import java.util.*;

public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) 
    // Your code here
}


************************************
Question ID: 1180

public int countLetters(String s) {
    int count = 0, current = 1;

    for (int i = 1; i < s.length(); i++) {
        if (s.charAt(i) == s.charAt(i - 1)) {
            current++;
        } else {
            count += (current * (current + 1)) / 2;
            current = 1;
        }
    }

    count += (current * (current + 1)) / 2;
    return count;
}

-----
public int countLetters(String s) 
    // Your code here
}

************************************
Question ID: 1181

import java.util.*;

public List<String> beforeAndAfterPuzzles(String[] phrases) {
    Map<String, Set<String>> firstWordMap = new HashMap<>();
    Set<String> result = new TreeSet<>();

    for (String phrase : phrases) {
        String firstWord = phrase.substring(0, phrase.indexOf(' '));
        firstWordMap.putIfAbsent(firstWord, new HashSet<>());
        firstWordMap.get(firstWord).add(phrase);
    }

    for (String phrase : phrases) {
        String lastWord = phrase.substring(phrase.lastIndexOf(' ') + 1);
        if (firstWordMap.containsKey(lastWord)) {
            for (String curPhrase : firstWordMap.get(lastWord)) {
                if (!phrase.equals(curPhrase)) {
                    result.add(phrase + curPhrase.substring(curPhrase.indexOf(' ')));
                }
            }
        }
    }

    return new ArrayList<>(result);
}

-----
import java.util.*;

public List<String> beforeAndAfterPuzzles(String[] phrases) 
    // Your code here
}

************************************
Question ID: 1182

import java.util.ArrayList;
import java.util.List;

public List<Integer> shortestDistance(int[] colors, int[][] queries) {
    List<Integer> result = new ArrayList<>();
    List<List<Integer>> positions = new ArrayList<>(3);

    for (int i = 0; i < 3; i++) {
        positions.add(new ArrayList<>());
    }

    for (int i = 0; i < colors.length; i++) {
        positions.get(colors[i] - 1).add(i);
    }

    for (int[] query : queries) {
        List<Integer> indexPositions = positions.get(query[1] - 1);

        if (indexPositions.isEmpty()) {
            result.add(-1);
        } else {
            int dist = Integer.MAX_VALUE;

            for (int pos : indexPositions) {
                dist = Math.min(dist, Math.abs(pos - query[0]));
            }

            result.add(dist);
        }
    }

    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<Integer> shortestDistance(int[] colors, int[][] queries) 
    // Your code here
}

************************************
Question ID: 1183

public double[] sampleStats(int[] count) {
    double minVal = -1, maxVal = -1, mode = 0, median = 0, mean = 0;
    long totalCount = 0, modeCount = 0, curCount = 0;
    double sum = 0;

    for (int i = 0; i <= 255; i++) {
        if (count[i] > 0) {
            if (minVal == -1) minVal = i;
            maxVal = i;
            sum += (double) i * count[i];
            totalCount += count[i];
            if (count[i] > modeCount) {
                modeCount = count[i];
                mode = i;
            }
        }
    }

    mean = sum / totalCount;
    boolean isEven = (totalCount % 2 == 0);
    long mid1 = totalCount / 2, mid2 = mid1 - 1;
    if (isEven) mid2++;

    for (int i = 0; i <= 255; i++) {
        curCount += count[i];
        if (isEven && curCount >= mid2) {
            median += i;
            mid2 = totalCount;
            isEven = false;
        }

        if (curCount >= mid1) {
            median += i;
            break;
        }
    }

    if (!isEven) median /= 2;
    return new double[]{minVal, maxVal, mean, median, mode};
}

-----
public double[] sampleStats(int[] count) 
    // Your code here
}

************************************
Question ID: 1184

import java.util.Map;
import java.util.TreeMap;

public boolean carPooling(int[][] trips, int capacity) {
    Map<Integer, Integer> stops = new TreeMap<>();
    for (int[] t : trips) {
        stops.put(t[1], stops.getOrDefault(t[1], 0) + t[0]);
        stops.put(t[2], stops.getOrDefault(t[2], 0) - t[0]);
    }
    for (int passengers : stops.values()) {
        capacity -= passengers;
        if (capacity < 0) {
            return false;
        }
    }
    return true;
}

-----
import java.util.Map;
import java.util.TreeMap;

public boolean carPooling(int[][] trips, int capacity) 
    // Your code here
}

************************************
Question ID: 1185

import java.time.LocalDate;

public String dayOfTheWeek(int day, int month, int year) {
    LocalDate date = LocalDate.of(year, month, day);
    int dayOfWeekIndex = date.getDayOfWeek().getValue() % 7;
    String[] days = {"Sunday ", "Monday ", "Tuesday ", "Wednesday ", "Thursday ", "Friday ", "Saturday "};
    return days[dayOfWeekIndex];
}

-----
import java.time.LocalDate;

public String dayOfTheWeek(int day, int month, int year) 
    // Your code here
}

************************************
Question ID: 1186

import java.util.concurrent.Semaphore;

class H2O {
    private Semaphore hydrogenSemaphore = new Semaphore(2);
    private Semaphore oxygenSemaphore = new Semaphore(1);

    public void hydrogen(Runnable releaseHydrogen) throws InterruptedException {
        hydrogenSemaphore.acquire();
        releaseHydrogen.run();
        oxygenSemaphore.release();
    }

    public void oxygen(Runnable releaseOxygen) throws InterruptedException {
        oxygenSemaphore.acquire();
        releaseOxygen.run();
        hydrogenSemaphore.release(2);
    }
}

-----
import java.util.concurrent.Semaphore;

class H2O 
    // Your code here
}

************************************
Question ID: 1187

import java.util.concurrent.*;

class FooBar {
    private int n;
    private Semaphore fooSemaphore = new Semaphore(1);
    private Semaphore barSemaphore = new Semaphore(0);

    public FooBar(int n) {
        this.n = n;
    }

    public void foo(Runnable printFoo) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            fooSemaphore.acquire();
            printFoo.run();
            barSemaphore.release();
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            barSemaphore.acquire();
            printBar.run();
            fooSemaphore.release();
        }
    }
}

-----
import java.util.concurrent.*;

class FooBar 
    // Your code here
}

************************************
Question ID: 1189

public int maxNumberOfBalloons(String text) {
    int[] letter_count = new int[5];
    for (char c : text.toCharArray()) {
        if (c == 'b') letter_count[0]++;
        if (c == 'a') letter_count[1]++;
        if (c == 'l') letter_count[2]++;
        if (c == 'o') letter_count[3]++;
        if (c == 'n') letter_count[4]++;
    }
    letter_count[2] /= 2;
    letter_count[3] /= 2;
    return Arrays.stream(letter_count).min().getAsInt();
}

-----
public int maxNumberOfBalloons(String text) 
    // Your code here
}

************************************
Question ID: 1190

import java.util.Stack;

public String reverseParentheses(String s) {
    Stack<Integer> stack = new Stack<>();
    StringBuilder result = new StringBuilder(s);
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '(') {
            stack.push(i);
        } else if (s.charAt(i) == ')') {
            int start = stack.pop();
            int end = i;
            result.replace(start, end + 1, new StringBuilder(s.substring(start + 1, end)).reverse().toString());
            s = result.toString();
            i -= 2;
        }
    }
    for (int i = 0; i < result.length(); i++) {
        if (result.charAt(i) == '(' || result.charAt(i) == ')') {
            result.deleteCharAt(i);
            i--;
        }
    }
    return result.toString();
}

-----
import java.util.Stack;

public String reverseParentheses(String s) 
    // Your code here
}

************************************
Question ID: 1191

public int kConcatenationMaxSum(int[] arr, int k) {
    long mod = (long) 1e9 + 7, n = arr.length;
    long sum = 0, maxSum = 0, tempSum = 0, maxLeft = 0, maxRight = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
        tempSum += arr[i];
        maxSum = Math.max(maxSum, tempSum);
        tempSum = Math.max(0, tempSum);
        maxLeft = Math.max(maxLeft, sum);
    }

    long temp = sum;
    for (int i = n - 1; i >= 0; i--) {
        temp -= arr[i];
        maxRight = Math.max(maxRight, temp);
    }

    long ans = Math.max(maxSum, maxLeft + maxRight + sum * (k - 2));
    return (int) (ans % mod);
}

-----
public int kConcatenationMaxSum(int[] arr, int k) 
    // Your code here
}

************************************
Question ID: 1192

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {
    List<List<Integer>> result = new ArrayList<>();
    Map<Integer, List<Integer>> graph = new HashMap<>();
    for (List<Integer> connection : connections) {
        graph.putIfAbsent(connection.get(0), new ArrayList<>());
        graph.putIfAbsent(connection.get(1), new ArrayList<>());
        graph.get(connection.get(0)).add(connection.get(1));
        graph.get(connection.get(1)).add(connection.get(0));
    }
    int[] rank = new int[n];
    for (int i = 0; i < n; i++) {
        rank[i] = -1;
    }
    dfs(0, -1, 0, rank, graph, result);
    return result;
}

private void dfs(int node, int parent, int depth, int[] rank, Map<Integer, List<Integer>> graph, List<List<Integer>> result) {
    rank[node] = depth;
    for (int neighbor : graph.get(node)) {
        if (neighbor == parent) {
            continue;
        }
        if (rank[neighbor] == -1) {
            dfs(neighbor, node, depth + 1, rank, graph, result);
        }
        rank[node] = Math.min(rank[node], rank[neighbor]);
        if (rank[neighbor] == depth + 1) {
            result.add(List.of(node, neighbor));
        }
    }
}


-----
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) 
    // Your code here
}


************************************
Question ID: 1196

public int minHeightShelves(int[][] books, int shelfWidth) {
    int n = books.length;
    int[] dp = new int[n + 1];
    Arrays.fill(dp, 1000000);
    dp[0] = 0;
    
    for (int i = 1; i <= n; i++) {
        int width = 0, height = 0;
        for (int j = i; j >= 1; j--) {
            width += books[j - 1][0];
            height = Math.max(height, books[j - 1][1]);
            
            if (width <= shelfWidth)
                dp[i] = Math.min(dp[i], dp[j - 1] + height);
        }
    }
    
    return dp[n];
}

-----
public int minHeightShelves(int[][] books, int shelfWidth) 
    // Your code here
}

************************************
Question ID: 1197

public boolean parseBoolExpr(String expression, int[] pos) {
    char current = expression.charAt(pos[0]++);
    switch (current) {
        case 't': return true;
        case 'f': return false;
        case '!': return !parseBoolExpr(expression, ++pos);
        case '&': {
            pos[0]++;
            boolean result = true;
            while (expression.charAt(pos[0]) != ')') {
                result &= parseBoolExpr(expression, pos);
                if(expression.charAt(pos[0]) == ',') pos[0]++;
            }
            pos[0]++;
            return result;
        }
        case '|': {
            pos[0]++;
            boolean result = false;
            while (expression.charAt(pos[0]) != ')') {
                result |= parseBoolExpr(expression, pos);
                if(expression.charAt(pos[0]) == ',') pos[0]++;
            }
            pos[0]++;
            return result;
        }
    }
    return false;
}

public boolean parseBoolExpr(String expression) {
    int[] pos = new int[] {0};
    return parseBoolExpr(expression, pos);
}

-----
public boolean parseBoolExpr(String expression, int[] pos) 
    // Your code here
}

************************************
Question ID: 1198

public int smallestCommonElement(int[][] mat) {
    HashMap<Integer, Integer> counts = new HashMap<>();
    for (int[] row : mat) {
        for (int num : row) {
            counts.put(num, counts.getOrDefault(num, 0) + 1);
            if (counts.get(num) == mat.length) {
                return num;
            }
        }
    }
    return -1;
}

-----
public int smallestCommonElement(int[][] mat) 
    // Your code here
}

************************************
Question ID: 1199

import java.util.PriorityQueue;

public int minBuildTime(int[] blocks, int split) {
    PriorityQueue<Integer> pq = new PriorityQueue<>();
    
    for (int block : blocks) {
        pq.add(block);
    }
    
    while (pq.size() > 1) {
        int a = pq.poll();
        int b = pq.poll();
        pq.add(b + split);
    }
    
    return pq.poll();
}

-----
import java.util.PriorityQueue;

public int minBuildTime(int[] blocks, int split) 
    // Your code here
}

************************************
Question ID: 1200

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<List<Integer>> minimumAbsDifference(int[] arr) {
    Arrays.sort(arr);
    int minDiff = Integer.MAX_VALUE;
    for (int i = 1; i < arr.length; i++) {
        minDiff = Math.min(minDiff, arr[i] - arr[i - 1]);
    }

    List<List<Integer>> result = new ArrayList<>();
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] - arr[i - 1] == minDiff) {
            result.add(Arrays.asList(arr[i - 1], arr[i]));
        }
    }

    return result;
}

-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<List<Integer>> minimumAbsDifference(int[] arr) 
    // Your code here
}

************************************
Question ID: 1201

public int nthUglyNumber(int n, int a, int b, int c) {
    long left = 1, right = (long) 2e9, gcd_ab = gcd(a, b), gcd_ac = gcd(a, c), gcd_bc = gcd(b, c);
    long lcm_ab = a / gcd_ab * b, lcm_ac = a / gcd_ac * c, lcm_bc = b / gcd_bc * c, lcm_abc = a / gcd_ab * lcm_bc;
    
    while (left < right) {
        long mid = left + (right - left) / 2;
        long count = mid / a + mid / b + mid / c - mid / lcm_ab - mid / lcm_ac - mid / lcm_bc + mid / lcm_abc;
        if (count < n) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return (int) left;
}

private long gcd(long a, long b) {
    return b == 0 ? a : gcd(b, a % b);
}

-----
public int nthUglyNumber(int n, int a, int b, int c) 
    // Your code here
}

************************************
Question ID: 1202

import java.util.*;

class Solution {
    public String smallestStringWithSwaps(String s, int[][] pairs) {
        int n = s.length();
        int[] p = new int[n];

        for (int i = 0; i < n; i++) {
            p[i] = i;
        }

        for (int[] pair : pairs) {
            int root1 = find(pair[0], p);
            int root2 = find(pair[1], p);
            if (root1 != root2) {
                p[root2] = root1;
            }
        }

        Map<Integer, PriorityQueue<Character>> groups = new HashMap<>();
        for (int i = 0; i < n; i++) {
            int root = find(i, p);
            groups.computeIfAbsent(root, k -> new PriorityQueue<>()).add(s.charAt(i));
        }

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            int root = find(i, p);
            sb.append(groups.get(root).poll());
        }

        return sb.toString();
    }

    private int find(int x, int[] p) {
        if (p[x] != x) {
            p[x] = find(p[x], p);
        }

        return p[x];
    }
}


-----
import java.util.*;

class Solution 
    // Your code here
}


************************************
Question ID: 1203

import java.util.concurrent.atomic.AtomicInteger;

class Foo {
    private AtomicInteger order = new AtomicInteger(1);

    public Foo() {}

    public void first() {
        synchronized(this) {
            // printFirst() outputs "first". Do not change or remove this line.
            printFirst();
            order.set(2);
            this.notifyAll();
        }
    }

    public void second() {
        synchronized(this) {
            while (order.get() != 2) {
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
            // printSecond() outputs "second". Do not change or remove this line.
            printSecond();
            order.set(3);
            this.notifyAll();
        }
    }

    public void third() {
        synchronized(this) {
            while (order.get() != 3) {
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
            // printThird() outputs "third". Do not change or remove this line.
            printThird();
        }
    }
}

-----
import java.util.concurrent.atomic.AtomicInteger;

class Foo 
    // Your code here
}

************************************
Question ID: 1206

public int[] corpFlightBookings(int[][] bookings, int n) {
    int[] answer = new int[n];
    for (int[] booking : bookings) {
        answer[booking[0] - 1] += booking[2];
        if (booking[1] < n) {
            answer[booking[1]] -= booking[2];
        }
    }
    for (int i = 1; i < n; i++) {
        answer[i] += answer[i - 1];
    }
    return answer;
}

-----
public int[] corpFlightBookings(int[][] bookings, int n) 
    // Your code here
}

************************************
Question ID: 1208

public int[] splitString(String seq) {
    int[] result = new int[seq.length()];
    int count = 0;

    for (int i = 0; i < seq.length(); ++i) {
        if (seq.charAt(i) == '(') {
            result[i] = count % 2;
            count++;
        } else {
            count--;
            result[i] = count % 2;
        }
    }

    return result;
}


-----
public int[] splitString(String seq) 
    // Your code here
}


************************************
Question ID: 1209

public String removeDuplicates(String s, int k) {
    Stack<int[]> stack = new Stack<>();
    for (char c : s.toCharArray()) {
        if (stack.isEmpty() || stack.peek()[0] != c) {
            stack.push(new int[]{c, 1});
        } else if (++stack.peek()[1] == k) {
            stack.pop();
        }
    }
    StringBuilder result = new StringBuilder();
    while (!stack.isEmpty()) {
        int[] elem = stack.pop();
        for (int i = 0; i < elem[1]; i++) {
            result.append((char) elem[0]);
        }
    }
    return result.reverse().toString();
}


-----
public String removeDuplicates(String s, int k) 
    // Your code here
}


************************************
Question ID: 1210

import java.util.Arrays;

public double trimmedMean(int[] arr) {
    int n = arr.length;
    int remove = (int) (n * 0.05);
    Arrays.sort(arr);
    double sum = 0.0;
    for (int i = remove; i < n - remove; i++) {
        sum += arr[i];
    }
    return sum / (n - 2 * remove);
}

-----
import java.util.Arrays;

public double trimmedMean(int[] arr) 
    // Your code here
}

************************************
Question ID: 1213

import java.util.ArrayList;
import java.util.List;

public List<Integer> arraysIntersection(int[] arr1, int[] arr2, int[] arr3) {
    int i = 0, j = 0, k = 0;
    ArrayList<Integer> result = new ArrayList<>();
    while (i < arr1.length && j < arr2.length && k < arr3.length) {
        if (arr1[i] == arr2[j] && arr2[j] == arr3[k]) {
            result.add(arr1[i]);
            i++; j++; k++;
        } else {
            if (arr1[i] <= arr2[j] && arr1[i] <= arr3[k]) i++;
            else if (arr2[j] <= arr3[k]) j++;
            else k++;
        }
    }
    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<Integer> arraysIntersection(int[] arr1, int[] arr2, int[] arr3) 
    // Your code here
}

************************************
Question ID: 1215

import java.util.ArrayList;
import java.util.List;

public List<Integer> countSteppingNumbers(int low, int high) {
    List<Integer> results = new ArrayList<>();
    for (int i = low; i <= high; i++) {
        int prev = -1;
        int j = i;
        boolean isStepping = true;
        while (j > 0) {
            int digit = j % 10;
            if (prev != -1 && Math.abs(prev - digit) != 1) {
                isStepping = false;
                break;
            }
            prev = digit;
            j /= 10;
        }
        if (isStepping) results.add(i);
    }
    return results;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<Integer> countSteppingNumbers(int low, int high) 
    // Your code here
}

************************************
Question ID: 1216

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.IntConsumer;

class ZeroEvenOdd {
    private int n;
    private int cnt;
    private Lock lock;
    private Condition condition;
    
    public ZeroEvenOdd(int n) {
        this.n = n;
        cnt = 1;
        lock = new ReentrantLock();
        condition = lock.newCondition();
    }

    public void zero(IntConsumer printNumber) throws InterruptedException {
        for(int i = 1; i <= n; i++) {
            lock.lock();
            try {
                while (cnt % 2 == 0)
                    condition.await();
                printNumber.accept(0);
                cnt++;
                condition.signalAll();
            } finally {
                lock.unlock();
            }
        }
    }

    public void even(IntConsumer printNumber) throws InterruptedException {
        for(int i = 2; i <= n; i+=2) {
            lock.lock();
            try {
                while (cnt != 2 * i)
                    condition.await();
                printNumber.accept(i);
                cnt++;
                condition.signalAll();
            } finally {
                lock.unlock();
            }
        }
    }

    public void odd(IntConsumer printNumber) throws InterruptedException {
        for(int i = 1; i <= n; i+=2) {
            lock.lock();
            try {
                while (cnt != 2 * i - 1)
                    condition.await();
                printNumber.accept(i);
                cnt++;
                condition.signalAll();
            } finally {
                lock.unlock();
            }
        }
    }
}

-----
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.IntConsumer;

class ZeroEvenOdd 
    // Your code here
}

************************************
Question ID: 1217

public void sortArray(int[] arr1, int[] arr2) {
    HashMap<Integer, Integer> counts = new HashMap<>();

    for (int num : arr1) {
        counts.put(num, counts.getOrDefault(num, 0) + 1);
    }

    int index = 0;
    for (int num : arr2) {
        while (counts.get(num) > 0) {
            arr1[index++] = num;
            counts.put(num, counts.get(num) - 1);
        }
    }

    Arrays.sort(arr1, index, arr1.length);
}

-----
public void sortArray(int[] arr1, int[] arr2) 
    // Your code here
}

************************************
Question ID: 1219

import java.util.HashMap;

public int longestWPI(int[] hours) {
    int score = 0;
    int maxLength = 0;
    HashMap<Integer, Integer> firstOccurrence = new HashMap<>();

    for (int i = 0; i < hours.length; ++i) {
        score += hours[i] > 8 ? 1 : -1;
        if (score > 0) maxLength = i + 1;
        else {
            firstOccurrence.putIfAbsent(score, i);
            if (firstOccurrence.containsKey(score - 1))
                maxLength = Math.max(maxLength, i - firstOccurrence.get(score - 1));
        }
    }
    return maxLength;
}


-----
import java.util.HashMap;

public int longestWPI(int[] hours) 
    // Your code here
}


************************************
Question ID: 1220

import java.util.*;

class Solution {
    public int[] smallestSufficientTeam(String[] req_skills, List<List<String>> people) {
        Map<String, Integer> index = new HashMap<>();
        int num_skills = req_skills.length;
        for (int i = 0; i < num_skills; i++) {
            index.put(req_skills[i], i);
        }
        
        List<Integer> sks = new ArrayList<>();
        for (int i = 0; i < people.size(); i++) {
            int cur = 0;
            for (String s : people.get(i)) {
                cur |= 1 << index.get(s);
            }
            sks.add(cur);
        }

        int INF = 64;
        int[] dp = new int[1 << num_skills];
        int[] parent = new int[1 << num_skills];
        Arrays.fill(dp, INF);
        dp[0] = 0;
        
        for (int i = 0; i < people.size(); i++) {
            int hiskills = sks.get(i);
            for (int done = (1 << num_skills) - 1; done >= 0; done--) {
                int withhim = done | hiskills;
                if (dp[withhim] > dp[done] + 1) {
                    dp[withhim] = dp[done] + 1;
                    parent[withhim] = done;
                }
            }
        }
        
        int[] ans = new int[dp[(1 << num_skills) - 1]];
        int cur = (1 << num_skills) - 1;
        int t = dp[(1 << num_skills) - 1] - 1;
        
        for (int i = people.size() - 1; i >= 0; i--) {
            int old = parent[cur];
            int diff = cur ^ old;
            boolean isEssential = (sks.get(i) & diff) > 0;
            if (isEssential) {
                ans[t] = i;
                t--;
            }
            cur = old;
        }
        return ans;
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 1221

public int findSpecialInteger(int[] arr) {
    int n = arr.length, requiredCount = n / 4;
    for (int i = 0; i < n; i++) {
        if (arr[i] == arr[i + requiredCount]) {
            return arr[i];
        }
    }
    return -1;
}

-----
public int findSpecialInteger(int[] arr) 
    // Your code here
}

************************************
Question ID: 1222

public int removeCoveredIntervals(int[][] intervals) {
    Arrays.sort(intervals, (a, b) -> {
        if (a[0] == b[0]) return b[1] - a[1];
        return a[0] - b[0];
    });
    
    int count = 0, end = 0;
    for (int[] interval : intervals) {
        if (interval[1] > end) {
            count++;
            end = interval[1];
        }
    }
    return count;
}


-----
public int removeCoveredIntervals(int[][] intervals) 
    // Your code here
}


************************************
Question ID: 1223

import java.util.Arrays;
import java.util.function.Function;
import java.util.function.BiConsumer;

public boolean[] areConnected(int n, int threshold, int[][] queries) {
    boolean[] answer = new boolean[queries.length];
    int[] parent = new int[n + 1];
    int[] rank = new int[n + 1];

    for (int i = 1; i <= n; i++) {
        parent[i] = i;
    }

    Function<Integer, Integer> find = x -> {
        if (parent[x] != x)
            parent[x] = find.apply(parent[x]);
        return parent[x];
    };

    BiConsumer<Integer, Integer> unite = (x, y) -> {
        int rootx = find.apply(x);
        int rooty = find.apply(y);
        if (rootx != rooty) {
            if (rank[rootx] > rank[rooty]) {
                int temp = rootx;
                rootx = rooty;
                rooty = temp;
            }
            parent[rootx] = rooty;
            if (rank[rootx] == rank[rooty])
                rank[rooty]++;
        }
    };

    for (int i = threshold + 1; i <= n; i++) {
        for (int j = 2 * i; j <= n; j += i) {
            unite.accept(i, j);
        }
    }

    for (int i = 0; i < queries.length; i++) {
        answer[i] = find.apply(queries[i][0]) == find.apply(queries[i][1]);
    }

    return answer;
}

-----
import java.util.Arrays;
import java.util.function.Function;
import java.util.function.BiConsumer;

public boolean[] areConnected(int n, int threshold, int[][] queries) 
    // Your code here
}

************************************
Question ID: 1224

import java.util.Arrays;

class Solution {
    public int minFallingPathSum(int[][] grid) {
        int n = grid.length;
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < n; j++) {
                int minVal = Integer.MAX_VALUE;
                for (int k = 0; k < n; k++) {
                    if (k == j) continue;
                    minVal = Math.min(minVal, grid[i - 1][k]);
                }
                grid[i][j] += minVal;
            }
        }
        return Arrays.stream(grid[n - 1]).min().getAsInt();
    }
}

-----
import java.util.Arrays;

class Solution 
    // Your code here
}

************************************
Question ID: 1227

import java.util.*;

public int numEquivDominoPairs(int[][] dominoes) {
    Map<Integer, Integer> freq = new HashMap<>();
    int result = 0;
    for (int[] domino : dominoes) {
        int key = Math.min(domino[0], domino[1]) * 10 + Math.max(domino[0], domino[1]);
        result += freq.getOrDefault(key, 0);
        freq.put(key, freq.getOrDefault(key, 0) + 1);
    }
    return result;
}

-----
import java.util.*;

public int numEquivDominoPairs(int[][] dominoes) 
    // Your code here
}

************************************
Question ID: 1228

public int mctFromLeafValues(int[] arr) {
    int n = arr.length;
    int[][] dp = new int[n][n];
    int[][] maxs = new int[n][n];

    for (int i = 0; i < n; ++i) {
        for (int j = i; j < n; ++j) {
            maxs[i][j] = Arrays.stream(arr, i, j + 1).max().getAsInt();
        }
    }

    for (int len = 1; len < n; ++len) {
        for (int i = 0; i + len < n; ++i) {
            int j = i + len;
            dp[i][j] = Integer.MAX_VALUE;
            for (int k = i; k < j; ++k) {
                dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j] + maxs[i][k] * maxs[k + 1][j]);
            }
        }
    }
    return dp[0][n - 1];
}

-----
public int mctFromLeafValues(int[] arr) 
    // Your code here
}

************************************
Question ID: 1229

import java.util.*;

public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {
    List<List<Integer>>[] adjList = new ArrayList[n][2];

    for (int i = 0; i < n; i++) {
        adjList[i][0] = new ArrayList<>();
        adjList[i][1] = new ArrayList<>();
    }

    for (int[] edge : redEdges) {
        adjList[edge[0]][0].add(edge[1]);
    }

    for (int[] edge : blueEdges) {
        adjList[edge[0]][1].add(edge[1]);
    }

    int[][] dist = new int[n][2];
    for (int[] row : dist) {
        Arrays.fill(row, -1);
    }
    dist[0][0] = 0;
    dist[0][1] = 0;

    Queue<int[]> q = new LinkedList<>();
    q.offer(new int[]{0, 0});
    q.offer(new int[]{0, 1});

    while (!q.isEmpty()) {
        int[] cur = q.poll();
        int node = cur[0], color = cur[1];
        int next_color = color ^ 1;

        for (int neighbor : adjList[node][next_color]) {
            if (dist[neighbor][next_color] == -1) {
                dist[neighbor][next_color] = dist[node][color] + 1;
                q.offer(new int[]{neighbor, next_color});
            }
        }
    }

    int[] result = new int[n];
    for (int i = 0; i < n; i++) {
        result[i] = Math.min(dist[i][0], dist[i][1]);
        if (dist[i][0] == -1 || dist[i][1] == -1) {
            result[i] = Math.max(dist[i][0], dist[i][1]);
        }
    }
    return result;
}


-----
import java.util.*;

public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) 
    // Your code here
}


************************************
Question ID: 1230

public int maxValue(int[] arr1, int[] arr2) {
    int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE,
        max3 = Integer.MIN_VALUE, max4 = Integer.MIN_VALUE;
    int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE,
        min3 = Integer.MAX_VALUE, min4 = Integer.MAX_VALUE;
    int n = arr1.length;

    for (int i = 0; i < n; i++) {
        max1 = Math.max(max1, arr1[i] - arr2[i] + i);
        max2 = Math.max(max2, arr1[i] + arr2[i] + i);
        max3 = Math.max(max3, -arr1[i] + arr2[i] + i);
        max4 = Math.max(max4, -arr1[i] - arr2[i] + i);

        min1 = Math.min(min1, arr1[i] - arr2[i] + i);
        min2 = Math.min(min2, arr1[i] + arr2[i] + i);
        min3 = Math.min(min3, -arr1[i] + arr2[i] + i);
        min4 = Math.min(min4, -arr1[i] - arr2[i] + i);
    }
    return Math.max(Math.max(max1 - min1, max2 - min2),
            Math.max(max3 - min3, max4 - min4));
}


-----
public int maxValue(int[] arr1, int[] arr2) 
    // Your code here
}


************************************
Question ID: 1231

public int[] replaceElements(int[] arr) {
    int n = arr.length;
    int maxElement = -1;
    for (int i = n - 1; i >= 0; i--) {
        int temp = arr[i];
        arr[i] = maxElement;
        maxElement = Math.max(maxElement, temp);
    }
    return arr;
}

-----
public int[] replaceElements(int[] arr) 
    // Your code here
}

************************************
Question ID: 1232

public int findBestValue(int[] arr, int target) {
    int left = 0;
    int right = 0;
    for (int num : arr) {
        right = Math.max(right, num);
    }
    int result = -1;
    int min_diff = Integer.MAX_VALUE;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        int sum = 0;
        for (int num : arr) {
            sum += Math.min(num, mid);
        }
        if (sum == target) {
            return mid;
        }
        else if (sum > target) {
            right = mid - 1;
        }
        else {
            left = mid + 1;
        }
        if (Math.abs(target - sum) < min_diff || Math.abs(target - sum) == min_diff && mid < result) {
            min_diff = Math.abs(target - sum);
            result = mid;
        }
    }
    return result;
}

-----
public int findBestValue(int[] arr, int target) 
    // Your code here
}

************************************
Question ID: 1233

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<String> removeSubfolders(String[] folder) {
    List<String> result = new ArrayList<>();
    Arrays.sort(folder);
    String prefix = "/";
    
    for (String path : folder) {
        if (!path.startsWith(prefix)) {
            result.add(path);
            prefix = path + "/";
        }
    }
    return result;
}

-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<String> removeSubfolders(String[] folder) 
    // Your code here
}

************************************
Question ID: 1234

import java.util.*;

public class Solution {
    public int[] getMaxSumAndCount(String[] board) {
        int mod = 1000000007;
        int n = board.length;
        int[][][] dp = new int[n][n][2];
        dp[n - 1][n - 1][1] = 1;

        for (int i = n - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                if (board[i].charAt(j) == 'X' || (i == n - 1 && j == n - 1)) continue;
                int currVal = board[i].charAt(j) == 'E' ? 0 : board[i].charAt(j) - '0';
                int[] up = i > 0 ? dp[i - 1][j] : new int[]{-1, 0};
                int[] left = j > 0 ? dp[i][j - 1] : new int[]{-1, 0};
                int[] diag = i > 0 && j > 0 ? dp[i - 1][j - 1] : new int[]{-1, 0};

                int[] maxArray = getMax(up, left, diag);
                if (maxArray[0] == -1) continue;

                dp[i][j][0] = maxArray[0] + currVal;
                if (Arrays.equals(up, maxArray)) dp[i][j][1] = (dp[i][j][1] + up[1] % mod) % mod;
                if (Arrays.equals(left, maxArray)) dp[i][j][1] = (dp[i][j][1] + left[1] % mod) % mod;
                if (Arrays.equals(diag, maxArray)) dp[i][j][1] = (dp[i][j][1] + diag[1] % mod) % mod;
            }
        }
        return dp[0][0];
    }

    public int[] getMax(int[] a, int[] b, int[] c) {
        if (a[0] >= b[0] && a[0] >= c[0]) return a;
        if (b[0] >= a[0] && b[0] >= c[0]) return b;
        return c;
    }
}


-----
import java.util.*;

public class Solution 
    // Your code here
}


************************************
Question ID: 1235

import java.util.Arrays;

public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {
    int n = startTime.length;
    int[][] jobs = new int[n][3];

    for (int i = 0; i < n; i++) {
        jobs[i] = new int[] {endTime[i], startTime[i], profit[i]};
    }

    Arrays.sort(jobs, (a, b) -> a[0] - b[0]);
    int[] dp = new int[n];
    dp[0] = jobs[0][2];

    for (int i = 1; i < n; i++) {
        int L = -1;
        for (int j = i - 1; j >= 0; j--) {
            if (jobs[j][1] >= jobs[L == -1 ? i : L][0]) {
                L = j;
            }
        }
        dp[i] = Math.max(dp[i - 1], (L == -1 ? 0 : dp[L]) + jobs[i][2]);
    }

    return dp[n - 1];
}

-----
import java.util.Arrays;

public int jobScheduling(int[] startTime, int[] endTime, int[] profit) 
    // Your code here
}

************************************
Question ID: 1236

public int tribonacci(int n) {
    if(n==0) return 0;
    if(n==1 || n==2) return 1;
    int a = 0, b = 1, c = 1, d;
    for(int i = 3; i <= n; i++) {
        d = a + b + c;
        a = b;
        b = c;
        c = d;
    }
    return c;
}

-----
public int tribonacci(int n) 
    // Your code here
}

************************************
Question ID: 1237

import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> findSolution(CustomFunction customfunction, int z) {
    List<List<Integer>> results = new ArrayList<>();
    for (int x = 1; x <= 1000; x++) {
        for (int y = 1; y <= 1000; y++) {
            if (customfunction.f(x, y) == z) {
                List<Integer> pair = new ArrayList<>();
                pair.add(x);
                pair.add(y);
                results.add(pair);
            } else if (customfunction.f(x, y) > z) {
                break;
            }
        }
    }
    return results;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> findSolution(CustomFunction customfunction, int z) 
    // Your code here
}

************************************
Question ID: 1238

public String alphabetBoardPath(String target) {
    int x = 0, y = 0;
    StringBuilder sb = new StringBuilder();

    for (char c : target.toCharArray()) {
        int dx = (c - 'a') / 5;
        int dy = (c - 'a') % 5;
        while (x > dx) {
            sb.append('U');
            x--;
        }
        while (y > dy) {
            sb.append('L');
            y--;
        }
        while (x < dx) {
            sb.append('D');
            x++;
        }
        while (y < dy) {
            sb.append('R');
            y++;
        }
        sb.append('!');
    }
    return sb.toString();
}


-----
public String alphabetBoardPath(String target) 
    // Your code here
}


************************************
Question ID: 1239

public int largest1BorderedSquare(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    int[][] horizontal = new int[m][n];
    int[][] vertical = new int[m][n];

    int maxSquareSize = 0;

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 1) {
                horizontal[i][j] = (j == 0) ? 1 : horizontal[i][j - 1] + 1;
                vertical[i][j] = (i == 0) ? 1 : vertical[i - 1][j] + 1;

                int minSize = Math.min(horizontal[i][j], vertical[i][j]);
                while (minSize > maxSquareSize) {
                    if (horizontal[i - minSize + 1][j] >= minSize &&
                        vertical[i][j - minSize + 1] >= minSize) {
                        maxSquareSize = minSize;
                    }
                    minSize--;
                }
            }
        }
    }

    return maxSquareSize * maxSquareSize;
}

-----
public int largest1BorderedSquare(int[][] grid) 
    // Your code here
}

************************************
Question ID: 1240

public int stoneGameII(int[] piles) {
    int n = piles.length;
    int[][] memo = new int[n][n + 1];
    
    for (int i = n - 2 ; i >= 0; --i) {
        piles[i] += piles[i + 1];
    }

    return search(piles, 0, 1, memo);
}

private int search(int[] piles, int idx, int M, int[][] memo) {
    int n = piles.length;
    
    if (idx + 2 * M >= n) {
        return piles[idx];
    }
    
    if (memo[idx][M] > 0) {
        return memo[idx][M];
    }
    
    memo[idx][M] = 0;
    
    for (int x = 1; x <= 2 * M; ++x) {
        memo[idx][M] = Math.max(memo[idx][M], piles[idx] - search(piles, idx + x, Math.max(M, x), memo));
    }
    
    return memo[idx][M];
}

-----
public int stoneGameII(int[] piles) 
    // Your code here
}

************************************
Question ID: 1243

public int sumEvenGrandparent(TreeNode root) {
    return sumEvenGrandparent(root, null, null);
}

private int sumEvenGrandparent(TreeNode root, TreeNode parent, TreeNode grandparent) {
    if (root == null) return 0;
    int sum = 0;
    if (grandparent != null && grandparent.val % 2 == 0) {
        sum += root.val;
    }
    sum += sumEvenGrandparent(root.left, root, parent) + sumEvenGrandparent(root.right, root, parent);
    return sum;
}

-----
public int sumEvenGrandparent(TreeNode root) 
    // Your code here
}

************************************
Question ID: 1244

int numDistinctRepeatedSubstrings(String s) {
    HashSet<String> seen = new HashSet<>();
    for (int len = s.length() / 2; len >= 1; len--) {
        for (int i = 0; i <= s.length() - 2 * len; i++) {
            String substr = s.substring(i, i + len);
            if (s.indexOf(substr, i + len) != -1)
                seen.add(substr);
        }
    }
    return seen.size();
}


-----
int numDistinctRepeatedSubstrings(String s) 
    // Your code here
}


************************************
Question ID: 1245

import java.util.*;

class Solution {
    public int treeDiameter(int[][] edges) {
        Map<Integer, List<Integer>> tree = new HashMap<>();
        for (int[] edge : edges) {
            tree.computeIfAbsent(edge[0], k -> new ArrayList<>()).add(edge[1]);
            tree.computeIfAbsent(edge[1], k -> new ArrayList<>()).add(edge[0]);
        }

        Queue<int[]> queue = new LinkedList<>();
        queue.add(new int[] {0, 0});
        int furthest = 0;
        int maxDistance = 0;
        while (!queue.isEmpty()) {
            int[] info = queue.poll();
            int node = info[0];
            int distance = info[1];
            if (distance > maxDistance) {
                maxDistance = distance;
                furthest = node;
            }
            for (int neighbor : tree.get(node)) {
                tree.get(neighbor).remove((Integer)node);
                queue.add(new int[] {neighbor, distance + 1});
            }
        }

        queue.add(new int[] {furthest, 0});
        maxDistance = 0;
        while (!queue.isEmpty()) {
            int[] info = queue.poll();
            int node = info[0];
            int distance = info[1];
            if (distance > maxDistance) {
                maxDistance = distance;
            }
            for (int neighbor : tree.get(node)) {
                tree.get(neighbor).remove((Integer)node);
                queue.add(new int[] {neighbor, distance + 1});
            }
        }

        return maxDistance;
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 1246

public int minimumMoves(int[] arr) {
    int[][] dp = new int[arr.length][arr.length];
    for (int[] row : dp)
        Arrays.fill(row, -1);
    return minRemovals(arr, 0, arr.length - 1, dp);
}

private int minRemovals(int[] arr, int i, int j, int[][] dp) {
    if (i > j) return 0;
    if (i == j) return 1;
    if (dp[i][j] != -1) return dp[i][j];

    int ans = minRemovals(arr, i + 1, j, dp) + 1;
    for (int k = i + 1; k <= j; k++) {
        if (arr[i] == arr[k])
            ans = Math.min(ans, minRemovals(arr, i + 1, k - 1, dp) + minRemovals(arr, k + 1, j, dp));
    }
    return dp[i][j] = ans;
}

-----
public int minimumMoves(int[] arr) 
    // Your code here
}

************************************
Question ID: 1247

int movesToMakeZigzag(int[] nums) {
    int moves1 = 0, moves2 = 0;
    for (int i = 0; i < nums.length; i++) {
        int left = i > 0 ? nums[i - 1] : Integer.MAX_VALUE;
        int right = i + 1 < nums.length ? nums[i + 1] : Integer.MAX_VALUE;
        int diff1 = nums[i] - Math.min(left, right) + 1;
        int diff2 = nums[i] - Math.min(left, right) + 1;
        if (i % 2 == 0) {
            moves1 += Math.max(0, diff1);
        } else {
            moves2 += Math.max(0, diff2);
        }
    }
    return Math.min(moves1, moves2);
}

-----
int movesToMakeZigzag(int[] nums) 
    // Your code here
}

************************************
Question ID: 1250

class Solution {
    public boolean isGoodArray(int[] nums) {
        int res = nums[0];
        for (int num : nums) {
            res = gcd(res, num);
        }
        return res == 1;
    }
    
    private int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
}

-----
class Solution 
    // Your code here
}

************************************
Question ID: 1252

public String breakPalindrome(String palindrome) {
    int n = palindrome.length();
    if (n < 2) return "";
    
    char[] arr = palindrome.toCharArray();
    for (int i = 0; i < n / 2; i++) {
        if (arr[i] != 'a') {
            arr[i] = 'a';
            return new String(arr);
        }
    }
    
    arr[n - 1] = 'b';
    return new String(arr);
}

-----
public String breakPalindrome(String palindrome) 
    // Your code here
}

************************************
Question ID: 1253

import java.util.*;

class Solution {
    public int[][] diagonalSort(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        for (int i = 0; i < m; ++i) {
            PriorityQueue<Integer> pq = new PriorityQueue<>();
            int row = i, col = 0;
            while (row < m && col < n) {
                pq.offer(mat[row++][col++]);
            }
            row = i; col = 0;
            while (row < m && col < n) {
                mat[row++][col++] = pq.poll();
            }
        }
        for (int i = 1; i < n; ++i) {
            PriorityQueue<Integer> pq = new PriorityQueue<>();
            int row = 0, col = i;
            while (row < m && col < n) {
                pq.offer(mat[row++][col++]);
            }
            row = 0; col = i;
            while (row < m && col < n) {
                mat[row++][col++] = pq.poll();
            }
        }
        return mat;
    }
}


-----
import java.util.*;

class Solution 
    // Your code here
}


************************************
Question ID: 1254

public int closedIsland(int[][] grid) {
    int count = 0;
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[0].length; j++) {
            if (grid[i][j] == 0 && dfs(grid, i, j)) {
                count++;
            }
        }
    }
    return count;
}

private boolean dfs(int[][] grid, int i, int j) {
    if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length) {
        return false;
    }

    if (grid[i][j] == 1) {
        return true;
    }

    grid[i][j] = 1;

    boolean up = dfs(grid, i - 1, j);
    boolean down = dfs(grid, i + 1, j);
    boolean left = dfs(grid, i, j - 1);
    boolean right = dfs(grid, i, j + 1);

    return up && down && left && right;
}


-----
public int closedIsland(int[][] grid) 
    // Your code here
}


************************************
Question ID: 1255

public int maxValueAfterReverse(int[] nums) {
    int total = 0, diff = 0;
    int min2 = Integer.MAX_VALUE, max2 = Integer.MIN_VALUE;
    for (int i = 0; i < nums.length - 1; ++i) {
        total += Math.abs(nums[i] - nums[i + 1]);
        min2 = Math.min(min2, Math.max(nums[i], nums[i + 1]));
        max2 = Math.max(max2, Math.min(nums[i], nums[i + 1]));
        diff = Math.max(diff, Math.abs(nums[i + 1] - nums[0]) - Math.abs(nums[i + 1] - nums[i]));
        diff = Math.max(diff, Math.abs(nums[i] - nums[nums.length - 1]) - Math.abs(nums[i] - nums[i + 1]));
    }
    return total + Math.max(diff, 2 * (max2 - min2));
}

-----
public int maxValueAfterReverse(int[] nums) 
    // Your code here
}

************************************
Question ID: 1256

import java.util.Arrays;
import java.util.HashMap;

public int[] arrayRankTransform(int[] arr) {
    int[] sortedArr = arr.clone();
    Arrays.sort(sortedArr);
    HashMap<Integer, Integer> rankMap = new HashMap<>();
    int rank = 1;

    for(int num : sortedArr) {
        if(!rankMap.containsKey(num)) {
            rankMap.put(num, rank++);
        }
    }

    for(int i = 0; i < arr.length; i++) {
        arr[i] = rankMap.get(arr[i]);
    }

    return arr;
}

-----
import java.util.Arrays;
import java.util.HashMap;

public int[] arrayRankTransform(int[] arr) 
    // Your code here
}

************************************
Question ID: 1257

import java.util.*;
import javafx.util.Pair;
class Solution {
    public int[][] matrixRankTransform(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        int[][] rank = new int[m][n];
        int[] sorted_row = new int[m], sorted_col = new int[n];
    
        for (int bound=0; bound<=200000; bound++) {
            Queue<Pair<Integer, Integer>> q = new LinkedList<>();
            for (int i = 0; i<m; ++i)
                for (int j = 0; j<n; ++j)
                    if (matrix[i][j] == bound && rank[i][j] == 0) q.add(new Pair<>(i, j));
    
            if (q.isEmpty()) break;
            for (Pair<Integer, Integer> rc; !q.isEmpty(); q.poll()) {
                int r = rc.getKey();
                int c = rc.getValue();
                int potential_rank = sorted_row[r] + 1;
                for (Pair<Integer, Integer> neighbour: neighbours(r, c, m, n)) {
                    int row = neighbour.getKey();
                    int col = neighbour.getValue();
                    if (matrix[row][col] <= matrix[r][c])
                        potential_rank = Math.max(potential_rank, rank[row][col] + (matrix[row][col] < matrix[r][c] ? 0 : 1));
                }
                if (potential_rank == sorted_col[c] + 1) {
                    rank[r][c] = sorted_row[r] = sorted_col[c] = potential_rank;
                } else {
                    q.add(rc);
                }
            }
        }
        return rank;
    }
    
    private List<Pair<Integer, Integer>> neighbours(int r, int c, int m, int n) {
        List<Pair<Integer, Integer>> res = new ArrayList<>();
        for (int i=0; i<m; ++i) if (i != r) res.add(new Pair<>(i, c));
        for (int i=0; i<n; ++i) if (i != c) res.add(new Pair<>(r, i));
        return res;
    }
}

-----
import java.util.*;
import javafx.util.Pair;
class Solution 
    // Your code here
}

************************************
Question ID: 1258

import java.util.*;

public List<String> generateSentences(List<List<String>> synonyms, String text) {
    Map<String, Set<String>> synonymMap = new HashMap<>();

    for (List<String> synPair : synonyms) {
        synonymMap.putIfAbsent(synPair.get(0), new HashSet<>());
        synonymMap.putIfAbsent(synPair.get(1), new HashSet<>());
        synonymMap.get(synPair.get(0)).add(synPair.get(1));
        synonymMap.get(synPair.get(1)).add(synPair.get(0));
    }

    String[] words = text.split(" ");
    List<String> result = new ArrayList<>();
    generateSentencesHelper(0, words, synonymMap, result, new StringBuilder());
    Collections.sort(result);

    return result;
}

private void generateSentencesHelper(int index, String[] words, Map<String, Set<String>> synonyms, List<String> result, StringBuilder curSentence) {
    if (index == words.length) {
        result.add(curSentence.toString());
    } else {
        Set<String> synSet = synonyms.getOrDefault(words[index], new HashSet<>());
        synSet.add(words[index]);

        int prevLength = curSentence.length();
        for (String syn : synSet) {
            if (prevLength > 0) {
                curSentence.append(" ");
            }
            curSentence.append(syn);

            generateSentencesHelper(index + 1, words, synonyms, result, curSentence);

            curSentence.setLength(prevLength);
        }
    }
}


-----
import java.util.*;

public List<String> generateSentences(List<List<String>> synonyms, String text) 
    // Your code here
}


************************************
Question ID: 1259

public int numberOfWays(int numPeople) {
    int MOD = 1000000007;
    int[] dp = new int[numPeople / 2 + 1];
    dp[0] = 1;
    for (int i = 1; i <= numPeople / 2; ++i) {
        for (int j = 1; j <= i; ++j) {
            dp[i] = (dp[i] + (int)(((long) dp[i - j] * dp[j - 1]) % MOD )) % MOD;
        }
    }
    return dp[numPeople / 2];
}


-----
public int numberOfWays(int numPeople) 
    // Your code here
}


************************************
Question ID: 1260

public int dayOfYear(String date) {
    int year = Integer.parseInt(date.substring(0, 4));
    int month = Integer.parseInt(date.substring(5, 7));
    int day = Integer.parseInt(date.substring(8, 10));

    int[] daysInMonth = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {
        daysInMonth[2] = 29;
    }

    int dayOfYear = 0;
    for (int i = 1; i < month; i++) {
        dayOfYear += daysInMonth[i];
    }
    dayOfYear += day;

    return dayOfYear;
}

-----
public int dayOfYear(String date) 
    // Your code here
}

************************************
Question ID: 1262

import java.util.*;

class MajorityChecker {
    Map<Integer, List<Integer>> positions;
    int[] arr;

    public MajorityChecker(int[] arr) {
        this.arr = arr;
        positions = new HashMap<>();
        for(int i = 0; i < arr.length; i++) {
            positions.computeIfAbsent(arr[i], x -> new ArrayList<>()).add(i);
        }
    }

    public int query(int left, int right, int threshold) {
        Random rnd = new Random();
        for(int i = 0; i < 20; i++) {
            int randomIndex = rnd.nextInt(right - left + 1) + left;
            int num = positions.get(arr[randomIndex]).size();
            if (num >= threshold) {
                int lb = Collections.binarySearch(positions.get(arr[randomIndex]), left);
                int ub = Collections.binarySearch(positions.get(arr[randomIndex]), right + 1);
                if(lb < 0) lb = ~lb;
                if(ub < 0) ub = ~ub;
                if(ub - lb >= threshold) return arr[randomIndex];
            }
        }
        return -1;
    }
}  

-----
import java.util.*;

class MajorityChecker 
    // Your code here
}  

************************************
Question ID: 1263

public int numRollsToTarget(int n, int k, int target) {
    final int MOD = 1000000007;
    int[][] dp = new int[n+1][target+1];
    dp[0][0] = 1;
    
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= target; ++j) {
            for (int l = 1; l <= k; ++l) {
                if (j >= l) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - l]) % MOD;
                }
            }
        }
    }
    return dp[n][target];
}

-----
public int numRollsToTarget(int n, int k, int target) 
    // Your code here
}

************************************
Question ID: 1265

public void printLinkedListInReverse(ImmutableListNode head) {
    if (head != null) {
        printLinkedListInReverse(head.getNext());
        head.printValue();
    }
}

-----
public void printLinkedListInReverse(ImmutableListNode head) 
    // Your code here
}

************************************
Question ID: 1266

public int minTimeToVisitAllPoints(int[][] points) {
    int time = 0;
    for (int i = 1; i < points.length; i++) {
        int dx = Math.abs(points[i][0] - points[i - 1][0]);
        int dy = Math.abs(points[i][1] - points[i - 1][1]);
        time += Math.max(dx, dy);
    }
    return time;
}

-----
public int minTimeToVisitAllPoints(int[][] points) 
    // Your code here
}

************************************
Question ID: 1267

public ListNode removeZeroSumSublists(ListNode head) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode current = dummy;

    while (current != null) {
        int sum = 0;
        while (head != null) {
            sum += head.val;
            if (sum == 0) {
                current.next = head.next;
            }
            head = head.next;
        }
        current = current.next;
        if (current != null) {
            head = current.next;
        }
    }

    return dummy.next;
}


-----
public ListNode removeZeroSumSublists(ListNode head) 
    // Your code here
}


************************************
Question ID: 1268

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<List<String>> suggestedProducts(String[] products, String searchWord) {
    List<List<String>> result = new ArrayList<>();
    Arrays.sort(products);
    
    for (int i = 0; i < searchWord.length(); ++i) {
        List<String> suggestions = new ArrayList<>();
        for (String product : products) {
            if (product.length() > i && product.charAt(i) == searchWord.charAt(i)) {
                suggestions.add(product);
                if (suggestions.size() == 3) break;
            }
        }
        result.add(suggestions);
    }
    
    return result;
}


-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<List<String>> suggestedProducts(String[] products, String searchWord) 
    // Your code here
}


************************************
Question ID: 1269

final int mod = 1000000007;

public int numOfWays(int steps, int arrLen) {
  int maxPos = Math.min(steps / 2, arrLen - 1);
  int[][] dp = new int[2][maxPos + 1];
  dp[0][0] = 1;
  for (int s = 1; s <= steps; ++s) {
    for (int p = 0; p <= maxPos; ++p) {
      dp[s % 2][p] = dp[(s - 1) % 2][p];
      if (p > 0)
        dp[s % 2][p] += dp[(s - 1) % 2][p - 1];
      if (p < maxPos)
        dp[s % 2][p] += dp[(s - 1) % 2][p + 1];
      dp[s % 2][p] %= mod;
    }
  }
  return dp[steps % 2][0];
}


-----
final int mod = 1000000007;

public int numOfWays(int steps, int arrLen) 
    // Your code here
}


************************************
Question ID: 1271

public String toHexspeak(String num) {
    long n = Long.parseLong(num);
    StringBuilder hex = new StringBuilder();
    while (n != 0) {
        int rem = (int)(n % 16);
        if (rem == 1) hex.insert(0, 'I');
        else if (rem == 0) hex.insert(0, 'O');
        else if (rem > 9) hex.insert(0, (char)(rem - 10 + 'A'));
        else return "ERROR";
        n /= 16;
    }
    return hex.toString();
}

-----
public String toHexspeak(String num) 
    // Your code here
}

************************************
Question ID: 1272

import java.util.*;

public List<String> invalidTransactions(String[] transactions) {
    Map<String, List<String[]>> trans_map = new HashMap<>();

    for (String trans : transactions) {
        String[] temp = trans.split(",");
        trans_map.putIfAbsent(temp[0], new ArrayList<>());
        trans_map.get(temp[0]).add(temp);
    }

    List<String> ans = new ArrayList<>();

    for (String trans : transactions) {
        String[] temp = trans.split(",");
        
        if (Integer.parseInt(temp[2]) > 1000) {
            ans.add(trans);
            continue;
        }

        List<String[]> others = trans_map.get(temp[0]);

        for (String[] other : others) {
            if (!other[3].equals(temp[3]) && Math.abs(Integer.parseInt(other[1]) - Integer.parseInt(temp[1])) <= 60) {
                ans.add(trans);
                break;
            }
        }
    }

    return ans;
}


-----
import java.util.*;

public List<String> invalidTransactions(String[] transactions) 
    // Your code here
}


************************************
Question ID: 1273

import java.util.Arrays;

public int[] countSmallerFrequencies(String[] words, String[] queries) {
    int[] freqWords = new int[words.length];
    
    for (int i = 0; i < words.length; i++) {
        char minChar = words[i].chars().min().getAsInt();
        freqWords[i] = (int) words[i].chars().filter(c -> c == minChar).count();
    }
    
    int[] ans = new int[queries.length];
    for (int i = 0; i < queries.length; i++) {
        char minChar = queries[i].chars().min().getAsInt();
        int freqQuery = (int) queries[i].chars().filter(c -> c == minChar).count();
        
        ans[i] = (int) Arrays.stream(freqWords).filter(f -> f > freqQuery).count();
    }

    return ans;
}

-----
import java.util.Arrays;

public int[] countSmallerFrequencies(String[] words, String[] queries) 
    // Your code here
}

************************************
Question ID: 1274

import java.time.LocalDate;
import java.time.temporal.ChronoUnit;

public int countDaysBetweenDates(String date1, String date2) {
    LocalDate localDate1 = LocalDate.parse(date1);
    LocalDate localDate2 = LocalDate.parse(date2);
    return (int)ChronoUnit.DAYS.between(localDate1, localDate2);
}

-----
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;

public int countDaysBetweenDates(String date1, String date2) 
    // Your code here
}

************************************
Question ID: 1275

public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {
    int[] parent = new int[n];
    Arrays.fill(parent, -1);
    for (int i = 0; i < n; i++) {
        if (leftChild[i] != -1) {
            if (parent[leftChild[i]] != -1) return false;
            parent[leftChild[i]] = i;
        }
        if (rightChild[i] != -1) {
            if (parent[rightChild[i]] != -1) return false;
            parent[rightChild[i]] = i;
        }
    }
    int root = -1;
    for (int i = 0; i < n; i++) {
        if (parent[i] == -1) {
            if (root != -1) return false;
            root = i;
        }
    }
    return root != -1;
}

-----
public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) 
    // Your code here
}

************************************
Question ID: 1276

public int[] closestFactors(int num) {
    int factor1 = (int) Math.sqrt(num + 2);
    while (true) {
        int factor2 = (num + 2) / factor1;
        if (factor1 * factor2 == num + 2) {
            return new int[] {factor1, factor2};
        }
        factor2 = (num + 1) / factor1;
        if (factor1 * factor2 == num + 1) {
            return new int[] {factor1, factor2};
        }
        factor1--;
    }
}

-----
public int[] closestFactors(int num) 
    // Your code here
}

************************************
Question ID: 1277

import java.util.*;

public String largestMultipleOfThree(int[] digits) {
    int sum = 0, count[] = new int[3];
    
    for (int d : digits) {
        sum += d;
        count[d % 3]++;
    }

    if (sum % 3 == 1) {
        if (count[1] >= 1) count[1]--; 
        else count[2] -= 2;
    }
    else if (sum % 3 == 2) {
        if (count[2] >= 1) count[2]--;
        else count[1] -= 2;
    }

    StringBuilder res = new StringBuilder();
    for (int i = 0; i <= 9; ++i) {
        int n = count[i % 3];
        while (n-- > 0) res.append(i);
    }

    if (res.length() != 0 && res.charAt(res.length() - 1) == '0') return "0";
    return res.reverse().toString();
}

-----
import java.util.*;

public String largestMultipleOfThree(int[] digits) 
    // Your code here
}

************************************
Question ID: 1278

public int palindromePartition(String s, int k) {
    int n = s.length();
    int[][] dp = new int[n][n];

    for (int len = 2; len <= n; ++len) {
        for (int i = 0; i <= n - len; ++i) {
            int j = i + len - 1;
            dp[i][j] = dp[i + 1][j - 1] + (s.charAt(i) != s.charAt(j) ? 1 : 0);
        }
    }

    int[] memo = new int[n];
    for (int i = 0; i < n; ++i) {
        if (dp[0][i] == 0) {
            memo[i] = 0;
        } else {
            memo[i] = Integer.MAX_VALUE;
            for (int j = 0; j < i; ++j) {
                memo[i] = Math.min(memo[i], memo[j] + dp[j + 1][i]);
            }
        }
    }

    return memo[memo.length - 1] + k;
}

-----
public int palindromePartition(String s, int k) 
    // Your code here
}

************************************
Question ID: 1281

import java.util.ArrayList;
import java.util.List;

public List<Boolean> canMakePaliQueries(String s, int[][] queries) {
    List<Boolean> result = new ArrayList<>();
    for (int[] query : queries) {
        int left = query[0], right = query[1], k = query[2];
        int[] count = new int[26];
        for (int i = left; i <= right; i++) {
            count[s.charAt(i) - 'a']++;
        }
        int odd_count = 0;
        for (int i = 0; i < 26; i++) {
            odd_count += count[i] % 2;
        }
        result.add(odd_count / 2 <= k);
    }
    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<Boolean> canMakePaliQueries(String s, int[][] queries) 
    // Your code here
}

************************************
Question ID: 1282

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public List<List<Integer>> groupThePeople(int[] groupSizes) {
    Map<Integer, List<Integer>> groups = new HashMap<>();
    List<List<Integer>> result = new ArrayList<>();

    for (int i = 0; i < groupSizes.length; i++) {
        groups.computeIfAbsent(groupSizes[i], k -> new ArrayList<>()).add(i);

        if (groups.get(groupSizes[i]).size() == groupSizes[i]) {
            result.add(groups.get(groupSizes[i]));
            groups.put(groupSizes[i], new ArrayList<>());
        }
    }

    return result;
}

-----
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public List<List<Integer>> groupThePeople(int[] groupSizes) 
    // Your code here
}

************************************
Question ID: 1283

import java.util.HashMap;

public class DateFormatter {

    public static String formatDate(String date) {
        HashMap<String, String> months = new HashMap<>();
        months.put("Jan", "01");
        months.put("Feb", "02");
        months.put("Mar", "03");
        months.put("Apr", "04");
        months.put("May", "05");
        months.put("Jun", "06");
        months.put("Jul", "07");
        months.put("Aug", "08");
        months.put("Sep", "09");
        months.put("Oct", "10");
        months.put("Nov", "11");
        months.put("Dec", "12");

        String[] parts = date.split(" ");
        String day = parts[0], month = parts[1], year = parts[2];
        return year + "-" + months.get(month) + "-" + day;
    }
}

-----
import java.util.HashMap;

public class DateFormatter 
    // Your code here
}

************************************
Question ID: 1284

public int sumOfDivisorsWithFourDivisors(int[] nums) {
    int sum = 0;
    for (int num : nums) {
        int divCount = 0;
        int divSum = 0;

        for (int i = 1; i * i <= num; ++i) {
            if (num % i == 0) {
                divSum += i;
                ++divCount;

                if (num / i != i) {
                    divSum += (num / i);
                    ++divCount;
                }
            }

            if (divCount > 4) {
                break;
            }
        }

        if (divCount == 4) {
            sum += divSum;
        }
    }

    return sum;
}

-----
public int sumOfDivisorsWithFourDivisors(int[] nums) 
    // Your code here
}

************************************
Question ID: 1286

public int maxSumSubsequence(int[] nums, int k) {
    int n = nums.length;
    int[] dp = new int[n];
    int result = 0;

    for (int i = 0; i < n; ++i) {
        dp[i] = nums[i];
        for (int j = Math.max(0, i - k); j < i; ++j) {
            dp[i] = Math.max(dp[i], dp[j] + nums[i]);
        }
        result = Math.max(result, dp[i]);
    }

    return result;
}

-----
public int maxSumSubsequence(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 1287

public int shortestDistance(int[] distance, int start, int destination) {
    int total_distance = 0, clockwise_distance = 0;
    
    for(int i = 0; i < distance.length; ++i) {
        total_distance += distance[i];
        if(i >= start && i < destination) {
            clockwise_distance += distance[i];
        }
    }
    
    return Math.min(clockwise_distance, total_distance - clockwise_distance);
}

-----
public int shortestDistance(int[] distance, int start, int destination) 
    // Your code here
}

************************************
Question ID: 1288

public int maximumSum(int[] arr) {
    int n = arr.length;
    int[] sumWithoutDeletion = new int[n], sumWithDeletion = new int[n];
    sumWithoutDeletion[0] = arr[0];
    sumWithDeletion[0] = 0;
    int maxSum = arr[0];

    for (int i = 1; i < n; i++) {
        sumWithoutDeletion[i] = Math.max(arr[i], sumWithoutDeletion[i - 1] + arr[i]);
        sumWithDeletion[i] = Math.max(sumWithDeletion[i - 1] + arr[i], sumWithoutDeletion[i - 1]);
        maxSum = Math.max(maxSum, Math.max(sumWithoutDeletion[i], sumWithDeletion[i]));
    }
    return maxSum;
}

-----
public int maximumSum(int[] arr) 
    // Your code here
}

************************************
Question ID: 1289

public String dayOfTheWeek(int day, int month, int year) {
    String[] days = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
    if (month < 3) {
        month += 12;
        year -= 1;
    }
    int k = year % 100;
    int j = year / 100;
    int dayOfWeek = (day + 13 * (month + 1) / 5 + k + k / 4 + 5 * j + j / 4) % 7;
    return days[dayOfWeek];
}

-----
public String dayOfTheWeek(int day, int month, int year) 
    // Your code here
}

************************************
Question ID: 1290

public int minOperations(int[] arr1, int[] arr2) {
    int n = arr1.length;
    int[] dp = new int[n];
    Arrays.fill(dp, Integer.MAX_VALUE);
    for (int a : arr2) {
        int[] new_dp = new int[n];
        Arrays.fill(new_dp, Integer.MAX_VALUE);
        int p = 0;
        for (int i = 0; i < n; ++i) {
            if (a < arr1[i]) new_dp[i] = p;
            if (i > 0 && dp[i - 1] < p) p = dp[i - 1];
            if (arr1[i] > arr1[i + 1]) return -1;
        }
        dp = new_dp;
    }
    return dp[n - 1];
}

-----
public int minOperations(int[] arr1, int[] arr2) 
    // Your code here
}

************************************
Question ID: 1291

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public List<Integer> sequentialDigits(int low, int high) {
    List<Integer> result = new ArrayList<>();
    for (int i = 1; i <= 9; ++i) {
        int number = i;
        for (int j = i + 1; j <= 9; ++j) {
            number = number * 10 + j;
            if (number >= low && number <= high) {
                result.add(number);
            }
        }
    }
    Collections.sort(result);
    return result;
}

-----
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public List<Integer> sequentialDigits(int low, int high) 
    // Your code here
}

************************************
Question ID: 1292

public int maxSideLength(int[][] mat, int threshold) {
    int m = mat.length, n = mat[0].length;
    int[][] preSum = new int[m + 1][n + 1];
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            preSum[i][j] = mat[i - 1][j - 1] + preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1];
        }
    }

    int maxSide = 0;
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            for (int k = 1; k <= Math.min(m, n); ++k) {
                int endX = i + k - 1, endY = j + k - 1;
                if (endX <= m && endY <= n) {
                    int sum = preSum[endX][endY] - preSum[endX][j - 1] - preSum[i - 1][endY] + preSum[i - 1][j - 1];
                    if (sum <= threshold) {
                        maxSide = Math.max(maxSide, k);
                    }
                } else {
                    break;
                }
            }
        }
    }
    return maxSide;
}


-----
public int maxSideLength(int[][] mat, int threshold) 
    // Your code here
}


************************************
Question ID: 1293

import java.util.LinkedList;
import java.util.Queue;

public int shortestPath(int[][] grid, int k) {
    int m = grid.length;
    int n = grid[0].length;
    boolean[][][] visited = new boolean[m][n][k + 1];
    Queue<int[]> q  = new LinkedList<>();
    int[][] moves = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    q.offer(new int[]{0, 0, 0, k});

    int steps = 0;
    while (!q.isEmpty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            int[] tmp = q.poll();
            int x = tmp[0];
            int y = tmp[1];
            if (x == m - 1 && y == n - 1) return steps;

            for (int[] move : moves) {
                int newX = x + move[0];
                int newY = y + move[1];
                int newK = tmp[3] - grid[newX][newY];
                if (newX >= 0 && newX < m && newY >= 0 && newY < n && newK >= 0 && !visited[newX][newY][newK]) {
                    visited[newX][newY][newK] = true;
                    q.offer(new int[]{newX, newY, steps + 1, newK});
                }
            }
        }
        steps++;
    }

    return -1;
}

-----
import java.util.LinkedList;
import java.util.Queue;

public int shortestPath(int[][] grid, int k) 
    // Your code here
}

************************************
Question ID: 1295

int minPerimeter(int neededApples) {
    int layer = 0;
    int apples = 0;

    while (apples < neededApples) {
        layer++;
        apples += 12 * layer;
    }

    return 8 * layer;
}

-----
int minPerimeter(int neededApples) 
    // Your code here
}

************************************
Question ID: 1297

public int maxNumberOfBalloons(String text) {
    int[] freqs = new int[26];
    for (char c : text.toCharArray()) {
        freqs[c - 'a']++;
    }
    int[] subs = {freqs['b' - 'a'], freqs['a' - 'a'], freqs['l' - 'a'] / 2, freqs['o' - 'a'] / 2, freqs['n' - 'a']};
    return Arrays.stream(subs).min().getAsInt();
}


-----
public int maxNumberOfBalloons(String text) 
    // Your code here
}


************************************
Question ID: 1298

import java.util.Stack;

public String reverseParentheses(String s) {
    Stack<Character> st = new Stack<>();
    String result = "";

    for (char c : s.toCharArray()) {
        if (c != ')') {
            st.push(c);
        } else {
            String temp = "";
            while (!st.empty() && st.peek() != '(') {
                temp += st.pop();
            }
            if (!st.empty()) st.pop(); // Remove '('
            for (char t : temp.toCharArray()) {
                st.push(t);
            }
        }
    }

    while (!st.empty()) {
        result = st.pop() + result;
    }

    return result;
}


-----
import java.util.Stack;

public String reverseParentheses(String s) 
    // Your code here
}


************************************
Question ID: 1299

public int kConcatenationMaxSum(int[] arr, int k) {
    int M = 1_000_000_007;
    long sum = 0, maxSum = 0, curMax = 0;
    for (int i = 0; i < arr.length; i++) {
        sum += arr[i];
        curMax = Math.max(arr[i], curMax + arr[i]);
        maxSum = Math.max(maxSum, curMax);
    }
    if (k == 1) return (int)(maxSum % M);
    long twoConcatenation = 0, twoConcatenationMax = 0;
    for (int i = 0; i < 2 * arr.length; i++) {
        twoConcatenation = Math.max(arr[i % arr.length], twoConcatenation + arr[i % arr.length]);
        twoConcatenationMax = Math.max(twoConcatenationMax, twoConcatenation);
    }
    return (int)(Math.max(Math.max(maxSum, twoConcatenationMax + (k - 2) * Math.max(0, sum)), 0) % M);
}

-----
public int kConcatenationMaxSum(int[] arr, int k) 
    // Your code here
}

************************************
Question ID: 1300

import java.util.ArrayList;
import java.util.List;

public class Solution {
    private int time = 0;

    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {
        List<Integer>[] graph = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new ArrayList<>();
        }
        for (List<Integer> edge : connections) {
            graph[edge.get(0)].add(edge.get(1));
            graph[edge.get(1)].add(edge.get(0));
        }

        List<List<Integer>> ans = new ArrayList<>();
        int[] low = new int[n], disc = new int[n];
        for (int i = 0; i < n; i++) low[i] = disc[i] = -1;
        
        dfs(graph, 0, low, disc, ans, -1);

        return ans;
    }

    private void dfs(List<Integer>[] graph, int u, int[] low, int[] disc, List<List<Integer>> ans, int parent) {
        low[u] = disc[u] = time++;
        for (Integer v : graph[u]) {
            if (v == parent) continue;
            if (disc[v] == -1) {
                dfs(graph, v, low, disc, ans, u);
                low[u] = Math.min(low[u], low[v]);
                if (low[v] > disc[u]) {
                    ans.add(new ArrayList<>(List.of(u, v)));
                }
            } else {
                low[u] = Math.min(low[u], disc[v]);
            }
        }
    }
}

-----
import java.util.ArrayList;
import java.util.List;

public class Solution 
    // Your code here
}

************************************
Question ID: 1301

import java.util.Arrays;
import java.util.List;

class Solution {
    private static final int MOD = 1000000007;

    public List<Integer> pathsWithMaxScore(List<String> board) {
        int n = board.size();
        int[][] dp = new int[n][n];
        int[][] cnt = new int[n][n];
        
        board.set(0, "0" + board.get(0).substring(1));
        board.set(n-1, board.get(n-1).substring(0, n - 1) + "0");
        cnt[n-1][n-1] = 1;
        
        for (int i = n-1; i >= 0; i--) {
            for (int j = n-1; j >= 0; j--) {
                if (board.get(i).charAt(j) != 'X') {
                    int[][] neighbors = {{i-1, j}, {i, j-1}, {i-1, j-1}};
                    for (int[] neighbor : neighbors) {
                        int x = neighbor[0], y = neighbor[1];
                        if(x >= 0 && y >= 0) {
                            if (dp[i][j] < dp[x][y] + board.get(i).charAt(j) - '0') {
                                dp[i][j] = dp[x][y] + board.get(i).charAt(j) - '0';
                                cnt[i][j] = cnt[x][y];
                            } else if (dp[i][j] == dp[x][y] + board.get(i).charAt(j) - '0') {
                                cnt[i][j] = (cnt[i][j] + cnt[x][y]) % MOD;
                            }
                        }
                    }
                }
            }
        }
        
        return Arrays.asList(dp[0][0], cnt[0][0]);
    }
}


-----
import java.util.Arrays;
import java.util.List;

class Solution 
    // Your code here
}


************************************
Question ID: 1302

public String makeFancyString(String s) {
    StringBuilder result = new StringBuilder();
    int count = 1;

    for (int i = 1; i < s.length(); i++) {
        if (s.charAt(i) == s.charAt(i - 1)) {
            count++;
        } else {
            count = 1;
        }
        if (count < 3) {
            result.append(s.charAt(i));
        }
    }

    return result.toString();
}


-----
public String makeFancyString(String s) 
    // Your code here
}


************************************
Question ID: 1304

import java.util.PriorityQueue;

public String longestHappyString(int a, int b, int c) {
    StringBuilder res = new StringBuilder();
    PriorityQueue<int[]> pq = new PriorityQueue<>((x, y) -> y[0] - x[0]);

    if (a > 0) pq.offer(new int[]{a, 'a'});
    if (b > 0) pq.offer(new int[]{b, 'b'});
    if (c > 0) pq.offer(new int[]{c, 'c'});

    while (!pq.isEmpty()) {
        int[] curr = pq.poll();
        if (res.length() >= 2 && res.charAt(res.length() - 1) == curr[1] && res.charAt(res.length() - 2) == curr[1]) {
            if (pq.isEmpty()) break;
            int[] next = pq.poll();
            res.append((char) next[1]);
            if (--next[0] > 0) pq.offer(next);
            pq.offer(curr);
        } else {
            res.append((char) curr[1]);
            if (--curr[0] > 0) pq.offer(curr);
        }
    }

    return res.toString();
}


-----
import java.util.PriorityQueue;

public String longestHappyString(int a, int b, int c) 
    // Your code here
}


************************************
Question ID: 1305

import java.util.Stack;

public int[] peopleCanSee(int[] heights) {
    int n = heights.length;
    int[] ans = new int[n];
    Stack<Integer> st = new Stack<>();

    for (int i = n - 1; i >= 0; --i) {
        while (!st.isEmpty() && heights[st.peek()] < heights[i]) {
            int idx = st.pop();
            ans[i]++;
            ans[i] += ans[idx];
        }
        st.push(i);
    }

    return ans;
}


-----
import java.util.Stack;

public int[] peopleCanSee(int[] heights) 
    // Your code here
}


************************************
Question ID: 1306

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<List<Integer>> minimumAbsDifference(int[] arr) {
    Arrays.sort(arr);
    int min_difference = Integer.MAX_VALUE;
    List<List<Integer>> result = new ArrayList<>();

    for (int i = 1; i < arr.length; ++i) {
        int difference = arr[i] - arr[i - 1];
        if (difference < min_difference) {
            min_difference = difference;
            result.clear();
            result.add(Arrays.asList(arr[i - 1], arr[i]));
        } else if (difference == min_difference) {
            result.add(Arrays.asList(arr[i - 1], arr[i]));
        }
    }

    return result;
}

-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<List<Integer>> minimumAbsDifference(int[] arr) 
    // Your code here
}

************************************
Question ID: 1307

public int nthUglyNumber(int n, int a, int b, int c) {
    long ab = a * b / gcd(a, b);
    long ac = a * c / gcd(a, c);
    long bc = b * c / gcd(b, c);
    long abc = a * (b * c / gcd(b, c)) / gcd(a, (b * c / gcd(b, c)));

    long left = 0, right = 2000000000;
    while (left < right) {
        long mid = left + (right - left) / 2;
        long cnt = mid / a + mid / b + mid / c - mid / ab - mid / ac - mid / bc + mid / abc;
        if (cnt < n) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return (int)left;
}

private long gcd(long a, long b) {
    return b == 0 ? a : gcd(b, a % b);
}

-----
public int nthUglyNumber(int n, int a, int b, int c) 
    // Your code here
}

************************************
Question ID: 1309

import java.util.*;

public List<Integer> sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {
    // Calculate outdegrees and dependencies for groups and items
    int[] groupOutdegree = new int[m];
    List<List<Integer>> groupEdges = new ArrayList<>(m);
    for (int i = 0; i < m; i++) {
        groupEdges.add(new ArrayList<>());
    }

    int[] itemOutdegree = new int[n];
    List<List<Integer>> itemEdges = new ArrayList<>(n);
    for (int i = 0; i < n; i++) {
        itemEdges.add(new ArrayList<>());
    }

    for (int i = 0; i < group.length; i++) {
        for (int dep : beforeItems.get(i)) {
            int a = group[i], b = group[dep];
            if (a != -1 && a != b && !(groupEdges.get(b).size() > 0 && groupEdges.get(b).get(groupEdges.get(b).size() - 1) == a)) {
                groupEdges.get(b).add(a);
                groupOutdegree[a]++;
            }
            if (a != b) {
                itemEdges.get(dep).add(i);
                itemOutdegree[i]++;
            }
        }
    }

    // Topological sort
    List<Integer> groupOrder = topologicalSort(groupOutdegree, groupEdges);
    if (groupOrder.size() < m) {
        return new ArrayList<>();
    }

    List<Integer> itemOrder = topologicalSort(itemOutdegree, itemEdges);
    if (itemOrder.size() < n) {
        return new ArrayList<>();
    }

    // Combine orders
    List<Integer> res = new ArrayList<>();
    for (int gi : groupOrder) {
        for (int idx : itemOrder) {
            if (group[idx] == gi) {
                res.add(idx);
            }
        }
    }

    return res;
}

private List<Integer>	topologicalSort(int[] outdegree, List<List<Integer>> edges) {
    List<Integer> res = new ArrayList<>();
    Deque<Integer> queue = new LinkedList<>();
    for (int i = 0; i < outdegree.length; i++) {
        if (outdegree[i] == 0) {
            queue.offerLast(i);
        }
    }

    while (!queue.isEmpty()) {
        int u = queue.pollLast();
        res.add(u);

        for (int v : edges.get(u)) {
            if (--outdegree[v] == 0) {
                queue.offerLast(v);
            }
        }
    }

    return res;
}


-----
import java.util.*;

public List<Integer> sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) 
    // Your code here
}


************************************
Question ID: 1310

public int waterPlants(int[] plants, int capacity) {
    int steps = 0;
    int waterLeft = 0;

    for (int i = 0; i < plants.length; ++i) {
        if (waterLeft < plants[i]) {
            steps += 2 * i + 1; // Refill the watering can
            waterLeft = capacity;
        }
        waterLeft -= plants[i];
        steps++; // Move to the next plant
    }
    
    return steps;
}


-----
public int waterPlants(int[] plants, int capacity) 
    // Your code here
}


************************************
Question ID: 1311

public int largestMagicSquare(int[][] grid) {
    int m = grid.length, n = grid[0].length;
    int[][] row = new int[m][n + 1];
    int[][] col = new int[m + 1][n];
    
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            row[i][j + 1] = row[i][j] + grid[i][j];
            col[i + 1][j] = col[i][j] + grid[i][j];
        }
    }
    
    for (int k = Math.min(m, n); k > 1; --k) {
        for (int i = 0; i + k - 1 < m; ++i) {
            for (int j = 0; j + k - 1 < n; ++j) {
                int sum = row[i][j + k] - row[i][j];
                boolean ok = true;
                for (int t = 1; t < k; ++t) {
                    if (row[i + t][j + k] - row[i + t][j] != sum) {
                        ok = false;
                        break;
                    }
                    if (col[i + k][j + t] - col[i][j + t] != sum) {
                        ok = false;
                        break;
                    }
                }
                if (!ok) continue;
                
                int diag1 = 0, diag2 = 0;
                for (int t = 0; t < k; ++t) {
                    diag1 += grid[i + t][j + t];
                    diag2 += grid[i + t][j + k - 1 - t];
                }
                if (diag1 == sum && diag2 == sum) return k;
            }
        }
    }
    
    return 1;
}


-----
public int largestMagicSquare(int[][] grid) 
    // Your code here
}


************************************
Question ID: 1312

public int extractArtifacts(int n, int[][] artifacts, int[][] dig) {
    Map<Integer, Set<Integer>> artifactCells = new HashMap<>();
    Map<Integer, Integer> artifactCount = new HashMap<>();
    for (int i = 0; i < artifacts.length; i++) {
        for (int r = artifacts[i][0]; r <= artifacts[i][2]; r++) {
            for (int c = artifacts[i][1]; c <= artifacts[i][3]; c++) {
                int cell = r * n + c;
                artifactCells.computeIfAbsent(cell, k -> new HashSet<>()).add(i);
                artifactCount.put(i, artifactCount.getOrDefault(i, 0) + 1);
            }
        }
    }
    
    int ans = 0;
    for (int[] d : dig) {
        int cell = d[0] * n + d[1];
        Set<Integer> artifactsInCell = artifactCells.remove(cell);
        if (artifactsInCell != null) {
            for (int artifactId : artifactsInCell) {
                int remaining = artifactCount.get(artifactId) - 1;
                artifactCount.put(artifactId, remaining);
                if (remaining == 0) ans++;
            }
        }
    }
    return ans;
}

-----
public int extractArtifacts(int n, int[][] artifacts, int[][] dig) 
    // Your code here
}

************************************
Question ID: 1313

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Solution {
    static final int MOD = (int) 1e9 + 7;

    int addRooms(int idx, List<List<Integer>> children, int[] memo) {
        if (children.get(idx).isEmpty()) return 1;

        if (memo[idx] != -1) return memo[idx];

        long res = 1;
        int cnt = 0;
        for (int child : children.get(idx)) {
            cnt++;
            res = (res * addRooms(child, children, memo)) % MOD;
        }

        for (int i = 2; i <= cnt; i++) {
            res = (res * i) % MOD;
        }

        return memo[idx] = (int) res;
    }

    public int numOfWays(int[] prevRoom) {
        int n = prevRoom.length;
        List<List<Integer>> children = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            children.add(new ArrayList<>());
        }
        for (int i = 1; i < n; i++) {
            children.get(prevRoom[i]).add(i);
        }

        int[] memo = new int[n];
        Arrays.fill(memo, -1);
        return addRooms(0, children, memo);
    }
}

-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Solution 
    // Your code here
}

************************************
Question ID: 1314

public int[][] matrixBlockSum(int[][] mat, int k) {
    int m = mat.length;
    int n = mat[0].length;
    int[][] answer = new int[m][n];

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            for (int r = Math.max(0, i - k); r <= Math.min(m - 1, i + k); r++) {
                for (int c = Math.max(0, j - k); c <= Math.min(n - 1, j + k); c++) {
                    answer[i][j] += mat[r][c];
                }
            }
        }
    }

    return answer;
}

-----
public int[][] matrixBlockSum(int[][] mat, int k) 
    // Your code here
}

************************************
Question ID: 1317

public int[] noZeroIntegers(int n) {
    for (int a = 1; a < n; ++a) {
        if (Integer.toString(a).indexOf('0') == -1 &&
            Integer.toString(n - a).indexOf('0') == -1) {
            return new int[]{a, n - a};
        }
    }
    return new int[]{0, 0}; // never gets here
}

-----
public int[] noZeroIntegers(int n) 
    // Your code here
}

************************************
Question ID: 1318

public int minFlips(int a, int b, int c) {
    int count = 0;
    for (int i = 0; i < 32; ++i) {
        int bitA = (a >> i) & 1;
        int bitB = (b >> i) & 1;
        int bitC = (c >> i) & 1;
        if (bitC == 0) {
            count += bitA + bitB;
        } else {
            count += 1 - (bitA | bitB);
        }
    }
    return count;
}

-----
public int minFlips(int a, int b, int c) 
    // Your code here
}

************************************
Question ID: 1319

import java.util.HashMap;
import java.util.HashSet;

public boolean uniqueOccurrences(int[] arr) {
    HashMap<Integer, Integer> counts = new HashMap<>();
    for (int num : arr) {
        counts.put(num, counts.getOrDefault(num, 0) + 1);
    }
    
    HashSet<Integer> uniqueCounts = new HashSet<>();
    for (int count : counts.values()) {
        if (uniqueCounts.contains(count)) {
            return false;
        }
        uniqueCounts.add(count);
    }
    
    return true;
}

-----
import java.util.HashMap;
import java.util.HashSet;

public boolean uniqueOccurrences(int[] arr) 
    // Your code here
}

************************************
Question ID: 1320

import java.util.Stack;

public String removeDuplicates(String s, int k) {
    Stack<Pair<Character, Integer>> st = new Stack<>();
    for (char c : s.toCharArray()) {
        if (!st.isEmpty() && st.peek().getKey() == c) {
            st.peek().setValue(st.peek().getValue() + 1);
            if (st.peek().getValue() == k) st.pop();
        } else {
            st.push(new Pair<>(c, 1));
        }
    }
    StringBuilder result = new StringBuilder();
    while (!st.isEmpty()) {
        Pair<Character, Integer> top = st.pop();
        for (int i = 0; i < top.getValue(); i++) {
            result.insert(0, top.getKey());
        }
    }
    return result.toString();
}

-----
import java.util.Stack;

public String removeDuplicates(String s, int k) 
    // Your code here
}

************************************
Question ID: 1323

public int maximum69Number (int num) {
    String numStr = Integer.toString(num);
    char[] numArr = numStr.toCharArray();
    for (int i = 0; i < numArr.length; i++) {
        if (numArr[i] == '6') {
            numArr[i] = '9';
            break;
        }
    }
    return Integer.parseInt(new String(numArr));
}

-----
public int maximum69Number (int num) 
    // Your code here
}

************************************
Question ID: 1324

public int[] findBall(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    int[] result = new int[n];

    for (int i = 0; i < n; i++) {
        int x = 0, y = i;
        result[i] = -1;

        while (x < m) {
            int nx = x + 1, ny = y + grid[x][y];
            if (ny < 0 || ny >= n || grid[x][ny] != grid[x][y]) break;
            x = nx;
            y = ny;
        }

        if (x == m) {
            result[i] = y;
        }
    }

    return result;
}

-----
public int[] findBall(int[][] grid) 
    // Your code here
}

************************************
Question ID: 1325

import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;

public class Solution {
    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {
        List<List<Edge>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            graph.add(new ArrayList<>());
        }
        for (int i = 0; i < edges.length; i++) {
            graph.get(edges[i][0]).add(new Edge(edges[i][1], succProb[i]));
            graph.get(edges[i][1]).add(new Edge(edges[i][0], succProb[i]));
        }

        double[] maxProb = new double[n];
        maxProb[start] = 1;

        PriorityQueue<Edge> pq = new PriorityQueue<>((a, b) -> Double.compare(b.prob, a.prob));
        pq.offer(new Edge(start, 1));

        while (!pq.isEmpty()) {
            Edge edge = pq.poll();
            int node = edge.to;
            double prob = edge.prob;

            if (node == end) {
                return prob;
            }

            if (prob < maxProb[node]) {
                continue;
            }

            for (Edge e : graph.get(node)) {
                double newProb = prob * e.prob;
                if (newProb > maxProb[e.to]) {
                    maxProb[e.to] = newProb;
                    pq.offer(new Edge(e.to, newProb));
                }
            }
        }

        return 0;
    }

    private static class Edge {
        int to;
        double prob;

        Edge(int to, double prob) {
            this.to = to;
            this.prob = prob;
        }
    }
}


-----
import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;

public class Solution 
    // Your code here
}


************************************
Question ID: 1326

public int sumOfFlooredPairs(int[] nums) {
    int mod = 1000000007;
    int maxVal = Integer.MIN_VALUE;
    for (int num : nums) {
        maxVal = Math.max(maxVal, num);
    }
    int[] count = new int[maxVal + 1];
    long[] prefSum = new long[maxVal + 1];

    for (int num : nums) {
        count[num]++;
    }

    for (int i = 1; i <= maxVal; i++) {
        prefSum[i] = (prefSum[i - 1] + count[i]) % mod;
    }

    long res = 0;
    for (int x = 1; x <= maxVal; x++) {
        for (int k = 1, nx = x; nx <= maxVal; k++, nx += x) {
            res = (res + ((prefSum[nx] - prefSum[nx - x] + mod) % mod) * k % mod * count[x] % mod) % mod;
        }
    }
    return (int) res;
}

-----
public int sumOfFlooredPairs(int[] nums) 
    // Your code here
}

************************************
Question ID: 1328

public String breakPalindrome(String palindrome) {
    int length = palindrome.length();
    if (length == 1) return "";
    
    char[] chars = palindrome.toCharArray();
    for (int i = 0; i < length / 2; i++) {
        if (chars[i] != 'a') {
            chars[i] = 'a';
            return String.valueOf(chars);
        }
    }
    
    chars[length - 1] = 'b';
    return String.valueOf(chars);
}

-----
public String breakPalindrome(String palindrome) 
    // Your code here
}

************************************
Question ID: 1329

public int minCostToMoveChips(int[] position) {
    int evenCount = 0, oddCount = 0;
    for (int i : position) {
        if (i % 2 == 0)
            evenCount++;
        else
            oddCount++;
    }
    return Math.min(evenCount, oddCount);
}

-----
public int minCostToMoveChips(int[] position) 
    // Your code here
}

************************************
Question ID: 1330

public int longestSubsequence(int[] arr, int difference) {
    HashMap<Integer, Integer> dp = new HashMap<>();
    int maxLength = 0;
    for (int num : arr) {
        dp.put(num, dp.getOrDefault(num - difference, 0) + 1);
        maxLength = Math.max(maxLength, dp.get(num));
    }
    return maxLength;
}


-----
public int longestSubsequence(int[] arr, int difference) 
    // Your code here
}


************************************
Question ID: 1331

import java.util.Arrays;

public int getMaximumGold(int[][] grid) {
    int m = grid.length, n = grid[0].length, maxGold = 0;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] != 0) {
                maxGold = Math.max(maxGold, getMaximumGoldHelper(grid, i, j, m, n));
            }
        }
    }
    return maxGold;
}

private int getMaximumGoldHelper(int[][] grid, int x, int y, int m, int n) {
    if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0) return 0;

    int originalGold = grid[x][y];
    grid[x][y] = 0;

    int maxGold = 0;
    maxGold = Math.max(maxGold, getMaximumGoldHelper(grid, x + 1, y, m, n));
    maxGold = Math.max(maxGold, getMaximumGoldHelper(grid, x - 1, y, m, n));
    maxGold = Math.max(maxGold, getMaximumGoldHelper(grid, x, y + 1, m, n));
    maxGold = Math.max(maxGold, getMaximumGoldHelper(grid, x, y - 1, m, n));

    grid[x][y] = originalGold;
    return maxGold + originalGold;
}


-----
import java.util.Arrays;

public int getMaximumGold(int[][] grid) 
    // Your code here
}


************************************
Question ID: 1332

public int countStrings(int n) {
    int mod = 1000000007;
    long a = 1, b = 1;
    for (int i = 0; i < n; i++) {
        a = (a * 2) % mod;
        b = (b * 3) % mod;
    }
    return (int)((b - a + mod) % mod);
}


-----
public int countStrings(int n) 
    // Your code here
}


************************************
Question ID: 1333

import java.util.Arrays;

public int[] sortBasedOnMapping(int[] mapping, int[] nums) {
    Integer[] boxedNums = Arrays.stream(nums).boxed().toArray(Integer[]::new);
    Arrays.sort(boxedNums, (a, b) -> {
        String aStr = Integer.toString(a);
        String bStr = Integer.toString(b);
        for (int i = 0; i < aStr.length(); i++)
            aStr = aStr.substring(0, i) + mapping[aStr.charAt(i) - '0'] + aStr.substring(i + 1);
        for (int i = 0; i < bStr.length(); i++)
            bStr = bStr.substring(0, i) + mapping[bStr.charAt(i) - '0'] + bStr.substring(i + 1);
        return aStr.compareTo(bStr);
    });
    return Arrays.stream(boxedNums).mapToInt(Integer::intValue).toArray();
}

-----
import java.util.Arrays;

public int[] sortBasedOnMapping(int[] mapping, int[] nums) 
    // Your code here
}

************************************
Question ID: 1334

public int findTheCity(int n, int[][] edges, int distanceThreshold) {
    int[][] distance = new int[n][n];

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            distance[i][j] = 10001;
        }
    }

    for (int[] edge : edges) {
        distance[edge[0]][edge[1]] = edge[2];
        distance[edge[1]][edge[0]] = edge[2];
    }

    for (int i = 0; i < n; i++) distance[i][i] = 0;

    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                distance[i][j] = Math.min(distance[i][j], distance[i][k] + distance[k][j]);
            }
        }
    }

    int res = 0, minReachable = n;
    for (int i = 0; i < n; i++) {
        int reachable = 0;
        for (int j = 0; j < n; j++) {
            if (distance[i][j] <= distanceThreshold) reachable++;
        }
        if (reachable <= minReachable) {
            minReachable = reachable;
            res = i;
        }
    }
    return res;
}


-----
public int findTheCity(int n, int[][] edges, int distanceThreshold) 
    // Your code here
}


************************************
Question ID: 1335

public int maxCandies(int[] candies, int k) {
    int left = 1;
    int right = 0;

    for (int candy : candies) {
        right = Math.max(right, candy);
    }
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        int count = 0;
        for (int candy : candies) {
            count += candy / mid;
        }
        if (count >= k) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return right;
}

-----
public int maxCandies(int[] candies, int k) 
    // Your code here
}

************************************
Question ID: 1337

import java.util.*;

class Solution {
    public int[] kWeakestRows(int[][] mat, int k) {
        int[] result = new int[k];
        List<Integer> tmp = new ArrayList<Integer>();
        for (int i = 0; i < mat.length; i++) {
            tmp.add(i, mat[i].length - Arrays.binarySearch(mat[i], 0) - 1);
        }
        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a, b) -> a - b);
        pq.addAll(tmp);
        for (int i = 0; i < k; i++) {
            result[i] = tmp.indexOf(pq.poll());
            tmp.set(result[i], -1);
        }
        return result;
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 1338

import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;

public int minSetSize(int[] arr) {
    Map<Integer, Integer> freq_map = new HashMap<>();
    PriorityQueue<Integer> max_heap = new PriorityQueue<>((a, b) -> b - a);
    for (int x : arr)
        freq_map.put(x, freq_map.getOrDefault(x, 0) + 1);
    for (int cnt : freq_map.values())
        max_heap.offer(cnt);
    int half = arr.length / 2;
    int cnt = 0;
    int size = 0;
    while (size < half) {
        size += max_heap.poll();
        cnt++;
    }
    return cnt;
}

-----
import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;

public int minSetSize(int[] arr) 
    // Your code here
}

************************************
Question ID: 1340

import java.util.concurrent.locks.*;

class DiningPhilosophers {
    private final ReentrantLock[] locks = new ReentrantLock[5];
    private final Condition[] notBusy = new Condition[5];

    public DiningPhilosophers() {
        for (int i = 0; i < 5; i++) {
            locks[i] = new ReentrantLock();
            notBusy[i] = locks[i].newCondition();
        }
    }

    public void wantsToEat(int philosopher,
                            Runnable pickLeftFork,
                            Runnable pickRightFork,
                            Runnable eat,
                            Runnable putLeftFork,
                            Runnable putRightFork) throws InterruptedException {
        int leftFork = philosopher;
        int rightFork = (philosopher + 1) % 5;

        locks[leftFork].lock();
        try {
            while (!locks[rightFork].tryLock()) {
                notBusy[leftFork].await();
            }
            pickLeftFork.run();

            try {
                pickRightFork.run();
                eat.run();
                putRightFork.run();
            } finally {
                locks[rightFork].unlock();
            }
            notBusy[rightFork].signalAll();

            putLeftFork.run();
        } finally {
            locks[leftFork].unlock();
        }
        notBusy[leftFork].signalAll();
    }
}

-----
import java.util.concurrent.locks.*;

class DiningPhilosophers 
    // Your code here
}

************************************
Question ID: 1342

import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {
    List<List<Integer>> result = new ArrayList<>();
    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            if (x == 0 && y == 0) continue;
            int posX = king[0] + x;
            int posY = king[1] + y;
            while (posX >= 0 && posY >= 0 && posX < 8 && posY < 8) {
                for (int[] queen : queens) {
                    if (posX == queen[0] && posY == queen[1]) {
                        List<Integer> attackingQueen = new ArrayList<>();
                        attackingQueen.add(queen[0]);
                        attackingQueen.add(queen[1]);
                        result.add(attackingQueen);
                        break;
                    }
                }
                posX += x;
                posY += y;
            }
        }
    }
    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) 
    // Your code here
}

************************************
Question ID: 1343

public int dieSimulator(int n, int[] rollMax) {
    int MOD = (int)1e9 + 7;
    int[][] dp = new int[6][n + 1];
    int[] sum = new int[n + 1];
    
    for (int i = 0; i < 6; i++) dp[i][1] = 1;
    sum[1] = 6;
    
    for (int j = 2; j <= n; j++) {
        int cur_sum = 0;
        for (int i = 0; i < 6; i++) {
            dp[i][j] = sum[j - 1];
            if (j - rollMax[i] - 1 >= 0) {
                dp[i][j] = (int)(((long)dp[i][j] - sum[j - rollMax[i] - 1] + MOD) % MOD);
                if (j - rollMax[i] - 1 >= 1) {
                    dp[i][j] = (dp[i][j] + dp[i][j - rollMax[i] - 1]) % MOD;
                }
            }
            cur_sum = (cur_sum + dp[i][j]) % MOD;
        }
        sum[j] = cur_sum;
    }

    return sum[n];
}

-----
public int dieSimulator(int n, int[] rollMax) 
    // Your code here
}

************************************
Question ID: 1344

public int maxEqualFreq(int[] nums) {
    Map<Integer, Integer> count = new HashMap<>();
    Map<Integer, Integer> freq = new HashMap<>();
    int max_len = 0, max_freq = 0;
    for (int i = 0; i < nums.length; i++) {
        count.put(nums[i], count.getOrDefault(nums[i], 0) + 1);
        freq.put(count.get(nums[i]) - 1, freq.getOrDefault(count.get(nums[i]) - 1, 0) - 1);
        freq.put(count.get(nums[i]), freq.getOrDefault(count.get(nums[i]), 0) + 1);

        max_freq = Math.max(max_freq, count.get(nums[i]));
        if (max_freq * (i + 1) == i || max_freq * (freq.getOrDefault(max_freq - 1, 0) + 1) + (max_freq - 1) * freq.getOrDefault(max_freq - 1, 0) == i) {
            max_len = i + 1;
        }
    }
    return max_len;
}


-----
public int maxEqualFreq(int[] nums) 
    // Your code here
}


************************************
Question ID: 1345

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Queue;

public int minJumps(int[] arr) {
    int n = arr.length;
    if (n <= 1) return 0;

    HashMap<Integer, LinkedList<Integer>> valueIndices = new HashMap<>();
    
    for (int i = 0; i < n; ++i) {
        valueIndices.computeIfAbsent(arr[i], v -> new LinkedList<>()).add(i);
    }

    Queue<Integer> queue = new LinkedList<>();
    boolean[] visited = new boolean[n];
    
    queue.offer(0);
    visited[0] = true;
    int steps = 0;
    
    while (!queue.isEmpty()) {
        int size = queue.size();
        
        for (int i = 0; i < size; ++i) {
            int index = queue.poll();
            
            if (index == n - 1) return steps;
            
            if (index > 0 && !visited[index - 1]) {
                queue.offer(index - 1);
                visited[index - 1] = true;
            }
            
            if (index < n - 1 && !visited[index + 1]) {
                queue.offer(index + 1);
                visited[index + 1] = true;
            }

            for (int neighbor : valueIndices.get(arr[index])) {
                if (!visited[neighbor]) {
                    queue.offer(neighbor);
                    visited[neighbor] = true;
                }
            }
            
            valueIndices.get(arr[index]).clear();
        }
        
        ++steps;
    }

    return -1;
}

-----
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Queue;

public int minJumps(int[] arr) 
    // Your code here
}

************************************
Question ID: 1346

public int maxValueInStack(int[] nums, int k) {
    int n = nums.length;
    if (k >= n) return -1;

    int max_val = Integer.MIN_VALUE;
    for (int i = 0; i <= k; ++i) {
        max_val = Math.max(max_val, nums[i]);
    }
    return max_val;
}

-----
public int maxValueInStack(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 1347

public int minSteps(String s, String t) {
    int[] s_Count = new int[26];
    int[] t_Count = new int[26];
    for(char c : s.toCharArray()) s_Count[c - 'a']++;
    for(char c : t.toCharArray()) t_Count[c - 'a']++;
    int res = 0;
    for(int i = 0; i < 26; i++) {
        res += Math.abs(s_Count[i] - t_Count[i]);
    }
    return res / 2;
}

-----
public int minSteps(String s, String t) 
    // Your code here
}

************************************
Question ID: 1348

import java.util.*;

class TweetCounts {

    private Map<String, TreeMap<Integer, Integer>> data;

    public TweetCounts() {
        data = new HashMap<>();
    }

    public void recordTweet(String tweetName, int time) {
        if (!data.containsKey(tweetName)) {
            data.put(tweetName, new TreeMap<>());
        }
        data.get(tweetName).put(time, data.get(tweetName).getOrDefault(time, 0) + 1);
    }

    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {
        int step = freq.equals("minute") ? 60 : freq.equals("hour") ? 3600 : 86400;
        List<Integer> chunks = new ArrayList<>(Collections.nCopies((endTime - startTime) / step + 1, 0));

        if (data.containsKey(tweetName)) {
            for (Map.Entry<Integer, Integer> entry : data.get(tweetName).subMap(startTime, true, endTime, true).entrySet()) {
                int chunk_index = (entry.getKey() - startTime) / step;
                if (chunk_index >= 0 && chunk_index < chunks.size()) {
                    chunks.set(chunk_index, chunks.get(chunk_index) + entry.getValue());
                }
            }
        }

        return chunks;
    }
}

-----
import java.util.*;

class TweetCounts 
    // Your code here
}

************************************
Question ID: 1349

class Solution {
    public boolean checkStraightLine(int[][] coordinates) {
        int dx = coordinates[1][0] - coordinates[0][0];
        int dy = coordinates[1][1] - coordinates[0][1];

        for(int i = 2; i < coordinates.length; i++) {
            int x = coordinates[i][0] - coordinates[0][0];
            int y = coordinates[i][1] - coordinates[0][1];
            if(dx * y != dy * x) return false;
        }

        return true;
    }
}

-----
class Solution 
    // Your code here
}

************************************
Question ID: 1351

import java.util.HashMap;

public int balancedString(String s) {
    int n = s.length();
    HashMap<Character, Integer> freq_map = new HashMap<>();
    for (char c : s.toCharArray())
        freq_map.put(c, freq_map.getOrDefault(c, 0) + 1);
    
    int i = 0, result = n;
    for (int j = 0; j < n; j++) {
        freq_map.put(s.charAt(j), freq_map.get(s.charAt(j)) - 1);
        while (i < n && freq_map.getOrDefault('Q', 0) <= n / 4 && freq_map.getOrDefault('W', 0) <= n / 4 && freq_map.getOrDefault('E', 0) <= n / 4 && freq_map.getOrDefault('R', 0) <= n / 4) {
            result = Math.min(result, j - i + 1);
            freq_map.put(s.charAt(i), freq_map.get(s.charAt(i)) + 1);
            i++;
        }
    }
    return result;
}

-----
import java.util.HashMap;

public int balancedString(String s) 
    // Your code here
}

************************************
Question ID: 1352

import java.util.Arrays;

class Job {
    int start;
    int end;
    int profit;

    public Job(int start, int end, int profit) {
        this.start = start;
        this.end = end;
        this.profit = profit;
    }
}

public int maxProfit(int[] startTime, int[] endTime, int[] profit) {
    int n = startTime.length;
    Job[] jobs = new Job[n];

    for (int i = 0; i < n; i++) {
        jobs[i] = new Job(startTime[i], endTime[i], profit[i]);
    }

    Arrays.sort(jobs, (a, b) -> a.end - b.end);

    int[] memo = new int[n];
    Arrays.fill(memo, -1);
    return maxProfitHelper(jobs, memo, n - 1);
}

private int findNextJob(Job[] jobs, int i) {
    for (int j = i + 1; j < jobs.length; j++) {
        if (jobs[j].start >= jobs[i].end) {
            return j;
        }
    }
    return -1;
}

private int maxProfitHelper(Job[] jobs, int[] memo, int i) {
    if (i == -1) return 0;
    if (memo[i] != -1) return memo[i];

    int nextJob = findNextJob(jobs, i);
    int inclCurrJob = jobs[i].profit + maxProfitHelper(jobs, memo, nextJob);
    int exclCurrJob = maxProfitHelper(jobs, memo, i - 1);

    memo[i] = Math.max(inclCurrJob, exclCurrJob);
    return memo[i];
}

-----
import java.util.Arrays;

class Job 
    // Your code here
}

************************************
Question ID: 1353

import java.util.*;

public int maxEvents(int[][] events) {
    Arrays.sort(events, (a, b) -> a[0] - b[0]);
    PriorityQueue<Integer> minHeap = new PriorityQueue<>();
    int eventCount = 0, day = 0;

    for (int[] event : events) {
        while (!minHeap.isEmpty() && minHeap.peek() < event[0]) {
            minHeap.poll();
        }
        minHeap.add(event[1]);
        eventCount++;
        day++;
    }

    return eventCount;
}


-----
import java.util.*;

public int maxEvents(int[][] events) 
    // Your code here
}


************************************
Question ID: 1354

import java.util.*;

public List<List<Integer>> winnersAndLosers(int[][] matches) {
    TreeSet<Integer> winners = new TreeSet<>();
    TreeSet<Integer> losers = new TreeSet<>();
    for (int[] match : matches) {
        winners.add(match[0]);
        losers.add(match[1]);
    }
    return Arrays.asList(new ArrayList<>(winners), new ArrayList<>(losers));
}

-----
import java.util.*;

public List<List<Integer>> winnersAndLosers(int[][] matches) 
    // Your code here
}

************************************
Question ID: 1356

public int minMovesToPalindrome(String s) {
    char[] chars = s.toCharArray();
    int moves = 0;
    int left = 0, right = s.length() - 1;

    while (left < right) {
        if (chars[left] != chars[right]) {
            int temp_right = right;

            while (chars[left] != chars[temp_right]) {
                temp_right--;
            }
            char temp = chars[temp_right];
            System.arraycopy(chars, temp_right + 1, chars, temp_right, right - temp_right);
            chars[right] = temp;
            moves += right - temp_right;
        }
        left++;
        right--;
    }

    return moves;
}

-----
public int minMovesToPalindrome(String s) 
    // Your code here
}

************************************
Question ID: 1358

import java.util.ArrayList;
import java.util.List;
import java.util.AbstractMap.SimpleEntry;

public List<SimpleEntry<Integer, Integer>> findPairs(int z) {
    List<SimpleEntry<Integer, Integer>> pairs = new ArrayList<>();

    int f(int x, int y) {
        return x + y;
    }

    for (int x = 1; x <= z; x++) {
        for (int y = 1; y <= z; y++) {
            if (f(x, y) == z) {
                pairs.add(new SimpleEntry<>(x, y));
            }
        }
    }
    return pairs;
}

-----
import java.util.ArrayList;
import java.util.List;
import java.util.AbstractMap.SimpleEntry;

public List<SimpleEntry<Integer, Integer>> findPairs(int z) 
    // Your code here
}

************************************
Question ID: 1359

import java.util.ArrayList;

public static ArrayList<Integer> circularPermutation(int n, int start) {
    ArrayList<Integer> result = new ArrayList<>(1 << n);
    for (int i = 0; i < (1 << n); ++i) {
        result.add(start ^ (i ^ (i >> 1)));
    }
    return result;
}


-----
import java.util.ArrayList;

public static ArrayList<Integer> circularPermutation(int n, int start) 
    // Your code here
}


************************************
Question ID: 1360

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public int maxLength(List<String> arr) {
    List<String> dp = new ArrayList<>();
    dp.add("");
    int maxLen = 0;
    for (String s : arr) {
        if (new HashSet<Character>(s.chars().mapToObj(c -> (char) c).collect(Collectors.toSet())).size() < s.length()) continue;
        for (int i = dp.size() - 1; i >= 0; --i) {
            String tmp = dp.get(i) + s;
            if (tmp.chars().distinct().count() == tmp.length()) {
                dp.add(tmp);
                maxLen = Math.max(maxLen, tmp.length());
            }
        }
    }
    return maxLen;
}

-----
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public int maxLength(List<String> arr) 
    // Your code here
}

************************************
Question ID: 1361

public int tilingRectangle(int n, int m) {
    if (n > m) {
        int temp = n;
        n = m;
        m = temp;
    }
    if (n == 1) return m;
    if (n == m) return 1;

    int res = Integer.MAX_VALUE;
    for (int a = 1; a <= n / 2; a++) {
        res = Math.min(res, tilingRectangle(a, m) + tilingRectangle(n - a, m));
    }
    for (int b = 1; b <= m / 2; b++) {
        res = Math.min(res, tilingRectangle(n, b) + tilingRectangle(n, m - b));
    }
    return res;
}


-----
public int tilingRectangle(int n, int m) 
    // Your code here
}


************************************
Question ID: 1362

public int[] findClosestDivisors(int num) {
    for (int i = (int)Math.sqrt(num + 2); i >= 1; i--) {
        if ((num + 1) % i == 0) return new int[]{i, (num + 1) / i};
        if ((num + 2) % i == 0) return new int[]{i, (num + 2) / i};
    }
    return new int[0];
}

-----
public int[] findClosestDivisors(int num) 
    // Your code here
}

************************************
Question ID: 1363

import java.util.*;

public String largestMultipleOfThree(int[] digits) {
    Arrays.sort(digits);
    int sum = 0;
    for (int digit : digits) {
        sum += digit;
    }

    if (sum % 3 == 0) {
        if (digits[0] == 0) return "0";
        StringBuilder result = new StringBuilder();
        for (int i = digits.length - 1; i >= 0; --i) {
            result.append(digits[i]);
        }
        return result.toString();
    }

    List<Integer>[] mod = new List[3];
    for (int i = 0; i < 3; ++i) {
        mod[i] = new ArrayList<Integer>();
    }
    for (int digit : digits) {
        mod[digit % 3].add(digit);
    }

    if (sum % 3 == 1) {
        if (!mod[1].isEmpty()) {
            mod[1].remove(mod[1].size() - 1);
        } else {
            mod[2].remove(mod[2].size() - 1);
            mod[2].remove(mod[2].size() - 1);
        }
    } else {
        if (!mod[2].isEmpty()) {
            mod[2].remove(mod[2].size() - 1);
        } else {
            mod[1].remove(mod[1].size() - 1);
            mod[1].remove(mod[1].size() - 1);
        }
    }

    StringBuilder result = new StringBuilder();
    for (int i = 0; i < 3; ++i) {
        for (int digit : mod[i]) {
            result.append(digit);
        }
    }

    result.reverse();
    if (result.length() == 0 || result.charAt(0) == '0') {
        return "0";
    }

    return result.toString();
}


-----
import java.util.*;

public String largestMultipleOfThree(int[] digits) 
    // Your code here
}


************************************
Question ID: 1365

public int[] smallerNumbersThanCurrent(int[] nums) {
    int[] result = new int[nums.length];
    for (int i = 0; i < nums.length; i++) {
        int count = 0;
        for (int j = 0; j < nums.length; j++) {
            if (i != j && nums[j] < nums[i]) {
                count++;
            }
        }
        result[i] = count;
    }
    return result;
}

-----
public int[] smallerNumbersThanCurrent(int[] nums) 
    // Your code here
}

************************************
Question ID: 1366

import java.util.*;

class Solution {
    public String rankTeams(String[] votes) {
        int n = votes.length, m = votes[0].length();
        int[][] count = new int[26][m];
        String res = votes[0];
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                count[votes[i].charAt(j) - 'A'][j]++;
            }
        }
        
        Character[] chars = new Character[m];
        for (int i = 0; i < m; i++) {
            chars[i] = res.charAt(i);
        }
        Arrays.sort(chars, (a, b) -> {
            for (int i = 0; i < m; i++) {
                if (count[a - 'A'][i] != count[b - 'A'][i]) {
                    return count[b - 'A'][i] - count[a - 'A'][i];
                }
            }
            return a - b;
        });
        
        StringBuilder sb = new StringBuilder();
        for(char c : chars) {
            sb.append(c);
        }
        return sb.toString();
    }
}


-----
import java.util.*;

class Solution 
    // Your code here
}


************************************
Question ID: 1367

import java.util.Arrays;

public int maxHeight(int[][] cuboids) {
    for (int[] cuboid : cuboids) {
        Arrays.sort(cuboid);
    }
    Arrays.sort(cuboids, (a, b) -> a[0] - b[0]);

    int n = cuboids.length;
    int[] dp = new int[n];
    int ans = 0;

    for (int i = 0; i < n; i++) {
        dp[i] = cuboids[i][2];
        for (int j = 0; j < i; j++) {
            if (cuboids[j][0] <= cuboids[i][0] && cuboids[j][1] <= cuboids[i][1] && cuboids[j][2] <= cuboids[i][2]) {
                dp[i] = Math.max(dp[i], dp[j] + cuboids[i][2]);
            }
        }
        ans = Math.max(ans, dp[i]);
    }
    return ans;
}


-----
import java.util.Arrays;

public int maxHeight(int[][] cuboids) 
    // Your code here
}


************************************
Question ID: 1368

import java.util.*;

class Solution {
    public int minCost(int[][] grid) {
        int m = grid.length, n = grid[0].length, cost = 0;

        int[][] visited = new int[m][n];
        for (int[] row : visited) {
            Arrays.fill(row, 1000000);
        }
        Queue<int[]> q = new LinkedList<>();
        q.offer(new int[]{0, 0});
        visited[0][0] = 0;

        while (!q.isEmpty()) {
            int[] curr = q.poll();
            int y = curr[0], x = curr[1];
            if (y == m - 1 && x == n - 1) {
                cost = visited[y][x];
                break;
            }

            int[] dx = {1, 0, -1, 0};
            int[] dy = {0, 1, 0, -1};

            for (int dir = 0; dir < 4; ++dir) {
                int newY = y + dy[dir], newX = x + dx[dir];
                if (0 <= newY && newY < m && 0 <= newX && newX < n) {
                    int newCost = visited[y][x] + (dir + 1 != grid[y][x] ? 1 : 0);
                    if (newCost < visited[newY][newX]) {
                        visited[newY][newX] = newCost;
                        q.offer(new int[]{newY, newX});
                    }
                }
            }
        }
        return cost;
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 1370

public int numberOfSubarrays(int[] nums, int k) {
    int n = nums.length, result = 0, count = 0;
    int[] oddCount = new int[n + 1];

    oddCount[0] = 1;
    for (int i = 0; i < n; i++) {
        count += nums[i] % 2;
        if (count >= k) result += oddCount[count - k];
        oddCount[count]++;
    }

    return result;
}

-----
public int numberOfSubarrays(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 1371

import java.util.Stack;

public String minRemoveToMakeValid(String s) {
    Stack<Integer> stk = new Stack<>();
    char[] result = s.toCharArray();

    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '(') {
            stk.push(i);
        } else if (s.charAt(i) == ')') {
            if (!stk.empty()) {
                stk.pop();
            } else {
                result[i] = '-';
            }
        }
    }

    while (!stk.empty()) {
        result[stk.pop()] = '-';
    }

    return new String(result).replace("-", "");
}


-----
import java.util.Stack;

public String minRemoveToMakeValid(String s) 
    // Your code here
}


************************************
Question ID: 1372

public class Main {
    public boolean isGoodArray(int[] nums) {
        int gcd = nums[0];
        for (int num : nums) {
            gcd = gcd(gcd, num);
            if (gcd == 1) {
                return true;
            }
        }
        return gcd == 1;
    }
    private int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
}


-----
public class Main 
    // Your code here
}


************************************
Question ID: 1374

class Solution {
    public String generateTheString(int n) {
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < n - 1; i++)
            result.append('a');
        if (n % 2 == 0)
            result.append('b');
        else
            result.append('a');
        return result.toString();
    }
}

-----
class Solution 
    // Your code here
}

************************************
Question ID: 1375

import java.util.ArrayList;
import java.util.List;

public int findKthPalindrome(int k, int intLength) {
    int mid = (intLength + 1) / 2;
    int limit = (int) Math.pow(10, mid) - 1;

    for (int i = 0; i <= limit; i++) {
        String num = Integer.toString(i);
        String rev = new StringBuilder(num).reverse().toString();
        if (intLength % 2 != 0)
            rev = rev.substring(1);
        num += rev;
        int palindrome = Integer.parseInt(num);
        if (palindrome > 0)
            k--;
        if (k == 0)
            return palindrome;
    }
    return -1;
}

public List<Integer> palindromeQueries(List<Integer> queries, int intLength) {
    List<Integer> answer = new ArrayList<>();
    for (int query : queries) {
        answer.add(findKthPalindrome(query, intLength));
    }
    return answer;
}


-----
import java.util.ArrayList;
import java.util.List;

public int findKthPalindrome(int k, int intLength) 
    // Your code here
}


************************************
Question ID: 1376

public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {
    List<List<Integer>> subordinates = new ArrayList<>();
    for (int i = 0; i < n; ++i) {
        subordinates.add(new ArrayList<>());
    }
    for (int i = 0; i < n; ++i) {
        if (manager[i] != -1) {
            subordinates.get(manager[i]).add(i);
        }
    }
    return dfs(headID, subordinates, informTime);
}

private int dfs(int employee, List<List<Integer>> subordinates, int[] informTime) {
    if (informTime[employee] == 0) {
        return 0;
    }
    int max_time = 0;
    for (int i : subordinates.get(employee)) {
        max_time = Math.max(max_time, dfs(i, subordinates, informTime));
    }
    return max_time + informTime[employee];
}


-----
public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) 
    // Your code here
}


************************************
Question ID: 1377

import java.util.*;

class Solution {
    public void dfs(int node, int parent, int t, int target, List<List<Integer>> graph, double prob, double[] ans) {
        if (t == 0) {
            if(node == target) ans[0] += prob;
            return;
        }
        
        boolean has_child = false;
        for(Integer child : graph.get(node)) {
            if(child != parent) {
                has_child = true;
                dfs(child, node, t - 1, target, graph, prob / (graph.get(node).size() - (node != 1 ? 1 : 0)), ans);
            }
        }
        
        if(!has_child && node == target) ans[0] += prob;
    }

    public double frogPosition(int n, int[][] edges, int t, int target) {
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i <= n; ++i) {
            graph.add(new ArrayList<Integer>());
        }
        for (int i = 0; i < n - 1; ++i) {
            int a = edges[i][0], b = edges[i][1];
            graph.get(a).add(b);
            graph.get(b).add(a);
        }
        
        double[] ans = {0.0};
        dfs(1, -1, t, target, graph, 1.0, ans);
        return ans[0];
    }
}


-----
import java.util.*;

class Solution 
    // Your code here
}


************************************
Question ID: 1379

import java.util.ArrayList;
import java.util.List;

public int[][] reconstructMatrix(int upper, int lower, int[] colsum) {
    int[][] result = new int[2][colsum.length];
    
    for (int i = 0; i < colsum.length; i++) {
        if (colsum[i] == 2) {
            result[0][i] = 1;
            result[1][i] = 1;
            upper--;
            lower--;
        } else if (colsum[i] == 1) {
            if (upper > lower) {
                result[0][i] = 1;
                upper--;
            } else {
                result[1][i] = 1;
                lower--;
            }
        }
        
        if (upper < 0 || lower < 0) {
            return new int[][]{};
        }
    }
    
    if (upper > 0 || lower > 0) {
        return new int[][]{};
    }
    
    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public int[][] reconstructMatrix(int upper, int lower, int[] colsum) 
    // Your code here
}

************************************
Question ID: 1380

int[] dx = {-1, 1, 0, 0};
int[] dy = {0, 0, -1, 1};

void dfs(int[][] grid, int x, int y) {
    int n = grid.length, m = grid[0].length;
    grid[x][y] = 1;
    for (int i = 0; i < 4; i++) {
        int nx = x + dx[i], ny = y + dy[i];
        if (nx >= 0 && nx < n && ny >= 0 && ny < m && grid[nx][ny] == 0) {
            dfs(grid, nx, ny);
        }
    }
}

public int closedIsland(int[][] grid) {
    int n = grid.length, m = grid[0].length;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (i == 0 || i == n - 1 || j == 0 || j == m - 1) {
                if (grid[i][j] == 0) {
                    dfs(grid, i, j);
                }
            }
        }
    }
    int res = 0;
    for (int i = 1; i < n - 1; i++) {
        for (int j = 1; j < m - 1; j++) {
            if (grid[i][j] == 0) {
                dfs(grid, i, j);
                res++;
            }
        }
    }
    return res;
}


-----
int[] dx = 
    // Your code here
}


************************************
Question ID: 1381

import java.util.*;

public int getMaxScore(String word, int[] score) {
    int sum = 0;
    for (char c : word.toCharArray()) {
        sum += score[c - 'a'];
    }
    return sum;
}

public int getMaxScoreHelper(String[] words, int[] score, char[] letters, int i) {
    if (i == words.length) {
        return 0;
    }
    int withoutCurrentWord = getMaxScoreHelper(words, score, letters, i + 1);
    for (char c : words[i].toCharArray()) {
        if (--letters[c - 'a'] < 0) {
            break;
        }
    }
    int withCurrentWord = getMaxScore(words[i], score) + getMaxScoreHelper(words, score, letters, i + 1);
    return Math.max(withCurrentWord, withoutCurrentWord);
}

public int maxScoreWords(String[] words, String letters, int[] score) {
    return getMaxScoreHelper(words, score, letters.toCharArray(), 0);
}
```
-----
import java.util.*;

public int getMaxScore(String word, int[] score) 
    // Your code here
}
```
************************************
Question ID: 1383

import java.util.*;

public int maxPerformance(int n, int k, int[] speed, int[] efficiency) {
    int[][] engineers = new int[n][2];
    for (int i = 0; i < n; i++) {
        engineers[i] = new int[] {efficiency[i], speed[i]};
    }

    Arrays.sort(engineers, (a, b) -> b[0] - a[0]);

    PriorityQueue<Integer> minHeap = new PriorityQueue<>(k, Comparator.reverseOrder());
    long speedSum = 0;
    long maxPerformance = 0;

    for (int[] engineer : engineers) {
        speedSum += engineer[1];
        minHeap.offer(engineer[1]);

        if (minHeap.size() > k) {
            speedSum -= minHeap.poll();
        }

        maxPerformance = Math.max(maxPerformance, speedSum * engineer[0]);
    }

    return (int) (maxPerformance % (1e9 + 7));
}

-----
import java.util.*;

public int maxPerformance(int n, int k, int[] speed, int[] efficiency) 
    // Your code here
}

************************************
Question ID: 1385

public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {
    int distance = 0;
    for (int a : arr1) {
        boolean found = true;
        for (int b : arr2) {
            if (Math.abs(a - b) <= d) {
                found = false;
                break;
            }
        }
        if (found) distance++;
    }
    return distance;
}

-----
public int findTheDistanceValue(int[] arr1, int[] arr2, int d) 
    // Your code here
}

************************************
Question ID: 1386

import java.util.List;
import java.util.ArrayList;

public List<List<Integer>> shiftGrid(int[][] grid, int k) {
    int m = grid.length, n = grid[0].length;
    k %= (m * n);
    List<List<Integer>> res = new ArrayList<>();
    for (int i = 0; i < m; ++i) {
        List<Integer> row = new ArrayList<>();
        for (int j = 0; j < n; ++j) {
            int idx = (i * n + j + k) % (m * n);
            row.add(grid[idx / n][idx % n]);
        }
        res.add(row);
    }
    return res;
}


-----
import java.util.List;
import java.util.ArrayList;

public List<List<Integer>> shiftGrid(int[][] grid, int k) 
    // Your code here
}


************************************
Question ID: 1388

public int maxSumDivThree(int[] nums) {
    int[] dp = new int[3];
    for (int num : nums) {
        int[] temp = Arrays.copyOf(dp, 3);
        for (int s : temp) {
            dp[(s + num) % 3] = Math.max(dp[(s + num) % 3], s + num);
        }
    }
    return dp[0];
}

-----
public int maxSumDivThree(int[] nums) 
    // Your code here
}

************************************
Question ID: 1390

public int sumOfFourDivisors(int[] nums) {
    int sum = 0;
    for (int num : nums) {
        int count = 0;
        int div_sum = 0;
        for (int i = 1; i * i <= num; ++i) {
            if (num % i == 0) {
                count += (i * i == num) ? 1 : 2;
                div_sum += i + (num / i);
                if (count > 4) break;
            }
        }
        if (count == 4) sum += div_sum;
    }
    return sum;
}

-----
public int sumOfFourDivisors(int[] nums) 
    // Your code here
}

************************************
Question ID: 1391

public boolean hasValidPath(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;

    int[][] directions = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};
    int[][] allowed = {{}, {0, 2}, {1, 3}, {0, 1}, {0, 3}, {1, 2}, {1, 0}};

    boolean[][] visited = new boolean[m][n];

    class DFS {
        boolean search(int i, int j) {
            if (i == m - 1 && j == n - 1) return true;
            visited[i][j] = true;
            for (int dir : allowed[grid[i][j]]) {
                int x = i + directions[dir][0];
                int y = j + directions[dir][1];
                if (x >= 0 && y >= 0 && x < m && y < n && !visited[x][y] && Arrays.stream(allowed[grid[x][y]]).anyMatch(d -> d == (dir + 2) % 4)) {
                    if (search(x, y)) return true;
                }
            }
            return false;
        }
    }

    return new DFS().search(0, 0);
}

-----
public boolean hasValidPath(int[][] grid) 
    // Your code here
}

************************************
Question ID: 1394

public int findLucky(int[] arr) {
    Map<Integer, Integer> freq = new HashMap<>();
    for (int num : arr) {
        freq.put(num, freq.getOrDefault(num, 0) + 1);
    }
    int maxLucky = -1;
    for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
        if (entry.getKey().equals(entry.getValue())) {
            maxLucky = Math.max(maxLucky, entry.getKey());
        }
    }
    return maxLucky;
}

-----
public int findLucky(int[] arr) 
    // Your code here
}

************************************
Question ID: 1395

public int minTimeToVisitAllPoints(int[][] points) {
    int time = 0;
    for(int i = 1; i < points.length; ++i) {
        int dx = Math.abs(points[i][0] - points[i-1][0]);
        int dy = Math.abs(points[i][1] - points[i-1][1]);
        time += Math.max(dx, dy);
    }
    return time;
}


-----
public int minTimeToVisitAllPoints(int[][] points) 
    // Your code here
}


************************************
Question ID: 1397

import java.util.*;

public List<List<String>> suggestedProducts(String[] products, String searchWord) {
    Arrays.sort(products);
    
    List<List<String>> result = new ArrayList<>();
    String currentPrefix = "";
    
    for (char letter : searchWord.toCharArray()) {
        currentPrefix += letter;
        
        int index = Arrays.binarySearch(products, currentPrefix);
        if (index < 0) {
            index = -index - 1;
        }
        
        List<String> suggestions = new ArrayList<>();
        for (int i = 0; i < 3 && index < products.length && products[index].startsWith(currentPrefix); i++) {
            suggestions.add(products[index]);
            index++;
        }
        
        result.add(suggestions);
    }
    
    return result;
}

-----
import java.util.*;

public List<List<String>> suggestedProducts(String[] products, String searchWord) 
    // Your code here
}

************************************
Question ID: 1399

public int countLargestGroup(int n) {
    int[] groups = new int[37];
    int largest_group_size = 0;
    int count_largest_groups = 0;

    for (int i = 1; i <= n; i++) {
        int sum = 0, num = i;
        while (num > 0) {
            sum += num % 10;
            num /= 10;
        }
        groups[sum]++;
        if (groups[sum] > largest_group_size) {
            largest_group_size = groups[sum];
            count_largest_groups = 1;
        } else if (groups[sum] == largest_group_size) {
            count_largest_groups++;
        }
    }
    return count_largest_groups;
}

-----
public int countLargestGroup(int n) 
    // Your code here
}

************************************
Question ID: 1400

import java.util.*;

public String tictactoe(int[][] moves) {
    int[][] grid = new int[3][3];
    int player = 1;
    for (int[] move : moves) {
        grid[move[0]][move[1]] = player;
        if ((grid[0][move[1]] == player && grid[1][move[1]] == player && grid[2][move[1]] == player) ||
            (grid[move[0]][0] == player && grid[move[0]][1] == player && grid[move[0]][2] == player) ||
            (move[0] == move[1] && grid[0][0] == player && grid[1][1] == player && grid[2][2] == player) ||
            (move[0] + move[1] == 2 && grid[0][2] == player && grid[1][1] == player && grid[2][0] == player)) {
            return player == 1 ? "A" : "B";
        }
        player = 3 - player;
    }
    return moves.length == 9 ? "Draw" : "Pending";
}


-----
import java.util.*;

public String tictactoe(int[][] moves) 
    // Your code here
}


************************************
Question ID: 1401

boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {
    int xClosest = Math.max(x1, Math.min(xCenter, x2));
    int yClosest = Math.max(y1, Math.min(yCenter, y2));
    return (xCenter - xClosest) * (xCenter - xClosest) + (yCenter - yClosest) * (yCenter - yClosest) <= radius * radius;
}

-----
boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) 
    // Your code here
}

************************************
Question ID: 1402

public int countSquares(int[][] matrix) {
    int m = matrix.length, n = matrix[0].length, ans = 0;
    int[][] dp = new int[m][n];
    for(int i = 0; i < m; i++) {
        for(int j = 0; j < n; j++) {
            if(i == 0 || j == 0) dp[i][j] = matrix[i][j];
            else if(matrix[i][j] == 1) dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;
            ans += dp[i][j];
        }
    }
    return ans;
}

-----
public int countSquares(int[][] matrix) 
    // Your code here
}

************************************
Question ID: 1403

public int minChangesToDivideString(String s, int k) {
    int n = s.length();
    if (n % k != 0) return -1;
    int chunkCount = n / k;
    int res = 0;
    for (int i = 0; i < k; ++i) {
        int[] counts = new int[26];
        for (int j = i; j < n; j += k) {
            ++counts[s.charAt(j) - 'a'];
        }
        int maxCount = Arrays.stream(counts).max().getAsInt();
        res += chunkCount - maxCount;
    }
    return res;
}

-----
public int minChangesToDivideString(String s, int k) 
    // Your code here
}

************************************
Question ID: 1404

public int numSteps(String s) {
    int steps = 0, carry = 0;
    for (int i = s.length() - 1; i > 0; --i) {
        int bit = s.charAt(i) - '0';
        if (bit == 1 && carry == 1) {
            carry = 1;
            steps += 2;
        } else if (bit == 1 || carry == 1) {
            carry ^= 1;
            steps += 2;
        } else {
            steps++;
        }
    }

    return steps + carry;
}

-----
public int numSteps(String s) 
    // Your code here
}

************************************
Question ID: 1405

import java.util.*;

class Solution {
    public String longestDiverseString(int a, int b, int c) {
        StringBuilder result = new StringBuilder();
        PriorityQueue<int[]> pq = new PriorityQueue<>((a1, a2) -> a2[0] - a1[0]);
        if (a != 0) pq.offer(new int[]{a, 'a'});
        if (b != 0) pq.offer(new int[]{b, 'b'});
        if (c != 0) pq.offer(new int[]{c, 'c'});
        
        while (!pq.isEmpty()) {
            int[] first = pq.poll();
            if (result.length() != 0 && result.charAt(result.length()-1) == first[1]) {
                if (pq.isEmpty()) break;
                int[] second = pq.poll();
                result.append((char)second[1]);
                second[0]--;
                if (second[0] != 0) pq.offer(second);
                pq.offer(first);
            } else {
                result.append((char)first[1]);
                first[0]--;
                if (first[0] != 0) pq.offer(first);
            }
        }
        return result.toString();
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 1406

public String stoneGameIII(int[] stoneValue) {
    int n = stoneValue.length;
    int[] dp = new int[n + 1];
    dp[n] = 0;
    
    for (int i = n - 1; i >= 0; --i) {
        dp[i] = Integer.MIN_VALUE;
        int curr = 0;
        for (int j = 0; j < 3 && i + j < n; ++j) {
            curr += stoneValue[i + j];
            dp[i] = Math.max(dp[i], curr - dp[i + j + 1]);
        }
    }
    
    return dp[0] == 0 ? "Tie " : dp[0] > 0 ? "Alice " : "Bob ";
}


-----
public String stoneGameIII(int[] stoneValue) 
    // Your code here
}


************************************
Question ID: 1408

import java.lang.Math;

public int smallestDivisor(int[] nums, int threshold) {
    int left = 1, right = 1000000;
    while (left < right) {
        int mid = (left + right) / 2;
        int sum = 0;
        for (int n : nums) {
            sum += Math.ceil(1.0 * n / mid);
        }
        if (sum > threshold) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}

-----
import java.lang.Math;

public int smallestDivisor(int[] nums, int threshold) 
    // Your code here
}

************************************
Question ID: 1409

import java.util.*;

public int minNumberOfFlips(int[][] mat) {
    final int m = mat.length, n = mat[0].length;
    final int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}, {0, 0}};
    int steps = 0;

    while (true) {
        int flipped = 0;
        Queue<Integer> que = new LinkedList<>();

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (mat[i][j] == 1) {
                    que.offer(i * n + j);
                }
            }
        }

        while (!que.isEmpty()) {
            int cur = que.poll(), cur_i = cur / n, cur_j = cur % n;
            for (int[] dir : dirs) {
                int ni = cur_i + dir[0], nj = cur_j + dir[1];
                if (ni >= 0 && ni < m && nj >= 0 && nj < n) {
                    mat[ni][nj] ^= 1;
                    ++flipped;
                }
            }
        }

        if (flipped == 0) {
            break;
        }
        steps += flipped;
    }

    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (mat[i][j] == 1) {
                return -1;
            }
        }
    }

    return steps;
}

-----
import java.util.*;

public int minNumberOfFlips(int[][] mat) 
    // Your code here
}

************************************
Question ID: 1410

import java.util.HashMap;
import java.util.Map;

public String entityParser(String text) {
    Map<String, String> entities = new HashMap<String, String>() {{
        put("&quot;", "\"");
        put("&apos;", "'");
        put("&amp;", "&");
        put("&gt;", ">");
        put("&lt;", "<");
        put("&frasl;", "/");
    }};
    
    StringBuilder result = new StringBuilder();
    StringBuilder currentEntity = new StringBuilder();
    boolean inEntity = false;
    
    for (char c : text.toCharArray()) {
        if (inEntity) {
            currentEntity.append(c);
            if (c == ';') {
                String entity = currentEntity.toString();
                if (entities.containsKey(entity)) {
                    result.append(entities.get(entity));
                } else {
                    result.append(entity);
                }
                inEntity = false;
                currentEntity = new StringBuilder();
            }
        } else {
            if (c == '&') {
                inEntity = true;
                currentEntity.append(c);
            } else {
                result.append(c);
            }
        }
    }
    
    return result.toString();
}

-----
import java.util.HashMap;
import java.util.Map;

public String entityParser(String text) 
    // Your code here
}

************************************
Question ID: 1413

public int maxSideLength(int[][] mat, int threshold) {
    int m = mat.length;
    int n = mat[0].length;
    int[][] dp = new int[m + 1][n + 1];
    int ans = 0;

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            dp[i][j] = mat[i - 1][j - 1] + dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1];
            int k = ans + 1;
            if (i >= k && j >= k && dp[i][j] - dp[i][j - k] - dp[i - k][j] + dp[i - k][j - k] <= threshold) {
                ans++;
            }
        }
    }
    return ans;
}

-----
public int maxSideLength(int[][] mat, int threshold) 
    // Your code here
}

************************************
Question ID: 1414

import java.util.*;

class Solution {
    public int shortestPath(int[][] grid, int k) {
        int m = grid.length;
        int n = grid[0].length;
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{0, 0, 0, k});
        boolean[][][] visited = new boolean[m][n][k + 1];

        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int x = current[0];
            int y = current[1];
            int step = current[2];
            int remainingK = current[3];

            if (x == m - 1 && y == n - 1) return step;
            if (visited[x][y][remainingK]) continue;
            visited[x][y][remainingK] = true;

            int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

            for (int[] dir : directions) {
                int nx = x + dir[0];
                int ny = y + dir[1];

                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                    if (grid[nx][ny] == 1 && remainingK > 0) {
                        queue.offer(new int[]{nx, ny, step + 1, remainingK - 1});
                    } else if (grid[nx][ny] == 0) {
                        queue.offer(new int[]{nx, ny, step + 1, remainingK});
                    }
                }
            }
        }

        return -1;
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 1416

public int numDecodings(String s, int k) {
    int n = s.length();
    int[] dp = new int[n + 1];
    dp[n] = 1;
    int MOD = 1000000007;

    for (int i = n - 1; i >= 0; i--) {
        long num = 0;
        for (int j = i; j < n && num <= k; j++) {
            num = num * 10 + s.charAt(j) - '0';
            if (num >= 1 && num <= k) {
                dp[i] = (dp[i] + dp[j + 1]) % MOD;
            }
        }
    }
    return dp[0];
}

-----
public int numDecodings(String s, int k) 
    // Your code here
}

************************************
Question ID: 1417

import java.util.LinkedList;
import java.util.Queue;

public String reformat(String s) {
    Queue<Character> letters = new LinkedList<>();
    Queue<Character> digits = new LinkedList<>();

    for (char c : s.toCharArray()) {
        if (Character.isLetter(c)) letters.add(c);
        else digits.add(c);
    }

    if (Math.abs(letters.size() - digits.size()) > 1) return "";

    StringBuilder result = new StringBuilder();
    boolean useLetter = letters.size() > digits.size();

    while (!letters.isEmpty() || !digits.isEmpty()) {
        if (useLetter) {
            result.append(letters.poll());
        } else {
            result.append(digits.poll());
        }
        useLetter = !useLetter;
    }

    return result.toString();
}

-----
import java.util.LinkedList;
import java.util.Queue;

public String reformat(String s) 
    // Your code here
}

************************************
Question ID: 1418

import java.util.*;

public List<List<String>> displayTable(List<List<String>> orders) {
    TreeMap<Integer, TreeMap<String, Integer>> tables = new TreeMap<>();
    TreeSet<String> foodSet = new TreeSet<>();

    for (List<String> order : orders) {
        int tableNumber = Integer.parseInt(order.get(1));
        String foodItem = order.get(2);
        tables.putIfAbsent(tableNumber, new TreeMap<>());
        tables.get(tableNumber).put(foodItem, tables.get(tableNumber).getOrDefault(foodItem, 0) + 1);
        foodSet.add(foodItem);
    }

    List<List<String>> result = new ArrayList<>();
    List<String> header = new ArrayList<>();
    header.add("Table");
    header.addAll(foodSet);
    result.add(header);

    for (Map.Entry<Integer, TreeMap<String, Integer>> table : tables.entrySet()) {
        List<String> row = new ArrayList<>();
        row.add(Integer.toString(table.getKey()));
        for (String foodItem : foodSet) {
            row.add(Integer.toString(table.getValue().getOrDefault(foodItem, 0)));
        }
        result.add(row);
    }

    return result;
}

-----
import java.util.*;

public List<List<String>> displayTable(List<List<String>> orders) 
    // Your code here
}

************************************
Question ID: 1419

public int minNumberOfFrogs(String croakOfFrogs) {
    int[] counter = new int[5];
    int frogs = 0, max_frogs = 0;
    for (char ch : croakOfFrogs.toCharArray()) {
        int idx = "croak".indexOf(ch);
        counter[idx]++;
        if (idx == 0) {
            max_frogs = Math.max(max_frogs, ++frogs);
        } else if (--counter[idx - 1] < 0) {
            return -1;
        } else if (idx == 4) {
            frogs--;
        }
    }
    return (counter[0] == counter[1] && counter[1] == counter[2] && counter[2] == counter[3] && counter[3] == counter[4]) ? max_frogs : -1;
}

-----
public int minNumberOfFrogs(String croakOfFrogs) 
    // Your code here
}

************************************
Question ID: 1420

public int waysToBuildArray(int n, int m, int k) {
    final int mod = 1000000007;
    int[][] dp = new int[n+1][k+1];
    dp[0][0] = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= k; ++j) {
            for (int x = 1; x <= m; ++x) {
                if (j < i * (x-1)) {
                    dp[i][j] = (dp[i][j] + dp[i-1][j-(i-1)*(x-1)]) % mod;
                }
            }
        }
    }
    return dp[n][k];
}

-----
public int waysToBuildArray(int n, int m, int k) 
    // Your code here
}

************************************
Question ID: 1422

import java.util.TreeMap;

public boolean isPossibleDivide(int[] nums, int k) {
    TreeMap<Integer, Integer> counts = new TreeMap<>();
    for (int num : nums) counts.put(num, counts.getOrDefault(num, 0) + 1);
    
    for (int key : counts.keySet()) {
        if (counts.get(key) > 0) {
            for (int i = k - 1; i >= 0; --i) {
                if (!counts.containsKey(key + i) || counts.get(key + i) < counts.get(key)) return false;
                counts.put(key + i, counts.get(key + i) - counts.get(key));
            }
        }
    }
    
    return true;
}

-----
import java.util.TreeMap;

public boolean isPossibleDivide(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 1423

import java.util.HashMap;

public int maxSubstringOccurrences(String s, int k) {
    int n = s.length(), res = 0;
    HashMap<Character, Integer> freq = new HashMap<>();
    for (int i = 0; i < n; ++i) {
        freq.put(s.charAt(i), freq.getOrDefault(s.charAt(i), 0) + 1);
        if (freq.size() <= k) {
            res = Math.max(res, freq.get(s.charAt(i)));
        }
    }
    return (freq.size() > k) ? 0 : res;
}


-----
import java.util.HashMap;

public int maxSubstringOccurrences(String s, int k) 
    // Your code here
}


************************************
Question ID: 1424

import java.util.*;

public int maxCandies(int[] status, int[] candies, List<List<Integer>> keys, List<List<Integer>> containedBoxes, int[] initialBoxes) {
    int maxCandies = 0;
    Set<Integer> visited = new HashSet<>();
    Queue<Integer> toProcess = new LinkedList<>();

    for (int box : initialBoxes) {
        toProcess.offer(box);
    }

    while (!toProcess.isEmpty()) {
        int box = toProcess.poll();

        if (visited.contains(box)) {
            continue;
        }

        visited.add(box);

        if (status[box] == 1) {
            maxCandies += candies[box];
            for (int key : keys.get(box)) {
                status[key] = 1;
                if (visited.contains(key)) {
                    toProcess.offer(key);
                }
            }
            for (int contained : containedBoxes.get(box)) {
                toProcess.offer(contained);
            }
        } else {
            toProcess.offer(box);
        }
    }

    return maxCandies;
}

-----
import java.util.*;

public int maxCandies(int[] status, int[] candies, List<List<Integer>> keys, List<List<Integer>> containedBoxes, int[] initialBoxes) 
    // Your code here
}

************************************
Question ID: 1425

public int maxSum(int[] nums, int k) {
    int n = nums.length;
    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);
    long[] dp = new long[n + 1];
    long sum = 0;

    for (int i = 0; i < n; i++) {
        if (i >= k) pq.poll(); // Maintain the maximum size of k
        pq.offer((int)(dp[i] - nums[i]));
        dp[i + 1] = Math.max(dp[i], nums[i] + pq.peek());
        sum = Math.max(sum, dp[i + 1]);
    }

    return (int) sum;
}

-----
public int maxSum(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 1426

public int[] sumZero(int n) {
    int[] res = new int[n];
    for (int i = 1; i <= n / 2; i++) {
        res[i - 1] = i;
        res[n - i] = -i;
    }
    return res;
}

-----
public int[] sumZero(int n) 
    // Your code here
}

************************************
Question ID: 1428

boolean canReach(int[] arr, int start) {
    if (start >= 0 && start < arr.length && arr[start] >= 0) {
        if (arr[start] == 0)
            return true;

        arr[start] = -arr[start];
        return canReach(arr, start + arr[start]) || canReach(arr, start - arr[start]);
    }
    return false;
}

-----
boolean canReach(int[] arr, int start) 
    // Your code here
}

************************************
Question ID: 1429

import java.util.Map;

public boolean isSolvable(Map<Character, Integer> words, int result) {
    int sum = 0;
    for (int value : words.values()) {
        sum += value;
    }
    return sum % 10 == result % 10;
}

-----
import java.util.Map;

public boolean isSolvable(Map<Character, Integer> words, int result) 
    // Your code here
}

************************************
Question ID: 1431

import java.util.*;

public class DAGAncestors {
    public static void findAncestors(int node, List<List<Integer>> adjList, boolean[] visited, List<Integer> ancestors) {
        if (visited[node]) return;
        visited[node] = true;
        for (int ancestor : adjList.get(node)) {
            ancestors.add(ancestor);
            findAncestors(ancestor, adjList, visited, ancestors);
        }
    }

    public static List<List<Integer>> findAncestorsInDAG(int n, int[][] edges) {
        List<List<Integer>> adjList = new ArrayList<>();
        List<List<Integer>> ans = new ArrayList<>();
        for (int i = 0; i < n; ++i) {
            adjList.add(new ArrayList<>());
            ans.add(new ArrayList<>());
        }
        for (int[] edge : edges) {
            adjList.get(edge[1]).add(edge[0]);
        }
        for (int i = 0; i < n; ++i) {
            boolean[] visited = new boolean[n];
            findAncestors(i, adjList, visited, ans.get(i));
            Collections.sort(ans.get(i));
        }
        return ans;
    }
}


-----
import java.util.*;

public class DAGAncestors 
    // Your code here
}


************************************
Question ID: 1432

public int maxDiff(int num) {
    int a = -1, b = -1;
    String s = Integer.toString(num);
    for (char c : s.toCharArray()) {
        if (a == -1 && c != '9') {
            a = c - '0';
        }
        if (b == -1 && c > '1') {
            b = c - '0';
        }
        if (a != -1 && b != -1) {
            break;
        }
    }
    int result = 0;
    for (char c : s.toCharArray()) {
        if (c - '0' == a) {
            result = result * 10 + 9;
        } else if (c - '0' == b) {
            result = result * 10 + ((c == s.charAt(0)) ? 1 : 0);
        } else {
            result = result * 10 + c - '0';
        }
    }
    return result - num;
}


-----
public int maxDiff(int num) 
    // Your code here
}


************************************
Question ID: 1434

public class Solution {
    public String freqAlphabets(String s) {
        StringBuilder result = new StringBuilder();
        int i = 0;
        while (i < s.length()) {
            if (i + 2 < s.length() && s.charAt(i + 2) == '#') {
                result.append((char) ('a' + (s.charAt(i) - '0') * 10 + (s.charAt(i + 1) - '0') - 10));
                i += 3;
            } else {
                result.append((char) ('a' + s.charAt(i) - '1'));
                i++;
            }
        }
        return result.toString();
    }
}

-----
public class Solution 
    // Your code here
}

************************************
Question ID: 1436

import java.util.*;

public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {
    Set<Integer> visited = new HashSet<>();
    Queue<int[]> q = new LinkedList<>();
    Map<String, Integer> videoFreq = new HashMap<>();

    q.offer(new int[]{id, 0});
    visited.add(id);

    while (!q.isEmpty()) {
        int[] pair = q.poll();
        int currentId = pair[0];
        int currentLevel = pair[1];

        if (currentLevel == level) {
            for (String video : watchedVideos.get(currentId)) {
                videoFreq.put(video, videoFreq.getOrDefault(video, 0) + 1);
            }
        } else if (currentLevel < level) {
            for (int friendId : friends[currentId]) {
                if (!visited.contains(friendId)) {
                    visited.add(friendId);
                    q.offer(new int[]{friendId, currentLevel + 1});
                }
            }
        }
    }

    List<String> result = new ArrayList<>(videoFreq.keySet());

    result.sort((a, b) -> {
        if (videoFreq.get(a).equals(videoFreq.get(b))) {
            return a.compareTo(b);
        } else {
            return videoFreq.get(a) - videoFreq.get(b);
        }
    });

    return result;
}

-----
import java.util.*;

public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) 
    // Your code here
}

************************************
Question ID: 1437

int minStepsToMakePalindrome(String s) {
    int n = s.length();
    int[][] dp = new int[n][n];

    for (int i = n - 2; i >= 0; i--) {
        for (int j = i + 1; j < n; j++) {
            if (s.charAt(i) == s.charAt(j)) {
                dp[i][j] = dp[i + 1][j - 1];
            } else {
                dp[i][j] = 1 + Math.min(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    
    return dp[0][n - 1];
}

-----
int minStepsToMakePalindrome(String s) 
    // Your code here
}

************************************
Question ID: 1438

import java.util.ArrayDeque;
import java.util.Deque;

public int longestSubarray(int[] nums, int limit) {
    Deque<Integer> maxDeque = new ArrayDeque<>();
    Deque<Integer> minDeque = new ArrayDeque<>();
    int left = 0, right = 0, longest = 0;
    while (right < nums.length) {
        while (!maxDeque.isEmpty() && nums[right] > maxDeque.peekLast()) maxDeque.pollLast();
        while (!minDeque.isEmpty() && nums[right] < minDeque.peekLast()) minDeque.pollLast();
        
        maxDeque.offerLast(nums[right]);
        minDeque.offerLast(nums[right]);
        
        while (maxDeque.peekFirst() - minDeque.peekFirst() > limit) {
            if (nums[left] == maxDeque.peekFirst()) maxDeque.pollFirst();
            if (nums[left] == minDeque.peekFirst()) minDeque.pollFirst();
            left++;
        }
        
        longest = Math.max(longest, right - left + 1);
        right++;
    }
    return longest;
}

-----
import java.util.ArrayDeque;
import java.util.Deque;

public int longestSubarray(int[] nums, int limit) 
    // Your code here
}

************************************
Question ID: 1439

import java.util.PriorityQueue;

public int kthSmallest(int[][] mat, int k) {
    int m = mat.length, n = mat[0].length;
    PriorityQueue<int[]> minHeap = new PriorityQueue<int[]>((a, b) -> a[0] - b[0]);
    minHeap.offer(new int[]{mat[0][0], 0, 0});

    boolean[][] visited = new boolean[m][n];
    visited[0][0] = true;
    int count = 0;

    while (!minHeap.isEmpty()) {
        int[] cur = minHeap.poll();
        int sum = cur[0], row = cur[1], col = cur[2];

        count++;
        if (count == k) {
            return sum;
        }

        if (row + 1 < m && !visited[row + 1][col]) {
            visited[row + 1][col] = true;
            minHeap.offer(new int[]{sum - mat[row][col] + mat[row + 1][col], row + 1, col});
        }
        
        if (col + 1 < n && !visited[row][col + 1]) {
            visited[row][col + 1] = true;
            minHeap.offer(new int[]{sum - mat[row][col] + mat[row][col + 1], row, col + 1});
        }
    }
    
    return -1;
}

-----
import java.util.PriorityQueue;

public int kthSmallest(int[][] mat, int k) 
    // Your code here
}

************************************
Question ID: 1441

import java.util.ArrayList;
import java.util.List;

public List<String> buildArray(int[] target, int n) {
    List<String> result = new ArrayList<>();
    int current = 1;
    for (int num : target) {
        while (current < num) {
            result.add("Push ");
            result.add("Pop ");
            current++;
        }
        result.add("Push ");
        current++;
    }
    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<String> buildArray(int[] target, int n) 
    // Your code here
}

************************************
Question ID: 1442

import java.util.ArrayList;
import java.util.List;

public int makeConnected(int n, int[][] connections) {
    List<List<Integer>> adjList = new ArrayList<>();
    boolean[] visited = new boolean[n];
    int components = 0, extraEdges = 0;

    for (int i = 0; i < n; i++) {
        adjList.add(new ArrayList<>());
    }

    for (int[] connection : connections) {
        adjList.get(connection[0]).add(connection[1]);
        adjList.get(connection[1]).add(connection[0]);
    }

    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            components++;
            List<Integer> stack = new ArrayList<>();
            stack.add(i);

            while (!stack.isEmpty()) {
                int current = stack.remove(stack.size() - 1);

                if (!visited[current]) {
                    visited[current] = true;
                    for (int neighbor : adjList.get(current)) {
                        if (!visited[neighbor]) {
                            stack.add(neighbor);
                        } else {
                            extraEdges++;
                        }
                    }
                }
            }
        }
    }

    int extraNeeded = components - 1;

    if (extraEdges >= extraNeeded) {
        return extraNeeded;
    }

    return -1;
}


-----
import java.util.ArrayList;
import java.util.List;

public int makeConnected(int n, int[][] connections) 
    // Your code here
}


************************************
Question ID: 1443

public int minimum_distance(String word) {
    return dp(-1, -1, 0, word);
}

private int dp(int first, int second, int pos, String word) {
    if (pos == word.length()) return 0;
    
    int ans = 1_000_000_000;
    for (int i : new int[]{first, second}) {
        if (i != -1) {
            int dx = Math.abs(word.charAt(pos) - word.charAt(i)) % 6, dy = Math.abs(word.charAt(pos) - word.charAt(i)) / 6;
            ans = Math.min(ans, Math.min(dx, dy) * 2 + Math.max(dx, dy));
        }
    }
    ans += dp(first, second, pos + 1, word);

    if (first == -1 || second == -1) {
        ans = Math.min(ans, dp(first == -1 ? pos : first, word.charAt(pos), pos + 1, word));
    }

    return ans;
}


-----
public int minimum_distance(String word) 
    // Your code here
}


************************************
Question ID: 1444

int numberOfSteps(int num) {
    int steps = 0;
    while (num != 0) {
        steps += (num % 2 == 0) ? 1 : 2;
        num >>= 1;
    }
    return steps - 1;
}

-----
int numberOfSteps(int num) 
    // Your code here
}

************************************
Question ID: 1446

double angleClock(int hour, int minutes) {
    double minuteAngle = 6 * minutes;
    double hourAngle = 30 * hour + 0.5 * minutes;
    double angle = Math.abs(hourAngle - minuteAngle);
    return Math.min(angle, 360 - angle);
}

-----
double angleClock(int hour, int minutes) 
    // Your code here
}

************************************
Question ID: 1447

public int minJumps(int[] arr) {
    int n = arr.length;
    int maxReach = arr[0];
    int step = arr[0];
    int jumps = 1;

    if(n == 1) return 0;

    for(int i = 1; i < n; i++) {
        if(i == n - 1) return jumps;

        maxReach = Math.max(maxReach, i + arr[i]);

        step--;

        if(step == 0) {
            jumps++;
            step = maxReach - i;
        }
    }
    return -1;
}

-----
public int minJumps(int[] arr) 
    // Your code here
}

************************************
Question ID: 1448

public int maximum69Number(int num) {
    String numStr = Integer.toString(num);
    char[] numChars = numStr.toCharArray();
    for (int i = 0; i < numChars.length; i++) {
        if (numChars[i] == '6') {
            numChars[i] = '9';
            break;
        }
    }
    return Integer.parseInt(new String(numChars));
}

-----
public int maximum69Number(int num) 
    // Your code here
}

************************************
Question ID: 1449

public String largestNumber(int[] cost, int target) {
    String[] dp = new String[target + 1];
    dp[0] = "";

    for (int i = 0; i < 9; ++i) {
        for (int j = cost[i]; j <= target; ++j) {
            if (dp[j - cost[i]] != null && dp[j - cost[i]].length() < j - cost[i]
                    && (dp[j] == null || dp[j - cost[i]].length() + 1 > dp[j].length())) {
                dp[j] = dp[j - cost[i]] + (char) ('1' + i);
            }
        }
    }

    return dp[target] == null ? "0" : dp[target];
}

-----
public String largestNumber(int[] cost, int target) 
    // Your code here
}

************************************
Question ID: 1450

public TreeNode removeLeafNodes(TreeNode root, int target) {
    if (root == null) return null;
    root.left = removeLeafNodes(root.left, target);
    root.right = removeLeafNodes(root.right, target);
    if (root.left == null && root.right == null && root.val == target) {
        return null;
    }
    return root;
}


-----
public TreeNode removeLeafNodes(TreeNode root, int target) 
    // Your code here
}


************************************
Question ID: 1451

public int minTaps(int n, int[] ranges) {
    int[] intervals = new int[n + 1];
    for (int i = 0; i <= n; i++) {
        int left = Math.max(0, i - ranges[i]);
        int right = Math.min(n, i + ranges[i]);
        intervals[left] = Math.max(intervals[left], right - left);
    }

    int position = 0, total_taps = 0, max_reach = 0;
    while (position < n) {
        max_reach = Math.max(max_reach, position + intervals[position]);
        if (max_reach == position) return -1;
        position = max_reach;
        total_taps++;
    }
    return total_taps;
}

-----
public int minTaps(int n, int[] ranges) 
    // Your code here
}

************************************
Question ID: 1452

import java.util.*;

class Solution {
    public List<Integer> peopleIndexes(List<List<String>> favoriteCompanies) {
        List<Integer> result = new ArrayList<>();
        List<Set<String>> companySets = new ArrayList<>();
        
        for (List<String> companies : favoriteCompanies) {
            companySets.add(new HashSet<String>(companies));
        }
        
        for (int i = 0; i < companySets.size(); ++i) {
            boolean isSubset = false;
            for (int j = 0; j < companySets.size(); ++j) {
                if (i != j && companySets.get(j).containsAll(companySets.get(i))) {
                    isSubset = true;
                    break;
                }
            }
            if (!isSubset) result.add(i);
        }
        
        return result;
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 1453

import java.util.List;

public int numPoints(List<List<Integer>> darts, int r) {
    int n = darts.size();
    int result = 1;
    
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            int cnt = 0;
            for (int k = 0; k < n; ++k) {
                int dx = darts.get(i).get(0) - darts.get(k).get(0);
                int dy = darts.get(i).get(1) - darts.get(k).get(1);
                if (Math.sqrt(dx * dx + dy * dy) <= r) cnt++;
            }
            
            if (cnt > result) result = cnt;
        }
    }
    return result;
}

-----
import java.util.List;

public int numPoints(List<List<Integer>> darts, int r) 
    // Your code here
}

************************************
Question ID: 1455

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public List<Integer> filterRestaurants(int[][] restaurants, int veganFriendly, int maxPrice, int maxDistance) {
    List<int[]> filteredRestaurants = new ArrayList<>();
    for (int[] r : restaurants) {
        if ((veganFriendly == 0 || r[2] == veganFriendly) && r[3] <= maxPrice && r[4] <= maxDistance) {
            filteredRestaurants.add(r);
        }
    }
    Collections.sort(filteredRestaurants, (a, b) -> a[1] == b[1] ? b[0] - a[0] : b[1] - a[1]);
    List<Integer> ids = new ArrayList<>();
    for (int[] r : filteredRestaurants) {
        ids.add(r[0]);
    }
    return ids;
}

-----
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public List<Integer> filterRestaurants(int[][] restaurants, int veganFriendly, int maxPrice, int maxDistance) 
    // Your code here
}

************************************
Question ID: 1456

import java.util.*;

public int findTheCity(int n, int[][] edges, int distanceThreshold) {
    int INF = Integer.MAX_VALUE;
    int[][] dist = new int[n][n];

    for (int i = 0; i < n; ++i) {
        Arrays.fill(dist[i], INF);
        dist[i][i] = 0;
    }

    for (int[] edge : edges) {
        dist[edge[0]][edge[1]] = dist[edge[1]][edge[0]] = edge[2];
    }

    for (int k = 0; k < n; ++k) {
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (dist[i][k] != INF && dist[k][j] != INF)
                    dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
            }
        }
    }

    int res = -1, minReachable = n + 1;
    for (int i = 0; i < n; ++i) {
        int cnt = 0;
        for (int d : dist[i]) {
            if (d <= distanceThreshold) ++cnt;
        }
        if (cnt <= minReachable) {
            minReachable = cnt;
            res = i;
        }
    }
    return res;
}


-----
import java.util.*;

public int findTheCity(int n, int[][] edges, int distanceThreshold) 
    // Your code here
}


************************************
Question ID: 1457

public int minDifficulty(int[] jobDifficulty, int d) {
    int n = jobDifficulty.length;
    if (n < d) return -1;
    int[][] dp = new int[d][n];

    dp[0][0] = jobDifficulty[0];
    for (int i = 1; i < n; ++i) {
        dp[0][i] = Math.max(dp[0][i-1], jobDifficulty[i]);
    }

    for (int i = 1; i < d; ++i) {
        for (int j = i; j < n; ++j) {
            int maxD = jobDifficulty[j];
            for (int k = j; k >= i; --k) {
                maxD = Math.max(maxD, jobDifficulty[k]);
                dp[i][j] = Math.min(dp[i][j], dp[i-1][k-1] + maxD);
            }
        }
    }
    return dp[d-1][n-1];
}


-----
public int minDifficulty(int[] jobDifficulty, int d) 
    // Your code here
}


************************************
Question ID: 1458

import java.util.Arrays;
import java.util.Comparator;

public int[] sortByBits(int[] arr) {
    Integer[] boxedArr = Arrays.stream(arr).boxed().toArray(Integer[]::new);
    Arrays.sort(boxedArr, new Comparator<Integer>() {
        @Override
        public int compare(Integer a, Integer b) {
            int count_a = Integer.bitCount(a);
            int count_b = Integer.bitCount(b);
            
            if (count_a == count_b) {
                return a - b;
            }
            return count_a - count_b;
        }
    });

    return Arrays.stream(boxedArr).mapToInt(Integer::intValue).toArray();
}


-----
import java.util.Arrays;
import java.util.Comparator;

public int[] sortByBits(int[] arr) 
    // Your code here
}


************************************
Question ID: 1460

public int numberOfSubstrings(String s) {
    int res = 0, left = 0;
    int[] count = new int[3];
    
    for (int right = 0; right < s.length(); right++) {
        count[s.charAt(right) - 'a']++;
        
        while (count[0] > 0 && count[1] > 0 && count[2] > 0) {
            count[s.charAt(left++) - 'a']--;
        }
        
        res += left;
    }
    
    return res;
}

-----
public int numberOfSubstrings(String s) 
    // Your code here
}

************************************
Question ID: 1461

int countOrders(int n) {
    long MOD = 1000000007;
    long ans = 1;
    for (int i = 1; i <= n; ++i) {
        ans = ans * (2 * i - 1) * i % MOD;
    }
    return (int) ans;
}

-----
int countOrders(int n) 
    // Your code here
}

************************************
Question ID: 1462

import java.util.List;
import java.util.ArrayList;

public List<Boolean> checkIfPrerequisite(int numCourses, int[][] prerequisites, int[][] queries) {
    boolean[][] adj_matrix = new boolean[numCourses][numCourses];
    for (int[] pre : prerequisites) {
        adj_matrix[pre[0]][pre[1]] = true;
    }
    
    for (int k = 0; k < numCourses; k++) {
        for (int i = 0; i < numCourses; i++) {
            for (int j = 0; j < numCourses; j++) {
                adj_matrix[i][j] = adj_matrix[i][j] || (adj_matrix[i][k] && adj_matrix[k][j]);
            }
        }
    }

    List<Boolean> answer = new ArrayList<>();
    for (int[] query : queries) {
        answer.add(adj_matrix[query[0]][query[1]]);
    }
    return answer;
}


-----
import java.util.List;
import java.util.ArrayList;

public List<Boolean> checkIfPrerequisite(int numCourses, int[][] prerequisites, int[][] queries) 
    // Your code here
}


************************************
Question ID: 1463

import java.util.*;

public int[] kWeakestRows(int[][] mat, int k) {
    int m = mat.length;
    int[] result = new int[k];
    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);

    for (int i = 0; i < m; ++i) {
        int soldiers = 0;
        for (int val : mat[i]) {
            if (val == 1) {
                soldiers++;
            } else {
                break;
            }
        }
        pq.add(new int[]{soldiers, i});
    }

    for (int i = 0; i < k; ++i) {
        result[i] = pq.poll()[1];
    }
    return result;
}


-----
import java.util.*;

public int[] kWeakestRows(int[][] mat, int k) 
    // Your code here
}


************************************
Question ID: 1464

import java.util.HashMap;
import java.util.ArrayList;
import java.util.Collections;

public int minSetSize(int[] arr) {
    HashMap<Integer, Integer> count = new HashMap<>();
    for (int value : arr)
        count.put(value, count.getOrDefault(value, 0) + 1);

    ArrayList<Integer> freq = new ArrayList<>(count.values());
    Collections.sort(freq, Collections.reverseOrder());

    int removed = 0, setSize = 0;
    for (int f : freq) {
        removed += f;
        setSize++;
        if (removed * 2 >= arr.length)
            return setSize;
    }

    return 0;
}


-----
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Collections;

public int minSetSize(int[] arr) 
    // Your code here
}


************************************
Question ID: 1466

import java.util.Arrays;

public int maxJumps(int[] arr, int d) {
    int n = arr.length;
    int[] dp = new int[n];
    Arrays.fill(dp, 1);

    for (int i = 0; i < n; i++) {
        maxJumpsHelper(arr, d, dp, i);
    }

    return Arrays.stream(dp).max().getAsInt();
}

private int maxJumpsHelper(int[] arr, int d, int[] dp, int idx) {
    if (dp[idx] > 1) return dp[idx];
    int maximum = 1;

    for (int i = 1; i <= d; i++) {
        if (idx + i < arr.length && arr[idx] <= arr[idx + i]) break;
        if (idx + i < arr.length)
            maximum = Math.max(maximum, 1 + maxJumpsHelper(arr, d, dp, idx + i));

        if (idx - i >= 0 && arr[idx] <= arr[idx - i]) break;
        if (idx - i >= 0)
            maximum = Math.max(maximum, 1 + maxJumpsHelper(arr, d, dp, idx - i));
    }
    dp[idx] = maximum;
    return maximum;
}


-----
import java.util.Arrays;

public int maxJumps(int[] arr, int d) 
    // Your code here
}


************************************
Question ID: 1467

import java.util.ArrayList;
import java.util.List;

public double factorial(int num) {
    double result = 1;
    for (int i = 1; i <= num; i++)
        result *= i;
    return result;
}

public double countCombinations(int[] balls, List<Integer> combinations, int currBall) {
    double totalCombinations = 1;
    for (int i = 0; i < currBall; i++)
        totalCombinations *= factorial(balls[i] + combinations.get(i)) / (factorial(balls[i]) * factorial(combinations.get(i)));

    return totalCombinations;
}

public double dfs(int[] balls, List<Integer> combinations, int currBall) {
    if (currBall == balls.length) {
        if (combinations.get(combinations.size() - 1).equals(combinations.get(0)))
            return countCombinations(balls, combinations, currBall);
        else
            return 0;
    }

    double result = 0;
    for (int i = 0; i <= balls[currBall]; i++) {
        combinations.add(i);
        result += dfs(balls, combinations, currBall + 1);
        combinations.remove(combinations.size() - 1);
    }

    return result;
}

public double getProbability(int[] balls) {
    int sumBalls = 0;
    for (int ball : balls)
        sumBalls += ball;

    double totalCombinations = 1;
    for (int ball : balls)
        totalCombinations *= factorial(ball);

    List<Integer> combinations = new ArrayList<>();
    return dfs(balls, combinations, 0) / totalCombinations;
}

-----
import java.util.ArrayList;
import java.util.List;

public double factorial(int num) 
    // Your code here
}

************************************
Question ID: 1469

public int minSteps(String s, String t) {
    int[] countS = new int[26];
    int[] countT = new int[26];
    int steps = 0;

    for (char c : s.toCharArray()) countS[c - 'a']++;
    for (char c : t.toCharArray()) countT[c - 'a']++;

    for (int i = 0; i < 26; i++) {
        steps += Math.abs(countS[i] - countT[i]);
    }

    return steps / 2;
}

-----
public int minSteps(String s, String t) 
    // Your code here
}

************************************
Question ID: 1470

import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.TreeMap;

public class TweetCounts {
    public void recordTweet(String tweetName, int time) {
        tweetRecords.computeIfAbsent(tweetName, k -> new TreeMap<>())
        .compute(time, (k, v) -> v == null ? 1 : v + 1);
    }

    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {
        int interval;
        if (freq.equals("minute")) interval = 60;
        else if (freq.equals("hour")) interval = 3600;
        else interval = 86400;

        List<Integer> result = new ArrayList<>((endTime - startTime) / interval + 1);
        for (int i = 0; i < (endTime - startTime) / interval + 1; i++) result.add(0);

        if (!tweetRecords.containsKey(tweetName)) return result;

        for (int time : tweetRecords.get(tweetName).navigableKeySet()) {
            if (time >= startTime && time <= endTime) {
                result.set((time - startTime) / interval,
                        result.get((time - startTime) / interval) + tweetRecords.get(tweetName).get(time));
            }
        }

        return result;
    }

    private HashMap<String, TreeMap<Integer, Integer>> tweetRecords = new HashMap<>();
}


-----
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.TreeMap;

public class TweetCounts 
    // Your code here
}


************************************
Question ID: 1471

int maxStudents(char[][] seats) {
    int m = seats.length, n = seats[0].length;
    int[] validRows = new int[m];
    int max_valid = (1 << n) - 1;
    for (int i = 0; i < m; i++) {
        int state = 0;
        for (int j = 0; j < n; j++) {
            state |= (seats[i][j] == '.') ? (1 << j) : 0;
        }
        validRows[i] = state;
    }

    int[][] memo = new int[m][1 << n];
    for(int i = 0; i < m; i++) {
        Arrays.fill(memo[i], -1);
    }
    return dfs(0, 0, validRows, m, n, max_valid, memo);
}

int dfs(int rowIndex, int prevState, int[] validRows, int m, int n, int max_valid, int[][] memo) {
    if (rowIndex == m) {
        return 0;
    }

    if (memo[rowIndex][prevState] != -1) {
        return memo[rowIndex][prevState];
    }

    int maxStudents = 0;
    for (int curState = 0; curState <= max_valid; curState++) {
        if ((curState & validRows[rowIndex]) != curState) continue;
        if ((curState & (curState << 1)) != 0) continue;
        if ((curState & (prevState << 1)) != 0 || (prevState & (curState << 1)) != 0) continue;

        maxStudents = Math.max(maxStudents, dfs(rowIndex + 1, curState, validRows, m, n, max_valid, memo) + Integer.bitCount(curState));
    }

    memo[rowIndex][prevState] = maxStudents;
    return maxStudents;
}

-----
int maxStudents(char[][] seats) 
    // Your code here
}

************************************
Question ID: 1472

import java.util.Map;
import java.util.TreeMap;

public String sortString(String s) {
    StringBuilder result = new StringBuilder();
    Map<Character, Integer> freqMap = new TreeMap<>();

    for (char c : s.toCharArray()) {
        freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);
    }

    while (!freqMap.isEmpty()) {
        for (char c : new ArrayList<>(freqMap.keySet())) {
            result.append(c);
            freqMap.put(c, freqMap.get(c) - 1);
            if (freqMap.get(c) == 0) {
                freqMap.remove(c);
            }
        }

        for (char c : new ArrayList<>(freqMap.descendingKeySet())) {
            result.append(c);
            freqMap.put(c, freqMap.get(c) - 1);
            if (freqMap.get(c) == 0) {
                freqMap.remove(c);
            }
        }
    }

    return result.toString();
}

-----
import java.util.Map;
import java.util.TreeMap;

public String sortString(String s) 
    // Your code here
}

************************************
Question ID: 1473

import java.util.HashMap;
import java.util.Map;

public int findTheLongestSubstring(String s) {
    Map<Integer, Integer> map = new HashMap<>();
    map.put(0, -1);
    int res = 0, n = s.length(), i, j = 0;
    for (i = 0; i < n; i++) {
        switch (s.charAt(i)) {
            case 'a': j ^= 1; break;
            case 'e': j ^= 2; break;
            case 'i': j ^= 4; break;
            case 'o': j ^= 8; break;
            case 'u': j ^= 16; break;
        }
        map.putIfAbsent(j, i);
        res = Math.max(res, i - map.get(j));
    }
    return res;
}

-----
import java.util.HashMap;
import java.util.Map;

public int findTheLongestSubstring(String s) 
    // Your code here
}

************************************
Question ID: 1476

public int countNegatives(int[][] grid) {
    int m = grid.length, n = grid[0].length, count = 0, i = 0, j = n - 1;
    while (i < m && j >= 0) {
        if (grid[i][j] < 0) {
            count += j + 1;
            i++;
        } else {
            j--;
        }
    }
    return count;
}

-----
public int countNegatives(int[][] grid) 
    // Your code here
}

************************************
Question ID: 1478

import java.util.Arrays;

public int maxEvents(int[][] events) {
    Arrays.sort(events, (a, b) -> a[1] - b[1]);

    int count = 0;
    int lastDay = -1;

    for (int[] event : events) {
        if (event[0] > lastDay) {
            count++;
            lastDay = event[1];
        }
    }

    return count;
}

-----
import java.util.Arrays;

public int maxEvents(int[][] events) 
    // Your code here
}

************************************
Question ID: 1480

public int[] runningSum(int[] nums) {
    for(int i = 1; i < nums.length; i++) {
        nums[i] += nums[i - 1];
    }
    return nums;
}

-----
public int[] runningSum(int[] nums) 
    // Your code here
}

************************************
Question ID: 1481

import java.util.*;
class Solution {
    public int findLeastNumOfUniqueInts(int[] arr, int k) {
        Map<Integer, Integer> count = new HashMap<>();
        for (int n : arr) {
           count.put(n, count.getOrDefault(n, 0) + 1);
        }
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for (int freq : count.values()) {
            pq.add(freq);
        }
        while (k > 0) {
            k -= pq.poll();
        }
        return k == 0 ? pq.size() : pq.size() + 1;
    }
}

-----
import java.util.*;
class Solution 
    // Your code here
}

************************************
Question ID: 1482

public int[] smallerNumbersThanCurrent(int[] nums) {
    int[] result = new int[nums.length];
    for (int i = 0; i < nums.length; i++) {
        for (int j = 0; j < nums.length; j++) {
            if (nums[j] < nums[i]) {
                result[i]++;
            }
        }
    }
    return result;
}

-----
public int[] smallerNumbersThanCurrent(int[] nums) 
    // Your code here
}

************************************
Question ID: 1483

import java.util.Arrays;
import java.util.Comparator;

public class Solution {
    public String rankTeams(String[] votes) {
        int teams = votes[0].length();
        int[][] ranks = new int[26][teams];

        for (String vote : votes) {
            for (int i = 0; i < teams; ++i) {
                ranks[vote.charAt(i) - 'A'][i]++;
            }
        }

        Character[] result = new Character[teams];
        for (int i = 0; i < teams; ++i) {
            result[i] = votes[0].charAt(i);
        }

        Arrays.sort(result, new Comparator<Character>() {
            public int compare(Character a, Character b) {
                for (int i = 0; i < teams; ++i) {
                    if (ranks[a - 'A'][i] != ranks[b - 'A'][i]) {
                        return ranks[b - 'A'][i] - ranks[a - 'A'][i];
                    }
                }
                return a.compareTo(b);
            }
        });

        StringBuilder sb = new StringBuilder();
        for (Character ch : result) {
            sb.append(ch);
        }
        return sb.toString();
    }
}


-----
import java.util.Arrays;
import java.util.Comparator;

public class Solution 
    // Your code here
}


************************************
Question ID: 1485

import java.util.Queue;
import java.util.LinkedList;

public int minCost(int[][] grid) {
    int m = grid.length, n = grid[0].length;
    int[][] cost = new int[m][n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            cost[i][j] = 1_000_000;
        }
    }
    Queue<int[]> q = new LinkedList<>();
    dfs(grid, cost, q, 0, 0, 0);
    int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    while (!q.isEmpty()) {
        int[] pos = q.poll();
        int r = pos[0], c = pos[1];
        for (int i = 0; i < 4; i++) {
            int nr = r + directions[i][0], nc = c + directions[i][1];
            dfs(grid, cost, q, nr, nc, cost[r][c] + (grid[r][c] == i + 1 ? 0 : 1));
        }
    }
    
    return cost[m - 1][n - 1];
}

void dfs(int[][] grid, int[][] cost, Queue<int[]> q, int r, int c, int d) {
    int m = grid.length, n = grid[0].length;
    if (r >= 0 && r < m && c >= 0 && c < n && d < cost[r][c]) {
        cost[r][c] = d;
        q.add(new int[]{r, c});
    }
}

-----
import java.util.Queue;
import java.util.LinkedList;

public int minCost(int[][] grid) 
    // Your code here
}

************************************
Question ID: 1486

public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {
    int count = 0;
    for (int i = 0; i < arr1.length; i++) {
        boolean valid = true;
        for (int j = 0; j < arr2.length; j++) {
            if (Math.abs(arr1[i] - arr2[j]) <= d) {
                valid = false;
                break;
            }
        }
        if (valid) count++;
    }
    return count;
}

-----
public int findTheDistanceValue(int[] arr1, int[] arr2, int d) 
    // Your code here
}

************************************
Question ID: 1487

import java.util.*;

public int maxNumberOfFamilies(int n, int[][] reservedSeats) {
    Map<Integer, Integer> rows = new HashMap<>();
    for (int[] seat : reservedSeats) {
        rows.put(seat[0], rows.getOrDefault(seat[0], 0) | (1 << (seat[1] - 1)));
    }
    
    int max_groups = (n - rows.size()) * 2;
    for (int rowMasks : rows.values()) {
        int seats = ~(rowMasks | (rowMasks >> 1) | (rowMasks >> 2) | (rowMasks >> 3)) & 0x3FF;        
        max_groups += (seats & (seats >> 1) & (seats >> 2) & (seats >> 3)) != 0 ? 1 : 0;
    }
    
    return max_groups;
}

-----
import java.util.*;

public int maxNumberOfFamilies(int n, int[][] reservedSeats) 
    // Your code here
}

************************************
Question ID: 1488

int getPower(int x) {
    int steps = 0;
    while (x != 1) {
        if (x % 2 == 0) x /= 2;
        else x = 3 * x + 1;
        steps++;
    }
    return steps;
}

int sortByPower(int lo, int hi, int k) {
    List<int[]> nums = new ArrayList<>();
    for (int i = lo; i <= hi; i++) {
        nums.add(new int[]{getPower(i), i});
    }
    nums.sort(Comparator.comparingInt((int[] a) -> a[0]).thenComparingInt(a -> a[1]));
    return nums.get(k - 1)[1];
}

-----
int getPower(int x) 
    // Your code here
}

************************************
Question ID: 1489

public int maxSizeSlices(int[] slices) {
    int n = slices.length / 3;
    int[][] memo1 = new int[slices.length][n + 1];
    for (int[] row : memo1) {
        Arrays.fill(row, -1);
    }
    int[][] memo2 = new int[slices.length][n + 1];
    for (int[] row : memo2) {
        Arrays.fill(row, -1);
    }

    return Math.max(maxSum(slices, 0, slices.length - 1, n, memo1),
                    maxSum(slices, 1, slices.length, n, memo2));
}

int maxSum(int[] slices, int start, int end, int n, int[][] memo) {
    if (n == 0) return 0;
    if (end - start + 1 < n * 2) return Integer.MIN_VALUE;
    if (memo[start][n] != -1) return memo[start][n];

    int pick = maxSum(slices, start + 2, end, n - 1, memo) + slices[start];
    int notPick = maxSum(slices, start + 1, end, n, memo);

    memo[start][n] = Math.max(pick, notPick);
    return memo[start][n];
}


-----
public int maxSizeSlices(int[] slices) 
    // Your code here
}


************************************
Question ID: 1490

public class Solution {
    public String generateTheString(int n) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n - 1; i++) {
            sb.append('a');
        }
        if (n % 2 == 0) {
            sb.append('b');
        } else {
            sb.append('a');
        }
        return sb.toString();
    }
}

-----
public class Solution 
    // Your code here
}

************************************
Question ID: 1491

public int countPrefixAligned(int[] flips) {
    int count = 0;
    for (int i = 0; i < flips.length; i++) {
        if (flips[i] == i + 1) {
            count++;
        }
    }
    return count;
}

-----
public int countPrefixAligned(int[] flips) 
    // Your code here
}

************************************
Question ID: 1492

import java.util.*;

public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {
    List<List<Integer>> subordinates = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        subordinates.add(new LinkedList<>());
    }
    for (int i = 0; i < n; i++) {
        if (manager[i] != -1) {
            subordinates.get(manager[i]).add(i);
        }
    }

    Queue<Pair> queue = new LinkedList<>();
    queue.offer(new Pair(headID, 0));
    int totalTime = 0;

    while (!queue.isEmpty()) {
        Pair pair = queue.poll();
        int current = pair.employeeID;
        int time = pair.time;
        totalTime = Math.max(totalTime, time);
        for (int sub : subordinates.get(current)) {
            queue.offer(new Pair(sub, time + informTime[current]));
        }
    }
    return totalTime;
}

class Pair {
    int employeeID;
    int time;

    Pair(int employeeID, int time) {
        this.employeeID = employeeID;
        this.time = time;
    }
}


-----
import java.util.*;

public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) 
    // Your code here
}


************************************
Question ID: 1493

import java.util.ArrayList;
import java.util.List;

public double frogPosition(int n, int[][] edges, int t, int target) {
    List<Integer>[] graph = new ArrayList[n + 1];
    for (int i = 0; i <= n; i++) {
        graph[i] = new ArrayList<>();
    }
    for (int[] edge : edges) {
        graph[edge[0]].add(edge[1]);
        graph[edge[1]].add(edge[0]);
    }
    return dfs(1, -1, t, target, graph);
}

private double dfs(int node, int parent, int t, int target, List<Integer>[] graph) {
    if (t == 0) {
        return node == target ? 1.0 : 0.0;
    }
    double probability = 0.0;
    for (int neighbor : graph[node]) {
        if (neighbor != parent) {
            probability += dfs(neighbor, node, t - 1, target, graph);
        }
    }
    return probability / (graph[node].size() - (parent == -1 ? 0 : 1));
}


-----
import java.util.ArrayList;
import java.util.List;

public double frogPosition(int n, int[][] edges, int t, int target) 
    // Your code here
}


************************************
Question ID: 1494

import java.util.*;

public int minNumberOfSemesters(int n, int[][] relations, int k) {
    int[] indegree = new int[n + 1];
    List<List<Integer>> graph = new ArrayList<>();
    for (int i = 0; i <= n; i++) {
        graph.add(new ArrayList<>());
    }

    for (int[] relation : relations) {
        graph.get(relation[0]).add(relation[1]);
        indegree[relation[1]]++;
    }

    int semesters = 0;
    while (n > 0) {
        Queue<Integer> zero_indegree = new LinkedList<>();
        for (int i = 1; i < indegree.length; i++) {
            if (indegree[i] == 0) {
                zero_indegree.add(i);
                indegree[i] = -1;
            }
        }

        int courses = 0;
        while (!zero_indegree.isEmpty() && courses < k) {
            int curr_course = zero_indegree.poll();
            n--;

            for (int next_course : graph.get(curr_course)) {
                indegree[next_course]--;
            }
            courses++;
        }
        semesters++;
    }
    return semesters;
}

-----
import java.util.*;

public int minNumberOfSemesters(int n, int[][] relations, int k) 
    // Your code here
}

************************************
Question ID: 1496

import java.util.ArrayList;
import java.util.List;

public List<Integer> luckyNumbers(int[][] matrix) {
    int m = matrix.length, n = matrix[0].length;
    List<Integer> luckyNumbers = new ArrayList<>();

    for (int i = 0; i < m; i++) {
        int minRow = matrix[i][0];
        int minRowIndex = 0;
        for (int j = 0; j < n; j++) {
            if (matrix[i][j] < minRow) {
                minRow = matrix[i][j];
                minRowIndex = j;
            }
        }

        boolean isLucky = true;
        for (int k = 0; k < m; k++) {
            if (matrix[k][minRowIndex] > minRow) {
                isLucky = false;
                break;
            }
        }

        if (isLucky)
            luckyNumbers.add(minRow);
    }

    return luckyNumbers;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<Integer> luckyNumbers(int[][] matrix) 
    // Your code here
}

************************************
Question ID: 1498

public TreeNode getTargetCopy(TreeNode original, TreeNode cloned, TreeNode target) {
    if (original == null)
        return null;
    if (original == target)
        return cloned;

    TreeNode left = getTargetCopy(original.left, cloned.left, target);
    return left != null ? left : getTargetCopy(original.right, cloned.right, target);
}

-----
public TreeNode getTargetCopy(TreeNode original, TreeNode cloned, TreeNode target) 
    // Your code here
}

************************************
Question ID: 1499

import java.util.*;

class Solution {
    public int maxPerformance(int n, int k, int[] speed, int[] efficiency) {
        int[][] engineers = new int[n][2];
        for (int i = 0; i < n; i++) {
            engineers[i] = new int[]{efficiency[i], speed[i]};
        }
        Arrays.sort(engineers, (a, b) -> b[0] - a[0]);

        long sum = 0, result = 0;
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        for (int[] engineer : engineers) {
            if (minHeap.size() >= k) {
                sum -= minHeap.poll();
            }
            minHeap.offer(engineer[1]);
            sum += engineer[1];
            result = Math.max(result, engineer[0] * sum);
        }
        return (int) (result % 1000000007);
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 1500

public int countLargestGroup(int n) {
    int[] freq = new int[37];
    int maxGroupSize = 0, maxGroupCount = 0;

    for (int i = 1; i <= n; i++) {
        int sum = 0, num = i;
        while (num != 0) {
            sum += num % 10;
            num = num / 10;
        }
        freq[sum]++;
        maxGroupSize = Math.max(maxGroupSize, freq[sum]);
    }

    for (int i = 0; i < 37; i++) {
        if (freq[i] == maxGroupSize) {
            maxGroupCount++;
        }
    }

    return maxGroupCount;
}


-----
public int countLargestGroup(int n) 
    // Your code here
}


************************************
Question ID: 1502

public boolean canConstruct(String s, int k) {
    int[] charCounts = new int[26];

    for (char c : s.toCharArray()) 
        charCounts[c - 'a']++;

    int oddCount = 0;
    for (int count : charCounts) 
        oddCount += count % 2;

    return oddCount <= k && k <= s.length();
}


-----
public boolean canConstruct(String s, int k) 
    // Your code here
}


************************************
Question ID: 1503

import java.util.Arrays;

public int maxSatisfaction(int[] satisfaction) {
    Arrays.sort(satisfaction);
    int ans = 0, total = 0, sum = 0;
    for (int i = satisfaction.length - 1; i >= 0; i--) {
        total += satisfaction[i];
        if (total > 0) {
            sum += total;
            ans = Math.max(ans, sum);
        }
    }
    return ans;
}

-----
import java.util.Arrays;

public int maxSatisfaction(int[] satisfaction) 
    // Your code here
}

************************************
Question ID: 1504

public int numSubmat(int[][] mat) {
    int m = mat.length, n = mat[0].length;
    int[][] dp = new int[m][n];
    int ans = 0;

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (mat[i][j] == 1) {
                dp[i][j] = j == 0 ? 1 : dp[i][j-1] + 1;
                int width = dp[i][j];
                for (int k = i; k >= 0; k--) {
                    width = Math.min(width, dp[k][j]);
                    ans += width;
                }
            }
        }
    }
    return ans;
}

-----
public int numSubmat(int[][] mat) 
    // Your code here
}

************************************
Question ID: 1505

import java.util.ArrayList;

public int[] createTargetArray(int[] nums, int[] index) {
    ArrayList<Integer> target = new ArrayList<>();
    for (int i = 0; i < nums.length; ++i) {
        target.add(index[i], nums[i]);
    }
    int[] result = new int[target.size()];
    for (int i = 0; i < target.size(); ++i) {
        result[i] = target.get(i);
    }
    return result;
}

-----
import java.util.ArrayList;

public int[] createTargetArray(int[] nums, int[] index) 
    // Your code here
}

************************************
Question ID: 1507

public boolean hasValidPath(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    boolean[][] visited = new boolean[m][n];

    return dfs(grid, 0, 0, m, n, visited);
}

private boolean dfs(int[][] grid, int x, int y, int m, int n, boolean[][] visited) {
    if (x < 0 || y < 0 || x >= m || y >= n || visited[x][y]) return false;
    if (x == m - 1 && y == n - 1) return true;
    
    visited[x][y] = true;

    int[] next_x = {-1, 0, 1, 0};
    int[] next_y = {0, 1, 0, -1};

    for (int i = 0; i < 4; i++) {
        int dx = x + next_x[i];
        int dy = y + next_y[i];

        if (dfs(grid, dx, dy, m, n, visited)) return true;
    }

    return false;
}

-----
public boolean hasValidPath(int[][] grid) 
    // Your code here
}

************************************
Question ID: 1508

public String longestHappyPrefix(String s) {
    int n = s.length();
    int[] lps = new int[n];
    int len = 0;
    int i = 1;
    while (i < n) {
        if (s.charAt(i) == s.charAt(len)) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    return s.substring(0, lps[n - 1]);
}

-----
public String longestHappyPrefix(String s) 
    // Your code here
}

************************************
Question ID: 1509

public int minDifference(int[] nums) {
    int n = nums.length;
    if (n <= 4) return 0;
    Arrays.sort(nums);
    int res = Integer.MAX_VALUE;
    for (int i = 0; i <= 3; ++i)
        res = Math.min(res, nums[n - 4 + i] - nums[i]);
    return res;
}

-----
public int minDifference(int[] nums) 
    // Your code here
}

************************************
Question ID: 1510

import java.util.HashMap;

public int findLucky(int[] arr) {
    HashMap<Integer, Integer> freq = new HashMap<>();

    for (int n : arr) {
        freq.put(n, freq.getOrDefault(n, 0) + 1);
    }

    int lucky = -1;
    for (int key : freq.keySet()) {
        if (key == freq.get(key)) {
            lucky = Math.max(lucky, key);
        }
    }

    return lucky;
}

-----
import java.util.HashMap;

public int findLucky(int[] arr) 
    // Your code here
}

************************************
Question ID: 1513

class Solution {
    private static final int MOD = 1000000007;

    public int countGoodStrings(String s1, String s2, String evil) {
        int n = s1.length();
        int m = evil.length();
        int[][] dp = new int[n + 1][m];

        // Preprocess the KMP prefix function for the evil string
        int[] lps = new int[m];
        int len = 0;
        for (int i = 1; i < m;) {
            if (evil.charAt(i) == evil.charAt(len)) {
                lps[i++] = ++len;
            } else if (len > 0) {
                len = lps[len - 1];
            } else {
                ++i;
            }
        }

        dp[0][0] = 1;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                for (int k = 0; k < 2; ++k) {
                    for (char c = 'a'; c <= (k == 1 ? s2.charAt(i) : 'z'); ++c) {
                        int e = j;
                        while (e > 0 && (c != evil.charAt(e))) {
                            e = lps[e - 1];
                        }

                        if (c != evil.charAt(e)) {
                            e++;
                        }

                        if (e != m) {
                            dp[i + 1][k | ((c < s2.charAt(i)) ? 1 : 0)] += dp[i][k];
                            dp[i + 1][k | ((c < s2.charAt(i)) ? 1 : 0)] %= MOD;
                        }
                    }
                }
            }
        }

        return (dp[n][1] - dp[n][0] + MOD) % MOD;
    }
}


-----
class Solution 
    // Your code here
}


************************************
Question ID: 1514

public int minStartValue(int[] nums) {
    int min_sum = 0, sum = 0;
    for (int num : nums) {
        sum += num;
        min_sum = Math.min(min_sum, sum);
    }
    return 1 - min_sum;
}

-----
public int minStartValue(int[] nums) 
    // Your code here
}

************************************
Question ID: 1515

public int findMinFibonacciNumbers(int k) {
    if (k == 0) return 0;
    int a = 0, b = 1;
    while (b <= k) {
        int temp = a;
        a = b;
        b = temp + a;
    }
    return 1 + findMinFibonacciNumbers(k - a);
}

-----
public int findMinFibonacciNumbers(int k) 
    // Your code here
}

************************************
Question ID: 1516

import java.util.List;
import java.util.ArrayList;

public String getHappyString(int n, int k) {
    List<String> happyStrings = new ArrayList<>();
    dfs(happyStrings, n, "", ' ');
    return k <= happyStrings.size() ? happyStrings.get(k - 1) : "";
}

private void dfs(List<String> happyStrings, int n, String s, char prev) {
    if (s.length() == n) {
        happyStrings.add(s);
        return;
    }
    for (char c = 'a'; c <= 'c'; c++) {
        if (c != prev) {
            dfs(happyStrings, n, s + c, c);
        }
    }
}

-----
import java.util.List;
import java.util.ArrayList;

public String getHappyString(int n, int k) 
    // Your code here
}

************************************
Question ID: 1518

public int numWaterBottles(int numBottles, int numExchange) {
    int totalBottles = numBottles;
    while (numBottles >= numExchange) {
        int newBottles = numBottles / numExchange;
        totalBottles += newBottles;
        numBottles = newBottles + numBottles % numExchange;
    }
    return totalBottles;
}

-----
public int numWaterBottles(int numBottles, int numExchange) 
    // Your code here
}

************************************
Question ID: 1519

import java.util.*;

class Solution {
    public List<Integer> minSubsequence(int[] nums) {
        List<Integer> result = new ArrayList<Integer>();
        Arrays.sort(nums);
        int totalSum = 0, currentSum = 0;
        for (int num : nums) {
            totalSum += num;
        }
        for (int i = nums.length - 1; i >= 0; i--) {
            currentSum += nums[i];
            result.add(nums[i]);
            if (currentSum > totalSum - currentSum) {
                break;
            }
        }
        return result;
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 1520

public int numSteps(String s) {
    int steps = 0, carry = 0;
    for (int i = s.length() - 1; i > 0; --i) {
        int current = s.charAt(i) - '0' + carry;
        if (current == 1) {
            steps += 2;
            carry = 1;
        } else {
            steps += carry;
            carry = current;
        }
    }

    return steps + carry;
}

-----
public int numSteps(String s) 
    // Your code here
}

************************************
Question ID: 1521

public int closestToTarget(int[] arr, int target) {
    int minDiff = Integer.MAX_VALUE;
    Set<Integer> prefix = new HashSet<>();

    for (int n : arr) {
        Set<Integer> nextPrefix = new HashSet<>();
        for (int p : prefix) {
            nextPrefix.add(p & n);
        }
        nextPrefix.add(n);

        for (int p : nextPrefix) {
            minDiff = Math.min(minDiff, Math.abs(p - target));
        }
        prefix = nextPrefix;
    }
    return minDiff;
}

-----
public int closestToTarget(int[] arr, int target) 
    // Your code here
}

************************************
Question ID: 1522

public String stoneGameIII(int[] stoneValue) {
    int n = stoneValue.length;
    int[] dp = new int[n + 1];
    dp[n - 1] = stoneValue[n - 1];
    for (int i = n - 2; i >= 0; --i) {
        dp[i] = stoneValue[i] - dp[i + 1];
        for (int j = 1; j < 3; ++j) {
            if (i + j < n)
                dp[i] = Math.max(dp[i], stoneValue[i + j] - dp[i + j + 1]);
        }
    }
    if (dp[0] > 0) return "Alice";
    if (dp[0] < 0) return "Bob";
    return "Tie";
}

-----
public String stoneGameIII(int[] stoneValue) 
    // Your code here
}

************************************
Question ID: 1523

public int countOdds(int low, int high) {
    return (high - low) / 2 + ((low % 2 == 1 || high % 2 == 1) ? 1 : 0);
}

-----
public int countOdds(int low, int high) 
    // Your code here
}

************************************
Question ID: 1524

import java.util.ArrayList;
import java.util.List;

public List<String> stringMatching(String[] words) {
    List<String> result = new ArrayList<>();
    for (String word1 : words) {
        for (String word2 : words) {
            if (!word1.equals(word2) && word2.contains(word1)) {
                result.add(word1);
                break;
            }
        }
    }
    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<String> stringMatching(String[] words) 
    // Your code here
}

************************************
Question ID: 1525

import java.util.ArrayList;
import java.util.List;

public List<Integer> processQueries(int[] queries, int m) {
    List<Integer> nums = new ArrayList<>();
    List<Integer> result = new ArrayList<>();
    for (int i = 0; i < m; i++) {
        nums.add(i + 1);
    }
    for (int q : queries) {
        int pos = nums.indexOf(q);
        result.add(pos);
        nums.remove(pos);
        nums.add(0, q);
    }
    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<Integer> processQueries(int[] queries, int m) 
    // Your code here
}

************************************
Question ID: 1526

import java.util.HashMap;

public String entityParser(String text) {
    HashMap<String, Character> entities = new HashMap<String, Character>();
    entities.put("&quot;", '\"');
    entities.put("&apos;", '\'');
    entities.put("&amp;", '&');
    entities.put("&gt;", '>');
    entities.put("&lt;", '<');
    entities.put("&frasl;", '/');
    
    StringBuilder result = new StringBuilder();
    for (int i = 0; i < text.length(); ++i) {
        if (text.charAt(i) == '&') {
            StringBuilder temp = new StringBuilder();
            for (int j = i; j < text.length() && j < i + 7; ++j) {
                temp.append(text.charAt(j));
                Character c = entities.get(temp.toString());
                if (c != null) {
                    result.append(c);
                    i = j;
                    break;
                }
            }
            if (temp.charAt(temp.length() - 1) != ';') result.append(text.charAt(i));
        } else {
            result.append(text.charAt(i));
        }
    }
    return result.toString();
}


-----
import java.util.HashMap;

public String entityParser(String text) 
    // Your code here
}


************************************
Question ID: 1528

import java.util.ArrayList;
import java.util.List;

public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {
    int maxCandies = 0;
    for (int candy : candies) {
        maxCandies = Math.max(candy, maxCandies);
    }

    List<Boolean> result = new ArrayList<>();
    for (int candy : candies) {
        result.add(candy + extraCandies >= maxCandies);
    }

    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) 
    // Your code here
}

************************************
Question ID: 1529

public int maxDifference(int num) {
    int a = num + 9 - (num % 10);
    int b = num - (num / 1000 % 10) * 111;

    return a - b;
}

-----
public int maxDifference(int num) 
    // Your code here
}

************************************
Question ID: 1530

import java.util.Arrays;

public boolean checkIfCanBreak(String s1, String s2) {
    char[] arr1 = s1.toCharArray();
    char[] arr2 = s2.toCharArray();
    Arrays.sort(arr1);
    Arrays.sort(arr2);
    
    boolean canBreak1 = true, canBreak2 = true;
    for(int i = 0; i < arr1.length; i++) {
        if(arr1[i] < arr2[i]) canBreak1 = false;
        if(arr2[i] < arr1[i]) canBreak2 = false;
    }
    return canBreak1 || canBreak2;
}


-----
import java.util.Arrays;

public boolean checkIfCanBreak(String s1, String s2) 
    // Your code here
}


************************************
Question ID: 1531

import java.util.*;

public int numberWays(List<List<Integer>> hats) {
    final int kMod = 1000000007;
    final int kMaxHats = 40;
    
    int num_people = hats.size();
    List<List<Integer>> people_with_hat = new ArrayList<>();
    
    for (int i = 0; i < kMaxHats; ++i) {
        people_with_hat.add(new ArrayList<>());
    }

    for (int i = 0; i < num_people; ++i) {
        for (int hat : hats.get(i)) {
            people_with_hat.get(hat - 1).add(i);
        }
    }

    int[][] dp = new int[1 << num_people][kMaxHats + 1];
    dp[0][0] = 1;

    for (int hat = 0; hat < kMaxHats; ++hat) {
        for (int mask = (1 << num_people) - 1; mask >= 0; --mask) {
            dp[mask][hat + 1] = (dp[mask][hat + 1] + dp[mask][hat]) % kMod;
            for (int person : people_with_hat.get(hat)) {
                if ((mask & (1 << person)) == 0) {
                    dp[mask | (1 << person)][hat + 1] = (dp[mask | (1 << person)][hat + 1] + dp[mask][hat]) % kMod;
                }
            }
        }
    }

    return dp[(1 << num_people) - 1][kMaxHats];
}

-----
import java.util.*;

public int numberWays(List<List<Integer>> hats) 
    // Your code here
}

************************************
Question ID: 1533

import java.util.*;

public List<List<String>> displayTable(List<List<String>> orders) {
    TreeSet<String> foodItems = new TreeSet<>();
    TreeMap<Integer, Map<String, Integer>> tableOrders = new TreeMap<>();

    for (List<String> order : orders) {
        foodItems.add(order.get(2));
        int tableNumber = Integer.parseInt(order.get(1));
        tableOrders.putIfAbsent(tableNumber, new HashMap<>());
        tableOrders.get(tableNumber).put(order.get(2), tableOrders.get(tableNumber).getOrDefault(order.get(2), 0) + 1);
    }

    List<List<String>> result = new ArrayList<>();
    List<String> header = new ArrayList<>();
    header.add("Table");
    header.addAll(foodItems);
    result.add(header);

    for (Map.Entry<Integer, Map<String, Integer>> entry : tableOrders.entrySet()) {
        List<String> row = new ArrayList<>();
        row.add(String.valueOf(entry.getKey()));
        for (String food : foodItems) {
            row.add(String.valueOf(entry.getValue().getOrDefault(food, 0)));
        }
        result.add(row);
    }

    return result;
}


-----
import java.util.*;

public List<List<String>> displayTable(List<List<String>> orders) 
    // Your code here
}


************************************
Question ID: 1534

int minNumberOfFrogs(String croakOfFrogs) {
    int[] counts = new int[5];
    int max_frogs = 0;

    for (char c : croakOfFrogs.toCharArray()) {
        int index = "croak".indexOf(c);
        if (index == 0) {
            counts[0]++;
            max_frogs = Math.max(max_frogs, counts[0]);
        } else if (counts[index - 1] > 0) {
            counts[index - 1]--;
            counts[index]++;
        } else {
            return -1;
        }
    }

    if (counts[0] == counts[4]) {
        return max_frogs;
    } else {
        return -1;
    }
}

-----
int minNumberOfFrogs(String croakOfFrogs) 
    // Your code here
}

************************************
Question ID: 1535

int numberOfWays(int n, int m, int k, int mod = 1_000_000_007) {
    if (k > 1) {
        long result = 1;
        for (int i = 0; i < n; ++i) {
            result = (result * m) % mod;
        }
        return (int)result;
    }
    return n % 2 == 0 ? 1 : m;
}

-----
int numberOfWays(int n, int m, int k, int mod = 1_000_000_007) 
    // Your code here
}

************************************
Question ID: 1536

public int minSwaps(int[][] grid) {
    int n = grid.length;
    int steps = 0;

    for (int i = 0; i < n; ++i) {
        int row = -1;
        for (int j = i; j < n; ++j) {
            if (grid[j][i] == 0) {
                row = j;
                break;
            }
        }
        if (row == -1) {
            return -1;
        }

        while (row > i) {
            int[] temp = grid[row];
            grid[row] = grid[row - 1];
            grid[row - 1] = temp;
            steps++;
            row--;
        }
    }
    return steps;
}


-----
public int minSwaps(int[][] grid) 
    // Your code here
}


************************************
Question ID: 1537

public int maxScore(String s) {
    int left_zeros = 0, right_ones = 0, max_score = 0;
    for(char c : s.toCharArray()) if(c == '1') right_ones++;      
        
    for(int i = 0; i < s.length() - 1; i++) {
        if(s.charAt(i) == '0') left_zeros++;
        else right_ones--;
        max_score = Math.max(max_score, left_zeros + right_ones);
    }
    return max_score;
}

-----
public int maxScore(String s) 
    // Your code here
}

************************************
Question ID: 1538

public int maxScore(int[] cardPoints, int k) {
    int n = cardPoints.length;
    int total = 0;
    for (int i = 0; i < k; i++) {
        total += cardPoints[i];
    }

    int maxScore = total;
    for (int i = k - 1, j = n - 1; i >= 0; i--, j--) {
        total += cardPoints[j] - cardPoints[i];
        maxScore = Math.max(maxScore, total);
    }

    return maxScore;
}


-----
public int maxScore(int[] cardPoints, int k) 
    // Your code here
}


************************************
Question ID: 1539

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

public List<Integer> findDiagonalOrder(List<List<Integer>> nums) {
    List<Integer> res = new ArrayList<>();
    int m = nums.size();
    HashMap<Integer, List<Integer>> diagonals = new HashMap<>();

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < nums.get(i).size(); j++) {
            int key = i + j;
            if (!diagonals.containsKey(key)) {
                diagonals.put(key, new ArrayList<>());
            }
            diagonals.get(key).add(nums.get(i).get(j));
        }
    }

    for (int key : diagonals.keySet()) {
        List<Integer> diag = diagonals.get(key);
        Collections.reverse(diag);
        res.addAll(diag);
    }

    return res;
}

-----
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

public List<Integer> findDiagonalOrder(List<List<Integer>> nums) 
    // Your code here
}

************************************
Question ID: 1540

public boolean canConvertString(String s, String t, int k) {
    if (s.length() != t.length()) return false;
    int[] count = new int[26];
    for (int i = 0; i < s.length(); i++) {
        int diff = (t.charAt(i) - s.charAt(i) + 26) % 26;
        if (diff > 0) {
            count[diff]++;
        }
    }
    for (int i = 1; i < 26; i++) {
        if (count[i] > 0) {
            if (count[i] * 26 - 26 + i > k) {
                return false;
            }
        }
    }
    return true;
}

-----
public boolean canConvertString(String s, String t, int k) 
    // Your code here
}

************************************
Question ID: 1541

public int minInsertions(String s) {
    int left = 0, res = 0;
    int n = s.length();
    for (int i = 0; i < n; i++) {
        if (s.charAt(i) == '(') {
            left++;
        } else {
            if (left == 0) res++;
            else left--;
            if (i == n - 1 || s.charAt(i + 1) != ')') {
                res++;
                i++;
            }
        }
    }
    return res + left * 2;
}

-----
public int minInsertions(String s) 
    // Your code here
}

************************************
Question ID: 1542

public int maxPower(String s) {
    int maxPower = 0, currentPower = 1;

    for (int i = 1; i < s.length(); i++) {
        if (s.charAt(i) == s.charAt(i-1)) {
            currentPower++;
        } else {
            maxPower = Math.max(maxPower, currentPower);
            currentPower = 1;
        }
    }

    return Math.max(maxPower, currentPower);
}

-----
public int maxPower(String s) 
    // Your code here
}

************************************
Question ID: 1544

public int goodNodes(TreeNode root) {
    return goodNodes(root, Integer.MIN_VALUE);
}

private int goodNodes(TreeNode root, int maxVal) {
    if (root == null) return 0;
    int result = 0;
    if (root.val >= maxVal) {
        result = 1;
        maxVal = root.val;
    }
    return result + goodNodes(root.left, maxVal) + goodNodes(root.right, maxVal);
}

-----
public int goodNodes(TreeNode root) 
    // Your code here
}

************************************
Question ID: 1545

public String largestNumber(int[] cost, int target) {
    String[] dp = new String[target + 1];
    dp[0] = "";
    
    for (int t = 1; t <= target; ++t) {
        for (int i = 1; i <= 9; ++i) {
            if (t >= cost[i - 1] && dp[t - cost[i - 1]] != null) {
                String temp = dp[t - cost[i - 1]] + Integer.toString(i);
                if (dp[t] == null || dp[t].length() <= temp.length()) {
                    dp[t] = temp;
                }
            }
        }
    }

    return dp[target] == null ? "0" : dp[target];
}


-----
public String largestNumber(int[] cost, int target) 
    // Your code here
}


************************************
Question ID: 1546

public int maxNonOverlapping(int[] nums, int target) {
    Map<Integer, Integer> prefixSum = new HashMap<>();
    int sum = 0, count = 0;
    prefixSum.put(0, 0);
    for (int num : nums) {
        sum += num;
        if (prefixSum.containsKey(sum - target)) {
            count = Math.max(count, 1 + prefixSum.get(sum - target));
        }
        prefixSum.put(sum, count);
    }
    return count;
}

-----
public int maxNonOverlapping(int[] nums, int target) 
    // Your code here
}

************************************
Question ID: 1547

import java.util.*;

public String destCity(List<List<String>> paths) {
    Set<String> startingCities = new HashSet<>();
    for (List<String> path : paths)
        startingCities.add(path.get(0));

    for (List<String> path : paths) {
        if (!startingCities.contains(path.get(1)))
            return path.get(1);
    }

    return "";
}

-----
import java.util.*;

public String destCity(List<List<String>> paths) 
    // Your code here
}

************************************
Question ID: 1548

public boolean kLengthApart(int[] nums, int k) {
    int last_one = -1;
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] == 1) {
            if (last_one != -1 && i - last_one <= k) {
                return false;
            }
            last_one = i;
        }
    }
    return true;
}

-----
public boolean kLengthApart(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 1550

import java.util.Comparator;
import java.util.PriorityQueue;

public int kthSmallest(int[][] mat, int k) {
    int m = mat.length, n = mat[0].length;
    
    PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparing(a -> a[0]));
    minHeap.offer(new int[]{mat[0][0], 0, 0});
    
    boolean[][] visited = new boolean[m][n];
    visited[0][0] = true;
    
    int res = 0;
    while (k-- > 0) {
        int[] cur = minHeap.poll();
        res = cur[0];
        int i = cur[1], j = cur[2];
        
        if (i < m - 1 && !visited[i+1][j]) {
            minHeap.offer(new int[]{res - mat[i][j] + mat[i + 1][j], i + 1, j});
            visited[i+1][j] = true;
        }
        if (j < n - 1 && !visited[i][j+1]) {
            minHeap.offer(new int[]{res - mat[i][j] + mat[i][j + 1], i, j + 1});
            visited[i][j+1] = true;
        }
    }
    
    return res;
}

-----
import java.util.Comparator;
import java.util.PriorityQueue;

public int kthSmallest(int[][] mat, int k) 
    // Your code here
}

************************************
Question ID: 1551

public int minOperations(int n) {
    return n * n / 4;
}

-----
public int minOperations(int n) 
    // Your code here
}

************************************
Question ID: 1552

import java.util.ArrayList;
import java.util.List;

public List<String> buildArray(int[] target, int n) {
    List<String> result = new ArrayList<>();
    int current = 1;
    for (int num : target) {
        while (current < num) {
            result.add("Push");
            result.add("Pop");
            current++;
        }
        result.add("Push");
        current++;
    }
    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<String> buildArray(int[] target, int n) 
    // Your code here
}

************************************
Question ID: 1553

public int countTriplets(int[] arr) {
    int n = arr.length;
    int[] XOR = new int[n+1];
    
    for (int i = 0; i < n; i++) {
        XOR[i+1] = XOR[i] ^ arr[i];
    }
    
    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int k = i+1; k < n; k++) {
            if(XOR[i] == XOR[k+1]) count += k-i;
        }
    }
    return count;
}

-----
public int countTriplets(int[] arr) 
    // Your code here
}

************************************
Question ID: 1554

import java.util.*;

public int minTime(int n, int[][] edges, boolean[] hasApple) {
    Map<Integer, Map<Integer, Integer>> graph = new HashMap<>();

    for (int[] edge : edges) {
        graph.computeIfAbsent(edge[0], k -> new HashMap<>()).put(edge[1], 0);
        graph.computeIfAbsent(edge[1], k -> new HashMap<>()).put(edge[0], 0);
    }

    return dfs(n, 0, -1, hasApple, graph);
}

private int dfs(int n, int v, int parent, boolean[] hasApple, Map<Integer, Map<Integer, Integer>> graph) {
    int ans = 0;
    for (int u : graph.get(v).keySet()) {
        if (u == parent) continue;
        ans += dfs(n, u, v, hasApple, graph) * 2;
    }

    return ans + ((hasApple[v] || ans > 0) ? 1 : 0);
}

-----
import java.util.*;

public int minTime(int n, int[][] edges, boolean[] hasApple) 
    // Your code here
}

************************************
Question ID: 1556

import java.util.Arrays;

public boolean canBeEqual(int[] target, int[] arr) {
    Arrays.sort(target);
    Arrays.sort(arr);
    return Arrays.equals(target, arr);
}


-----
import java.util.Arrays;

public boolean canBeEqual(int[] target, int[] arr) 
    // Your code here
}


************************************
Question ID: 1557

public boolean hasAllCodes(String s, int k) {
    int need = 1 << k;
    Set<String> got = new HashSet<>();
    
    for (int i = 0; i <= s.length() - k; i++) {
        got.add(s.substring(i, i + k));
    }
    
    return got.size() == need;
}

-----
public boolean hasAllCodes(String s, int k) 
    // Your code here
}

************************************
Question ID: 1558

import java.util.*;

public class Solution {
    public void DFS(int src, Map<Integer, List<Integer>> graph, boolean[] visited, boolean[] transitiveClosure, int dest) {
        if (src == dest) {
            transitiveClosure[dest] = true;
            return;
        }
        if (visited[src]) return;
        visited[src] = true;
        for (int neighbor : graph.get(src)) {
            DFS(neighbor, graph, visited, transitiveClosure, dest);
            if (transitiveClosure[dest]) return;
        }
    }

    public boolean[] checkIfPrerequisite(int numCourses, int[][] prerequisites, int[][] queries) {
        Map<Integer, List<Integer>> graph = new HashMap<>();

        for (int[] pre : prerequisites) {
            graph.computeIfAbsent(pre[0], k -> new ArrayList<>()).add(pre[1]);
        }

        boolean[] result = new boolean[queries.length];

        for (int i = 0; i < queries.length; ++i) {
            boolean[] visited = new boolean[numCourses];
            boolean[] transitiveClosure = new boolean[numCourses];
            DFS(queries[i][0], graph, visited, transitiveClosure, queries[i][1]);
            result[i] = transitiveClosure[queries[i][1]];
        }

        return result;
    }
}


-----
import java.util.*;

public class Solution 
    // Your code here
}


************************************
Question ID: 1559

public int cherryPickup(int[][] grid) {
    int rows = grid.length;
    int cols = grid[0].length;
    int[][][] dp = new int[rows][cols][cols];

    for (int row = rows - 1; row >= 0; --row) {
        for (int col1 = 0; col1 < cols; ++col1) {
            for (int col2 = 0; col2 < cols; ++col2) {
                int currentCell = row < rows - 1 ? dp[row + 1][col1][col2] : 0;
                currentCell += grid[row][col1] + (col1 != col2 ? grid[row][col2] : 0);

                int maxVal = 0;
                for (int move1 = -1; move1 <= 1; ++move1) {
                    for (int move2 = -1; move2 <= 1; ++move2) {
                        int newCol1 = col1 + move1;
                        int newCol2 = col2 + move2;
                        if (newCol1 >= 0 && newCol1 < cols && newCol2 >= 0 && newCol2 < cols) {
                            maxVal = Math.max(maxVal, dp[row][newCol1][newCol2]);
                        }
                    }
                }

                dp[row][col1][col2] = currentCell + maxVal;
            }
        }
    }

    return dp[0][0][cols - 1];
}


-----
public int cherryPickup(int[][] grid) 
    // Your code here
}


************************************
Question ID: 1560

public int busyStudent(int[] startTime, int[] endTime, int queryTime) {
    int count = 0;
    for (int i = 0; i < startTime.length; i++) {
        if (startTime[i] <= queryTime && endTime[i] >= queryTime) {
            count++;
        }
    }
    return count;
}

-----
public int busyStudent(int[] startTime, int[] endTime, int queryTime) 
    // Your code here
}

************************************
Question ID: 1561

import java.util.Arrays;

public class Main {
    public static String arrangeWords(String text) {
        String[] words = text.toLowerCase().split(" ");
        Arrays.sort(words, (a, b) -> a.length() - b.length());
        words[0] = Character.toUpperCase(words[0].charAt(0)) + words[0].substring(1);
        return String.join(" ", words);
    }
}

-----
import java.util.Arrays;

public class Main 
    // Your code here
}

************************************
Question ID: 1562

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Solution {
    public List<Integer> peopleIndexes(List<List<String>> favoriteCompanies) {
        List<Integer> result = new ArrayList<>();
        for (int i = 0; i < favoriteCompanies.size(); i++) {
            boolean isSubset = false;
            for (int j = 0; j < favoriteCompanies.size() && !isSubset; j++) {
                if (i != j && favoriteCompanies.get(j).containsAll(favoriteCompanies.get(i))) {
                    isSubset = true;
                }
            }
            if (!isSubset) result.add(i);
        }
        return result;
    }
}

-----
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Solution 
    // Your code here
}

************************************
Question ID: 1563

import java.awt.geom.Point2D;
import java.util.List;

public int maxNumberOfDarts(List<List<Integer>> darts, int r) {
    int n = darts.size();
    int maxDarts = 1;

    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            double dist = Point2D.distance(darts.get(j).get(0), darts.get(j).get(1), darts.get(i).get(0), darts.get(i).get(1));
            if (dist > 2.0 * r) continue;

            double angle = Math.acos(dist / (2.0 * r));
            for (int k = 0; k < 2; k++) {
                double locAngle = angle * (k == 0 ? 1 : -1);
                double cx = darts.get(i).get(0) + r * (darts.get(j).get(0) - darts.get(i).get(0)) / dist * Math.cos(locAngle) - r * (darts.get(j).get(1) - darts.get(i).get(1)) / dist * Math.sin(locAngle);
                double cy = darts.get(i).get(1) + r * (darts.get(j).get(0) - darts.get(i).get(0)) / dist * Math.sin(locAngle) + r * (darts.get(j).get(1) - darts.get(i).get(1)) / dist * Math.cos(locAngle);

                int cnt = 0;
                for (int l = 0; l < n; l++) {
                    double newDist = Point2D.distance(darts.get(l).get(0), darts.get(l).get(1), cx, cy);
                    if (newDist <= r + 1e-5) cnt++;
                }

                maxDarts = Math.max(maxDarts, cnt);
            }
        }
    }

    return maxDarts;
}

-----
import java.awt.geom.Point2D;
import java.util.List;

public int maxNumberOfDarts(List<List<Integer>> darts, int r) 
    // Your code here
}

************************************
Question ID: 1564

public int maxBoxesInWarehouse(int[] boxes, int[] warehouse) {
    int n = warehouse.length;
    for (int i = 1; i < n; i++)
        warehouse[i] = Math.min(warehouse[i], warehouse[i - 1]);
    Arrays.sort(boxes);
    int boxIndex = boxes.length - 1;
    int boxesCount = 0;
    for (int i = 0; i < n && boxIndex >= 0; i++) {
        if (boxes[boxIndex] <= warehouse[i]) {
            boxesCount++;
            boxIndex--;
        }
    }
    return boxesCount;
}


-----
public int maxBoxesInWarehouse(int[] boxes, int[] warehouse) 
    // Your code here
}


************************************
Question ID: 1566

public int isPrefixOfWord(String sentence, String searchWord) {
    String[] words = sentence.split(" ");
    for (int i = 0; i < words.length; i++) {
        if (words[i].startsWith(searchWord)) {
            return i + 1;
        }
    }
    return -1;
}

-----
public int isPrefixOfWord(String sentence, String searchWord) 
    // Your code here
}

************************************
Question ID: 1567

public int maxVowels(String s, int k) {
    int max_count = 0, count = 0;
    for (int i = 0; i < s.length(); i++) {
        count += isVowel(s.charAt(i)) ? 1 : 0;
        if (i >= k)
            count -= isVowel(s.charAt(i - k)) ? 1 : 0;
        max_count = Math.max(max_count, count);
    }
    return max_count;
}

private boolean isVowel(char c) {
    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
}


-----
public int maxVowels(String s, int k) 
    // Your code here
}


************************************
Question ID: 1568

public int pseudoPalindromicPaths(TreeNode root, int cnt) {
    if (root == null) return 0;
    cnt ^= 1 << (root.val - 1);
    if (root.left == null && root.right == null)
        return (cnt & (cnt - 1)) == 0 ? 1 : 0;
    return pseudoPalindromicPaths(root.left, cnt) + pseudoPalindromicPaths(root.right, cnt);
}

-----
public int pseudoPalindromicPaths(TreeNode root, int cnt) 
    // Your code here
}

************************************
Question ID: 1569

public int maxDotProduct(int[] nums1, int[] nums2) {
    int n = nums1.length, m = nums2.length;
    int[][] dp = new int[n + 1][m + 1];
    for (int i = 0; i <= n; ++i) {
        Arrays.fill(dp[i], Integer.MIN_VALUE);
    }
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            dp[i][j] = Math.max(dp[i][j], Math.max(dp[i - 1][j], Math.max(dp[i][j - 1], Math.max(dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1], nums1[i - 1] * nums2[j - 1]))));
        }
    }
    return dp[n][m];
}

-----
public int maxDotProduct(int[] nums1, int[] nums2) 
    // Your code here
}

************************************
Question ID: 1570

public int[] finalPrices(int[] prices) {
    for(int i = 0; i < prices.length; i++) {
        for(int j = i + 1; j < prices.length; j++) {
            if(prices[j] <= prices[i]) {
                prices[i] -= prices[j];
                break;
            }
        }
    }
    return prices;
}

-----
public int[] finalPrices(int[] prices) 
    // Your code here
}

************************************
Question ID: 1573

import java.util.HashMap;

public int minSumOfLengths(int[] arr, int target) {
    int n = arr.length, sum = 0, minLen = Integer.MAX_VALUE, result = Integer.MAX_VALUE;
    HashMap<Integer, Integer> map = new HashMap<>();
    map.put(0, -1);

    for (int i = 0; i < n; ++i) {
        sum += arr[i];
        if (sum >= target && map.containsKey(sum - target)) {
            if (map.get(sum - target) > -1 && minLen != Integer.MAX_VALUE) {
                result = Math.min(result, i - map.get(sum - target) + minLen);
            }
            minLen = Math.min(minLen, i - map.get(sum - target));
        }
        map.put(sum, i);
    }
    return result == Integer.MAX_VALUE ? -1 : result;
}

-----
import java.util.HashMap;

public int minSumOfLengths(int[] arr, int target) 
    // Your code here
}

************************************
Question ID: 1574

public int findLengthOfShortestSubarray(int[] arr) {
    int n = arr.length, left = 0, right = n - 1;
    while (left < n - 1 && arr[left] <= arr[left + 1]) left++;
    if (left == n - 1) return 0;
    while (right > 0 && arr[right] >= arr[right - 1]) right--;
    int result = Math.min(n - left - 1, right);
    for (int i = 0, j = right; i <= left && j < n;) {
        if (arr[i] <= arr[j]) {
            result = Math.min(result, j - i - 1);
            i++;
        } else {
            j++;
        }
    }
    return result;
}

-----
public int findLengthOfShortestSubarray(int[] arr) 
    // Your code here
}

************************************
Question ID: 1575

import java.util.Arrays;

public int maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts) {
    Arrays.sort(horizontalCuts);
    Arrays.sort(verticalCuts);
    
    int maxH = Math.max(horizontalCuts[0], h - horizontalCuts[horizontalCuts.length - 1]);
    int maxV = Math.max(verticalCuts[0], w - verticalCuts[verticalCuts.length - 1]);
    
    for (int i = 1; i < horizontalCuts.length; ++i) {
        maxH = Math.max(maxH, horizontalCuts[i] - horizontalCuts[i - 1]);
    }
    
    for (int i = 1; i < verticalCuts.length; ++i) {
        maxV = Math.max(maxV, verticalCuts[i] - verticalCuts[i - 1]);
    }
    
    return (int)((long)maxH * maxV % 1000000007);
}

-----
import java.util.Arrays;

public int maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts) 
    // Your code here
}

************************************
Question ID: 1576

import java.util.*;

class Solution {
    public void dfs(int node, int parent, List<List<Integer>> graph, int[] count) {
        if (node != 0 && parent == 0) count[0]++;
    
        for (int neighbor : graph.get(node)) {
            if (neighbor != parent) {
                dfs(neighbor, node, graph, count);
            }
        }
    }
    
    public int minReorder(int n, int[][] connections) {
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            graph.add(new ArrayList<>());
        }
    
        for (int[] c : connections) {
            graph.get(c[0]).add(c[1]);
            graph.get(c[1]).add(c[0]);
        }

        int[] count = {0};
        dfs(0, -1, graph, count);
        return count[0];
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 1578

public int minTime(String colors, int[] neededTime) {
    int res = 0, prev = -1;
    for (int i = 0; i < colors.length() - 1; i++) {
        if (colors.charAt(i) == colors.charAt(i + 1)) {
            if (prev == -1 || neededTime[i] < neededTime[prev]) prev = i;
            if (neededTime[i + 1] < neededTime[prev]) prev = i + 1;
            res += neededTime[prev];
            neededTime[prev] = 1000000;
            prev = -1;
        }
    }
    return res;
}

-----
public int minTime(String colors, int[] neededTime) 
    // Your code here
}

************************************
Question ID: 1580

public int[] shuffle(int[] nums, int n) {
    int[] shuffled = new int[nums.length];
    for(int i = 0; i < n; i++) {
        shuffled[2*i] = nums[i];
        shuffled[2*i+1] = nums[i+n];
    }
    return shuffled;
}


-----
public int[] shuffle(int[] nums, int n) 
    // Your code here
}


************************************
Question ID: 1583

public int minCost(int[] houses, int[][] cost, int m, int n, int target) {
    int[][][] dp = new int[m][n][target + 1];

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            Arrays.fill(dp[i][j], Integer.MAX_VALUE);
        }
    }

    if (houses[0] != 0) {
        dp[0][houses[0] - 1][1] = 0;
    } else {
        for (int j = 0; j < n; j++) {
            dp[0][j][1] = cost[0][j];
        }
    }

    for (int i = 1; i < m; i++) {
        for (int j = 0; j < n; j++) {
            for (int k = 1; k <= target; k++) {
                if (houses[i] != 0 && houses[i] != j + 1) {
                    continue;
                }
                int paint_cost = (houses[i] != 0) ? 0 : cost[i][j];

                for (int l = 0; l < n; l++) {
                    if (l == j) {
                        dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][l][k] + paint_cost);
                    } else {
                        dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][l][k - 1] + paint_cost);
                    }
                }
            }
        }
    }

    int ans = Integer.MAX_VALUE;
    for (int j = 0; j < n; j++) {
        ans = Math.min(ans, dp[m - 1][j][target]);
    }
    return (ans == Integer.MAX_VALUE) ? -1 : ans;
}


-----
public int minCost(int[] houses, int[][] cost, int m, int n, int target) 
    // Your code here
}


************************************
Question ID: 1584

import java.util.Arrays;

public double average(int[] salary) {
    double sum = 0;
    int minSalary = Arrays.stream(salary).min().getAsInt();
    int maxSalary = Arrays.stream(salary).max().getAsInt();
    for (int s : salary) {
        sum += s;
    }
    sum -= (minSalary + maxSalary);
    return sum / (salary.length - 2);
}

-----
import java.util.Arrays;

public double average(int[] salary) 
    // Your code here
}

************************************
Question ID: 1585

public int kthFactor(int n, int k) {
    for (int i = 1; i <= n; ++i) {
        if (n % i == 0) {
            --k;
            if (k == 0) return i;
        }
    }
    return -1;
}


-----
public int kthFactor(int n, int k) 
    // Your code here
}


************************************
Question ID: 1586

public int findMaxLength(int[] nums) {
    int max_length = 0, zeroes = 0, ones = 0;
    HashMap<Integer, Integer> count_map = new HashMap<>();
    count_map.put(0, -1);

    for(int i = 0; i < nums.length; ++i) {
        if(nums[i] == 0)
            zeroes++;
        else
            ones++;

        if(!count_map.containsKey(zeroes - ones))
            count_map.put(zeroes - ones, i);
        else
            max_length = Math.max(max_length, i - count_map.get(zeroes - ones));
    }
    return max_length;
}

-----
public int findMaxLength(int[] nums) 
    // Your code here
}

************************************
Question ID: 1588

public int sumOddLengthSubarrays(int[] arr) {
    int sum = 0, n = arr.length;
    for (int i = 0; i < n; i++) {
        int oddSubarrays = ((i + 1) * (n - i) + 1) / 2;
        sum += arr[i] * oddSubarrays;
    }
    return sum;
}

-----
public int sumOddLengthSubarrays(int[] arr) 
    // Your code here
}

************************************
Question ID: 1589

import java.util.Arrays;

public int maxSumRangeQuery(int[] nums, int[][] requests) {
    int n = nums.length;
    int[] count = new int[n];
    for (int[] request : requests) {
        count[request[0]]++;
        if (request[1] + 1 < n)
            count[request[1] + 1]--;
    }
    for (int i = 1; i < n; i++) {
        count[i] += count[i - 1];
    }
    Arrays.sort(nums);
    Arrays.sort(count);
    
    long ans = 0;
    for (int i = 0; i < n; i++) {
        ans = (ans + (long)nums[i] * count[i]) % 1000000007;
    }
    return (int) ans;
}

-----
import java.util.Arrays;

public int maxSumRangeQuery(int[] nums, int[][] requests) 
    // Your code here
}

************************************
Question ID: 1590

import java.util.HashMap;

public int minSubarray(int[] nums, int p) {
    int n = nums.length, res = n, need = 0, cur = 0;
    for (int num : nums)
        need = (need + num) % p;
    if (need == 0) return 0;
    HashMap<Integer, Integer> last_seen = new HashMap<>();
    last_seen.put(0, -1);
    for (int i = 0; i < n; i++) {
        cur = (cur + nums[i]) % p;
        last_seen.put(cur, i);
        res = Math.min(res, i - last_seen.getOrDefault((cur - need + p) % p, -n));
    }
    return res < n ? res : -1;
}

-----
import java.util.HashMap;

public int minSubarray(int[] nums, int p) 
    // Your code here
}

************************************
Question ID: 1591

public boolean isPrintable(int[][] targetGrid) {
    int m = targetGrid.length, n = targetGrid[0].length;
    Map<Integer, int[]> colorBounds = new HashMap<>();
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            int color = targetGrid[i][j];
            colorBounds.putIfAbsent(color, new int[] {i, j, i, j});
            colorBounds.get(color)[0] = Math.min(colorBounds.get(color)[0], i);
            colorBounds.get(color)[1] = Math.min(colorBounds.get(color)[1], j);
            colorBounds.get(color)[2] = Math.max(colorBounds.get(color)[2], i);
            colorBounds.get(color)[3] = Math.max(colorBounds.get(color)[3], j);
        }
    }

    Set<Integer> remainingColors = new HashSet<>(colorBounds.keySet());
    while (!remainingColors.isEmpty()) {
        boolean progress = false;
        for (Iterator<Integer> it = remainingColors.iterator(); it.hasNext();) {
            int color = it.next();
            int[] bounds = colorBounds.get(color);
            boolean contained = true;
            for (int i = bounds[0]; i <= bounds[2] && contained; ++i) {
                for (int j = bounds[1]; j <= bounds[3]; ++j) {
                    if (targetGrid[i][j] != color && targetGrid[i][j] != -1) {
                        contained = false;
                        break;
                    }
                }
            }
            if (contained) {
                for (int i = bounds[0]; i <= bounds[2]; ++i) {
                    for (int j = bounds[1]; j <= bounds[3]; ++j) {
                        targetGrid[i][j] = -1;
                    }
                }
                it.remove();
                progress = true;
            }
        }
        if (!progress) return false;
    }
    return true;
}

-----
public boolean isPrintable(int[][] targetGrid) 
    // Your code here
}

************************************
Question ID: 1592

import java.util.ArrayList;
import java.util.List;

public String reorderSpaces(String text) {
    int spaces = 0, words = 0;

    for (char c : text.toCharArray()) {
        if (c == ' ') spaces++;
    }
    
    String[] splitText = text.trim().split("\\s+");
    List<String> wordList = new ArrayList<>();
    for (String word : splitText) {
        wordList.add(word);
        words++;
    }
    
    int spacesBetweenWords = words == 1 ? 0 : spaces / (words - 1);
    int extraSpaces = words == 1 ? spaces : spaces % (words - 1);
    
    StringBuilder result = new StringBuilder();

    for (int i = 0; i < words; i++) {
        result.append(wordList.get(i));
        if (i != words - 1) {
            result.append(" ".repeat(spacesBetweenWords));
        } else {
            result.append(" ".repeat(extraSpaces));
        }
    }
    
    return result.toString();
}

-----
import java.util.ArrayList;
import java.util.List;

public String reorderSpaces(String text) 
    // Your code here
}

************************************
Question ID: 1593

import java.util.HashSet;

public int maxUniqueSplit(String s) {
    return maxUniqueSplit(s, 0, new HashSet<String>());
}

private int maxUniqueSplit(String s, int start, HashSet<String> seen) {
    if (start == s.length()) {
        return 0;
    }
    int maxUnique = -1;
    for (int i = start + 1; i <= s.length(); ++i) {
        String sub = s.substring(start, i);
        if (!seen.contains(sub)) {
            seen.add(sub);
            int unique = maxUniqueSplit(s, i, seen);
            if (unique != -1) {
                maxUnique = Math.max(maxUnique, unique + 1);
            }
            seen.remove(sub);
        }
    }
    return maxUnique;
}

-----
import java.util.HashSet;

public int maxUniqueSplit(String s) 
    // Your code here
}

************************************
Question ID: 1594

public int maxProductPath(int[][] grid) {
    int m = grid.length, n = grid[0].length, mod = 1_000_000_007;
    long[][][] dp = new long[m][n][2];
    dp[0][0][0] = dp[0][0][1] = grid[0][0];
    for (int i = 1; i < m; ++i) dp[i][0][0] = dp[i][0][1] = grid[i][0] * dp[i - 1][0][0];
    for (int j = 1; j < n; ++j) dp[0][j][0] = dp[0][j][1] = grid[0][j] * dp[0][j - 1][0];
    for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
            if (grid[i][j] < 0) {
                dp[i][j][0] = Math.min(grid[i][j] * dp[i - 1][j][1], grid[i][j] * dp[i][j - 1][1]);
                dp[i][j][1] = Math.max(grid[i][j] * dp[i - 1][j][0], grid[i][j] * dp[i][j - 1][0]);
            } else {
                dp[i][j][0] = Math.min(grid[i][j] * dp[i - 1][j][0], grid[i][j] * dp[i][j - 1][0]);
                dp[i][j][1] = Math.max(grid[i][j] * dp[i - 1][j][1], grid[i][j] * dp[i][j - 1][1]);
            }
        }
    }
    return dp[m - 1][n - 1][1] < 0 ? -1 : (int)(dp[m - 1][n - 1][1] % mod);
}

-----
public int maxProductPath(int[][] grid) 
    // Your code here
}

************************************
Question ID: 1595

import java.util.Arrays;

public int connectTwoGroups(List<List<Integer>> cost) {
    int size1 = cost.size(), size2 = cost.get(0).size();
    int[] min_cost = new int[size2];
    Arrays.fill(min_cost, Integer.MAX_VALUE);

    for (int i = 0; i < size1; i++) {
        for (int j = 0; j < size2; j++) {
            min_cost[j] = Math.min(min_cost[j], cost.get(i).get(j));
        }
    }

    int total_cost = 0;
    for (int i = 0; i < size1; i++) {
        total_cost += Collections.min(cost.get(i));
    }

    for (int j = 0; j < size2; j++) {
        total_cost += min_cost[j];
    }

    return total_cost;
}


-----
import java.util.Arrays;

public int connectTwoGroups(List<List<Integer>> cost) 
    // Your code here
}


************************************
Question ID: 1598

public int minOperations(String[] logs) {
    int depth = 0;
    for (String log : logs) {
        if (log.equals("../")) {
            depth = Math.max(0, depth - 1);
        } else if (!log.equals("./")) {
            depth += 1;
        }
    }
    return depth;
}

-----
public int minOperations(String[] logs) 
    // Your code here
}

************************************
Question ID: 1599

public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {
    int waiting = 0;
    int profit = 0;
    int max_profit = 0;
    int rotations = 0;
    int result = -1;

    for (int i = 0; i < customers.length || waiting > 0; ++i) {
        if (i < customers.length) {
            waiting += customers[i];
        }
        int boarding = Math.min(waiting, 4);
        waiting -= boarding;
        profit += boarding * boardingCost - runningCost;

        if (profit > max_profit) {
            max_profit = profit;
            result = rotations + 1;
        }
        rotations++;
    }
    return result;
}


-----
public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) 
    // Your code here
}


************************************
Question ID: 1601

import java.util.List;

public int maximumRequests(int n, List<List<Integer>> requests) {
    int req_size = requests.size();
    int max_requests = 0;

    for (int i = 0; i < (1 << req_size); ++i) {
        int[] net_transfers = new int[n];
        int count = 0;

        for (int j = 0; j < req_size; ++j) {
            if ((i & (1 << j)) != 0) {
                net_transfers[requests.get(j).get(0)]--;
                net_transfers[requests.get(j).get(1)]++;
                count++;
            }
        }

        boolean valid = true;
        for (int val : net_transfers) {
            if (val != 0) {
                valid = false;
                break;
            }
        }

        if (valid)
            max_requests = Math.max(max_requests, count);
    }

    return max_requests;
}

-----
import java.util.List;

public int maximumRequests(int n, List<List<Integer>> requests) 
    // Your code here
}

************************************
Question ID: 1603

public int[] runningSum(int[] nums) {
    for (int i = 1; i < nums.length; i++) {
        nums[i] += nums[i - 1];
    }
    return nums;
}

-----
public int[] runningSum(int[] nums) 
    // Your code here
}

************************************
Question ID: 1604

import java.util.HashMap;
import java.util.PriorityQueue;

public int findLeastNumOfUniqueInts(int[] arr, int k) {
    HashMap<Integer, Integer> freqMap = new HashMap<>();
    for (int n : arr) {
        freqMap.put(n, freqMap.getOrDefault(n, 0) + 1);
    }

    PriorityQueue<Integer> minHeap = new PriorityQueue<>();
    for (int count : freqMap.values()) {
        minHeap.offer(count);
    }

    while (k > 0) {
        k -= minHeap.poll();
    }

    return k == 0 ? minHeap.size() : minHeap.size() + 1;
}

-----
import java.util.HashMap;
import java.util.PriorityQueue;

public int findLeastNumOfUniqueInts(int[] arr, int k) 
    // Your code here
}

************************************
Question ID: 1605

public int minDays(int[] bloomDay, int m, int k) {
    int left = Arrays.stream(bloomDay).min().getAsInt();
    int right = Arrays.stream(bloomDay).max().getAsInt();

    while (left < right) {
        int mid = left + (right - left) / 2;
        int bouquets = 0, flowers = 0;
        for (int day : bloomDay) {
            if (day > mid) {
                flowers = 0;
            } else {
                flowers++;
                if (flowers == k) {
                    bouquets++;
                    flowers = 0;
                }
            }
        }
        if (bouquets >= m) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return m == 0 ? -1 : left;
}

-----
public int minDays(int[] bloomDay, int m, int k) 
    // Your code here
}

************************************
Question ID: 1606

import java.util.ArrayList;
import java.util.List;

public List<Integer> busiestServers(int k, int[] arrival, int[] load) {
    int[] server_status = new int[k];
    int[] server_request_count = new int[k];

    for (int i = 0; i < arrival.length; i++) {
        int index = i % k;
        for (int j = 0; j < k; j++) {
            if (server_status[index] <= arrival[i]) {
                server_status[index] = arrival[i] + load[i];
                server_request_count[index]++;
                break;
            }
            index = (index + 1) % k;
        }
    }

    int max_requests = 0;
    for (int count : server_request_count) {
        max_requests = Math.max(max_requests, count);
    }
    List<Integer> busiest_servers = new ArrayList<>();
    for (int i = 0; i < k; i++) {
        if (server_request_count[i] == max_requests) {
            busiest_servers.add(i);
        }
    }
    return busiest_servers;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<Integer> busiestServers(int k, int[] arrival, int[] load) 
    // Your code here
}

************************************
Question ID: 1608

public int specialArray(int[] nums) {
    int max_val = Arrays.stream(nums).max().orElse(0);
    for (int x = 1; x <= max_val; ++x) {
        int count = 0;
        for (int num : nums) {
            if (num >= x) count++;
        }
        if (count == x) return x;
    }
    return -1;
}

-----
public int specialArray(int[] nums) 
    // Your code here
}

************************************
Question ID: 1609

import java.util.LinkedList;
import java.util.Queue;

public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
}

public boolean isEvenOddTree(TreeNode root) {
    if (root == null) return false;
    
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int level = 0;
    
    while (!queue.isEmpty()) {
        int size = queue.size();
        int prevVal = (level % 2 == 0) ? 0 : 1000001;
        
        for (int i = 0; i < size; ++i) {
            TreeNode curr = queue.poll();

            if ((level % 2 == 0 && (curr.val % 2 == 0 || curr.val <= prevVal)) || 
                (level % 2 != 0 && (curr.val % 2 != 0 || curr.val >= prevVal))) {
                return false;
            }

            prevVal = curr.val;

            if (curr.left != null) queue.offer(curr.left);
            if (curr.right != null) queue.offer(curr.right);
        }
        
        level++;
    }
    
    return true;
}

-----
import java.util.LinkedList;
import java.util.Queue;

public class TreeNode 
    // Your code here
}

************************************
Question ID: 1610

public int xorOperation(int n, int start) {
    int xorResult = 0;
    for (int i = 0; i < n; i++) {
        xorResult ^= (start + 2 * i);
    }
    return xorResult;
}

-----
public int xorOperation(int n, int start) 
    // Your code here
}

************************************
Question ID: 1611

import java.util.*;

public String[] getFolderNames(String[] names) {
    HashMap<String, Integer> nameCount = new HashMap<String, Integer>();
    String[] ans = new String[names.length];

    for (int i = 0; i < names.length; i++) {
        String name = names[i];
        if (nameCount.get(name) == null) {
            ans[i] = name;
            nameCount.put(name, 1);
        } else {
            int k = nameCount.get(name);
            String newName = "";
            while (nameCount.get(name + "(" + k + ")") != null) {
                k++;
            }
            newName = name + "(" + k + ")";
            ans[i] = newName;
            nameCount.put(newName, 1);
            nameCount.put(name, k + 1);
        }
    }

    return ans;
}

-----
import java.util.*;

public String[] getFolderNames(String[] names) 
    // Your code here
}

************************************
Question ID: 1612

import java.util.*;

class Solution {
    public int[] avoidFlood(int[] rains) {
        int[] res = new int[rains.length];
        Arrays.fill(res, -1);
        Map<Integer, Integer> filledLakes = new HashMap<>();
        TreeSet<Integer> dryDays = new TreeSet<>();

        for (int i = 0; i < rains.length; i++) {
            if (rains[i] == 0) {
                dryDays.add(i);
            } else {
                int lake = rains[i];
                if (filledLakes.containsKey(lake)) {
                    Integer day = dryDays.ceiling(filledLakes.get(lake));
                    if (day == null) return new int[0];
                    res[day] = lake;
                    dryDays.remove(day);
                }
                filledLakes.put(lake, i);
            }
        }

        for (int day : dryDays) {
            res[day] = 1;
        }

        return res;
    }
}


-----
import java.util.*;

class Solution 
    // Your code here
}


************************************
Question ID: 1614

public int maxDepth(String s) {
    int depth = 0, maxDepth = 0;

    for (char c : s.toCharArray()) {
        if (c == '(') {
            depth++;
            maxDepth = Math.max(depth, maxDepth);
        } else if (c == ')') {
            depth--;
        }
    }

    return maxDepth;
}

-----
public int maxDepth(String s) 
    // Your code here
}

************************************
Question ID: 1615

public int rangeSum(int[] nums, int n, int left, int right) {
    int MOD = (int)1e9 + 7;
    int[] sums = new int[n * (n + 1) / 2];
    int index = 0;
    for (int i = 0; i < n; ++i) {
        int sum = 0;
        for (int j = i; j < n; ++j) {
            sum += nums[j];
            sums[index++] = sum;
        }
    }
    Arrays.sort(sums);
    int result = 0;
    for (int i = left - 1; i < right; ++i) {
        result = (result + sums[i]) % MOD;
    }
    return result;
}

-----
public int rangeSum(int[] nums, int n, int left, int right) 
    // Your code here
}

************************************
Question ID: 1616

import java.util.Arrays;

public int minDifference(int[] nums) {
    int size = nums.length;
    if (size < 5) return 0;

    Arrays.sort(nums);

    return Math.min(Math.min(nums[size-1] - nums[3], nums[size-2] - nums[2]), Math.min(nums[size-3] - nums[1], nums[size-4] - nums[0]));
}

-----
import java.util.Arrays;

public int minDifference(int[] nums) 
    // Your code here
}

************************************
Question ID: 1617

public boolean winnerSquareGame(int n) {
    boolean[] dp = new boolean[n + 1];
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j * j <= i; j++) {
            if (!dp[i - j * j]) {
                dp[i] = true;
                break;
            }
        }
    }
    return dp[n];
}

-----
public boolean winnerSquareGame(int n) 
    // Your code here
}

************************************
Question ID: 1618

int maxFontSize(String text, int w, int h, int[] fonts, FontInfo fontInfo) {
    int left = 0, right = fonts.length - 1, mid, ans = -1;
    while (left <= right) {
        mid = left + (right - left) / 2;
        int fontSize = fonts[mid];
        int width = 0, height = fontInfo.getHeight(fontSize);
        for (char ch : text.toCharArray())
            width += fontInfo.getWidth(fontSize, ch);
        if (width <= w && height <= h) {
            ans = fontSize;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return ans;
}

-----
int maxFontSize(String text, int w, int h, int[] fonts, FontInfo fontInfo) 
    // Your code here
}

************************************
Question ID: 1619

import java.util.HashSet;
import java.util.Set;

public boolean isPathCrossing(String path) {
    Set<String> visited = new HashSet<>();
    int x = 0, y = 0;
    visited.add(x + "," + y);
    for (char dir : path.toCharArray()) {
        if (dir == 'N') y++;
        else if (dir == 'S') y--;
        else if (dir == 'E') x++;
        else if (dir == 'W') x--;
        String location = x + "," + y;
        if (visited.contains(location)) return true;
        visited.add(location);
    }
    return false;
}

-----
import java.util.HashSet;
import java.util.Set;

public boolean isPathCrossing(String path) 
    // Your code here
}

************************************
Question ID: 1620

public boolean canArrange(int[] arr, int k) {
    int[] counts = new int[k];
    for (int num : arr) {
        counts[(num % k + k) % k]++;
    }
    if (counts[0] % 2 != 0) {
        return false;
    }
    for (int i = 1; i <= k / 2; i++) {
        if (counts[i] != counts[k - i]) {
            return false;
        }
    }
    return true;
}

-----
public boolean canArrange(int[] arr, int k) 
    // Your code here
}

************************************
Question ID: 1621

import java.util.Arrays;

class Solution {
    public int numSubseq(int[] nums, int target) {
        int n = nums.length;
        int mod = 1000000007;

        Arrays.sort(nums);

        long[] power = new long[n];
        power[0] = 1;
        for (int i = 1; i < n; ++i) {
            power[i] = (power[i - 1] * 2) % mod;
        }

        int ans = 0;
        int r = n;

        for (int l = 0; l < n; ++l) {
            while (r > l && nums[l] + nums[r - 1] > target) {
                --r;
            }

            ans = (ans + (int)power[r - l]) % mod;
        }

        return ans;
    }
}


-----
import java.util.Arrays;

class Solution 
    // Your code here
}


************************************
Question ID: 1622

import java.util.*;

class Solution {
    public int findMaxValueOfEquation(int[][] points, int k) {
        int res = Integer.MIN_VALUE;
        Deque<int[]> q = new LinkedList<>();
        
        for (int[] p : points) {
            while (!q.isEmpty() && p[0] - q.peekFirst()[1] > k)
                q.pollFirst();
            
            if (!q.isEmpty())
                res = Math.max(res, p[1] + p[0] + q.peekFirst()[0]);
            
            while (!q.isEmpty() && p[1] - p[0] >= q.peekLast()[0])
                q.pollLast();

            q.offerLast(new int[]{p[1] - p[0], p[0]});
        }
        
        return res;
    }
}


-----
import java.util.*;

class Solution 
    // Your code here
}


************************************
Question ID: 1624

public int maxLengthBetweenEqualCharacters(String s) {
    int result = -1;
    HashMap<Character, Integer> char_map = new HashMap<>();

    for (int i = 0; i < s.length(); ++i) {
        if (!char_map.containsKey(s.charAt(i))) {
            char_map.put(s.charAt(i), i);
        } else {
            result = Math.max(result, i - char_map.get(s.charAt(i)) - 1);
        }
    }
    return result;
}

-----
public int maxLengthBetweenEqualCharacters(String s) 
    // Your code here
}

************************************
Question ID: 1625

public String findLexSmallestString(String s, int a, int b) {
    int n = s.length();
    String minStr = s;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < 10; j++) {
            String rotatedStr = rotateString(s, b);
            String tempStr = addOdd(rotatedStr, a);
            minStr = minStr.compareTo(tempStr) < 0 ? minStr : tempStr;
            s = rotatedStr;
        }
        s = addAtIndex(s, a, n - i - 1);
    }
    return minStr;
}

private String rotateString(String s, int k) {
    k %= s.length();
    return s.substring(s.length() - k) + s.substring(0, s.length() - k);
}

private String addAtIndex(String s, int a, int index) {
    char[] arr = s.toCharArray();
    arr[index] = (char) ((arr[index] - '0' + a) % 10 + '0');
    return new String(arr);
}

private String addOdd(String s, int a) {
    StringBuilder sb = new StringBuilder(s);
    for (int i = 1; i < s.length(); i += 2) {
        sb.setCharAt(i, (char) ((s.charAt(i) - '0' + a) % 10 + '0'));
    }
    return sb.toString();
}

-----
public String findLexSmallestString(String s, int a, int b) 
    // Your code here
}

************************************
Question ID: 1626

import java.util.Arrays;

public boolean canMakeArithmeticProgression(int[] arr) {
    Arrays.sort(arr);
    int difference = arr[1] - arr[0];
    for (int i = 2; i < arr.length; i++) {
        if (arr[i] - arr[i - 1] != difference) {
            return false;
        }
    }
    return true;
}

-----
import java.util.Arrays;

public boolean canMakeArithmeticProgression(int[] arr) 
    // Your code here
}

************************************
Question ID: 1627

public int lastMoment(int n, int[] left, int[] right) {
    int max_left = 0;
    int min_right = n;
    
    for(int position : left) {
        max_left = Math.max(max_left, position);
    }

    for(int position : right) {
        min_right = Math.min(min_right, position);
    }

    return Math.max(max_left, n - min_right);
}

-----
public int lastMoment(int n, int[] left, int[] right) 
    // Your code here
}

************************************
Question ID: 1628

public int numSubmat(int[][] mat) {
    int m = mat.length, n = mat[0].length;
    int[][] dp = new int[m][n];
    int count = 0;

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (mat[i][j] == 1) {
                dp[i][j] = (j == 0) ? 1 : dp[i][j - 1] + 1;
                int minWidth = dp[i][j];
                for (int k = i; k >= 0; k--) {
                    minWidth = Math.min(minWidth, dp[k][j]);
                    count += minWidth;
                }
            }
        }
    }
    return count;
}

-----
public int numSubmat(int[][] mat) 
    // Your code here
}

************************************
Question ID: 1629

public String minInteger(String num, int k) {
    if (k == 0) return num;
    int n = num.length();
    char[] arr = num.toCharArray();
    for (int i = 0; i < n; ++i) {
        int idx = i;
        for (int j = i + 1; j < n && j - i <= k; ++j) {
            if (arr[j] < arr[idx]) {
                idx = j;
            }
        }
        char minDigit = arr[idx];
        for (int j = idx; j > i; --j) {
            arr[j] = arr[j - 1];
        }
        arr[i] = minDigit;
        k -= idx - i;
    }
    return new String(arr);
}

-----
public String minInteger(String num, int k) 
    // Your code here
}

************************************
Question ID: 1630

public int countOdds(int low, int high) {
    return (high + 1) / 2 - low / 2;
}

-----
public int countOdds(int low, int high) 
    // Your code here
}

************************************
Question ID: 1631

public int numOfSubarrays(int[] arr) {
    int odd = 0, even = 1, sum = 0, result = 0;
    int mod = 1_000_000_007;
    for (int x : arr) {
        sum = (sum + x) % 2;
        if (sum % 2 == 0) {
            even++;
        } else {
            odd++;
        }
        result = (result + odd) % mod;
    }
    return result;
}

-----
public int numOfSubarrays(int[] arr) 
    // Your code here
}

************************************
Question ID: 1632

import java.util.HashSet;
import java.util.Set;

public int numSplits(String s) {
    Set<Character> leftSet = new HashSet<>();
    Set<Character> rightSet = new HashSet<>();
    int[] left = new int[s.length()], right = new int[s.length()];
    int count = 0;

    for (int i = 0; i < s.length(); i++) {
        leftSet.add(s.charAt(i));
        left[i] = leftSet.size();
    }

    for (int i = s.length() - 1; i > 0; i--) {
        rightSet.add(s.charAt(i));
        right[i] = rightSet.size();
    }

    for (int i = 0; i < s.length() - 1; i++) {
        if (left[i] == right[i + 1]) {
            count++;
        }
    }

    return count;
}

-----
import java.util.HashSet;
import java.util.Set;

public int numSplits(String s) 
    // Your code here
}

************************************
Question ID: 1636

public int numSub(String s) {
    int mod = 1000000007;
    long result = 0;
    int count = 0;
    for (char c : s.toCharArray()) {
        count = (c == '1') ? count + 1 : 0;
        result = (result + count) % mod;
    }
    return (int)result;
}

-----
public int numSub(String s) 
    // Your code here
}

************************************
Question ID: 1637

public int min_length_encoded(String s, int k) {
    int n = s.length();
    int[][] dp = new int[n + 1][k + 1];

    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= k; ++j) {
            int cnt = 1;
            dp[i][j] = i - j;
            for (int l = i - 2; l >= 0 && i - 2 - l <= j; --l) {
                if (s.charAt(l) == s.charAt(i - 1)) cnt++;
                else cnt = 1;
                int used = i - 2 - l;
                int new_aposition = i - 1 - cnt - used + 1;
                if (cnt >= 100) new_aposition += 4;
                else if (cnt >= 10) new_aposition += 3;
                else if (cnt >= 2) new_aposition += 2;
                else new_aposition++;
                dp[i][j] = Math.min(dp[i][j], new_aposition + dp[l][j - used]);
            }
        }
    }
    return dp[n][k];
}

-----
public int min_length_encoded(String s, int k) 
    // Your code here
}

************************************
Question ID: 1638

public double getMinDistSum(int[][] positions) {
    double x = 0;
    double y = 0;
    int n = positions.length;
    for (int i = 0; i < n; i++) {
        x += positions[i][0];
        y += positions[i][1];
    }
    x /= n;
    y /= n;
    return x;
}

-----
public double getMinDistSum(int[][] positions) 
    // Your code here
}

************************************
Question ID: 1639

public int numWays(String[] words, String target) {
    int n = words.length;
    int m = target.length();
    int[][] count = new int[n][26];
    int[][] dp = new int[m][n];
    final int mod = 1000000007;

    for (int i = 0; i < n; i++) {
        for (char c : words[i].toCharArray()) {
            count[i][c - 'a']++;
        }
    }

    for (int i = 0; i < n; i++) {
        dp[0][i] = count[i][target.charAt(0) - 'a'];
    }

    for (int i = 1; i < m; i++) {
        for (int j = 0; j < n; j++) {
            for (int k = 0; k < n; k++) {
                dp[i][j] = (dp[i][j] + (int)(((long) dp[i-1][k] * count[j][target.charAt(i) - 'a']) % mod)) % mod;
            }
        }
    }

    int res = 0;
    for (int i = 0; i < n; i++) {
        res = (res + dp[m-1][i]) % mod;
    }
    return res;
}

-----
public int numWays(String[] words, String target) 
    // Your code here
}

************************************
Question ID: 1640

import java.util.HashMap;
import java.util.Map;

public boolean canFormArray(int[] arr, int[][] pieces) {
    Map<Integer, int[]> map = new HashMap<>();
    for (int[] piece : pieces) {
        map.put(piece[0], piece);
    }

    int i = 0;
    while (i < arr.length) {
        if (!map.containsKey(arr[i])) {
            return false;
        }
        int[] piece = map.get(arr[i]);
        for (int j = 0; j < piece.length; ++j) {
            if (piece[j] != arr[i]) {
                return false;
            }
            ++i;
        }
    }
    return true;
}


-----
import java.util.HashMap;
import java.util.Map;

public boolean canFormArray(int[] arr, int[][] pieces) 
    // Your code here
}


************************************
Question ID: 1641

public int countVowelStrings(int n) {
    int[] dp = {1, 1, 1, 1, 1};
    for (int i = 2; i <= n; i++) {
        for (int j = 3; j >= 0; j--) {
            dp[j] = dp[j] + dp[j + 1];
        }
    }
    return Arrays.stream(dp).sum();
}

-----
public int countVowelStrings(int n) 
    // Your code here
}

************************************
Question ID: 1642

public int maxWaterBottles(int numBottles, int numExchange) {
    int total = numBottles;
    while (numBottles >= numExchange) {
        int newBottles = numBottles / numExchange;
        total += newBottles;
        numBottles = newBottles + numBottles % numExchange;
    }
    return total;
}

-----
public int maxWaterBottles(int numBottles, int numExchange) 
    // Your code here
}

************************************
Question ID: 1643

import java.util.*;

public int[] countSubTrees(int n, int[][] edges, String labels) {
    ArrayList<ArrayList<Integer>> g = new ArrayList<>();
    for (int i = 0; i < n; ++i) g.add(new ArrayList<>());
    for (int[] edge : edges) g.get(edge[1]).add(edge[0]);
    int[] ans = new int[n];
    int[] count = new int[26];
    dfs(0, g, labels, ans, count);
    return ans;
}

private void dfs(int node, ArrayList<ArrayList<Integer>> g, String labels, int[] ans, int[] count) {
    int pre = count[labels.charAt(node) - 'a'];
    count[labels.charAt(node) - 'a']++;
    ans[node] = count[labels.charAt(node) - 'a'] - pre;
    for (int child : g.get(node)) dfs(child, g, labels, ans, count);
    count[labels.charAt(node) - 'a'] = pre;
}

-----
import java.util.*;

public int[] countSubTrees(int n, int[][] edges, String labels) 
    // Your code here
}

************************************
Question ID: 1644

public List<String> maxNumOfSubstrings(String s) {
    int[] last = new int[26];
    Arrays.fill(last, -1);
    for (int i = 0; i < s.length(); ++i) {
        last[s.charAt(i) - 'a'] = i;
    }
    
    List<String> res = new ArrayList<>();
    int pre = -1, maxRight = -1;
    for (int i = 0; i < s.length(); ++i) {
        maxRight = Math.max(maxRight, last[s.charAt(i) - 'a']);
        if (maxRight == i) {
            res.add(s.substring(pre + 1, maxRight + 1));
            pre = i;
        }
    }
    
    return res;
}

-----
public List<String> maxNumOfSubstrings(String s) 
    // Your code here
}

************************************
Question ID: 1646

public int findKthPositive(int[] arr, int k) {
    int i = 0, num = 1;
    while (k > 0) {
        if (i < arr.length && arr[i] == num) {
            i++;
        } else {
            k--;
        }
        num++;
    }
    return num - 1;
}

-----
public int findKthPositive(int[] arr, int k) 
    // Your code here
}

************************************
Question ID: 1647

public boolean canConvert(String s, String t, int k) {
    int diff = 0;
    for (int i = 0; i < s.length(); i++) {
        int curr_diff = (t.charAt(i) - s.charAt(i) + 26) % 26;
        if (curr_diff > 0) {
            diff += curr_diff;
            k -= curr_diff;
        }
    }
    return k >= 0 && k >= diff - s.length() && k % 26 == 0;
}

-----
public boolean canConvert(String s, String t, int k) 
    // Your code here
}

************************************
Question ID: 1648

public int minInsertions(String s) {
    int ans = 0, depth = 0;
    for (int i = 0; i < s.length(); ++i) {
        if (s.charAt(i) == '(') {
            depth += 2;
        } else {
            if (s.charAt(i - 1) == '(') {
                --depth;
            } else {
                depth -= 2;
            }
            if (depth < 0) {
                ans -= depth;
                depth = 0;
            }
        }
    }
    return ans + depth;
}

-----
public int minInsertions(String s) 
    // Your code here
}

************************************
Question ID: 1649

import java.util.HashMap;
import java.util.Map;

public int maxNonOverlapping(int[] nums, int target) {
    int sum = 0, count = 0;
    Map<Integer, Integer> map = new HashMap<>();
    map.put(0, 1);
    for (int num : nums) {
        sum += num;
        if (map.containsKey(sum - target)) {
            count++;
            map.clear();
            map.put(0, 1);
            sum = 0;
        } else {
            map.put(sum, map.getOrDefault(sum, 0) + 1);
        }
    }
    return count;
}


-----
import java.util.HashMap;
import java.util.Map;

public int maxNonOverlapping(int[] nums, int target) 
    // Your code here
}


************************************
Question ID: 1652

public int minOperations(String target) {
    int operations = 0;
    char current_bit = '0';
    for (char bit : target.toCharArray()) {
        if (bit != current_bit) {
            operations++;
            current_bit = bit;
        }
    }
    return operations;
}

-----
public int minOperations(String target) 
    // Your code here
}

************************************
Question ID: 1653

public int dfs(TreeNode root, int distance, List<Integer> depths) {
    if (root == null) return 0;
    if (root.left == null && root.right == null) {
        depths.add(0);
        return 1;
    }
    List<Integer> left = new ArrayList<>(), right = new ArrayList<>();
    int count = dfs(root.left, distance, left) + dfs(root.right, distance, right);
    for (int l : left) {
        for (int r : right) {
            if (l + r + 2 <= distance) count++;
        }
    }
    for (int l : left) depths.add(l + 1);
    for (int r : right) depths.add(r + 1);
    return count;
}

public int countPairs(TreeNode root, int distance) {
    List<Integer> depths = new ArrayList<>();
    return dfs(root, distance, depths);
}

-----
public int dfs(TreeNode root, int distance, List<Integer> depths) 
    // Your code here
}

************************************
Question ID: 1654

import java.util.*;

public int minimumJumps(int[] forbidden, int a, int b, int x) {
    Set<Integer> forbidden_positions = new HashSet<>();
    for (int f : forbidden) {
        forbidden_positions.add(f);
    }
    Queue<int[]> q = new LinkedList<>();
    q.add(new int[]{0, 0, 0});
    Set<String> visited = new HashSet<>();
    visited.add("0,0");
    while (!q.isEmpty()) {
        int[] curr = q.poll();
        int pos = curr[0];
        int steps = curr[1];
        int backward = curr[2];
        if (pos == x) return steps;
        int forward_pos = pos + a;
        int backward_pos = pos - b;
        if (forward_pos <= 6000 && !forbidden_positions.contains(forward_pos) && !visited.contains(forward_pos + ",0")) {
            visited.add(forward_pos + ",0");
            q.add(new int[]{forward_pos, steps + 1, 0});
        }
        if (backward == 0 && backward_pos > 0 && !forbidden_positions.contains(backward_pos) && !visited.contains(backward_pos + ",1")) {
            visited.add(backward_pos + ",1");
            q.add(new int[]{backward_pos, steps + 1, 1});
        }
    }
    return -1;
}

-----
import java.util.*;

public int minimumJumps(int[] forbidden, int a, int b, int x) 
    // Your code here
}

************************************
Question ID: 1655

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public boolean canDistribute(int[] nums, int[] quantity) {
    Map<Integer, Integer> counts = new HashMap<>();
    for (int num : nums) {
        counts.put(num, counts.getOrDefault(num, 0) + 1);
    }

    List<Integer> values = new ArrayList<>(counts.values());
    Integer[] quantityArray = new Integer[quantity.length];
    for (int i = 0; i < quantity.length; i++) {
        quantityArray[i] = quantity[i];
    }
    Arrays.sort(quantityArray, Collections.reverseOrder());

    return dfs(0, values, quantityArray);
}

private boolean dfs(int index, List<Integer> values, Integer[] quantityArray) {
    if (index == quantityArray.length) {
        return true;
    }
    for (int i = 0; i < values.size(); i++) {
        if (values.get(i) >= quantityArray[index]) {
            values.set(i, values.get(i) - quantityArray[index]);
            if (dfs(index + 1, values, quantityArray)) return true;
            values.set(i, values.get(i) + quantityArray[index]);
        }
    }
    return false;
}


-----
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public boolean canDistribute(int[] nums, int[] quantity) 
    // Your code here
}


************************************
Question ID: 1656

int countGoodTriplets(int[] arr, int a, int b, int c) {
    int count = 0;
    for (int i = 0; i < arr.length; i++) {
        for (int j = i + 1; j < arr.length; j++) {
            if (Math.abs(arr[i] - arr[j]) <= a) {
                for (int k = j + 1; k < arr.length; k++) {
                    if (Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[i] - arr[k]) <= c) {
                        count++;
                    }
                }
            }
        }
    }
    return count;
}


-----
int countGoodTriplets(int[] arr, int a, int b, int c) 
    // Your code here
}


************************************
Question ID: 1657

public int getWinner(int[] arr, int k) {
    int winner = arr[0];
    int consecutiveWins = 0;

    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > winner) {
            winner = arr[i];
            consecutiveWins = 0;
        }
        if (++consecutiveWins == k) {
            break;
        }
    }
    return winner;
}

-----
public int getWinner(int[] arr, int k) 
    // Your code here
}

************************************
Question ID: 1658

public int minSwaps(int[][] grid) {
    int n = grid.length;
    int[] row_zeros = new int[n];
    
    for (int i = 0; i < n; i++) {
        for (int j = n - 1; j >= 0; j--) {
            if (grid[i][j] == 0) {
                row_zeros[i]++;
            } else {
                break;
            }
        }
    }
    
    int steps = 0;
    for (int i = 0; i < n; i++) {
        int target = n - i - 1;
        int current_row = i;
        while (current_row < n && row_zeros[current_row] < target) {
            current_row++;
        }
        if (current_row == n) {
            return -1;
        }
        steps += current_row - i;
        int temp = row_zeros[current_row];
        System.arraycopy(row_zeros, i, row_zeros, i + 1, current_row - i);
        row_zeros[i] = temp;
    }
    
    return steps;
}

-----
public int minSwaps(int[][] grid) 
    // Your code here
}

************************************
Question ID: 1659

import java.util.*;

public int maxSum(int[] nums1, int[] nums2) {
    int mod = 1000000007;
    int m = nums1.length, n = nums2.length;
    long[] dp1 = new long[m + 1], dp2 = new long[n + 1];
    int i = m - 1, j = n - 1;
    while (i >= 0 || j >= 0) {
        long a = i >= 0 ? dp1[i] + nums1[i] : Long.MIN_VALUE;
        long b = j >= 0 ? dp2[j] + nums2[j] : Long.MIN_VALUE;
        Set<Integer> seen = new HashSet<>();
        if (a > b) {
            dp1[i--] = a % mod;
            seen.add(nums1[i + 1]);
        } else {
            dp2[j--] = b % mod;
            seen.add(nums2[j + 1]);
        }
    }
    return (int) Math.max(dp1[0], dp2[0]) % mod;
}

-----
import java.util.*;

public int maxSum(int[] nums1, int[] nums2) 
    // Your code here
}

************************************
Question ID: 1660

public String thousandSeparator(int n) {
    String result = Integer.toString(n);
    int count = 0;
    for (int i = result.length() - 1; i > 0; --i) {
        count++;
        if (count % 3 == 0) {
            result = result.substring(0, i) + "." + result.substring(i);
        }
    }
    return result;
}

-----
public String thousandSeparator(int n) 
    // Your code here
}

************************************
Question ID: 1662

public int minNumOperations(int[] nums) {
    int result = 0;
    int[] highestBit = new int[32];
    for (int num : nums) {
        for (int j = 0; j < 32; j++) {
            if ((num & (1 << j)) != 0) {
                highestBit[j]++;
            }
        }
    }
    for (int count : highestBit) {
        result = Math.max(result, count);
    }
    return result + 31;
}

-----
public int minNumOperations(int[] nums) 
    // Your code here
}

************************************
Question ID: 1663

public boolean containsCycle(char[][] grid) {
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[0].length; j++) {
            if (dfs(grid, i, j, i, j, 0)) return true;
        }
    }
    return false;
}

private boolean dfs(char[][] grid, int x, int y, int startX, int startY, int depth) {
    if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != grid[startX][startY])
        return false;
    
    grid[x][y] = '*';
    
    int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    for (int[] direction : directions) {
        int newX = x + direction[0];
        int newY = y + direction[1];

        if (newX == startX && newY == startY && depth >= 4) return true;
        
        if (dfs(grid, newX, newY, startX, startY, depth + 1)) return true;
    }
    
    grid[x][y] = grid[startX][startY];
    
    return false;
}

-----
public boolean containsCycle(char[][] grid) 
    // Your code here
}

************************************
Question ID: 1664

public int numberOfFairs(int[] nums) {
    int even_sum = 0, odd_sum = 0, l_even = 0, l_odd = 0, count = 0;
    for (int i = 0; i < nums.length; ++i) {
        if (i % 2 == 0) even_sum += nums[i];
        else odd_sum += nums[i];
    }
    for (int i = 0; i < nums.length; ++i) {
        if (i % 2 == 0) {
            even_sum -= nums[i];
            if (l_even + odd_sum == l_odd + even_sum) ++count;
            l_even += nums[i];
        } else {
            odd_sum -= nums[i];
            if (l_even + odd_sum == l_odd + even_sum) ++count;
            l_odd += nums[i];
        }
    }
    return count;
}

-----
public int numberOfFairs(int[] nums) 
    // Your code here
}

************************************
Question ID: 1665

public int minimumEffort(int[][] tasks) {
    Arrays.sort(tasks, (a, b) -> (b[1] - b[0]) - (a[1] - a[0]));
    int ans = 0, sum = 0;
    for (int[] task : tasks) {
        ans = Math.max(ans, sum + task[1]);
        sum += task[0];
    }
    return ans;
}

-----
public int minimumEffort(int[][] tasks) 
    // Your code here
}

************************************
Question ID: 1666

public String makeGood(String s) {
    StringBuilder result = new StringBuilder();
    for (char c : s.toCharArray()) {
        int length = result.length();
        if (length > 0 && Math.abs(result.charAt(length - 1) - c) == 32) {
            result.deleteCharAt(length - 1);
        } else {
            result.append(c);
        }
    }
    return result.toString();
}


-----
public String makeGood(String s) 
    // Your code here
}


************************************
Question ID: 1668

int longestAwesomeSubstring(String s) {
    int n = s.length();
    int maxLen = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j <= n; ++j) {
            String substr = s.substring(i, j);
            if (isAwesome(substr)) {
                maxLen = Math.max(maxLen, j - i);
            }
        }
    }
    return maxLen;
}

boolean isAwesome(String s) {
    int odd_count = 0;
    int[] freq = new int[26];
    for (char c : s.toCharArray()) {
        freq[c - 'a']++;
    }
    for (int i = 0; i < 26; i++) {
        if (freq[i] % 2 == 1) {
            odd_count++;
        }
    }
    return (odd_count <= 1);
}

-----
int longestAwesomeSubstring(String s) 
    // Your code here
}

************************************
Question ID: 1669

import java.util.Arrays;

public int minCost(int n, int[] cuts) {
    int[] new_cuts = Arrays.copyOf(cuts, cuts.length + 2);
    new_cuts[cuts.length] = 0;
    new_cuts[cuts.length + 1] = n;
    Arrays.sort(new_cuts);
    int size = new_cuts.length;
    
    int[][] dp = new int[size][size];

    for (int len = 2; len < size; ++len) {
        for (int i = 0; i < size - len; ++i) {
            int j = i + len;
            dp[i][j] = Integer.MAX_VALUE;
            for (int k = i + 1; k < j; ++k) {
                dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + new_cuts[j] - new_cuts[i]);
            }
        }
    }

    return dp[0][size - 1];
}

-----
import java.util.Arrays;

public int minCost(int n, int[] cuts) 
    // Your code here
}

************************************
Question ID: 1670

import java.util.LinkedList;

class FrontMiddleBackQueue {
    LinkedList<Integer> first, second;
    
    public FrontMiddleBackQueue() {
        first = new LinkedList<>();
        second = new LinkedList<>();
    }
    
    public void pushFront(int val) {
        first.addFirst(val);
        if (first.size() > second.size() + 1) {
            second.addFirst(first.removeLast());
        }
    }
    
    public void pushMiddle(int val) {
        if (first.size() < second.size()) {
            first.addLast(val);
        } else {
            second.addFirst(val);
        }
    }
    
    public void pushBack(int val) {
        second.addLast(val);
        if (second.size() > first.size()) {
            first.addLast(second.removeFirst());
        }
    }
    
    public int popFront() {
        if (first.isEmpty() && second.isEmpty()) return -1;
        int val = first.pollFirst();
        if (first.size() + 1 < second.size()) {
            first.addLast(second.pollFirst());
        }
        return val;
    }
    
    public int popMiddle() {
        if (first.isEmpty() && second.isEmpty()) return -1;
        int val;
        if (first.size() < second.size()) {
            val = second.pollFirst();
        } else {
            val = first.pollLast();
        }
        if (second.size() > first.size()) {
            first.addLast(second.pollFirst());
        }
        return val;
    }
    
    public int popBack() {
        if (first.isEmpty() && second.isEmpty()) return -1;
        int val = second.pollLast();
        if (first.size() > second.size() + 1) {
            second.addFirst(first.pollLast());
        }
        return val;
    }
}

-----
import java.util.LinkedList;

class FrontMiddleBackQueue 
    // Your code here
}

************************************
Question ID: 1671

public int minimumMountainRemovals(int[] nums) {
    int n = nums.length;
    int[] left = new int[n], right = new int[n];
    for (int i = 1; i < n; ++i) {
        left[i] = left[i - 1] + (nums[i] > nums[i - 1] ? 1 : 0);
        right[n - i - 1] = right[n - i] + (nums[n - i - 1] > nums[n - i] ? 1 : 0);
    }
    int ans = n - 3;
    for (int i = 1; i < n - 1; ++i) {
        ans = Math.min(ans, n - 1 - left[i] - right[i]);
    }
    return ans;
}

-----
public int minimumMountainRemovals(int[] nums) 
    // Your code here
}

************************************
Question ID: 1672

public int maximumWealth(int[][] accounts) {
    int maxWealth = 0;
    for (int[] customer : accounts) {
        int wealth = 0;
        for (int account : customer) {
            wealth += account;
        }
        maxWealth = Math.max(maxWealth, wealth);
    }
    return maxWealth;
}

-----
public int maximumWealth(int[][] accounts) 
    // Your code here
}

************************************
Question ID: 1673

import java.util.Stack;

public int[] mostCompetitive(int[] nums, int k) {
    Stack<Integer> stack = new Stack<>();
    int n = nums.length;
    for (int i = 0; i < n; i++) {
        while (!stack.empty() && stack.peek() > nums[i] && stack.size() + n - i > k) {
            stack.pop();
        }
        if (stack.size() < k) {
            stack.push(nums[i]);
        }
    }
    int[] result = new int[k];
    for (int i = k - 1; i >= 0; i--) {
        result[i] = stack.pop();
    }
    return result;
}


-----
import java.util.Stack;

public int[] mostCompetitive(int[] nums, int k) 
    // Your code here
}


************************************
Question ID: 1674

public int minOperations(int n) {
    return n * (n - 1) / 2;
}


-----
public int minOperations(int n) 
    // Your code here
}


************************************
Question ID: 1675

import java.util.Arrays;

public int maxDistance(int[] position, int m) {
    Arrays.sort(position);

    int left = 1;
    int right = position[position.length - 1] - position[0];
    int ans = 0;

    while (left <= right) {
        int mid = (left + right) / 2;
        if (canPlaceBalls(mid, position, m)) {
            ans = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return ans;
}

private boolean canPlaceBalls(int force, int[] position, int m) {
    int last_position = position[0];
    int placed_balls = 1;

    for (int i = 1; i < position.length; i++) {
        if (position[i] - last_position >= force) {
            placed_balls++;
            last_position = position[i];

            if (placed_balls == m) {
                return true;
            }
        }
    }

    return false;
}

-----
import java.util.Arrays;

public int maxDistance(int[] position, int m) 
    // Your code here
}

************************************
Question ID: 1678

public int numWays(String s) {
    int numberOfOnes = 0;
    for (char c : s.toCharArray()) {
        if (c == '1') numberOfOnes++;
    }
    if (numberOfOnes % 3 != 0) return 0;

    int target = numberOfOnes / 3;
    if (target == 0) {
        long n = s.length();
        return (int) ((n - 1) * (n - 2) / 2 % 1000000007);
    }

    int onesSoFar1 = 0, onesSoFar2 = 0;
    long way1 = 0, way2 = 0;
    for (char c : s.toCharArray()) {
        if (c == '1') {
            onesSoFar1++;
            if (onesSoFar1 == target) {
                way1++;
                onesSoFar1 = 0;
            }

            onesSoFar2++;
            if (onesSoFar2 == target * 2) {
                way2++;
                onesSoFar2 = 0;
            }
        }
    }

    return (int) (way1 * way2 % 1000000007);
}


-----
public int numWays(String s) 
    // Your code here
}


************************************
Question ID: 1679

public int findLengthOfShortestSubarray(int[] arr) {
    int n = arr.length;
    int left = 0, right = n - 1;

    while (left < n - 1 && arr[left] <= arr[left + 1]) left++;
    if (left == n - 1) return 0;

    while (right > 0 && arr[right] >= arr[right - 1]) right--;

    int result = Math.min(right, n - left - 1);

    int i = 0, j = right;

    while (i <= left && j < n) {
        if (arr[i] <= arr[j]) {
            result = Math.min(result, j - i - 1);
            i++;
        } else {
            j++;
        }
    }

    return result;
}


-----
public int findLengthOfShortestSubarray(int[] arr) 
    // Your code here
}


************************************
Question ID: 1680

public int countRoutes(int[] locations, int start, int finish, int fuel) {
    Integer[][] memo = new Integer[locations.length][fuel + 1];
    return countRoutes(locations, start, finish, fuel, start, fuel, memo);
}

private int countRoutes(int[] locations, int start, int finish, int fuel, int curr, int remainingFuel, Integer[][] memo) {
    if (remainingFuel < 0) {
        return 0;
    }

    if (memo[curr][remainingFuel] != null) {
        return memo[curr][remainingFuel];
    }

    int ans = curr == finish ? 1 : 0;
    for (int next = 0; next < locations.length; ++next) {
        if (next != curr) {
            ans += countRoutes(locations, start, finish, fuel, next, remainingFuel - Math.abs(locations[curr] - locations[next]), memo);
            ans %= 1000000007;
        }
    }
    memo[curr][remainingFuel] = ans;
    return ans;
}

-----
public int countRoutes(int[] locations, int start, int finish, int fuel) 
    // Your code here
}

************************************
Question ID: 1682

import java.util.*;

public List<Integer> mostVisited(int n, int[] rounds) {
    int[] visited = new int[n + 1];
    for (int i = 1; i < rounds.length; ++i) {
        for (int start = rounds[i - 1], end = rounds[i]; start != end; start = start % n + 1) {
            ++visited[start];
        }
    }
    ++visited[rounds[rounds.length - 1]];

    int maxVisits = Arrays.stream(visited).max().getAsInt();
    List<Integer> result = new ArrayList<>();

    for (int i = 1; i <= n; ++i) {
        if (visited[i] == maxVisits) {
            result.add(i);
        }
    }
    return result;
}

-----
import java.util.*;

public List<Integer> mostVisited(int n, int[] rounds) 
    // Your code here
}

************************************
Question ID: 1684

public int findLatestStep(int[] arr, int m) {
    int n = arr.length;
    int[] lengthLeft = new int[n + 2], lengthRight = new int[n + 2];
    int count = 0, result = -1;

    for (int i = 0; i < n; ++i) {
        int pos = arr[i];
        int leftLength = lengthRight[pos - 1];
        int rightLength = lengthLeft[pos + 1];
        int newLength = leftLength + rightLength + 1;

        if (leftLength == m || rightLength == m) {
            count--;
        }
        
        if (newLength == m) {
            count++;
        }
        
        if (newLength > 0) {
            lengthLeft[pos - leftLength] = newLength;
            lengthRight[pos + rightLength] = newLength;
            result = i + 1;
        }
    }

    return count > 0 ? result : -1;
}


-----
public int findLatestStep(int[] arr, int m) 
    // Your code here
}


************************************
Question ID: 1685

public int stoneGameV(int[] stoneValue) {
    int n = stoneValue.length;
    int[][] memo = new int[n][n];
    return maxScore(stoneValue, 0, n - 1, memo);
}

private int maxScore(int[] stoneValue, int start, int end, int[][] memo) {
    if (start == end) return 0;
    if (memo[start][end] != 0) return memo[start][end];

    int leftSum = 0, rightSum = 0;
    for (int i = start; i < end; ++i) {
        leftSum += stoneValue[i];
        rightSum = 0;
        for (int j = i + 1; j <= end; ++j)
            rightSum += stoneValue[j];

        if (leftSum > rightSum)
            memo[start][end] = Math.max(memo[start][end], rightSum + maxScore(stoneValue, i + 1, end, memo));
        else if (leftSum < rightSum)
            memo[start][end] = Math.max(memo[start][end], leftSum + maxScore(stoneValue, start, i, memo));
        else
            memo[start][end] = Math.max(memo[start][end], leftSum + Math.max(maxScore(stoneValue, start, i, memo), maxScore(stoneValue, i + 1, end, memo)));
    }
    return memo[start][end];
}


-----
public int stoneGameV(int[] stoneValue) 
    // Your code here
}


************************************
Question ID: 1686

import java.util.Arrays;
import java.util.Comparator;

public int stoneGameVI(int[] aliceValues, int[] bobValues) {
    int n = aliceValues.length;
    Integer[] indices = new Integer[n];
    for (int i = 0; i < n; i++) {
        indices[i] = i;
    }
    
    Arrays.sort(indices, (a, b) -> (bobValues[a] + aliceValues[a]) - (bobValues[b] + aliceValues[b]));
    
    int aliceSum = 0, bobSum = 0;
    for (int i = n - 1; i >= 0; i--) {
        if ((n - 1 - i) % 2 == 0)
            aliceSum += aliceValues[indices[i]];
        else
            bobSum += bobValues[indices[i]];
    }

    return Integer.compare(aliceSum, bobSum);
}


-----
import java.util.Arrays;
import java.util.Comparator;

public int stoneGameVI(int[] aliceValues, int[] bobValues) 
    // Your code here
}


************************************
Question ID: 1687

public int min_trips(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {
    int trips = 0, idx = 0, n = boxes.length;
    while (idx < n) {
        int curr_limit = maxWeight, prev_port = 0;
        for (int count = 0; count < maxBoxes && idx < n; ++idx) {
            if (boxes[idx][1] <= curr_limit) {
                if (prev_port != boxes[idx][0]) {
                    prev_port = boxes[idx][0];
                    ++trips;
                }
                curr_limit -= boxes[idx][1];
                ++count;
            }
        }
        ++trips;
    }
    return trips;
}

-----
public int min_trips(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) 
    // Your code here
}

************************************
Question ID: 1688

public int numberOfMatches(int n) {
    int matches = 0;
    while (n > 1) {
        matches += n / 2;
        n = (n + 1) / 2;
    }
    return matches;
}

-----
public int numberOfMatches(int n) 
    // Your code here
}

************************************
Question ID: 1689

public boolean containsPattern(int[] arr, int m, int k) {
    int n = arr.length;
    if (m * k > n) return false;

    for (int i = 0; i + m * k <= n; i++) {
        boolean patternFound = true;
        for (int j = 0; j < m; j++) {
            for (int l = 1; l < k; l++) {
                if (arr[i + j] != arr[i + j + l * m]) {
                    patternFound = false;
                    break;
                }
            }
            if (!patternFound) break;
        }
        if (patternFound) return true;
    }
    return false;
}

-----
public boolean containsPattern(int[] arr, int m, int k) 
    // Your code here
}

************************************
Question ID: 1690

public int getMaxLen(int[] nums) {
    int maxLength = 0, currentLen = 0, currentNegLen = 0;
    
    for (int num : nums) {
        if (num > 0) {
            ++currentLen;
            if (currentNegLen > 0) ++currentNegLen;
        } else if (num < 0) {
            int tmp = currentLen;
            currentLen = currentNegLen;
            currentNegLen = tmp + 1;
        } else {
            currentLen = 0;
            currentNegLen = 0;
        }
        maxLength = Math.max(maxLength, currentLen);
    }
    
    return maxLength;
}

-----
public int getMaxLen(int[] nums) 
    // Your code here
}

************************************
Question ID: 1692

public int numTrees(int n) {
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = 1;

    for (int i = 2; i <= n; i++) {
        for (int j = 0; j < i; j++) {
            dp[i] += dp[j] * dp[i - 1 - j];
            dp[i] %= 1000000007;
        }
    }

    return dp[n];
}

-----
public int numTrees(int n) 
    // Your code here
}

************************************
Question ID: 1694

import java.util.HashMap;

public int minSubarray(int[] nums, int p) {
    int n = nums.length, need = 0, cur = 0, res = n;
    for (int num : nums) need = (need + num) % p;
    if (need == 0) return 0;
    HashMap<Integer, Integer> last_seen = new HashMap<>();
    last_seen.put(cur, -1);
    for (int i = 0; i < n; ++i) {
        cur = (cur + nums[i]) % p;
        last_seen.put(cur, i);
        int want = (cur - need + p) % p;
        if (last_seen.containsKey(want)) {
            res = Math.min(res, i-last_seen.get(want));
        }
    }
    return res == n ? -1 : res;
}


-----
import java.util.HashMap;

public int minSubarray(int[] nums, int p) 
    // Your code here
}


************************************
Question ID: 1695

import java.util.Arrays;

class Solution {
    public int maxSumRangeQuery(int[] nums, int[][] requests) {
        int n = nums.length;
        int[] cnt = new int[n];
        int mod = (int) 1e9 + 7;

        for (int[] req : requests) {
            cnt[req[0]]++;
            if (req[1] + 1 < n) cnt[req[1] + 1]--;
        }

        for (int i = 1; i < n; i++) {
            cnt[i] += cnt[i - 1];
        }

        Arrays.sort(nums);
        Arrays.sort(cnt);

        long ans = 0;
        for (int i = 0; i < n; i++) {
            ans += (long) nums[i] * cnt[i];
            ans %= mod;
        }

        return (int) ans;
    }
}

-----
import java.util.Arrays;

class Solution 
    // Your code here
}

************************************
Question ID: 1696

import java.util.Arrays;

class Solution {
    public boolean isPrintable(int[][] targetGrid) {
        int m = targetGrid.length, n = targetGrid[0].length;
        int[] top = new int[61], bottom = new int[61], left = new int[61], right = new int[61];
        boolean[][] vis = new boolean[m][n];

        Arrays.fill(top, m);
        Arrays.fill(bottom, -1);
        Arrays.fill(left, n);
        Arrays.fill(right, -1);

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                int c = targetGrid[i][j];
                top[c] = Math.min(top[c], i);
                bottom[c] = Math.max(bottom[c], i);
                left[c] = Math.min(left[c], j);
                right[c] = Math.max(right[c], j);
            }
        }

        for (int color = 1; color <= 60; ++color) {
            for (int i = top[color]; i <= bottom[color]; ++i) {
                for (int j = left[color]; j <= right[color]; ++j) {
                    if (!vis[i][j] && !dfs(i * n + j, targetGrid, vis, top, bottom, left, right)) {
                        return false;
                    }
                }
            }
        }

        return true;
    }

    private boolean dfs(int x, int[][] targetGrid, boolean[][] vis, int[] top, int[] bottom, int[] left, int[] right) {
        int n = targetGrid[0].length;
        int i = x / n, j = x % n;
        if (vis[i][j]) return true;
        int c = targetGrid[i][j];
        if (i < top[c] || i > bottom[c] || j < left[c] || j > right[c]) return false;
        vis[i][j] = true;
        for (int k = 1; k <= 60; ++k) {
            if (k == c) continue;
            if (i >= top[k] && i <= bottom[k] && j >= left[k] && j <= right[k]) return false;
            if (!dfs(((i-top[k])*(right[k]-left[k]+1)) + j - left[k], targetGrid, vis, top, bottom, left, right)) return false;
        }
        return true;
    }
}


-----
import java.util.Arrays;

class Solution 
    // Your code here
}


************************************
Question ID: 1697

import java.util.*;

public class Solution {
    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {
        Map<Integer, List<int[]>> graph = new HashMap<>();

        for (int[] edge : edgeList) {
            graph.putIfAbsent(edge[0], new ArrayList<>());
            graph.putIfAbsent(edge[1], new ArrayList<>());
            graph.get(edge[0]).add(new int[]{edge[1], edge[2]});
            graph.get(edge[1]).add(new int[]{edge[0], edge[2]});
        }

        boolean[] answer = new boolean[queries.length];
        for (int i = 0; i < queries.length; i++) {
            int pj = queries[i][0], qj = queries[i][1], limitj = queries[i][2];

            Queue<int[]> q = new LinkedList<>();
            q.add(new int[]{pj, 0});
            boolean[] visited = new boolean[n];
            visited[pj] = true;

            while (!q.isEmpty()) {
                int[] curr = q.poll();

                for (int[] next : graph.getOrDefault(curr[0], new ArrayList<>())) {
                    if (curr[1] + next[1] < limitj) {
                        if (next[0] == qj) {
                            answer[i] = true;
                            break;
                        }
                        if (!visited[next[0]]) {
                            visited[next[0]] = true;
                            q.add(new int[]{next[0], curr[1] + next[1]});
                        }
                    }
                }
                if (answer[i]) 
                    break;
            }
        }
        return answer;
    }
}

-----
import java.util.*;

public class Solution 
    // Your code here
}

************************************
Question ID: 1698

public String modifyString(String s) {
    char[] result = s.toCharArray();
    for (int i = 0; i < result.length; i++) {
        if (result[i] == '?') {
            for (char c = 'a'; c <= 'z'; c++) {
                if ((i - 1 < 0 || result[i - 1] != c) && (i + 1 >= result.length || result[i + 1] != c)) {
                    result[i] = c;
                    break;
                }
            }
        }
    }
    return new String(result);
}


-----
public String modifyString(String s) 
    // Your code here
}


************************************
Question ID: 1700

public int min_time_to_remove_balloons(String colors, int[] neededTime) {
    int n = colors.length();
    int[][] dp = new int[n][26];
    final int INF = (int) 1e9;

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < 26; j++) {
            dp[i][j] = INF;
        }
    }

    for (int color = 0; color < 26; color++) {
        if (colors.charAt(0) != 'A' + color) dp[0][color] = neededTime[0];
    }

    for (int i = 1; i < n; i++) {
        for (int color1 = 0; color1 < 26; color1++) {
            for (int color2 = 0; color2 < 26; color2++) {
                if (color1 != color2 && colors.charAt(i) != 'A' + color1) {
                    dp[i][color1] = Math.min(dp[i][color1], dp[i-1][color2] + neededTime[i]);
                }
            }
        }
    }

    int ans = INF;
    for (int color = 0; color < 26; color++) {
        ans = Math.min(ans, dp[n-1][color]);
    }
    return ans;
}


-----
public int min_time_to_remove_balloons(String colors, int[] neededTime) 
    // Your code here
}


************************************
Question ID: 1701

public int maxNumEdgesToRemove(int n, int[][] edges) {
    int[] parent = new int[2 * n + 1];
    for (int i = 0; i <= 2 * n; ++i) parent[i] = i;
    int[] ct = new int[2], both = new int[]{n - 1};
    
    Arrays.sort(edges, (o1, o2) -> Integer.compare(o2[0], o1[0]));
    for (int[] edge : edges) {
        if (edge[0] == 3 && unite(parent, edge[1], edge[2] + n)) --both[0];
        if (both[0] == 0) break;
    }
    
    for (int type = 1; type < 3; ++type) {
        for (int[] edge : edges) {
            if (edge[0] == type && unite(parent, edge[1], edge[2] + n)) ++ct[type - 1];
        }
        if (both[type - 1] + ct[type - 1] < n - 1) return -1;
    }
    return ct[0] + ct[1] - n + 1;
}

private boolean unite(int[] parent, int u, int v) {
    u = find(parent, u);
    v = find(parent, v);
    if (u != v) {
        parent[u] = v;
        return true;
    }
    return false;
}

private int find(int[] parent, int u) {
    return parent[u] == u ? u : (parent[u] = find(parent, parent[u]));
}


-----
public int maxNumEdgesToRemove(int n, int[][] edges) 
    // Your code here
}


************************************
Question ID: 1702

public String maximumBinaryString(String binary) {
    int zeroCount = 0;
    int oneCount = 0;
    
    for (char c : binary.toCharArray()) {
        if (c == '0') {
            zeroCount++;
        } else {
            oneCount++;
        }
    }
    
    if (zeroCount <= 1) {
        return binary;
    }
    
    StringBuilder result = new StringBuilder();
    for (int i = 0; i < oneCount; ++i) {
        result.append('1');
    }
    for (int i = 0; i < zeroCount - 1; ++i) {
        result.append('0');
    }
    result.append("1####1");
    return result.substring(0, binary.length());
}

-----
public String maximumBinaryString(String binary) 
    // Your code here
}

************************************
Question ID: 1703

public int minMoves(int[] nums, int k) {
    List<Integer> ones_pos = new ArrayList<>();
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] == 1) {
            ones_pos.add(i - ones_pos.size());
        }
    }
    int sum = 0;
    for (int i = 0; i < k; i++) {
        sum += ones_pos.get(i);
    }
    int min_sum = sum;
    for (int i = k; i < ones_pos.size(); i++) {
        sum += ones_pos.get(i) - ones_pos.get(i - k);
        min_sum = Math.min(min_sum, sum);
    }
    return min_sum - (k - 1) * k / 2;
}

-----
public int minMoves(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 1704

public int numSpecial(int[][] mat) {
    int m = mat.length, n = mat[0].length;
    int[] row = new int[m], col = new int[n];

    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (mat[i][j] == 1) {
                ++row[i];
                ++col[j];
            }
        }
    }

    int special_positions = 0;
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (mat[i][j] == 1 && row[i] == 1 && col[j] == 1) {
                ++special_positions;
            }
        }
    }

    return special_positions;
}

-----
public int numSpecial(int[][] mat) 
    // Your code here
}

************************************
Question ID: 1705

public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {
    int[] pairMapping = new int[n];
    for (int[] pair : pairs) {
        pairMapping[pair[0]] = pair[1];
        pairMapping[pair[1]] = pair[0];
    }

    int unhappyCount = 0;
    for (int x = 0; x < n; x++) {
        int y = pairMapping[x];
        int[] prefX = preferences[x];
        int idxY = -1;
        for (int i = 0; i < prefX.length; i++) {
            if (prefX[i] == y) {
                idxY = i;
                break;
            }
        }

        for (int i = 0; i < idxY; i++) {
            int u = prefX[i];
            int v = pairMapping[u];
            int[] prefU = preferences[u];
            for (int j = 0; j < prefU.length; j++) {
                if (prefU[j] == x) {
                    unhappyCount++;
                    break;
                } else if (prefU[j] == v) {
                    break;
                }
            }
        }
    }

    return unhappyCount / 2;
}


-----
public int unhappyFriends(int n, int[][] preferences, int[][] pairs) 
    // Your code here
}


************************************
Question ID: 1706

import java.util.Arrays;

public int minCostConnectPoints(int[][] points) {
    int n = points.length;
    int[] cost = new int[n];
    boolean[] visited = new boolean[n];
    Arrays.fill(cost, Integer.MAX_VALUE);
    cost[0] = 0;

    int ans = 0;

    for (int i = 0; i < n; i++) {
        int min_cost = Integer.MAX_VALUE;
        int cur_point = -1;
        for (int j = 0; j < n; j++) {
            if (!visited[j] && cost[j] < min_cost) {
                min_cost = cost[j];
                cur_point = j;
            }
        }

        visited[cur_point] = true;
        ans += min_cost;

        for (int j = 0; j < n; j++) {
            if (!visited[j]) {
                int new_cost = Math.abs(points[cur_point][0] - points[j][0]) + Math.abs(points[cur_point][1] - points[j][1]);
                cost[j] = Math.min(cost[j], new_cost);
            }
        }
    }

    return ans;
}

-----
import java.util.Arrays;

public int minCostConnectPoints(int[][] points) 
    // Your code here
}

************************************
Question ID: 1707

boolean canTransform(String s, String t) {
    int i = 0, j = 0;
    while (i < s.length() && j < t.length()) {
        if (s.charAt(i) == t.charAt(j)) {
            i++;
            j++;
        } else {
            i++;
        }
    }
    return j == t.length();
}


-----
boolean canTransform(String s, String t) 
    // Your code here
}


************************************
Question ID: 1710

import java.util.*;

public List<Integer> busiestServers(int k, int[] arrival, int[] load) {
    int[] serverRequests = new int[k];
    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
    Queue<Integer> availableServers = new LinkedList<>();

    for (int i = 0; i < k; i++) {
        availableServers.offer(i);
    }

    for (int i = 0; i < arrival.length; i++) {
        while (!pq.isEmpty() && pq.peek()[0] <= arrival[i]) {
            availableServers.offer(pq.poll()[1]);
        }

        if (!availableServers.isEmpty()) {
            int serverId = availableServers.poll();
            serverRequests[serverId]++;
            pq.offer(new int[]{arrival[i] + load[i], serverId});
        }
    }

    int maxRequests = 0;
    for (int requests : serverRequests) {
        maxRequests = Math.max(maxRequests, requests);
    }

    List<Integer> result = new ArrayList<>();
    for (int i = 0; i < k; i++) {
        if (serverRequests[i] == maxRequests) {
            result.add(i);
        }
    }

    return result;
}


-----
import java.util.*;

public List<Integer> busiestServers(int k, int[] arrival, int[] load) 
    // Your code here
}


************************************
Question ID: 1711

public int[][] restoreMatrix(int[] rowSum, int[] colSum) {
    int m = rowSum.length;
    int n = colSum.length;
    int[][] result = new int[m][n];

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            int value = Math.min(rowSum[i], colSum[j]);
            result[i][j] = value;
            rowSum[i] -= value;
            colSum[j] -= value;
        }
    }

    return result;
}

-----
public int[][] restoreMatrix(int[] rowSum, int[] colSum) 
    // Your code here
}

************************************
Question ID: 1712

public int waysToSplit(int[] nums) {
    int MOD = 1000000007;
    int n = nums.length;
    long[] prefixSum = new long[n + 1];
    for (int i = 0; i < n; i++) {
        prefixSum[i + 1] = prefixSum[i] + nums[i];
    }
    int ans = 0;
    int left = 0, right = 0;
    for (int mid = 1; mid < n - 1; mid++) {
        while (left + 1 < mid && prefixSum[left + 1] * 2 <= prefixSum[mid]) {
            left++;
        }
        while (right < mid || (right + 1 < n && prefixSum[right + 1] - prefixSum[mid] <= prefixSum[n] - prefixSum[right + 1])) {
            right++;
        }
        if (right >= mid && prefixSum[mid] - prefixSum[left] <= prefixSum[right] - prefixSum[mid]) {
            ans = (int) ((ans + right - mid + 1) % MOD);
        }
    }
    return ans;
}

-----
public int waysToSplit(int[] nums) 
    // Your code here
}

************************************
Question ID: 1713

import java.util.*;

public int minOperations(int[] target, int[] arr) {
    Map<Integer, Integer> pos = new HashMap<>();
    for (int i = 0; i < target.length; ++i) {
        pos.put(target[i], i);
    }

    List<Integer> dp = new ArrayList<>();
    for (int a : arr) {
        if (pos.containsKey(a)) {
            int idx = Collections.binarySearch(dp, pos.get(a));
            if (idx < 0) {
                idx = -(idx + 1);
            }
            if (idx == dp.size()) {
                dp.add(pos.get(a));
            } else {
                dp.set(idx, pos.get(a));
            }
        }
    }
    return target.length - dp.size();
}

-----
import java.util.*;

public int minOperations(int[] target, int[] arr) 
    // Your code here
}

************************************
Question ID: 1714

import java.util.ArrayList;
import java.util.List;

public String reorderSpaces(String text) {
    int spaces = 0;
    List<String> words = new ArrayList<>();
    
    String[] splitText = text.split("\\s+");
    for (String word : splitText) {
        words.add(word);
        spaces += word.length() - word.trim().length();
    }
    
    if (words.size() == 1) {
        return words.get(0) + " ".repeat(spaces);
    }

    int spaceBetweenWords = spaces / (words.size() - 1);
    int extraSpaces = spaces % (words.size() - 1);
    StringBuilder result = new StringBuilder();
    
    for (int i = 0; i < words.size(); i++) {
        result.append(words.get(i));
        if (i < words.size() - 1) {
            result.append(" ".repeat(spaceBetweenWords));
        }
    }
    
    result.append(" ".repeat(extraSpaces));

    return result.toString();
}

-----
import java.util.ArrayList;
import java.util.List;

public String reorderSpaces(String text) 
    // Your code here
}

************************************
Question ID: 1716

public int maxProductPath(int[][] grid) {
    int m = grid.length, n = grid[0].length, mod = 1000000007;
    long[][][] dp = new long[m][n][2];
    
    dp[0][0] = new long[]{grid[0][0], grid[0][0]};
    
    for(int i = 1; i < m; i++) {
        dp[i][0] = new long[]{dp[i-1][0][0] * grid[i][0], dp[i-1][0][0] * grid[i][0]};
    }
    for(int j = 1; j < n; j++) {
        dp[0][j] = new long[]{dp[0][j-1][0] * grid[0][j], dp[0][j-1][0] * grid[0][j]};
    }
    
    for(int i = 1; i < m; i++) {
        for(int j = 1; j < n; j++) {
            if(grid[i][j] < 0) {
                dp[i][j][0] = Math.min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j];
                dp[i][j][1] = Math.max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j];
            } else {
                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j];
                dp[i][j][1] = Math.min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j];
            }
        }
    }
    
    return dp[m - 1][n - 1][0] >= 0 ? (int)(dp[m - 1][n - 1][0] % mod) : -1;
}


-----
public int maxProductPath(int[][] grid) 
    // Your code here
}


************************************
Question ID: 1717

import java.util.Arrays;

public int minCost(int[][] cost, int size1, int size2) {
    int[] dp = new int[size2 + 1];
    Arrays.fill(dp, Integer.MAX_VALUE);
    dp[0] = 0;

    for (int i = 0; i < size1; i++) {
        for (int j = size2; j >= 0; j--) {
            int minCost = Integer.MAX_VALUE;
            for (int k = 0; k < size2; k++) {
                if (((1 << k) & j) == 0) {
                    minCost = Math.min(minCost, cost[i][k] + dp[j | (1 << k)]);
                }
            }
            dp[j] = Math.min(dp[j], minCost);
        }
    }

    return dp[(1 << size2) - 1];
}

-----
import java.util.Arrays;

public int minCost(int[][] cost, int size1, int size2) 
    // Your code here
}

************************************
Question ID: 1719

import java.util.HashMap;
import java.util.Map;
import java.util.List;

public int checkWays(List<List<Integer>> pairs) {
    Map<Integer, Integer> candidates = new HashMap<>();
    for (List<Integer> pair : pairs) {
        candidates.put(pair.get(0),
                candidates.getOrDefault(pair.get(0), 0) + 1);
        candidates.put(pair.get(1),
                candidates.getOrDefault(pair.get(1), 0) + 1);
    }

    int rootCount = 0;
    for (int candidate : candidates.values()) {
        if (candidate == 1) {
            rootCount++;
            if (rootCount > 1) {
                return 2;
            }
        }
    }

    return rootCount;
}

-----
import java.util.HashMap;
import java.util.Map;
import java.util.List;

public int checkWays(List<List<Integer>> pairs) 
    // Your code here
}

************************************
Question ID: 1720

public int minOperations(String[] logs) {
    int depth = 0;
    for (String log : logs) {
        if (log.equals("../")) {
            if (depth > 0) {
                depth--;
            }
        } else if (!log.equals("./")) {
            depth++;
        }
    }
    return depth;
}


-----
public int minOperations(String[] logs) 
    // Your code here
}


************************************
Question ID: 1721

public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {
    int rotations = 0, waiting = 0, onBoard, profit = 0, maxProfit = 0, maxRotations = 0;
    int idx = 0;
    while (idx < customers.length || waiting > 0) {
        if (idx < customers.length) {
            waiting += customers[idx];
            idx++;
        }
        
        onBoard = Math.min(waiting, 4);
        waiting -= onBoard;
        profit += onBoard * boardingCost - runningCost;
        rotations++;
        
        if (profit > maxProfit) {
            maxProfit = profit;
            maxRotations = rotations;
        }
    }
    return maxProfit > 0 ? maxRotations : -1;
}


-----
public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) 
    // Your code here
}


************************************
Question ID: 1723

import java.util.ArrayList;

public int maxAchievableRequests(int n, ArrayList<ArrayList<Integer>> requests, int idx, ArrayList<Integer> counts) {
    if (counts == null) {
        counts = new ArrayList<Integer>(n);
        for (int i = 0; i < n; i++) {
            counts.add(0);
        }
    }
    if (idx == requests.size()) {
        for (int count : counts) {
            if (count != 0) return 0;
        }
        return 0;
    }
    int ignored = maxAchievableRequests(n, requests, idx + 1, counts);
    counts.set(requests.get(idx).get(0), counts.get(requests.get(idx).get(0)) + 1);
    counts.set(requests.get(idx).get(1), counts.get(requests.get(idx).get(1)) - 1);

    int accepted = 1 + maxAchievableRequests(n, requests, idx + 1, counts);

    return Math.max(ignored, accepted);
}

-----
import java.util.ArrayList;

public int maxAchievableRequests(int n, ArrayList<ArrayList<Integer>> requests, int idx, ArrayList<Integer> counts) 
    // Your code here
}

************************************
Question ID: 1725

public int numberOfSets(int n, int k) {
    long mod = 1000000007;
    long[][] dp = new long[n][k + 1];
    long[] presum = new long[n];
    Arrays.fill(presum, 1);
    
    for (int j = 1; j <= k; ++j) {
        for (int i = 0; i < n; ++i) {
            dp[i][j] = presum[i];
            if (i > 0) {
                dp[i][j] += dp[i - 1][j];
            }
            dp[i][j] %= mod;
            presum[i] = (presum[i] + dp[i][j - 1]) % mod;
        }
    }
    
    return (int) dp[n - 1][k];
}

-----
public int numberOfSets(int n, int k) 
    // Your code here
}

************************************
Question ID: 1726

import java.util.List;
import java.util.ArrayList;

public int[] bestCoordinate(List<int[]> towers, int radius) {
    int max_quality = 0, best_x = 0, best_y = 0;

    for (int x = 0; x <= 50; ++x) {
        for (int y = 0; y <= 50; ++y) {
            int sum_quality = 0;
            for (int[] tower : towers) {
                double dist = Math.sqrt(Math.pow(x - tower[0], 2) + Math.pow(y - tower[1], 2));
                if (dist <= radius) {
                    sum_quality += tower[2] / (1 + dist);
                }
            }
            if (sum_quality > max_quality) {
                max_quality = sum_quality;
                best_x = x;
                best_y = y;
            }
        }
    }

    return new int[]{best_x, best_y};
}

-----
import java.util.List;
import java.util.ArrayList;

public int[] bestCoordinate(List<int[]> towers, int radius) 
    // Your code here
}

************************************
Question ID: 1727

public boolean canMouseWin(char[][] grid, int catJump, int mouseJump) {
    int rows = grid.length;
    int cols = grid[0].length;
    int cat_r = 0, cat_c = 0, mouse_r = 0, mouse_c = 0;

    for (int r = 0; r < rows; ++r)
        for (int c = 0; c < cols; ++c) {
            if (grid[r][c] == 'C') {
                cat_r = r;
                cat_c = c;
            } else if (grid[r][c] == 'M') {
                mouse_r = r;
                mouse_c = c;
            }
        }

    int[] dirs = {-1, 0, 1, 0, -1};
    return dfs(grid, mouse_r, mouse_c, cat_r, cat_c, 0, Math.abs(cat_r - mouse_r) + Math.abs(cat_c - mouse_c), catJump, mouseJump, dirs, new HashSet<>());
}

private boolean dfs(char[][] grid, int r_m, int c_m, int r_c, int c_c, int cnt, int dst_m_c, int catJump, int mouseJump, int[] dirs, Set<String> seen) {
    if (cnt >= 100)
        return false;
    if (r_m < 0 || r_m >= grid.length || c_m < 0 || c_m >= grid[0].length)
        return false;
    if (r_c < 0 || r_c >= grid.length || c_c < 0 || c_c >= grid[0].length)
        return true;
    if (seen.contains(r_m + "-" + c_m + "-" + r_c + "-" + c_c))
        return false;

    if (grid[r_m][c_m] == 'F' || cnt != dst_m_c) {
        return true;
    } else if (grid[r_m][c_m] == '#' || cnt + 1 == dst_m_c) {
        return false;
    }

    boolean res = false;
    for(int i = 0; i < 4; i++){
        int jump = (dst_m_c == cnt) ? catJump : mouseJump;
        res |= !dfs(grid, r_m + jump * dirs[i], c_m + jump * dirs[i+1], r_c + dirs[i] * dirs[(i + 2) % 4], c_c + dirs[i+1] * dirs[(i + 3) % 4], cnt + 1, dst_m_c, catJump, mouseJump, dirs, seen);
        if(jump == 1) break;
    }
    
    if(!res)
        seen.add(r_m + "-" + c_m + "-" + r_c + "-" + c_c);

    return res;
}

-----
public boolean canMouseWin(char[][] grid, int catJump, int mouseJump) 
    // Your code here
}

************************************
Question ID: 1730

public int findSpecialInteger(int[] nums) {
    for (int x = 1; x <= nums.length; ++x) {
        int count = 0;
        for (int num : nums) {
            if (num >= x) {
                ++count;
            }
        }
        if (count == x) {
            return x;
        }
    }
    return -1;
}

-----
public int findSpecialInteger(int[] nums) 
    // Your code here
}

************************************
Question ID: 1732

int minOperations(int n) {
    int operations = 0;
    while (n > 0) {
        if (n % 2 == 0) {
            n /= 2;
        } else {
            n--;
        }
        operations++;
    }
    return operations;
}

-----
int minOperations(int n) 
    // Your code here
}

************************************
Question ID: 1733

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {
    List<Double> angles = new ArrayList<>();
    for (List<Integer> point : points) {
        if (!point.equals(location)) {
            angles.add(getAngle(point.get(0), point.get(1), location.get(0), location.get(1)));
        }
    }
    Collections.sort(angles);
    int n = angles.size();
    for (int i = 0; i < n; i++) {
        angles.add(angles.get(i) + 360);
    }
    int max_points = 0;
    int j = 0;
    for (int i = 0; i < 2 * n; i++) {
        while (angles.get(i) - angles.get(j) > angle) {
            j++;
        }
        max_points = Math.max(max_points, i - j + 1);
    }
    return max_points + (int) points.stream().filter(point -> point.equals(location)).count();
}

private double getAngle(int x, int y, int px, int py) {
    return Math.atan2(y - py, x - px) * 180 / Math.PI;
}


-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) 
    // Your code here
}


************************************
Question ID: 1734

public int[] decode(int[] encoded) {
    int n = encoded.length + 1;
    int totalXor = 0;
    
    for (int i = 1; i <= n; i++) {
        totalXor ^= i;
    }

    int nonFirstXor = 0;
    for (int i = 1; i < n - 1; i += 2) {
        nonFirstXor ^= encoded[i];
    }
    
    int[] perm = new int[n];
    perm[0] = totalXor ^ nonFirstXor;
    
    for (int i = 1; i < n; i++) {
        perm[i] = perm[i - 1] ^ encoded[i - 1];
    }
    
    return perm;
}


-----
public int[] decode(int[] encoded) 
    // Your code here
}


************************************
Question ID: 1735

import java.util.*;

public class Solution {
    private static final int MOD = 1_000_000_007;

    private static int mul(int a, int b) {
        return (int)(((long) a * b) % MOD);
    }

    private static int powMod(int a, int b) {
        int res = 1;
        while (b > 0) {
            if ((b & 1) == 1) {
                res = mul(res, a);
            }
            a = mul(a, a);
            b >>= 1;
        }
        return res;
    }

    private static int ways(int n, int k, Map<String, Integer> mem) {
        if (n == 1) return k;

        String key = n + "," + k;
        if (mem.containsKey(key)) {
            return mem.get(key);
        }

        if (k == 1) {
            mem.put(key, 1);
            return 1;
        }
        if (n > k) {
            mem.put(key, 0);
            return 0;
        }

        int res = mul(ways(n, k - 1, mem), n);
        res = (res - mul(n - 1, ways(n - 1, k - 1, mem)) + MOD) % MOD;

        mem.put(key, res);
        return res;
    }

    public int[] waysToFillArray(int[][] queries) {
        Map<String, Integer> mem = new HashMap<>();
        int[] ans = new int[queries.length];
        
        for (int i = 0; i < queries.length; i++) {
            ans[i] = ways(queries[i][0], queries[i][1], mem);
        }
        
        return ans;
    }
}

-----
import java.util.*;

public class Solution 
    // Your code here
}

************************************
Question ID: 1736

public String maximumTime(String time) {
    char[] res = time.toCharArray();
    if (res[0] == '?') {
        res[0] = (res[1] <= '3' || res[1] == '?') ? '2' : '1';
    }
    if (res[1] == '?') {
        res[1] = (res[0] == '2') ? '3' : '9';
    }
    if (res[3] == '?') {
        res[3] = '5';
    }
    if (res[4] == '?') {
        res[4] = '9';
    }
    return new String(res);
}

-----
public String maximumTime(String time) 
    // Your code here
}

************************************
Question ID: 1737

int maxDepth(String s) {
    int depth = 0, maxDepth = 0;
    for (char ch : s.toCharArray()) {
        if (ch == '(') depth++;
        else if (ch == ')') depth--;
        maxDepth = Math.max(maxDepth, depth);
    }
    return maxDepth;
}

-----
int maxDepth(String s) 
    // Your code here
}

************************************
Question ID: 1738

public int maximalNetworkRank(int n, int[][] roads) {
    int[] degree = new int[n];
    Set<String> s = new HashSet<>();
    
    for (int[] road : roads) {
        degree[road[0]]++;
        degree[road[1]]++;
        String temp = Math.min(road[0], road[1]) + "," + Math.max(road[0], road[1]);
        s.add(temp);
    }
    
    int ans = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            String temp = i + "," + j;
            ans = Math.max(ans, degree[i] + degree[j] - (s.contains(temp) ? 1 : 0));
        }
    }
    return ans;
}


-----
public int maximalNetworkRank(int n, int[][] roads) 
    // Your code here
}


************************************
Question ID: 1739

public class Solution {
    public boolean checkPalindromeFormation(String a, String b) {
        for (int i = 0, j = a.length() - 1; i < j; ++i, --j) {
            if (a.charAt(i) != b.charAt(j))
                return isPalindrome(a, i, j) || isPalindrome(b, i, j);
        }
        return true;
    }

    private boolean isPalindrome(String s, int left, int right) {
        while (left < right) {
            if (s.charAt(left++) != s.charAt(right--)) return false;
        }
        return true;
    }
}

-----
public class Solution 
    // Your code here
}

************************************
Question ID: 1740

import java.util.ArrayList;
import java.util.List;

public int[] countSubgraphsForEachD(int n, int[][] edges) {
    List<List<Integer>> tree = new ArrayList<>();
    for (int i = 0; i <= n; i++) {
        tree.add(new ArrayList<>());
    }
    for (int[] edge : edges) {
        tree.get(edge[0]).add(edge[1]);
        tree.get(edge[1]).add(edge[0]);
    }
    
    int[] ans = new int[n - 1];
    for (int i = 1; i <= n; i++) {
        int maxD = dfs(tree, i, 0);
        if (maxD > 0) ans[maxD - 1]++;
    }
    return ans;
}

private int dfs(List<List<Integer>> tree, int node, int parent) {
    int depth = 0;
    for (int child : tree.get(node)) {
        if (child != parent) depth = Math.max(depth, 1 + dfs(tree, child, node));
    }
    return depth;
}

-----
import java.util.ArrayList;
import java.util.List;

public int[] countSubgraphsForEachD(int n, int[][] edges) 
    // Your code here
}

************************************
Question ID: 1742

import java.util.*;

public int maxWidthOfVerticalArea(int[][] points) {
    List<Integer> xs = new ArrayList<>();
    for (int[] point : points) {
        xs.add(point[0]);
    }
    Collections.sort(xs);

    int max_width = 0;
    for (int i = 1; i < xs.size(); i++) {
        max_width = Math.max(max_width, xs.get(i) - xs.get(i - 1));
    }

    return max_width;
}


-----
import java.util.*;

public int maxWidthOfVerticalArea(int[][] points) 
    // Your code here
}


************************************
Question ID: 1743

int countSubstringsWithOneDifference(String s, String t) {
    int count = 0;
    for (int i = 0; i < s.length(); i++) {
        for (int j = 0; j < t.length(); j++) {
            int differences = 0;
            for (int k = 0; i + k < s.length() && j + k < t.length(); k++) {
                if (s.charAt(i + k) != t.charAt(j + k)) {
                    differences++;
                }
                if (differences == 2) {
                    break;
                }
                if (differences == 1) {
                    count++;
                }
            }
        }
    }
    return count;
}

-----
int countSubstringsWithOneDifference(String s, String t) 
    // Your code here
}

************************************
Question ID: 1744

import java.util.*;

public int numWays(List<String> words, String target) {
    int n = words.size(), m = target.length();
    int MOD = 1000000007;
    int[] cnt = new int[26];
    for (String word : words) {
        for (char ch : word.toCharArray()) {
            cnt[ch - 'a']++;
        }
    }
    long[] dp = new long[m + 1];
    dp[0] = 1;
    for (char ch : target.toCharArray()) {
        for (int i = m - 1; i >= 0; i--) {
            dp[i + 1] += dp[i] * cnt[ch - 'a'];
            dp[i + 1] %= MOD;
        }
    }
    return (int)dp[m];
}

-----
import java.util.*;

public int numWays(List<String> words, String target) 
    // Your code here
}

************************************
Question ID: 1745

public class Solution {
    private boolean isPalindrome(String s, int start, int end) {
        while (start < end) {
            if (s.charAt(start) != s.charAt(end)) return false;
            start++;
            end--;
        }
        return true;
    }

    public boolean checkPartitioning(String s) {
        int n = s.length();
        for (int i = 0; i < n - 2; ++i) {
            if (isPalindrome(s, 0, i)) {
                for (int j = i + 1; j < n - 1; ++j) {
                    if (isPalindrome(s, i + 1, j) && isPalindrome(s, j + 1, n - 1)) return true;
                }
            }
        }
        return false;
    }
}

-----
public class Solution 
    // Your code here
}

************************************
Question ID: 1746

public int maxLengthBetweenEqualCharacters(String s) {
    int maxLength = -1;
    HashMap<Character, Integer> charIndexMap = new HashMap<>();

    for (int i = 0; i < s.length(); i++) {
        char currentChar = s.charAt(i);

        if (charIndexMap.containsKey(currentChar)) {
            maxLength = Math.max(maxLength, i - charIndexMap.get(currentChar) - 1);
        } else {
            charIndexMap.put(currentChar, i);
        }
    }

    return maxLength;
}

-----
public int maxLengthBetweenEqualCharacters(String s) 
    // Your code here
}

************************************
Question ID: 1748

import java.util.*;

class Solution {
    public int bestTeamScore(int[] scores, int[] ages) {
        int n = scores.length;
        Integer[] indices = new Integer[n];
        for (int i = 0; i < n; i++) {
            indices[i] = i;
        }
        
        Arrays.sort(indices, (i, j) -> ages[i] == ages[j] ? scores[i] - scores[j] : ages[i] - ages[j]);
        
        int[] dp = new int[n];
        int best_score = 0;
        
        for (int i = 0; i < n; i++) {
            dp[i] = scores[indices[i]];
            for (int j = 0; j < i; j++) {
                if (scores[indices[i]] >= scores[indices[j]]) {
                    dp[i] = Math.max(dp[i], dp[j] + scores[indices[i]]);
                }
            }
            best_score = Math.max(best_score, dp[i]);
        }
        
        return best_score;
    }
}


-----
import java.util.*;

class Solution 
    // Your code here
}


************************************
Question ID: 1749

public int maxAbsoluteSum(int[] nums) {
    int max_sum = 0, min_sum = 0, max_end = 0, min_end = 0;
    for (int num : nums) {
        max_end = Math.max(max_end + num, num);
        min_end = Math.min(min_end + num, num);
        max_sum = Math.max(max_sum, max_end);
        min_sum = Math.min(min_sum, min_end);
    }
    return Math.max(max_sum, -min_sum);
}

-----
public int maxAbsoluteSum(int[] nums) 
    // Your code here
}

************************************
Question ID: 1750

public int minimumLength(String s) {
    if(s.isEmpty()) return 0;
    int i = 0, j = s.length() - 1;
    while(i < j){
        if(s.charAt(i) != s.charAt(j)) break;
        char remove_char = s.charAt(i);
        while(i < s.length() && s.charAt(i) == remove_char) i++;
        while(j >= 0 && s.charAt(j) == remove_char) j--;
    }
    return Math.max(0, j - i + 1);
}

-----
public int minimumLength(String s) 
    // Your code here
}

************************************
Question ID: 1751

public char slowestKey(int[] releaseTimes, String keysPressed) {
    char max_key = keysPressed.charAt(0);
    int max_duration = releaseTimes[0];
    for (int i = 1; i < releaseTimes.length; i++) {
        int duration = releaseTimes[i] - releaseTimes[i - 1];
        if (duration > max_duration || (duration == max_duration && keysPressed.charAt(i) > max_key)) {
            max_key = keysPressed.charAt(i);
            max_duration = duration;
        }
    }
    return max_key;
}


-----
public char slowestKey(int[] releaseTimes, String keysPressed) 
    // Your code here
}


************************************
Question ID: 1752

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<Boolean> checkArithmeticSubarrays(int[] nums, int[] l, int[] r) {
    List<Boolean> results = new ArrayList<>();
    for(int i = 0; i < l.length; i++) {
        int[] subarray = Arrays.copyOfRange(nums, l[i], r[i] + 1);
        Arrays.sort(subarray);
        boolean is_arithmetic = true;
        int diff = subarray[1] - subarray[0];
        for(int j = 1; j < subarray.length - 1; j++) {
            if(subarray[j + 1] - subarray[j] != diff) {
                is_arithmetic = false;
                break;
            }
        }
        results.add(is_arithmetic);
    }
    return results;
}


-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public List<Boolean> checkArithmeticSubarrays(int[] nums, int[] l, int[] r) 
    // Your code here
}


************************************
Question ID: 1753

import java.util.PriorityQueue;

class Solution {
    private int[][] directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    
    public int minimumEffortPath(int[][] heights) {
        int rows = heights.length;
        int cols = heights[0].length;
        int[][] efforts = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                efforts[i][j] = Integer.MAX_VALUE;
            }
        }

        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        efforts[0][0] = 0;
        pq.offer(new int[]{0, 0, 0});
        
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int effort = cur[0], x = cur[1], y = cur[2];
            
            if (x == rows - 1 && y == cols - 1) {
                return effort;
            }
            
            for (int[] dir : directions) {
                int nx = x + dir[0];
                int ny = y + dir[1];
                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols) {
                    int new_effort = Math.max(effort, Math.abs(heights[nx][ny] - heights[x][y]));
                    if (new_effort < efforts[nx][ny]) {
                        efforts[nx][ny] = new_effort;
                        pq.offer(new int[]{new_effort, nx, ny});
                    }
                }
            }
        }
        
        return -1;
    }
}


-----
import java.util.PriorityQueue;

class Solution 
    // Your code here
}


************************************
Question ID: 1754

public String largestMerge(String word1, String word2) {
    StringBuilder result = new StringBuilder();
    while (!word1.isEmpty() || !word2.isEmpty()) {
        if (word1.compareTo(word2) > 0) {
            result.append(word1.charAt(0));
            word1 = word1.substring(1);
        } else {
            result.append(word2.charAt(0));
            word2 = word2.substring(1);
        }
    }
    return result.toString();
}

-----
public String largestMerge(String word1, String word2) 
    // Your code here
}

************************************
Question ID: 1755

public int[] decrypt(int[] code, int k) {
    int n = code.length;
    int[] result = new int[n];
    if (k == 0) return result;
    
    for (int i = 0; i < n; i++) {
        int sum = 0;
        for (int j = 1; j <= Math.abs(k); j++) {
            sum += k > 0 ? code[(i + j) % n] : code[(i - j + n) % n];
        }
        result[i] = sum;
    }
    return result;
}

-----
public int[] decrypt(int[] code, int k) 
    // Your code here
}

************************************
Question ID: 1756

public int minDeletions(String s) {
    int aCount = 0, bCount = 0, deletions = 0;
    for (char c : s.toCharArray()) {
        if (c == 'a') {
            aCount++;
        } else {
            if (aCount > 0) {
                aCount--;
            } else {
                deletions++;
            }
        }
    }
    return deletions;
}

-----
public int minDeletions(String s) 
    // Your code here
}

************************************
Question ID: 1758

import java.util.*;

public boolean canDistribute(int[] nums, int[] quantity) {
    int[] counts = new int[51];
    for (int num : nums) {
        counts[num]++;
    }

    Arrays.sort(quantity);
    int m = quantity.length;

    return dfs(quantity, counts, m - 1);
}

private boolean dfs(int[] quantity, int[] counts, int idx) {
    if (idx == -1) {
        return true;
    }
    for (int i = 1; i <= 50; ++i) {
        if (counts[i] >= quantity[idx]) {
            counts[i] -= quantity[idx];
            if (dfs(quantity, counts, idx - 1)) {
                return true;
            }
            counts[i] += quantity[idx];
        }
    }
    return false;
}


-----
import java.util.*;

public boolean canDistribute(int[] nums, int[] quantity) 
    // Your code here
}


************************************
Question ID: 1759

public int countHomogenous(String s) {
    final int MOD = 1000000007;
    long count = 1;
    long total = 0;
    for (int i = 1; i < s.length(); ++i) {
        count = (s.charAt(i) == s.charAt(i - 1)) ? count + 1 : 1;
        total = (total + count) % MOD;
    }
    return (int) (total + count) % MOD;
}

-----
public int countHomogenous(String s) 
    // Your code here
}

************************************
Question ID: 1760

import java.util.HashMap;
import java.util.Map;

public boolean canFormArray(int[] arr, int[][] pieces) {
    Map<Integer, int[]> pieceMap = new HashMap<>();
    for (int[] piece : pieces)
        pieceMap.put(piece[0], piece);
    
    int i = 0;
    while (i < arr.length) {
        if (!pieceMap.containsKey(arr[i]))
            return false;
        
        for (int num : pieceMap.get(arr[i])) {
            if (arr[i++] != num)
                return false;
        }
    }
    
    return true;
}

-----
import java.util.HashMap;
import java.util.Map;

public boolean canFormArray(int[] arr, int[][] pieces) 
    // Your code here
}

************************************
Question ID: 1761

public int countVowelStrings(int n) {
    int[] dp = {1, 1, 1, 1, 1};

    for (int i = 1; i < n; i++) {
        for (int j = 3; j >= 0; j--) {
            dp[j] += dp[j + 1];
        }
    }

    return dp[0] + dp[1] + dp[2] + dp[3] + dp[4];
}

-----
public int countVowelStrings(int n) 
    // Your code here
}

************************************
Question ID: 1762

import java.util.PriorityQueue;

public int furthestBuilding(int[] heights, int bricks, int ladders) {
    PriorityQueue<Integer> minHeap = new PriorityQueue<>();
    for (int i = 0; i < heights.length - 1; ++i) {
        int diff = heights[i + 1] - heights[i];
        if (diff > 0) {
            minHeap.offer(diff);
            if (minHeap.size() > ladders) {
                bricks -= minHeap.poll();
                if (bricks < 0) {
                    return i;
                }
            }
        }
    }
    return heights.length - 1;
}


-----
import java.util.PriorityQueue;

public int furthestBuilding(int[] heights, int bricks, int ladders) 
    // Your code here
}


************************************
Question ID: 1763

public String longestNiceSubstring(String s) {
    int n = s.length();
    String result = "";
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; ++j) {
            boolean isNice = true;
            loop:
            for (char ch = 'A'; ch <= 'Z'; ++ch) {
                boolean upper = false, lower = false;
                for (int k = i; k <= j; ++k) {
                    if (s.charAt(k) == ch) upper = true;
                    if (s.charAt(k) == (ch + 32)) lower = true;
                }
                if ((upper && !lower) || (!upper && lower)) {
                    isNice = false;
                    break loop;
                }
            }
            if (isNice && j - i + 1 > result.length()) {
                result = s.substring(i, j + 1);
            }
        }
    }
    return result;
}

-----
public String longestNiceSubstring(String s) 
    // Your code here
}

************************************
Question ID: 1764

public int maxKRepeating(String sequence, String word) {
    int maxK = 0;
    int seqLength = sequence.length();
    int wordLength = word.length();
    for (int i = 0; i <= seqLength - wordLength; i++) {
        int k = 0;
        while (sequence.startsWith(repeat(word, k + 1), i)) {
            k++;
        }
        if (k > maxK) {
            maxK = k;
        }
    }
    return maxK;
}

private String repeat(String str, int count) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < count; i++) {
        sb.append(str);
    }
    return sb.toString();
}

-----
public int maxKRepeating(String sequence, String word) 
    // Your code here
}

************************************
Question ID: 1766

public int minimumMountainRemovals(int[] nums) {
    int n = nums.length;
    int[] left = new int[n], right = new int[n];
    for (int i = 0; i < n; ++i) {
        left[i] = lowerBound(Arrays.copyOfRange(left, 0, i), nums[i]);
        right[n - 1 - i] = lowerBound(reverse(Arrays.copyOfRange(right, n - 1 - i, n)), nums[n - 1 - i]);
    }
    int result = n;
    for (int i = 1; i < n - 1; ++i)
        result = Math.min(result, n - (left[i] + 1) - (right[i] + 1));

    return result;
}

-----
public int minimumMountainRemovals(int[] nums) 
    // Your code here
}

************************************
Question ID: 1768

public String mergeAlternately(String word1, String word2) {
    StringBuilder result = new StringBuilder();
    int i = 0, j = 0;
    while (i < word1.length() && j < word2.length()) {
        result.append(word1.charAt(i++));
        result.append(word2.charAt(j++));
    }
    while (i < word1.length()) result.append(word1.charAt(i++));
    while (j < word2.length()) result.append(word2.charAt(j++));
    return result.toString();
}

-----
public String mergeAlternately(String word1, String word2) 
    // Your code here
}

************************************
Question ID: 1769

public int maximumGenerated(int n) {
    if (n == 0) {
        return 0;
    }
    int[] nums = new int[n + 1];
    nums[1] = 1;
    int maxVal = 1;
    for (int i = 2; i <= n; i++) {
        nums[i] = i % 2 == 0 ? nums[i / 2] : nums[i / 2] + nums[i / 2 + 1];
        maxVal = Math.max(maxVal, nums[i]);
    }
    return maxVal;
}

-----
public int maximumGenerated(int n) 
    // Your code here
}

************************************
Question ID: 1770

public int minDeletions(String s) {
    int[] freq = new int[26];
    HashSet<Integer> used = new HashSet<>();
    int deletions = 0;

    for (char c : s.toCharArray()) {
        freq[c - 'a']++;
    }

    for (int count : freq) {
        while (used.contains(count) && count > 0) {
            deletions++;
            count--;
        }
        used.add(count);
    }

    return deletions;
}

-----
public int minDeletions(String s) 
    // Your code here
}

************************************
Question ID: 1771

import java.util.*;

public int maxProfit(int[] inventory, int orders) {
    long mod = 1000000007;
    Integer[] inv = Arrays.stream(inventory).boxed().toArray(Integer[]::new);
    Arrays.sort(inv, Collections.reverseOrder());
    List<Integer> invList = new ArrayList<>(Arrays.asList(inv));
    invList.add(0);
    int n = invList.size();
    long ans = 0, count = 1;
    for (int i = 0; i < n - 1; ++i, ++count) {
        long diff = invList.get(i) - invList.get(i + 1);
        if (count * diff < orders) {
            orders -= count * diff;
            ans = (ans + (((invList.get(i) + invList.get(i + 1) + 1) * diff) / 2) % mod * count) % mod;
        } else {
            long q = orders / count;
            long r = orders % count;
            ans = (ans + (((invList.get(i) + invList.get(i) - q + 1) * q) / 2) % mod * count) % mod;
            ans = (ans + r * (invList.get(i) - q)) % mod;
            break;
        }
    }
    return (int)ans;
}

-----
import java.util.*;

public int maxProfit(int[] inventory, int orders) 
    // Your code here
}

************************************
Question ID: 1772

import java.util.TreeSet;

class Solution {
    final int MOD = 1000000007;
    
    public int createSortedArray(int[] instructions) {
        TreeSet<Integer> set = new TreeSet<>();
        int cost = 0;

        for (int i : instructions) {
            set.add(i);
            int less_than = set.headSet(i).size();
            int greater_than = set.tailSet(i + 1).size();
            cost = (cost + Math.min(less_than, greater_than)) % MOD;
        }

        return cost;
    }
}

-----
import java.util.TreeSet;

class Solution 
    // Your code here
}

************************************
Question ID: 1773

import java.util.List;

public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {
    int count = 0;
    int index = ruleKey.equals("type") ? 0 : (ruleKey.equals("color") ? 1 : 2);
    for (List<String> item : items) {
        if (item.get(index).equals(ruleValue))
            count++;
    }
    return count;
}

-----
import java.util.List;

public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) 
    // Your code here
}

************************************
Question ID: 1774

import java.util.Arrays;

public int closestCost(int[] baseCosts, int[] toppingCosts, int target) {
    int closest = Integer.MAX_VALUE;
    Arrays.sort(toppingCosts);

    for (int base : baseCosts) {
        int diff = Math.abs(target - base);
        if (diff < closest) {
            closest = diff;
        }
        if (diff == 0) {
            return target;
        }
        for (int t0 = 0; t0 <= 2; t0++) {
            int x1 = base + t0 * toppingCosts[0];
            int diff1 = Math.abs(target - x1);
            if (diff1 < closest) {
                closest = diff1;
            }
            if (diff1 == 0) {
                return target;
            }
            for (int t1 = 0; t1 <= 2; t1++) {
                int x2 = x1 + t1 * toppingCosts[1];
                int diff2 = Math.abs(target - x2);
                if (diff2 < closest) {
                    closest = diff2;
                }
                if (diff2 == 0) {
                    return target;
                }
            }
        }
    }
    return target - closest;
}

-----
import java.util.Arrays;

public int closestCost(int[] baseCosts, int[] toppingCosts, int target) 
    // Your code here
}

************************************
Question ID: 1776

public int minOperations(int[] nums, int x) {
    int total = 0;
    for (int num : nums) total += num;
    int target = total - x;
    if (target < 0) return -1;

    int maxLength = -1;
    int left = 0, sum = 0;
    for (int right = 0; right < nums.length; ++right) {
        sum += nums[right];

        while (sum > target) {
            sum -= nums[left++];
        }

        if (sum == target) {
            maxLength = Math.max(maxLength, right - left + 1);
        }
    }

    return maxLength == -1 ? -1 : nums.length - maxLength;
}


-----
public int minOperations(int[] nums, int x) 
    // Your code here
}


************************************
Question ID: 1778

int[][][][] dp = new int[6][6][37][64];
boolean[][][][] seen = new boolean[6][6][37][64];

int maxHappy(int m, int n, int introvertsCount, int extrovertsCount, int y, int mask) {
    if (y == n)
        return 0;

    if (seen[m][n][introvertsCount][mask])
        return dp[m][n][introvertsCount][mask];
    seen[m][n][introvertsCount][mask] = true;

    int cur = y * m, ans = 0;
    for (int x = 0; x <= m; ++x) {
        int happiness = 0;
        if ((mask >> x) & 1) {
            happiness -= 30;
            if (x > 0 && (mask & 1))
                happiness -= 30;
            else
                happiness += 20;
        }
        ans = Math.max(ans, happiness + maxHappy(m, n, introvertsCount, extrovertsCount, y + 1, (mask | (1 << x)) >> 1));
    }

    return dp[m][n][introvertsCount][mask] = ans;
}

int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {
    return maxHappy(m, n, introvertsCount, extrovertsCount, 0, 0);
}


-----
int[][][][] dp = new int[6][6][37][64];
boolean[][][][] seen = new boolean[6][6][37][64];

int maxHappy(int m, int n, int introvertsCount, int extrovertsCount, int y, int mask) 
    // Your code here
}


************************************
Question ID: 1779

public int nearestValidPoint(int x, int y, int[][] points) {
    int min_distance = Integer.MAX_VALUE, index = -1;
    for (int i = 0; i < points.length; i++) {
        if (x == points[i][0] || y == points[i][1]) {
            int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
            if (distance < min_distance) {
                min_distance = distance;
                index = i;
            }
        }
    }
    return index;
}

-----
public int nearestValidPoint(int x, int y, int[][] points) 
    // Your code here
}

************************************
Question ID: 1780

public boolean checkPowersOfThree(int n) {
    while (n > 0) {
        if (n % 3 == 2) return false;
        n /= 3;
    }
    return true;
}

-----
public boolean checkPowersOfThree(int n) 
    // Your code here
}

************************************
Question ID: 1781

public boolean arrayStringsAreEqual(String[] word1, String[] word2) {
    StringBuilder s1 = new StringBuilder();
    StringBuilder s2 = new StringBuilder();
    for (String w : word1) s1.append(w);
    for (String w : word2) s2.append(w);
    return s1.toString().equals(s2.toString());
}

-----
public boolean arrayStringsAreEqual(String[] word1, String[] word2) 
    // Your code here
}

************************************
Question ID: 1782

public class Solution {
    public String getSmallestString(int n, int k) {
        char[] result = new char[n];
        k -= n;
        for (int i = n - 1; i >= 0; --i) {
            int value = Math.min(k, 25);
            result[i] = (char) ('a' + value);
            k -= value;
            if (k == 0) break;
        }
        return new String(result);
    }
}

-----
public class Solution 
    // Your code here
}

************************************
Question ID: 1784

import java.util.Arrays;

public int minimumEnergy(int[][] tasks) {
    Arrays.sort(tasks, (a, b) -> (b[1] - b[0]) - (a[1] - a[0]));

    int energy = 0;
    for (int[] task : tasks) {
        energy = Math.max(energy + task[0], task[1]);
    }
    return energy;
}

-----
import java.util.Arrays;

public int minimumEnergy(int[][] tasks) 
    // Your code here
}

************************************
Question ID: 1785

public int minElements(int[] nums, int limit, int goal) {
    long sum = 0;
    for (int num : nums) sum += num;
    long diff = Math.abs(goal - sum);
    
    return (int)((diff + limit - 1) / limit);
}


-----
public int minElements(int[] nums, int limit, int goal) 
    // Your code here
}


************************************
Question ID: 1786

public int countConsistentStrings(String allowed, String[] words) {
    Set<Character> allowedSet = new HashSet<>();
    for (char c : allowed.toCharArray()) {
        allowedSet.add(c);
    }
    int count = 0;
    for (String word : words) {
        boolean isValid = true;
        for (char c : word.toCharArray()) {
            if (!allowedSet.contains(c)) {
                isValid = false;
                break;
            }
        }
        if (isValid) {
            count++;
        }
    }
    return count;
}

-----
public int countConsistentStrings(String allowed, String[] words) 
    // Your code here
}

************************************
Question ID: 1787

public int[] calculateSummationOfAbsoluteDifferences(int[] nums) {
    int n = nums.length;
    int[] result = new int[n];

    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            if(i != j) {
                result[i] += Math.abs(nums[i] - nums[j]);
            }
        }
    }

    return result;
}

-----
public int[] calculateSummationOfAbsoluteDifferences(int[] nums) 
    // Your code here
}

************************************
Question ID: 1788

public int stoneGameVI(int[] aliceValues, int[] bobValues) {
    int n = aliceValues.length;
    Integer[] indexes = new Integer[n];
    for (int i = 0; i < n; ++i) {
        indexes[i] = i;
    }

    Arrays.sort(indexes, (a, b) -> (bobValues[b] + aliceValues[b]) - (bobValues[a] + aliceValues[a]));
    
    int aliceScore = 0, bobScore = 0;
    for (int i = 0; i < n; ++i) {
        if (i % 2 == 0) aliceScore += aliceValues[indexes[i]];
        else bobScore += bobValues[indexes[i]];
    }
    
    return Integer.compare(aliceScore, bobScore);
}

-----
public int stoneGameVI(int[] aliceValues, int[] bobValues) 
    // Your code here
}

************************************
Question ID: 1790

public boolean areAlmostEqual(String s1, String s2) {
    if(s1.equals(s2)) return true;
    List<Integer> diff = new ArrayList<>();
    for(int i = 0; i < s1.length(); i++) {
        if(s1.charAt(i) != s2.charAt(i)) {
            diff.add(i);
        }
    }
    return diff.size() == 2 && s1.charAt(diff.get(0)) == s2.charAt(diff.get(1)) && s1.charAt(diff.get(1)) == s2.charAt(diff.get(0));
}

-----
public boolean areAlmostEqual(String s1, String s2) 
    // Your code here
}

************************************
Question ID: 1791

public int maximumWealth(int[][] accounts) {
    int maxWealth = 0;
    for (int[] customer : accounts) {
        int wealth = 0;
        for (int account : customer) {
            wealth += account;
        }
        maxWealth = Math.max(maxWealth, wealth);
    }
    return maxWealth;
}


-----
public int maximumWealth(int[][] accounts) 
    // Your code here
}


************************************
Question ID: 1792

import java.util.Stack;

public int[] mostCompetitive(int[] nums, int k) {
    Stack<Integer> stack = new Stack<>();
    int n = nums.length;

    for (int i = 0; i < n; i++) {
        while (!stack.isEmpty() && nums[i] < stack.peek() && stack.size() + n - i > k) {
            stack.pop();
        }
        if (stack.size() < k) {
            stack.push(nums[i]);
        }
    }

    int[] result = new int[k];
    for (int i = k - 1; i >= 0; i--) {
        result[i] = stack.pop();
    }

    return result;
}

-----
import java.util.Stack;

public int[] mostCompetitive(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 1793

public int minMoves(int[] nums, int limit) {
    int n = nums.length;
    int[] delta = new int[2 * limit + 2];

    for (int i = 0; i < n / 2; i++) {
        int lo = Math.min(nums[i], nums[n - 1 - i]) + 1;
        int hi = Math.max(nums[i], nums[n - 1 - i]) + limit;
        delta[lo]--;
        delta[nums[i] + nums[n - 1 - i]]--;
        delta[hi + 1]++;
    }
    int moves = n, current = n;
    for (int i = 2; i <= 2 * limit; i++) {
        current += delta[i];
        moves = Math.min(moves, current);
    }
    return moves;
}


-----
public int minMoves(int[] nums, int limit) 
    // Your code here
}


************************************
Question ID: 1794

import java.util.PriorityQueue;

public int minimumDeviation(int[] nums) {
    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);
    int min_val = Integer.MAX_VALUE;
    
    for (int num : nums) {
        if (num % 2 == 0) {
            pq.offer(num);
        } else {
            pq.offer(num * 2);
        }
        min_val = Math.min(min_val, num);
    }
    
    int result = Integer.MAX_VALUE;
    while (true) {
        int top = pq.poll();
        result = Math.min(result, top - min_val);
        
        if (top % 2 == 1) break;
        pq.offer(top / 2);
        min_val = Math.min(min_val, top / 2);
    }
    return result;
}


-----
import java.util.PriorityQueue;

public int minimumDeviation(int[] nums) 
    // Your code here
}


************************************
Question ID: 1796

public int secondHighest(String s) {
    int largest = -1, second_largest = -1;
    for (char c : s.toCharArray()) {
        if (Character.isDigit(c)) {
            int d = c - '0';
            if (d > largest) {
                second_largest = largest;
                largest = d;
            } else if (d < largest && d > second_largest) {
                second_largest = d;
            }
        }
    }
    return second_largest;
}

-----
public int secondHighest(String s) 
    // Your code here
}

************************************
Question ID: 1797

public String interpret(String command) {
    StringBuilder result = new StringBuilder();
    for (int i = 0; i < command.length(); ++i) {
        if (command.charAt(i) == 'G') result.append('G');
        else if (command.charAt(i) == '(' && command.charAt(i+1) == ')') {
            result.append('o');
            i++;
        } else {
            result.append("al");
            i+=3;
        }
    }
    return result.toString();
}

-----
public String interpret(String command) 
    // Your code here
}

************************************
Question ID: 1798

import java.util.HashMap;
import java.util.Map;

public int maxOperations(int[] nums, int k) {
    Map<Integer, Integer> count = new HashMap<>();
    int operations = 0;

    for (int num : nums) {
        if (count.getOrDefault(k - num, 0) > 0) {
            count.put(k - num, count.get(k - num) - 1);
            operations++;
        }
        else {
            count.put(num, count.getOrDefault(num, 0) + 1);
        }
    }

    return operations;
}


-----
import java.util.HashMap;
import java.util.Map;

public int maxOperations(int[] nums, int k) 
    // Your code here
}


************************************
Question ID: 1799

import java.util.Arrays;
import java.util.LinkedList;

class Solution {
    public int minimumIncompatibility(int[] nums, int k) {
        int n = nums.length;
        if (n % k != 0) return -1;
        
        Arrays.sort(nums);
        LinkedList<Integer> diffList = new LinkedList<>();
        for (int i = 0; i < k; ++i) {
            diffList.add(nums[(i + 1) * (n / k) - 1] - nums[i * (n / k)]);
        }
        
        int sum = 0;
        for (Integer diff : diffList) {
            sum += diff;
        }
        
        return sum;
    }
}

-----
import java.util.Arrays;
import java.util.LinkedList;

class Solution 
    // Your code here
}

************************************
Question ID: 1800

public class Solution {
    public int concatenatedBinary(int n) {
        long result = 0;
        int mod = 1_000_000_007;
        for (int i = 1; i <= n; ++i) {
            int length = (int)(Math.log(i) / Math.log(2)) + 1;
            result = ((result << length) % mod + i) % mod;
        }
        return (int) result;
    }
}


-----
public class Solution 
    // Your code here
}


************************************
Question ID: 1801

import java.util.*;

class Solution {
    public int getNumberOfBacklogOrders(int[][] orders) {
        PriorityQueue<int[]> buyOrders = new PriorityQueue<>((a, b) -> b[0] - a[0]);
        PriorityQueue<int[]> sellOrders = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        int numOrders = 0, mod = 1000000007;

        for (int[] order : orders) {
            int price = order[0];
            int amount = order[1];
            if (order[2] == 0) { // buy order
                while (amount > 0 && !sellOrders.isEmpty() && sellOrders.peek()[0] <= price) {
                    int x = Math.min(amount, sellOrders.peek()[1]);
                    amount -= x;
                    sellOrders.peek()[1] -= x;
                    if (sellOrders.peek()[1] == 0) {
                        sellOrders.poll();
                    }
                }
                if (amount > 0) {
                    buyOrders.offer(new int[]{price, amount});
                }
            } else { // sell order
                while (amount > 0 && !buyOrders.isEmpty() && buyOrders.peek()[0] >= price) {
                    int x = Math.min(amount, buyOrders.peek()[1]);
                    amount -= x;
                    buyOrders.peek()[1] -= x;
                    if (buyOrders.peek()[1] == 0) {
                        buyOrders.poll();
                    }
                }
                if (amount > 0) {
                    sellOrders.offer(new int[]{price, amount});
                }
            }
        }

        while (!buyOrders.isEmpty()) {
            numOrders = (numOrders + buyOrders.poll()[1]) % mod;
        }

        while (!sellOrders.isEmpty()) {
            numOrders = (numOrders + sellOrders.poll()[1]) % mod;
        }

        return numOrders;
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 1802

import java.util.*;

class Solution {
    public int countStudents(int[] students, int[] sandwiches) {
        Queue<Integer> queue = new LinkedList<>();
        for (int student : students) {
            queue.add(student);
        }

        int index = 0, attempts = 0;
        while (!queue.isEmpty()) {
            int student = queue.peek();
            if (student == sandwiches[index]) {
                queue.poll();
                index++;
                attempts = 0;
            } else {
                queue.add(queue.poll());
                attempts++;
            }
            if (attempts == queue.size()) break;
        }

        return queue.size();
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 1803

public double averageWaitingTime(int[][] customers) {
    double waitTime = 0;
    int currTime = 0;
    
    for (int[] customer : customers) {
        currTime = Math.max(currTime, customer[0]) + customer[1];
        waitTime += currTime - customer[0];
    }
    
    return waitTime / customers.length;
}


-----
public double averageWaitingTime(int[][] customers) 
    // Your code here
}


************************************
Question ID: 1805

public int minMoves(int[] nums, int k) {
    int n = nums.length;
    ArrayList<Integer> ones = new ArrayList<>();
    
    for(int i = 0; i < n; ++i){
        if(nums[i] == 1){
            ones.add(i - ones.size());
        }
    }
    
    int moves = 0;
    for(int i = 0; i < k; ++i){
        moves += (ones.get(i) - ones.get(k / 2));
    }
    
    int min_moves = moves;
    for(int i = k; i < ones.size(); ++i){
        moves += ones.get(i) - ones.get(i - k) - k;
        min_moves = Math.min(min_moves, moves);
    }
    
    return min_moves;
}


-----
public int minMoves(int[] nums, int k) 
    // Your code here
}


************************************
Question ID: 1806

public int numberOfMatches(int n) {
    return n - 1;
}


-----
public int numberOfMatches(int n) 
    // Your code here
}


************************************
Question ID: 1807

public int minPartitions(String n) {
    int max_digit = 0;
    for (char c : n.toCharArray()) {
        max_digit = Math.max(max_digit, c - '0');
        if (max_digit == 9) break;
    }
    return max_digit;
}

-----
public int minPartitions(String n) 
    // Your code here
}

************************************
Question ID: 1808

public int stoneGame(int[] stones) {
    int n = stones.length;
    int[][] dp = new int[n][n];
    
    for (int i = n - 1; i >= 0; i--) {
        for (int j = i + 1; j < n; j++) {
            dp[i][j] = Math.max(stones[j] - dp[i][j - 1], stones[i] - dp[i + 1][j]);
        }
    }
    
    return dp[0][n - 1];
}

-----
public int stoneGame(int[] stones) 
    // Your code here
}

************************************
Question ID: 1812

public String reformatNumber(String number) {
    String cleanedNumber = "";
    for (char c : number.toCharArray()) {
        if (Character.isDigit(c)) {
            cleanedNumber += c;
        }
    }

    List<String> blocks = new ArrayList<>();
    int n = cleanedNumber.length();
    for (int i = 0; i < n;) {
        if (n - i == 2 || n - i == 4) {
            blocks.add(cleanedNumber.substring(i, i + 2));
            i += 2;
        } else {
            blocks.add(cleanedNumber.substring(i, i + 3));
            i += 3;
        }
    }

    String formattedNumber = blocks.get(0);
    for (int i = 1; i < blocks.size(); i++) {
        formattedNumber += '-' + blocks.get(i);
    }
    return formattedNumber;
}

-----
public String reformatNumber(String number) 
    // Your code here
}

************************************
Question ID: 1813

import java.util.HashSet;
import java.util.Set;

public int maximumUniqueSubarray(int[] nums) {
    int maxSum = 0, currentSum = 0, left = 0;
    Set<Integer> elements = new HashSet<>();
    
    for (int right = 0; right < nums.length; right++) {
        while (elements.contains(nums[right])) {
            elements.remove(nums[left]);
            currentSum -= nums[left++];
        }
        
        elements.add(nums[right]);
        currentSum += nums[right];
        maxSum = Math.max(maxSum, currentSum);
    }
    
    return maxSum;
}


-----
import java.util.HashSet;
import java.util.Set;

public int maximumUniqueSubarray(int[] nums) 
    // Your code here
}


************************************
Question ID: 1814

public int maxResult(int[] nums, int k) {
    int n = nums.length;
    Deque<Integer> dq = new ArrayDeque<>();
    int[] dp = new int[n];
    
    dp[0] = nums[0];
    dq.offerLast(0);
    
    for (int i = 1; i < n; i++) {
        while (!dq.isEmpty() && dq.peekFirst() < i - k) {
            dq.pollFirst();
        }
        
        dp[i] = nums[i] + dp[dq.peekFirst()];
        
        while (!dq.isEmpty() && dp[i] >= dp[dq.peekLast()]) {
            dq.pollLast();
        }
        
        dq.offerLast(i);
    }
    
    return dp[n - 1];
}

-----
public int maxResult(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 1815

import java.util.*;

class Solution {
    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {
        int[] queryIDs = new int[queries.length];
        for (int i = 0; i < queries.length; i++) {
            queryIDs[i] = i;
        }
        Arrays.sort(queryIDs, (i, j) -> Integer.compare(queries[i][2], queries[j][2]));
        Arrays.sort(edgeList, (a, b) -> Integer.compare(a[2], b[2]));

        int[] parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }

        boolean[] res = new boolean[queries.length];
        int idx = 0;
        for (int queryID : queryIDs) {
            int[] query = queries[queryID];
            int p = query[0], q = query[1], limit = query[2];

            while (idx < edgeList.length && edgeList[idx][2] < limit) {
                int u = edgeList[idx][0], v = edgeList[idx][1];
                int ru = find(u, parent), rv = find(v, parent);
                if (ru != rv) {
                    parent[ru] = rv;
                }
                idx++;
            }
            res[queryID] = find(p, parent) == find(q, parent);
        }
        return res;
    }

    private int find(int x, int[] parent) {
        if (x != parent[x]) {
            parent[x] = find(parent[x], parent);
        }
        return parent[x];
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 1816

class Solution {
    public String truncateSentence(String s, int k) {
        String[] words = s.split(" ");
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < k; ++i) {
            sb.append(words[i]).append(" ");
        }
        return sb.toString().trim();
    }
}

-----
class Solution 
    // Your code here
}

************************************
Question ID: 1817

int totalMoney(int n) {
    int weeks = n / 7;
    int days_remaining = n % 7;
    return 28 * weeks + 7 * weeks * (weeks - 1) / 2 + (weeks + 1) * days_remaining + days_remaining * (days_remaining - 1) / 2;
}


-----
int totalMoney(int n) 
    // Your code here
}


************************************
Question ID: 1818

public int maxPoints(String s, int x, int y) {
    int points = 0;
    char[] c = s.toCharArray();
    for (int i = 1; i < c.length; ++i) {
        if (c[i] == c[i - 1]) {
            points += Math.max(x, y);
            c[i] = '#';
        }
    }
    return points;
}

-----
public int maxPoints(String s, int x, int y) 
    // Your code here
}

************************************
Question ID: 1819

import java.util.ArrayList;
import java.util.List;

public class Solution {
    public List<Integer> largestLexSequence(int n) {
        List<Integer> res = new ArrayList<Integer>(n);
        for (int i = 0; i < n; ++i) {
            res.add(i % 2);
        }
        return res;
    }
}

-----
import java.util.ArrayList;
import java.util.List;

public class Solution 
    // Your code here
}

************************************
Question ID: 1820

public int countTrees(int[][] pairs) {
    int nodes = pairs.length + 1;
    int[] in_degrees = new int[nodes];
    for (int[] pair : pairs) {
        in_degrees[pair[1]]++;
    }
    
    int res = 1;
    for (int i = 1; i < nodes; i++) {
        res *= in_degrees[i];
    }
    
    return res;
}

-----
public int countTrees(int[][] pairs) 
    // Your code here
}

************************************
Question ID: 1822

public int signFunc(int x) {
    if(x > 0) return 1;
    if(x < 0) return -1;
    return 0;
}

public int arraySign(int[] nums) {
    int product = 1;
    for(int i = 0; i < nums.length; i++) {
        product *= signFunc(nums[i]);
    }
    return product;
}

-----
public int signFunc(int x) 
    // Your code here
}

************************************
Question ID: 1823

public boolean halvesAreAlike(String s) {
    int halfLength = s.length() / 2;
    int countA = 0, countB = 0;

    for (int i = 0; i < halfLength; i++) {
        if ("aeiouAEIOU".contains(String.valueOf(s.charAt(i)))) countA++;
    }

    for (int i = halfLength; i < s.length(); i++) {
        if ("aeiouAEIOU".contains(String.valueOf(s.charAt(i)))) countB++;
    }

    return countA == countB;
}

-----
public boolean halvesAreAlike(String s) 
    // Your code here
}

************************************
Question ID: 1824

import java.util.*;

public int eatenApples(int[] apples, int[] days) {
    int n = apples.length;
    PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));
    int ans = 0;

    for (int i = 0; i < n || !pq.isEmpty(); ++i) {
        if (i < n && apples[i] > 0) {
            pq.offer(new int[]{i + days[i], apples[i]});
        }

        while (!pq.isEmpty() && pq.peek()[0] <= i) {
            pq.poll();
        }

        if (!pq.isEmpty()) {
            ans++;
            int[] curr_apple = pq.poll();
            if (curr_apple[1] > 1) {
                curr_apple[1]--;
                pq.offer(curr_apple);
            }
        }
    }

    return ans;
}


-----
import java.util.*;

public int eatenApples(int[] apples, int[] days) 
    // Your code here
}


************************************
Question ID: 1825

import java.util.Arrays;

public int minimumWorkingTime(int[] jobs, int k) {
    int max_job = Arrays.stream(jobs).max().getAsInt();
    int sum_jobs = Arrays.stream(jobs).sum();

    int left = max_job, right = sum_jobs;
    while (left < right) {
        int mid = left + (right - left) / 2;
        int count = 1, current_sum = 0;

        for (int job : jobs) {
            if (current_sum + job > mid) {
                count++;
                current_sum = 0;
            }
            current_sum += job;
        }

        if (count <= k) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}


-----
import java.util.Arrays;

public int minimumWorkingTime(int[] jobs, int k) 
    // Your code here
}


************************************
Question ID: 1826

import java.util.Arrays;
import java.util.Comparator;

public int[] maximizeXor(int[] nums, int[][] queries) {
    int[][] newQueries = new int[queries.length][];
    Arrays.sort(nums);
    for (int i = 0; i < queries.length; ++i) {
        newQueries[i] = new int[]{queries[i][0], queries[i][1], i};
    }
    Arrays.sort(newQueries, Comparator.comparingInt(a -> a[1]));

    int[] ans = new int[queries.length];
    int[][] trie = new int[200010][2];
    int[] sum = new int[200010];
    sum[0] = 1;
    int idx = 0, cnt = 0;
    for (int[] q : newQueries) {
        int x = q[0], m = q[1], k = q[2], p = 0;
        while (idx < nums.length && nums[idx] <= m) {
            int cur = 0, t = nums[idx++];
            for (int i = 31; i >= 0; --i) {
                int bit = ((t >> i) & 1);
                if (trie[cur][bit] == 0) {
                    trie[cur][bit] = ++cnt;
                }
                cur = trie[cur][bit];
            }
            sum[cur]++;
        }
        if (cnt == 0) { 
            ans[k] = -1; 
            continue; 
        }
        int cur = 0, ans2 = 0;
        for (int i = 31; i >= 0; --i) {
            int bit = ((x >> i) & 1);
            if (trie[cur][bit ^ 1] != 0) {
                cur = trie[cur][bit ^ 1];
                ans2 |= (1 << i);
            } else {
                cur = trie[cur][bit];
            }
        }
        ans[k] = ans2;
    }
    return ans;
}


-----
import java.util.Arrays;
import java.util.Comparator;

public int[] maximizeXor(int[] nums, int[][] queries) 
    // Your code here
}


************************************
Question ID: 1827

public int minOperations(int[] nums) {
    int operations = 0;
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] <= nums[i - 1]) {
            operations += (nums[i - 1] - nums[i]) + 1;
            nums[i] = nums[i - 1] + 1;
        }
    }
    return operations;
}

-----
public int minOperations(int[] nums) 
    // Your code here
}

************************************
Question ID: 1828

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public int[] countPoints(int[][] points, int[][] queries) {
    int[] answer = new int[queries.length];
    for (int i = 0; i < queries.length; i++) {
        int inside = 0;
        for (int[] point : points) {
            int dx = point[0] - queries[i][0];
            int dy = point[1] - queries[i][1];
            if (dx * dx + dy * dy <= queries[i][2] * queries[i][2]) {
                inside++;
            }
        }
        answer[i] = inside;
    }
    return answer;
}


-----
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public int[] countPoints(int[][] points, int[][] queries) 
    // Your code here
}


************************************
Question ID: 1829

import java.util.Arrays;

public int maximumUnits(int[][] boxTypes, int truckSize) {
    Arrays.sort(boxTypes, (a, b) -> b[1] - a[1]);
    
    int totalUnits = 0;
    for (int[] box : boxTypes) {
        int boxCount = Math.min(truckSize, box[0]);
        totalUnits += boxCount * box[1];
        truckSize -= boxCount;
        if (truckSize == 0) {
            break;
        }
    }
    
    return totalUnits;
}

-----
import java.util.Arrays;

public int maximumUnits(int[][] boxTypes, int truckSize) 
    // Your code here
}

************************************
Question ID: 1830

import java.util.HashMap;

public int countPairs(int[] deliciousness) {
    final int MOD = (int) (1e9 + 7);
    HashMap<Integer, Integer> hashMap = new HashMap<>();
    int maxVal = 0;
    for (int val : deliciousness) {
        maxVal = Math.max(maxVal, val);
    }
    int maxSum = maxVal * 2;

    int count = 0;
    for (int val : deliciousness) {
        for (int sum = 1; sum <= maxSum; sum <<= 1) {
            count = (count + hashMap.getOrDefault(sum - val, 0)) % MOD;
        }
        hashMap.put(val, hashMap.getOrDefault(val, 0) + 1);
    }

    return count;
}

-----
import java.util.HashMap;

public int countPairs(int[] deliciousness) 
    // Your code here
}

************************************
Question ID: 1832

import java.util.HashMap;
import java.util.Map;
import java.util.Arrays;

public int minOperations(int[] target, int[] arr) {
    Map<Integer, Integer> indexMap = new HashMap<>();
    for (int i = 0; i < target.length; ++i) {
        indexMap.put(target[i], i);
    }

    int[] lis = new int[arr.length];
    int lisSize = 0;
    for (int num : arr) {
        if (indexMap.containsKey(num)) {
            int pos = Arrays.binarySearch(lis, 0, lisSize, indexMap.get(num));
            if (pos < 0) {
                pos = -(pos + 1);
            }
            lis[pos] = indexMap.get(num);
            if (pos == lisSize) {
                lisSize++;
            }
        }
    }
    
    return target.length - lisSize;
}

-----
import java.util.HashMap;
import java.util.Map;
import java.util.Arrays;

public int minOperations(int[] target, int[] arr) 
    // Your code here
}

************************************
Question ID: 1833

public int largestAltitude(int[] gain) {
    int max_altitude = 0, current_altitude = 0;
    for (int i = 0; i < gain.length; i++) {
        current_altitude += gain[i];
        max_altitude = Math.max(max_altitude, current_altitude);
    }
    return max_altitude;
}

-----
public int largestAltitude(int[] gain) 
    // Your code here
}

************************************
Question ID: 1834

import java.util.*;

class Solution {
    public int minimumTeachings(int n, int[][] languages, int[][] friendships) {
        Map<Integer, Set<Integer>> languageUsers = new HashMap<>();
        Set<Integer> unconnectedUsers = new HashSet<>();

        for (int[] friendship : friendships) {
            int u = friendship[0], v = friendship[1];
            boolean canCommunicate = false;

            for (int lang : languages[u - 1]) {
                if (Arrays.stream(languages[v - 1]).anyMatch(x -> x == lang)) {
                    canCommunicate = true;
                    break;
                }
            }

            if (!canCommunicate) {
                unconnectedUsers.add(u);
                unconnectedUsers.add(v);
            }
        }

        int res = unconnectedUsers.size();
        for (int i = 1; i <= n; ++i) {
            int cnt = 0;
            for (int user : unconnectedUsers) {
                if (Arrays.stream(languages[user - 1]).noneMatch(x -> x == i)) {
                    cnt++;
                }
            }
            res = Math.min(res, cnt);
        }

        return res;
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 1835

public int[] decode(int[] encoded) {
    int n = encoded.length + 1;
    int total_xor = 0;
    for (int i = 1; i <= n; ++i) {
        total_xor ^= i;
    }
    int encoded_xor = 0;
    for (int i = 1; i < n - 1; i += 2) {
        encoded_xor ^= encoded[i];
    }
    int[] perm = new int[n];
    perm[0] = total_xor ^ encoded_xor;
    for (int i = 1; i < n; ++i) {
        perm[i] = perm[i - 1] ^ encoded[i - 1];
    }
    return perm;
}

-----
public int[] decode(int[] encoded) 
    // Your code here
}

************************************
Question ID: 1836

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Vector;

public class Solution {
    static final int MOD = 1000000007;

    public static ArrayList<Integer> productWays(int[][] queries) {
        ArrayList<Integer> res = new ArrayList<>();
        for (int[] q : queries) {
            int n = q[0], k = q[1];

            List<Integer> pf = new ArrayList<>();
            Map<Integer, Integer> pm = new HashMap<>();
            for (int i = 2; i * i <= k; ++i) {
                int cnt = 0;
                while (k % i == 0) {
                    cnt++;
                    k /= i;
                }
                if (cnt != 0) {
                    pf.add(cnt);
                    pm.put(cnt, pm.getOrDefault(cnt, 0) + 1);
                }
            }

            if (k > 1) {
                pm.put(k, pm.getOrDefault(k, 0) + 1);
                pf.add(1);
            }

            long ans = 1;
            for (int p : pf) {
                ans = (ans * (p * (n - 1) + 1)) % MOD;
            }

            res.add((int) ans);
        }
        return res;
    }
}

-----
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Vector;

public class Solution 
    // Your code here
}

************************************
Question ID: 1837

public int sumBase(int n, int k) {
    int sum = 0;
    while (n > 0) {
        sum += n % k;
        n /= k;
    }
    return sum;
}


-----
public int sumBase(int n, int k) 
    // Your code here
}


************************************
Question ID: 1838

public int maxFrequency(int[] nums, int k) {
    Arrays.sort(nums);
    int n = nums.length, i = 0;
    long sum = 0;
    int max_freq = 0;

    for (int j = 0; j < n; j++) {
        sum += nums[j];
        while (sum + k < (long) nums[j] * (j - i + 1)) {
            sum -= nums[i++];
        }
        max_freq = Math.max(max_freq, j - i + 1);
    }

    return max_freq;
}

-----
public int maxFrequency(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 1839

public int[] decode(int[] encoded, int first) {
    int[] arr = new int[encoded.length + 1];
    arr[0] = first;
    for (int i = 0; i < encoded.length; i++) {
        arr[i + 1] = arr[i] ^ encoded[i];
    }
    return arr;
}


-----
public int[] decode(int[] encoded, int first) 
    // Your code here
}


************************************
Question ID: 1840

import java.util.*;

class Solution {
    private void dfs(int node, int[] visited, Map<Integer, List<Integer>> graph, List<Integer> group) {
        if (visited[node] == 1) return;
        visited[node] = 1;
        group.add(node);
        for (int neighbor : graph.get(node)) dfs(neighbor, visited, graph, group);
    }

    public int minimumHammingDistance(int[] source, int[] target, int[][] allowedSwaps) {
        int n = source.length;
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int[] swap : allowedSwaps) {
            graph.computeIfAbsent(swap[0], k -> new ArrayList<>()).add(swap[1]);
            graph.computeIfAbsent(swap[1], k -> new ArrayList<>()).add(swap[0]);
        }

        int res = 0;
        int[] visited = new int[n];
        for (int i = 0; i < n; ++i) {
            if (visited[i] == 0) {
                List<Integer> group = new ArrayList<>();
                dfs(i, visited, graph, group);
                Map<Integer, Integer> count = new HashMap<>();

                for (int node : group) count.put(source[node], count.getOrDefault(source[node], 0) + 1);
                for (int node : group) if (count.getOrDefault(target[node], 0) > 0) {
                    res++;
                    count.put(target[node], count.get(target[node]) - 1);
                }
            }
        }
        
        return n - res;
    }
}


-----
import java.util.*;

class Solution 
    // Your code here
}


************************************
Question ID: 1842

import java.util.Arrays;

public class Solution {
    public String nextPalindrome(String num) {
        int n = num.length();
        char[] firstHalf = num.substring(0, (n + 1) / 2).toCharArray();
        if (!nextPermutation(firstHalf)) return "";

        String secondHalf = new StringBuilder(String.valueOf(firstHalf)).reverse().toString();
        if (n % 2 == 1) secondHalf = secondHalf.substring(1);
        return String.valueOf(firstHalf) + secondHalf;
    }

    private boolean nextPermutation(char[] array) {
        int n = array.length;
        int k = n - 2;
        while (k >= 0 && array[k] >= array[k + 1]) k--;

        if (k == -1) return false;

        int l = n - 1;
        while (array[l] <= array[k]) l--;

        char temp = array[k];
        array[k] = array[l];
        array[l] = temp;

        int left = k + 1, right = n - 1;
        while (left < right) {
            temp = array[left];
            array[left++] = array[right];
            array[right--] = temp;
        }

        return true;
    }
}

-----
import java.util.Arrays;

public class Solution 
    // Your code here
}

************************************
Question ID: 1844

public int countBalls(int lowLimit, int highLimit) {
    int[] boxCounts = new int[46];
    for(int i = lowLimit; i <= highLimit; i++) {
        int boxNumber = 0;
        int num = i;
        while(num != 0) {
            boxNumber += num % 10;
            num /= 10;
        }
        boxCounts[boxNumber]++;
    }
    return Arrays.stream(boxCounts).max().orElse(0);
}

-----
public int countBalls(int lowLimit, int highLimit) 
    // Your code here
}

************************************
Question ID: 1845

import java.util.Arrays;

class Solution {
    public int largestSubmatrix(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        int[] height = new int[n];
        int max_area = 0;

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (matrix[i][j] == 1) height[j]++;
                else height[j] = 0;
            }
            int[] sorted_height = height.clone();
            Arrays.sort(sorted_height);
            for (int j = 0; j < n; ++j) {
                max_area = Math.max(max_area, sorted_height[j] * (n - j));
            }
        }
        return max_area;
    }
}


-----
import java.util.Arrays;

class Solution 
    // Your code here
}


************************************
Question ID: 1846

public int maximumElementAfterDecrementingAndRearranging(int[] arr) {
    Arrays.sort(arr);
    arr[0] = 1;
    for (int i = 1; i < arr.length; i++) {
        arr[i] = Math.min(arr[i], arr[i - 1] + 1);
    }
    return arr[arr.length - 1];
}

-----
public int maximumElementAfterDecrementingAndRearranging(int[] arr) 
    // Your code here
}

************************************
Question ID: 1847


```java
import java.util.*;

class Solution {
    public int[] closestRoom(int[][] rooms, int[][] queries) {
        Arrays.sort(rooms, (a, b) -> b[1] - a[1]);
        int[] result = new int[queries.length];

        for (int i = 0; i < queries.length; ++i) {
            int[] q = new int[]{queries[i][0], queries[i][1], i};
            queries[i] = q;
        }
        
        Arrays.sort(queries, (a, b) -> b[1] - a[1]);
        
        TreeSet<Integer> ids = new TreeSet<>();
        int j = 0;
        for (int[] q : queries) {
            while (j < rooms.length && rooms[j][1] >= q[1]) {
                ids.add(rooms[j++][0]);
            }
            if (ids.isEmpty()) {
                result[q[2]] = -1;
            } else {
                Integer cid1 = ids.ceiling(q[0]);
                Integer cid2 = ids.floor(q[0]);
                if (cid1 == null) {
                    result[q[2]] = cid2;
                } else if (cid2 == null) {
                    result[q[2]] = cid1;
                } else {
                    result[q[2]] = (q[0] - cid2 <= cid1 - q[0]) ? cid2 : cid1;
                }
            }
        }
        
        return result;
    }
}
```


-----

```java
import java.util.*;

class Solution 
    // Your code here
}
```


************************************
Question ID: 1848

public int sumOfUniqueElements(int[] nums) {
    Map<Integer, Integer> elemCount = new HashMap<>();
    for (int num : nums) {
        elemCount.put(num, elemCount.getOrDefault(num, 0) + 1);
    }
    int sum = 0;
    for (Map.Entry<Integer, Integer> entry : elemCount.entrySet()) {
        if (entry.getValue() == 1) {
            sum += entry.getKey();
        }
    }
    return sum;
}


-----
public int sumOfUniqueElements(int[] nums) 
    // Your code here
}


************************************
Question ID: 1849

public int maxAbsoluteSum(int[] nums) {
    int maxSum = 0, minSum = 0, maxSoFar = 0, minSoFar = 0;
    for (int num : nums) {
        maxSoFar = Math.max(num, maxSoFar + num);
        maxSum = Math.max(maxSum, maxSoFar);

        minSoFar = Math.min(num, minSoFar + num);
        minSum = Math.min(minSum, minSoFar);
    }
    return Math.max(maxSum, Math.abs(minSum));
}

-----
public int maxAbsoluteSum(int[] nums) 
    // Your code here
}

************************************
Question ID: 1850

public int minLengthAfterOperations(String s) {
    int aCount = s.length() - s.replace("a", "").length();
    int bCount = s.length() - s.replace("b", "").length();
    int cCount = s.length() - s.replace("c", "").length();

    if (aCount % 2 == bCount % 2 && bCount % 2 == cCount % 2) {
        return s.length() % 2;
    }
    return (s.length() + 1) % 2;
}

-----
public int minLengthAfterOperations(String s) 
    // Your code here
}

************************************
Question ID: 1851

import java.util.Arrays;

class Solution {
    public int maxValue(int[][] events, int k) {
        Arrays.sort(events, (a, b) -> a[1] - b[1]);
        int n = events.length;
        int[][] dp = new int[n + 1][k + 1];

        for (int i = 1; i <= n; i++) {
            int start = -1;
            for (int j = i - 1; j >= 1; j--) {
                if (events[j - 1][1] < events[i - 1][0]) {
                    start = j;
                    break;
                }
            }

            for (int j = 1; j <= k; j++) {
                if (start == -1) {
                    dp[i][j] = Math.max(dp[i - 1][j], events[i - 1][2]);
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[start][j - 1] + events[i - 1][2]);
                }
            }
        }

        return dp[n][k];
    }
}


-----
import java.util.Arrays;

class Solution 
    // Your code here
}


************************************
Question ID: 1852

import java.util.HashMap;
import java.util.ArrayList;

public int[] distinctNumbersInSubarrays(int[] nums, int k) {
    HashMap<Integer, Integer> counts = new HashMap<>();
    ArrayList<Integer> ans = new ArrayList<>();
    for (int i = 0; i < nums.length; i++) {
        counts.put(nums[i], counts.getOrDefault(nums[i], 0) + 1);
        if (i >= k) {
            counts.put(nums[i - k], counts.get(nums[i - k]) - 1);
            if (counts.get(nums[i - k]) == 0) {
                counts.remove(nums[i - k]);
            }
        }
        if (i >= k - 1) {
            ans.add(counts.size());
        }
    }
    return ans.stream().mapToInt(i -> i).toArray();
}

-----
import java.util.HashMap;
import java.util.ArrayList;

public int[] distinctNumbersInSubarrays(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 1854

public int maxAliveYear(int[][] logs) {
    int[] years = new int[101];
    for (int[] log : logs) {
        years[log[0] - 1950]++;
        years[log[1] - 1950]--;
    }
    int max_population = years[0];
    int max_year = 1950;
    for (int i = 1; i < 101; i++) {
        years[i] += years[i - 1];
        if (years[i] > max_population) {
            max_population = years[i];
            max_year = i + 1950;
        }
    }
    return max_year;
}

-----
public int maxAliveYear(int[][] logs) 
    // Your code here
}

************************************
Question ID: 1855

public int maxDistance(int[] nums1, int[] nums2) {
    int i = 0, j = 0, maxDist = 0;
    while (i < nums1.length && j < nums2.length) {
        if (nums1[i] > nums2[j]) {
            ++i;
        } else {
            maxDist = Math.max(maxDist, j - i);
            ++j;
        }
    }
    return maxDist;
}

-----
public int maxDistance(int[] nums1, int[] nums2) 
    // Your code here
}

************************************
Question ID: 1856

import java.util.Stack;

public int maxSumMinProduct(int[] nums) {
    long max_product = 0;
    Stack<Integer> stk = new Stack<>();
    long[] prefix_sum = new long[nums.length + 1];
    final int MOD = 1000000007;

    for (int i = 0; i < nums.length; i++) {
        prefix_sum[i + 1] = prefix_sum[i] + nums[i];
    }

    for (int i = 0; i < nums.length; i++) {
        while (!stk.isEmpty() && nums[stk.peek()] > nums[i]) {
            int min_val = nums[stk.pop()];
            max_product = Math.max(max_product, min_val * (prefix_sum[i] - prefix_sum[stk.isEmpty() ? 0 : stk.peek() + 1]));
        }
        stk.push(i);
    }
    
    while (!stk.isEmpty()) {
        int min_val = nums[stk.pop()];
        max_product = Math.max(max_product, min_val * (prefix_sum[nums.length] - prefix_sum[stk.isEmpty() ? 0 : stk.peek() + 1]));
    }

    return (int) (max_product % MOD);
}


-----
import java.util.Stack;

public int maxSumMinProduct(int[] nums) 
    // Your code here
}


************************************
Question ID: 1857

import java.util.*;

class Solution {
    public int largestPathValue(String colors, int[][] edges) {
        int n = colors.length();
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            adj.add(new ArrayList<>());
        }

        int[] inDegrees = new int[n];
        for (int[] e : edges) {
            adj.get(e[0]).add(e[1]);
            inDegrees[e[1]]++;
        }

        int[][] colorCounts = new int[n][26];
        Deque<Integer> queue = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            if (inDegrees[i] == 0) {
                queue.addLast(i);
            }
        }

        int visitedNodes = 0;
        int maxColorValue = 0;

        while (!queue.isEmpty()) {
            int node = queue.removeLast();
            int color = colors.charAt(node) - 'a';
            visitedNodes++;

            for (int neighbor : adj.get(node)) {
                for (int c = 0; c < 26; c++) {
                    int count = colorCounts[node][c] + (c == color ? 1 : 0);
                    colorCounts[neighbor][c] = Math.max(colorCounts[neighbor][c], count);
                    maxColorValue = Math.max(maxColorValue, count);
                }
                if (--inDegrees[neighbor] == 0) {
                    queue.addLast(neighbor);
                }
            }
        }

        return visitedNodes == n ? maxColorValue : -1;
    }
}


-----
import java.util.*;

class Solution 
    // Your code here
}


************************************
Question ID: 1858

public String maximumTime(String time) {
    char[] result = time.toCharArray();
    if (result[0] == '?') {
        result[0] = (result[1] == '?' || result[1] - '0' < 4) ? '2' : '1';
    }
    if (result[1] == '?') {
        result[1] = (result[0] == '2') ? '3' : '9';
    }
    if (result[3] == '?') {
        result[3] = '5';
    }
    if (result[4] == '?') {
        result[4] = '9';
    }
    return new String(result);
}

-----
public String maximumTime(String time) 
    // Your code here
}

************************************
Question ID: 1859

int minOperationsToSatisfyConditions(String a, String b) {
    int same = 0, less = 0, greater = 0;

    for (int i = 0; i < a.length(); i++) {
        if (a.charAt(i) == b.charAt(i)) same++;
        else if (a.charAt(i) < b.charAt(i)) less++;
        else greater++;
    }

    return Math.min(same + Math.max(less, greater), Math.min(less, greater));
}

-----
int minOperationsToSatisfyConditions(String a, String b) 
    // Your code here
}

************************************
Question ID: 1860

import java.util.PriorityQueue;

public int kthLargestValue(int[][] matrix, int k) {
    int m = matrix.length;
    int n = matrix[0].length;
    int[][] prefixXOR = new int[m + 1][n + 1];
    PriorityQueue<Integer> pq = new PriorityQueue<>(k);

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            prefixXOR[i][j] = matrix[i - 1][j - 1] ^ prefixXOR[i - 1][j] ^ prefixXOR[i][j - 1] ^ prefixXOR[i - 1][j - 1];
            pq.offer(prefixXOR[i][j]);
            if (pq.size() > k) {
                pq.poll();
            }
        }
    }
    return pq.peek();
}


-----
import java.util.PriorityQueue;

public int kthLargestValue(int[][] matrix, int k) 
    // Your code here
}


************************************
Question ID: 1861

public int minBoxesTouchingFloor(int n) {
    return (n + 1) / 2;
}

-----
public int minBoxesTouchingFloor(int n) 
    // Your code here
}

************************************
Question ID: 1862

public int sumOfFlooredPairs(int[] nums) {
    final int MOD = 1000000007;
    int n = nums.length;
    int maxElement = Arrays.stream(nums).max().getAsInt();
    long[] cnt = new long[maxElement + 1];
    for (int num : nums)
        cnt[num]++;
    for (int i = 1; i <= maxElement; i++)
        cnt[i] += cnt[i - 1];
    
    long res = 0;
    for (int num : nums) {
        for (int j = 1, k = 1; k <= maxElement; j++, k += num) {
            res += j * (cnt[Math.min(k + num - 1, maxElement)] - cnt[k - 1]);
            res %= MOD;
        }
    }
    
    return (int) res;
}

-----
public int sumOfFlooredPairs(int[] nums) 
    // Your code here
}

************************************
Question ID: 1863

public int subsetXORSum(int[] nums) {
    int ans = 0, n = nums.length, max_val = 1 << n;
    for (int i = 1; i < max_val; i++) {
        int xor_total = 0;
        for (int j = 0; j < n; j++) {
            if ((i & (1 << j)) > 0) {
                xor_total ^= nums[j];
            }
        }
        ans += xor_total;
    }
    return ans;
}

-----
public int subsetXORSum(int[] nums) 
    // Your code here
}

************************************
Question ID: 1864

public int minSwaps(String s) {
    int zeroCount = 0, oneCount = 0;
    for (char c : s.toCharArray()) {
        if (c == '0') {
            zeroCount++;
        } else {
            oneCount++;
        }
    }

    if (Math.abs(zeroCount - oneCount) > 1) {
        return -1;
    }

    int swaps1 = 0, swaps2 = 0;
    for (int i = 0; i < s.length(); i++) {
        if (i % 2 == 0 && s.charAt(i) != '0') {
            swaps1++;
        }
        if (i % 2 == 1 && s.charAt(i) != '1') {
            swaps1++;
        }
    }
    swaps1 = swaps1 / 2;

    for (int i = 0; i < s.length(); i++) {
        if (i % 2 == 0 && s.charAt(i) != '1') {
            swaps2++;
        }
        if (i % 2 == 1 && s.charAt(i) != '0') {
            swaps2++;
        }
    }
    swaps2 = swaps2 / 2;

    if (zeroCount == oneCount) {
        return Math.min(swaps1, swaps2);
    }
    return (zeroCount > oneCount) ? swaps2 : swaps1;
}

-----
public int minSwaps(String s) 
    // Your code here
}

************************************
Question ID: 1865

import java.util.HashMap;
import java.util.Map;

class FindSumPairs {
    int[] nums1;
    int[] nums2;
    Map<Integer, Integer> nums2Map;

    public FindSumPairs(int[] nums1, int[] nums2) {
        this.nums1 = nums1;
        this.nums2 = nums2;
        this.nums2Map = new HashMap<>();
        for (int num : nums2) {
            nums2Map.put(num, nums2Map.getOrDefault(num, 0) + 1);
        }
    }

    public void add(int index, int val) {
        nums2Map.put(nums2[index], nums2Map.get(nums2[index]) - 1);
        nums2[index] += val;
        nums2Map.put(nums2[index], nums2Map.getOrDefault(nums2[index], 0) + 1);
    }

    public int count(int tot) {
        int count = 0;
        for (int num : nums1) {
            count += nums2Map.getOrDefault(tot - num, 0);
        }
        return count;
    }
}


-----
import java.util.HashMap;
import java.util.Map;

class FindSumPairs 
    // Your code here
}


************************************
Question ID: 1866

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public int[] restoreArray(int[][] adjacentPairs) {
    Map<Integer, List<Integer>> graph = new HashMap<>();
    for (int[] pair : adjacentPairs) {
        graph.computeIfAbsent(pair[0], k -> new ArrayList<>()).add(pair[1]);
        graph.computeIfAbsent(pair[1], k -> new ArrayList<>()).add(pair[0]);
    }
    int n = adjacentPairs.length + 1;
    int[] nums = new int[n];
    for (Map.Entry<Integer, List<Integer>> entry : graph.entrySet()) {
        int key = entry.getKey();
        List<Integer> nodes = entry.getValue();
        if (nodes.size() == 1) {
            nums[0] = key;
            break;
        }
    }
    nums[1] = graph.get(nums[0]).get(0);
    for (int i = 2; i < n; i++) {
        List<Integer> nodes = graph.get(nums[i - 1]);
        nums[i] = nums[i - 2] == nodes.get(0) ? nodes.get(1) : nodes.get(0);
    }
    return nums;
}

-----
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public int[] restoreArray(int[][] adjacentPairs) 
    // Your code here
}

************************************
Question ID: 1868

import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> findRLEProduct(List<List<Integer>> encoded1, List<List<Integer>> encoded2) {
    List<List<Integer>> result = new ArrayList<>();
    int i = 0, j = 0, count1 = 0, count2 = 0;

    while (i < encoded1.size() && j < encoded2.size()) {
        int product = encoded1.get(i).get(0) * encoded2.get(j).get(0);
        int count = Math.min(encoded1.get(i).get(1) - count1, encoded2.get(j).get(1) - count2);
        count1 += count;
        count2 += count;

        if (!result.isEmpty() && result.get(result.size() - 1).get(0) == product) {
            result.get(result.size() - 1).set(1, result.get(result.size() - 1).get(1) + count);
        } else {
            List<Integer> pair = new ArrayList<>();
            pair.add(product);
            pair.add(count);
            result.add(pair);
        }

        if (count1 == encoded1.get(i).get(1)) {
            i++;
            count1 = 0;
        }

        if (count2 == encoded2.get(j).get(1)) {
            j++;
            count2 = 0;
        }
    }

    return result;
}

-----
import java.util.ArrayList;
import java.util.List;

public List<List<Integer>> findRLEProduct(List<List<Integer>> encoded1, List<List<Integer>> encoded2) 
    // Your code here
}

************************************
Question ID: 1869

public boolean checkZeroOnes(String s) {
    int max_ones = 0, max_zeros = 0, current_ones = 0, current_zeros = 0;
    for (char c : s.toCharArray()) {
        if (c == '1') {
            current_ones++;
            current_zeros = 0;
        } else {
            current_zeros++;
            current_ones = 0;
        }
        max_ones = Math.max(max_ones, current_ones);
        max_zeros = Math.max(max_zeros, current_zeros);
    }
    return max_ones > max_zeros;
}

-----
public boolean checkZeroOnes(String s) 
    // Your code here
}

************************************
Question ID: 1870

public int minSpeedOnTime(int[] dist, double hour) {
    double max_time = hour - dist.length + 1;
    double lower = 1.0, upper = 1e7;
    while (upper - lower >= 1e-9) {
        double mid = (lower + upper) / 2;
        double time_taken = 0.0;
        for (int i = 0; i < dist.length; ++i) {
            time_taken += Math.ceil(dist[i] / mid) - (i == dist.length - 1 ? 0 : 1);
        }
        if (time_taken <= max_time) {
            upper = mid;
        } else {
            lower = mid;
        }
    }
    return (lower <= 1e7) ? (int) Math.ceil(lower) : -1;
}

-----
public int minSpeedOnTime(int[] dist, double hour) 
    // Your code here
}

************************************
Question ID: 1871

public boolean isPalindrome(String s, int l, int r) {
    while (l < r) {
        if (s.charAt(l++) != s.charAt(r--)) return false;
    }
    return true;
}

public boolean checkPartitioning(String s) {
    int n = s.length();
    for (int i = 0; i < n - 2; i++) {
        if (isPalindrome(s, 0, i)) {
            for (int j = i + 1; j < n - 1; j++) {
                if (isPalindrome(s, i + 1, j) && isPalindrome(s, j + 1, n - 1)) {
                    return true;
                }
            }
        }
    }
    return false;
}


-----
public boolean isPalindrome(String s, int l, int r) 
    // Your code here
}


************************************
Question ID: 1872

import java.util.*;

public boolean[] canEat(int[] candiesCount, int[][] queries) {
    long[] prefixSum = new long[candiesCount.length + 1];
    for (int i = 0; i < candiesCount.length; ++i) {
        prefixSum[i + 1] = prefixSum[i] + candiesCount[i];
    }

    boolean[] result = new boolean[queries.length];
    for (int i = 0; i < queries.length; ++i) {
        int favoriteType = queries[i][0], favoriteDay = queries[i][1], dailyCap = queries[i][2];
        long x1 = favoriteDay + 1;
        long y1 = (favoriteDay + 1L) * dailyCap;

        long x2 = prefixSum[favoriteType] + 1;
        long y2 = prefixSum[favoriteType + 1];

        result[i] = !(x1 > y2 || y1 < x2);
    }

    return result;
}

-----
import java.util.*;

public boolean[] canEat(int[] candiesCount, int[][] queries) 
    // Your code here
}

************************************
Question ID: 1874

public boolean canChoose(int[][] groups, int[] nums) {
    int g_i = 0, n_i = 0;
    while (g_i < groups.length && n_i + groups[g_i].length <= nums.length) {
        boolean match = true;
        for (int i = 0; i < groups[g_i].length; ++i) {
            if (groups[g_i][i] != nums[n_i + i]) {
                match = false;
                break;
            }
        }
        if (match) {
            n_i += groups[g_i].length;
            g_i++;
        } else {
            n_i++;
        }
    }
    return g_i == groups.length;
}

-----
public boolean canChoose(int[][] groups, int[] nums) 
    // Your code here
}

************************************
Question ID: 1876

import java.util.*;

public int[][] highestIsland(int[][] isWater) {
    int m = isWater.length;
    int n = isWater[0].length;
    int[][] height = new int[m][n];
    Queue<int[]> q = new LinkedList<>();

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (isWater[i][j] == 1) {
                height[i][j] = 0;
                q.offer(new int[]{i, j});
            } else {
                height[i][j] = -1;
            }
        }
    }

    int[] dx = {-1, 0, 1, 0};
    int[] dy = {0, 1, 0, -1};

    while (!q.isEmpty()) {
        int[] curr = q.poll();
        int x = curr[0];
        int y = curr[1];

        for (int i = 0; i < 4; i++) {
            int newX = x + dx[i];
            int newY = y + dy[i];

            if (newX >= 0 && newX < m && newY >= 0 && newY < n && height[newX][newY] == -1) {
                height[newX][newY] = height[x][y] + 1;
                q.offer(new int[]{newX, newY});
            }
        }
    }

    return height;
}

-----
import java.util.*;

public int[][] highestIsland(int[][] isWater) 
    // Your code here
}

************************************
Question ID: 1877

public int minPairSum(int[] nums) {
    Arrays.sort(nums);
    int maxSum = 0;
    for (int i = 0; i < nums.length / 2; i++)
        maxSum = Math.max(maxSum, nums[i] + nums[nums.length - 1 - i]);
    return maxSum;
}

-----
public int minPairSum(int[] nums) 
    // Your code here
}

************************************
Question ID: 1878

public boolean check(int[] nums) {
    int count = 0;
    for (int i = 1; i < nums.length; ++i) {
        if (nums[i] < nums[i - 1]) {
            ++count;
        }
        if (count > 1) {
            return false;
        }
    }
    return count == 1 || nums[0] >= nums[nums.length - 1];
}

-----
public boolean check(int[] nums) 
    // Your code here
}

************************************
Question ID: 1879

public int maxScore(int a, int b, int c) {
    return (a + b + c - Math.max(a, Math.max(b, c))) / 2;
}


-----
public int maxScore(int a, int b, int c) 
    // Your code here
}


************************************
Question ID: 1880

public String largestMerge(String word1, String word2) {
    StringBuilder merge = new StringBuilder();
    while (!word1.isEmpty() || !word2.isEmpty()) {
        if (word1.compareTo(word2) > 0) {
            merge.append(word1.charAt(0));
            word1 = word1.substring(1);
        } else {
            merge.append(word2.charAt(0));
            word2 = word2.substring(1);
        }
    }
    return merge.toString();
}

-----
public String largestMerge(String word1, String word2) 
    // Your code here
}

************************************
Question ID: 1881

import java.util.TreeSet;

public int minAbsDifference(int[] nums, int goal) {
    int n = nums.length;
    int half = n / 2;
    int[] left = Arrays.copyOfRange(nums, 0, half);
    int[] right = Arrays.copyOfRange(nums, half, n);
    TreeSet<Integer> sums = new TreeSet<>();

    for (int mask = 0; mask < (1 << left.length); ++mask) {
        int sum = 0;
        for (int i = 0; i < left.length; ++i) {
            if ((mask & (1 << i)) != 0) {
                sum += left[i];
            }
        }
        sums.add(sum);
    }

    int ans = Math.abs(goal);

    for (int mask = 0; mask < (1 << right.length); ++mask) {
        int sum = 0;
        for (int i = 0; i < right.length; ++i) {
            if ((mask & (1 << i)) != 0) {
                sum += right[i];
            }
        }
        Integer ceiling = sums.ceiling(goal - sum);
        if (ceiling != null) {
            ans = Math.min(ans, Math.abs(ceiling + sum - goal));
        }
        Integer floor = sums.floor(goal - sum);
        if (floor != null) {
            ans = Math.min(ans, Math.abs(floor + sum - goal));
        }
    }

    return ans;
}

-----
import java.util.TreeSet;

public int minAbsDifference(int[] nums, int goal) 
    // Your code here
}

************************************
Question ID: 1882

import java.util.*;

public int[] assignTasks(int[] servers, int[] tasks) {
    int[] result = new int[tasks.length];
    PriorityQueue<int[]> freeServers = new PriorityQueue<>((a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);
    PriorityQueue<int[]> busyServers = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));
    
    for (int i = 0; i < servers.length; i++) {
        freeServers.offer(new int[] {servers[i], i});
    }
    
    int time = 0;
    int taskIndex = 0;
    
    while (taskIndex < tasks.length) {
        while (!busyServers.isEmpty() && busyServers.peek()[0] <= time) {
            freeServers.offer(busyServers.poll());
        }
        
        while (!freeServers.isEmpty() && taskIndex <= time && taskIndex < tasks.length) {
            int[] server = freeServers.poll();
            result[taskIndex] = server[1];
            busyServers.offer(new int[] {time + tasks[taskIndex], server[0], server[1]});
            taskIndex++;
        }
        
        time++;
    }
    
    return result;
}


-----
import java.util.*;

public int[] assignTasks(int[] servers, int[] tasks) 
    // Your code here
}


************************************
Question ID: 1883

public int minSkips(int[] dist, int speed, int hoursBefore) {
    int n = dist.length;
    double[][] dp = new double[n + 1][n + 1];
    
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= n; j++) {
            dp[i][j] = 1e9;
        }
    }
    dp[0][0] = 0;
    
    for (int i = 0; i < n; i++) {
        for (int j = -1; j < i; j++) {
            double t = dist[i] / (double)speed + (j != -1 ? 1 : 0);
            dp[i + 1][j + 1] = Math.min(dp[i + 1][j + 1], dp[i][j] + t);
            double skipped_t = Math.ceil(dp[i][j] + dist[i] / (double)speed) - dp[i][j];
            dp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j] + skipped_t);
        }
    }
    
    for (int i = 0; i <= n; i++) {
        if (dp[n][i] <= hoursBefore) {
            return i;
        }
    }
    return -1;
}

-----
public int minSkips(int[] dist, int speed, int hoursBefore) 
    // Your code here
}

************************************
Question ID: 1884

public int minOperationsToAlternate(String s) {
    int countA = 0, countB = 0;
    for (int i = 0; i < s.length(); i++) {
        if (i % 2 == 0) {
            if (s.charAt(i) == '0') countA++;
            else countB++;
        } else {
            if (s.charAt(i) == '0') countB++;
            else countA++;
        }
    }
    return Math.min(countA, countB);
}

-----
public int minOperationsToAlternate(String s) 
    // Your code here
}

************************************
Question ID: 1885

int countHomogenous(String s) {
    int res = 0, count = 1, mod = 1000000007;
    for (int i = 1; i < s.length(); ++i) {
        count = (s.charAt(i) == s.charAt(i - 1)) ? count + 1 : 1;
        res = (res + count) % mod;
    }
    return res;
}

-----
int countHomogenous(String s) 
    // Your code here
}

************************************
Question ID: 1886

import java.util.PriorityQueue;

public int minimumSize(int[] nums, int maxOperations) {
    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);
    for (int num : nums) {
        pq.offer(num);
    }
    while (maxOperations > 0) {
        int maxBalls = pq.poll();
        pq.offer(maxBalls / 2);
        pq.offer(maxBalls - (maxBalls / 2));
        maxOperations--;
    }
    return pq.peek();
}

-----
import java.util.PriorityQueue;

public int minimumSize(int[] nums, int maxOperations) 
    // Your code here
}

************************************
Question ID: 1887

import java.util.*;

class Solution {
    public int minTrioDegree(int n, int[][] edges) {
        Map<Integer, Map<Integer, Boolean>> graph = new HashMap<>();
        int[] degree = new int[n + 1];

        for (int[] edge : edges) {
            graph.computeIfAbsent(edge[0], k -> new HashMap<>()).put(edge[1], true);
            graph.computeIfAbsent(edge[1], k -> new HashMap<>()).put(edge[0], true);
            degree[edge[0]]++;
            degree[edge[1]]++;
        }

        int minDegree = Integer.MAX_VALUE;
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1];
            for (int w = 1; w <= n; ++w) {
                if (graph.get(u).get(w) != null && graph.get(v).get(w) != null) {
                    minDegree = Math.min(minDegree, degree[u] + degree[v] + degree[w] - 6);
                }
            }
        }

        return minDegree == Integer.MAX_VALUE ? -1 : minDegree;
    }
}


-----
import java.util.*;

class Solution 
    // Your code here
}


************************************
Question ID: 1888

public int nearestValidPoint(int x, int y, int[][] points) {
    int minDistance = Integer.MAX_VALUE;
    int minIndex = -1;

    for (int i = 0; i < points.length; i++) {
        if (x == points[i][0] || y == points[i][1]) {
            int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
            if (distance < minDistance) {
                minDistance = distance;
                minIndex = i;
            }
        }
    }

    return minIndex;
}

-----
public int nearestValidPoint(int x, int y, int[][] points) 
    // Your code here
}

************************************
Question ID: 1889

public boolean checkPowersOfThree(int n) {
    while (n > 0) {
        if (n % 3 == 2) return false;
        n /= 3;
    }
    return true;
}

-----
public boolean checkPowersOfThree(int n) 
    // Your code here
}

************************************
Question ID: 1893

public boolean isCovered(int[][] ranges, int left, int right) {
    for (int i = left; i <= right; i++) {
        boolean found = false;
        for (int[] range : ranges) {
            if (i >= range[0] && i <= range[1]) {
                found = true;
                break;
            }
        }
        if (!found) return false;
    }
    return true;
}

-----
public boolean isCovered(int[][] ranges, int left, int right) 
    // Your code here
}

************************************
Question ID: 1894

public String mergeAlternately(String word1, String word2) {
    StringBuilder merged = new StringBuilder();
    int i = 0, j = 0;
    while (i < word1.length() || j < word2.length()) {
        if (i < word1.length()) merged.append(word1.charAt(i++));
        if (j < word2.length()) merged.append(word2.charAt(j++));
    }
    return merged.toString();
}

-----
public String mergeAlternately(String word1, String word2) 
    // Your code here
}

************************************
Question ID: 1895

public int[] minOperations(String boxes) {
    int[] result = new int[boxes.length()];
    int count = 0, total = 0;
    
    for (int i = 0; i < boxes.length(); i++) {
        total += count;
        result[i] = total;
        if (boxes.charAt(i) == '1') count++;
    }

    count = 0;
    total = 0;
    for (int i = boxes.length() - 1; i >= 0; i--) {
        total += count;
        result[i] += total;
        if (boxes.charAt(i) == '1') count++;
    }

    return result;
}

-----
public int[] minOperations(String boxes) 
    // Your code here
}

************************************
Question ID: 1896

public int maximumScore(int[] nums, int[] multipliers) {
    int n = nums.length, m = multipliers.length;
    int[][] dp = new int[m + 1][m + 1];
    int maxScore = Integer.MIN_VALUE;

    for (int i = 0; i <= m; i++) {
        for (int j = 0; i + j <= m; j++) {
            if (i == 0 && j == 0) continue;
            int score = 0;
            if (i == 0) {
                score = dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1];
            } else if (j == 0) {
                score = dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1];
            } else {
                score = Math.max(dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1],
                                dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1]);
            }
            dp[i][j] = score;
            if (i + j == m) {
                maxScore = Math.max(maxScore, score);
            }
        }
    }

    return maxScore;
}

-----
public int maximumScore(int[] nums, int[] multipliers) 
    // Your code here
}

************************************
Question ID: 1897

public int longestPalindromeSubseq(String word1, String word2) {
    int n = word1.length();
    int m = word2.length();

    int[][] dp = new int[1001][1001];

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (word1.charAt(i) == word2.charAt(j)) {
                dp[i + 1][j + 1] = dp[i][j] + 1;
            } else {
                dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);
            }
        }
    }

    return dp[n][m];
}

-----
public int longestPalindromeSubseq(String word1, String word2) 
    // Your code here
}

************************************
Question ID: 1898

public int maximumRemovals(String s, String p, int[] removable) {
    int low = 0, high = removable.length;
    while (low < high) {
        int mid = (low + high + 1) / 2;
        StringBuilder temp_s = new StringBuilder(s);
        for (int i = 0; i < mid; i++) {
            temp_s.setCharAt(removable[i], '-');
        }
        int i = 0, j = 0;
        while (i < temp_s.length() && j < p.length()) {
            if (temp_s.charAt(i) == p.charAt(j)) {
                j++;
            }
            i++;
        }
        if (j == p.length()) {
            low = mid;
        } else {
            high = mid - 1;
        }
    }
    return low;
}


-----
public int maximumRemovals(String s, String p, int[] removable) 
    // Your code here
}


************************************
Question ID: 1899

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {
    Map<String, Integer> rule = new HashMap<>();
    rule.put("type", 0);
    rule.put("color", 1);
    rule.put("name", 2);
    int count = 0;

    for (List<String> item : items) {
        if (item.get(rule.get(ruleKey)).equals(ruleValue)) {
            count++;
        }
    }

    return count;
}

-----
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) 
    // Your code here
}

************************************
Question ID: 1900

import java.util.List;

public class Solution {
    public int closestCost(List<Integer> baseCosts, List<Integer> toppingCosts, int target) {
        int closest = baseCosts.get(0);
        for (int base : baseCosts) {
            int cost = base;
            for (int i = 0; i < (1 << (toppingCosts.size() * 2)); ++i) {
                int bitMask = i;
                for (int j = 0; j < toppingCosts.size(); ++j, bitMask >>= 2) {
                    cost += (bitMask & 3) * toppingCosts.get(j);
                }

                if (Math.abs(target - cost) < Math.abs(target - closest)) {
                    closest = cost;
                } else if (Math.abs(target - cost) == Math.abs(target - closest) && cost < closest) {
                    closest = cost;
                }

                cost = base;
            }
        }
        return closest;
    }
}


-----
import java.util.List;

public class Solution 
    // Your code here
}


************************************
Question ID: 1901

public int minOperations(int[] nums1, int[] nums2) {
    int sum1 = Arrays.stream(nums1).sum();
    int sum2 = Arrays.stream(nums2).sum();
    if (sum1 == sum2) return 0;
    if (sum1 < sum2) {
        int[] temp = nums1;
        nums1 = nums2;
        nums2 = temp;
    }
    Arrays.sort(nums1);
    Arrays.sort(nums2);
    int diff = Math.abs(sum1 - sum2), operations = 0;
    int i = nums1.length - 1, j = 0;
    while (diff > 0 && (i >= 0 || j < nums2.length)) {
        int option1 = i >= 0 ? nums1[i] - 1 : 0;
        int option2 = j < nums2.length ? 6 - nums2[j] : 0;
        if (option1 > option2) {
            diff -= option1;
            i--;
        } else {
            diff -= option2;
            j++;
        }
        operations++;
    }
    return diff == 0 ? operations : -1;
}


-----
public int minOperations(int[] nums1, int[] nums2) 
    // Your code here
}


************************************
Question ID: 1902

import java.util.Arrays;

class Solution {
    public double[] getCollisionTimes(int[][] cars) {
        int n = cars.length;
        double[] collisions = new double[n];
        Arrays.fill(collisions, -1);
        for (int i = n - 1; i >= 0; --i) {
            double time_to_collision = 1e9;
            for (int j = i + 1; j < n; ++j) {
                if (cars[j][1] > cars[i][1]) continue;
                double current_collision = (double) (cars[j][0] - cars[i][0]) / (cars[i][1] - cars[j][1]);
                if(current_collision < time_to_collision) {
                    time_to_collision = Math.min(time_to_collision, Math.min(collisions[j], current_collision));
                }
            }
            collisions[i] = time_to_collision == 1e9 ? -1.0 : time_to_collision;
        }
        return collisions;
    }
}

-----
import java.util.Arrays;

class Solution 
    // Your code here
}

************************************
Question ID: 1903

public String largestOddNumber(String num) {
    for (int i = num.length() - 1; i >= 0; i--) {
        if ((num.charAt(i) - '0') % 2 != 0) {
            return num.substring(0, i + 1);
        }
    }
    return "";
}

-----
public String largestOddNumber(String num) 
    // Your code here
}

************************************
Question ID: 1904

public int secondLargestDigit(String s) {
    int largest = -1, secondLargest = -1;
    for (char c : s.toCharArray()) {
        if (Character.isDigit(c)) {
            int digit = Character.getNumericValue(c);
            if (digit > largest) {
                secondLargest = largest;
                largest = digit;
            } else if (digit != largest && digit > secondLargest) {
                secondLargest = digit;
            }
        }
    }
    return secondLargest;
}

-----
public int secondLargestDigit(String s) 
    // Your code here
}

************************************
Question ID: 1906

public int maxScore(int[] nums) {
    int n = nums.length;
    int[][] dp = new int[n + 1][n * 2 + 1];

    for (int i = 0; i <= n; i++) {
        Arrays.fill(dp[i], -1);
    }

    return dfs(1, 0, n, nums, dp);
}

private int gcd(int x, int y) {
    if (y == 0) return x;
    return gcd(y, x % y);
}

private int dfs(int i, int j, int n, int[] nums, int[][] dp) {
    if (i > n) return 0;
    if (dp[i][j] != -1) return dp[i][j];
    int ans = 0;
    for (int k = j + 1; k < n * 2; k++) {
        ans = Math.max(ans, dfs(i + 1, k, n, nums, dp) + i * gcd(nums[j], nums[k]));
    }
    return dp[i][j] = ans;
}

-----
public int maxScore(int[] nums) 
    // Your code here
}

************************************
Question ID: 1908

public boolean aliceWins(int[] piles) {
    int xorSum = 0;
    for (int pile : piles) {
        xorSum ^= pile;
    }
    return xorSum != 0;
}


-----
public boolean aliceWins(int[] piles) 
    // Your code here
}


************************************
Question ID: 1909

public boolean canBeIncreasing(int[] nums) {
    int count = 0;
    for (int i = 1; i < nums.length; ++i) {
        if (nums[i - 1] >= nums[i]) {
            count++;
            if (count > 1) return false;
            if (i > 1 && nums[i - 2] >= nums[i] && i < nums.length - 1 && nums[i - 1] >= nums[i + 1]) return false;
        }
    }
    return true;
}

-----
public boolean canBeIncreasing(int[] nums) 
    // Your code here
}

************************************
Question ID: 1910

public boolean checkOnesSegment(String s) {
    int count = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '1') {
            if (i > 0 && s.charAt(i - 1) == '0') {
                count++;
            }
        }
    }
    return count <= 1;
}

-----
public boolean checkOnesSegment(String s) 
    // Your code here
}

************************************
Question ID: 1911

int minElements(int[] nums, int limit, int goal) {
    long sum = 0;
    for (int num : nums) sum += num;
    long diff = Math.abs(goal - sum);
    return (int)((diff + limit - 1) / limit);
}


-----
int minElements(int[] nums, int limit, int goal) 
    // Your code here
}


************************************
Question ID: 1912

import java.util.*;

class Solution {
    static final int mod = 1000000007;
    
    public int countRestrictedPaths(int n, int[][] edges) {
        List<List<Pair>> graph = new ArrayList<>();
        for (int i = 0; i <= n; i++) {
            graph.add(new ArrayList<>());
        }
        
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1], weight = edge[2];
            graph.get(u).add(new Pair(v, weight));
            graph.get(v).add(new Pair(u, weight));
        }

        long[] dist = new long[n + 1];
        Arrays.fill(dist, Long.MAX_VALUE);
        
        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> Long.compare(a.weight, b.weight));
        pq.offer(new Pair(n, 0));
        dist[n] = 0;

        while (!pq.isEmpty()) {
            Pair p = pq.poll();
            int u = p.node;
            long d = p.weight;

            if (d != dist[u]) continue;

            for (Pair to : graph.get(u)) {
                int v = to.node;
                long w = to.weight;
                if (dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                    pq.offer(new Pair(v, dist[v]));
                }
            }
        }

        int[] dp = new int[n + 1];
        Arrays.fill(dp, -1);
        return dfs(graph, dist, dp, 1);
    }
    
    int dfs(List<List<Pair>> graph, long[] dist, int[] dp, int u) {
        int n = dist.length - 1;
        if (u == n) return 1;
        if (dp[u] != -1) return dp[u];
        int ans = 0;
        for (Pair to : graph.get(u)) {
            int v = to.node;
            if (dist[v] < dist[u]) {
                ans = (int) ((ans + (long) dfs(graph, dist, dp, v)) % mod);
            }
        }
        dp[u] = ans;
        return ans;
    }

    static class Pair {
        int node;
        long weight;

        Pair(int node, long weight) {
            this.node = node;
            this.weight = weight;
        }
    }
}

-----
import java.util.*;

class Solution 
    // Your code here
}

************************************
Question ID: 1913

import java.util.HashMap;

public int minChanges(int[] nums, int k) {
    int n = nums.length;
    int[] xor_prefix = new int[n + 1];
    for (int i = 1; i <= n; ++i) {
        xor_prefix[i] = xor_prefix[i - 1] ^ nums[i - 1];
    }

    HashMap<Integer, Integer>[] dp = new HashMap[k];
    int[] min_dp = new int[k];
    for (int j = 0; j < k; ++j) {
        dp[j] = new HashMap<>();
        min_dp[j] = n;
    }

    for (int i = 1; i <= n; ++i) {
        int x = xor_prefix[i] ^ xor_prefix[i - k];

        if (i >= k) {
            dp[0].put(x, dp[0].getOrDefault(x, 0) + 1);
        }

        for (int j = 1; i - j * k >= 0; ++j) {
            dp[j].put(x, dp[j].getOrDefault(x, 0) + 1);
            min_dp[j] = Math.min(min_dp[j], dp[j - 1].getOrDefault(x, 0) - dp[j].getOrDefault(x, 0));
        }
    }

    int answer = n;
    for (int j = 0; j < k; ++j) {
        answer = Math.min(answer, min_dp[j] + j);
    }
    return answer;
}

-----
import java.util.HashMap;

public int minChanges(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 1914

import java.util.ArrayList;

public int[][] rotateGrid(int[][] grid, int k) {
    if (grid == null || grid.length == 0) return grid;
    
    int m = grid.length; // number of rows
    int n = grid[0].length; // number of columns
    int numLayers = Math.min(m, n) / 2;

    for (int layer = 0; layer < numLayers; ++layer) {
        int numToRotate = (m - 2 * layer) * 2 + (n - 2 * layer - 2) * 2; // number of elements in the outer ring
        int effective_k = k % numToRotate; // effective number of rotations
        
        while (effective_k-- > 0) {
            int temp = grid[layer][layer];
            for (int i = layer + 1; i < m - layer; ++i) {
                int swap = grid[i][layer];
                grid[i][layer] = temp;
                temp = swap;
            }
            for (int j = layer + 1; j < n - layer; ++j) {
                int swap = grid[m - layer - 1][j];
                grid[m - layer - 1][j] = temp;
                temp = swap;
            }
            for (int i = m - layer - 2; i >= layer; --i) {
                int swap = grid[i][n - layer - 1];
                grid[i][n - layer - 1] = temp;
                temp = swap;
            }
            for (int j = n - layer - 2; j > layer; --j) {
                int swap = grid[layer][j];
                grid[layer][j] = temp;
                temp = swap;
            }
        }
    }

    return grid;
}

-----
import java.util.ArrayList;

public int[][] rotateGrid(int[][] grid, int k) 
    // Your code here
}

************************************
Question ID: 1915

public boolean areAlmostEqual(String s1, String s2) {
    int diffCount = 0;
    int firstDiff = -1;
    int secondDiff = -1;
    for (int i = 0; i < s1.length(); i++) {
        if (s1.charAt(i) != s2.charAt(i)) {
            diffCount++;
            if (diffCount == 1)
                firstDiff = i;
            else if (diffCount == 2)
                secondDiff = i;
            else
                return false;
        }
    }
    return diffCount == 0 || (diffCount == 2 && s1.charAt(firstDiff) == s2.charAt(secondDiff) && s1.charAt(secondDiff) == s2.charAt(firstDiff));
}

-----
public boolean areAlmostEqual(String s1, String s2) 
    // Your code here
}

************************************
Question ID: 1916

public int findCenter(int[][] edges) {
    if (edges[0][0] == edges[1][0] || edges[0][0] == edges[1][1]) {
        return edges[0][0];
    }
    return edges[0][1];
}

-----
public int findCenter(int[][] edges) 
    // Your code here
}

************************************
Question ID: 1918

public int maxScore(int[] nums, int k) {
    int n = nums.length;
    int result = 0;
    for (int i = k; i >= 0; i--) {
        for (int j = k; j < n; j++) {
            int minVal = nums[i];
            for (int x = i; x <= j; x++)
                minVal = Math.min(minVal, nums[x]);
            result = Math.max(result, minVal * (j - i + 1));
        }
    }
    return result;
}

-----
public int maxScore(int[] nums, int k) 
    // Your code here
}

************************************
Question ID: 1920

public boolean squareIsWhite(String coordinates) {
    return (coordinates.charAt(0) - 'a' + coordinates.charAt(1) - '1') % 2 == 0;
}

-----
public boolean squareIsWhite(String coordinates) 
    // Your code here
}

************************************
Question ID: 1921

public int eliminateMaximum(int[] dist, int[] speed) {
    int n = dist.length;
    int[] timeToReachCity = new int[n];
    for (int i = 0; i < n; i++) {
        timeToReachCity[i] = (dist[i] + speed[i] - 1) / speed[i];
    }
    Arrays.sort(timeToReachCity);
    int eliminated = 0;
    for (int i = 0; i < n && timeToReachCity[i] > i; i++) {
        eliminated++;
    }
    return eliminated;
}

-----
public int eliminateMaximum(int[] dist, int[] speed) 
    // Your code here
}

************************************
Question ID: 1922

public long goodDigitStrings(int n) {
    final int mod = 1000000007;
    long evenCount = 1, primeCount = 1;
    for (int i = 0; i < n; ++i) {
        if (i % 2 == 0) evenCount = (evenCount * 5) % mod;
        else primeCount = (primeCount * 4) % mod;
    }
    return (evenCount * primeCount) % mod;
}

-----
public long goodDigitStrings(int n) 
    // Your code here
}

************************************
Question ID: 1923

import java.util.*;

public boolean areSentencesSimilar(String sentence1, String sentence2) {
    List<String> words1 = new ArrayList<>(Arrays.asList(sentence1.split(" ")));
    List<String> words2 = new ArrayList<>(Arrays.asList(sentence2.split(" ")));

    while (!words1.isEmpty() && !words2.isEmpty() && words1.get(0).equals(words2.get(0))) {
        words1.remove(0);
        words2.remove(0);
    }

    while (!words1.isEmpty() && !words2.isEmpty() && words1.get(words1.size() - 1).equals(words2.get(words2.size() - 1))) {
        words1.remove(words1.size() - 1);
        words2.remove(words2.size() - 1);
    }

    return words1.isEmpty() || words2.isEmpty();
}

-----
import java.util.*;

public boolean areSentencesSimilar(String sentence1, String sentence2) 
    // Your code here
}

************************************
Question ID: 1924

public int maxHappyGroups(int batchSize, int[] groups) {
    int[] remainders = new int[batchSize];
    for (int g : groups) {
        remainders[g % batchSize]++;
    }

    int result = remainders[0];
    int i = 1, j = batchSize - 1;

    while (i < j) {
        result += Math.min(remainders[i], remainders[j]);
        i++;
        j--;
    }
    if (i == j) {
        result += remainders[i] / 2;
    }

    return result;
}

-----
public int maxHappyGroups(int batchSize, int[] groups) 
    // Your code here
}

************************************
Question ID: 1925

public int reverse(int x) {
    int rev = 0;
    while (x != 0) {
        rev = rev * 10 + x % 10;
        x = x / 10;
    }
    return rev;
}

public int countNicePairs(int[] nums) {
    final int MOD = 1_000_000_007;
    HashMap<Integer, Integer> count = new HashMap<>();
    int result = 0;

    for (int num : nums) {
        int diff = num - reverse(num);
        count.put(diff, count.getOrDefault(diff, 0) + 1);
    }

    for (int val : count.values()) {
        result = (int)((result + ((val * (val - 1L)) / 2) % MOD) % MOD);
    }

    return result;
}

-----
public int reverse(int x) 
    // Your code here
}

************************************
Question ID: 1926

import java.util.ArrayDeque;
import java.util.Queue;

public int nearestExit(char[][] maze, int[] entrance) {
    int m = maze.length;
    int n = maze[0].length;
    int[][] moves = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    Queue<int[]> q = new ArrayDeque<>();
    q.offer(new int[]{entrance[0], entrance[1]});
    
    int steps = -1;
    while (!q.isEmpty()) {
        steps++;
        int size = q.size();
        for (int i = 0; i < size; ++i) {
            int[] pos = q.poll();
            int r = pos[0];
            int c = pos[1];
            if (maze[r][c] == '+') continue;
            if (r == 0 || r == m-1 || c == 0 || c == n-1) {
                if (r != entrance[0] || c != entrance[1]) return steps;
            }
            maze[r][c] = '+';
            for (int[] move : moves) {
                int nr = r + move[0];
                int nc = c + move[1];
                if (nr >= 0 && nr < m && nc >= 0 && nc < n) {
                    q.offer(new int[]{nr, nc});
                }
            }
        }
    }
    return -1;
}

-----
import java.util.ArrayDeque;
import java.util.Queue;

public int nearestExit(char[][] maze, int[] entrance) 
    // Your code here
}

************************************
Question ID: 1927

public int maxAscendingSum(int[] nums) {
    int maxSum = 0, currentSum = nums[0];

    for (int i = 1; i < nums.length; ++i) {
        if (nums[i] > nums[i - 1]) {
            currentSum += nums[i];
        } else {
            maxSum = Math.max(maxSum, currentSum);
            currentSum = nums[i];
        }
    }

    return Math.max(maxSum, currentSum);
}

-----
public int maxAscendingSum(int[] nums) 
    // Your code here
}

************************************
Question ID: 1928

import java.util.*;

class Solution {
    public int getNumberOfBacklogOrders(int[][] orders) {
        PriorityQueue<int[]> sell = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        PriorityQueue<int[]> buy = new PriorityQueue<>((a, b) -> b[0] - a[0]);

        for (int[] order : orders) {
            if (order[2] == 0) {
                while (!sell.isEmpty() && order[1] > 0 && sell.peek()[0] <= order[0]) {
                    int executedAmount = Math.min(order[1], sell.peek()[1]);
                    order[1] -= executedAmount;
                    sell.peek()[1] -= executedAmount;
                    if (sell.peek()[1] == 0) sell.poll();
                }
                if (order[1] > 0) buy.offer(order);
            } else {
                while (!buy.isEmpty() && order[1] > 0 && buy.peek()[0] >= order[0]) {
                    int executedAmount = Math.min(order[1], buy.peek()[1]);
                    order[1] -= executedAmount;
                    buy.peek()[1] -= executedAmount;
                    if (buy.peek()[1] == 0) buy.poll();
                }
                if (order[1] > 0) sell.offer(order);
            }
        }

        long res = 0;
        while (!buy.isEmpty()) res += buy.poll()[1];
        while (!sell.isEmpty()) res += sell.poll()[1];
        res %= 1_000_000_007;

        return (int) res;
    }
}


-----
import java.util.*;

class Solution 
    // Your code here
}


************************************
Question ID: 1929

public int maxValue(int n, int index, int maxSum) {
    maxSum -= n;
    int left = 0, right = maxSum, ans = 0;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        long sum = (long)Math.min(mid, index) * (Math.min(mid, index) + 1) / 2 + (long)Math.min(mid, n - index - 1) * (Math.min(mid, n - index) + 1) / 2;
        if (mid > index) {
            sum += (long)(mid - index - 1) * (mid - index) / 2;
        }
        if (mid > n - index) {
            sum += (long)(mid - n + index) * (mid - n + index + 1) / 2;
        }
        if (sum <= maxSum) {
            ans = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return ans + 1;
}

-----
public int maxValue(int n, int index, int maxSum) 
    // Your code here
}

************************************
Question ID: 1930

import java.util.Arrays;

public int maxConsecutiveValues(int[] coins) {
    Arrays.sort(coins);
    int maxValue = 0;
    for (int coin : coins) {
        if (coin <= maxValue + 1) {
            maxValue += coin;
        } else {
            break;
        }
    }
    return maxValue + 1;
}

-----
import java.util.Arrays;

public int maxConsecutiveValues(int[] coins) 
    // Your code here
}

************************************
Question ID: 1931

public int numOfWays(int m, int n) {
    long mod = 1000000007;
    long a = 6, b = 6, c = 3, d = 3;
    while (--n > 0) {
        long temp_a = a, temp_c = c;
        a = (a * 3 + b * 2) % mod;
        b = (temp_a * 2 + b * 2) % mod;
        c = (c * 3 + d * 2) % mod;
        d = (temp_c * 2 + d * 2) % mod;
    }
    return (int)(m == 1 ? b : (a + c) % mod);
}

-----
public int numOfWays(int m, int n) 
    // Your code here
}

************************************
Question ID: 1933

import java.util.HashSet;
import java.util.Set;

public int numDifferentIntegers(String word) {
    for (int i = 0; i < word.length(); i++) {
        if (!Character.isDigit(word.charAt(i))) {
            word = word.substring(0, i) + " " + word.substring(i + 1);
        }
    }
    String[] nums = word.split("\\s+");
    Set<String> uniqueNums = new HashSet<>();
    for (String num : nums) {
        num = num.replaceFirst("^0+(?!$)", "");
        uniqueNums.add(num);
    }
    return uniqueNums.size();
}

-----
import java.util.HashSet;
import java.util.Set;

public int numDifferentIntegers(String word) 
    // Your code here
}

************************************
Question ID: 1935

public int min_operations(int n) {
    int count = 1;
    int temp = 1;

    while (temp % n != 0) {
        temp = (temp * 2) % n;
        count++;
    }

    return count;
}

-----
public int min_operations(int n) 
    // Your code here
}

************************************
Question ID: 1936

public int numberOfNiceDivisors(int primeFactors) {
    int MOD = 1000000007;
    long result = 1;
    for (int p = 2; p <= primeFactors; ++p) {
        if (primeFactors % p == 0) {
            int count = 0;
            while (primeFactors % p == 0) {
                primeFactors /= p;
                ++count;
            }
            result = (result * (count * 2 + 1)) % MOD;
        }
    }
    return (int) result;
}

-----
public int numberOfNiceDivisors(int primeFactors) 
    // Your code here
}

************************************
Question ID: 1937

public int maxPoints(int[][] points) {
    int m = points.length, n = points[0].length;
    long[] dp = new long[n];
    for (int[] row : points) {
        long[] next_dp = new long[n];
        for (int c1 = 0; c1 < n; ++c1) {
            long score = dp[c1] + row[c1] - c1;
            for (int c2 = 0; c2 < n; ++c2) {
                next_dp[c2] = Math.max(next_dp[c2], score - row[c1] + c2);
            }
        }
        dp = next_dp;
    }
    long max_points = 0;
    for (long score : dp) {
        max_points = Math.max(max_points, score);
    }
    return (int) max_points;
}

-----
public int maxPoints(int[][] points) 
    // Your code here
}

************************************
Question ID: 1938

public int minOperations(int[] nums) {
    int operations = 0;
    for (int i = 1; i < nums.length; ++i) {
        if (nums[i] <= nums[i - 1]) {
            operations += nums[i - 1] - nums[i] + 1;
            nums[i] = nums[i - 1] + 1;
        }
    }
    return operations;
}

-----
public int minOperations(int[] nums) 
    // Your code here
}

************************************
Question ID: 1942

import java.util.*;

public int smallestChair(int[][] times, int targetFriend) {
    TreeMap<Integer, Integer> events = new TreeMap<>();
    for (int i = 0; i < times.length; ++i) {
        events.put(times[i][0], i);
        events.put(times[i][1], ~i);
    }
    
    TreeSet<Integer> availableChairs = new TreeSet<>();
    
    for (int i = 0; i < times.length; i++) {
        availableChairs.add(i);
    }

    int[] assignedChair = new int[times.length];

    for (Map.Entry<Integer, Integer> entry : events.entrySet()) {
        int idx = entry.getValue();
        if (idx >= 0) {
            int chair = availableChairs.first();
            availableChairs.remove(chair);
            assignedChair[idx] = chair;
            if (idx == targetFriend) return chair;
        } else {
            availableChairs.add(assignedChair[~idx]);
        }
    }

    return -1;
}

-----
import java.util.*;

public int smallestChair(int[][] times, int targetFriend) 
    // Your code here
}

************************************
