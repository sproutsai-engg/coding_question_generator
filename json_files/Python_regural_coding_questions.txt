Question ID: 1
def twoSum(nums, target):
    map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in map:
            return [map[complement], i]
        map[num] = i
    return []

-----
def twoSum(nums, target):
    # Your code here


************************************
Question ID: 3
def length_of_longest_substring(s: str) -> int:
    left = 0
    right = 0
    max_length = 0
    characters = set()

    while right < len(s):
        if s[right] not in characters:
            characters.add(s[right])
            max_length = max(max_length, right - left + 1)
            right += 1
        else:
            characters.remove(s[left])
            left += 1

    return max_length

-----
def length_of_longest_substring(s: str) -> int:
    # Your code here


************************************
Question ID: 4
def findMedianSortedArrays(nums1, nums2):
    if len(nums1) > len(nums2):
        return findMedianSortedArrays(nums2, nums1)
    
    x, y = len(nums1), len(nums2)
    low, high = 0, x

    while low <= high:
        partition_x = (low + high) // 2
        partition_y = (x + y + 1) // 2 - partition_x

        max_left_x = float('-inf') if partition_x == 0 else nums1[partition_x - 1]
        min_right_x = float('inf') if partition_x == x else nums1[partition_x]

        max_left_y = float('-inf') if partition_y == 0 else nums2[partition_y - 1]
        min_right_y = float('inf') if partition_y == y else nums2[partition_y]

        if max_left_x <= min_right_y and max_left_y <= min_right_x:
            if (x + y) % 2 == 0:
                return (max(max_left_x, max_left_y) + min(min_right_x, min_right_y)) / 2
            else:
                return max(max_left_x, max_left_y)
        elif max_left_x > min_right_y:
            high = partition_x - 1
        else:
            low = partition_x + 1
    
    return 0

-----
def findMedianSortedArrays(nums1, nums2):
    # Your code here


************************************
Question ID: 5
def longest_palindromic_substring(s: str) -> str:
    n = len(s)
    if n == 0: return ""

    start, max_length = 0, 1

    for i in range(n):
        l, r = i, i

        while r < n - 1 and s[r] == s[r + 1]:
            r += 1
        i = r

        while l > 0 and r < n - 1 and s[l - 1] == s[r + 1]:
            l -= 1
            r += 1

        length = r - l + 1
        if length > max_length:
            start, max_length = l, length

    return s[start:start + max_length]

-----
def longest_palindromic_substring(s: str) -> str:
    # Your code here


************************************
Question ID: 6
def convert(s: str, numRows: int) -> str:
    if numRows == 1 or numRows >= len(s):
        return s

    rows = [""] * numRows
    curRow = 0
    goingDown = False

    for c in s:
        rows[curRow] += c
        if curRow == 0 or curRow == numRows - 1:
            goingDown = not goingDown
        curRow += 1 if goingDown else -1

    return "".join(rows)

-----
def convert(s: str, numRows: int) -> str:
    # Your code here


************************************
Question ID: 7
def reverse(x: int) -> int:
    sign = -1 if x < 0 else 1
    x = abs(x)
    res = 0
    while x:
        res = res * 10 + x % 10
        x //= 10
    res *= sign
    return res if -2**31 <= res <= 2**31 - 1 else 0

-----
def reverse(x: int) -> int:
    # Your code here


************************************
Question ID: 8
def myAtoi(s):
    result, i, sign = 0, 0, 1
    while i < len(s) and s[i] == ' ': i += 1
    if i < len(s) and (s[i] == '-' or s[i] == '+'):
        sign = -1 if s[i] == '-' else 1
        i += 1
    while i < len(s) and s[i].isdigit():
        result = result * 10 + int(s[i])
        i += 1
        if result * sign > 2**31 - 1: return 2**31 - 1
        if result * sign < -2**31: return -2**31
    return result * sign

-----
def myAtoi(s):
    # Your code here


************************************
Question ID: 9
def is_palindrome(x: int) -> bool:
    if x < 0:
        return False
    original, reversed = x, 0
    while x > 0:
        reversed = reversed * 10 + x % 10
        x //= 10
    return original == reversed


-----
def is_palindrome(x: int) -> bool:
    # Your code here


************************************
Question ID: 10
def is_match(s: str, p: str) -> bool:
    m, n = len(s), len(p)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True

    for j in range(1, n + 1):
        if p[j - 1] == '*' and dp[0][j - 2]:
            dp[0][j] = True

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j - 1] == s[i - 1] or p[j - 1] == '.':
                dp[i][j] = dp[i - 1][j - 1]
            elif p[j - 1] == '*':
                dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))

    return dp[m][n]

-----
def is_match(s: str, p: str) -> bool:
    # Your code here


************************************
Question ID: 11
def max_area(height):
    max_area, left, right = 0, 0, len(height) - 1
    while left < right:
        max_area = max(max_area, min(height[left], height[right]) * (right - left))
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    return max_area

-----
def max_area(height):
    # Your code here


************************************
Question ID: 12
def int_to_roman(num):
    romans = [
        (1000, "M"), (900, "CM"), (500, "D"),
        (400, "CD"), (100, "C"), (90, "XC"),
        (50, "L"), (40, "XL"), (10, "X"), 
        (9, "IX"), (5, "V"), (4, "IV"), (1, "I")
    ]
    roman = ""
    for value, symbol in romans:
        while num >= value:
            roman += symbol
            num -= value
    return roman

-----
def int_to_roman(num):
    # Your code here


************************************
Question ID: 13
def roman_to_int(s):
    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    total = 0
    prev_value = 0
    
    for c in s:
        current_value = roman_values[c]
        if current_value > prev_value:
            total += current_value - 2 * prev_value
        else:
            total += current_value
        prev_value = current_value

    return total


-----
def roman_to_int(s):
    # Your code here


************************************
Question ID: 14
def longest_common_prefix(strs):
    if not strs:
        return ""

    for i, c in enumerate(strs[0]):
        for j in range(1, len(strs)):
            if i == len(strs[j]) or strs[j][i] != c:
                return strs[0][:i]
    return strs[0]

-----
def longest_common_prefix(strs):
    # Your code here


************************************
Question ID: 15
def threeSum(nums):
    nums.sort()
    result = []

    for i in range(len(nums) - 2):
        if i == 0 or nums[i] != nums[i - 1]:
            j, k = i + 1, len(nums) - 1
            while j < k:
                s = nums[i] + nums[j] + nums[k]
                if s == 0:
                    result.append([nums[i], nums[j], nums[k]])
                    while j < k and nums[j] == nums[j + 1]:
                        j += 1
                    while j < k and nums[k] == nums[k - 1]:
                        k -= 1
                    j += 1
                    k -= 1
                elif s < 0:
                    j += 1
                else:
                    k -= 1

    return result

-----
def threeSum(nums):
    # Your code here


************************************
Question ID: 16
def threeSumClosest(nums, target):
    nums.sort()
    closest = sum(nums[:3])
    for i in range(len(nums) - 2):
        left, right = i + 1, len(nums) - 1
        while left < right:
            cur_sum = nums[i] + nums[left] + nums[right]
            if cur_sum == target:
                return cur_sum
            if abs(target - cur_sum) < abs(target - closest):
                closest = cur_sum
            if cur_sum < target:
                left += 1
            else:
                right -= 1
    return closest

-----
def threeSumClosest(nums, target):
    # Your code here


************************************
Question ID: 17
def letter_combinations(digits: str):
    if not digits: return []
    phone = ["abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]
    result = [""]

    for digit in digits:
        temp = []
        for s in result:
            for c in phone[int(digit) - 2]:
                temp.append(s + c)
        result = temp

    return result

-----
def letter_combinations(digits: str):
    # Your code here


************************************
Question ID: 18
def fourSum(nums, target):
    nums.sort()
    result = []
    for i in range(len(nums) - 3):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        for j in range(i + 1, len(nums) - 2):
            if j > i + 1 and nums[j] == nums[j - 1]:
                continue
            left = j + 1
            right = len(nums) - 1
            while left < right:
                cur_sum = nums[i] + nums[j] + nums[left] + nums[right]
                if cur_sum == target:
                    result.append([nums[i], nums[j], nums[left], nums[right]])
                    left += 1
                    right -= 1
                    while left < right and nums[left] == nums[left - 1]: left += 1
                    while left < right and nums[right] == nums[right + 1]: right -= 1
                elif cur_sum < target:
                    left += 1
                else:
                    right -= 1
    return result


-----
def fourSum(nums, target):
    # Your code here


************************************
Question ID: 20
def is_valid(s: str) -> bool:
    stack = []

    for c in s:
        if c in '([{':
            stack.append(c)
        else:
            if not stack:
                return False
            if c == ')' and stack[-1] != '(':
                return False
            if c == '}' and stack[-1] != '{':
                return False
            if c == ']' and stack[-1] != '[':
                return False
            stack.pop()

    return not stack

-----
def is_valid(s: str) -> bool:
    # Your code here


************************************
Question ID: 22
def generate_parenthesis(n):
    def generate_parenthesis_helper(open, close, current):
        if open == 0 and close == 0:
            result.append(current)
            return
        if open > 0:
            generate_parenthesis_helper(open - 1, close + 1, current + '(')
        if close > 0:
            generate_parenthesis_helper(open, close - 1, current + ')')

    result = []
    generate_parenthesis_helper(n, 0, '')
    return result


-----
def generate_parenthesis(n):
    # Your code here


************************************
Question ID: 24
def swapPairs(head: Optional[ListNode]) -> Optional[ListNode]:
    if not head or not head.next:
        return head

    second = head.next
    head.next = swapPairs(second.next)
    second.next = head

    return second

-----
def swapPairs(head: Optional[ListNode]) -> Optional[ListNode]:
    # Your code here


************************************
Question ID: 26
def removeDuplicates(nums):
    if not nums: return 0
    i = 0
    for j in range(1, len(nums)):
        if nums[j] != nums[i]:
            i += 1
            nums[i] = nums[j]
    return i + 1


-----
def removeDuplicates(nums):
    # Your code here


************************************
Question ID: 27
def removeElement(nums, val):
    i = 0
    for j in range(len(nums)):
        if nums[j] != val:
            nums[i] = nums[j]
            i += 1
    return i

-----
def removeElement(nums, val):
    # Your code here


************************************
Question ID: 28
def strStr(haystack: str, needle: str) -> int:
    if not needle:
        return 0
    try:
        index = haystack.index(needle)
        return index
    except ValueError:
        return -1

-----
def strStr(haystack: str, needle: str) -> int:
    # Your code here


************************************
Question ID: 29
def divide(dividend: int, divisor: int) -> int:
    if dividend == -(2**31) and divisor == -1:
        return 2**31 - 1

    sign = -1 if (dividend > 0) ^ (divisor > 0) else 1

    dvd = abs(dividend)
    dvs = abs(divisor)
    ans = 0

    while dvd >= dvs:
        temp = dvs
        multiple = 1
        while dvd >= (temp << 1):
            temp <<= 1
            multiple <<= 1
        dvd -= temp
        ans += multiple

    return ans * sign

-----
def divide(dividend: int, divisor: int) -> int:
    # Your code here


************************************
Question ID: 30
from collections import Counter

def findSubstring(s, words):
    if not s or not words:
        return []

    word_count = Counter(words)
    word_length = len(words[0])
    total_words = len(words)
    total_length = word_length * total_words
    result = []

    for i in range(len(s) - total_length + 1):
        temp_word_count = Counter()
        for j in range(total_words):
            current_word = s[i + j * word_length:i + (j + 1) * word_length]
            if current_word not in word_count:
                break
            temp_word_count[current_word] += 1
            if temp_word_count[current_word] > word_count[current_word]:
                break
            if j + 1 == total_words:
                result.append(i)

    return result

-----
from collections import Counter
    # Your code here


************************************
Question ID: 31
def nextPermutation(nums):
    n, k = len(nums), -1
    for i in range(n - 1, 0, -1):
        if nums[i - 1] < nums[i]:
            k = i - 1
            break
    if k == -1:
        nums.reverse()
    else:
        l = 0
        for i in range(n - 1, k, -1):
            if nums[i] > nums[k]:
                l = i
                break
        nums[k], nums[l] = nums[l], nums[k]
        nums[k + 1:] = reversed(nums[k + 1:])

-----
def nextPermutation(nums):
    # Your code here


************************************
Question ID: 32
def longest_valid_parentheses(s: str) -> int:
    n = len(s)
    result = 0
    st = []

    for i in range(n):
        if s[i] == '(':
            st.append(i)
        else:
            if st and s[st[-1]] == '(':
                st.pop()
            else:
                st.append(i)

    if not st:
        result = n
    else:
        right, left = n, 0
        while st:
            left = st.pop()
            result = max(result, right - left - 1)
            right = left
        result = max(result, right)

    return result

-----
def longest_valid_parentheses(s: str) -> int:
    # Your code here


************************************
Question ID: 33
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] >= nums[left]:
            if target >= nums[left] and target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if target > nums[mid] and target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1

-----
def search(nums, target):
    # Your code here


************************************
Question ID: 34
def searchRange(nums, target):
    start, end = -1, -1
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
            if nums[mid] == target:
                start = mid

    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] > target:right = mid - 1
        else:
            left = mid + 1
            if nums[mid] == target:
                end = mid
    
    return [start, end]

-----
def searchRange(nums, target):
    # Your code here


************************************
Question ID: 35
def searchInsert(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return left

-----
def searchInsert(nums, target):
    # Your code here


************************************
Question ID: 36
def isValidSudoku(board):
    seen = set()

    for i in range(9):
        for j in range(9):
            current_val = board[i][j]
            
            if current_val != '.':
                row = f"{current_val} in row {i}"
                col = f"{current_val} in col {j}"
                box = f"{current_val} in box {i // 3}-{j // 3}"
                
                if row in seen or col in seen or box in seen:
                    return False

                seen.add(row)
                seen.add(col)
                seen.add(box)

    return True


-----
def isValidSudoku(board):
    # Your code here


************************************
Question ID: 37
def isValid(board, row, col, c):
    for i in range(9):
        if board[i][col] == c:
            return False
        if board[row][i] == c:
            return False
        if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == c:
            return False
    return True

def solveSudokuHelper(board):
    for i in range(9):
        for j in range(9):
            if board[i][j] == '.':
                for c in '123456789':
                    if isValid(board, i, j, c):
                        board[i][j] = c

                        if solveSudokuHelper(board):
                            return True

                        board[i][j] = '.'
                return False

    return True

def solveSudoku(board):
    solveSudokuHelper(board)

-----
def isValid(board, row, col, c):
    # Your code here


************************************
Question ID: 38
def count_and_say(n):
    if n == 1:
        return "1"
    previous = count_and_say(n - 1)
    result = []
    count = 1
    for i in range(1, len(previous)):
        if previous[i] == previous[i - 1]:
            count += 1
        else:
            result.append(str(count))
            result.append(previous[i - 1])
            count = 1
    result.append(str(count))
    result.append(previous[-1])
    return "".join(result)

-----
def count_and_say(n):
    # Your code here


************************************
Question ID: 39
def combinationSum(candidates, target):
    def findCombinations(startIndex, remaining):
        if remaining == 0:
            return [[]]
        if startIndex == len(candidates) or remaining < 0:
            return []

        result = []
        result.extend(findCombinations(startIndex + 1, remaining))
        result.extend([x + [candidates[startIndex]] for x in findCombinations(startIndex, remaining - candidates[startIndex])])
        
        return result

    return findCombinations(0, target)


-----
def combinationSum(candidates, target):
    # Your code here


************************************
Question ID: 40
def combinationSum2(candidates, target):
    def combine(candidates, target, start, path, res):
        if target == 0:
            res.append(path)
            return
        for i in range(start, len(candidates)):
            if i > start and candidates[i] == candidates[i - 1]:
                continue
            if candidates[i] > target:
                break
            combine(candidates, target - candidates[i], i+1, path + [candidates[i]], res)

    candidates.sort()
    res = []
    combine(candidates, target, 0, [], res)
    return res


-----
def combinationSum2(candidates, target):
    # Your code here


************************************
Question ID: 41
def firstMissingPositive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]

    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1

-----
def firstMissingPositive(nums):
    # Your code here


************************************
Question ID: 42
def trap(height):
    n = len(height)
    left, right, max_left, max_right, water = 0, n - 1, 0, 0, 0

    while left < right:
        if height[left] <= height[right]:
            max_left = max(max_left, height[left])
            water += max_left - height[left]
            left += 1
        else:
            max_right = max(max_right, height[right])
            water += max_right - height[right]
            right -= 1

    return water

-----
def trap(height):
    # Your code here


************************************
Question ID: 43
def multiply(num1, num2):
    m, n = len(num1), len(num2)
    pos = [0] * (m + n)
    
    for i in range(m-1, -1, -1):
        for j in range(n-1, -1, -1):
            mult = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))
            p1, p2 = i + j, i + j + 1
            total_pos = mult + pos[p2]
            pos[p1] += total_pos // 10
            pos[p2] = total_pos % 10
            
    res = ''.join(str(p) for p in pos if not (len(res) == 0 and p == 0))            
    return '0' if len(res) == 0 else res

-----
def multiply(num1, num2):
    # Your code here


************************************
Question ID: 44
def is_match(s: str, p: str) -> bool:
    m, n = len(s), len(p)
    i = j = 0
    match = asterisk = -1
    while i < m:
        if j < n and (s[i] == p[j] or p[j] == '?'):
            i, j = i + 1, j + 1
        elif j < n and p[j] == '*':
            match, asterisk = i, j
            j += 1
        elif asterisk >= 0:
            i, j = match + 1, asterisk + 1
            match += 1
        else:
            return False
    while j < n and p[j] == '*':
        j += 1
    return j == n

-----
def is_match(s: str, p: str) -> bool:
    # Your code here


************************************
Question ID: 45
def jump(nums):
    jumps = 0
    current_end = 0
    current_farthest = 0

    for i in range(len(nums) - 1):
        current_farthest = max(current_farthest, i + nums[i])
        if i == current_end:
            jumps += 1
            current_end = current_farthest

    return jumps

-----
def jump(nums):
    # Your code here


************************************
Question ID: 46
from typing import List

def permute(nums: List[int]) -> List[List[int]]:
    def helper(index):
        if index == len(nums) - 1:
            results.append(nums[:])
            return

        for i in range(index, len(nums)):
            nums[index], nums[i] = nums[i], nums[index]
            helper(index + 1)
            nums[index], nums[i] = nums[i], nums[index]

    results = []
    helper(0)
    return results

-----
from typing import List
    # Your code here


************************************
Question ID: 47
from typing import List

def permuteUnique(nums: List[int]) -> List[List[int]]:
    def backtrack(start):
        if start == len(nums):
            result.append(nums[:])
        for i in range(start, len(nums)):
            if i > start and nums[i] == nums[start]:
                continue
            nums[start], nums[i] = nums[i], nums[start]
            backtrack(start + 1)
            nums[start], nums[i] = nums[i], nums[start]

    nums.sort()
    result = []
    backtrack(0)
    return result


-----
from typing import List
    # Your code here


************************************
Question ID: 48
def rotate(matrix):
    n = len(matrix)
    for i in range(n // 2):
        for j in range(i, n - i - 1):
            temp = matrix[i][j]
            matrix[i][j] = matrix[n - j - 1][i]
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]
            matrix[j][n - i - 1] = temp

-----
def rotate(matrix):
    # Your code here


************************************
Question ID: 49
from collections import defaultdict

def group_anagrams(strs):
    anagram_map = defaultdict(list)

    for s in strs:
        key = ''.join(sorted(s))
        anagram_map[key].append(s)

    return list(anagram_map.values())

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 50
def myPow(x: float, n: int) -> float:
    if n == 0:
        return 1
    if n < 0:
        x = 1 / x
        n = -n
    result = 1
    currentProduct = x
    i = n
    while i:
        if i % 2 == 1:
            result *= currentProduct
        currentProduct *= currentProduct
        i //= 2
    return result

-----
def myPow(x: float, n: int) -> float:
    # Your code here


************************************
Question ID: 51
def solveNQueens(n):
    def isSafe(board, row, col):
        for i in range(col):
            if board[row][i] == 'Q': return False
        i, j = row, col
        while i >= 0 and j >= 0:
            if board[i][j] == 'Q': return False
            i, j = i - 1, j - 1
        i, j = row, col
        while i < n and j >= 0:
            if board[i][j] == 'Q': return False
            i, j = i + 1, j - 1
        return True

    def solve(result, board, n, col):
        if col == n:
            result.append(board.copy())
            return
        for row in range(n):
            if isSafe(board, row, col):
                board[row] = board[row][:col] + 'Q' + board[row][col + 1:]
                solve(result, board, n, col + 1)
                board[row] = board[row][:col] + '.' + board[row][col + 1:]

    result, board = [], ['.' * n for _ in range(n)]
    solve(result, board, n, 0)
    return result

-----
def solveNQueens(n):
    # Your code here


************************************
Question ID: 52
def is_safe(cols, row):
    col = len(cols)
    for i, r in enumerate(cols):
        if r == row or abs(i - col) == abs(r - row):
            return False
    return True


def backtrack(n, cols):
    if len(cols) == n:
        return 1

    count = 0
    for i in range(n):
        if is_safe(cols, i):
            cols.append(i)
            count += backtrack(n, cols)
            cols.pop()

    return count


def total_n_queens(n):
    cols = []
    return backtrack(n, cols)

-----
def is_safe(cols, row):
    # Your code here


************************************
Question ID: 53
def maxSubArray(nums):
    max_sum = current_sum = nums[0]

    for num in nums[1:]:
        current_sum = max(current_sum + num, num)
        max_sum = max(max_sum, current_sum)

    return max_sum

-----
def maxSubArray(nums):
    # Your code here


************************************
Question ID: 54
def spiralOrder(matrix):
    result = []
    if not matrix: return result
    m, n = len(matrix), len(matrix[0])
    rowStart, colStart, rowEnd, colEnd = 0, 0, m - 1, n - 1

    while rowStart <= rowEnd and colStart <= colEnd:
        for i in range(colStart, colEnd + 1): 
            result.append(matrix[rowStart][i])
        rowStart += 1
        
        for i in range(rowStart, rowEnd + 1): 
            result.append(matrix[i][colEnd]) 
        colEnd -= 1
        
        if rowStart <= rowEnd:
            for i in range(colEnd, colStart - 1, -1): 
                result.append(matrix[rowEnd][i]) 
        rowEnd -= 1
        
        if colStart <= colEnd:
            for i in range(rowEnd, rowStart - 1, -1): 
                result.append(matrix[i][colStart]) 
        colStart += 1
        
    return result

-----
def spiralOrder(matrix):
    # Your code here


************************************
Question ID: 55
def canJump(nums):
    max_reach = 0
    for i, num in enumerate(nums):
        if i > max_reach:
            return False
        max_reach = max(max_reach, i + num)
    return True

-----
def canJump(nums):
    # Your code here


************************************
Question ID: 56
def merge(intervals):
    if not intervals:
        return []

    intervals.sort()
    result = [intervals[0]]

    for i in range(1, len(intervals)):
        if result[-1][1] >= intervals[i][0]:
            result[-1][1] = max(result[-1][1], intervals[i][1])
        else:
            result.append(intervals[i])

    return result

-----
def merge(intervals):
    # Your code here


************************************
Question ID: 57
from typing import List

def insert(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
    result = []
    start_pos = 0

    while start_pos < len(intervals) and intervals[start_pos][1] < newInterval[0]:
        result.append(intervals[start_pos])
        start_pos += 1

    while start_pos < len(intervals) and intervals[start_pos][0] <= newInterval[1]:
        newInterval[0] = min(newInterval[0], intervals[start_pos][0])
        newInterval[1] = max(newInterval[1], intervals[start_pos][1])
        start_pos += 1

    result.append(newInterval)

    while start_pos < len(intervals):
        result.append(intervals[start_pos])
        start_pos += 1

    return result

-----
from typing import List
    # Your code here


************************************
Question ID: 58
def length_of_last_word(s: str) -> int:
    length = 0
    tail = len(s) - 1
    while tail >= 0 and s[tail] == ' ':
        tail -= 1
    while tail >= 0 and s[tail] != ' ':
        length += 1
        tail -= 1
    return length

-----
def length_of_last_word(s: str) -> int:
    # Your code here


************************************
Question ID: 59
def generateMatrix(n: int) -> List[List[int]]:
    matrix = [[0] * n for _ in range(n)]
    value, top, bottom, left, right = 1, 0, n - 1, 0, n - 1

    while value <= n * n:
        for i in range(left, right + 1):
            matrix[top][i] = value
            value += 1

        for i in range(top + 1, bottom + 1):
            matrix[i][right] = value
            value += 1

        if top < bottom and left < right:
            for i in range(right - 1, left - 1, -1):
                matrix[bottom][i] = value
                value += 1

            for i in range(bottom - 1, top, -1):
                matrix[i][left] = value
                value += 1

        top, bottom, left, right = top + 1, bottom - 1, left + 1, right - 1

    return matrix

-----
def generateMatrix(n: int) -> List[List[int]]:
    # Your code here


************************************
Question ID: 60
def getPermutation(n, k):
    factorials = [1]
    nums = list(range(1, n + 1))
    result = []

    for i in range(1, n):
        factorials.append(factorials[-1] * i)

    k -= 1

    for i in range(n, 0, -1):
        index = k // factorials[i - 1]
        k %= factorials[i - 1]
        result.append(str(nums.pop(index)))

    return ''.join(result)

-----
def getPermutation(n, k):
    # Your code here


************************************
Question ID: 62
def uniquePaths(m, n):
    dp = [[1] * n for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    return dp[m - 1][n - 1]

-----
def uniquePaths(m, n):
    # Your code here


************************************
Question ID: 63
def uniquePathsWithObstacles(grid):
    m, n = len(grid), len(grid[0])
    if grid[0][0] == 1:
        return 0

    grid[0][0] = 1
    for i in range(1, m):
        grid[i][0] = 1 if grid[i][0] == 0 and grid[i - 1][0] == 1 else 0
    for i in range(1, n):
        grid[0][i] = 1 if grid[0][i] == 0 and grid[0][i - 1] == 1 else 0

    for i in range(1, m):
        for j in range(1, n):
            if grid[i][j] == 0:
                grid[i][j] = grid[i - 1][j] + grid[i][j - 1]
            else:
                grid[i][j] = 0

    return grid[m - 1][n - 1]

-----
def uniquePathsWithObstacles(grid):
    # Your code here


************************************
Question ID: 64
def minPathSum(grid):
    m, n = len(grid), len(grid[0])

    for i in range(1, m):
        grid[i][0] += grid[i - 1][0]

    for i in range(1, n):
        grid[0][i] += grid[0][i - 1]

    for i in range(1, m):
        for j in range(1, n):
            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])

    return grid[m - 1][n - 1]

-----
def minPathSum(grid):
    # Your code here


************************************
Question ID: 65
import re

def is_number(s: str) -> bool:
    pattern = re.compile(r'^[-+]?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(e[-+]?[0-9]+)?$')
    return bool(pattern.match(s))


-----
import re
    # Your code here


************************************
Question ID: 66
def plusOne(digits: List[int]) -> List[int]:
    n = len(digits)

    for i in range(n - 1, -1, -1):
        if digits[i] < 9:
            digits[i] += 1
            return digits
        digits[i] = 0

    digits.insert(0, 1)
    return digits


-----
def plusOne(digits: List[int]) -> List[int]:
    # Your code here


************************************
Question ID: 67
def addBinary(a: str, b: str) -> str:
    result, carry, i, j = "", 0, len(a) - 1, len(b) - 1
    while i >= 0 or j >= 0 or carry:
        if i >= 0:
            carry += int(a[i])
            i -= 1
        if j >= 0:
            carry += int(b[j])
            j -= 1
        result = str(carry % 2) + result
        carry //= 2
    return result

-----
def addBinary(a: str, b: str) -> str:
    # Your code here


************************************
Question ID: 68
def fullJustify(words, maxWidth):
    result = []
    idx = 0
    while idx < len(words):
        total_chars = len(words[idx])
        last = idx + 1
        while last < len(words):
            if total_chars + 1 + len(words[last]) > maxWidth:
                break
            total_chars += 1 + len(words[last])
            last += 1
        gaps = last - idx - 1
        line = []
        if last == len(words) or gaps == 0:
            for i in range(idx, last):
                line.append(words[i])
                if i < last - 1:
                    line.append(" ")
            while sum(len(w) for w in line) < maxWidth:
                line.append(" ")
        else:
            even_spaces = (maxWidth - total_chars) // gaps
            extra_spaces = (maxWidth - total_chars) % gaps
            for i in range(idx, last):
                line.append(words[i])
                if i < last - 1:
                    line.append(" " * (even_spaces + (1 if i - idx < extra_spaces else 0)))
        idx = last
        result.append("".join(line))
    return result

-----
def fullJustify(words, maxWidth):
    # Your code here


************************************
Question ID: 69
def mySqrt(x):
    if x == 0 or x == 1:
        return x
    start, end, ans = 1, x, 0
    while start <= end:
        mid = (start + end) // 2
        if mid * mid == x:
            return mid
        if mid * mid < x:
            start = mid + 1
            ans = mid
        else:
            end = mid - 1
    return ans

-----
def mySqrt(x):
    # Your code here


************************************
Question ID: 70
def climbStairs(n):
    if n <= 2:
        return n
    a, b = 1, 2
    for _ in range(3, n+1):
        a, b = b, a + b
    return b


-----
def climbStairs(n):
    # Your code here


************************************
Question ID: 71
def simplifyPath(path: str) -> str:
    stack = []
    parts = path.split("/")

    for part in parts:
        if not part or part == ".":
            continue
        if part == "..":
            if stack:
                stack.pop()
        else:
            stack.append(part)

    return "/" + "/".join(stack)

-----
def simplifyPath(path: str) -> str:
    # Your code here


************************************
Question ID: 72
def minDistance(word1: str, word2: str) -> int:
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif word1[i - 1] == word2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
    
    return dp[m][n]

-----
def minDistance(word1: str, word2: str) -> int:
    # Your code here


************************************
Question ID: 73
def setZeroes(matrix):
    rows = len(matrix)
    cols = len(matrix[0])
    firstRow, firstCol = False, False

    for i in range(rows):
        for j in range(cols):
            if matrix[i][j] == 0:
                if i == 0: firstRow = True
                if j == 0: firstCol = True
                matrix[i][0] = 0
                matrix[0][j] = 0

    for i in range(1, rows):
        for j in range(1, cols):
            if matrix[i][0] == 0 or matrix[0][j] == 0:
                matrix[i][j] = 0

    if firstRow:
        for j in range(cols):
            matrix[0][j] = 0

    if firstCol:
        for i in range(rows):
            matrix[i][0] = 0

-----
def setZeroes(matrix):
    # Your code here


************************************
Question ID: 74
def searchMatrix(matrix, target):
    m, n = len(matrix), len(matrix[0])
    l, r = 0, m * n - 1

    while l <= r:
        mid = l + (r - l) // 2
        mid_val = matrix[mid // n][mid % n]

        if mid_val == target:
            return True
        elif mid_val < target:
            l = mid + 1
        else:
            r = mid - 1

    return False

-----
def searchMatrix(matrix, target):
    # Your code here


************************************
Question ID: 75
def sortColors(nums: List[int]) -> None:
    red, white, blue = 0, 0, len(nums) - 1
    while white <= blue:
        if nums[white] == 0:
            nums[red], nums[white] = nums[white], nums[red]
            red += 1
            white += 1
        elif nums[white] == 1:
            white += 1
        else:
            nums[white], nums[blue] = nums[blue], nums[white]
            blue -= 1

-----
def sortColors(nums: List[int]) -> None:
    # Your code here


************************************
Question ID: 76
from collections import Counter

def min_window(s, t):
    need = Counter(t)
    window = {}
    
    left = 0
    right = 0
    valid = 0
    start = 0
    length = float('inf')

    while right < len(s):
        c = s[right]
        right += 1
        if c in need:
            window[c] = window.get(c, 0) + 1
            if window[c] <= need[c]:
                valid += 1

        while valid == len(t):
            if right - left < length:
                start = left
                length = right - left

            d = s[left]
            left += 1
            if d in need:
                if window[d] <= need[d]:
                    valid -= 1
                window[d] -= 1

    return "" if length == float('inf') else s[start : start + length]


-----
from collections import Counter
    # Your code here


************************************
Question ID: 77
from typing import List

def combine(n: int, k: int) -> List[List[int]]:
    def backtrack(start, current_combination):
        if len(current_combination) == k:
            result.append(current_combination[:])

        for i in range(start, n + 1):
            current_combination.append(i)
            backtrack(i + 1, current_combination)
            current_combination.pop()

    result = []
    backtrack(1, [])
    return result

-----
from typing import List
    # Your code here


************************************
Question ID: 78
def subsets(nums):
    n = len(nums)
    num_subsets = 1 << n
    result = []

    for i in range(num_subsets):
        subset = []
        for j in range(n):
            if i & (1 << j):
                subset.append(nums[j])
        result.append(subset)
    return result

-----
def subsets(nums):
    # Your code here


************************************
Question ID: 79
def exist(board, word):
    m, n = len(board), len(board[0])

    def dfs(i, j, k):
        if not 0 <= i < m or not 0 <= j < n or board[i][j] != word[k]:
            return False
        if k == len(word) - 1:
            return True

        tmp, board[i][j] = board[i][j], '/'
        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
        board[i][j] = tmp
        return res

    for i in range(m):
        for j in range(n):
            if dfs(i, j, 0):
                return True
    return False


-----
def exist(board, word):
    # Your code here


************************************
Question ID: 80
def remove_duplicates(nums):
    i = 0
    for num in nums:
        if i < 2 or num > nums[i - 2]:
            nums[i] = num
            i += 1
    return i

-----
def remove_duplicates(nums):
    # Your code here


************************************
Question ID: 81
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            return True

        if nums[mid] == nums[left]:
            left += 1
        elif nums[mid] > nums[left]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return False

-----
def search(nums, target):
    # Your code here


************************************
Question ID: 84
def largestRectangleArea(heights):
    stack = []
    max_area = 0
    for i, h in enumerate(heights + [0]):
        while stack and heights[stack[-1]] > h:
            height = heights[stack.pop()]
            width = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, height * width)
        stack.append(i)
    return max_area

-----
def largestRectangleArea(heights):
    # Your code here


************************************
Question ID: 85
def maximalRectangle(matrix):
    if not matrix:
        return 0

    m = len(matrix)
    n = len(matrix[0])
    height = [0] * (n + 1)
    max_area = 0

    for i in range(m):
        s = []
        for j in range(n + 1):
            if j < n:
                height[j] = height[j] + 1 if matrix[i][j] == '1' else 0
            while s and height[j] < height[s[-1]]:
                h = height[s.pop()]
                w = j if not s else j - s[-1] - 1
                max_area = max(max_area, h * w)
            s.append(j)

    return max_area


-----
def maximalRectangle(matrix):
    # Your code here


************************************
Question ID: 87
def isScramble(s1: str, s2: str) -> bool:
    if s1 == s2:
        return True
    if len(s1) != len(s2) or sorted(s1) != sorted(s2):
        return False

    for i in range(1, len(s1)):
        if (isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:])) or \
           (isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i])):
            return True
    return False

-----
def isScramble(s1: str, s2: str) -> bool:
    # Your code here


************************************
Question ID: 88
def merge(nums1, m, nums2, n):
    i, j, k = m - 1, n - 1, m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1
    while j >= 0:
        nums1[k] = nums2[j]
        k -= 1
        j -= 1

-----
def merge(nums1, m, nums2, n):
    # Your code here


************************************
Question ID: 89
def grayCode(n):
    result = []
    for i in range(1 << n):
        result.append(i ^ (i >> 1))
    return result

-----
def grayCode(n):
    # Your code here


************************************
Question ID: 90
from itertools import combinations

def subsetsWithDup(nums):
    result = set()
    nums.sort()
    for i in range(len(nums) + 1):
        for combo in combinations(nums, i):
            result.add(combo)
    return list(result)

-----
from itertools import combinations
    # Your code here


************************************
Question ID: 91
def numDecodings(s: str) -> int:
    n = len(s)
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1 if s[0] != '0' else 0

    for i in range(2, n + 1):
        one_digit = int(s[i - 1:i])
        two_digits = int(s[i - 2:i])

        if one_digit >= 1:
            dp[i] += dp[i - 1]
        if two_digits >= 10 and two_digits <= 26:
            dp[i] += dp[i - 2]
    return dp[n]


-----
def numDecodings(s: str) -> int:
    # Your code here


************************************
Question ID: 92
def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
    if not head or left == right:
        return head
    dummy = ListNode(0)
    dummy.next = head
    pre = dummy
    for _ in range(left - 1):
        pre = pre.next
    cur = pre.next
    for _ in range(left, right):
        t = cur.next
        cur.next = t.next
        t.next = pre.next
        pre.next = t
    return dummy.next

-----
def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
    # Your code here


************************************
Question ID: 93
def restore_ip_addresses(s):
    def dfs(s, start, ip, result, part):
        if part == 4 and start == len(s):
            result.append(ip[:-1])
            return
        if part == 4 or start >= len(s):
            return

        num = 0
        for i in range(start, len(s)):
            num = num * 10 + int(s[i])
            if num > 255:
                break
            dfs(s, i + 1, ip + s[i] + ".", result, part + 1)
            if num == 0:
                break

    result = []
    dfs(s, 0, "", result, 0)
    return result


-----
def restore_ip_addresses(s):
    # Your code here


************************************
Question ID: 96
def numTrees(n):
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1
    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]

-----
def numTrees(n):
    # Your code here


************************************
Question ID: 97
def isInterleave(s1, s2, s3):
    m, n = len(s1), len(s2)
    if m + n != len(s3):
        return False

    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True
    for i in range(1, m + 1):
        dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]
    for j in range(1, n + 1):
        dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or \
                       (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])

    return dp[m][n]

-----
def isInterleave(s1, s2, s3):
    # Your code here


************************************
Question ID: 99
def inorder(node, nodes):
    if not node: return
    inorder(node.left, nodes)
    if nodes[1] and nodes[1].val > node.val:
        if not nodes[0]: nodes[0] = nodes[1]
        nodes[2] = node
    nodes[1] = node
    inorder(node.right, nodes)

def recoverTree(root):
    nodes = [None, None, None]
    inorder(root, nodes)
    nodes[0].val, nodes[2].val = nodes[2].val, nodes[0].val

-----
def inorder(node, nodes):
    # Your code here


************************************
Question ID: 101
def isSymmetric(root):
    return checkSymmetry(root, root)

def checkSymmetry(node1, node2):
    if not node1 and not node2:
        return True
    if not node1 or not node2:
        return False
    return (node1.val == node2.val) and checkSymmetry(node1.right, node2.left) and checkSymmetry(node1.left, node2.right)

-----
def isSymmetric(root):
    # Your code here


************************************
Question ID: 104
def maxDepth(root):
    if root is None:
        return 0
    return 1 + max(maxDepth(root.left), maxDepth(root.right))

-----
def maxDepth(root):
    # Your code here


************************************
Question ID: 107
from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def levelOrderBottom(root):
    result = []
    if not root:
        return result

    queue = deque([root])

    while queue:
        level = []
        size = len(queue)

        for i in range(size):
            current = queue.popleft()
            level.append(current.val)

            if current.left:
                queue.append(current.left)
            if current.right:
                queue.append(current.right)

        result.insert(0, level)

    return result

-----
from collections import deque
    # Your code here


************************************
Question ID: 111
def minDepth(root):
    if not root:
        return 0
    left = minDepth(root.left)
    right = minDepth(root.right)
    return (left == 0 or right == 0) and left + right + 1 or min(left, right) + 1

-----
def minDepth(root):
    # Your code here


************************************
Question ID: 114
def flatten(root):
    if not root:
        return
    flatten(root.left)
    flatten(root.right)
    if root.left:
        temp = root.right
        root.right = root.left
        root.left = None
        while root.right:
            root = root.right
        root.right = temp

-----
def flatten(root):
    # Your code here


************************************
Question ID: 115
def numDistinct(s: str, t: str) -> int:
    m, n = len(s), len(t)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m + 1):
        dp[i][0] = 1

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s[i - 1] == t[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j]

    return dp[m][n]

-----
def numDistinct(s: str, t: str) -> int:
    # Your code here


************************************
Question ID: 116
def connect(self, root: 'Node') -> 'Node':
    if not root or not root.left:
        return root
    root.left.next = root.right
    if root.next:
        root.right.next = root.next.left
    self.connect(root.left)
    self.connect(root.right)
    return root


-----
def connect(self, root: 'Node') -> 'Node':
    # Your code here


************************************
Question ID: 118
def generate(numRows):
    pascalsTriangle = []
    for i in range(numRows):
        row = [1]
        if i > 0:
            for j in range(1, i):
                row.append(pascalsTriangle[i-1][j-1] + pascalsTriangle[i-1][j])
            row.append(1)
        pascalsTriangle.append(row)
    return pascalsTriangle

-----
def generate(numRows):
    # Your code here


************************************
Question ID: 119
def get_row(rowIndex):
    row = [1] * (rowIndex + 1)
    for i in range(1, rowIndex + 1):
        for j in range(i - 1, 0, -1):
            row[j] += row[j - 1]
    return row

-----
def get_row(rowIndex):
    # Your code here


************************************
Question ID: 120
def minimumTotal(triangle):
    for row in range(len(triangle) - 2, -1, -1):
        for col in range(len(triangle[row])):
            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])
    return triangle[0][0]

-----
def minimumTotal(triangle):
    # Your code here


************************************
Question ID: 121
def maxProfit(prices):
    minPrice = float('inf')
    maxProfit = 0
    for price in prices:
        minPrice = min(minPrice, price)
        maxProfit = max(maxProfit, price - minPrice)
    return maxProfit

-----
def maxProfit(prices):
    # Your code here


************************************
Question ID: 122
def max_profit(prices):
    max_profit = 0
    for i in range(1, len(prices)):
        if prices[i] > prices[i - 1]:
            max_profit += prices[i] - prices[i - 1]
    return max_profit

-----
def max_profit(prices):
    # Your code here


************************************
Question ID: 123
def maxProfit(prices):
    buy1, buy2 = float("inf"), float("inf")
    profit1, profit2 = 0, 0

    for price in prices:
        buy1 = min(buy1, price)
        profit1 = max(profit1, price - buy1)
        buy2 = min(buy2, price - profit1)
        profit2 = max(profit2, price - buy2)

    return profit2

-----
def maxProfit(prices):
    # Your code here


************************************
Question ID: 125
def isPalindrome(s: str) -> bool:
    cleaned = "".join(c.lower() for c in s if c.isalnum())
    left, right = 0, len(cleaned) - 1
    while left < right:
        if cleaned[left] != cleaned[right]:
            return False
        left += 1
        right -= 1
    return True

-----
def isPalindrome(s: str) -> bool:
    # Your code here


************************************
Question ID: 126
from collections import defaultdict, deque

def findLadders(beginWord, endWord, wordList):
    wordList = set(wordList)
    if endWord not in wordList:
        return []

    adjacent = defaultdict(list)
    distance = defaultdict(int)
    queue = deque([beginWord])
    distance[beginWord] = 0
    
    def neighbors(word):
        for i in range(len(word)):
            for j in range(ord('a'), ord('z') + 1):
                yield word[:i] + chr(j) + word[i + 1:]
                
    while queue:
        current = queue.popleft()
        if current == endWord:
            break
        for neighbor in neighbors(current):
            if neighbor not in wordList:
                continue
            if neighbor not in distance:
                distance[neighbor] = distance[current] + 1
                queue.append(neighbor)
            if distance[neighbor] == distance[current] + 1:
                adjacent[current].append(neighbor)

    result = []
    path = [beginWord]

    def backtrack(word):
        if word == endWord:
            result.append(path[:])
        else:
            for next_word in adjacent[word]:
                path.append(next_word)
                backtrack(next_word)
                path.pop()
                
    backtrack(beginWord)
    return result


-----
from collections import defaultdict, deque
    # Your code here


************************************
Question ID: 127
from collections import deque

def ladderLength(beginWord, endWord, wordList):
    word_set = set(wordList)
    if endWord not in word_set:
        return 0

    q = deque([beginWord])
    steps = 1

    while q:
        size = len(q)
        current_level = set()
        
        for _ in range(size):
            current_word = q.popleft()
            if current_word == endWord:
                return steps

            word_chars = list(current_word)
            for i in range(len(word_chars)):
                original_char = word_chars[i]
                for j in range(26):
                    word_chars[i] = chr(ord('a') + j)
                    new_word = ''.join(word_chars)
                    if new_word in word_set:
                        q.append(new_word)
                        current_level.add(new_word)
                        
                word_chars[i] = original_char
        
        word_set -= current_level
        steps += 1
        
    return 0

-----
from collections import deque
    # Your code here


************************************
Question ID: 128
def longest_consecutive(nums):
    elements = set(nums)
    longest_seq = 0

    for num in nums:
        if num - 1 not in elements:
            current_num = num
            current_seq = 1
            
            while current_num + 1 in elements:
                current_num += 1
                current_seq += 1

            longest_seq = max(longest_seq, current_seq)
    
    return longest_seq

-----
def longest_consecutive(nums):
    # Your code here


************************************
Question ID: 129
def sumNumbers(root, cur=0):
    if root is None: return 0
    cur = cur * 10 + root.val
    if root.left is None and root.right is None: return cur
    return sumNumbers(root.left, cur) + sumNumbers(root.right, cur)


-----
def sumNumbers(root, cur=0):
    # Your code here


************************************
Question ID: 131
def isPalindrome(s, start, end):
    while start < end:
        if s[start] != s[end]:
            return False
        start += 1
        end -= 1
    return True

def dfs(s, start, results, current):
    if start == len(s):
        results.append(current[:])
        return
    
    for end in range(start, len(s)):
        if isPalindrome(s, start, end):
            current.append(s[start:end+1])
            dfs(s, end + 1, results, current)
            current.pop()

def partition(s):
    results = []
    dfs(s, 0, results, [])
    return results

-----
def isPalindrome(s, start, end):
    # Your code here


************************************
Question ID: 132
def minCut(s):
    n = len(s)
    dp = [i - 1 for i in range(n + 1)]
    is_palindrome = [[False] * n for _ in range(n)]
    
    for j in range(1, n):
        for i in range(j, -1, -1):
            if s[i] == s[j] and (j - i < 2 or is_palindrome[i + 1][j - 1]):
                is_palindrome[i][j] = True
                dp[j + 1] = min(dp[j + 1], dp[i] + 1)
                
    return dp[n]

-----
def minCut(s):
    # Your code here


************************************
Question ID: 134
def can_complete_circuit(gas, cost):
    total_gas, total_cost, start, gas_tank = 0, 0, 0, 0
    for i in range(len(gas)):
        total_gas += gas[i]
        total_cost += cost[i]
        gas_tank += gas[i] - cost[i]
        if gas_tank < 0:
            start = i + 1
            gas_tank = 0
    return -1 if total_gas < total_cost else start

-----
def can_complete_circuit(gas, cost):
    # Your code here


************************************
Question ID: 135
def min_candies(ratings):
    n = len(ratings)
    candies = [1] * n

    for i in range(1, n):
        if ratings[i] > ratings[i - 1]:
            candies[i] = candies[i - 1] + 1

    for i in range(n - 2, -1, -1):
        if ratings[i] > ratings[i + 1]:
            candies[i] = max(candies[i], candies[i + 1] + 1)

    return sum(candies)

-----
def min_candies(ratings):
    # Your code here


************************************
Question ID: 136
def singleNumber(nums):
    result = 0
    for num in nums:
        result ^= num
    return result

-----
def singleNumber(nums):
    # Your code here


************************************
Question ID: 137
def singleNumber(nums):
    ones, twos = 0, 0
    for n in nums:
        ones = (ones ^ n) & ~twos
        twos = (twos ^ n) & ~ones
    return ones

-----
def singleNumber(nums):
    # Your code here


************************************
Question ID: 139
def word_break(s, word_dict):
    word_set = set(word_dict)
    dp = [False] * (len(s) + 1)
    dp[0] = True
    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in word_set:
                dp[i] = True
                break
    return dp[len(s)]


-----
def word_break(s, word_dict):
    # Your code here


************************************
Question ID: 140
def word_break(s, word_dict):
    def helper(s, dict, memo):
        if s in memo:
            return memo[s]

        res = []
        if s in dict:
            res.append(s)

        for i in range(1, len(s)):
            prefix = s[:i]
            if prefix not in dict:
                continue
            suffix = s[i:]
            temp = helper(suffix, dict, memo)
            for t in temp:
                res.append(prefix + " " + t)

        memo[s] = res
        return res

    word_set = set(word_dict)
    memo = {}
    return helper(s, word_set, memo)

-----
def word_break(s, word_dict):
    # Your code here


************************************
Question ID: 141
def hasCycle(head):
    slow = fast = head
    while fast is not None and fast.next is not None:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False

-----
def hasCycle(head):
    # Your code here


************************************
Question ID: 146
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.cache = OrderedDict()
        self.capacity = capacity

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        value = self.cache.pop(key)
        self.cache[key] = value
        return value

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.pop(key)
        elif len(self.cache) >= self.capacity:
            self.cache.popitem(last=False)
        self.cache[key] = value


-----
from collections import OrderedDict
    # Your code here


************************************
Question ID: 149
from math import gcd
from collections import defaultdict

def maxPoints(points):
    n = len(points)
    if n <= 2:
        return n

    max_count = 0

    for i in range(n):
        slope_map = defaultdict(int)
        duplicates = 0
        local_max = 0

        for j in range(i+1, n):
            deltaX = points[j][0] - points[i][0]
            deltaY = points[j][1] - points[i][1]

            if deltaX == 0 and deltaY == 0:
                duplicates += 1
                continue

            g = gcd(deltaX, deltaY)
            deltaX = deltaX // g
            deltaY = deltaY // g

            key = f"{deltaX}_{deltaY}"
            slope_map[key] += 1
            local_max = max(local_max, slope_map[key])

        max_count = max(max_count, local_max + duplicates + 1)

    return max_count


-----
from math import gcd
    # Your code here


************************************
Question ID: 150
def evalRPN(tokens):
    stack = []
    for token in tokens:
        if token in {"+", "-", "*", "/"}:
            b = stack.pop()
            a = stack.pop()
            if token == "+":
                stack.append(a + b)
            elif token == "-":
                stack.append(a - b)
            elif token == "*":
                stack.append(a * b)
            else:
                stack.append(int(a / b))
        else:
            stack.append(int(token))
    return stack[-1]

-----
def evalRPN(tokens):
    # Your code here


************************************
Question ID: 151
def reverseWords(s):
    words = s.split()
    words.reverse()
    return ' '.join(words)

-----
def reverseWords(s):
    # Your code here


************************************
Question ID: 152
def maxProduct(nums):
    max_so_far = min_so_far = result = nums[0]
    
    for i in range(1, len(nums)):
        if nums[i] < 0:
            max_so_far, min_so_far = min_so_far, max_so_far
        
        max_so_far = max(nums[i], max_so_far * nums[i])
        min_so_far = min(nums[i], min_so_far * nums[i])
        result = max(result, max_so_far)
    
    return result


-----
def maxProduct(nums):
    # Your code here


************************************
Question ID: 153
def find_min(nums):
    left, right = 0, len(nums) - 1

    while left < right:
        mid = left + (right - left) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]

-----
def find_min(nums):
    # Your code here


************************************
Question ID: 154
def findMin(nums):
    low, high = 0, len(nums) - 1
    
    while low < high:
        mid = low + (high - low) // 2
        if nums[mid] > nums[high]:
            low = mid + 1
        elif nums[mid] < nums[high]:
            high = mid
        else:
            high -= 1
            
    return nums[low]

-----
def findMin(nums):
    # Your code here


************************************
Question ID: 157
def read4(buf4: List[str]) -> int:
    pass

def read(buf: List[str], n: int) -> int:
    total_read = 0
    buf4 = [''] * 4

    while total_read < n:
        read4_count = read4(buf4)
        for i in range(read4_count):
            if total_read < n:
                buf[total_read] = buf4[i]
                total_read += 1
            else:
                break
        if read4_count < 4:
            break

    return total_read

-----
def read4(buf4: List[str]) -> int:
    # Your code here


************************************
Question ID: 159
def lengthOfLongestSubstringTwoDistinct(s: str) -> int:
    l, r, max_len, cur_len = 0, 0, 0, 0
    char_count = {}

    while r < len(s):
        if s[r] in char_count:
            char_count[s[r]] += 1
        else:
            char_count[s[r]] = 1
        if len(char_count) <= 2:
            cur_len += 1
        else:
            while len(char_count) > 2 and l <= r:
                char_count[s[l]] -= 1
                if char_count[s[l]] == 0:
                    del char_count[s[l]]
                l += 1
                cur_len -= 1
            cur_len += 1
        max_len = max(max_len, cur_len)
        r += 1
    return max_len

-----
def lengthOfLongestSubstringTwoDistinct(s: str) -> int:
    # Your code here


************************************
Question ID: 161
def isOneEditDistance(s: str, t: str) -> bool:
    m, n = len(s), len(t)
    if m > n:
        return isOneEditDistance(t, s)
    if n - m > 1:
        return False
    for i in range(m):
        if s[i] != t[i]:
            return s[i + (m < n):] == t[i + 1:]
    return m + 1 == n

-----
def isOneEditDistance(s: str, t: str) -> bool:
    # Your code here


************************************
Question ID: 162
def findPeakElement(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = left + (right - left) // 2
        if nums[mid] < nums[mid + 1]:
            left = mid + 1
        else:
            right = mid
    return left

-----
def findPeakElement(nums):
    # Your code here


************************************
Question ID: 163
from typing import List

def find_missing_ranges(nums: List[int], lower: int, upper: int) -> List[str]:
    result = []
    prev = lower - 1

    for i, num in enumerate(nums + [upper + 1]):
        if num - prev >= 2:
            result.append(f"{prev + 1}" + ("" if num - prev == 2 else "->") + f"{num - 1}")
        prev = num

    return result

-----
from typing import List
    # Your code here


************************************
Question ID: 164
def maximumGap(nums):
    if len(nums) < 2:
        return 0

    min_val = min(nums)
    max_val = max(nums)
    length = len(nums)
    bucket_size = max(1, (max_val - min_val) // (length - 1))
    bucket_num = (max_val - min_val) // bucket_size + 1
    buckets = [[float("inf"), float("-inf")] for _ in range(bucket_num)]

    for num in nums:
        idx = (num - min_val) // bucket_size
        buckets[idx][0] = min(buckets[idx][0], num)
        buckets[idx][1] = max(buckets[idx][1], num)

    max_gap = 0
    prev_max = min_val
    for bucket in buckets:
        if bucket[0] == float("inf"):
            continue
        max_gap = max(max_gap, bucket[0] - prev_max)
        prev_max = bucket[1]
    return max_gap

-----
def maximumGap(nums):
    # Your code here


************************************
Question ID: 165
def compare_version(version1, version2):
    v1 = version1.split('.')
    v2 = version2.split('.')
    
    while v1 or v2:
        num1 = int(v1.pop(0)) if v1 else 0
        num2 = int(v2.pop(0)) if v2 else 0
        
        if num1 < num2:
            return -1
        if num1 > num2:
            return 1
    return 0

-----
def compare_version(version1, version2):
    # Your code here


************************************
Question ID: 166
def fraction_to_decimal(numerator, denominator):
    if numerator == 0:
        return "0"
    res = []
    if (numerator > 0) ^ (denominator > 0):
        res.append("-")
    num = abs(numerator)
    den = abs(denominator)
    res.append(str(num // den))
    num %= den
    if num == 0:
        return "".join(res)
    res.append(".")
    map = {}
    while num:
        if num in map:
            res.insert(map[num], "(")
            res.append(")")
            break
        map[num] = len(res)
        num *= 10
        res.append(str(num // den))
        num %= den
    return "".join(res)


-----
def fraction_to_decimal(numerator, denominator):
    # Your code here


************************************
Question ID: 167
def twoSum(numbers, target):
    left, right = 0, len(numbers) - 1
    while left < right:
        current_sum = numbers[left] + numbers[right]
        if current_sum == target:
            return [left + 1, right + 1]
        elif current_sum < target:
            left += 1
        else:
            right -= 1
    return []

-----
def twoSum(numbers, target):
    # Your code here


************************************
Question ID: 168
def convert_to_title(columnNumber: int) -> str:
    result = ""
    while columnNumber:
        columnNumber -= 1
        result = chr(columnNumber % 26 + ord('A')) + result
        columnNumber //= 26
    return result


-----
def convert_to_title(columnNumber: int) -> str:
    # Your code here


************************************
Question ID: 169
def majority_element(nums):
    count = 0
    candidate = None

    for num in nums:
        if count == 0:
            candidate = num
        count += (num == candidate) - (num != candidate)

    return candidate

-----
def majority_element(nums):
    # Your code here


************************************
Question ID: 171
def title_to_number(column_title: str) -> int:
    result = 0
    for c in column_title:
        result = result * 26 + (ord(c) - ord('A') + 1)
    return result

-----
def title_to_number(column_title: str) -> int:
    # Your code here


************************************
Question ID: 172
def trailing_zeroes(n: int) -> int:
    count = 0
    while n > 0:
        n //= 5
        count += n
    return count


-----
def trailing_zeroes(n: int) -> int:
    # Your code here


************************************
Question ID: 174
def calculateMinimumHP(dungeon):
    m, n = len(dungeon), len(dungeon[0])
    dp = [[0] * n for _ in range(m)]

    for i in range(m - 1, -1, -1):
        for j in range(n - 1, -1, -1):
            if i == m - 1 and j == n - 1:
                dp[i][j] = min(0, dungeon[i][j])
            elif i == m - 1:
                dp[i][j] = min(0, dp[i][j + 1] + dungeon[i][j])
            elif j == n - 1:
                dp[i][j] = min(0, dp[i + 1][j] + dungeon[i][j])
            else:
                dp[i][j] = min(0, max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j])

    return abs(dp[0][0]) + 1

-----
def calculateMinimumHP(dungeon):
    # Your code here


************************************
Question ID: 179
from functools import cmp_to_key

def largestNumber(nums):
    def comparator(a, b):
        return -1 if a + b > b + a else int(a + b < b + a)

    nums_as_str = list(map(str, nums))
    nums_as_str.sort(key=cmp_to_key(comparator))
    return '0' if nums_as_str[0] == "0" else "".join(nums_as_str)

-----
from functools import cmp_to_key
    # Your code here


************************************
Question ID: 186
def reverseWords(s: list) -> None:
    def reverse(s, start, end):
        while start < end:
            s[start], s[end] = s[end], s[start]
            start += 1
            end -= 1

    reverse(s, 0, len(s)-1)
    start = 0
    for i, char in enumerate(s + [' ']):
        if char == ' ':
            reverse(s, start, i - 1)
            start = i + 1

-----
def reverseWords(s: list) -> None:
    # Your code here


************************************
Question ID: 187
from collections import defaultdict

def findRepeatedDnaSequences(s: str):
    dna_counter = defaultdict(int)
    result = []

    for i in range(len(s) - 9):
        sequence = s[i:i + 10]
        dna_counter[sequence] += 1
        if dna_counter[sequence] == 2:
            result.append(sequence)

    return result

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 188
def maxProfit(k, prices):
    n = len(prices)
    if k > n // 2:
        return sum(max(prices[i] - prices[i - 1], 0) for i in range(1, n))

    dp = [[0] * n for _ in range(k + 1)]
    for i in range(1, k + 1):
        max_diff = -prices[0]
        for j in range(1, n):
            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)
            max_diff = max(max_diff, dp[i - 1][j] - prices[j])
    return dp[k][n - 1]

-----
def maxProfit(k, prices):
    # Your code here


************************************
Question ID: 189
def rotate(nums, k):
    n = len(nums)
    k %= n
    nums[:] = nums[-k:] + nums[:-k]

-----
def rotate(nums, k):
    # Your code here


************************************
Question ID: 190
def reverse_bits(n: int) -> int:
    res = 0
    for _ in range(32):
        res <<= 1
        res |= n & 1
        n >>= 1
    return res

-----
def reverse_bits(n: int) -> int:
    # Your code here


************************************
Question ID: 191
def hamming_weight(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count

-----
def hamming_weight(n):
    # Your code here


************************************
Question ID: 194
def transpose(content):
    data = [line.split(" ") for line in content]
    result = [" ".join(data[j][i] for j in range(len(data))) for i in range(len(data[0]))]
    return result


-----
def transpose(content):
    # Your code here


************************************
Question ID: 198
def rob(nums):
    prev1, prev2 = 0, 0
    for num in nums:
        prev1, prev2 = max(prev2 + num, prev1), prev1
    return prev1

-----
def rob(nums):
    # Your code here


************************************
Question ID: 200
def dfs(grid, i, j):
    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':
        return

    grid[i][j] = '0'
    dfs(grid, i + 1, j)
    dfs(grid, i - 1, j)
    dfs(grid, i, j + 1)
    dfs(grid, i, j - 1)

def numIslands(grid):
    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                count += 1
                dfs(grid, i, j)
    return count

-----
def dfs(grid, i, j):
    # Your code here


************************************
Question ID: 201
def range_bitwise_and(left: int, right: int) -> int:
    shift = 0
    while left != right:
        left >>= 1
        right >>= 1
        shift += 1
    return left << shift

-----
def range_bitwise_and(left: int, right: int) -> int:
    # Your code here


************************************
Question ID: 202
def get_next(n):
    sum = 0
    while n > 0:
        digit = n % 10
        sum += digit * digit
        n //= 10
    return sum

def is_happy(n):
    slow, fast = n, get_next(n)
    while fast != 1 and slow != fast:
        slow = get_next(slow)
        fast = get_next(get_next(fast))
    return fast == 1

-----
def get_next(n):
    # Your code here


************************************
Question ID: 204
def countPrimes(n: int) -> int:
    if n <= 2:
        return 0
    is_prime = [True] * n
    is_prime[0] = is_prime[1] = False
    for i in range(2, int(n**0.5) + 1):
        if is_prime[i]:
            for j in range(i * i, n, i):
                is_prime[j] = False
    return sum(is_prime)

-----
def countPrimes(n: int) -> int:
    # Your code here


************************************
Question ID: 205
def is_isomorphic(s: str, t: str) -> bool:
    map1, map2 = {}, {}
    for char_s, char_t in zip(s, t):
        if char_s not in map1:
            map1[char_s] = char_t
        if char_t not in map2:
            map2[char_t] = char_s
        if map1[char_s] != char_t or map2[char_t] != char_s:
            return False
    return True

-----
def is_isomorphic(s: str, t: str) -> bool:
    # Your code here


************************************
Question ID: 207
from collections import defaultdict, deque

def canFinish(numCourses, prerequisites):
    adj = defaultdict(list)
    inDegree = [0] * numCourses
    
    for a, b in prerequisites:
        adj[b].append(a)
        inDegree[a] += 1
    
    q = deque([i for i in range(numCourses) if inDegree[i]==0])
    
    while q:
        currCourse = q.popleft()
        numCourses -= 1
        
        for nextCourse in adj[currCourse]:
            inDegree[nextCourse] -= 1
            if inDegree[nextCourse] == 0:
                q.append(nextCourse)
    
    return numCourses == 0


-----
from collections import defaultdict, deque
    # Your code here


************************************
Question ID: 209
def minSubArrayLen(target: int, nums: List[int]) -> int:
    left, cur_sum, min_len = 0, 0, float('inf')
    for right in range(len(nums)):
        cur_sum += nums[right]
        while cur_sum >= target:
            min_len = min(min_len, right - left + 1)
            cur_sum -= nums[left]
            left += 1
    return min_len if min_len != float('inf') else 0

-----
def minSubArrayLen(target: int, nums: List[int]) -> int:
    # Your code here


************************************
Question ID: 210
from collections import deque

def findOrder(numCourses, prerequisites):
    in_degree = [0] * numCourses
    adj_list = [[] for _ in range(numCourses)]
    
    for p in prerequisites:
        adj_list[p[1]].append(p[0])
        in_degree[p[0]] += 1
    
    q = deque([i for i in range(numCourses) if in_degree[i] == 0])
    order = []
    
    while q:
        curr = q.popleft()
        order.append(curr)
        for next in adj_list[curr]:
            in_degree[next] -= 1
            if in_degree[next] == 0:
                q.append(next)
    
    return order if len(order) == numCourses else []


-----
from collections import deque
    # Your code here


************************************
Question ID: 212
def findWords(board, words):
    def dfs(board, word, index, i, j, visited):
        if index == len(word):
            return True
        if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or visited[i][j] or board[i][j] != word[index]:
            return False
        visited[i][j] = True
        found = dfs(board, word, index + 1, i - 1, j, visited) or \
                dfs(board, word, index + 1, i + 1, j, visited) or \
                dfs(board, word, index + 1, i, j - 1, visited) or \
                dfs(board, word, index + 1, i, j + 1, visited)
        visited[i][j] = False
        return found

    res = []
    for word in words:
        if any(dfs(board, word, 0, i, j, [[False] * len(board[0]) for _ in range(len(board))])
               for i in range(len(board)) for j in range(len(board[0]))):
            res.append(word)
    return res


-----
def findWords(board, words):
    # Your code here


************************************
Question ID: 213
def rob(nums):
    if len(nums) == 1:
        return nums[0]
    prev, curr = 0, 0
    for i in range(len(nums) - 1):
        temp = max(curr, prev + nums[i])
        prev, curr = curr, temp
    res = curr
    prev, curr = 0, 0
    for i in range(1, len(nums)):
        temp = max(curr, prev + nums[i])
        prev, curr = curr, temp
    return max(res, curr)

-----
def rob(nums):
    # Your code here


************************************
Question ID: 214
def shortest_palindrome(s: str) -> str:
    n = len(s)
    rev_s = s[::-1]
    
    for i in range(n):
        if s[:n - i] == rev_s[i:]:
            return rev_s[:i] + s
    return ""


-----
def shortest_palindrome(s: str) -> str:
    # Your code here


************************************
Question ID: 215
def findKthLargest(nums: List[int], k: int) -> int:
    nums.sort(reverse=True)
    return nums[k-1]

-----
def findKthLargest(nums: List[int], k: int) -> int:
    # Your code here


************************************
Question ID: 216
def combinationSum3(k, n):
    def helper(k, n, current, current_comb, result):
        if k == 0 and n == 0:
            result.append(list(current_comb))
        elif k > 0 and n > 0:
            for i in range(current + 1, 10):
                current_comb.append(i)
                helper(k - 1, n - i, i, current_comb, result)
                current_comb.pop()

    result = []
    helper(k, n, 0, [], result)
    return result


-----
def combinationSum3(k, n):
    # Your code here


************************************
Question ID: 217
def containsDuplicate(nums):
    return len(nums) != len(set(nums))


-----
def containsDuplicate(nums):
    # Your code here


************************************
Question ID: 218
from sortedcontainers import SortedList

def getSkyline(buildings):
    points = []
    for l, r, h in buildings:
        points.append((l, -h))
        points.append((r, h))
    points.sort()
    heights = SortedList([0])
    prev = 0
    skyline = []
    for x, h in points:
        if h < 0:
            heights.add(-h)
        else:
            heights.remove(h)
        cur = heights[-1]
        if cur != prev:
            skyline.append([x, cur])
            prev = cur
    return skyline

-----
from sortedcontainers import SortedList
    # Your code here


************************************
Question ID: 219
def containsNearbyDuplicate(nums, k):
    value_index_map = {}
    for i, num in enumerate(nums):
        if num in value_index_map and i - value_index_map[num] <= k:
            return True
        value_index_map[num] = i
    return False

-----
def containsNearbyDuplicate(nums, k):
    # Your code here


************************************
Question ID: 220
from sortedcontainers import SortedList

def containsNearbyAlmostDuplicate(nums, k, t):
    window = SortedList()
    for i in range(len(nums)):
        if i > k:
            window.remove(nums[i - k - 1])
        pos = window.bisect_left(nums[i] - t)
        if pos != len(window) and window[pos] - nums[i] <= t:
            return True
        window.add(nums[i])
    return False

-----
from sortedcontainers import SortedList
    # Your code here


************************************
Question ID: 221
def maximalSquare(matrix):
    m, n = len(matrix), len(matrix[0])
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    maxSize = 0

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if matrix[i - 1][j - 1] == '1':
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
                maxSize = max(maxSize, dp[i][j])

    return maxSize * maxSize

-----
def maximalSquare(matrix):
    # Your code here


************************************
Question ID: 223
def total_area(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):
    area1 = (ax2 - ax1) * (ay2 - ay1)
    area2 = (bx2 - bx1) * (by2 - by1)

    overlap_width = min(ax2, bx2) - max(ax1, bx1)
    overlap_height = min(ay2, by2) - max(ay1, by1)

    overlap_area = max(overlap_width, 0) * max(overlap_height, 0)

    return area1 + area2 - overlap_area


-----
def total_area(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):
    # Your code here


************************************
Question ID: 224
def calculate(s: str) -> int:
    result = 0
    sign = 1
    num = 0
    st = []
    for c in s:
        if c.isdigit():
            num = num * 10 + int(c)
        else:
            result += sign * num
            num = 0
            if c == '+':
                sign = 1
            elif c == '-':
                sign = -1
            elif c == '(':
                st.append(result)
                st.append(sign)
                result = 0
                sign = 1
            elif c == ')':
                prev_sign = st.pop()
                prev_result = st.pop()
                result = prev_result + prev_sign * result
    result += sign * num
    return result

-----
def calculate(s: str) -> int:
    # Your code here


************************************
Question ID: 225
from collections import deque

class MyStack:

    def __init__(self):
        self.q1 = deque()
        self.q2 = deque()

    def push(self, x: int) -> None:
        self.q2.append(x)
        while self.q1:
            self.q2.append(self.q1.popleft())
        self.q1, self.q2 = self.q2, self.q1

    def pop(self) -> int:
        return self.q1.popleft()

    def top(self) -> int:
        return self.q1[0]

    def empty(self) -> bool:
        return not self.q1

-----
from collections import deque
    # Your code here


************************************
Question ID: 227
def calculate(s: str) -> int:
    result, num, sign, stack = 0, 0, 1, []

    for c in s:
        if c.isdigit():
            num = num * 10 + int(c)
        elif c == '+':
            result += sign * num
            num = 0
            sign = 1
        elif c == '-':
            result += sign * num
            num = 0
            sign = -1
        elif c == '(':
            stack.append(result)
            stack.append(sign)
            result = 0
            sign = 1
        elif c == ')':
            result += sign * num
            num = 0
            result *= stack.pop()
            result += stack.pop()
    
    if num:
        result += sign * num
        
    return result

-----
def calculate(s: str) -> int:
    # Your code here


************************************
Question ID: 228
from typing import List

def find_ranges(nums: List[int]) -> List[str]:
    result = []
    n = len(nums)
    if n == 0: 
        return result

    start = nums[0]
    for i in range(1, n):
        if nums[i] > nums[i-1] + 1:
            if start == nums[i-1]:
                result.append(str(start))
            else:
                result.append(str(start) + "->" + str(nums[i-1]))
            start = nums[i]

    if start == nums[n-1]:
        result.append(str(start))
    else:
        result.append(str(start) + "->" + str(nums[n-1]))

    return result

-----
from typing import List
    # Your code here


************************************
Question ID: 229
def majorityElement(nums):
    n = len(nums)
    count = {}
    result = []

    for num in nums:
        if num not in count:
            count[num] = 1
        else:
            count[num] += 1
        if count[num] > n / 3 and num not in result:
            result.append(num)

    return result

-----
def majorityElement(nums):
    # Your code here


************************************
Question ID: 231
def is_power_of_two(n):
    if n <= 0:
        return False
    return (n & (n - 1)) == 0

-----
def is_power_of_two(n):
    # Your code here


************************************
Question ID: 233
def countDigitOne(n):
    count = 0
    i = 1
    while i <= n:
        divider = i * 10
        count += (n // divider) * i + min(max(n % divider - i + 1, 0), i)
        i *= 10
    return count

-----
def countDigitOne(n):
    # Your code here


************************************
Question ID: 237
def deleteNode(node):
    next_node = node.next
    node.val = next_node.val
    node.next = next_node.next

-----
def deleteNode(node):
    # Your code here


************************************
Question ID: 238
def productExceptSelf(nums):
    n = len(nums)
    answer = [1] * n
    
    left = 1
    for i in range(n):
        answer[i] *= left
        left *= nums[i]
    
    right = 1
    for i in range(n - 1, -1, -1):
        answer[i] *= right
        right *= nums[i]
    
    return answer

-----
def productExceptSelf(nums):
    # Your code here


************************************
Question ID: 239
from collections import deque

def maxSlidingWindow(nums, k):
    dq = deque()
    result = []

    for i in range(len(nums)):
        while dq and dq[0] < i - k + 1:
            dq.popleft()

        while dq and nums[dq[-1]] < nums[i]:
            dq.pop()

        dq.append(i)

        if i >= k - 1:
            result.append(nums[dq[0]])

    return result


-----
from collections import deque
    # Your code here


************************************
Question ID: 240
def searchMatrix(matrix, target):
    row, col = len(matrix) - 1, 0
    while row >= 0 and col < len(matrix[0]):
        if matrix[row][col] > target:
            row -= 1
        elif matrix[row][col] < target:
            col += 1
        else:
            return True
    return False

-----
def searchMatrix(matrix, target):
    # Your code here


************************************
Question ID: 241
def diffWaysToCompute(input: str):
    result = []
    for i in range(len(input)):
        c = input[i]
        if c == '+' or c == '-' or c == '*':
            left = diffWaysToCompute(input[:i])
            right = diffWaysToCompute(input[i + 1:])
            for l in left:
                for r in right:
                    if c == '+': result.append(l + r)
                    elif c == '-': result.append(l - r)
                    elif c == '*': result.append(l * r)
    if not result:
        result.append(int(input))
    return result

-----
def diffWaysToCompute(input: str):
    # Your code here


************************************
Question ID: 242
def is_anagram(s, t):
    if len(s) != len(t):
        return False

    counts = {}
    for c in s:
        if c in counts:
            counts[c] += 1
        else:
            counts[c] = 1

    for c in t:
        if c not in counts or counts[c] == 0:
            return False
        counts[c] -= 1

    return True

-----
def is_anagram(s, t):
    # Your code here


************************************
Question ID: 243
def shortestDistance(wordsDict, word1, word2):
    idx1, idx2, minDistance = -1, -1, float('inf')
    for i, word in enumerate(wordsDict):
        if word == word1:
            idx1 = i
        if word == word2:
            idx2 = i
        if idx1 != -1 and idx2 != -1:
            minDistance = min(minDistance, abs(idx1 - idx2))
    return minDistance

-----
def shortestDistance(wordsDict, word1, word2):
    # Your code here


************************************
Question ID: 245
def shortest_distance(words_dict, word1, word2):
    index1, index2, min_distance = -1, -1, float('inf')
    for i, word in enumerate(words_dict):
        if word == word1:
            index1 = i
        if word == word2:
            index2 = i
        if index1 != -1 and(index2 != -1):
            min_distance = min(min_distance, abs(index1 - index2))
    return min_distance

-----
def shortest_distance(words_dict, word1, word2):
    # Your code here


************************************
Question ID: 246
def isStrobogrammatic(num: str) -> bool:
    lookup = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}
    left, right = 0, len(num) - 1
    while left <= right:
        if num[left] not in lookup or lookup[num[left]] != num[right]:
            return False
        left += 1
        right -= 1
    return True

-----
def isStrobogrammatic(num: str) -> bool:
    # Your code here


************************************
Question ID: 247
def findStrobogrammatic(n):
    def helper(n, m):
        if n == 0:
            return [""]
        if n == 1:
            return ["0", "1", "8"]

        list = helper(n - 2, m)
        res = []

        for s in list:
            if n != m:
                res.append("0" + s + "0")

            res.append("1" + s + "1")
            res.append("6" + s + "9")
            res.append("8" + s + "8")
            res.append("9" + s + "6")

        return res

    return helper(n, n)

-----
def findStrobogrammatic(n):
    # Your code here


************************************
Question ID: 248
def strobogrammaticInRange(low, high):
    count = 0
    for len in range(len(low), len(high)+1):
        count += 1 if low <= helper(len, len) <= high else 0
    return count

def helper(m, n):
    if m == 0:
        return ""
    if m == 1:
        return "0 1 8"
    if n == 0:
        return "11 69 88 96"
    res = ""
    for a in helper(m-2, n).split():
        if m != n:
            res += a + "0" + a + " "
        res += a + "1" + a + " "
        res += a + "6" + a + " "
        res += a + "8" + a + " "
        res += a + "9" + a + " "
    return res


-----
def strobogrammaticInRange(low, high):
    # Your code here


************************************
Question ID: 249
from collections import defaultdict

def groupStrings(strings):
    groups = defaultdict(list)

    for s in strings:
        key = tuple((ord(c) - ord(s[0])) % 26 for c in s)
        groups[key].append(s)

    return list(groups.values())

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 252
def can_attend_meetings(intervals):
    intervals.sort()

    for i in range(1, len(intervals)):
        if intervals[i][0] < intervals[i - 1][1]:
            return False

    return True

-----
def can_attend_meetings(intervals):
    # Your code here


************************************
Question ID: 253
import heapq

def minMeetingRooms(intervals):
    if not intervals:
        return 0

    intervals.sort(key=lambda x: x[0])

    min_heap = [intervals[0][1]]
    for start, end in intervals[1:]:
        if start >= min_heap[0]:
            heapq.heappop(min_heap)
        heapq.heappush(min_heap, end)

    return len(min_heap)

-----
import heapq
    # Your code here


************************************
Question ID: 254
def getFactors(n):
    def helper(n, start, path, result):
        if n == 1:
            if len(path) > 1:
                result.append(path[:])
            return

        for i in range(start, n + 1):
            if n % i == 0:
                path.append(i)
                helper(n // i, i, path, result)
                path.pop()

    result = []
    helper(n, 2, [], result)
    return result

-----
def getFactors(n):
    # Your code here


************************************
Question ID: 255
def isValidPreorder(preorder: List[int]) -> bool:
    stack = []
    lower_bound = float('-inf')
    for num in preorder:
        if num < lower_bound:
            return False
        while stack and num > stack[-1]:
            lower_bound = stack.pop()
        stack.append(num)
    return True

-----
def isValidPreorder(preorder: List[int]) -> bool:
    # Your code here


************************************
Question ID: 256
def minCost(costs: List[List[int]]) -> int:
    if not costs:
        return 0
    for i in range(1, len(costs)):
        costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])
        costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])
        costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])
    return min(costs[-1][0], costs[-1][1], costs[-1][2])

-----
def minCost(costs: List[List[int]]) -> int:
    # Your code here


************************************
Question ID: 258
def addDigits(num: int) -> int:
    return 1 + (num - 1) % 9

-----
def addDigits(num: int) -> int:
    # Your code here


************************************
Question ID: 259
def threeSumSmaller(nums, target):
    count = 0
    nums.sort()
    for i in range(len(nums)):
        j, k = i + 1, len(nums) - 1
        while j < k:
            if nums[i] + nums[j] + nums[k] < target:
                count += k - j
                j += 1
            else:
                k -= 1
    return count

-----
def threeSumSmaller(nums, target):
    # Your code here


************************************
Question ID: 260
def singleNumber(nums):
    xor_all = 0
    for num in nums:
        xor_all ^= num

    bit = xor_all & -xor_all
    n1 = 0
    n2 = 0
    for num in nums:
        if num & bit:
            n1 ^= num
        else:
            n2 ^= num

    return n1, n2

-----
def singleNumber(nums):
    # Your code here


************************************
Question ID: 261
from typing import List

def isTree(n: int, edges: List[List[int]]) -> bool:
    neighbors = [[] for _ in range(n)]
    for edge in edges:
        neighbors[edge[0]].append(edge[1])
        neighbors[edge[1]].append(edge[0])
    visited = [False] * n
    if hasCycle(neighbors, visited, -1, 0): return False
    return all(visited)

def hasCycle(neighbors: List[List[int]], visited: List[bool], parent: int, node: int) -> bool:
    visited[node] = True
    for neighbor in neighbors[node]:
        if (neighbor != parent and visited[neighbor]) or (not visited[neighbor] and hasCycle(neighbors, visited, node, neighbor)): return True
    return False

-----
from typing import List
    # Your code here


************************************
Question ID: 263
def is_ugly(n: int) -> bool:
    if n <= 0:
        return False
    for factor in [2, 3, 5]:
        while n % factor == 0:
            n //= factor
    return n == 1

-----
def is_ugly(n: int) -> bool:
    # Your code here


************************************
Question ID: 264
def nthUglyNumber(n: int) -> int:
    ugly_numbers = [0] * n
    ugly_numbers[0] = 1
    i2, i3, i5 = 0, 0, 0

    for i in range(1, n):
        ugly_numbers[i] = min(ugly_numbers[i2] * 2, ugly_numbers[i3] * 3, ugly_numbers[i5] * 5)
        if ugly_numbers[i] == ugly_numbers[i2] * 2: i2 += 1
        if ugly_numbers[i] == ugly_numbers[i3] * 3: i3 += 1
        if ugly_numbers[i] == ugly_numbers[i5] * 5: i5 += 1

    return ugly_numbers[n - 1]



-----
def nthUglyNumber(n: int) -> int:
    # Your code here


************************************
Question ID: 265
def min_cost(costs: List[List[int]]) -> int:
    if not costs:
        return 0

    n, k = len(costs), len(costs[0])

    for i in range(1, n):
        for j in range(k):
            min_cost = float("inf")
            for l in range(k):
                if l == j:
                    continue
                min_cost = min(min_cost, costs[i - 1][l])
            costs[i][j] += min_cost

    return min(costs[n - 1])


-----
def min_cost(costs: List[List[int]]) -> int:
    # Your code here


************************************
Question ID: 266
def canPermutePalindrome(s: str) -> bool:
    count = {}
    for c in s:
        if c in count:
            count[c] += 1
        else:
            count[c] = 1
    odd_count = 0
    for value in count.values():
        if value % 2:
            odd_count += 1
    return odd_count <= 1

-----
def canPermutePalindrome(s: str) -> bool:
    # Your code here


************************************
Question ID: 267
from collections import Counter
from itertools import permutations

def generatePalindromes(s):
    result = []
    char_count = Counter(s)

    mid_char = ""
    half_str = []
    num_ocurrences = 0

    for char, count in char_count.items():
        if count % 2 == 1:
            num_ocurrences += 1
            mid_char = char
        half_str.extend([char] * (count // 2))

        if num_ocurrences > 1:
            return result

    for perm in set(permutations(half_str)):
        palindrome = "".join(perm) + mid_char + "".join(reversed(perm))
        result.append(palindrome)

    return result

-----
from collections import Counter
    # Your code here


************************************
Question ID: 268
def missingNumber(nums):
    n = len(nums)
    expected_sum = (n * (n + 1)) // 2
    actual_sum = sum(nums)
    return expected_sum - actual_sum

-----
def missingNumber(nums):
    # Your code here


************************************
Question ID: 269
from collections import deque, defaultdict, Counter

def alienOrder(words):
    graph = defaultdict(set)
    in_degree = Counter({c: 0 for word in words for c in word})
    
    for word1, word2 in zip(words, words[1:]):
        found = False
        for c1, c2 in zip(word1, word2):
            if c1 != c2:
                if c2 not in graph[c1]:
                    graph[c1].add(c2)
                    in_degree[c2] += 1
                found = True
                break
        if not found and len(word1) > len(word2):
            return ""
    
    q = deque([c for c in in_degree if in_degree[c] == 0])
    result = []
    while q:
        c = q.popleft()
        result.append(c)
        
        for neigh in graph[c]:
            in_degree[neigh] -= 1
            if in_degree[neigh] == 0:
                q.append(neigh)
                 
    if len(result) < len(in_degree):
        return ""
    
    return "".join(result)

-----
from collections import deque, defaultdict, Counter
    # Your code here


************************************
Question ID: 271
def encode(strs):
    encoded_string = ""
    for s in strs:
        encoded_string += str(len(s)) + "#" + s
    return encoded_string

def decode(s):
    strs = []
    i = 0
    while i < len(s):
        delimiter_pos = s.find('#', i)
        length = int(s[i:delimiter_pos])
        strs.append(s[delimiter_pos + 1:delimiter_pos + 1 + length])
        i = delimiter_pos + 1 + length
    return strs


-----
def encode(strs):
    # Your code here


************************************
Question ID: 272
from heapq import heappush, heappop

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def closestKValues(root, target, k):
    values = []
    max_heap = []

    def inorder_traverse(node):
        if not node:
            return
        inorder_traverse(node.left)
        heappush(max_heap, (-abs(node.val - target), node.val))
        if len(max_heap) > k:
            heappop(max_heap)
        inorder_traverse(node.right)

    inorder_traverse(root)
    while max_heap:
        _, val = heappop(max_heap)
        values.append(val)
    return values

-----
from heapq import heappush, heappop
    # Your code here


************************************
Question ID: 274
def hIndex(citations: List[int]) -> int:
    citations.sort(reverse=True)
    h = 0
    for i, citation in enumerate(citations):
        if citation >= i + 1:
            h = i + 1
        else:
            break
    return h

-----
def hIndex(citations: List[int]) -> int:
    # Your code here


************************************
Question ID: 275
def hIndex(citations: List[int]) -> int:
    n = len(citations)
    left, right = 0, n - 1

    while left <= right:
        mid = left + (right - left) // 2
        if citations[mid] == n - mid:
            return n - mid
        elif citations[mid] < n - mid:
            left = mid + 1
        else:
            right = mid - 1

    return n - left

-----
def hIndex(citations: List[int]) -> int:
    # Your code here


************************************
Question ID: 276
def numWays(n, k):
    if n == 0:
        return 0
    if n == 1:
        return k
    same = k
    different = k * (k - 1)
    for i in range(2, n):
        temp = different
        different = (same + different) * (k - 1)
        same = temp
    return same + different

-----
def numWays(n, k):
    # Your code here


************************************
Question ID: 277
def knows(a: int, b:int) -> bool:
    pass

def findCelebrity(n: int) -> int:
    candidate = 0
    for i in range(1, n):
        if knows(candidate, i):
            candidate = i
    
    for i in range(n):
        if i != candidate and (knows(candidate, i) or not knows(i, candidate)):
            return -1
    return candidate

-----
def knows(a: int, b:int) -> bool:
    # Your code here


************************************
Question ID: 278
def first_bad_version(n):
    left, right = 1, n
    while left < right:
        mid = left + (right - left) // 2
        if is_bad_version(mid):
            right = mid
        else:
            left = mid + 1
    return left


-----
def first_bad_version(n):
    # Your code here


************************************
Question ID: 279
def numSquares(n):
    dp = [float('inf')] * (n + 1)
    dp[0] = 0
    
    for i in range(1, n + 1):
        j = 1
        while j * j <= i:
            dp[i] = min(dp[i], dp[i - j * j] + 1)
            j += 1
            
    return dp[n]

-----
def numSquares(n):
    # Your code here


************************************
Question ID: 280
def wiggleSort(nums):
    for i in range(1, len(nums)):
        if (i % 2 == 0 and nums[i] > nums[i-1]) or (i % 2 == 1 and nums[i] < nums[i-1]):
            nums[i], nums[i-1] = nums[i-1], nums[i]

-----
def wiggleSort(nums):
    # Your code here


************************************
Question ID: 282
from typing import List

def addOperators(num: str, target: int) -> List[str]:
    def helper(num, target, pos, currVal, prevVal, currExpr):
        if pos == len(num):
            if currVal == target:
                res.append(currExpr)
            return

        for i in range(pos, len(num)):
            if i != pos and num[pos] == '0':
                break

            val = int(num[pos:i + 1])
            if pos == 0:
                helper(num, target, i + 1, val, val, currExpr + num[pos:i + 1])
            else:
                helper(num, target, i + 1, currVal + val, val, currExpr + "+" + num[pos:i + 1])
                helper(num, target, i + 1, currVal - val, -val, currExpr + "-" + num[pos:i + 1])
                helper(num, target, i + 1, currVal - prevVal + prevVal * val, prevVal * val, currExpr + "*" + num[pos:i + 1])

    res = []
    helper(num, target, 0, 0, 0, "")
    return res


-----
from typing import List
    # Your code here


************************************
Question ID: 283
def moveZeroes(nums):
    index = 0
    for i in range(len(nums)):
        if nums[i] != 0:
            nums[index] = nums[i]
            index += 1
    for i in range(index, len(nums)):
        nums[i] = 0

-----
def moveZeroes(nums):
    # Your code here


************************************
Question ID: 286
from collections import deque

def wallsAndGates(rooms):
    m, n = len(rooms), len(rooms[0])
    q = deque()
    INF = 2147483647

    for i in range(m):
        for j in range(n):
            if rooms[i][j] == 0:
                q.append((i, j))

    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    while q:
        i, j = q.popleft()

        for d in directions:
            ni, nj = i + d[0], j + d[1]

            if 0 <= ni < m and 0 <= nj < n and rooms[ni][nj] == INF:
                rooms[ni][nj] = rooms[i][j] + 1
                q.append((ni, nj))


-----
from collections import deque
    # Your code here


************************************
Question ID: 287
def findDuplicate(nums):
    slow = nums[0]
    fast = nums[0]

    while True:
        slow = nums[slow]
        fast = nums[nums[fast]]
        if slow == fast:
            break

    slow = nums[0]

    while slow != fast:
        slow = nums[slow]
        fast = nums[fast]

    return slow


-----
def findDuplicate(nums):
    # Your code here


************************************
Question ID: 289
def gameOfLife(board):
    m, n = len(board), len(board[0])
    result = [[0] * n for _ in range(m)]
    dirs = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]
    
    for i in range(m):
        for j in range(n):
            liveNeighbors = 0
            
            for dir in dirs:
                newRow = i + dir[0]
                newCol = j + dir[1]
                
                if newRow >= 0 and newRow < m and newCol >= 0 and newCol < n and board[newRow][newCol] == 1:
                    liveNeighbors += 1
            
            if board[i][j] == 1 and (liveNeighbors == 2 or liveNeighbors == 3):
                result[i][j] = 1
            elif board[i][j] == 0 and liveNeighbors == 3:
                result[i][j] = 1
                
    return result

-----
def gameOfLife(board):
    # Your code here


************************************
Question ID: 290
def word_pattern(pattern, s):
    words = s.split()
    if len(pattern) != len(words):
        return False

    char_map, word_map = {}, {}
    for c, word in zip(pattern, words):
        if c not in char_map and word not in word_map:
            char_map[c] = word
            word_map[word] = c
        else:
            if char_map.get(c) != word or word_map.get(word) != c:
                return False

    return True


-----
def word_pattern(pattern, s):
    # Your code here


************************************
Question ID: 291
def wordPatternMatch(pattern: str, s: str) -> bool:
    def backtrack(p_index, s_index, pattern_map, words):
        if p_index == len(pattern) and s_index == len(s):
            return True
        if p_index == len(pattern) or s_index == len(s):
            return False

        p = pattern[p_index]
        if p in pattern_map:
            word = pattern_map[p]
            if not s.startswith(word, s_index):
                return False
            return backtrack(p_index + 1, s_index + len(word), pattern_map, words)
        else:
            for length in range(1, len(s) - s_index + 1):
                word = s[s_index : s_index + length]
                if word in words:
                    continue
                pattern_map[p] = word
                words.add(word)
                if backtrack(p_index + 1, s_index + length, pattern_map, words):
                    return True
                pattern_map.pop(p)
                words.remove(word)
        return False

    return backtrack(0, 0, {}, set())

-----
def wordPatternMatch(pattern: str, s: str) -> bool:
    # Your code here


************************************
Question ID: 292
def canWinNim(n):
    return n % 4 != 0

-----
def canWinNim(n):
    # Your code here


************************************
Question ID: 293
def generate_possible_next_moves(current_state):
    result = []
    for i in range(1, len(current_state)):
        if current_state[i] == '+' and current_state[i - 1] == '+':
            result.append(current_state[:i - 1] + '--' + current_state[i + 1:])
    return result

-----
def generate_possible_next_moves(current_state):
    # Your code here


************************************
Question ID: 294
def canWin(currentState: str) -> bool:
    for i in range(len(currentState) - 1):
        if currentState[i] == '+' and currentState[i + 1] == '+':
            temp = currentState[:i] + "--" + currentState[i + 2:]
            if not canWin(temp):
                return True
    return False

-----
def canWin(currentState: str) -> bool:
    # Your code here


************************************
Question ID: 295
import heapq

class MedianFinder:
    def __init__(self):
        self.left = []  # max heap
        self.right = []  # min heap

    def addNum(self, num: int) -> None:
        if not self.left or num <= -self.left[0]:
            heapq.heappush(self.left, -num)
        else:
            heapq.heappush(self.right, num)
        
        if len(self.left) < len(self.right):
            heapq.heappush(self.left, -heapq.heappop(self.right))
        elif len(self.left) > len(self.right) + 1:
            heapq.heappush(self.right, -heapq.heappop(self.left))

    def findMedian(self) -> float:
        if len(self.left) == len(self.right):
            return (-self.left[0] + self.right[0]) / 2
        else:
            return -self.left[0]


-----
import heapq
    # Your code here


************************************
Question ID: 296
def minTotalDistance(grid):
    m, n = len(grid), len(grid[0])
    rows, cols = [], []
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                rows.append(i)
                cols.append(j)

    cols.sort()
    row_median, col_median = rows[len(rows) // 2], cols[len(cols) // 2]
    distance = sum(abs(i - row_median) for i in rows) + sum(abs(j - col_median) for j in cols)
    return distance

-----
def minTotalDistance(grid):
    # Your code here


************************************
Question ID: 299
def get_hint(secret: str, guess: str) -> str:
    bulls = cows = 0
    secret_count = [0] * 10
    guess_count = [0] * 10

    for i in range(len(secret)):
        if secret[i] == guess[i]:
            bulls += 1
        else:
            secret_count[int(secret[i])] += 1
            guess_count[int(guess[i])] += 1
   
    for i in range(10):
        cows += min(secret_count[i], guess_count[i])
    
    return f"{bulls}A{cows}B"


-----
def get_hint(secret: str, guess: str) -> str:
    # Your code here


************************************
Question ID: 300
def lengthOfLIS(nums):
    dp = [1] * len(nums)
    max_length = 1
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
        max_length = max(max_length, dp[i])
    return max_length

-----
def lengthOfLIS(nums):
    # Your code here


************************************
Question ID: 301
from collections import deque

class Solution:
    def removeInvalidParentheses(self, s: str):
        visited = set()
        queue = deque([s])
        result = []
        found = False

        while queue:
            cur = queue.popleft()

            if self.is_valid(cur):
                found = True
                result.append(cur)

            if found: continue

            for i in range(len(cur)):
                if cur[i] == '(' or cur[i] == ')':
                    next_str = cur[:i] + cur[i+1:]
                    if next_str not in visited:
                        visited.add(next_str)
                        queue.append(next_str)

        return result

    def is_valid(self, s: str) -> bool:
        count = 0
        for c in s:
            if c == '(': count += 1
            if c == ')':
                count -= 1
                if count < 0: return False
        return count == 0


-----
from collections import deque
    # Your code here


************************************
Question ID: 302
def minArea(image, x, y):
    top, bottom, left, right = x, x, y, y
    for i, row in enumerate(image):
        for j, cell in enumerate(row):
            if cell == '1':
                top, bottom = min(top, i), max(bottom, i)
                left, right = min(left, j), max(right, j)
    return (bottom - top + 1) * (right - left + 1)

-----
def minArea(image, x, y):
    # Your code here


************************************
Question ID: 305
def numIslands2(m: int, n: int, positions: List[List[int]]) -> List[int]:
    def index(x: int, y: int) -> int:
        return x * n + y
    
    def find(x: int) -> int:
        if roots[x] != x:
            roots[x] = find(roots[x])
        return roots[x]

    roots = [-1] * (m * n)
    dirs = [[0, 1], [1, 0], [-1, 0], [0, -1]]
    islandCount = 0
    result = []

    for i, j in positions:
        idx = index(i, j)
        if roots[idx] != -1:
            result.append(islandCount)
            continue
        islandCount += 1
        roots[idx] = idx
        for dx, dy in dirs:
            ni, nj = i + dx, j + dy
            neighbor = index(ni, nj)
            if 0 <= ni < m and 0 <= nj < n and roots[neighbor] != -1:
                root_neighbor = find(neighbor)
                if idx != root_neighbor:
                    roots[root_neighbor] = idx
                    islandCount -= 1
        result.append(islandCount)
    return result


-----
def numIslands2(m: int, n: int, positions: List[List[int]]) -> List[int]:
    # Your code here


************************************
Question ID: 306
def isAdditiveNumber(num):
    for i in range(1, len(num) // 2 + 1):
        for j in range(1, (len(num) - i) // 2 + 1):
            if check(num[:i], num[i:i+j], num[i+j:]):
                return True
    return False

def check(num1, num2, remaining):
    if (len(num1) > 1 and num1[0] == '0') or (len(num2) > 1 and num2[0] == '0'):
        return False
    _sum = add(num1, num2)
    if remaining == _sum:
        return True
    if not remaining.startswith(_sum):
        return False
    return check(num2, _sum, remaining[len(_sum):])

def add(num1, num2):
    carry, result = 0, []
    i, j = len(num1) - 1, len(num2) - 1
    while i >= 0 or j >= 0 or carry > 0:
        n1 = int(num1[i]) if i >= 0 else 0
        n2 = int(num2[j]) if j >= 0 else 0
        _sum = n1 + n2 + carry
        carry = _sum // 10
        result.append(str(_sum % 10))
        i, j = i - 1, j - 1
    return ''.join(result[::-1])

-----
def isAdditiveNumber(num):
    # Your code here


************************************
Question ID: 309
def maxProfit(prices):
    profit = 0
    for i in range(1, len(prices)):
        profit += max(prices[i] - prices[i - 1], 0)
    return profit

-----
def maxProfit(prices):
    # Your code here


************************************
Question ID: 310
from collections import deque
from typing import List

def find_min_height_trees(n: int, edges: List[List[int]]) -> List[int]:
    if n == 1:
        return [0]

    adj_list = [set() for _ in range(n)]
    for a, b in edges:
        adj_list[a].add(b)
        adj_list[b].add(a)

    leaves = deque(i for i in range(n) if len(adj_list[i]) == 1)

    while n > 2:
        leaves_size = len(leaves)
        n -= leaves_size
        for _ in range(leaves_size):
            leaf = leaves.popleft()
            for neighbor in adj_list[leaf]:
                adj_list[neighbor].remove(leaf)
                if len(adj_list[neighbor]) == 1:
                    leaves.append(neighbor)

    return list(leaves)

-----
from collections import deque
    # Your code here


************************************
Question ID: 311
def multiply(mat1, mat2):
    m, k, n = len(mat1), len(mat1[0]), len(mat2[0])
    result = [[0] * n for _ in range(m)]
    for i in range(m):
        for j in range(k):
            if mat1[i][j] != 0:
                for l in range(n):
                    result[i][l] += mat1[i][j] * mat2[j][l]
    return result

-----
def multiply(mat1, mat2):
    # Your code here


************************************
Question ID: 312
def maxCoins(nums):
    nums = [1] + nums + [1]
    n = len(nums)
    dp = [[0] * n for _ in range(n)]

    for length in range(1, n - 1):
        for left in range(1, n - length):
            right = left + length - 1
            for i in range(left, right + 1):
                dp[left][right] = max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right])

    return dp[1][n - 2]

-----
def maxCoins(nums):
    # Your code here


************************************
Question ID: 313
def nthSuperUglyNumber(n, primes):
    ugly = [0] * n
    ugly[0] = 1
    indices = [0] * len(primes)

    for i in range(1, n):
        min_val = float("inf")

        for j in range(len(primes)):
            min_val = min(min_val, ugly[indices[j]] * primes[j])

        ugly[i] = min_val

        for j in range(len(primes)):
            if ugly[i] == ugly[indices[j]] * primes[j]:
                indices[j] += 1

    return ugly[-1]

-----
def nthSuperUglyNumber(n, primes):
    # Your code here


************************************
Question ID: 314
from collections import defaultdict, deque
from typing import List, Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def verticalOrder(root: Optional[TreeNode]) -> List[List[int]]:
    if not root: return []

    column_table = defaultdict(list)
    q = deque([(root, 0)])

    while q:
        cur_node, column = q.popleft()

        if cur_node:
            column_table[column].append(cur_node.val)
            q.append((cur_node.left, column - 1))
            q.append((cur_node.right, column + 1))

    return [column_table[key] for key in sorted(column_table)]

-----
from collections import defaultdict, deque
    # Your code here


************************************
Question ID: 315
def countSmaller(nums):
    def merge_sort(indices):
        if len(indices) <= 1:
            return indices
        mid = len(indices) // 2
        left = merge_sort(indices[:mid])
        right = merge_sort(indices[mid:])
        return merge(left, right)

    def merge(left, right):
        merged, count = [], 0
        while left and right:
            if nums[left[0]] <= nums[right[0]]:
                counts[left[0]] += count
                merged.append(left.pop(0))
            else:
                count += len(left)
                merged.append(right.pop(0))
        for i in left:
            counts[i] += count
        return merged + left + right

    counts = [0] * len(nums)
    merge_sort(list(range(len(nums))))
    return counts

-----
def countSmaller(nums):
    # Your code here


************************************
Question ID: 316
def removeDuplicateLetters(s):
    count = [0] * 256
    visited = [False] * 256
    st = []

    for ch in s:
        count[ord(ch)] += 1

    for ch in s:
        count[ord(ch)] -= 1
        if visited[ord(ch)]:
            continue
        while st and ch < st[-1] and count[ord(st[-1])] > 0:
            visited[ord(st.pop())] = False
        st.append(ch)
        visited[ord(ch)] = True

    return "".join(st)   

-----
def removeDuplicateLetters(s):
    # Your code here


************************************
Question ID: 317
from collections import deque

def shortestDistance(grid: list[list[int]]) -> int:
    m, n = len(grid), len(grid[0])

    total_count = [[0] * n for _ in range(m)]
    dist_sum = [[0] * n for _ in range(m)]
    house_count = 0

    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]

    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                house_count += 1
                q = deque([(i, j)])
                visited = [[False] * n for _ in range(m)]
                level = 1
                while q:
                    for _ in range(len(q)):
                        x, y = q.popleft()
                        for dx, dy in dirs:
                            x_new, y_new = x + dx, y + dy
                            if 0 <= x_new < m and 0 <= y_new < n and not visited[x_new][y_new] and grid[x_new][y_new] == 0:
                                visited[x_new][y_new] = True
                                q.append((x_new, y_new))
                                dist_sum[x_new][y_new] += level
                                total_count[x_new][y_new] += 1
                    level += 1

    min_dist = float("inf")
    for i in range(m):
        for j in range(n):
            if total_count[i][j] == house_count:
                min_dist = min(min_dist, dist_sum[i][j])

    return -1 if min_dist == float("inf") else min_dist


-----
from collections import deque
    # Your code here


************************************
Question ID: 318
def maxProduct(words):
    n = len(words)
    mask = [0] * n
    for i, word in enumerate(words):
        for c in word:
            mask[i] |= (1 << (ord(c) - ord('a')))
    
    max_product = 0
    for i in range(n):
        for j in range(i + 1, n):
            if (mask[i] & mask[j]) == 0:
                max_product = max(max_product, len(words[i]) * len(words[j]))
    
    return max_product


-----
def maxProduct(words):
    # Your code here


************************************
Question ID: 319
def bulbSwitch(n):
    return int(n**0.5)

-----
def bulbSwitch(n):
    # Your code here


************************************
Question ID: 320
def generateAbbreviations(word):
    if not word:
        return [""]
    res = []
    for i in range(len(word) + 1):
        for item in generateAbbreviations(word[i+1:]):
            if i == 0 or not item or not item[0].isdigit():
                res.append(word[:i+1] + item)
            if item and item[0].isdigit():
                res.append(word[:i] + '1' + item)
    return res

-----
def generateAbbreviations(word):
    # Your code here


************************************
Question ID: 321

```javascript
function maxNumber(nums1, nums2, k) {
    function maxArray(nums, k) {
        let ans = [];
        for (let i = 0; i < nums.length; i++) {
            while (nums.length - i > k - ans.length && ans.length && ans[ans.length - 1] < nums[i])
                ans.pop();
            if (ans.length < k) ans.push(nums[i]);
        }
        return ans;
    }

    function merge(nums1, nums2) {
        let ans = [], i = 0, j = 0;
        while (i < nums1.length || j < nums2.length)
            ans.push((nums1.slice(i).join('') >= nums2.slice(j).join('') ? nums1[i++] : nums2[j++]));
        return ans;
    }

    let result = [];
    for (let i = Math.max(0, k - nums2.length); i <= k && i <= nums1.length; i++) {
        const candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i));
        if (candidate.join('') > result.join('')) result = candidate;
    }
    return result;
}
```


-----

    # Your code here


************************************
Question ID: 322
def coinChange(coins, amount):
    dp = [amount + 1] * (amount + 1)
    dp[0] = 0

    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)

    return dp[amount] if dp[amount] <= amount else -1

-----
def coinChange(coins, amount):
    # Your code here


************************************
Question ID: 323
def countComponents(n, edges):
    adj_list = [[] for _ in range(n)]
    for edge in edges:
        adj_list[edge[0]].append(edge[1])
        adj_list[edge[1]].append(edge[0])

    visited = [False] * n
    connected_components = 0

    def dfs(node):
        visited[node] = True
        for neighbor in adj_list[node]:
            if not visited[neighbor]:
                dfs(neighbor)

    for i in range(n):
        if not visited[i]:
            dfs(i)
            connected_components += 1

    return connected_components


-----
def countComponents(n, edges):
    # Your code here


************************************
Question ID: 324
def wiggleSort(nums):
    nums.sort()
    for i in range(1, len(nums) - 1, 2):
        nums[i], nums[i + 1] = nums[i + 1], nums[i]


-----
def wiggleSort(nums):
    # Your code here


************************************
Question ID: 325
def maxSubArrayLen(nums: List[int], k: int) -> int:
    sum_index = {}
    maxLength = sum = 0
    for i, num in enumerate(nums):
        sum += num
        if sum == k:
            maxLength = i + 1
        if sum - k in sum_index:
            maxLength = max(maxLength, i - sum_index[sum - k])
        if sum not in sum_index:
            sum_index[sum] = i
    return maxLength


-----
def maxSubArrayLen(nums: List[int], k: int) -> int:
    # Your code here


************************************
Question ID: 326
def is_power_of_three(n: int) -> bool:
    if n < 1:
        return False
    
    while n % 3 == 0:
        n //= 3
    
    return n == 1

-----
def is_power_of_three(n: int) -> bool:
    # Your code here


************************************
Question ID: 327
def countRangeSum(nums, lower, upper):
    sums = [0] * (len(nums) + 1)
    for i in range(len(nums)):
        sums[i + 1] = sums[i] + nums[i]

    def mergeSort(start, end):
        if start == end:
            return 0
        mid = start + (end - start) // 2
        count = mergeSort(start, mid) + mergeSort(mid + 1, end)

        j, k = mid + 1, mid + 1
        for i in range(start, mid + 1):
            while j <= end and sums[j] - sums[i] < lower: j += 1
            while k <= end and sums[k] - sums[i] <= upper: k += 1
            count += k - j

        sums[start:end + 1] = sorted(sums[start:end + 1])
        return count

    return mergeSort(0, len(nums))

-----
def countRangeSum(nums, lower, upper):
    # Your code here


************************************
Question ID: 329
dx = (0, 0, 1, -1)
dy = (1, -1, 0, 0)

def dfs(matrix, memo, i, j):
    if memo[i][j] != 0:
        return memo[i][j]
    
    max_len = 0
    for k in range(4):
        ni, nj = i + dx[k], j + dy[k]
        if (0 <= ni < len(matrix) and 0 <= nj < len(matrix[0]) and matrix[ni][nj] > matrix[i][j]):
            max_len = max(max_len, dfs(matrix, memo, ni, nj))
    
    memo[i][j] = max_len + 1
    return memo[i][j]

def longest_increasing_path(matrix):
    m, n = len(matrix), len(matrix[0])
    
    memo = [[0] * n for _ in range(m)]
    
    ans = 0
    for i in range(m):
        for j in range(n):
            ans = max(ans, dfs(matrix, memo, i, j))
    
    return ans


-----
dx = (0, 0, 1, -1)
    # Your code here


************************************
Question ID: 330
def minPatches(nums, n):
    max_sum = 0
    patches = 0
    i = 0

    while max_sum < n:
        if i < len(nums) and nums[i] <= max_sum + 1:
            max_sum += nums[i]
            i += 1
        else:
            max_sum += max_sum + 1
            patches += 1

    return patches


-----
def minPatches(nums, n):
    # Your code here


************************************
Question ID: 331
def is_valid_serialization(preorder: str) -> bool:
    nodes = preorder.split(',')
    node_count = 1

    for node in nodes:
        node_count -= 1
        if node_count < 0:
            return False
        if node != '#':
            node_count += 2

    return node_count == 0

-----
def is_valid_serialization(preorder: str) -> bool:
    # Your code here


************************************
Question ID: 332
from collections import defaultdict

def findItinerary(tickets):
    flights = defaultdict(list)
    itinerary = []

    for ticket in tickets:
        flights[ticket[0]].append(ticket[1])
        flights[ticket[0]].sort(reverse=True)

    def dfs(airport):
        while flights[airport]:
            dfs(flights[airport].pop())
        itinerary.append(airport)

    dfs("JFK")
    
    return itinerary[::-1]

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 334
def findTriplets(nums: List[int]) -> bool:
    first = float('inf')
    second = float('inf')

    for num in nums:
        if num <= first:
            first = num
        elif num <= second:
            second = num
        else:
            return True
    return False

-----
def findTriplets(nums: List[int]) -> bool:
    # Your code here


************************************
Question ID: 335
def is_path_crossing(distance):
    visited = set([(0, 0)])
    x, y = 0, 0
    directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]
    
    for i, d in enumerate(distance):
        dx, dy = directions[i % 4]
        for _ in range(d):
            x += dx
            y += dy
            if (x, y) in visited:
                return True
            visited.add((x, y))
    return False


-----
def is_path_crossing(distance):
    # Your code here


************************************
Question ID: 336
def palindrome_pairs(words):
    def is_palindrome(s):
        return s == s[::-1]

    result = []
    for i in range(len(words)):
        for j in range(len(words)):
            if i == j:
                continue
            concat = words[i] + words[j]
            if is_palindrome(concat):
                result.append([i, j])
    return result

-----
def palindrome_pairs(words):
    # Your code here


************************************
Question ID: 337
def rob(self, root: TreeNode) -> int:
    def rob_helper(node):
        if not node:
            return 0, 0

        left_with_node, left_without_node = rob_helper(node.left)
        right_with_node, right_without_node = rob_helper(node.right)

        with_node = node.val + left_without_node + right_without_node
        without_node = max(left_with_node, left_without_node) + max(right_with_node, right_without_node)
        return with_node, without_node

    return max(rob_helper(root))

-----
def rob(self, root: TreeNode) -> int:
    # Your code here


************************************
Question ID: 338
def countBits(n):
    ans = [0] * (n + 1)
    for i in range(1, n + 1):
        ans[i] = ans[i & (i - 1)] + 1
    return ans

-----
def countBits(n):
    # Your code here


************************************
Question ID: 339
from typing import List, Union

def depth_sum(nested_list: List[Union[int, List]]) -> int:
    def depth_sum_helper(nested_list: List[Union[int, List]], depth: int) -> int:
        return sum(element * depth if isinstance(element, int) else depth_sum_helper(element, depth + 1) for element in nested_list)

    return depth_sum_helper(nested_list, 1)


-----
from typing import List, Union
    # Your code here


************************************
Question ID: 340
def length_of_longest_substring_k_distinct(s: str, k: int) -> int:
    char_count = {}
    left = 0
    max_length = 0

    for right, char in enumerate(s):
        char_count[char] = char_count.get(char, 0) + 1

        while len(char_count) > k:
            char_count[s[left]] -= 1
            if char_count[s[left]] == 0:
                del char_count[s[left]]
            left += 1

        max_length = max(max_length, right - left + 1)

    return max_length

-----
def length_of_longest_substring_k_distinct(s: str, k: int) -> int:
    # Your code here


************************************
Question ID: 342
def isPowerOfFour(n: int) -> bool:
    if n <= 0:
        return False
    while n % 4 == 0:
        n //= 4
    return n == 1

-----
def isPowerOfFour(n: int) -> bool:
    # Your code here


************************************
Question ID: 343
def integer_break(n):
    if n <= 3:
        return n - 1
    product = 1
    while n > 4:
        product *= 3
        n -= 3
    return product * n

-----
def integer_break(n):
    # Your code here


************************************
Question ID: 344
def reverseString(s: List[str]) -> None:
    left, right = 0, len(s) - 1
    while left < right:
        s[left], s[right] = s[right], s[left]
        left, right = left + 1, right - 1

-----
def reverseString(s: List[str]) -> None:
    # Your code here


************************************
Question ID: 345
def reverseVowels(s: str) -> str:
    vowels = set('aeiouAEIOU')
    s_list = list(s)
    i, j = 0, len(s) - 1
    while i < j:
        if s_list[i] not in vowels:
            i += 1
        elif s_list[j] not in vowels:
            j -= 1
        else:
            s_list[i], s_list[j] = s_list[j], s_list[i]
            i += 1
            j -= 1
    return ''.join(s_list)

-----
def reverseVowels(s: str) -> str:
    # Your code here


************************************
Question ID: 346
from collections import deque

class MovingAverage:
    def __init__(self, size: int):
        self.queue = deque()
        self.maxSize = size
        self.sum = 0.0

    def next(self, val: int) -> float:
        if len(self.queue) == self.maxSize:
            self.sum -= self.queue.popleft()
        self.queue.append(val)
        self.sum += val
        return self.sum / len(self.queue)

-----
from collections import deque
    # Your code here


************************************
Question ID: 347
from heapq import heappush, heappop
from collections import Counter

def k_most_frequent(nums, k):
    frequency = Counter(nums)
    min_heap = []

    for num, freq in frequency.items():
        heappush(min_heap, (freq, num))
        if len(min_heap) > k:
            heappop(min_heap)

    return [heappop(min_heap)[1] for _ in range(k)]


-----
from heapq import heappush, heappop
    # Your code here


************************************
Question ID: 349
def intersection(nums1, nums2):
    set1 = set(nums1)
    result = set1.intersection(nums2)
    return list(result)

-----
def intersection(nums1, nums2):
    # Your code here


************************************
Question ID: 350
def intersect(nums1, nums2):
    count_map = {}
    result = []
    
    for num in nums1:
        count_map[num] = count_map.get(num, 0) + 1
    
    for num in nums2:
        if count_map.get(num, 0) > 0:
            result.append(num)
            count_map[num] -= 1

    return result


-----
def intersect(nums1, nums2):
    # Your code here


************************************
Question ID: 351
def numberOfPatterns(m: int, n: int) -> int:
    def dfs(curr, remaining):
        if remaining < 0:
            return 0
        if remaining == 0:
            return 1

        visited[curr] = True
        cnt = 0
        for next in range(1, 10):
            if not visited[next] and (jumps[curr][next] == 0 or visited[jumps[curr][next]]):
                cnt += dfs(next, remaining - 1)
        visited[curr] = False

        return cnt

    jumps = [[0] * 10 for _ in range(10)]
    jumps[1][3] = jumps[3][1] = 2
    jumps[1][7] = jumps[7][1] = 4
    jumps[3][9] = jumps[9][3] = 6
    jumps[7][9] = jumps[9][7] = 8
    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5

    visited = [False] * 10

    cnt = 0
    for i in range(m, n + 1):
        cnt += dfs(1, i - 1) * 4  # 1, 3, 7, 9
        cnt += dfs(2, i - 1) * 4  # 2, 4, 6, 8
        cnt += dfs(5, i - 1)      # 5

    return cnt


-----
def numberOfPatterns(m: int, n: int) -> int:
    # Your code here


************************************
Question ID: 352
from collections import OrderedDict

class SummaryRanges:

    def __init__(self):
        self.intervals = OrderedDict()

    def addNum(self, val: int) -> None:
        if not self.intervals or next(iter(self.intervals)) > val + 1:
            self.intervals[val] = val
        else:
            keys = list(self.intervals.keys())
            idx = bisect_left(keys, val)
            if idx > 0 and keys[idx - 1] <= val <= self.intervals[keys[idx - 1]]:
                pass
            elif idx < len(keys) and val + 1 == keys[idx]:
                self.intervals[val] = self.intervals[keys[idx]]
                del self.intervals[keys[idx]]
            else:
                self.intervals[val] = val

    def getIntervals(self):
        return list(self.intervals.items())


-----
from collections import OrderedDict
    # Your code here


************************************
Question ID: 353
from collections import deque

class SnakeGame:
    def __init__(self, width: int, height: int, food: List[List[int]]):
        self.width = width
        self.height = height
        self.food = food
        self.pos = 0
        self.score = 0
        self.snake = deque([(0, 0)])
        self.occupied = {(0, 0)}
        self.dx = {'U': -1, 'D': 1, 'L': 0, 'R': 0}
        self.dy = {'U': 0, 'D': 0, 'L': -1, 'R': 1}

    def move(self, direction: str) -> int:
        new_x = self.snake[-1][0] + self.dx[direction]
        new_y = self.snake[-1][1] + self.dy[direction]

        if new_x < 0 or new_x >= self.height or new_y < 0 or new_y >= self.width:
            return -1

        new_head = (new_x, new_y)
        tail = self.snake.popleft()

        if self.pos < len(self.food) and self.food[self.pos] == list(new_head):
            self.score += 1
            self.pos += 1
        else:
            self.occupied.remove(tail)

        if new_head in self.occupied:
            return -1

        self.snake.append(new_head)
        self.occupied.add(new_head)
        return self.score

-----
from collections import deque
    # Your code here


************************************
Question ID: 354
from bisect import bisect_left

def max_envelopes(envelopes):
    envelopes.sort(key=lambda x: (x[0], -x[1]))
    dp = []
    
    for _, h in envelopes:
        idx = bisect_left(dp, h)
        if idx == len(dp):
            dp.append(h)
        else:
            dp[idx] = h

    return len(dp)

-----
from bisect import bisect_left
    # Your code here


************************************
Question ID: 355
from collections import defaultdict
from typing import List

class Twitter:

    class Tweet:
        def __init__(self, time, tweetId):
            self.time = time
            self.tweetId = tweetId

    def __init__(self):
        self.tweets = defaultdict(list)
        self.following = defaultdict(set)
        self.timeStamp = 0

    def postTweet(self, userId: int, tweetId: int) -> None:
        self.tweets[userId].append(self.Tweet(self.timeStamp, tweetId))
        self.timeStamp += 1

    def getNewsFeed(self, userId: int) -> List[int]:
        feed = self.tweets[userId][:]
        for user in self.following[userId]:
            feed.extend(self.tweets[user])

        feed.sort(key=lambda x: x.time, reverse=True)
        return [t.tweetId for t in feed[:10]]

    def follow(self, followerId: int, followeeId: int) -> None:
        if followerId != followeeId:
            self.following[followerId].add(followeeId)

    def unfollow(self, followerId: int, followeeId: int) -> None:
        self.following[followerId].discard(followeeId)


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 356
def isReflected(points):
    min_x = min(point[0] for point in points)
    max_x = max(point[0] for point in points)
    point_set = {(point[0], point[1]) for point in points}
    
    sum_x = min_x + max_x
    for point in points:
        if (sum_x - point[0], point[1]) not in point_set:
            return False

    return True

-----
def isReflected(points):
    # Your code here


************************************
Question ID: 357
def countNumbersWithUniqueDigits(n):
    if n == 0:
        return 1
    
    total = 10
    unique_digits = 9
    current_available_digits = 9
    
    while n > 1 and current_available_digits > 0:
        unique_digits *= current_available_digits
        total += unique_digits
        current_available_digits -= 1
        n -= 1
        
    return total


-----
def countNumbersWithUniqueDigits(n):
    # Your code here


************************************
Question ID: 358
import heapq
from collections import Counter

def rearrange_string(s, k):
    if k == 0:
        return s

    counter = Counter(s)
    max_heap = [(-count, char) for char, count in counter.items()]
    heapq.heapify(max_heap)

    result = []
    while max_heap:
        temp = []

        for _ in range(k):
            if not max_heap:
                break

            count, char = heapq.heappop(max_heap)
            result.append(char)

            if count + 1 < 0:
                temp.append((count + 1, char))

        for item in temp:
            heapq.heappush(max_heap, item)

        if not max_heap:
            break

        if len(result) < len(s):
            result.extend([' '] * (k - len(temp)))

    if len(result) < len(s):
        return ""
    return "".join(result)


-----
import heapq
    # Your code here


************************************
Question ID: 360
def sort_transformed_array(nums, a, b, c):
    result = [0] * len(nums)
    i, j = 0, len(nums) - 1
    index = len(nums) - 1 if a >= 0 else 0
    
    while i <= j:
        left = nums[i] * nums[i] * a + nums[i] * b + c
        right = nums[j] * nums[j] * a + nums[j] * b + c
        
        if a >= 0:
            if left >= right:
                result[index] = left
                index -= 1
                i += 1
            else:
                result[index] = right
                index -= 1
                j -= 1
        else:
            if left <= right:
                result[index] = left
                index += 1
                i += 1
            else:
                result[index] = right
                index += 1
                j -= 1
    return result

-----
def sort_transformed_array(nums, a, b, c):
    # Your code here


************************************
Question ID: 361
def maxKilledEnemies(grid):
    if not grid: return 0
    m, n, result, rowhits = len(grid), len(grid[0]), 0, 0
    colhits = [0] * n
    for i in range(m):
        for j in range(n):
            if j == 0 or grid[i][j - 1] == 'W':
                rowhits = 0
                k = j
                while k < n and grid[i][k] != 'W':
                    rowhits += grid[i][k] == 'E'
                    k += 1
            if i == 0 or grid[i - 1][j] == 'W':
                colhits[j] = 0
                k = i
                while k < m and grid[k][j] != 'W':
                    colhits[j] += grid[k][j] == 'E'
                    k += 1
            if grid[i][j] == '0':
                result = max(result, rowhits + colhits[j])
    return result

-----
def maxKilledEnemies(grid):
    # Your code here


************************************
Question ID: 362
from collections import deque

class HitCounter:

    def __init__(self):
        self.queue = deque()

    def hit(self, timestamp: int) -> None:
        self.queue.append(timestamp)

    def getHits(self, timestamp: int) -> int:
        while self.queue and self.queue[0] <= timestamp - 300:
            self.queue.popleft()
        return len(self.queue)

-----
from collections import deque
    # Your code here


************************************
Question ID: 363
from sortedcontainers import SortedList

def maxSumSubmatrix(matrix, k):
    rows = len(matrix)
    cols = len(matrix[0])
    max_sum = float('-inf')

    for l in range(cols):
        sums = [0] * rows
        for r in range(l, cols):
            for i in range(rows):
                sums[i] += matrix[i][r]

            sorted_sums = SortedList()
            sorted_sums.add(0)
            curr_sum = 0
            for sum in sums:
                curr_sum += sum
                it = sorted_sums.bisect_left(curr_sum - k)
                if it != len(sorted_sums):
                    max_sum = max(max_sum, curr_sum - sorted_sums[it])
                sorted_sums.add(curr_sum)

    return max_sum


-----
from sortedcontainers import SortedList
    # Your code here


************************************
Question ID: 364
from typing import List, Union

NestedInteger = Union[int, List[Union[int, "NestedInteger"]]]

def depthSumInverse(nestedList: List[NestedInteger]) -> int:
    max_depth = max_depth_helper(nestedList)
    return sum_helper(nestedList, max_depth)

def max_depth_helper(nested_list: List[NestedInteger]) -> int:
    depth = 1
    for nested in nested_list:
        if isinstance(nested, list):
            depth = max(depth, 1 + max_depth_helper(nested))
    return depth

def sum_helper(nested_list: List[NestedInteger], depth: int) -> int:
    sum = 0
    for nested in nested_list:
        if isinstance(nested, int):
            sum += depth * nested
        else:
            sum += sum_helper(nested, depth - 1)
    return sum

-----
from typing import List, Union
    # Your code here


************************************
Question ID: 365
def canMeasureWater(jug1Capacity, jug2Capacity, targetCapacity):
    if targetCapacity > jug1Capacity + jug2Capacity:
        return False
    if jug1Capacity == targetCapacity or jug2Capacity == targetCapacity or jug1Capacity + jug2Capacity == targetCapacity:
        return True
    return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a


-----
def canMeasureWater(jug1Capacity, jug2Capacity, targetCapacity):
    # Your code here


************************************
Question ID: 367
def is_perfect_square(num: int) -> bool:
    if num < 2:
        return True
    left, right = 2, num // 2
    while left <= right:
        mid = left + (right - left) // 2
        square = mid * mid
        if square == num:
            return True
        if square > num:
            right = mid - 1
        else:
            left = mid + 1
    return False

-----
def is_perfect_square(num: int) -> bool:
    # Your code here


************************************
Question ID: 368
def largestDivisibleSubset(nums):
    nums.sort()
    n = len(nums)
    count = [1] * n
    prev = [-1] * n

    max_idx = 0
    for i in range(1, n):
        for j in range(i):
            if nums[i] % nums[j] == 0 and count[i] < count[j] + 1:
                count[i] = count[j] + 1
                prev[i] = j
        if count[max_idx] < count[i]:
            max_idx = i

    res = []
    i = max_idx
    while i >= 0:
        res.append(nums[i])
        i = prev[i]

    return res

-----
def largestDivisibleSubset(nums):
    # Your code here


************************************
Question ID: 370
def get_updated_array(length, updates):
    arr = [0] * length

    for start, end, inc in updates:
        arr[start] += inc
        if end + 1 < length:
            arr[end + 1] -= inc

    for i in range(1, length):
        arr[i] += arr[i - 1]

    return arr

-----
def get_updated_array(length, updates):
    # Your code here


************************************
Question ID: 371
def add(a, b):
    MAX = 0x7FFFFFFF
    MASK = 0xFFFFFFFF
    while b:
        a, b = (a ^ b) & MASK, ((a & b) << 1) & MASK
    return a if a <= MAX else ~(a ^ MASK)

-----
def add(a, b):
    # Your code here


************************************
Question ID: 372
def powmod(a, b):
    if b == 0:
        return 1
    res = powmod(a, b // 2)
    return res * res % 1337 * a % 1337 if b % 2 else res * res % 1337

def superPow(a, b):
    n = 0
    for bi in b:
        n = (n * 10 + bi) % 1140
    return powmod(a % 1337, n + 1140)

-----
def powmod(a, b):
    # Your code here


************************************
Question ID: 373
import heapq

def kSmallestPairs(nums1, nums2, k):
    if not nums1 or not nums2:
        return []
    
    heap = [(nums1[i] + nums2[0], i, 0) for i in range(min(k, len(nums1)))]
    heapq.heapify(heap)
    result = []

    while k > 0 and heap:
        s, i, j = heapq.heappop(heap)
        result.append([nums1[i], nums2[j]])
        if j + 1 < len(nums2):
            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1

    return result

-----
import heapq
    # Your code here


************************************
Question ID: 374
def guessNumber(n):
    low, high = 1, n
    while low <= high:
        mid = low + (high - low) // 2
        result = guess(mid)
        if result == 0:
            return mid
        elif result < 0:
            high = mid - 1
        else:
            low = mid + 1
    return -1

-----
def guessNumber(n):
    # Your code here


************************************
Question ID: 375
def getMoneyAmount(n: int) -> int:
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    for i in range(n - 1, 0, -1):
        for j in range(i + 1, n + 1):
            min_cost = float("inf")
            for k in range(i, j):
                cost = k + max(dp[i][k - 1], dp[k + 1][j])
                min_cost = min(min_cost, cost)
            dp[i][j] = min_cost
    return dp[1][n]

-----
def getMoneyAmount(n: int) -> int:
    # Your code here


************************************
Question ID: 376
def wiggleMaxLength(nums):
    if len(nums) < 2:
        return len(nums)

    up, down = 1, 1
    for i in range(1, len(nums)):
        if nums[i] > nums[i - 1]:
            up = down + 1
        elif nums[i] < nums[i - 1]:
            down = up + 1
    return max(up, down)

-----
def wiggleMaxLength(nums):
    # Your code here


************************************
Question ID: 377
def combination_sum(nums, target):
    dp = [0] * (target + 1)
    dp[0] = 1

    for num in nums:
        for i in range(num, target + 1):
            dp[i] += dp[i - num]

    return dp[target]


-----
def combination_sum(nums, target):
    # Your code here


************************************
Question ID: 378
import heapq

def kthSmallest(matrix, k):
    n = len(matrix)
    min_heap = []

    for i in range(n):
        heapq.heappush(min_heap, (matrix[i][0], i, 0))

    while k > 1:
        val, row, col = heapq.heappop(min_heap)

        if col + 1 < n:
            heapq.heappush(min_heap, (matrix[row][col + 1], row, col + 1))

        k -= 1

    return min_heap[0][0]

-----
import heapq
    # Your code here


************************************
Question ID: 379
from collections import deque

class PhoneDirectory:
    def __init__(self, maxNumbers: int):
        self.available = [True] * maxNumbers
        self.released = deque()
    
    def get(self) -> int:
        if self.released:
            number = self.released.popleft()
            self.available[number] = False
            return number
        for i in range(len(self.available)):
            if self.available[i]:
                self.available[i] = False
                return i
        return -1
    
    def check(self, number: int) -> bool:
        return self.available[number]
    
    def release(self, number: int) -> None:
        if not self.available[number]:
            self.available[number] = True
            self.released.append(number)


-----
from collections import deque
    # Your code here


************************************
Question ID: 380
import random

class RandomizedSet:
    def __init__(self):
        self.index_map = {}
        self.nums = []

    def insert(self, val: int) -> bool:
        if val in self.index_map:
            return False

        self.index_map[val] = len(self.nums)
        self.nums.append(val)
        return True

    def remove(self, val: int) -> bool:
        if val not in self.index_map:
            return False

        last = self.nums[-1]
        self.index_map[last] = self.index_map[val]
        self.nums[self.index_map[val]] = last

        self.nums.pop()
        del self.index_map[val]
        return True

    def getRandom(self) -> int:
        return self.nums[random.randint(0, len(self.nums) - 1)]

-----
import random
    # Your code here


************************************
Question ID: 381
import random
from collections import defaultdict

class RandomizedCollection:
    def __init__(self):
        self.indices = defaultdict(set)
        self.nums = []

    def insert(self, val):
        self.nums.append(val)
        self.indices[val].add(len(self.nums) - 1)
        return len(self.indices[val]) == 1

    def remove(self, val):
        if not self.indices[val]:
            return False

        idx = self.indices[val].pop()
        if idx < len(self.nums) - 1:
            last = self.nums[-1]
            self.nums[idx] = last
            self.indices[last].remove(len(self.nums) - 1)
            self.indices[last].add(idx)
        self.nums.pop()
        return True

    def getRandom(self):
        return self.nums[random.randint(0, len(self.nums) - 1)]


-----
import random
    # Your code here


************************************
Question ID: 382
import random

class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    def __init__(self, head: ListNode):
        self.head = head

    def getRandom(self) -> int:
        current, result = self.head, 0
        for i, node in enumerate(self.iterate_nodes(current)):
            if random.randint(0, i) == 0:
                result = node.val
        return result

    def iterate_nodes(self, current):
        while current:
            yield current
            current = current.next

-----
import random
    # Your code here


************************************
Question ID: 383
def can_construct(ransom_note, magazine):
    letter_count = {}
    
    for c in magazine:
        letter_count[c] = letter_count.get(c, 0) + 1
        
    for c in ransom_note:
        if c not in letter_count or letter_count[c] == 0:
            return False
        letter_count[c] -= 1
        
    return True

-----
def can_construct(ransom_note, magazine):
    # Your code here


************************************
Question ID: 384
import random

class Solution:
    def __init__(self, nums):
        self.original = nums

    def reset(self):
        return self.original

    def shuffle(self):
        shuffled = self.original[:]
        for i in range(len(shuffled) - 1, 0, -1):
            j = random.randint(0, i)
            shuffled[i], shuffled[j] = shuffled[j], shuffled[i]
        return shuffled


-----
import random
    # Your code here


************************************
Question ID: 386
def lexicographical_order_helper(current, n, result):
    if current > n:
        return

    result.append(current)
    for i in range(10):
        lexicographical_order_helper(current * 10 + i, n, result)

def lexical_order(n):
    result = []
    for i in range(1, 10):
        lexicographical_order_helper(i, n, result)
    return result

-----
def lexicographical_order_helper(current, n, result):
    # Your code here


************************************
Question ID: 387
def firstUniqChar(s):
    char_count = {}
    for c in s:
        char_count[c] = char_count.get(c, 0) + 1
    for i in range(len(s)):
        if char_count[s[i]] == 1:
            return i
    return -1


-----
def firstUniqChar(s):
    # Your code here


************************************
Question ID: 388
def length_longest_path(input: str) -> int:
    dir_length_stack = []
    max_file_length = 0
    lines = input.split('\n')

    for line in lines:
        level = line.count('\t')
        line = line.lstrip('\t')

        while len(dir_length_stack) > level:
            dir_length_stack.pop()

        if dir_length_stack:
            length = dir_length_stack[-1] + len(line) + 1
        else:
            length = len(line)
        dir_length_stack.append(length)

        if '.' in line:
            max_file_length = max(max_file_length, length)
            
    return max_file_length


-----
def length_longest_path(input: str) -> int:
    # Your code here


************************************
Question ID: 389
def findTheDifference(s: str, t: str) -> str:
    return chr(sum(ord(c) for c in t) - sum(ord(c) for c in s))

-----
def findTheDifference(s: str, t: str) -> str:
    # Your code here


************************************
Question ID: 390
def last_remaining(n: int) -> int:
    direction = True
    head = 1
    remaining = n
    step = 1

    while remaining > 1:
        if direction or remaining % 2 == 1:
            head += step
        remaining //= 2
        step *= 2
        direction = not direction

    return head

-----
def last_remaining(n: int) -> int:
    # Your code here


************************************
Question ID: 391
def isRectangleCover(rectangles):
    area = 0
    points = set()
    lx, ly, rx, ry = float('inf'), float('inf'), float('-inf'), float('-inf')

    for rect in rectangles:
        lx, ly = min(lx, rect[0]), min(ly, rect[1])
        rx, ry = max(rx, rect[2]), max(ry, rect[3])

        area += (rect[2] - rect[0]) * (rect[3] - rect[1])

        p1, p2, p3, p4 = (rect[0], rect[1]), (rect[0], rect[3]), (rect[2], rect[1]), (rect[2], rect[3])

        points ^= {p1, p2, p3, p4}

    return len(points) == 4 and area == (rx - lx) * (ry - ly) and (lx, ly) in points and \
           (lx, ry) in points and (rx, ly) in points and (rx, ry) in points

-----
def isRectangleCover(rectangles):
    # Your code here


************************************
Question ID: 392
def is_subsequence(s, t):
    si, ti = 0, 0

    while si < len(s) and ti < len(t):
        if s[si] == t[ti]:
            si += 1
        ti += 1

    return si == len(s)


-----
def is_subsequence(s, t):
    # Your code here


************************************
Question ID: 393
def validUtf8(data):
    count = 0
    for byte in data:
        if count == 0:
            if byte >> 5 == 0b110:
                count = 1
            elif byte >> 4 == 0b1110:
                count = 2
            elif byte >> 3 == 0b11110:
                count = 3
            elif byte >> 7:
                return False
        else:
            if byte >> 6 != 0b10:
                return False
            count -= 1
    return count == 0

-----
def validUtf8(data):
    # Your code here


************************************
Question ID: 394
def decodeString(s):
    counts = []
    results = []
    current = ""
    ptr = 0

    while ptr < len(s):
        if s[ptr].isdigit():
            count = 0
            while s[ptr].isdigit():
                count = count * 10 + int(s[ptr])
                ptr += 1
            counts.append(count)
        elif s[ptr] == '[':
            results.append(current)
            current = ""
            ptr += 1
        elif s[ptr] == ']':
            prev = results.pop()
            count = counts.pop()
            current = prev + current * count
            ptr += 1
        else:
            current += s[ptr]
            ptr += 1

    return current

-----
def decodeString(s):
    # Your code here


************************************
Question ID: 395
def longestSubstring(s: str, k: int) -> int:
    if not s or k <= 0:
        return 0

    char_count = {}
    for ch in s:
        char_count[ch] = char_count.get(ch, 0) + 1

    for char, count in char_count.items():
        if count < k:
            return max(longestSubstring(sub_s, k) for sub_s in s.split(char))
    return len(s)

-----
def longestSubstring(s: str, k: int) -> int:
    # Your code here


************************************
Question ID: 396
def maxRotateFunction(nums):
    n = len(nums)
    total_sum = sum(nums)
    f = sum(i * num for i, num in enumerate(nums))

    max_f = f
    for i in range(1, n):
        f += total_sum - n * nums[-i]
        max_f = max(max_f, f)

    return max_f


-----
def maxRotateFunction(nums):
    # Your code here


************************************
Question ID: 397
def min_operations(n):
    steps = 0
    while n > 1:
        n = n // 2 if n % 2 == 0 else n - 1
        steps += 1
    return steps

-----
def min_operations(n):
    # Your code here


************************************
Question ID: 398
import random

class Solution:

    def __init__(self, nums):
        self.nums = nums

    def pick(self, target):
        count, res = 0, 0
        for i, num in enumerate(self.nums):
            if num == target:
                count += 1
                if random.randint(0, count - 1) == 0:
                    res = i
        return res

-----
import random
    # Your code here


************************************
Question ID: 399
from collections import defaultdict

def dfs(s1, s2, graph):
    if s1 not in graph or s2 not in graph:
        return -1.0
    if s1 == s2:
        return 1.0
    
    for neighbor, weight in graph[s1]:
        if neighbor not in visited:
            visited.add(neighbor)
            temp = dfs(neighbor, s2, graph)
            if temp > 0:
                return weight * temp
    return -1.0

def calcEquation(equations, values, queries):
    graph = defaultdict(list)
    for (s1, s2), value in zip(equations, values):
        graph[s1].append((s2, value))
        graph[s2].append((s1, 1 / value))
    
    ans = []
    for s1, s2 in queries:
        visited = set()
        ans.append(dfs(s1, s2, graph))
    return ans

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 400
def findNthDigit(n):
    size = 1
    length = 9
    start = 1

    while n > length * size:
        n -= length * size
        size += 1
        length *= 10
        start *= 10

    start += (n - 1) // size
    s = str(start)
    return int(s[(n - 1) % size])

-----
def findNthDigit(n):
    # Your code here


************************************
Question ID: 401
def readBinaryWatch(turnedOn: int):
    def count_bits(n):
        return bin(n).count('1')

    times = []
    for h in range(12):
        for m in range(60):
            if count_bits(h) + count_bits(m) == turnedOn:
                times.append(f"{h}:{m:02d}")
    return times

-----
def readBinaryWatch(turnedOn: int):
    # Your code here


************************************
Question ID: 402
def remove_k_digits(num, k):
    stack = []
    for c in num:
        while k > 0 and stack and stack[-1] > c:
            stack.pop()
            k -= 1
        stack.append(c)
    while k > 0:
        stack.pop()
        k -= 1
    return ''.join(stack).lstrip('0') or '0'

-----
def remove_k_digits(num, k):
    # Your code here


************************************
Question ID: 403
def can_cross(stones):
    dp = {stone: set() for stone in stones}
    dp[0].add(0)

    for stone in stones:
        for k in dp[stone]:
            for jump in (k - 1, k, k + 1):
                if jump > 0 and stone + jump in dp:
                    dp[stone + jump].add(jump)

    return bool(dp[stones[-1]])


-----
def can_cross(stones):
    # Your code here


************************************
Question ID: 405
def to_hex(num: int) -> str:
    if num == 0:
        return '0'
    hex_str = ''
    hex_digits = '0123456789abcdef'
    n = num & 0xffffffff
    while n:
        hex_str = hex_digits[n & 0xf] + hex_str
        n >>= 4
    return hex_str

-----
def to_hex(num: int) -> str:
    # Your code here


************************************
Question ID: 406
from typing import List

def reconstructQueue(people: List[List[int]]) -> List[List[int]]:
    people.sort(key=lambda x: (-x[0], x[1]))

    result = []
    for p in people:
        result.insert(p[1], p)
    return result


-----
from typing import List
    # Your code here


************************************
Question ID: 407
import heapq

def trapRainWater(heightMap):
    m, n = len(heightMap), len(heightMap[0])
    pq = []
    visited = [[False] * n for _ in range(m)]

    for i in range(m):
        heapq.heappush(pq, (heightMap[i][0], i, 0))
        heapq.heappush(pq, (heightMap[i][n - 1], i, n - 1))
        visited[i][0] = visited[i][n - 1] = True

    for i in range(1, n - 1):
        heapq.heappush(pq, (heightMap[0][i], 0, i))
        heapq.heappush(pq, (heightMap[m - 1][i], m - 1, i))
        visited[0][i] = visited[m - 1][i] = True

    water, maxHeight = 0, 0
    dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))

    while pq:
        h, r, c = heapq.heappop(pq)
        maxHeight = max(maxHeight, h)
        for dx, dy in dirs:
            x, y = r + dx, c + dy
            if x < 0 or x >= m or y < 0 or y >= n or visited[x][y]:
                continue
            if heightMap[x][y] < maxHeight:
                water += maxHeight - heightMap[x][y]
            heapq.heappush(pq, (heightMap[x][y], x, y))
            visited[x][y] = True

    return water

-----
import heapq
    # Your code here


************************************
Question ID: 408
def validWordAbbreviation(word, abbr):
    i, j = 0, 0
    while i < len(word) and j < len(abbr):
        if abbr[j].isdigit():
            if abbr[j] == '0': return False  # leading zero
            num = 0
            while j < len(abbr) and abbr[j].isdigit():
                num = num * 10 + int(abbr[j])
                j += 1
            i += num
        else:
            if word[i] != abbr[j]: return False
            i, j = i + 1, j + 1
    return i == len(word) and j == len(abbr)

-----
def validWordAbbreviation(word, abbr):
    # Your code here


************************************
Question ID: 409
def longestPalindrome(s: str) -> int:
    charCount = [0] * 128
    result = 0
    for c in s:
        charCount[ord(c)] += 1
    for count in charCount:
        result += count // 2 * 2
        if result % 2 == 0 and count % 2 == 1:
            result += 1
    return result

-----
def longestPalindrome(s: str) -> int:
    # Your code here


************************************
Question ID: 410
def splitArray(nums, m):
    left, right = max(nums), sum(nums)

    while left < right:
        mid = (left + right) // 2
        count, cur_sum = 1, 0
        for num in nums:
            cur_sum += num
            if cur_sum > mid:
                cur_sum = num
                count += 1

        if count > m:
            left = mid + 1
        else:
            right = mid

    return left

-----
def splitArray(nums, m):
    # Your code here


************************************
Question ID: 411
def abbreviate(s, k, i):
    if i == len(s):
        return str(k) if k > 0 else ""
    if k == 0:
        return s[i:] + (abbreviate(s, 1, i + 1) if i + 1 < len(s) else "")
    return str(k) + s[i] + (abbreviate(s, 1, i + 1) if i + 1 < len(s) else "")

def is_abbreviation(target, word):
    i, j = 0, 0
    while i < len(target) and j < len(word):
        if target[i] == word[j]:
            i, j = i + 1, j + 1
        elif target[i].isdigit():
            k = 0
            while i < len(target) and target[i].isdigit():
                k = k * 10 + int(target[i])
                i += 1
            j += k
        else:
            return False
    return i == len(target) and j == len(word)

def min_abbreviation(target, dictionary):
    ans = target
    for k in range(0, len(target) + 1):
        for i in range(0, len(target) - k + 1):
            current = abbreviate(target, k, i)
            if len(current) < len(ans):
                valid = True
                for word in dictionary:
                    if is_abbreviation(current, word):
                        valid = False
                        break
                if valid:
                    ans = current
    return ans


-----
def abbreviate(s, k, i):
    # Your code here


************************************
Question ID: 412
def fizzBuzz(n):
    result = []
    for i in range(1, n + 1):
        if i % 15 == 0:
            result.append("FizzBuzz")
        elif i % 3 == 0:
            result.append("Fizz")
        elif i % 5 == 0:
            result.append("Buzz")
        else:
            result.append(str(i))
    return result

-----
def fizzBuzz(n):
    # Your code here


************************************
Question ID: 413
def numberOfArithmeticSlices(nums):
    n = len(nums)
    count, cur = 0, 0
    for i in range(2, n):
        if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:
            cur += 1
            count += cur
        else:
            cur = 0
    return count

-----
def numberOfArithmeticSlices(nums):
    # Your code here


************************************
Question ID: 414
def third_max(nums):
    top3 = set()
    for num in nums:
        top3.add(num)
        if len(top3) > 3:
            top3.remove(min(top3))
    return min(top3) if len(top3) == 3 else max(top3)

-----
def third_max(nums):
    # Your code here


************************************
Question ID: 415
def addStrings(num1: str, num2: str) -> str:
    i, j, carry, result = len(num1) - 1, len(num2) - 1, 0, []

    while i >= 0 or j >= 0 or carry:
        sum = carry

        if i >= 0:
            sum += int(num1[i])
            i -= 1
        if j >= 0:
            sum += int(num2[j])
            j -= 1

        carry = sum // 10
        result.append(str(sum % 10))

    return ''.join(result[::-1])


-----
def addStrings(num1: str, num2: str) -> str:
    # Your code here


************************************
Question ID: 416
def canPartition(nums):
    total_sum = sum(nums)
    if total_sum % 2 != 0:
        return False
    
    target = total_sum // 2
    dp = [False] * (target + 1)
    dp[0] = True
    
    for num in nums:
        for i in range(target, num - 1, -1):
            dp[i] = dp[i] or dp[i - num]
    
    return dp[target]

-----
def canPartition(nums):
    # Your code here


************************************
Question ID: 417
def pacificAtlantic(heights):
    def dfs(r, c, prev_height, visited):
        if not (0 <= r < len(heights)) or not (0 <= c < len(heights[0])):
            return
        if heights[r][c] >= prev_height and not visited[r][c]:
            visited[r][c] = True
            dfs(r - 1, c, heights[r][c], visited)
            dfs(r + 1, c, heights[r][c], visited)
            dfs(r, c - 1, heights[r][c], visited)
            dfs(r, c + 1, heights[r][c], visited)

    m, n = len(heights), len(heights[0])
    pacific = [[False] * n for _ in range(m)]
    atlantic = [[False] * n for _ in range(m)]

    for r in range(m):
        dfs(r, 0, -1, pacific)
        dfs(r, n - 1, -1, atlantic)
    for c in range(n):
        dfs(0, c, -1, pacific)
        dfs(m - 1, c, -1, atlantic)

    result = []
    for r in range(m):
        for c in range(n):
            if pacific[r][c] and atlantic[r][c]:
                result.append([r, c])
    return result


-----
def pacificAtlantic(heights):
    # Your code here


************************************
Question ID: 418
def words_typing(sentence, rows, cols):
    total_chars = sum(len(word) + 1 for word in sentence)

    result = 0
    index = 0
    for _ in range(rows):
        remaining_cols = cols
        while True:
            word_len = len(sentence[index])
            if remaining_cols >= word_len:
                remaining_cols -= word_len + 1
                index = (index + 1) % len(sentence)
                if index == 0:
                    result += 1
            else:
                break

    return result

-----
def words_typing(sentence, rows, cols):
    # Your code here


************************************
Question ID: 419
def countBattleships(board):
    count = 0
    for i in range(len(board)):
        for j in range(len(board[0])):
            if (board[i][j] == 'X' and
                (i == 0 or board[i - 1][j] == '.') and
                (j == 0 or board[i][j - 1] == '.')):
                count += 1
    return count

-----
def countBattleships(board):
    # Your code here


************************************
Question ID: 420
def strong_password(password):
    missing_lower = 1
    missing_upper = 1
    missing_digit = 1
    total = len(password)
    
    for c in password:
        if c.islower(): missing_lower = 0
        if c.isupper(): missing_upper = 0
        if c.isdigit(): missing_digit = 0
    
    missing = missing_lower + missing_upper + missing_digit
    if total < 6: return max(missing, 6 - total)
    if total > 20: return missing + total - 20

    return missing

-----
def strong_password(password):
    # Your code here


************************************
Question ID: 421
def findMaximumXOR(nums):
    max_xor = 0
    mask = 0

    for i in range(31, -1, -1):
        mask |= (1 << i)
        prefixes = {num & mask for num in nums}

        possible_max = max_xor | (1 << i)

        for prefix in prefixes:
            if prefix ^ possible_max in prefixes:
                max_xor = possible_max
                break

    return max_xor

-----
def findMaximumXOR(nums):
    # Your code here


************************************
Question ID: 422
def valid_word_square(words):
    for i in range(len(words)):
        for j in range(len(words[i])):
            if j >= len(words) or i >= len(words[j]) or words[i][j] != words[j][i]:
                return False
    return True


-----
def valid_word_square(words):
    # Your code here


************************************
Question ID: 423
def find_digits_in_ascending_order(s):
    count = [0] * 10
    for c in s:
        if c == 'z': count[0] += 1
        if c == 'w': count[2] += 1
        if c == 'u': count[4] += 1
        if c == 'x': count[6] += 1
        if c == 'g': count[8] += 1
        if c == 'o': count[1] += 1
        if c == 'h': count[3] += 1
        if c == 'f': count[5] += 1
        if c == 's': count[7] += 1
        if c == 'i': count[9] += 1
    count[1] -= count[0] + count[2] + count[4]
    count[3] -= count[8]
    count[5] -= count[4]
    count[7] -= count[6]
    count[9] -= count[5] + count[6] + count[8]
    
    res = []
    for i in range(10):
        res.extend([str(i)] * count[i])
    return ''.join(res)


-----
def find_digits_in_ascending_order(s):
    # Your code here


************************************
Question ID: 424
def characterReplacement(s:str, k:int) -> int:
    n = len(s)
    left = 0
    right = 0
    maxFreq = 0
    result = 0
    freq = [0] * 26

    for right in range(n):
        freq[ord(s[right]) - ord('A')] += 1
        maxFreq = max(maxFreq, freq[ord(s[right]) - ord('A')])

        if right - left + 1 - maxFreq > k:
            freq[ord(s[left]) - ord('A')] -= 1
            left += 1

        result = max(result, right - left + 1)

    return result


-----
def characterReplacement(s:str, k:int) -> int:
    # Your code here


************************************
Question ID: 425
from collections import defaultdict

def wordSquares(words):
    def build(row, squares, word_lens):
        if row == word_lens:
            res.append(list(squares))
            return
        prefix = ''.join(squares[i][row] for i in range(row))
        for w in prefixes[prefix]:
            squares[row] = w
            build(row+1, squares, word_lens)

    if not words: return []
    res = []
    word_lens = len(words[0])
    
    prefixes = defaultdict(list)
    for word in words:
        for i in range(word_lens+1):
            prefixes[word[:i]].append(word)
            
    for word in words:
        build(1, [word] + [None]*(word_lens-1), word_lens)
        
    return res

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 433
from collections import deque

def minMutation(start, end, bank):
    q = deque([start])
    visited = set([start])
    depth = 0

    while q:
        levelSize = len(q)
        for _ in range(levelSize):
            current = q.popleft()
            if current == end:
                return depth

            for gene in bank:
                if gene not in visited:
                    diff = sum(1 for j in range(8) if current[j] != gene[j])
                    if diff == 1:
                        q.append(gene)
                        visited.add(gene)
        depth += 1
    return -1


-----
from collections import deque
    # Your code here


************************************
Question ID: 434
def count_segments(s: str) -> int:
    return len(s.split())

-----
def count_segments(s: str) -> int:
    # Your code here


************************************
Question ID: 435
def eraseOverlapIntervals(intervals):
    if not intervals:
        return 0
    
    intervals.sort(key=lambda x: x[1])
    
    count = 0
    prev_end = intervals[0][1]
    
    for i in range(1, len(intervals)):
        if intervals[i][0] < prev_end:
            count += 1
        else:
            prev_end = intervals[i][1]
    
    return count

-----
def eraseOverlapIntervals(intervals):
    # Your code here


************************************
Question ID: 436
def findRightInterval(intervals):
    starts = {interval[0]: index for index, interval in enumerate(intervals)}
    res = []

    for interval in intervals:
        right = min(filter(lambda x: x >= interval[1], starts.keys()), default=-1)
        res.append(starts[right] if right != -1 else -1)

    return res

-----
def findRightInterval(intervals):
    # Your code here


************************************
Question ID: 437
def path_sum_helper(node, target_sum, current_sum):
    if node is None:
        return 0

    current_sum += node.val
    total_paths = 1 if current_sum == target_sum else 0
    total_paths += path_sum_helper(node.left, target_sum, current_sum)
    total_paths += path_sum_helper(node.right, target_sum, current_sum)
    return total_paths

def path_sum(root, target_sum):
    if root is None:
        return 0

    return path_sum_helper(root, target_sum, 0) + path_sum(root.left, target_sum) + path_sum(root.right, target_sum)


-----
def path_sum_helper(node, target_sum, current_sum):
    # Your code here


************************************
Question ID: 438
def find_anagrams(s, p):
    if len(s) < len(p):
        return []

    s_count = [0] * 26
    p_count = [0] * 26
    for c in p:
        p_count[ord(c) - ord('a')] += 1

    result = []
    for i in range(len(s)):
        s_count[ord(s[i]) - ord('a')] += 1
        if i >= len(p):
            s_count[ord(s[i - len(p)]) - ord('a')] -= 1
        if s_count == p_count:
            result.append(i - len(p) + 1)

    return result

-----
def find_anagrams(s, p):
    # Your code here


************************************
Question ID: 439
def parseTernary(expression: str) -> str:
    stack = []
    for c in reversed(expression):
        if stack and stack[-1] == '?':
            stack.pop()  # Pop '?'
            first = stack.pop()
            stack.pop()  # Pop ':'
            second = stack.pop()
            stack.append(first if c == 'T' else second)
        else:
            stack.append(c)
    return stack[-1]


-----
def parseTernary(expression: str) -> str:
    # Your code here


************************************
Question ID: 440
def find_kth_number(n, k):
    nums = [i for i in range(1, n + 1)]
    nums.sort(key=lambda x: str(x))
    return nums[k - 1]


-----
def find_kth_number(n, k):
    # Your code here


************************************
Question ID: 441
def arrange_coins(n: int) -> int:
    k = 0
    while n > k:
        k += 1
        n -= k
    return k

-----
def arrange_coins(n: int) -> int:
    # Your code here


************************************
Question ID: 442
def find_duplicates(nums):
    duplicates = []
    for i in range(len(nums)):
        index = abs(nums[i]) - 1
        if nums[index] < 0:
            duplicates.append(abs(nums[i]))
        else:
            nums[index] *= -1
    return duplicates

-----
def find_duplicates(nums):
    # Your code here


************************************
Question ID: 443
def compress(chars):
    index, i = 0, 0
    
    while i < len(chars):
        count = 1
        while i + count < len(chars) and chars[i] == chars[i + count]:
            count += 1
            
        chars[index] = chars[i]
        index += 1
        
        if count > 1:
            count_str = str(count)
            for c in count_str:
                chars[index] = c
                index += 1
                
        i += count
        
    return index

-----
def compress(chars):
    # Your code here


************************************
Question ID: 444
def is_shortest_and_unique_supersequence(nums, sequences):
    pos = {val: idx for idx, val in enumerate(nums)}

    for seq in sequences:
        if pos[seq[0]] > pos[seq[-1]]:
            return False
    return True

-----
def is_shortest_and_unique_supersequence(nums, sequences):
    # Your code here


************************************
Question ID: 446
def numberOfArithmeticSlices(nums):
    res = 0
    n = len(nums)
    dp = [dict() for _ in range(n)]

    for i in range(n):
        for j in range(i):
            diff = nums[i] - nums[j]
            if diff <= -2**31 or diff > 2**31:
                continue

            dp[i][diff] = dp[i].get(diff, 0) + 1

            if diff in dp[j]:
                res += dp[j][diff]
                dp[i][diff] += dp[j][diff]

    return res


-----
def numberOfArithmeticSlices(nums):
    # Your code here


************************************
Question ID: 447
def numberOfBoomerangs(points):
    count = 0

    for i in points:
        group_count = {}
        for j in points:
            dx, dy = i[0] - j[0], i[1] - j[1]
            dist = dx * dx + dy * dy
            group_count[dist] = group_count.get(dist, 0) + 1

        for g in group_count.values():
            count += g * (g - 1)

    return count

-----
def numberOfBoomerangs(points):
    # Your code here


************************************
Question ID: 448
def find_disappeared_numbers(nums):
    result = []
    
    for num in nums:
        index = abs(num) - 1
        nums[index] = -abs(nums[index])

    for i, num in enumerate(nums):
        if num > 0:
            result.append(i + 1)

    return result

-----
def find_disappeared_numbers(nums):
    # Your code here


************************************
Question ID: 451
from collections import Counter

def sort_by_frequency(s):
    freq = Counter(s)
    chars = list(s)
    chars.sort(key=lambda c: freq[c], reverse=True)
    return ''.join(chars)

-----
from collections import Counter
    # Your code here


************************************
Question ID: 452
def findMinArrowShots(points):
    if not points:
        return 0
    points.sort(key=lambda x: x[1])

    arrows = 1
    end = points[0][1]

    for i in range(1, len(points)):
        if points[i][0] > end:
            arrows += 1
            end = points[i][1]

    return arrows

-----
def findMinArrowShots(points):
    # Your code here


************************************
Question ID: 453
def min_moves(nums):
    min_element = min(nums)
    moves = sum(num - min_element for num in nums)
    return moves


-----
def min_moves(nums):
    # Your code here


************************************
Question ID: 454
def fourSumCount(nums1, nums2, nums3, nums4):
    hashMap = {}
    count = 0

    for i in nums1:
        for j in nums2:
            hashMap[i + j] = hashMap.get(i + j, 0) + 1

    for k in nums3:
        for l in nums4:
            count += hashMap.get(-(k + l), 0)

    return count

-----
def fourSumCount(nums1, nums2, nums3, nums4):
    # Your code here


************************************
Question ID: 455
def find_content_children(g, s):
    g.sort()
    s.sort()
    i = j = 0

    while i < len(g) and j < len(s):
        if s[j] >= g[i]:
            i += 1

        j += 1

    return i


-----
def find_content_children(g, s):
    # Your code here


************************************
Question ID: 456
def find132pattern(nums):
    third, stack = float('-inf'), []
    for num in reversed(nums):
        if num < third:
            return True
        while stack and stack[-1] < num:
            third = stack.pop()
        stack.append(num)
    return False

-----
def find132pattern(nums):
    # Your code here


************************************
Question ID: 457
def circularArrayLoop(nums: List[int]) -> bool:
    N = len(nums)
    for i in range(N):
        slow, fast = i, i
        while True:
            slow = getNextIndex(slow, nums)
            fast = getNextIndex(getNextIndex(fast, nums), nums)
            if slow != fast and nums[slow] * nums[fast] > 0:
                break
            if slow == fast:
                break
        else:
            continue
        cycle = False
        start = slow
        while start != slow:
            cycle |= getNextIndex(start, nums) == start
            start = getNextIndex(start, nums)
        if not cycle:
            return True
    return False

def getNextIndex(idx: int, nums: List[int]) -> int:
    N = len(nums)
    return (idx + nums[idx]) % N


-----
def circularArrayLoop(nums: List[int]) -> bool:
    # Your code here


************************************
Question ID: 458
def poor_pigs(buckets, minutes_to_die, minutes_to_test):
    pigs = 0
    while (minutes_to_test // minutes_to_die + 1) ** pigs < buckets:
        pigs += 1
    return pigs


-----
def poor_pigs(buckets, minutes_to_die, minutes_to_test):
    # Your code here


************************************
Question ID: 459
def can_construct(s):
    n = len(s)
    for i in range(n // 2, 0, -1):
        if n % i == 0:
            substr = s[:i]
            flag = True
            for j in range(i, n, i):
                if s[j:j+i] != substr:
                    flag = False
                    break

            if flag:
                return True

    return False


-----
def can_construct(s):
    # Your code here


************************************
Question ID: 461
def hammingDistance(x: int, y: int) -> int:
    xorResult = x ^ y
    dist = 0
    while xorResult:
        dist += xorResult & 1
        xorResult >>= 1
    return dist

-----
def hammingDistance(x: int, y: int) -> int:
    # Your code here


************************************
Question ID: 462
def min_moves2(nums):
    nums.sort()
    mid = nums[len(nums) // 2]
    moves = 0
    for num in nums:
        moves += abs(num - mid)
    return moves

-----
def min_moves2(nums):
    # Your code here


************************************
Question ID: 463
def islandPerimeter(grid):
    perimeter = 0
    for row in range(len(grid)):
        for col in range(len(grid[row])):
            if grid[row][col] == 1:
                perimeter += 4
                if row > 0 and grid[row - 1][col] == 1:
                    perimeter -= 2
                if col > 0 and grid[row][col - 1] == 1:
                    perimeter -= 2
    return perimeter

-----
def islandPerimeter(grid):
    # Your code here


************************************
Question ID: 464
def canIWin(maxChoosableInteger, desiredTotal):
    if maxChoosableInteger >= desiredTotal: return True
    if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal: return False

    memo = {}
        
    def canWin(state):
        if state in memo:
            return memo[state]
        for i in range(1, maxChoosableInteger + 1):
            bitCheck = 1 << i
            if (state & bitCheck) == 0:
                if not canWin(state | bitCheck):
                    memo[state] = True
                    return True
    
        memo[state] = False
        return False

    return canWin(0)


-----
def canIWin(maxChoosableInteger, desiredTotal):
    # Your code here


************************************
Question ID: 465
from collections import defaultdict

def minTransfers(transactions):
    balances = defaultdict(int)
    for transaction in transactions:
        balances[transaction[0]] -= transaction[2]
        balances[transaction[1]] += transaction[2]

    debts = [balance for balance in balances.values() if balance != 0]
    return dfs(debts, 0)

def dfs(debts, start):
    while start < len(debts) and debts[start] == 0:
        start += 1
    if start == len(debts):
        return 0
    result = float('inf')
    for i in range(start + 1, len(debts)):
        if (debts[start] > 0) != (debts[i] > 0):
            debts[i] += debts[start]
            result = min(result, 1 + dfs(debts, start + 1))
            debts[i] -= debts[start]
    return result


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 466
def getMaxRepetitions(s1: str, n1: int, s2: str, n2: int) -> int:
    count1, count2, i, j = 0, 0, 0, 0
    while count1 < n1:
        if s1[i] == s2[j]:
            j += 1
            if j == len(s2):
                j = 0
                count2 += 1
        i += 1
        if i == len(s1):
            i = 0
            count1 += 1
    return count2 // n2


-----
def getMaxRepetitions(s1: str, n1: int, s2: str, n2: int) -> int:
    # Your code here


************************************
Question ID: 467
def findSubstringInWraproundString(p: str) -> int:
    cnt = [0] * 26
    length = 0

    for i in range(len(p)):
        if i > 0 and (p[i] == chr(ord(p[i - 1]) + 1) or ord(p[i - 1]) - ord(p[i]) == 25):
            length += 1
        else:
            length = 1
        cnt[ord(p[i]) - ord('a')] = max(cnt[ord(p[i]) - ord('a')], length)

    return sum(cnt)


-----
def findSubstringInWraproundString(p: str) -> int:
    # Your code here


************************************
Question ID: 468
def validateIP(queryIP):
    ipv4_parts = queryIP.split('.')
    ipv6_parts = queryIP.split(':')

    if len(ipv4_parts) == 4:
        if is_valid_ipv4(ipv4_parts):
            return "IPv4"
    elif len(ipv6_parts) == 8:
        if is_valid_ipv6(ipv6_parts):
            return "IPv6"

    return "Neither"

def is_valid_ipv4(parts):
    for part in parts:
        if not part or len(part) > 3 or (len(part) > 1 and part[0] == '0'):
            return False

        if not part.isdigit() or int(part) < 0 or int(part) > 255:
            return False

    return True

def is_valid_ipv6(parts):
    for part in parts:
        if not part or len(part) > 4:
            return False

        for ch in part:
            if not ch.isdigit() and not (ch.lower() >= 'a' and ch.lower() <= 'f'):
                return False

    return True

-----
def validateIP(queryIP):
    # Your code here


************************************
Question ID: 469
def isConvex(points):
    n = len(points)
    pre = cur = 0

    for i in range(n):
        x1 = points[(i + 1) % n][0] - points[i][0]
        y1 = points[(i + 1) % n][1] - points[i][1]
        x2 = points[(i + 2) % n][0] - points[(i + 1) % n][0]
        y2 = points[(i + 2) % n][1] - points[(i + 1) % n][1]
        cur = x1 * y2 - x2 * y1

        if cur == 0:
            continue
        if cur * pre < 0:
            return False
        pre = cur

    return True

-----
def isConvex(points):
    # Your code here


************************************
Question ID: 470
def rand7():
    pass  # Provided API

def rand10():
    result = None
    while True:
        result = (rand7() - 1) * 7 + rand7()
        if result <= 40:
            break
    return result % 10 + 1

-----
def rand7():
    # Your code here


************************************
Question ID: 471
def encode(s: str) -> str:
    n = len(s)
    for i in range(n // 2, 0, -1):
        if n % i == 0:
            reps = n // i
            sub = s[:i]
            composed = sub * reps
            if s == composed:
                return f"{reps}[{sub}]"
    return s

-----
def encode(s: str) -> str:
    # Your code here


************************************
Question ID: 472
def is_concatenated(word, word_dict):
    n = len(word)
    dp = [False] * (n + 1)
    dp[0] = True

    for i in range(1, n + 1):
        for j in range(i):
            if dp[j] and word[j:i] in word_dict:
                dp[i] = True
                break

    return dp[n]


def find_all_concatenated_words(words):
    word_dict = set(words)
    result = []

    for word in words:
        if is_concatenated(word, word_dict):
            result.append(word)

    return result

-----
def is_concatenated(word, word_dict):
    # Your code here


************************************
Question ID: 473
from itertools import chain

def makesquare(matchsticks):
    if len(matchsticks) < 4:
        return False
    total = sum(matchsticks)
    if total % 4:
        return False
    target = total // 4
    matchsticks.sort(reverse=True)
    sums = [0]*4
    return dfs(matchsticks, sums, target, 0)

def dfs(matchsticks, sums, target, index):
    if index == len(matchsticks):
        return sums[0] == target and sums[1] == target and sums[2] == target
    for i in range(4):
        if sums[i] + matchsticks[index] <= target:
            sums[i] += matchsticks[index]
            if dfs(matchsticks, sums, target, index + 1):
                return True
            sums[i] -= matchsticks[index]
    return False


-----
from itertools import chain
    # Your code here


************************************
Question ID: 474
def findMaxForm(strs, m, n):
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for s in strs:
        ones = s.count('1')
        zeros = len(s) - ones
        
        for i in range(m, zeros - 1, -1):
            for j in range(n, ones - 1, -1):
                dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)
    
    return dp[m][n]

-----
def findMaxForm(strs, m, n):
    # Your code here


************************************
Question ID: 475
def findRadius(houses, heaters):
    houses.sort()
    heaters.sort()
    result, i = 0, 0

    for house in houses:
        while i < len(heaters) - 1 and abs(heaters[i + 1] - house) <= abs(heaters[i] - house):
            i += 1
        result = max(result, abs(heaters[i] - house))

    return result

-----
def findRadius(houses, heaters):
    # Your code here


************************************
Question ID: 476
def find_complement(num: int) -> int:
    bit_length = 0
    mask = num
    while mask > 0:
        mask >>= 1
        bit_length += 1
    all_ones = (1 << bit_length) - 1

    return num ^ all_ones

-----
def find_complement(num: int) -> int:
    # Your code here


************************************
Question ID: 477
def total_hamming_distance(nums):
    total_distance = 0
    n = len(nums)

    for i in range(32):
        bit_count = sum(((num >> i) & 1) for num in nums)
        total_distance += bit_count * (n - bit_count)

    return total_distance

-----
def total_hamming_distance(nums):
    # Your code here


************************************
Question ID: 478
import random
from math import sqrt, pi, cos, sin

class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.radius = radius
        self.x_center = x_center
        self.y_center = y_center

    def randPoint(self):
        r = sqrt(random.random()) * self.radius
        theta = random.random() * 2 * pi
        return [self.x_center + r * cos(theta), self.y_center + r * sin(theta)]

-----
import random
    # Your code here


************************************
Question ID: 479
def largestPalindrome(n):
    if n == 1: 
        return 9
    upper_limit = 10**n - 1
    lower_limit = upper_limit // 10
    for i in range(upper_limit, lower_limit, -1):
        temp = i
        reverse = 0
        while temp != 0:
            reverse = reverse * 10 + temp % 10
            temp //= 10
        palindrome = i * (10**n) + reverse
        for j in range(upper_limit, lower_limit, -1):
            product = palindrome // j
            if palindrome % j == 0 and product <= upper_limit:
                return palindrome % 1337
    return -1

-----
def largestPalindrome(n):
    # Your code here


************************************
Question ID: 480
from sortedcontainers import SortedList

def medianSlidingWindow(nums, k):
    window = SortedList(nums[:k])
    medians = []
    
    for i in range(k, len(nums) + 1):
        medians.append((window[k // 2 - 1] + window[k // 2]) / 2 if k % 2 == 0 else float(window[k // 2]))
        
        if i < len(nums):
            window.remove(nums[i - k])
            window.add(nums[i])

    return medians


-----
from sortedcontainers import SortedList
    # Your code here


************************************
Question ID: 481
def magical_string(n: int) -> int:
    if n == 0:
        return 0
    if n <= 3:
        return 1

    magic = [1, 2, 2]
    count_ones = 1
    index = 2
    value = 1

    while len(magic) < n:
        for _ in range(magic[index]):
            magic.append(value)
            if value == 1 and len(magic) <= n:
                count_ones += 1
        value = 3 - value
        index += 1

    return count_ones


-----
def magical_string(n: int) -> int:
    # Your code here


************************************
Question ID: 482
def license_key_formatting(s: str, k: int) -> str:
    result = []
    count = 0
    for c in reversed(s):
        if c != '-':
            if count == k:
                result.append('-')
                count = 0
            result.append(c.upper())
            count += 1
    return ''.join(reversed(result))

-----
def license_key_formatting(s: str, k: int) -> str:
    # Your code here


************************************
Question ID: 483
def smallest_good_base(n: str) -> str:
    num_n = int(n)

    for m in range(int(num_n.bit_length()), 0, -1):
        k = int(num_n ** (1.0 / m))
        if sum(k**i for i in range(m+1)) == num_n:
            return str(k)

    return "-1"

-----
def smallest_good_base(n: str) -> str:
    # Your code here


************************************
Question ID: 484
def findPermutation(s: str) -> list[int]:
    perm = [0] * (len(s) + 1)
    left = 1
    i = 0
    while i < len(s):
        if s[i] == 'I':
            perm[i] = left
            left += 1
            while i + 1 < len(s) and s[i + 1] == 'D':
                i += 1
        i += 1
    perm[len(s)] = left
    left += 1
    for i in reversed(range(len(s))):
        if s[i] == 'D':
            perm[i] = left
            left += 1
    return perm

-----
def findPermutation(s: str) -> list[int]:
    # Your code here


************************************
Question ID: 485
def findMaxConsecutiveOnes(nums):
    max_consecutive, current_consecutive = 0, 0
    for num in nums:
        current_consecutive = current_consecutive + 1 if num == 1 else 0
        max_consecutive = max(max_consecutive, current_consecutive)
    return max_consecutive

-----
def findMaxConsecutiveOnes(nums):
    # Your code here


************************************
Question ID: 486
def can_win(nums):
    n = len(nums)
    dp = [[0] * n for _ in range(n)]
    for i in range(n):
        dp[i][i] = nums[i]
    for len in range(1, n):
        for i in range(n - len):
            j = i + len
            dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])
    return dp[0][n - 1] >= 0


-----
def can_win(nums):
    # Your code here


************************************
Question ID: 487
def findMaxConsecutiveOnes(nums: List[int]) -> int:
    max_count, count_zeros, left = 0, 0, 0
    for right in range(len(nums)):
        if nums[right] == 0:
            count_zeros += 1
        while count_zeros > 1:
            if nums[left] == 0:
                count_zeros -= 1
            left += 1
        max_count = max(max_count, right - left + 1)
    return max_count

-----
def findMaxConsecutiveOnes(nums: List[int]) -> int:
    # Your code here


************************************
Question ID: 488
from collections import Counter

def find_min_step(board: str, hand: str) -> int:
    def find_min_step_helper(board, memo, hand):
        if not board:
            return 0
        if board in memo:
            return memo[board]

        result = float('inf')
        i = 0
        while i < len(board):
            j = i
            while j < len(board) and board[i] == board[j]:
                j += 1            

            color = board[i]
            required = 3 - (j - i)
            if hand[color] >= required:
                hand[color] -= required
                next_board = board[:i] + board[j:]
                tmp = find_min_step_helper(next_board, memo, hand)
                if tmp != -1:
                    result = min(result, tmp + required)
                hand[color] += required
            i = j

        memo[board] = -1 if result == float('inf') else result
        return memo[board]

    hand_count = Counter(hand)
    memo = {}
    return find_min_step_helper(board, memo, hand_count)


-----
from collections import Counter
    # Your code here


************************************
Question ID: 489
from math import comb

def kthSmallestPath(destination, k):
    row, col = destination
    ans = ""

    for i in range(row + col):
        if row == 0:
            ans += 'H'
            col -= 1
        elif col == 0:
            ans += 'V'
            row -= 1
        elif k <= comb(row + col - 1, row - 1):
            ans += 'H'
            col -= 1
        else:
            ans += 'V'
            k -= comb(row + col - 1, row - 1)
            row -= 1

    return ans


-----
from math import comb
    # Your code here


************************************
Question ID: 490
def hasPath(maze, start, destination):
    dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))
    q = [start]
    while q:
        x, y = q.pop(0)
        if x == destination[0] and y == destination[1]:
            return True
        for dx, dy in dirs:
            i, j = x, y
            while 0 <= i + dx < len(maze) and 0 <= j + dy < len(maze[0]) and maze[i + dx][j + dy] == 0:
                i += dx
                j += dy
            if maze[i][j] == 0:
                maze[i][j] = 1
                q.append((i, j))
    return False

-----
def hasPath(maze, start, destination):
    # Your code here


************************************
Question ID: 491
from typing import List

def findSubsequences(nums: List[int]) -> List[List[int]]:
    res = set()
    dfs(nums, 0, [], res)
    return list(res)

def dfs(nums, start, path, res):
    if len(path) >= 2:
        res.add(tuple(path))
    for i in range(start, len(nums)):
        if path and path[-1] > nums[i]:
            continue
        dfs(nums, i + 1, path + [nums[i]], res)

-----
from typing import List
    # Your code here


************************************
Question ID: 492
def constructRectangle(area: int) -> List[int]:
    width = int(area**0.5)
    while area % width != 0:
        width -= 1
    length = area // width
    return [length, width]

-----
def constructRectangle(area: int) -> List[int]:
    # Your code here


************************************
Question ID: 493
def reversePairs(nums):
    def mergeSort(l, r):
        if l >= r:
            return 0
        
        mid = (l + r) // 2
        count = mergeSort(l, mid) + mergeSort(mid + 1, r)
        j = mid + 1
        for i in range(l, mid + 1):
            while j <= r and nums[i] > 2 * nums[j]:
                j += 1
            count += j - (mid + 1)
        
        nums[l:r + 1] = sorted(nums[l:r + 1])
        
        return count
    
    return mergeSort(0, len(nums) - 1)


-----
def reversePairs(nums):
    # Your code here


************************************
Question ID: 494
def findTargetSumWays(nums, target):
    total_sum = sum(nums)
    if total_sum < target or (total_sum + target) % 2 != 0:
        return 0
    target_sum = (total_sum + target) // 2
    dp = [0] * (target_sum + 1)
    dp[0] = 1
    for num in nums:
        for j in range(target_sum, num - 1, -1):
            dp[j] += dp[j - num]
    return dp[target_sum]


-----
def findTargetSumWays(nums, target):
    # Your code here


************************************
Question ID: 495
def find_poisoned_duration(time_series, duration):
    if not time_series:
        return 0
    total = 0
    for i in range(1, len(time_series)):
        total += min(time_series[i] - time_series[i - 1], duration)
    return total + duration

-----
def find_poisoned_duration(time_series, duration):
    # Your code here


************************************
Question ID: 496
def next_greater_element(nums1, nums2):
    next_greater = {}
    stack = []

    for num in nums2:
        while stack and stack[-1] < num:
            next_greater[stack.pop()] = num
        stack.append(num)

    return [next_greater.get(n, -1) for n in nums1]

-----
def next_greater_element(nums1, nums2):
    # Your code here


************************************
Question ID: 497
import random
from typing import List

class Solution:
    def __init__(self, rects: List[List[int]]):
        self.rects = rects
        self.areas = [0] * len(rects)
        self.total_area = 0

        for i, rect in enumerate(rects):
            area = (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1)
            self.areas[i] = area
            self.total_area += area

    def pick(self) -> List[int]:
        rnd = random.randint(0, self.total_area - 1)
        idx = 0
        while rnd >= self.areas[idx]:
            rnd -= self.areas[idx]
            idx += 1

        x = random.randint(self.rects[idx][0], self.rects[idx][2])
        y = random.randint(self.rects[idx][1], self.rects[idx][3])
        
        return [x, y]


-----
import random
    # Your code here


************************************
Question ID: 498
from typing import List

def findDiagonalOrder(mat: List[List[int]]) -> List[int]:
    m, n = len(mat), len(mat[0])
    result = [0] * (m * n)
    row, col = 0, 0
    for i in range(m * n):
        result[i] = mat[row][col]
        if (row + col) % 2 == 0:
            if col == n - 1:
                row += 1
            elif row == 0:
                col += 1
            else:
                row -= 1
                col += 1
        else:
            if row == m - 1:
                col += 1
            elif col == 0:
                row += 1
            else:
                row += 1
                col -= 1
    return result

-----
from typing import List
    # Your code here


************************************
Question ID: 499
from heapq import heappush, heappop

class Solution:
    def findShortestWay(self, maze: List[List[int]], ball: List[int], hole: List[int]) -> str:
        m, n = len(maze), len(maze[0])
        dist = [[float("inf")] * n for _ in range(m)]
        dirs = ["d", "l", "r", "u"]
        dirs_vector = [[1, 0], [0, -1], [0, 1], [-1, 0]]
        dist[ball[0]][ball[1]] = 0
        pq = [(0, "", ball[0], ball[1])]
        
        while pq:
            cur_dist, cur_path, x, y = heappop(pq)
            if [x, y] == hole:
                return cur_path

            for k, d in enumerate(dirs):
                dist_move, r, c = 0, x + dirs_vector[k][0], y + dirs_vector[k][1]
                while 0 <= r < m and 0 <= c < n and maze[r][c] == 0 and [r, c] != hole:
                    r += dirs_vector[k][0]
                    c += dirs_vector[k][1]
                    dist_move += 1
                r -= dirs_vector[k][0]
                c -= dirs_vector[k][1]
                dist_move -= 1
                
                if dist[x][y] + dist_move < dist[r][c]:
                    dist[r][c] = dist[x][y] + dist_move
                    heappush(pq, (cur_dist + dist_move, cur_path + d, r, c))
        
        return "impossible"

-----
from heapq import heappush, heappop
    # Your code here


************************************
Question ID: 500
def find_words(words):
    rows = [
        set("qwertyuiopQWERTYUIOP"),
        set("asdfghjklASDFGHJKL"),
        set("zxcvbnmZXCVBNM")
    ]
    res = []

    for word in words:
        row = -1
        for i in range(3):
            if word[0] in rows[i]:
                row = i
                break

        if all(c in rows[row] for c in word):
            res.append(word)

    return res


-----
def find_words(words):
    # Your code here


************************************
Question ID: 501
def findMode(root):
    def InOrder(node):
        if not node: return
        yield from InOrder(node.left)
        yield node.val
        yield from InOrder(node.right)
        
    counts = collections.Counter(InOrder(root))
    max_count = max(counts.values(), default=0)
    return [k for k, v in counts.items() if v == max_count]

-----
def findMode(root):
    # Your code here


************************************
Question ID: 502
import heapq

def findMaximizedCapital(k: int, w: int, profits, capital) -> int:
    project_pool = list(zip(capital, profits))
    project_pool.sort(reverse=True)
    
    profit_pool = []
    
    while k:
        while project_pool and project_pool[-1][0] <= w:
            heapq.heappush(profit_pool, -project_pool.pop()[1])
        
        if not profit_pool:
            break
        
        w -= heapq.heappop(profit_pool)
        k -= 1
        
    return w

-----
import heapq
    # Your code here


************************************
Question ID: 503
def nextGreaterElements(nums):
    result = [-1] * len(nums)
    stack = []

    for i in range(len(nums) * 2):
        index = i % len(nums)
        while stack and nums[stack[-1]] < nums[index]:
            result[stack.pop()] = nums[index]
        if i < len(nums):
            stack.append(index)

    return result

-----
def nextGreaterElements(nums):
    # Your code here


************************************
Question ID: 504
def convert_to_base7(num: int) -> str:
    if num == 0:
        return "0"
    result = ""
    negative = num < 0
    if negative:
        num *= -1
    while num > 0:
        result = str(num % 7) + result
        num //= 7
    return "-" + result if negative else result

-----
def convert_to_base7(num: int) -> str:
    # Your code here


************************************
Question ID: 505
from queue import PriorityQueue

def shortestDistance(maze, start, destination):
    m, n = len(maze), len(maze[0])
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    dist = [[-1 for _ in range(n)] for _ in range(m)]

    q = PriorityQueue()

    dist[start[0]][start[1]] = 0
    q.put((0, start[0], start[1]))

    while not q.empty():
        cur = q.get()
        x, y = cur[1], cur[2]

        for dir in directions:
            newX, newY = x + dir[0], y + dir[1]
            step = 0

            while 0 <= newX < m and 0 <= newY < n and maze[newX][newY] == 0:
                newX += dir[0]
                newY += dir[1]
                step += 1

            newX -= dir[0]
            newY -= dir[1]

            if dist[newX][newY] == -1 or dist[x][y] + step < dist[newX][newY]:
                dist[newX][newY] = dist[x][y] + step
                q.put((dist[newX][newY], newX, newY))

    return dist[destination[0]][destination[1]]


-----
from queue import PriorityQueue
    # Your code here


************************************
Question ID: 506
def find_relative_ranks(score):
    rank_sort = sorted(range(len(score)), key=lambda i: score[i], reverse=True)
    result = [0] * len(score)
    for i, rank in enumerate(rank_sort):
        result[rank] = i + 1
    return result


-----
def find_relative_ranks(score):
    # Your code here


************************************
Question ID: 507
def checkPerfectNumber(num: int) -> bool:
    if num <= 1:
        return False
    sum = 1
    i = 2
    while i * i <= num:
        if num % i == 0:
            sum += i
            if i * i != num:
                sum += num // i
        i += 1
    return sum == num

-----
def checkPerfectNumber(num: int) -> bool:
    # Your code here


************************************
Question ID: 508
from collections import defaultdict

def helper(node, counts):
    if not node: return 0
    val = node.val + helper(node.left, counts) + helper(node.right, counts)
    counts[val] += 1
    return val

def findFrequentTreeSum(root):
    counts = defaultdict(int)
    helper(root, counts)
    max_count = max(counts.values(), default=0)
    return [s for s, c in counts.items() if c == max_count]


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 509
def fib(n: int) -> int:
    if n < 2:
        return n
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b

-----
def fib(n: int) -> int:
    # Your code here


************************************
Question ID: 513
def findBottomLeftValue(self, root: TreeNode) -> int:
    result = [0, 0] # [depth, value]
    self.helper(root, 1, result)
    return result[1]

def helper(self, node, depth, result):
    if not node:
        return
    if depth > result[0]:
        result[0] = depth
        result[1] = node.val

    self.helper(node.left, depth+1, result)
    self.helper(node.right, depth+1, result)


-----
def findBottomLeftValue(self, root: TreeNode) -> int:
    # Your code here


************************************
Question ID: 514
def find_rotate_steps(ring: str, key: str) -> int:
    n, m = len(ring), len(key)
    dp = [[0] * n for _ in range(m + 1)]

    for i in range(m - 1, -1, -1):
        for j in range(n):
            dp[i][j] = float('inf')
            for k in range(n):
                if ring[k] == key[i]:
                    diff = abs(j - k)
                    step = min(diff, n - diff)
                    dp[i][j] = min(dp[i][j], step + dp[i + 1][k])

    return dp[0][0] + m


-----
def find_rotate_steps(ring: str, key: str) -> int:
    # Your code here


************************************
Question ID: 515
from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def largestValues(root: TreeNode):
    if not root:
        return []
    result = []
    queue = deque([root])

    while queue:
        size = len(queue)
        max_val = float('-inf')
        for _ in range(size):
            node = queue.popleft()
            max_val = max(max_val, node.val)

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        result.append(max_val)

    return result

-----
from collections import deque
    # Your code here


************************************
Question ID: 516
def longestPalindromeSubseq(s: str) -> int:
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    
    for i in range(n - 1, -1, -1):
        dp[i][i] = 1
        for j in range(i + 1, n):
            if s[i] == s[j]:
                dp[i][j] = 2 + dp[i + 1][j - 1]
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
                
    return dp[0][n - 1]

-----
def longestPalindromeSubseq(s: str) -> int:
    # Your code here


************************************
Question ID: 517
def find_min_moves(machines):
    n = len(machines)
    total_dresses = sum(machines)
    if total_dresses % n != 0:
        return -1
    average = total_dresses // n
    moves = 0
    imbalance = 0
    
    for i in range(n):
        imbalance += machines[i] - average
        moves = max(moves, abs(imbalance), machines[i] - average)
        
    return moves

-----
def find_min_moves(machines):
    # Your code here


************************************
Question ID: 518
def change(amount, coins):
    dp = [1] + [0] * amount
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] += dp[i - coin]
    return dp[amount]

-----
def change(amount, coins):
    # Your code here


************************************
Question ID: 519
import random

class Solution:
    def __init__(self, m: int, n: int):
        self.m, self.n = m, n
        self.total = m * n
        self.matrix = [[0] * n for _ in range(m)]

    def flip(self):
        idx = random.randint(0, self.total - 1)
        self.total -= 1

        for i in range(self.m):
            for j in range(self.n):
                if self.matrix[i][j] == 0:
                    if idx == 0:
                        self.matrix[i][j] = 1
                        return [i, j]
                    idx -= 1
        return [-1, -1] # This line should never be reached

    def reset(self):
        self.total = self.m * self.n
        for row in self.matrix:
            for j in range(self.n):
                row[j] = 0


-----
import random
    # Your code here


************************************
Question ID: 520
def detectCapitalUse(word: str) -> bool:
    numCapital = sum(1 for c in word if c.isupper())
    return numCapital == 0 or numCapital == len(word) or (numCapital == 1 and word[0].isupper())


-----
def detectCapitalUse(word: str) -> bool:
    # Your code here


************************************
Question ID: 521
def findLUSlength(a: str, b: str) -> int:
    if a == b:
        return -1
    return max(len(a), len(b))

-----
def findLUSlength(a: str, b: str) -> int:
    # Your code here


************************************
Question ID: 522
def find_lus_length(strs):
    max_length = -1
    for i in range(len(strs)):
        is_uncommon = True
        for j in range(len(strs)):
            if i != j and strs[i] in strs[j]:
                is_uncommon = False
                break
        if is_uncommon:
            max_length = max(max_length, len(strs[i]))
    return max_length


-----
def find_lus_length(strs):
    # Your code here


************************************
Question ID: 523
def checkSubarraySum(nums, k):
    n, sum_ = len(nums), 0
    mp = {0: -1}
    for i, num in enumerate(nums):
        sum_ += num
        if k != 0:
            sum_ %= k
        if sum_ in mp:
            if i - mp[sum_] > 1:
                return True
        else:
            mp[sum_] = i
    return False

-----
def checkSubarraySum(nums, k):
    # Your code here


************************************
Question ID: 524
def findLongestWord(s, dictionary):
    def is_subsequence(target, source):
        iter_source = iter(source)
        return all(char in iter_source for char in target)

    dictionary = sorted(dictionary)
    longest = ''
    for word in dictionary:
        if is_subsequence(word, s) and len(word) > len(longest):
            longest = word
    return longest


-----
def findLongestWord(s, dictionary):
    # Your code here


************************************
Question ID: 525
def findMaxLength(nums):
    counts = {0: -1}
    max_len = count = 0
    for i, num in enumerate(nums):
        count += 1 if num == 1 else -1
        if count in counts:
            max_len = max(max_len, i - counts[count])
        else:
            counts[count] = i
    return max_len

-----
def findMaxLength(nums):
    # Your code here


************************************
Question ID: 526
def countArrangement(n: int) -> int:
    def helper(idx: int, visited: List[bool], n: int) -> int:
        if idx > n:
            return 1

        count = 0
        for i in range(1, n+1):
            if not visited[i] and (idx % i == 0 or i % idx == 0):
                visited[i] = True
                count += helper(idx+1, visited, n)
                visited[i] = False

        return count

    visited = [False] * (n+1)
    return helper(1, visited, n)

-----
def countArrangement(n: int) -> int:
    # Your code here


************************************
Question ID: 527
def wordsAbbreviation(words):
    def abbrev(word, k):
        return word[:k+1] + str(len(word) - k - 2) + word[-1] if k < len(word) - 2 else word

    n = len(words)
    abbr = [abbrev(word, 1) for word in words]
    prefix_len = [1] * n

    for i in range(n):
        while abbr.count(abbr[i]) > 1:
            groups = {}
            for j in range(i + 1, n):
                if abbr[i] == abbr[j]:
                    if abbr[j] not in groups:
                        groups[abbr[j]] = []
                    groups[abbr[j]].append(j)
            for group_members in groups.values():
                for j in group_members:
                    abbr[j] = abbrev(words[j], prefix_len[j] + 1)
                    prefix_len[j] += 1
            abbr[i] = abbrev(words[i], prefix_len[i] + 1)
            prefix_len[i] += 1

    return abbr

-----
def wordsAbbreviation(words):
    # Your code here


************************************
Question ID: 529
from typing import List

def reveal(board: List[List[str]], row: int, col: int, directions: List[List[int]]) -> None:
    if row < 0 or row >= len(board) or col < 0 or col >= len(board[0]) or board[row][col] != 'E':
        return

    mines = 0
    for dir in directions:
        newRow, newCol = row + dir[0], col + dir[1]
        if newRow >= 0 and newRow < len(board) and newCol >= 0 and newCol < len(board[0]) and board[newRow][newCol] == 'M':
            mines += 1

    if mines > 0:
        board[row][col] = str(mines)
    else:
        board[row][col] = 'B'
        for dir in directions:
            reveal(board, row + dir[0], col + dir[1], directions)

def updateBoard(board: List[List[str]], click: List[int]) -> List[List[str]]:
    row, col = click

    if board[row][col] == 'M':
        board[row][col] = 'X'
    else:
        directions = [[1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1]]
        reveal(board, row, col, directions)

    return board
```
-----
from typing import List
    # Your code here

```
************************************
Question ID: 531
def findLonelyPixel(picture):
    m, n = len(picture), len(picture[0])
    row, col = [0] * m, [0] * n
    
    for i in range(m):
        for j in range(n):
            if picture[i][j] == 'B':
                row[i] += 1
                col[j] += 1
                
    lonely = 0
    for i in range(m):
        for j in range(n):
            if picture[i][j] == 'B' and row[i] == 1 and col[j] == 1:
                lonely += 1
                
    return lonely

-----
def findLonelyPixel(picture):
    # Your code here


************************************
Question ID: 532
def find_pairs(nums, k):
    if k < 0:
        return 0
    starters = set()
    occurrences = {}
    for num in nums:
        if num + k in occurrences:
            starters.add(num)
        if num - k in occurrences:
            starters.add(num - k)
        occurrences[num] = occurrences.get(num, 0) + 1
    return len(starters)

-----
def find_pairs(nums, k):
    # Your code here


************************************
Question ID: 533
def findBlackPixel(picture, target):
    m, n = len(picture), len(picture[0])
    rows = [0] * m
    cols = [0] * n
    rowCounts = {}
    for i in range(m):
        row = ""
        for j in range(n):
            if picture[i][j] == 'B':
                rows[i] += 1
                cols[j] += 1
            row += picture[i][j]
        if rows[i] == target:
            rowCounts[row] = rowCounts.get(row, 0) + 1
    ans = 0
    for row, count in rowCounts.items():
        if count == target:
            for j in range(n):
                if row[j] == 'B' and cols[j] == target:
                    ans += count
    return ans

-----
def findBlackPixel(picture, target):
    # Your code here


************************************
Question ID: 535
import random
import string

class Solution:
    def __init__(self):
        self.url_map = {}
        self.alphabet = string.ascii_letters + string.digits

    def encode(self, longUrl: str) -> str:
        key = ''.join(random.choices(self.alphabet, k=6))

        while key in self.url_map:
            key = ''.join(random.choices(self.alphabet, k=6))

        self.url_map[key] = longUrl
        return "http://tinyurl.com/" + key

    def decode(self, shortUrl: str) -> str:
        return self.url_map[shortUrl[-6:]]

-----
import random
    # Your code here


************************************
Question ID: 537
def complexNumberMultiply(num1: str, num2: str) -> str:
    real1, imag1 = map(int, num1[:-1].split('+'))
    real2, imag2 = map(int, num2[:-1].split('+'))

    real = real1 * real2 - imag1 * imag2
    imag = real1 * imag2 + real2 * imag1

    return f"{real}+{imag}i"

-----
def complexNumberMultiply(num1: str, num2: str) -> str:
    # Your code here


************************************
Question ID: 539
def findMinDifference(timePoints):
    timePoints.sort()
    min_difference = float('inf')

    for i in range(len(timePoints)):
        h1, m1 = map(int, timePoints[i].split(':'))
        h2, m2 = map(int, timePoints[(i+1)%len(timePoints)].split(':'))
        cur_difference = abs((h1 * 60 + m1) - (h2 * 60 + m2))
        min_difference = min(min_difference, 1440 - cur_difference if cur_difference > 720 else cur_difference)

    return min_difference

-----
def findMinDifference(timePoints):
    # Your code here


************************************
Question ID: 540
def singleNonDuplicate(nums):
    low, high = 0, len(nums) - 1
    while low < high:
        mid = low + (high - low) // 2
        if mid % 2 == 1:
            mid -= 1
        if nums[mid] == nums[mid + 1]:
            low = mid + 2
        else:
            high = mid
    return nums[low]

-----
def singleNonDuplicate(nums):
    # Your code here


************************************
Question ID: 541
def reverseStr(s, k):
    chars = list(s)
    for i in range(0, len(chars), 2 * k):
        chars[i:i + k] = reversed(chars[i:i + k])
    return "".join(chars)

-----
def reverseStr(s, k):
    # Your code here


************************************
Question ID: 542
from collections import deque

def updateMatrix(mat):
    m, n = len(mat), len(mat[0])
    distance = [[0 if mat[i][j] == 0 else float('inf') for j in range(n)] for i in range(m)]
    queue = deque([(i, j) for i in range(m) for j in range(n) if mat[i][j] == 0])

    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    while queue:
        x, y = queue.popleft()
        for dx, dy in directions:
            newX, newY = x + dx, y + dy
            if 0 <= newX < m and 0 <= newY < n and distance[newX][newY] > distance[x][y] + 1:
                distance[newX][newY] = distance[x][y] + 1
                queue.append((newX, newY))

    return distance


-----
from collections import deque
    # Your code here


************************************
Question ID: 544
def findContestMatch(n):
    matches = [str(i) for i in range(1, n + 1)]

    while n > 1:
        for i in range(n // 2):
            matches[i] = "(" + matches[i] + "," + matches[n - 1 - i] + ")"
        n //= 2

    return matches[0]


-----
def findContestMatch(n):
    # Your code here


************************************
Question ID: 546
def removeBoxes(boxes):
    def dfs(l, r, k):
        if l > r: return 0
        if dp[l][r][k] != 0: return dp[l][r][k]

        while r > l and boxes[r] == boxes[r - 1]:
            r -= 1
            k += 1
            
        dp[l][r][k] = (k + 1) * (k + 1) + dfs(l, r - 1, 0)

        for i in range(l, r):
            if boxes[i] == boxes[r]:
                dp[l][r][k] = max(dp[l][r][k], dfs(l, i, k + 1) + dfs(i + 1, r - 1, 0))
                
        return dp[l][r][k]

    dp = [[[0] * 100 for _ in xrange(100)] for _ in xrange(100)]
    return dfs(0, len(boxes) - 1, 0)

-----
def removeBoxes(boxes):
    # Your code here


************************************
Question ID: 547
def findCircleNum(isConnected):
    def dfs(isConnected, visited, i):
        visited[i] = True
        for j in range(len(isConnected)):
            if isConnected[i][j] == 1 and not visited[j]:
                dfs(isConnected, visited, j)

    provinces = 0
    visited = [False] * len(isConnected)
    for i in range(len(isConnected)):
        if not visited[i]:
            dfs(isConnected, visited, i)
            provinces += 1
    return provinces

-----
def findCircleNum(isConnected):
    # Your code here


************************************
Question ID: 548
def find_triplet_equal_sum(nums):
    n = len(nums)
    prefix_sum = [0] * (n + 1)

    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]

    for i in range(1, n - 2):
        for j in range(i + 2, n - 1):
            for k in range(j + 2, n):
                s1 = prefix_sum[i]
                s2 = prefix_sum[j] - prefix_sum[i + 1]
                s3 = prefix_sum[k] - prefix_sum[j + 1]
                s4 = prefix_sum[n] - prefix_sum[k + 1]
                if s1 == s2 == s3 == s4:
                    return True
    return False

-----
def find_triplet_equal_sum(nums):
    # Your code here


************************************
Question ID: 551
def checkRecord(s: str) -> bool:
    late, absent = 0, 0
    for c in s:
        if c == 'A':
            absent += 1
            late = 0
        elif c == 'L':
            late += 1
        else:
            late = 0

        if absent >= 2 or late >= 3:
            return False
    return True

-----
def checkRecord(s: str) -> bool:
    # Your code here


************************************
Question ID: 552
def checkRecord(n: int) -> int:
    M = 1000000007
    dp = [1] * 6  # [latent state 0, latent state 1, ..., latent state 5]
    while n:
        next_dp = [0] * 6
        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M
        next_dp[1] = dp[0]
        next_dp[2] = dp[1]
        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M
        next_dp[4] = dp[3]
        next_dp[5] = dp[4]
        dp = next_dp
        n -= 1
    return sum(dp) % M


-----
def checkRecord(n: int) -> int:
    # Your code here


************************************
Question ID: 553
def optimal_division(nums):
    n = len(nums)
    if n == 1:
        return str(nums[0])
    if n == 2:
        return str(nums[0]) + '/' + str(nums[1])
    res = str(nums[0]) + '/('
    for i in range(1, n - 1):
        res += str(nums[i]) + '/'
    res += str(nums[n - 1]) + ')'
    return res


-----
def optimal_division(nums):
    # Your code here


************************************
Question ID: 554
from collections import defaultdict

def least_bricks(wall):
    edge_count = defaultdict(int)
    max_count = 0

    for row in wall:
        edge_position = 0
        for i in range(len(row) - 1):
            edge_position += row[i]
            edge_count[edge_position] += 1
            max_count = max(max_count, edge_count[edge_position])

    return len(wall) - max_count


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 555
def splitLoopedString(strs):
    ans = ''
    cur = ''.join(max(s, s[::-1]) for s in strs)
    
    for i, s in enumerate(strs):
        for xstr in (s, s[::-1]):
            for j in range(len(xstr)):
                t = xstr[j:] + cur[len(xstr):] + cur[:len(xstr)] + xstr[:j]
                ans = max(ans, t)
        cur = cur[len(s):] + cur[:len(s)]
    
    return ans


-----
def splitLoopedString(strs):
    # Your code here


************************************
Question ID: 556
from itertools import permutations

def nextGreaterElement(n: int) -> int:
    num_str = str(n)
    num_permutations = sorted(set(int("".join(p)) for p in permutations(num_str)))
    index = num_permutations.index(n)
    if index + 1 < len(num_permutations) and num_permutations[index + 1] <= 2**31 - 1:
        return num_permutations[index + 1]
    return -1

-----
from itertools import permutations
    # Your code here


************************************
Question ID: 557
def reverse_words_in_string(s: str) -> str:
    return " ".join(word[::-1] for word in s.split(" "))

-----
def reverse_words_in_string(s: str) -> str:
    # Your code here


************************************
Question ID: 560
def subarraySum(nums, k):
    prefix_sum_frequency = {0: 1}
    prefix_sum, result = 0, 0
    
    for num in nums:
        prefix_sum += num
        result += prefix_sum_frequency.get(prefix_sum - k, 0)
        prefix_sum_frequency[prefix_sum] = prefix_sum_frequency.get(prefix_sum, 0) + 1

    return result

-----
def subarraySum(nums, k):
    # Your code here


************************************
Question ID: 561
def array_pair_sum(nums):
    nums.sort()
    return sum(nums[::2])

-----
def array_pair_sum(nums):
    # Your code here


************************************
Question ID: 562
def longestLine(mat):
    rows, cols = len(mat), len(mat[0])
    max_length = 0
    dp = [[[0, 0, 0, 0] for _ in range(cols)] for _ in range(rows)]

    for r in range(rows):
        for c in range(cols):
            if mat[r][c] == 1:
                dp[r][c][0] = dp[r - 1][c][0] + 1 if r > 0 else 1
                dp[r][c][1] = dp[r][c - 1][1] + 1 if c > 0 else 1
                dp[r][c][2] = dp[r - 1][c - 1][2] + 1 if r > 0 and c > 0 else 1
                dp[r][c][3] = dp[r - 1][c + 1][3] + 1 if r > 0 and c < cols - 1 else 1
                max_length = max(max_length, max(dp[r][c]))

    return max_length


-----
def longestLine(mat):
    # Your code here


************************************
Question ID: 563
def findTilt(self, root):
    def findTiltUtil(node):
        if not node: return 0, 0
        
        leftSum, leftTilt = findTiltUtil(node.left)
        rightSum, rightTilt = findTiltUtil(node.right)
    
        return (node.val + leftSum + rightSum, abs(leftSum - rightSum) + leftTilt + rightTilt)

    return findTiltUtil(root)[1]


-----
def findTilt(self, root):
    # Your code here


************************************
Question ID: 564
def is_palindrome(s: str) -> bool:
    return s == s[::-1]

def closest_palindrome(n: str) -> int:
    num = int(n)
    left = num - 1
    right = num + 1

    while True:
        if is_palindrome(str(left)):
            return left
        if is_palindrome(str(right)):
            return right
        left -= 1
        right += 1

-----
def is_palindrome(s: str) -> bool:
    # Your code here


************************************
Question ID: 565
def arrayNesting(nums):
    n = len(nums)
    max_len = 0
    for i in range(n):
        if nums[i] != -1:
            start = nums[i]
            count = 0
            while nums[start] != -1:
                temp = start
                start = nums[start]
                count += 1
                nums[temp] = -1
            max_len = max(max_len, count)
    return max_len

-----
def arrayNesting(nums):
    # Your code here


************************************
Question ID: 566
def matrixReshape(mat, r, c):
    m, n = len(mat), len(mat[0])
    if m * n != r * c:
        return mat

    reshaped = [[0] * c for _ in range(r)]
    for i in range(m * n):
        reshaped[i // c][i % c] = mat[i // n][i % n]

    return reshaped

-----
def matrixReshape(mat, r, c):
    # Your code here


************************************
Question ID: 567
def checkInclusion(s1: str, s2: str) -> bool:
    if len(s1) > len(s2): 
        return False
    
    s1_map = [0] * 26
    s2_map = [0] * 26
    
    for i in range(len(s1)):
        s1_map[ord(s1[i]) - ord('a')] += 1
        s2_map[ord(s2[i]) - ord('a')] += 1
    
    for i in range(len(s2) - len(s1)):
        if s1_map == s2_map: 
            return True
        
        s2_map[ord(s2[i]) - ord('a')] -= 1
        s2_map[ord(s2[i + len(s1)]) - ord('a')] += 1

    return s1_map == s2_map


-----
def checkInclusion(s1: str, s2: str) -> bool:
    # Your code here


************************************
Question ID: 568
def maxVacationDays(flights, days):
    n = len(flights)
    k = len(days[0])
    memo = [[-1] * k for _ in range(n)]

    def dfs(currentWeek, currentCity):
        if currentWeek == k:
            return 0
        if memo[currentCity][currentWeek] != -1:
            return memo[currentCity][currentWeek]

        maxVacation = days[currentCity][currentWeek] + dfs(currentWeek + 1, currentCity)

        for i in range(n):
            if flights[currentCity][i] == 1:
                maxVacation = max(maxVacation, days[i][currentWeek] + dfs(currentWeek + 1, i))

        memo[currentCity][currentWeek] = maxVacation
        return maxVacation

    return dfs(0, 0)


-----
def maxVacationDays(flights, days):
    # Your code here


************************************
Question ID: 572

```javascript
class TreeNode {
    constructor(val, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

function isSubtree(root, subRoot) {
    if (root === null) return false;
    if (isIdentical(root, subRoot)) return true;
    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);
}

function isIdentical(n1, n2) {
    if (n1 === null || n2 === null) return n1 === n2;
    if (n1.val !== n2.val) return false;
    return isIdentical(n1.left, n2.left) && isIdentical(n1.right, n2.right);
}
```


-----

    # Your code here


************************************
Question ID: 573
def minDistance(height, width, tree, squirrel, nuts):
    totalDist = 0
    minDiff = float("inf")
    
    for nut in nuts:
        treeDist = abs(tree[0] - nut[0]) + abs(tree[1] - nut[1])
        squirrelDist = abs(squirrel[0] - nut[0]) + abs(squirrel[1] - nut[1])
        
        totalDist += 2 * treeDist
        minDiff = min(minDiff, squirrelDist - treeDist)
    
    return totalDist + minDiff


-----
def minDistance(height, width, tree, squirrel, nuts):
    # Your code here


************************************
Question ID: 575
def maxNumberOfCandies(candyType):
    uniqueCandies = set(candyType)
    return min(len(uniqueCandies), len(candyType) // 2)


-----
def maxNumberOfCandies(candyType):
    # Your code here


************************************
Question ID: 576
def findPaths(m, n, maxMove, startRow, startColumn):               
    MOD = 10**9 + 7                     
    dp = [[[0]* n for _ in range(m)] for _ in range(maxMove + 1)]
    moves = ((-1, 0), (1, 0), (0, -1), (0, 1))

    for k in range(1, maxMove + 1):                                
        for i in range(m):                                         
            for j in range(n):                                           
                for move in moves:              
                    ni, nj = i + move[0], j + move[1]
                    if ni < 0 or ni >= m or nj < 0 or nj >= n:                                 
                        dp[k][i][j] = (dp[k][i][j] + 1) % MOD          
                    else:
                        dp[k][i][j] = (dp[k][i][j] + dp[k - 1][ni][nj]) % MOD

    return dp[maxMove][startRow][startColumn]

-----
def findPaths(m, n, maxMove, startRow, startColumn):               
    # Your code here


************************************
Question ID: 581
def findUnsortedSubarray(nums):
    sorted_nums = sorted(nums)
    start, end = 0, len(nums) - 1
    while start < len(nums) and nums[start] == sorted_nums[start]:
        start += 1
    while end > start and nums[end] == sorted_nums[end]:
        end -= 1
    return end - start + 1

-----
def findUnsortedSubarray(nums):
    # Your code here


************************************
Question ID: 582
from collections import defaultdict

def killProcess(pid, ppid, kill):
    children = defaultdict(list)
    for i in range(len(pid)):
        children[ppid[i]].append(pid[i])

    def dfs(id, killed):
        killed.append(id)
        for child in children[id]:
            dfs(child, killed)

    killed = []
    dfs(kill, killed)
    return killed

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 583
def minDistance(word1, word2):
    m, n = len(word1), len(word2)
    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]

    for i in range(m+1):
        for j in range(n+1):
            if i == 0 or j == 0:
                dp[i][j] = i + j
            elif word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])

    return dp[m][n]

-----
def minDistance(word1, word2):
    # Your code here


************************************
Question ID: 587
def cross_product(p, q, r):
    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])

def fence(trees):
    trees.sort(key=lambda p: (p[0], p[1]))
    hull = []
    for p in trees:
        while len(hull) >= 2 and cross_product(hull[-2], hull[-1], p) > 0:
            hull.pop()
        hull.append(p)

    for p in reversed(trees):
        while len(hull) >= 2 and cross_product(hull[-2], hull[-1], p) > 0:
            hull.pop()
        hull.append(p)
    
    return hull

-----
def cross_product(p, q, r):
    # Your code here


************************************
Question ID: 591
def is_valid(code, i):
    if i >= len(code) or code[i] != '<':
        return False, i
    i += 1
    name_start = i
    while i < len(code) and code[i].isupper():
        i += 1
    name_len = i - name_start
    if name_len < 1 or name_len > 9 or code[i] != '>':
        return False, i
    i += 1

    while i < len(code) and code[i] != '<':
        i += 1
    if i + 2 + name_len >= len(code) or code[i:i + 2 + name_len] != '</' + code[name_start:i] + '>':
        return False, i
    return True, i + 2 + name_len

def validate_code_snippet(code):
    is_valid_code, i = is_valid(code, 0)
    return is_valid_code and i == len(code)

-----
def is_valid(code, i):
    # Your code here


************************************
Question ID: 592
from fractions import Fraction

def fractionAddition(expression: str) -> str:
    fractions = expression.replace('+', ' +').replace('-', ' -').split()
    result = sum(Fraction(fraction) for fraction in fractions)
    return f"{result.numerator}/{result.denominator}"

-----
from fractions import Fraction
    # Your code here


************************************
Question ID: 593
def validSquare(p1, p2, p3, p4):
    def dist_sq(p, q):
        return (p[0] - q[0])**2 + (p[1] - q[1])**2

    points = [p1, p2, p3, p4]
    dists = set()

    for i in range(4):
        for j in range(i + 1, 4):
            dists.add(dist_sq(points[i], points[j]))

    return len(dists) == 2 and 0 not in dists

-----
def validSquare(p1, p2, p3, p4):
    # Your code here


************************************
Question ID: 594
def findLHS(nums):
    count = {}
    for num in nums:
        count[num] = count.get(num, 0) + 1

    longest_sequence = 0
    for key in count:
        if key + 1 in count:
            longest_sequence = max(longest_sequence, count[key] + count[key + 1])

    return longest_sequence

-----
def findLHS(nums):
    # Your code here


************************************
Question ID: 598
def maxCount(m: int, n: int, ops: List[List[int]]) -> int:
    for op in ops:
        m = min(m, op[0])
        n = min(n, op[1])
    return m * n

-----
def maxCount(m: int, n: int, ops: List[List[int]]) -> int:
    # Your code here


************************************
Question ID: 599
from typing import List

def findRestaurant(list1: List[str], list2: List[str]) -> List[str]:
    restaurantMap = {restaurant: i for i, restaurant in enumerate(list1)}

    minSum = float("inf")
    result = []
    for j, restaurant in enumerate(list2):
        if restaurant in restaurantMap:
            totalSum = j + restaurantMap[restaurant]
            if totalSum < minSum:
                result = [restaurant]
                minSum = totalSum
            elif totalSum == minSum:
                result.append(restaurant)

    return result


-----
from typing import List
    # Your code here


************************************
Question ID: 600
def findIntegers(n: int) -> int:
    dp = [[0, 0] for _ in range(32)]
    dp[0][0], dp[0][1] = 1, 1

    for i in range(1, 32):
        dp[i][0] = dp[i - 1][0] + dp[i - 1][1]
        dp[i][1] = dp[i - 1][0]

    ans = 0
    prev_bit = 0
    for i in range(30, -1, -1):
        if n & (1 << i):
            ans += dp[i][0]
            if prev_bit:
                break
            prev_bit = 1
        else:
            prev_bit = 0

    return ans + 1


-----
def findIntegers(n: int) -> int:
    # Your code here


************************************
Question ID: 605
def canPlaceFlowers(flowerbed, n):
    count = 0
    for i in range(len(flowerbed)):
        if flowerbed[i] == 0 and (i == 0 or flowerbed[i - 1] == 0) and (i == len(flowerbed) - 1 or flowerbed[i + 1] == 0):
            flowerbed[i] = 1
            count += 1
        if count >= n:
            return True
    return count >= n


-----
def canPlaceFlowers(flowerbed, n):
    # Your code here


************************************
Question ID: 609
from collections import defaultdict

def find_duplicate(paths):
    content_map = defaultdict(list)
    for path in paths:
        parts = path.split()
        directory = parts[0]
        for file in parts[1:]:
            start = file.index('(')
            end = file.index(')')
            content = file[start + 1:end]
            file_path = directory + '/' + file[:start]
            content_map[content].append(file_path)

    result = [file_paths for file_paths in content_map.values() if len(file_paths) > 1]
    return result

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 611
def triangleNumber(nums: list) -> int:
    nums.sort()
    count = 0
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            for k in range(j + 1, len(nums)):
                if nums[i] + nums[j] > nums[k]:
                    count += 1
                else:
                    break
    return count

-----
def triangleNumber(nums: list) -> int:
    # Your code here


************************************
Question ID: 616
def addBoldTag(s: str, words: list) -> str:
    n = len(s)
    marked = [False] * n
    for word in words:
        pos = s.find(word)
        while pos != -1:
            for i in range(pos, pos + len(word)):
                marked[i] = True
            pos = s.find(word, pos + 1)
    result = []
    i = 0
    while i < n:
        if marked[i]:
            result.append("<b>")
            while i < n and marked[i]:
                result.append(s[i])
                i += 1
            result.append("</b>")
        else:
            result.append(s[i])
            i += 1
    return "".join(result)

-----
def addBoldTag(s: str, words: list) -> str:
    # Your code here


************************************
Question ID: 621
from collections import Counter

def least_interval(tasks, n):
    task_freq = Counter(tasks)

    max_f = max(task_freq.values())
    max_count = sum(1 for count in task_freq.values() if count == max_f)

    return max(len(tasks), (max_f - 1) * (n + 1) + max_count)


-----
from collections import Counter
    # Your code here


************************************
Question ID: 623
def add_one_row_helper(node, val, depth, current_depth):
    if not node:
        return
    if current_depth == depth - 1:
        left = node.left
        right = node.right
        node.left = TreeNode(val)
        node.left.left = left
        node.right = TreeNode(val)
        node.right.right = right
    else:
        add_one_row_helper(node.left, val, depth, current_depth + 1)
        add_one_row_helper(node.right, val, depth, current_depth + 1)
        
def add_one_row(root, val, depth):
    if depth == 1:
        new_root = TreeNode(val)
        new_root.left = root
        return new_root
    add_one_row_helper(root, val, depth, 1)
    return root

-----
def add_one_row_helper(node, val, depth, current_depth):
    # Your code here


************************************
Question ID: 624
def maxDistance(arrays: List[List[int]]) -> int:
    max_dist = 0
    min_val = arrays[0][0]
    max_val = arrays[0][-1]
    
    for arr in arrays[1:]:
        max_dist = max(max_dist, max(abs(arr[-1] - min_val), abs(max_val - arr[0])))
        min_val = min(min_val, arr[0])
        max_val = max(max_val, arr[-1])
        
    return max_dist

-----
def maxDistance(arrays: List[List[int]]) -> int:
    # Your code here


************************************
Question ID: 625
def smallestFactorization(num: int) -> int:
    if num == 1:
        return 1
    result = 0
    factor = 1
    for i in range(9, 1, -1):
        while num % i == 0:
            num //= i
            result += i * factor
            factor *= 10
            if result > 2**31 - 1:
                return 0
    return result if num == 1 else 0

-----
def smallestFactorization(num: int) -> int:
    # Your code here


************************************
Question ID: 628
def maximumProduct(nums):
    nums.sort()
    n = len(nums)
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])

-----
def maximumProduct(nums):
    # Your code here


************************************
Question ID: 629
def kInversePairs(n: int, k: int) -> int:
    mod = 10**9 + 7
    dp = [[0] * (k + 1) for _ in range(n + 1)]
    for i in range(1, n + 1):
        dp[i][0] = 1
        for j in range(1, k + 1):
            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod
            if j - i >= 0:
                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod
    return dp[n][k]

-----
def kInversePairs(n: int, k: int) -> int:
    # Your code here


************************************
Question ID: 630
import heapq

def scheduleCourse(courses):
    courses.sort(key=lambda x: x[1])
    curr_time, duration_sum = 0, []

    for duration, deadline in courses:
        curr_time += duration
        heapq.heappush(duration_sum, -duration)

        if curr_time > deadline:
            curr_time += heapq.heappop(duration_sum)

    return len(duration_sum)

-----
import heapq
    # Your code here


************************************
Question ID: 632
import heapq

def smallestRange(nums):
    minHeap = []
    maxVal = -1e9
    
    for i, lst in enumerate(nums):
        heapq.heappush(minHeap, (lst[0], i))
        maxVal = max(maxVal, lst[0])
        
    listIndices = [0] * len(nums)
    minRange = 1e9
    start, end = -1, -1
    
    while len(minHeap) == len(nums):
        val, listIdx = heapq.heappop(minHeap)
        range_ = maxVal - val
        
        if range_ < minRange:
            minRange = range_
            start, end = val, maxVal
            
        listIndices[listIdx] += 1
        if listIndices[listIdx] < len(nums[listIdx]):
            newVal = nums[listIdx][listIndices[listIdx]]
            heapq.heappush(minHeap, (newVal, listIdx))
            maxVal = max(maxVal, newVal)
            
    return [start, end]

-----
import heapq
    # Your code here


************************************
Question ID: 633
def judge_square_sum(c):
    for a in range(int(c ** 0.5) + 1):
        b = int((c - a * a) ** 0.5)
        if a * a + b * b == c:
            return True
    return False

-----
def judge_square_sum(c):
    # Your code here


************************************
Question ID: 634
def findDerangement(n: int) -> int:
    MOD = 10**9 + 7
    dp = [0] * (n + 1)
    dp[2] = 1
    for i in range(3, n + 1):
        dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD
    return dp[n]

-----
def findDerangement(n: int) -> int:
    # Your code here


************************************
Question ID: 636
def exclusiveTime(n, logs):
    res = [0] * n
    stack = []
    prev_time = 0

    for log in logs:
        parts = log.split(':')
        id = int(parts[0])
        type = parts[1]
        time = int(parts[2])

        if type == "start":
            if stack:
                res[stack[-1]] += time - prev_time
            stack.append(id)
            prev_time = time
        else:
            res[stack.pop()] += time - prev_time + 1
            prev_time = time + 1

    return res

-----
def exclusiveTime(n, logs):
    # Your code here


************************************
Question ID: 638
from typing import List

def shoppingOffers(price: List[int], special: List[List[int]], needs: List[int]) -> int:
    def helper(index):
        if index == len(special):
            return sum(needs[i] * price[i] for i in range(len(needs)))

        no_offer = helper(index + 1)
        can_apply_offer = True
        for i in range(len(needs)):
            needs[i] -= special[index][i]
            if needs[i] < 0:
                can_apply_offer = False

        with_offer = float('inf')
        if can_apply_offer:
            offer_cost = special[index][-1] + helper(index)
            with_offer = min(no_offer, offer_cost)

        for i in range(len(needs)):
            needs[i] += special[index][i]
        
        return with_offer if can_apply_offer else no_offer

    return helper(0)


-----
from typing import List
    # Your code here


************************************
Question ID: 639
def num_decodings(s: str) -> int:
    MOD = 10**9 + 7
    n = len(s)
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 9 if s[0] == '*' else (0 if s[0] == '0' else 1)

    for i in range(2, n + 1):
        c, prev_c = s[i - 1], s[i - 2]
        
        if c == '*':
            dp[i] = 9 * dp[i - 1]
            if prev_c == '1': dp[i] += 9 * dp[i - 2]
            elif prev_c == '2': dp[i] += 6 * dp[i - 2]
            elif prev_c == '*': dp[i] += 15 * dp[i - 2]
        else:
            dp[i] = dp[i - 1] if c != '0' else 0
            num = int(s[i - 2 : i])
            if prev_c == '1' or (prev_c == '2' and num <= 26): dp[i] += dp[i - 2]
            elif prev_c == '*': dp[i] += 2 * dp[i - 2] if 10 <= num <= 26 else dp[i - 2]

        dp[i] %= MOD
    return dp[n]

-----
def num_decodings(s: str) -> int:
    # Your code here


************************************
Question ID: 640
def solve_equation(equation: str) -> str:
    coef = val = left = operate = 0
    equation += '+'
    parts = [s.strip()+c for c in equation if c in '+-' for s in equation.split(c)]
    for part in parts:
        if part == '=':
            left = -1
            operate = 1
        else:
            n, x = part.split('x')
            value_to_change = 1 if n else int(n)
            if x:
                coef += (1 if part[0] == '+' else -1) * left * operate * value_to_change
            else:
                val += (1 if part[0] == '+' else -1) * left * operate * value_to_change
            operate = 1 - x.find('x')

    if coef == 0:
        return "Infinite solutions" if val == 0 else "No solution"
    return "x=" + str(-val // coef)


-----
def solve_equation(equation: str) -> str:
    # Your code here


************************************
Question ID: 642
from typing import List
import heapq

class TrieNode:
    def __init__(self):
        self.children = {}
        self.sentence = ""
        self.times = 0

class AutocompleteSystem:

    def __init__(self, sentences: List[str], times: List[int]):
        self.root = TrieNode()
        self.current = self.root
        self.search = ""
        
        for i in range(len(sentences)):
            self.insert(sentences[i], times[i])

    def insert(self, sentence: str, times: int):
        curr = self.root
        for c in sentence:
            if c not in curr.children:
                curr.children[c] = TrieNode()
            curr = curr.children[c]
        curr.sentence = sentence
        curr.times += times

    def input(self, c: str) -> List[str]:
        if c == '#':
            self.insert(self.search, 1)
            self.search = ""
            self.current = self.root
            return []
        
        self.search += c
        if not self.current:
            return []
        
        if c not in self.current.children:
            self.current = None
            return []
        
        self.current = self.current.children[c]
        heap = []
        for child in self.current.children.values():
            if child.times:
                heapq.heappush(heap, (-child.times, child.sentence))
        
        res = []
        for _ in range(3):
            if not heap:
                break
            res.append(heapq.heappop(heap)[1])
        return res


-----
from typing import List
    # Your code here


************************************
Question ID: 643
def findMaxAverage(nums, k):
    n = len(nums)
    sum_ = sum(nums[:k])
    max_avg = sum_ / k
    for i in range(k, n):
        sum_ = sum_ - nums[i - k] + nums[i]
        max_avg = max(max_avg, sum_ / k)
    return max_avg

-----
def findMaxAverage(nums, k):
    # Your code here


************************************
Question ID: 644
def findMaxAverage(nums, k):
    total = sum(nums[:k])
    max_avg = total / k
    for i in range(k, len(nums)):
        total += nums[i] - nums[i - k]
        max_avg = max(max_avg, total / k)
    return max_avg

-----
def findMaxAverage(nums, k):
    # Your code here


************************************
Question ID: 645
def findErrorNums(nums):
    result = []
    for num in nums:
        index = abs(num) - 1
        if nums[index] > 0:
            nums[index] = -nums[index]
        else:
            result.append(index + 1)
    for i, num in enumerate(nums):
        if num > 0:
            result.append(i + 1)
            break
    return result

-----
def findErrorNums(nums):
    # Your code here


************************************
Question ID: 646
def findLongestChain(pairs):
    pairs.sort(key=lambda x: x[1])

    max_chain_length = 0
    last_right = float('-inf')
    for pair in pairs:
        if pair[0] > last_right:
            last_right = pair[1]
            max_chain_length += 1

    return max_chain_length


-----
def findLongestChain(pairs):
    # Your code here


************************************
Question ID: 647
def countSubstrings(s: str) -> int:
    n = len(s)
    count = 0
    for center in range(2 * n - 1):
        left = center // 2
        right = left + center % 2
        while left >= 0 and right < n and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
    return count

-----
def countSubstrings(s: str) -> int:
    # Your code here


************************************
Question ID: 648
def replaceWords(dict, sentence):
    roots = set(dict)
    words = sentence.split()
    result = []

    for word in words:
        prefix = ''
        for i in range(1, len(word) + 1):
            prefix = word[:i]
            if prefix in roots:
                break
        result.append(prefix)

    return ' '.join(result)

-----
def replaceWords(dict, sentence):
    # Your code here


************************************
Question ID: 649
from collections import deque

def predict_party_victory(senate: str) -> str:
    radiant = deque()
    dire = deque()
    n = len(senate)
    
    for i, s in enumerate(senate):
        if s == 'R':
            radiant.append(i)
        else:
            dire.append(i)

    while radiant and dire:
        r = radiant.popleft()
        d = dire.popleft()

        if r < d:
            radiant.append(r + n)
        else:
            dire.append(d + n)

    return "Dire" if not radiant else "Radiant"


-----
from collections import deque
    # Your code here


************************************
Question ID: 650
def min_steps(n):
    result = 0
    i = 2
    while i <= n:
        while n % i == 0:
            result += i
            n //= i
        i += 1
    return result

-----
def min_steps(n):
    # Your code here


************************************
Question ID: 651
def maxA(n: int) -> int:
    dp = [0] * (n + 1)
    for i in range(1, n + 1):
        dp[i] = i
        for j in range(1, i - 2):
            dp[i] = max(dp[i], dp[j] * (i - j - 1))
    return dp[n]

-----
def maxA(n: int) -> int:
    # Your code here


************************************
Question ID: 653
def findTarget(root, k):
    nodes = set()
    return findNode(root, k, nodes)

def findNode(root, k, nodes):
    if not root:
        return False
    if k - root.val in nodes:
        return True
    nodes.add(root.val)
    return findNode(root.left, k, nodes) or findNode(root.right, k, nodes)

-----
def findTarget(root, k):
    # Your code here


************************************
Question ID: 655
from collections import deque

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
        
def printTree(root):
    if not root:
        return [[]]

    # Calculate Depth
    depth = 0
    q = deque([root])
    while q:
        depth += 1
        for _ in range(len(q)):
            node = q.popleft()
            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)

    res = [["" for _ in range((1 << depth) - 1)] for _ in range(depth)]

    # Fill in matrix
    q.append(root)
    level = 0
    step = (1 << (depth - 1))
    while q:
        cur_pos = step - 1
        for _ in range(len(q)):
            node = q.popleft()
            res[level][cur_pos] = str(node.val)
            cur_pos += (step << 1)
            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)
        step >>= 1
        level += 1

    return res


-----
from collections import deque
    # Your code here


************************************
Question ID: 656
def cheapestJump(coins, maxJump):
    n = len(coins)
    dp = [float('inf')] * n
    parent = [-1] * n
    dp[0] = coins[0]
    for i in range(n):
        if coins[i] == -1:
            continue
        for j in range(1, maxJump + 1):
            if i + j >= n:
                break
            next = i + j
            cost = coins[next] + dp[i]
            if cost < dp[next]:
                dp[next] = cost
                parent[next] = i
    ans = []
    if dp[n - 1] == float('inf'):
        return ans
    cur = n - 1
    while cur != -1:
        ans.append(cur + 1)
        cur = parent[cur]
    ans.reverse()
    return ans

-----
def cheapestJump(coins, maxJump):
    # Your code here


************************************
Question ID: 657
def judgeCircle(moves: str) -> bool:
    x, y = 0, 0
    for move in moves:
        if move == 'U': y += 1
        elif move == 'D': y -= 1
        elif move == 'R': x += 1
        elif move == 'L': x -= 1
    return x == 0 and y == 0

-----
def judgeCircle(moves: str) -> bool:
    # Your code here


************************************
Question ID: 658
from typing import List

def findClosestElements(arr: List[int], k: int, x: int) -> List[int]:
    left = 0
    right = len(arr) - k

    while left < right:
        mid = left + (right - left) // 2
        if x - arr[mid] > arr[mid + k] - x:
            left = mid + 1
        else:
            right = mid

    return arr[left:left + k]

-----
from typing import List
    # Your code here


************************************
Question ID: 659
def can_split(nums):
    freq = [0] * 20001
    needed = [0] * 20001
    for n in nums:
        freq[n] += 1
    for n in nums:
        if not freq[n]: continue
        if not needed[n - 1]:
            if freq[n + 1] and freq[n + 2]:
                freq[n] -= 1; freq[n + 1] -= 1; freq[n + 2] -= 1;
                needed[n + 2] += 1
            else: return False
        else:
            freq[n] -= 1; needed[n - 1] -= 1;
            needed[n] += 1
    return True

-----
def can_split(nums):
    # Your code here


************************************
Question ID: 660
def newInteger(n):
    result = 0
    base = 1
    while n:
        result += n % 9 * base
        n //= 9
        base *= 10
    return result

-----
def newInteger(n):
    # Your code here


************************************
Question ID: 661
def imageSmoother(img):
    m, n = len(img), len(img[0])
    result = [[0] * n for _ in range(m)]

    for i in range(m):
        for j in range(n):
            count, total = 0, 0
            for x in range(i - 1, i + 2):
                for y in range(j - 1, j + 2):
                    if 0 <= x < m and 0 <= y < n:
                        total += img[x][y]
                        count += 1
            result[i][j] = total // count

    return result

-----
def imageSmoother(img):
    # Your code here


************************************
Question ID: 662
from collections import deque

def widthOfBinaryTree(root):
    if not root:
        return 0

    maxWidth = 0
    q = deque([(root, 1)])

    while q:
        levelSize = len(q)
        left, _ = q[0]
        right = left
        for _ in range(levelSize):
            node, pos = q.popleft()
            right = pos

            if node.left:
                q.append((node.left, 2 * pos))
            if node.right:
                q.append((node.right, 2 * pos + 1))
        
        maxWidth = max(maxWidth, right - left + 1)
    
    return maxWidth

-----
from collections import deque
    # Your code here


************************************
Question ID: 664
def strange_printer(s: str) -> int:
    n = len(s)
    if n == 0: return 0
    dp = [[0] * n for _ in range(n)]
    for i in range(n):
        dp[i][i] = 1
    for len in range(1, n):
        for i in range(n - len):
            j = i + len
            dp[i][j] = dp[i+1][j] + 1
            for k in range(i + 1, j + 1):
                if s[i] == s[k]:
                    dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k][j])
    return dp[0][n-1]

-----
def strange_printer(s: str) -> int:
    # Your code here


************************************
Question ID: 665
def checkPossibility(nums):
    cnt = 0
    for i in range(1, len(nums)):
        if nums[i] < nums[i - 1]:
            cnt += 1
            if i == 1 or nums[i] >= nums[i - 2]:
                nums[i-1] = nums[i]
            else:
                nums[i] = nums[i - 1]
            if cnt > 1:
                return False
    return True

-----
def checkPossibility(nums):
    # Your code here


************************************
Question ID: 666
def sumPaths(root, val):
    if not root: return 0
    val = val * 10 + root.val
    if not root.left and not root.right: return val
    return sumPaths(root.left, val) + sumPaths(root.right, val)

def pathSum(nums):
    root = TreeNode(nums[0] % 10)
    for num in nums:
        depth, pos, val = num // 100, num % 100 // 10, num % 10
        cur = root
        for d in reversed(range(depth - 1)):
            if (pos >> d) & 1:
                if not cur.right: cur.right = TreeNode(val)
                cur = cur.right
            else:
                if not cur.left: cur.left = TreeNode(val)
                cur = cur.left
    return sumPaths(root, 0)

-----
def sumPaths(root, val):
    # Your code here


************************************
Question ID: 667
def constructArray(n: int, k: int) -> List[int]:
    answer = [0] * n
    for i in range(n):
        if i % 2 == 0:
            answer[i] = i // 2 + 1
        else:
            answer[i] = n - (i - 1) // 2
            k -= 1
    if k > 0:
        for i in range(n - 2, -1, -1):
            if k > 0:
                answer[i] = answer[i + 1] - answer[i]
                k -= 1
    return answer

-----
def constructArray(n: int, k: int) -> List[int]:
    # Your code here


************************************
Question ID: 668
def findKthNumber(m, n, k):
    low, high = 1, m * n
    while low < high:
        mid = low + (high - low) // 2
        count = 0
        for i in range(1, m+1):
            count += min(mid // i, n)
        if count < k:
            low = mid + 1
        else:
            high = mid
    return low

-----
def findKthNumber(m, n, k):
    # Your code here


************************************
Question ID: 670
def maximumSwap(num):
    num_str = list(str(num))
    last = {int(v): i for i, v in enumerate(num_str)}

    for i, v in enumerate(num_str):
        for d in range(9, int(v), -1):
            if last.get(d, -1) > i:
                num_str[i], num_str[last[d]] = num_str[last[d]], num_str[i]
                return int("".join(num_str))

    return num

-----
def maximumSwap(num):
    # Your code here


************************************
Question ID: 672
def num_light_configuration(n, presses):
    dp = [[0] * (presses + 1) for _ in range(n+1)]
    dp[0][0] = 1

    for i in range(n + 1):
        for j in range(1, presses + 1):
            dp[i][j] = dp[i][j - 1] * (i + 1) + (dp[i - 1][j - 1] if i > 0 else 0)

    return dp[n][presses]

-----
def num_light_configuration(n, presses):
    # Your code here


************************************
Question ID: 673
def findNumberOfLIS(nums):
    n = len(nums)
    maxLength = ans = 0
    length = [1] * n
    count = [1] * n

    for i in range(n):
        for j in range(i):
            if nums[i] > nums[j]:
                if length[i] == length[j] + 1:
                    count[i] += count[j]
                elif length[i] < length[j] + 1:
                    length[i] = length[j] + 1
                    count[i] = count[j]
        if maxLength == length[i]:
            ans += count[i]
        elif maxLength < length[i]:
            maxLength = length[i]
            ans = count[i]

    return ans


-----
def findNumberOfLIS(nums):
    # Your code here


************************************
Question ID: 674
def findLengthOfLCIS(nums):
    if not nums:
        return 0
    result, current = 1, 1
    for i in range(1, len(nums)):
        current = current + 1 if nums[i] > nums[i - 1] else 1
        result = max(result, current)
    return result

-----
def findLengthOfLCIS(nums):
    # Your code here


************************************
Question ID: 675
from heapq import heappush, heappop
from collections import deque

def cutOffTree(forest: List[List[int]]) -> int:
    if not forest or not forest[0]: return 0
    m, n = len(forest), len(forest[0])
    trees = []
    
    for i in range(m):
        for j in range(n):
            if forest[i][j] > 1:
                heappush(trees, (forest[i][j], i, j))
    
    startX, startY = 0, 0
    totalSteps = 0
    while trees:
        tree, endX, endY = heappop(trees)
        steps = bfs(forest, startX, startY, endX, endY)
        if steps == -1:
            return -1
        totalSteps += steps
        startX, startY = endX, endY
    
    return totalSteps

def bfs(forest, startX, startY, endX, endY):
    if startX == endX and startY == endY:
        return 0
        
    m, n = len(forest), len(forest[0])
    visited = [[False] * n for _ in range(m)]
    q = deque([(startX, startY, 0)])
    visited[startX][startY] = True
    dirs = [-1, 0, 1, 0, -1]
    
    while q:
        x, y, steps = q.popleft()
        for k in range(4):
            newX, newY = x + dirs[k], y + dirs[k+1]
            if 0 <= newX < m and 0 <= newY < n and not visited[newX][newY] and forest[newX][newY] != 0:
                if newX == endX and newY == endY:
                    return steps + 1
                q.append((newX, newY, steps + 1))
                visited[newX][newY] = True
    
    return -1

-----
from heapq import heappush, heappop
    # Your code here


************************************
Question ID: 678
def checkValidString(s: str) -> bool:
    left_balance, right_balance = 0, 0

    for i in range(len(s)):
        left_balance += 1 if s[i] == '(' or s[i] == '*' else -1
        right_balance += 1 if s[len(s) - 1 - i] == ')' or s[len(s) - 1 - i] == '*' else -1

        if left_balance < 0 or right_balance < 0:
            return False

    return True


-----
def checkValidString(s: str) -> bool:
    # Your code here


************************************
Question ID: 679
from itertools import permutations

def helper(cards, target=24):
    if len(cards) == 1:
        return abs(cards[0] - target) < 1e-6

    for i in range(len(cards)):
        for j in range(i + 1, len(cards)):
            a, b = cards[i], cards[j]
            rest = [cards[k] for k in range(len(cards)) if k != i and k != j]
            for e in a + b, a - b, a * b, a / b:
                if helper(rest + [e]):
                    return True
    return False

def canGet24(cards):
    return helper(cards)


-----
from itertools import permutations
    # Your code here


************************************
Question ID: 680
def validPalindrome(s: str) -> bool:
    i, j = 0, len(s) - 1
    while i < j:
        if s[i] != s[j]:
            temp1, temp2 = i + 1, j
            while temp1 < temp2 and s[temp1] == s[temp2]:
                temp1 += 1
                temp2 -= 1
            if temp1 >= temp2:
                return True

            temp1, temp2 = i, j - 1
            while temp1 < temp2 and s[temp1] == s[temp2]:
                temp1 += 1
                temp2 -= 1
            if temp1 >= temp2:
                return True

            return False
        i += 1
        j -= 1
    return True

-----
def validPalindrome(s: str) -> bool:
    # Your code here


************************************
Question ID: 681
def nextClosestTime(time: str) -> str:
    digits = time[:2] + time[3:]
    next_time = time
    elapsed = float('inf')

    for a in digits:
        for b in digits:
            for c in digits:
                for d in digits:
                    candidate_time = f"{a}{b}:{c}{d}"
                    cand_elapsed = (int(candidate_time[:2]) * 60 + int(candidate_time[3:]) -
                                    int(time[:2]) * 60 - int(time[3:]) + 1440) % 1440
                    if 0 < cand_elapsed < elapsed:
                        elapsed = cand_elapsed
                        next_time = candidate_time

    return next_time

-----
def nextClosestTime(time: str) -> str:
    # Your code here


************************************
Question ID: 682
def calPoints(ops):
    record = []
    for op in ops:
        if op == '+':
            record.append(record[-1] + record[-2])
        elif op == 'D':
            record.append(record[-1] * 2)
        elif op == 'C':
            record.pop()
        else:
            record.append(int(op))
    return sum(record)


-----
def calPoints(ops):
    # Your code here


************************************
Question ID: 683
def kEmptySlots(bulbs, k):
    days = [0] * len(bulbs)
    for i, bulb in enumerate(bulbs):
        days[bulb - 1] = i

    ans = float('inf')
    left = 0
    right = k + 1
    while right < len(days):
        i = left + 1
        for i in range(left + 1, right):
            if days[i] < days[left] or days[i] < days[right]:
                left = i
                break
        else:
            ans = min(ans, max(days[left], days[right]))
            left += 1
            right += 1

    return -1 if ans == float('inf') else ans + 1


-----
def kEmptySlots(bulbs, k):
    # Your code here


************************************
Question ID: 684
from typing import List

def findRedundantConnection(edges: List[List[int]]) -> List[int]:
    def find(parent, x):
        if parent[x] != x:
            parent[x] = find(parent, parent[x])
        return parent[x]

    parent = list(range(len(edges) + 1))
    for edge in edges:
        root1 = find(parent, edge[0])
        root2 = find(parent, edge[1])
        if root1 == root2:
            return edge
        parent[root1] = root2
    return []


-----
from typing import List
    # Your code here


************************************
Question ID: 685
def findRedundantDirectedConnection(edges):
    parent = [0] * (len(edges) + 1)
    candidateA = candidateB = None

    for u, v in edges:
        if parent[v] > 0:
            candidateA = [parent[v], v]
            candidateB = [u, v]
        else:
            parent[v] = u

    for i in range(1, len(edges) + 1):
        cycle = i
        steps = len(edges)
        while parent[cycle] != 0 and steps > 0:
            cycle = parent[cycle]
            steps -= 1
        if steps == 0:
            if not candidateA:
                return [parent[i], i]
            else:
                return candidateA

    return candidateB


-----
def findRedundantDirectedConnection(edges):
    # Your code here


************************************
Question ID: 686
def min_repeats_to_substring(a: str, b: str) -> int:
    times = (len(b) + len(a) - 1) // len(a)

    for i in range(2):
        repeated_a = a * (times + i)
        if b in repeated_a:
            return times + i

    return -1

-----
def min_repeats_to_substring(a: str, b: str) -> int:
    # Your code here


************************************
Question ID: 687
def longestUnivaluePath(root):
    def findUnivaluePath(node):
        if not node:
            return 0
        left = findUnivaluePath(node.left)
        right = findUnivaluePath(node.right)
        left = left + 1 if node.left and node.left.val == node.val else 0
        right = right + 1 if node.right and node.right.val == node.val else 0
        maxLen[0] = max(maxLen[0], left + right)
        return max(left, right)

    maxLen = [0]
    findUnivaluePath(root)
    return maxLen[0]


-----
def longestUnivaluePath(root):
    # Your code here


************************************
Question ID: 688
def knightProbability(self, n: int, k: int, row: int, column: int) -> float:
    memo = [[[-1.0 for _ in range(k + 1)] for _ in range(n)] for _ in range(n)]
    return self.helper(n, k, row, column, memo)

def helper(self, n, k, row, column, memo):
    if row < 0 or row >= n or column < 0 or column >= n:
        return 0.0
    if k == 0:
        return 1.0
    if memo[row][column][k] >= 0:
        return memo[row][column][k]

    result = 0.0
    moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]
    for move in moves:
        result += self.helper(n, k - 1, row + move[0], column + move[1], memo) / 8

    memo[row][column][k] = result
    return result

-----
def knightProbability(self, n: int, k: int, row: int, column: int) -> float:
    # Your code here


************************************
Question ID: 689
def max_sum_of_three_subarrays(nums, k):
    n = len(nums)
    sums = [0] * (n - k + 1)
    left, right = [0] * n, [0] * n

    acc_sum = 0
    for i in range(n):
        acc_sum += nums[i]
        if i >= k:
            acc_sum -= nums[i - k]
        if i >= k - 1:
            sums[i - k + 1] = acc_sum

    left[0] = 0
    right[n - k] = n - k
    for i in range(1, n - k + 1):
        left[i] = i if sums[i] > sums[left[i - 1]] else left[i - 1]

    for i in range(n - k - 1, -1, -1):
        right[i] = i if sums[i] >= sums[right[i + 1]] else right[i + 1]

    max_sum, ans = 0, [0] * 3
    for i in range(k, n - 2 * k + 1):
        left_idx, right_idx = left[i - k], right[i + k]
        total_sum = sums[left_idx] + sums[i] + sums[right_idx]
        if total_sum > max_sum:
            max_sum = total_sum
            ans = [left_idx, i, right_idx]

    return ans

-----
def max_sum_of_three_subarrays(nums, k):
    # Your code here


************************************
Question ID: 691
from collections import Counter
from functools import lru_cache

def minStickers(stickers, target):
    target_count = Counter(target)
    memo = {}
    
    for s in stickers:
        sticker_count = Counter(s)
        state = ''.join(sticker_count & target_count)
        memo[state] = 1
    
    @lru_cache(None)
    def dp(state):
        counts = Counter(state)
        ans = float('inf')
        for key, value in memo.items():
            if any(counts[ch] < key.count(ch) for ch in state): continue
            ans = min(ans, dp(state.translate(str.maketrans('', '', key))) + value)
        return -1 if ans == float('inf') else ans
    
    return dp(target)

-----
from collections import Counter
    # Your code here


************************************
Question ID: 692
import heapq
from collections import Counter

def k_frequent_words(words, k):
    word_count = Counter(words)
    heap = [(-count, word) for word, count in word_count.items()]
    heapq.heapify(heap)

    result = []
    for _ in range(k):
        result.append(heapq.heappop(heap)[1])

    return result

-----
import heapq
    # Your code here


************************************
Question ID: 693
def has_alternating_bits(n):
    prev_bit = n % 2
    n //= 2
    while n > 0:
        curr_bit = n % 2
        if curr_bit == prev_bit:
            return False
        prev_bit = curr_bit
        n //= 2
    return True


-----
def has_alternating_bits(n):
    # Your code here


************************************
Question ID: 694
def numDistinctIslands(grid):
    unique_islands = set()
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                island_shape = []
                dfs(grid, i, j, i, j, island_shape)
                island_shape.sort()
                unique_islands.add(tuple(island_shape))
    return len(unique_islands)

def dfs(grid, i, j, i0, j0, shape):
    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1:
        grid[i][j] = 2
        shape.append((i - i0, j - j0))
        dfs(grid, i - 1, j, i0, j0, shape)
        dfs(grid, i + 1, j, i0, j0, shape)
        dfs(grid, i, j - 1, i0, j0, shape)
        dfs(grid, i, j + 1, i0, j0, shape)

-----
def numDistinctIslands(grid):
    # Your code here


************************************
Question ID: 695
def maxAreaOfIsland(grid):
    def dfs(i, j):
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:
            return 0
        grid[i][j] = 0
        return 1 + dfs(i-1, j) + dfs(i+1, j) + dfs(i, j-1) + dfs(i, j+1)

    max_area = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j]:
                max_area = max(max_area, dfs(i, j))
    return max_area

-----
def maxAreaOfIsland(grid):
    # Your code here


************************************
Question ID: 696
def count_binary_substrings(s: str) -> int:
    prev, curr, result = 0, 1, 0
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            curr += 1
        else:
            result += min(prev, curr)
            prev, curr = curr, 1
    return result + min(prev, curr)

-----
def count_binary_substrings(s: str) -> int:
    # Your code here


************************************
Question ID: 697
def findShortestSubArray(nums):
    freq_map, start_map = {}, {}
    max_freq, min_length = 0, len(nums)

    for i, num in enumerate(nums):
        if num not in start_map:
            start_map[num] = i
        freq_map[num] = freq_map.get(num, 0) + 1

        freq = freq_map[num]
        if freq > max_freq:
            max_freq = freq
            min_length = i - start_map[num] + 1
        elif freq == max_freq:
            min_length = min(min_length, i - start_map[num] + 1)

    return min_length

-----
def findShortestSubArray(nums):
    # Your code here


************************************
Question ID: 698
def canPartitionKSubsets(nums, k):
    total_sum = sum(nums)
    if total_sum % k != 0:
        return False
    target = total_sum // k
    visited = [False] * len(nums)
    return dfs(nums, visited, 0, target, 0, k)

def dfs(nums, visited, start, target, curr_sum, k):
    if k == 1:
        return True
    if curr_sum == target:
        return dfs(nums, visited, 0, target, 0, k - 1)
    for i in range(start, len(nums)):
        if not visited[i] and curr_sum + nums[i] <= target:
            visited[i] = True
            if dfs(nums, visited, i + 1, target, curr_sum + nums[i], k):
                return True
            visited[i] = False
    return False

-----
def canPartitionKSubsets(nums, k):
    # Your code here


************************************
Question ID: 699
def fallingSquares(positions):
    ans = []
    intervals = []

    for p in positions:
        L, size = p
        R = L + size
        h = size
        for h2, R2 in intervals:
            if R2 > L and R > R2:
                h = max(h, size + h2)

        maxHeight = max((h2 for h2, R2 in intervals), default=0)
        ans.append(max(maxHeight, h))
        intervals.append((h, R))

    return ans

-----
def fallingSquares(positions):
    # Your code here


************************************
Question ID: 702
def search(reader, target):
    left, right = 0, 1
    while reader.get(right) < target:
        left = right
        right <<= 1

    while left <= right:
        mid = left + ((right - left) >> 1)
        val = reader.get(mid)
        if val == target:
            return mid
        if val > target:
            right = mid - 1
        else:
            left = mid + 1
    return -1

-----
def search(reader, target):
    # Your code here


************************************
Question ID: 703
import heapq

class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.min_heap = nums
        heapq.heapify(self.min_heap)
        
        while len(self.min_heap) > k:
            heapq.heappop(self.min_heap)

    def add(self, val: int) -> int:
        if len(self.min_heap) < self.k:
            heapq.heappush(self.min_heap, val)
        elif val > self.min_heap[0]:
            heapq.heappushpop(self.min_heap, val)
        return self.min_heap[0]

-----
import heapq
    # Your code here


************************************
Question ID: 704
def search(nums: List[int], target: int) -> int:
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1


-----
def search(nums: List[int], target: int) -> int:
    # Your code here


************************************
Question ID: 709
def toLowerCase(s: str) -> str:
    return s.lower()

-----
def toLowerCase(s: str) -> str:
    # Your code here


************************************
Question ID: 710
import random

class Solution:
    def __init__(self, n: int, blacklist: List[int]):
        blacklist.sort()
        self.mapping = dict()
        idx = 0
        for black in blacklist:
            while idx < black:
                self.mapping[idx] = n - 1
                idx += 1
                n -= 1
            idx += 1
            n -= 1
        self.last = n

    def pick(self) -> int:
        num = random.randrange(self.last)
        return self.mapping.get(num, num)

-----
import random
    # Your code here


************************************
Question ID: 712
def minimumDeleteSum(s1: str, s2: str) -> int:
    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]
    for i in range(1, len(s1) + 1):
        dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])
    for j in range(1, len(s2) + 1):
        dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])
    for i in range(1, len(s1) + 1):
        for j in range(1, len(s2) + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = min(dp[i - 1][j] + ord(s1[i - 1]), dp[i][j - 1] + ord(s2[j - 1]))
    return dp[len(s1)][len(s2)]

-----
def minimumDeleteSum(s1: str, s2: str) -> int:
    # Your code here


************************************
Question ID: 713
def numSubarrayProductLessThanK(nums, k):
    if k <= 1:
        return 0
    prod = 1
    count = 0
    left = 0
    for right in range(len(nums)):
        prod *= nums[right]
        while prod >= k:
            prod /= nums[left]
            left += 1
        count += right - left + 1
    return count

-----
def numSubarrayProductLessThanK(nums, k):
    # Your code here


************************************
Question ID: 714
def maxProfit(prices, fee):
    cash, hold = 0, -prices[0]
    for price in prices:
        temp = cash
        cash = max(cash, hold + price - fee)
        hold = max(hold, temp - price)
    return cash

-----
def maxProfit(prices, fee):
    # Your code here


************************************
Question ID: 716
from sortedcontainers import SortedList

class MaxStack:
    def __init__(self):
        self.mainStack = []
        self.maxSet = SortedList()

    def push(self, x: int) -> None:
        self.mainStack.append(x)
        self.maxSet.add(x)

    def pop(self) -> int:
        top = self.mainStack.pop()
        self.maxSet.remove(top)
        return top

    def top(self) -> int:
        return self.mainStack[-1]

    def peekMax(self) -> int:
        return self.maxSet[-1]

    def popMax(self) -> int:
        max_val = self.maxSet.pop()
        tempStack = []
        while self.mainStack[-1] != max_val:
            tempStack.append(self.mainStack.pop())
        self.mainStack.pop()
        while tempStack:
            self.mainStack.append(tempStack.pop())
        return max_val

-----
from sortedcontainers import SortedList
    # Your code here


************************************
Question ID: 717
def is_one_bit_character(bits):
    i = 0
    while i < len(bits) - 1:
        i += bits[i] + 1
    return i == len(bits) - 1

-----
def is_one_bit_character(bits):
    # Your code here


************************************
Question ID: 718
def findLength(nums1, nums2):
    m, n = len(nums1), len(nums2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    maxLength = 0

    for i in range(m - 1, -1, -1):
        for j in range(n - 1, -1, -1):
            if nums1[i] == nums2[j]:
                dp[i][j] = dp[i + 1][j + 1] + 1
                maxLength = max(maxLength, dp[i][j])

    return maxLength

-----
def findLength(nums1, nums2):
    # Your code here


************************************
Question ID: 719
def smallestDistancePair(nums, k):
    nums.sort()
    low, high = 0, nums[-1] - nums[0]
    
    while low < high:
        mid = (low + high) // 2
        count, left = 0, 0

        for right in range(len(nums)):
            while nums[right] - nums[left] > mid:
                left += 1
            count += (right - left)

        if count < k:
            low = mid + 1
        else:
            high = mid
    
    return low


-----
def smallestDistancePair(nums, k):
    # Your code here


************************************
Question ID: 720
def longest_word(words):
    built_words = set()
    result = ''

    for word in sorted(words):
        if len(word) == 1 or word[:-1] in built_words:
            if len(word) > len(result):
                result = word
            built_words.add(word)

    return result


-----
def longest_word(words):
    # Your code here


************************************
Question ID: 721
from collections import defaultdict

def accountsMerge(accounts):
    def dfs(id, visited, merged_emails):
        if id in visited:
            return
        visited.add(id)
        for email in accounts[id][1:]:
            merged_emails.add(email)
            dfs(email_to_id[email], visited, merged_emails)

    email_to_id = {}
    for i, account in enumerate(accounts):
        for email in account[1:]:
            email_to_id[email] = i

    result = []
    visited = set()
    for i, account in enumerate(accounts):
        if i not in visited:
            merged_emails = set()
            dfs(i, visited, merged_emails)
            result.append([account[0]] + sorted(merged_emails))
    return result


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 722
def removeComments(self, source: List[str]) -> List[str]:
    result = []
    buffer = []
    in_block_comment = False

    for line in source:
        i = 0
        while i < len(line):
            if in_block_comment:
                if i < len(line) - 1 and line[i] == '*' and line[i + 1] == '/':
                    in_block_comment = False
                    i += 1
            else:
                if i < len(line) - 1 and line[i] == '/' and line[i + 1] == '*':
                    in_block_comment = True
                    i += 1
                elif i < len(line) - 1 and line[i] == '/' and line[i + 1] == '/':
                    break
                else:
                    buffer.append(line[i])
            i += 1

        if not in_block_comment and buffer:
            result.append(''.join(buffer))
            buffer.clear()

    return result


-----
def removeComments(self, source: List[str]) -> List[str]:
    # Your code here


************************************
Question ID: 723
def candyCrush(board):
    rows = len(board)
    cols = len(board[0])
    toDo = False
    
    for r in range(rows):
        for c in range(cols - 2):
            val = abs(board[r][c])
            if val and val == abs(board[r][c + 1]) and val == abs(board[r][c + 2]):
                board[r][c] = board[r][c + 1] = board[r][c + 2] = -val
                toDo = True
                
    for r in range(rows - 2):
        for c in range(cols):
            val = abs(board[r][c])
            if val and val == abs(board[r + 1][c]) and val == abs(board[r + 2][c]):
                board[r][c] = board[r + 1][c] = board[r + 2][c] = -val
                toDo = True
                
    for c in range(cols):
        wr = rows - 1
        for r in range(rows - 1, -1, -1):
            if board[r][c] > 0:
                board[wr][c] = board[r][c]
                wr -= 1
                
        for r in range(wr, -1, -1):
            board[r][c] = 0
                
    return candyCrush(board) if toDo else board

-----
def candyCrush(board):
    # Your code here


************************************
Question ID: 724
def pivotIndex(nums):
    total_sum = sum(nums)
    left_sum = 0
    for i, num in enumerate(nums):
        if left_sum == total_sum - left_sum - num:
            return i
        left_sum += num
    return -1


-----
def pivotIndex(nums):
    # Your code here


************************************
Question ID: 726
from collections import Counter

def parse(formula, i):
    counts = Counter()
    while i[0] < len(formula):
        if formula[i[0]] == '(':
            i[0] += 1
            temp = parse(formula, i)
            count = 0
            while i[0] < len(formula) and formula[i[0]].isdigit():
                count = count * 10 + int(formula[i[0]])
                i[0] += 1
            if count == 0: count = 1
            for name, c in temp.items():
                counts[name] += c * count
        elif formula[i[0]] == ')':
            i[0] += 1
            return counts
        else:
            name = formula[i[0]]
            i[0] += 1
            while i[0] < len(formula) and formula[i[0]].islower():
                name += formula[i[0]]
                i[0] += 1
            count = 0
            while i[0] < len(formula) and formula[i[0]].isdigit():
                count = count * 10 + int(formula[i[0]])
                i[0] += 1
            if count == 0: count = 1
            counts[name] += count
    return counts

def countOfAtoms(formula):
    i = [0]
    counts = parse(formula, i)
    ans = []
    for name, count in counts.items():
        ans.append(name)
        if count > 1: ans.append(str(count))
    return ''.join(ans)


-----
from collections import Counter
    # Your code here


************************************
Question ID: 727
def min_window_sub_sequence(s1: str, s2: str) -> str:
    m, n = len(s1), len(s2)
    dp = [[0] * (m + 1) for _ in range(n + 1)]

    for j in range(0, m + 1):
        dp[0][j] = j

    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if s1[j - 1] == s2[i - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = dp[i][j - 1]

    start, length = 0, m + 1
    for j in range(1, m + 1):
        if dp[n][j] != 0 and j - dp[n][j] < length:
            start = dp[n][j]
            length = j - start

    return "" if length == m + 1 else s1[start:start + length]

-----
def min_window_sub_sequence(s1: str, s2: str) -> str:
    # Your code here


************************************
Question ID: 728
def is_self_dividing(num):
    n = num
    while n:
        digit = n % 10
        if digit == 0 or num % digit != 0:
            return False
        n //= 10
    return True

def self_dividing_numbers(left, right):
    return [i for i in range(left, right+1) if is_self_dividing(i)]

-----
def is_self_dividing(num):
    # Your code here


************************************
Question ID: 729
from bisect import bisect_left, insort

class MyCalendar:

    def __init__(self):
        self.calendar = []

    def book(self, start, end):
        i = bisect_left(self.calendar, [start, end])
        if i % 2 == 1:
            return False
        if i > 0 and self.calendar[i-1] > start:
            return False
        if i < len(self.calendar) and end > self.calendar[i]:
            return False
        insort(self.calendar, start)
        insort(self.calendar, end)
        return True

-----
from bisect import bisect_left, insort
    # Your code here


************************************
Question ID: 730
def countPalindromicSubsequences(s: str) -> int:
    n = len(s)
    MOD = 1000000007
    dp = [[0] * (n + 1) for _ in range(4)]

    for i in range(n - 1, -1, -1):
        for j in range(i + 1, n + 1):
            c = ord(s[i]) - ord('a')
            dp[c][j] = sum(dp[k][j - 1] for k in range(4)) - dp[c][i] + 2
            dp[c][j] = (dp[c][j] + MOD) % MOD

    return sum(dp[c][n] for c in range(4)) % MOD


-----
def countPalindromicSubsequences(s: str) -> int:
    # Your code here


************************************
Question ID: 732
from collections import defaultdict
import heapq

class MyCalendarThree:

    def __init__(self):
        self.timeline = defaultdict(int)

    def book(self, start: int, end: int) -> int:
        self.timeline[start] += 1
        self.timeline[end] -= 1
        ongoing, k = 0, 0
        for value in self.timeline.values():
            k = max(k, ongoing + value)
            ongoing += value
        return k


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 733
def floodFill(image, sr, sc, newColor):
    startColor = image[sr][sc]
    def fill(sr, sc):
        if not (0 <= sr < len(image)) or not (0 <= sc < len(image[0])) or image[sr][sc] != startColor or image[sr][sc] == newColor: 
            return
        image[sr][sc] = newColor
        fill(sr - 1, sc)
        fill(sr + 1, sc)
        fill(sr, sc - 1)
        fill(sr, sc + 1)
    
    fill(sr, sc)
    return image


-----
def floodFill(image, sr, sc, newColor):
    # Your code here


************************************
Question ID: 734
from collections import defaultdict

def areSentencesSimilar(sentence1, sentence2, similarPairs):
    if len(sentence1) != len(sentence2): return False
    similarityMap = defaultdict(set)
    for pair in similarPairs:
        similarityMap[pair[0]].add(pair[1])
        similarityMap[pair[1]].add(pair[0])
    for i in range(len(sentence1)):
        if sentence1[i] != sentence2[i] and sentence2[i] not in similarityMap[sentence1[i]]:
            return False
    return True


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 735
def asteroidCollision(asteroids):
    s = []
    for num in asteroids:
        if num > 0 or not s or s[-1] < 0:
            s.append(num)
        elif s[-1] <= -num:
            if s[-1] < -num:
                s.pop()
                s.append(num)
            else:
                s.pop()
    return s


-----
def asteroidCollision(asteroids):
    # Your code here


************************************
Question ID: 736
def evaluate(expression: str) -> int:
    def calculate(s, start, end, variables):
        if s[start] == '(':
            if s[start + 1:start + 4] == "add":
                first = start + 5
                second = first
                value1 = calculate(s, first, end, variables)
                second = s.index(' ', second) + 1
                value2 = calculate(s, second, end, variables)
                return value1 + value2
            elif s[start + 1:start + 5] == "mult":
                first = start + 6
                second = first
                value1 = calculate(s, first, end, variables)
                second = s.index(' ', second) + 1
                value2 = calculate(s, second, end, variables)
                return value1 * value2
            else:
                inner = variables.copy()
                idx = start + 5
                while idx < end - 1 and s[idx] != '(':
                    temp = idx
                    idx = s.index(' ', idx + 1)
                    var = s[temp:idx]
                    temp = idx + 1
                    if s[temp] == '(':
                        idx += 1
                    else:
                        idx = s.index(' ', idx + 1)
                    result = calculate(s, temp, idx, variables)
                    inner[var] = result
                    variables = inner
                return calculate(s, end - 1, end, variables)
        else:
            if s[start].isdigit() or s[start] == '-':
                end = s.find(' ', start) if ' ' in s[start:end] else end
                return int(s[start:end])
            else:
                end = s.find(' ', start) if ' ' in s[start:end] else end
                return variables[s[start:end]]

    return calculate(expression, 0, len(expression), {})

-----
def evaluate(expression: str) -> int:
    # Your code here


************************************
Question ID: 737
from collections import defaultdict

def areSentencesSimilar(sentence1, sentence2, pairs):
    if len(sentence1) != len(sentence2):
        return False
    
    graph = defaultdict(set)
    for a, b in pairs:
        graph[a].add(b)
        graph[b].add(a)

    for a, b in zip(sentence1, sentence2):
        if a == b:
            continue
        if b not in graph[a]:
            return False

    return True

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 738
def monotoneIncreasingDigits(n: int) -> int:
    n_str = [c for c in str(n)]

    i = len(n_str) - 1
    while i > 0:
        if n_str[i] < n_str[i - 1]:
            n_str[i - 1] = chr(ord(n_str[i - 1]) - 1)
            for j in range(i, len(n_str)):
                n_str[j] = '9'
        i -= 1

    return int(''.join(n_str))

-----
def monotoneIncreasingDigits(n: int) -> int:
    # Your code here


************************************
Question ID: 739
def daily_temperatures(temperatures):
    result = [0] * len(temperatures)
    stack = []

    for i, temp in enumerate(temperatures):
        while stack and temp > temperatures[stack[-1]]:
            idx = stack.pop()
            result[idx] = i - idx
        stack.append(i)

    return result

-----
def daily_temperatures(temperatures):
    # Your code here


************************************
Question ID: 740
def max_points(nums):
    dp = [0] * 100001
    max_points = 0
    for num in nums:
        dp[num] += 1
    for i in range(2, len(dp)):
        dp[i] = max(dp[i - 1], dp[i - 2] + i * dp[i])
        max_points = max(max_points, dp[i])
    return max_points

-----
def max_points(nums):
    # Your code here


************************************
Question ID: 741
def cherryPickup(self, grid: List[List[int]]) -> int:
    def dp(r1, c1, c2):
        r2 = r1 + c1 - c2
        if (r1 == len(grid) or r2 == len(grid) or c1 == len(grid) or c2 == len(grid) or
            grid[r1][c1] == -1 or grid[r2][c2] == -1):
            return float('-inf')
        elif r1 == len(grid) - 1 and c1 == len(grid) - 1:
            return grid[r1][c1]
        elif memo[r1][c1][c2] != float('-inf'):
            return memo[r1][c1][c2]
        else:
            memo[r1][c1][c2] = grid[r1][c1] + (r1 != r2) * grid[r2][c2]
            max_cherries = max(dp(r1 + 1, c1, c2 + 1), dp(r1, c1 + 1, c2 + 1),
                               dp(r1 + 1, c1, c2), dp(r1, c1 + 1, c2))
            memo[r1][c1][c2] += max_cherries
        
        return memo[r1][c1][c2]
    
    N = len(grid)
    memo = [[[float('-inf')] * N for _1 in range(N)] for _2 in range(N)]
    return max(0, dp(0, 0, 0))


-----
def cherryPickup(self, grid: List[List[int]]) -> int:
    # Your code here


************************************
Question ID: 742
def to_lower_case(s: str) -> str:
    return s.lower()

-----
def to_lower_case(s: str) -> str:
    # Your code here


************************************
Question ID: 743
import heapq

def networkDelayTime(times, n, k):
    graph = {i: [] for i in range(1, n+1)}
    for u, v, w in times:
        graph[u].append((v, w))

    dist = {u: float('inf') for u in range(1, n+1)}
    dist[k] = 0

    pq = [(0, k)]

    while pq:
        curr_dist, u = heapq.heappop(pq)

        for v, weight in graph[u]:
            new_dist = curr_dist + weight
            if new_dist < dist[v]:
                dist[v] = new_dist
                heapq.heappush(pq, (new_dist, v))

    max_time = max(dist.values())
    return max_time if max_time < float('inf') else -1


-----
import heapq
    # Your code here


************************************
Question ID: 744
import heapq
from collections import defaultdict

def networkDelayTime(times, n, k):
    graph = defaultdict(list)
    for u, v, w in times:
        graph[u].append((v, w))

    dist = {i: float('inf') for i in range(1, n + 1)}
    dist[k] = 0

    pq = [(0, k)]

    while pq:
        time, node = heapq.heappop(pq)

        if time > dist[node]:
            continue

        for neighbour, neighbourTime in graph[node]:
            candidate_dist = time + neighbourTime
            if candidate_dist < dist[neighbour]:
                dist[neighbour] = candidate_dist
                heapq.heappush(pq, (candidate_dist, neighbour))

    maxTime = max(dist.values())
    return maxTime if maxTime < float('inf') else -1

-----
import heapq
    # Your code here


************************************
Question ID: 745
def next_greatest_letter(letters, target):
    for letter in letters:
        if letter > target:
            return letter
    return letters[0]

-----
def next_greatest_letter(letters, target):
    # Your code here


************************************
Question ID: 747
def minCostClimbingStairs(cost):
    for i in range(2, len(cost)):
        cost[i] += min(cost[i-1], cost[i-2])
    return min(cost[-1], cost[-2])

-----
def minCostClimbingStairs(cost):
    # Your code here


************************************
Question ID: 748
def shortestCompletingWord(licensePlate: str, words: list[str]) -> str:
    from collections import Counter

    lp_count = Counter(c.lower() for c in licensePlate if c.isalpha())

    result = ""
    for word in words:
        word_count = Counter(word)

        valid = all(word_count[ch] >= count for ch, count in lp_count.items())

        if valid and (not result or len(word) < len(result)):
            result = word

    return result


-----
def shortestCompletingWord(licensePlate: str, words: list[str]) -> str:
    # Your code here


************************************
Question ID: 749
def shortest_completing_word(license_plate, words):
    target = [0] * 26
    for c in license_plate:
        if c.isalpha():
            target[ord(c.lower()) - ord('a')] += 1

    result = ""
    for word in words:
        current = [0] * 26
        for c in word:
            if c.isalpha():
                current[ord(c.lower()) - ord('a')] += 1

        if all(a <= b for a, b in zip(target, current)) and (not result or len(word) < len(result)):
            result = word

    return result

-----
def shortest_completing_word(license_plate, words):
    # Your code here


************************************
Question ID: 750
def countCornerRectangles(grid):
    count = 0
    m = len(grid)
    n = len(grid[0])
    
    for i in range(m - 1):
        for j in range(n - 1):
            if grid[i][j] == 1:
                for k in range(i + 1, m):
                    for l in range(j + 1, n):
                        if grid[k][l] == 1 and grid[i][l] == 1 and grid[k][j] == 1:
                            count += 1
    return count

-----
def countCornerRectangles(grid):
    # Your code here


************************************
Question ID: 751
def ipToCIDR(ip: str, n: int) -> List[str]:
    a, b, c, d = map(int, ip.split('.'))
    start = (a << 24) + (b << 16) + (c << 8) + d
    end = start + n - 1
    
    ans = []
    while start <= end:
        samePrefixBits = (~start & start).bit_length() - 1
        while ((end - start) >> samePrefixBits) < 1:
            samePrefixBits -= 1
        range = 1 << samePrefixBits
        ans.append(f"{start >> 24}.{(start >> 16) & 255}.{(start >> 8) & 255}.{start & 255}/{32 - samePrefixBits}")
        start += range
    
    return ans


-----
def ipToCIDR(ip: str, n: int) -> List[str]:
    # Your code here


************************************
Question ID: 752
from collections import deque

def openLock(deadends, target):
    dead = set(deadends)
    visited = set()
    q = deque(["0000"])

    if "0000" in dead:
        return -1

    visited.add("0000")
    moves = 0

    while q:
        level_size = len(q)
        for i in range(level_size):
            cur = q.popleft()

            if cur == target:
                return moves

            for j in range(4):
                for k in [-1, 1]:
                    next_val = cur[:j] + str((int(cur[j]) + k + 10) % 10) + cur[j + 1:]

                    if next_val not in visited and next_val not in dead:
                        visited.add(next_val)
                        q.append(next_val)

        moves += 1

    return -1


-----
from collections import deque
    # Your code here


************************************
Question ID: 753
from collections import deque

def openLock(deadends, target):
    dead = set(deadends)
    visited = set()
    wheel_states = deque([("0000", 0)])

    if "0000" in dead:
        return -1

    while wheel_states:
        current_state, turns = wheel_states.popleft()

        if current_state == target:
            return turns

        for i in range(4):
            up_state = current_state[:i] + str((int(current_state[i]) + 1) % 10) + current_state[i + 1:]
            down_state = current_state[:i] + str((int(current_state[i]) - 1) % 10) + current_state[i + 1:]

            if up_state not in visited and up_state not in dead:
                wheel_states.append((up_state, turns + 1))
                visited.add(up_state)

            if down_state not in visited and down_state not in dead:
                wheel_states.append((down_state, turns + 1))
                visited.add(down_state)

    return -1

-----
from collections import deque
    # Your code here


************************************
Question ID: 754
def reachNumber(target: int) -> int:
    target = abs(target)
    step = 0
    sum = 0
    while sum < target:
        step += 1
        sum += step
    while (sum - target) % 2 != 0:
        step += 1
        sum += step
    return step


-----
def reachNumber(target: int) -> int:
    # Your code here


************************************
Question ID: 755
def min_moves(target: int) -> int:
    target = abs(target)
    step = 0
    total = 0
    while total < target or (total - target) % 2 != 0:
        step += 1
        total += step
    return step


-----
def min_moves(target: int) -> int:
    # Your code here


************************************
Question ID: 756
def pyramid_transition(bottom, allowed):
    mapping = {}
    for s in allowed:
        key = s[:2]
        if key not in mapping:
            mapping[key] = []
        mapping[key].append(s[2])
    return pyramid_transition_helper(bottom, "", 0, mapping)

def pyramid_transition_helper(bottom, top, idx, mapping):
    if len(bottom) == 1:
        return True
    if idx == len(bottom) - 1:
        return pyramid_transition_helper(top, "", 0, mapping)
    key = bottom[idx:idx + 2]
    if key not in mapping:
        return False
    for c in mapping[key]:
        if pyramid_transition_helper(bottom, top + c, idx + 1, mapping):
            return True
    return False


-----
def pyramid_transition(bottom, allowed):
    # Your code here


************************************
Question ID: 757
from collections import defaultdict

def pyramidTransition(bottom, allowed):
    mapping = defaultdict(list)
    for s in allowed:
        mapping[s[:2]].append(s[2])
    return dfs("", bottom, mapping)

def dfs(curr, bottom, mapping):
    if len(bottom) == 1:
        return True
    for i in range(len(bottom) - 1):
        if bottom[i:i+2] not in mapping:
            return False
    curr = "".join(mapping[bottom[i:i + 2]][0] for i in range(len(bottom) - 1))
    return dfs(curr, curr, mapping)


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 758
def addBoldTag(words, s):
    bold = [False] * len(s)
    for word in words:
        pos = s.find(word)
        while pos != -1:
            for i in range(pos, pos + len(word)):
                bold[i] = True
            pos = s.find(word, pos + 1)

    result = []
    for i in range(len(s)):
        if bold[i] and (i == 0 or not bold[i - 1]):
            result.append("<b>")
        result.append(s[i])
        if bold[i] and (i == len(s) - 1 or not bold[i + 1]):
            result.append("</b>")

    return "".join(result)

-----
def addBoldTag(words, s):
    # Your code here


************************************
Question ID: 759
def min_set_size(intervals):
    intervals.sort()
    n = len(intervals)
    end = intervals[0][1]
    count = 1

    for i in range(1, n):
        if end < intervals[i][0]:
            end = intervals[i][1]
            count += 1
        else:
            end = min(end, intervals[i][1])
    return count * 2

-----
def min_set_size(intervals):
    # Your code here


************************************
Question ID: 760
def anagramMappings(nums1, nums2):
    num_map = {num: i for i, num in enumerate(nums2)}
    mapping = [num_map[num] for num in nums1]
    return mapping


-----
def anagramMappings(nums1, nums2):
    # Your code here


************************************
Question ID: 761
def makeLargestSpecial(s: str) -> str:
    count, i = 0, 0
    subs = []

    for j in range(len(s)):
        if s[j] == '1':
            count += 1
        else:
            count -= 1

        if count == 0:
            subs.append("1" + makeLargestSpecial(s[i+1:j]) + "0")
            i = j + 1

    subs.sort(reverse=True)
    return "".join(subs)


-----
def makeLargestSpecial(s: str) -> str:
    # Your code here


************************************
Question ID: 762
def is_prime(n: int) -> bool:
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def count_prime_set_bits(left: int, right: int) -> int:
    return sum(is_prime(bin(i).count('1')) for i in range(left, right + 1))


-----
def is_prime(n: int) -> bool:
    # Your code here


************************************
Question ID: 763
def partition_labels(s):
    last = {c:i for i, c in enumerate(s)}
    ans = []
    j = anchor = 0
    for i, c in enumerate(s):
        j = max(j, last[c])
        if i == j:
            ans.append(i - anchor + 1)
            anchor = i + 1
    return ans

-----
def partition_labels(s):
    # Your code here


************************************
Question ID: 764
from collections import deque

class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []

def levelOrder(root):
    result = []

    if not root:
        return result

    toVisit = deque([root])

    while toVisit:
        size = len(toVisit)
        level = []

        for _ in range(size):
            currentNode = toVisit.popleft()
            level.append(currentNode.val)

            for child in currentNode.children:
                toVisit.append(child)

        result.append(level)

    return result

-----
from collections import deque
    # Your code here


************************************
Question ID: 765
def minSwapsCouples(row):
    n = len(row)
    position = [0] * n
    for i in range(n):
        position[row[i]] = i

    swaps = 0
    for i in range(0, n, 2):
        partner = row[i] + 1 if row[i] % 2 == 0 else row[i] - 1
        if row[i + 1] != partner:
            row[position[partner]], row[i + 1] = row[i + 1], row[position[partner]]
            position[row[i + 1]], position[partner] = position[partner], position[row[i + 1]]
            swaps += 1
    return swaps


-----
def minSwapsCouples(row):
    # Your code here


************************************
Question ID: 767
def is_prime(n: int) -> bool:
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def count_prime_set_bits(left: int, right: int) -> int:
    count = 0
    for i in range(left, right + 1):
        bits = bin(i).count('1')
        if is_prime(bits):
            count += 1
    return count

-----
def is_prime(n: int) -> bool:
    # Your code here


************************************
Question ID: 768
def partition_labels(s: str) -> list[int]:
    last_pos = {}
    for i, c in enumerate(s):
        last_pos[c] = i

    partitions = []
    start, end = 0, 0
    for i, c in enumerate(s):
        end = max(end, last_pos[c])
        if i == end:
            partitions.append(end - start + 1)
            start = i + 1
    return partitions


-----
def partition_labels(s: str) -> list[int]:
    # Your code here


************************************
Question ID: 769
def orderOfLargestPlusSign(n, mines):
    grid = [[1] * n for _ in range(n)]
    for mine in mines:
        grid[mine[0]][mine[1]] = 0
        
    left, right, up, down = [list(grid) for _ in range(4)]

    for i in range(n):
        for j in range(n):
            if grid[i][j]:
                left[i][j] = 1 + (left[i][j - 1] if j > 0 else 0)
                up[i][j] = 1 + (up[i - 1][j] if i > 0 else 0)

    ans = 0
    for i in range(n - 1, -1, -1):
        for j in range(n - 1, -1, -1):
            if grid[i][j]:
                right[i][j] = 1 + (right[i][j + 1] if j < n - 1 else 0)
                down[i][j] = 1 + (down[i + 1][j] if i < n - 1 else 0)
                ans = max(ans, min([left[i][j], right[i][j], up[i][j], down[i][j]]))

    return ans


-----
def orderOfLargestPlusSign(n, mines):
    # Your code here


************************************
Question ID: 770
def minSwapsCouples(row):
    n = len(row) // 2
    swaps = 0
    position = {num: i for i, num in enumerate(row)}

    for i in range(0, len(row), 2):
        couple = row[i] - 1 if row[i] % 2 else row[i] + 1
        if row[i + 1] != couple:
            row[i + 1], row[position[couple]] = row[position[couple]], row[i + 1]
            position[row[i + 1]], position[couple] = position[couple], i + 1
            swaps += 1

    return swaps

-----
def minSwapsCouples(row):
    # Your code here


************************************
Question ID: 771
def num_jewels_in_stones(jewels: str, stones: str) -> int:
    count = 0
    for stone in stones:
        if stone in jewels:
            count += 1
    return count

-----
def num_jewels_in_stones(jewels: str, stones: str) -> int:
    # Your code here


************************************
Question ID: 777
def isToeplitzMatrix(matrix):
    rows = len(matrix)
    cols = len(matrix[0])
    for i in range(rows - 1):
        for j in range(cols - 1):
            if matrix[i][j] != matrix[i+1][j+1]:
                return False
    return True


-----
def isToeplitzMatrix(matrix):
    # Your code here


************************************
Question ID: 778
import heapq

def rearrange_string(s):
    counts = {}
    for c in s:
        counts[c] = counts.get(c, 0) + 1
    
    pq = [(-count, char) for char, count in counts.items()]
    heapq.heapify(pq)
    
    result = []
    previous = (0, '')
    
    while pq:
        count, char = heapq.heappop(pq)
        result.append(char)
        
        if previous[0] < 0:
            heapq.heappush(pq, previous)
        
        count += 1
        previous = (count, char)
    
    result_str = ''.join(result)
    return result_str if len(result_str) == len(s) else ""


-----
import heapq
    # Your code here


************************************
Question ID: 779
def max_chunks_to_sorted(arr):
    max_val, chunks = 0, 0
    for i, value in enumerate(arr):
        max_val = max(max_val, value)
        if max_val == i:
            chunks += 1
    return chunks

-----
def max_chunks_to_sorted(arr):
    # Your code here


************************************
Question ID: 780
def max_chunks_to_sorted(arr):
    max_so_far, count = 0, 0
    for i, val in enumerate(arr):
        max_so_far = max(max_so_far, val)
        if max_so_far == i:
            count += 1
    return count


-----
def max_chunks_to_sorted(arr):
    # Your code here


************************************
Question ID: 781
from collections import Counter

def numRabbits(answers):
    count = Counter(answers)
    rabbits = 0
    for ans, cnt in count.items():
        rabbits += (ans + cnt)//(ans + 1) * (ans + 1)
    return rabbits


-----
from collections import Counter
    # Your code here


************************************
Question ID: 782
def numJewelsInStones(jewels, stones):
    count = 0
    for s in stones:
        if s in jewels:
            count += 1
    return count

-----
def numJewelsInStones(jewels, stones):
    # Your code here


************************************
Question ID: 785
def isBipartite(graph: List[List[int]]) -> bool:
    def dfs(node: int, color: int) -> bool:
        if colors[node]:
            return colors[node] == color

        colors[node] = color
        for neighbor in graph[node]:
            if not dfs(neighbor, 3 - color):
                return False

        return True

    n = len(graph)
    colors = [0] * n

    for i in range(n):
        if not colors[i] and not dfs(i, 1):
            return False

    return True

-----
def isBipartite(graph: List[List[int]]) -> bool:
    # Your code here


************************************
Question ID: 786
import heapq
from typing import List

def kthSmallestPrimeFraction(arr: List[int], k: int) -> List[int]:
    pq = [(arr[i] / arr[j], i, j) for j in range(len(arr) - 1, 0, -1)]
    heapq.heapify(pq)
    for _ in range(k - 1):
        _, i, j = heapq.heappop(pq)
        if j != i + 1:
            heapq.heappush(pq, (arr[i] / arr[j - 1], i, j - 1))
    return [arr[pq[0][1]], arr[pq[0][2]]]

-----
import heapq
    # Your code here


************************************
Question ID: 787
from collections import deque

def slidingPuzzle(board):
    m, n = 2, 3
    target = "123450"
    start = "".join(str(num) for row in board for num in row)
    dirs = [[1, 3], [0, 2, 4], [1, 5], [0, 4], [1, 3, 5], [2, 4]]
    q = deque([start])
    res = 0
    visited = {start}
    while q:
        for _ in range(len(q)):
            cur = q.popleft()
            if cur == target:
                return res
            zero_idx = cur.index("0")
            for dir in dirs[zero_idx]:
                neighbor = list(cur)
                neighbor[zero_idx], neighbor[dir] = neighbor[dir], neighbor[zero_idx]
                neighbor = "".join(neighbor)
                if neighbor not in visited:
                    visited.add(neighbor)
                    q.append(neighbor)
        res += 1
    return -1

-----
from collections import deque
    # Your code here


************************************
Question ID: 788
def rotatedDigits(n: int) -> int:
    count = 0
    for i in range(1, n + 1):
        if isGood(i):
            count += 1
    return count

def isGood(num: int) -> bool:
    changed = False
    while num:
        digit = num % 10
        if digit in (3, 4, 7):
            return False
        if digit in (2, 5, 6, 9):
            changed = True
        num //= 10
    return changed

-----
def rotatedDigits(n: int) -> int:
    # Your code here


************************************
Question ID: 789
import heapq

class KthLargest:

    def __init__(self, k, nums):
        self.heap = []
        self.k = k
        for num in nums:
            self.add(num)

    def add(self, val):
        heapq.heappush(self.heap, val)
        if len(self.heap) > self.k:
            heapq.heappop(self.heap)
        return self.heap[0]

-----
import heapq
    # Your code here


************************************
Question ID: 790
def is_ideal_permutation(nums):
    for i, num in enumerate(nums):
        if abs(num - i) > 1:
            return False
    return True


-----
def is_ideal_permutation(nums):
    # Your code here


************************************
Question ID: 791
def customSortString(order, s):
    priority = {char: idx for idx, char in enumerate(order)}
    return "".join(sorted(s, key=lambda x: priority.get(x, 0)))

-----
def customSortString(order, s):
    # Your code here


************************************
Question ID: 792
def search(nums, target):
    left = 0
    right = len(nums) - 1

    while left <= right:
        mid = left + (right - left) // 2

        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1


-----
def search(nums, target):
    # Your code here


************************************
Question ID: 793
def canTransform(start: str, end: str) -> bool:
    if len(start) != len(end): return False

    i, j = 0, 0
    n = len(start)
    while i < n and j < n:
        while i < n and start[i] == 'X': i += 1
        while j < n and end[j] == 'X': j += 1

        if start[i] != end[j]: return False

        if (start[i] == 'R' and i > j) or (start[i] == 'L' and i < j): return False

        i += 1; j += 1
    return True

-----
def canTransform(start: str, end: str) -> bool:
    # Your code here


************************************
Question ID: 794
import heapq

def swim(n, grid):
    pq = [(grid[0][0], 0, 0)]
    visited = [[False] * n for _ in range(n)]

    dr = [-1, 0, 1, 0]
    dc = [0, 1, 0, -1]

    while pq:
        curT, curR, curC = heapq.heappop(pq)

        if curR == n - 1 and curC == n - 1:
            return curT

        for d in range(4):
            newRow, newCol = curR + dr[d], curC + dc[d]
            if 0 <= newRow < n and 0 <= newCol < n and not visited[newRow][newCol]:
                visited[newRow][newCol] = True
                heapq.heappush(pq, (max(curT, grid[newRow][newCol]), newRow, newCol))

    return -1

-----
import heapq
    # Your code here


************************************
Question ID: 795
def kthSymbolInGrammar(n, k):
    if n == 1:
        return 0
    if k % 2 == 0:
        return 1 - kthSymbolInGrammar(n - 1, k // 2)
    else:
        return kthSymbolInGrammar(n - 1, (k + 1) // 2)

-----
def kthSymbolInGrammar(n, k):
    # Your code here


************************************
Question ID: 796
def can_transform(sx, sy, tx, ty):
    while sx != tx or sy != ty:
        if sx > tx or sy > ty:
            return False
        if sx < tx:
            tx -= ty
        else:
            ty -= sx
    return True

-----
def can_transform(sx, sy, tx, ty):
    # Your code here


************************************
Question ID: 797
from collections import defaultdict
def numRabbits(answers):
    count = defaultdict(int)
    res = 0
    for a in answers:
        count[a] += 1
        if count[a] == 1:
            res += (a + 1)
        elif count[a] > a + 1:
            count[a] = 1
            res += (a + 1)
    return res


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 798
def moves_to_chessboard(board):
    N = len(board)
    row, col = 0, 0
    row_count, col_count = 0, 0

    for i in range(N):
        for j in range(N):
            if (board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]) != 0:
                return -1

    for i in range(N):
        row ^= board[0][i]
        col ^= board[i][0]
        row_count += 1 if board[0][i] == 1 else 0
        col_count += 1 if board[i][0] == 1 else 0

    if row != 0 and row_count * 2 != N:
        return -1
    if col != 0 and col_count * 2 != N:
        return -1

    if N % 2 == 1:
        if row_count % 2 == 1:
            row_count = N - row_count
        if col_count % 2 == 1:
            col_count = N - col_count
    else:
        row_count = min(row_count, N - row_count)
        col_count = min(col_count, N - col_count)

    return (row_count + col_count) // 2

-----
def moves_to_chessboard(board):
    # Your code here


************************************
Question ID: 800
def letterCasePermutation(s):
    def backtrack(index):
        if index == len(s):
            result.append("".join(s))
            return
        backtrack(index + 1)
        if s[index].isalpha():
            s[index] = s[index].swapcase()
            backtrack(index + 1)
            s[index] = s[index].swapcase()

    result = []
    s = list(s)
    backtrack(0)
    return result

-----
def letterCasePermutation(s):
    # Your code here


************************************
Question ID: 801
from collections import deque

def isBipartite(graph):
    colors = [0] * len(graph)
    for i in range(len(graph)):
        if colors[i] != 0:
            continue
        colors[i] = 1
        queue = deque([i])
        while queue:
            node = queue.popleft()
            for neighbor in graph[node]:
                if colors[neighbor] == 0:
                    colors[neighbor] = -colors[node]
                    queue.append(neighbor)
                elif colors[neighbor] == colors[node]:
                    return False
    return True


-----
from collections import deque
    # Your code here


************************************
Question ID: 802
import heapq

def kthSmallestPrimeFraction(arr, k):
    pq = [(-arr[i] / arr[-1], i, len(arr) - 1) for i in range(len(arr) - 1)]

    heapq.heapify(pq)

    for _ in range(k - 1):
        frac, i, j = heapq.heappop(pq)
        j -= 1
        if i < j:
            heapq.heappush(pq, (-arr[i] / arr[j], i, j))

    frac, i, j = heapq.heappop(pq)
    return [arr[i], arr[j]]

-----
import heapq
    # Your code here


************************************
Question ID: 803
import heapq

def findCheapestPrice(n, flights, src, dst, k):
    graph = [[] for _ in range(n)]
    for flight in flights:
        graph[flight[0]].append((flight[1], flight[2]))

    pq = [(0, src, k + 1)]
    while pq:
        price, city, stops = heapq.heappop(pq)

        if city == dst:
            return price

        if stops > 0:
            for nei, prc in graph[city]:
                heapq.heappush(pq, (price + prc, nei, stops - 1))

    return -1


-----
import heapq
    # Your code here


************************************
Question ID: 804
def rotated_digits(n):
    count = 0
    for i in range(1, n + 1):
        is_valid_after_rotation = True
        is_different_after_rotation = False
        num = i
        while num:
            digit = num % 10
            if digit in {3, 4, 7}:
                is_valid_after_rotation = False
                break
            if digit in {2, 5, 6, 9}:
                is_different_after_rotation = True
            num //= 10
        if is_valid_after_rotation and is_different_after_rotation:
            count += 1
    return count

-----
def rotated_digits(n):
    # Your code here


************************************
Question ID: 805
from typing import List

def escape_ghosts(ghosts: List[List[int]], target: List[int]) -> bool:
    max_dist = abs(target[0]) + abs(target[1])
    for ghost in ghosts:
        ghost_dist = abs(ghost[0] - target[0]) + abs(ghost[1] - target[1])
        if ghost_dist <= max_dist:
            return False
    return True


-----
from typing import List
    # Your code here


************************************
Question ID: 806
def numberOfWays(n):
    MOD = 1000000007
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1

    for i in range(2, n + 1):
        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD

    return dp[n]


-----
def numberOfWays(n):
    # Your code here


************************************
Question ID: 807
def custom_sort_string(order, s):
    return ''.join(sorted(s, key=lambda x: order.index(x) if x in order else len(order)))


-----
def custom_sort_string(order, s):
    # Your code here


************************************
Question ID: 808
from bisect import bisect_left
from collections import defaultdict

def numMatchingSubseq(s, words):
    positions = defaultdict(list)

    for i, c in enumerate(s):
        positions[c].append(i)

    count = 0

    for word in words:
        index = -1
        isSubsequence = True

        for c in word:
            position_list = positions.get(c, [])
            i = bisect_left(position_list, index + 1)
            if (i == len(position_list)):
                isSubsequence = False
                break
            index = position_list[i]

        if isSubsequence:
            count += 1

    return count

-----
from bisect import bisect_left
    # Your code here


************************************
Question ID: 809
def num_zeros(k):
    x = 0
    i = 5
    while k // i >= 1:
        x += k // i
        i *= 5
    return x

-----
def num_zeros(k):
    # Your code here


************************************
Question ID: 810
def valid_tic_tac_toe(board: List[str]) -> bool:
    x_count = sum(row.count('X') for row in board)
    o_count = sum(row.count('O') for row in board)
    if x_count != o_count and x_count != o_count + 1: return False

    x_win, o_win = False, False
    for i in range(3):
        if board[i][0] == board[i][1] == board[i][2] != ' ':
            x_win, o_win = (True, o_win) if board[i][0] == 'X' else (x_win, True)
        if board[0][i] == board[1][i] == board[2][i] != ' ':
            x_win, o_win = (True, o_win) if board[0][i] == 'X' else (x_win, True)
    if board[0][0] == board[1][1] == board[2][2] != ' ':
        x_win, o_win = (True, o_win) if board[0][0] == 'X' else (x_win, True)
    if board[0][2] == board[1][1] == board[2][0] != ' ':
        x_win, o_win = (True, o_win) if board[0][2] == 'X' else (x_win, True)

    if x_win and o_win: return False
    if x_win and x_count == o_count: return False
    if o_win and x_count > o_count: return False

    return True


-----
def valid_tic_tac_toe(board: List[str]) -> bool:
    # Your code here


************************************
Question ID: 811
def numSubarrayBoundedMax(nums, left, right):
    result, prev, start = 0, 0, -1
    for i, num in enumerate(nums):
        if left <= num <= right:
            prev = i - start
            result += prev
        elif num < left:
            result += prev
        else:
            start = i
            prev = 0
    return result


-----
def numSubarrayBoundedMax(nums, left, right):
    # Your code here


************************************
Question ID: 812
def is_shifted(s, goal):
    if len(s) != len(goal): return False

    s = s + s
    return goal in s

-----
def is_shifted(s, goal):
    # Your code here


************************************
Question ID: 813
from typing import List

def allPathsSourceTarget(graph: List[List[int]]) -> List[List[int]]:
    def DFS(currentNode, path):
        path.append(currentNode)
        if currentNode == len(graph) - 1:
            result.append(path[:])
        else:
            for neighbor in graph[currentNode]:
                DFS(neighbor, path)
        path.pop()

    result = []
    DFS(0, [])
    return result

-----
from typing import List
    # Your code here


************************************
Question ID: 814
def best_rotation(nums):
    n = len(nums)
    change = [0] * n

    for i in range(n):
        change[(i - nums[i] + 1 + n) % n] -= 1
        change[(i + 1) % n] += 1

    max_score = 0
    cur_score = change[0]
    for i in range(1, n):
        cur_score += change[i]
        if cur_score > max_score:
            max_score = cur_score
            
    return max_score


-----
def best_rotation(nums):
    # Your code here


************************************
Question ID: 815
from collections import defaultdict, deque

def numBusesToDestination(routes, source, target):
    if source == target:
        return 0

    stop_route_map = defaultdict(set)
    for i, route in enumerate(routes):
        for stop in route:
            stop_route_map[stop].add(i)

    queue = deque([source])
    visited_sources = {source}

    transfers = 0
    while queue:
        size = len(queue)
        for _ in range(size):
            curr = queue.popleft()
            if curr == target:
                return transfers

            for route in stop_route_map[curr]:
                for stop in routes[route]:
                    if stop not in visited_sources:
                        queue.append(stop)
                        visited_sources.add(stop)
                stop_route_map[curr].remove(route)
        transfers += 1
    return -1

-----
from collections import defaultdict, deque
    # Your code here


************************************
Question ID: 818
def racecar(target: int) -> int:
    memo = {}
    def dp(position, speed):
        if abs(position) > 2 * target:
            return target + 1
        if position == target:
            return 0 if speed == 1 else 1
        if (position, speed) in memo:
            return memo[(position, speed)]
        
        ans = dp(position + speed // 2, -speed // 2) + 1 if speed > 0 else dp(position - speed // 2, -speed // 2) + 1
        ans = min(ans, dp(position + speed, speed * 2) + 1)
        memo[(position, speed)] = ans
        return ans
    
    return dp(0, 1)

-----
def racecar(target: int) -> int:
    # Your code here


************************************
Question ID: 819
def minSwaps(nums1, nums2):
    n = len(nums1)
    noSwap = [float('inf')] * n
    doSwap = [float('inf')] * n
    noSwap[0] = 0
    doSwap[0] = 1

    for i in range(1, n):
        if nums1[i] > nums1[i - 1] and nums2[i] > nums2[i - 1]:
            noSwap[i] = noSwap[i - 1]
            doSwap[i] = doSwap[i - 1] + 1
        if nums1[i] > nums2[i - 1] and nums2[i] > nums1[i - 1]:
            noSwap[i] = min(noSwap[i], doSwap[i - 1])
            doSwap[i] = min(doSwap[i], noSwap[i - 1] + 1)

    return min(noSwap[n - 1], doSwap[n - 1])

-----
def minSwaps(nums1, nums2):
    # Your code here


************************************
Question ID: 820
from typing import List

def eventualSafeNodes(graph: List[List[int]]) -> List[int]:
    n = len(graph)
    color = [0] * n
    ans = []

    def hasCycle(node: int, color: List[int], graph: List[List[int]]) -> bool:
        if color[node] > 0:
            return color[node] == 1
        color[node] = 1
        for neighbor in graph[node]:
            if hasCycle(neighbor, color, graph):
                return True
        color[node] = 2
        return False

    for i in range(n):
        if not hasCycle(i, color, graph):
            ans.append(i)
    return ans

-----
from typing import List
    # Your code here


************************************
Question ID: 821
from typing import List

def hitBricks(grid: List[List[int]], hits: List[List[int]]) -> List[int]:
    def dfs(x, y):
        if not (0 <= x < m) or not (0 <= y < n) or grid[x][y] <= 0:
            return 0
        grid[x][y] = -1
        return 1 + sum(dfs(x + dx, y + dy) for dx, dy in directions)

    m, n = len(grid), len(grid[0])
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    for x, y in hits:
        grid[x][y] -= 1

    for j in range(n):
        if grid[0][j] == 1:
            dfs(0, j)

    result = []
    for x, y in hits:
        grid[x][y] += 1
        if grid[x][y] != 1:
            result.append(0)
            continue
        for dx, dy in directions:
            if dfs(x + dx, y + dy) != 0:
                result.append(dfs(x, y) - 1)
                break
        else:
            result.append(0)

    return result

-----
from typing import List
    # Your code here


************************************
Question ID: 822
def uniqueMorseRepresentations(words):
    morse = [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
    transformations = set()

    for word in words:
        morseCode = ''.join(morse[ord(c) - ord('a')] for c in word)
        transformations.add(morseCode)

    return len(transformations)

-----
def uniqueMorseRepresentations(words):
    # Your code here


************************************
Question ID: 823
def isPossibleToSplit(nums):
    n = len(nums)
    total_sum = sum(nums)

    if total_sum % n != 0:
        return False

    target_sum = total_sum * (n // 2) // n
    dp = [[False] * (target_sum + 1) for _ in range(n // 2 + 1)]
    dp[0][0] = True

    for num in nums:
        for count in range(n // 2, 0, -1):
            for sum_ in range(target_sum, num - 1, -1):
                dp[count][sum_] = dp[count][sum_] or dp[count - 1][sum_ - num]

        if dp[n // 2][target_sum]:
            return True

    return False


-----
def isPossibleToSplit(nums):
    # Your code here


************************************
Question ID: 824
def number_of_lines(widths, s):
    lines = 1
    current_pixel = 0
    for c in s:
        letter_pixels = widths[ord(c) - ord('a')]
        if current_pixel + letter_pixels > 100:
            lines += 1
            current_pixel = 0
        current_pixel += letter_pixels
    return [lines, current_pixel]


-----
def number_of_lines(widths, s):
    # Your code here


************************************
Question ID: 825
def max_increase_keeping_skyline(grid):
    n = len(grid)
    row_max = [0] * n
    col_max = [0] * n
    
    for i in range(n):
        for j in range(n):
            row_max[i] = max(row_max[i], grid[i][j])
            col_max[j] = max(col_max[j], grid[i][j])
    
    total_sum = 0
    for i in range(n):
        for j in range(n):
            total_sum += min(row_max[i], col_max[j]) - grid[i][j]
    
    return total_sum

-----
def max_increase_keeping_skyline(grid):
    # Your code here


************************************
Question ID: 826
def maxProfitAssignment(difficulty, profit, worker):
    n = len(difficulty)
    jobs = sorted(zip(difficulty, profit))
    worker.sort()

    max_profit = 0
    total_profit = 0
    job_idx = 0

    for w in worker:
        while job_idx < n and w >= jobs[job_idx][0]:
            max_profit = max(max_profit, jobs[job_idx][1])
            job_idx += 1
        total_profit += max_profit

    return total_profit

-----
def maxProfitAssignment(difficulty, profit, worker):
    # Your code here


************************************
Question ID: 827
def maxAreaOfIsland(grid):
    def dfs(x, y):
        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0:
            return 0
        grid[x][y] = 0
        return dfs(x - 1, y) + dfs(x + 1, y) + dfs(x, y - 1) + dfs(x, y + 1) + 1

    ans = 0
    for i, row in enumerate(grid):
        for j, cell in enumerate(row):
            if cell == 0:
                grid[i][j] = 1
                ans = max(ans, dfs(i, j))
                grid[i][j] = 0
    return ans

-----
def maxAreaOfIsland(grid):
    # Your code here


************************************
Question ID: 828
def xor_game(nums: List[int]) -> bool:
    xor_sum = 0
    for num in nums:
        xor_sum ^= num
    return xor_sum == 0 or len(nums) % 2 == 0

-----
def xor_game(nums: List[int]) -> bool:
    # Your code here


************************************
Question ID: 829
from collections import defaultdict

def subdomainVisits(cpdomains):
    counts = defaultdict(int)
    result = []

    for cpdomain in cpdomains:
        count, domain = cpdomain.split()
        count = int(count)

        for i in range(len(domain)):
            if domain[i] == '.':
                counts[domain[i + 1:]] += count
        counts[domain] += count

    for sub, cnt in counts.items():
        result.append(f"{cnt} {sub}")
        
    return result


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 830
from itertools import combinations

def largestTriangleArea(points):
    return max(0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) for (x1, y1), (x2, y2), (x3, y3) in combinations(points, 3))

-----
from itertools import combinations
    # Your code here


************************************
Question ID: 832
def pruneTree(root: TreeNode) -> TreeNode:
    if not root:
        return None
    root.left = pruneTree(root.left)
    root.right = pruneTree(root.right)
    if root.val == 0 and not root.left and not root.right:
        return None
    return root

-----
def pruneTree(root: TreeNode) -> TreeNode:
    # Your code here


************************************
Question ID: 833
from collections import defaultdict
from queue import Queue

def numBusesToDestination(routes, source, target):
    if source == target:
        return 0

    stop_to_buses = defaultdict(set)
    for i, route in enumerate(routes):
        for stop in route:
            stop_to_buses[stop].add(i)

    q = Queue()
    visited_buses = set()
    num_buses = 0
    q.put(source)

    while not q.empty():
        size = q.qsize()
        for _ in range(size):
            stop = q.get()
            for bus in stop_to_buses[stop]:
                if bus in visited_buses:
                    continue
                visited_buses.add(bus)
                for next_stop in routes[bus]:
                    if next_stop == target:
                        return num_buses + 1
                    q.put(next_stop)
        num_buses += 1

    return -1

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 834
def ambiguousCoordinates(s):
    def generateNumber(s):
        if not s or (len(s) > 1 and s[0] == '0' and s[-1] == '0'):
            return []
        if len(s) > 1 and s[0] == '0':
            return ["0." + s[1:]]
        res = [s]
        if len(s) == 1 or s[-1] == '0':
            return res
        for i in range(1, len(s)):
            res.append(s[:i] + "." + s[i:])
        return res

    n = len(s)
    res = []
    
    for i in range(2, n - 1):
        first = generateNumber(s[1:i])
        second = generateNumber(s[i:n - 1])
        
        for f in first:
            for sec in second:
                res.append("(" + f + ", " + sec + ")")
    
    return res


-----
def ambiguousCoordinates(s):
    # Your code here


************************************
Question ID: 836
def racecar(target: int) -> int:
    memo = {}

    def dp(pos: int, speed: int) -> int:
        if pos == target:
            return 0
        if abs(pos) > 2 * target:
            return float('inf')

        key = (pos, speed)
        if key in memo:
            return memo[key]

        op1 = dp(pos + speed, speed * 2) + 1
        op2 = dp(pos, -speed) + 2

        ans = min(op1, op2)
        memo[key] = ans
        return ans

    return dp(0, 1)

-----
def racecar(target: int) -> int:
    # Your code here


************************************
Question ID: 837
def mostCommonWord(paragraph: str, banned: List[str]):
    word_count = {}
    banned_set = {ban.lower() for ban in banned}

    for word in paragraph.lower().split():
        cleaned_word = ''.join(c for c in word if c.isalpha())
        if cleaned_word not in banned_set:
            word_count[cleaned_word] = word_count.get(cleaned_word, 0) + 1

    return max(word_count, key=word_count.get)


-----
def mostCommonWord(paragraph: str, banned: List[str]):
    # Your code here


************************************
Question ID: 838
def pushDominoes(dominoes: str) -> str:
    n = len(dominoes)
    forces = [0] * n
    
    force = 0
    for i in range(n):
        if dominoes[i] == 'R':
            force = n
        elif dominoes[i] == 'L':
            force = 0
        else:
            force = max(force - 1, 0)
        forces[i] += force
    
    force = 0
    for i in range(n - 1, -1, -1):
        if dominoes[i] == 'L':
            force = n
        elif dominoes[i] == 'R':
            force = 0
        else:
            force = max(force - 1, 0)
        forces[i] -= force
    
    return "".join(['R' if f > 0 else 'L' if f < 0 else '.' for f in forces])


-----
def pushDominoes(dominoes: str) -> str:
    # Your code here


************************************
Question ID: 839
def minimal_length_encoding(words):
    word_set = set(words)

    for word in words:
        for i in range(1, len(word)):
            word_set.discard(word[i:])

    return sum(len(word) + 1 for word in word_set)

-----
def minimal_length_encoding(words):
    # Your code here


************************************
Question ID: 840
def numMagicSquaresInside(grid):
    count = 0
    for i in range(len(grid) - 2):
        for j in range(len(grid[0]) - 2):
            if grid[i][j] <= 9 and grid[i + 1][j + 1] == 5 and isMagic(grid, i, j):
                count += 1
    return count


def isMagic(grid, x, y):
    temp = [0] * 16
    for i in range(3):
        for j in range(3):
            num = grid[x + i][y + j]
            temp[num] += 1
            if num > 9 or temp[num] > 1:
                return False

    _sum = grid[x][y] + grid[x][y+1] + grid[x][y+2]
    for i in range(3):
        row_sum, col_sum = 0, 0
        for j in range(3):
            row_sum += grid[x + i][y + j]
            col_sum += grid[x + j][y + i]
        if row_sum != _sum or col_sum != _sum:
            return False

    if grid[x][y] + grid[x + 1][y + 1] + grid[x + 2][y + 2] != _sum:
        return False
    if grid[x][y + 2] + grid[x + 1][y + 1] + grid[x + 2][y] != _sum:
        return False

    return True


-----
def numMagicSquaresInside(grid):
    # Your code here


************************************
Question ID: 841
def shortestToChar(s, c):
    n = len(s)
    result = [n for _ in range(n)]
    pos = -n

    for i in range(n):
        if s[i] == c:
            pos = i
        result[i] = i - pos

    for i in range(pos - 1, -1, -1):
        if s[i] == c:
            pos = i
        result[i] = min(result[i], pos - i)

    return result


-----
def shortestToChar(s, c):
    # Your code here


************************************
Question ID: 842
def smallest_good_integer(fronts, backs):
    not_good = {fronts[i] for i in range(len(fronts)) if fronts[i] == backs[i]}

    result = float('inf')
    for i in range(len(fronts)):
        if fronts[i] not in not_good:
            result = min(result, fronts[i])
        if backs[i] not in not_good:
            result = min(result, backs[i])

    return 0 if result == float('inf') else result

-----
def smallest_good_integer(fronts, backs):
    # Your code here


************************************
Question ID: 843
def numFactoredBinaryTrees(arr):
    MOD = 10**9 + 7
    n = len(arr)
    arr.sort()
    dp = {}
    for i, x in enumerate(arr):
        dp[x] = 1
        for y in arr[:i]:
            if x % y == 0 and x // y in dp:
                dp[x] = (dp[x] + dp[y] * dp[x // y]) % MOD
    return sum(dp.values()) % MOD

-----
def numFactoredBinaryTrees(arr):
    # Your code here


************************************
Question ID: 844
def backspaceCompare(s: str, t: str) -> bool:
    i, j = len(s) - 1, len(t) - 1
    while True:
        back = 0
        while i >= 0 and (back > 0 or s[i] == '#'):
            back = back + 1 if s[i] == '#' else back - 1
            i -= 1
        back = 0
        while j >= 0 and (back > 0 or t[j] == '#'):
            back = back + 1 if t[j] == '#' else back - 1
            j -= 1
        if i >= 0 and j >= 0 and s[i] == t[j]:
            i, j = i -1, j - 1
        else:
            return i == -1 and j == -1

-----
def backspaceCompare(s: str, t: str) -> bool:
    # Your code here


************************************
Question ID: 845
def longestMountain(arr):
    n = len(arr)
    res = up = down = 0

    for i in range(1, n):
        if (down and arr[i - 1] < arr[i]) or arr[i - 1] == arr[i]:
            up = down = 0

        up += arr[i - 1] < arr[i]
        down += arr[i - 1] > arr[i]

        if up and down:
            res = max(res, up + down + 1)

    return res

-----
def longestMountain(arr):
    # Your code here


************************************
Question ID: 846
from collections import Counter

def is_possible_divide(hand, group_size):
    card_count = Counter(hand)

    for card in sorted(card_count):
        if card_count[card] > 0:
            count = card_count[card]
            for i in range(1, group_size):
                if card_count[card + i] < count:
                    return False
                card_count[card + i] -= count

    return True


-----
from collections import Counter
    # Your code here


************************************
Question ID: 847
from collections import deque

def shortestPathLength(graph):
    n = len(graph)
    queue = deque([(i, 1 << i, 0) for i in range(n)])
    visited = [[False] * (1 << n) for _ in range(n)]

    for i in range(n):
        visited[i][1 << i] = True

    while queue:
        node, bitmask, length = queue.popleft()

        if bitmask == (1 << n) - 1:
            return length

        for nei in graph[node]:
            next_bitmask = bitmask | (1 << nei)
            if not visited[nei][next_bitmask]:
                visited[nei][next_bitmask] = True
                queue.append((nei, next_bitmask, length + 1))

    return 0

-----
from collections import deque
    # Your code here


************************************
Question ID: 848
def shiftingLetters(s: str, shifts) -> str:
    for i in range(len(shifts) - 2, -1, -1):
        shifts[i] += shifts[i + 1] % 26

    result = list(s)
    for i in range(len(s)):
        result[i] = chr((ord(result[i]) - ord('a') + shifts[i] % 26) % 26 + ord('a'))
        
    return "".join(result)

-----
def shiftingLetters(s: str, shifts) -> str:
    # Your code here


************************************
Question ID: 849
def maxDistToClosest(seats):
    n = len(seats)
    maxDist = 0
    lastPerson = -1

    for i in range(n):
        if seats[i] == 1:
            if lastPerson == -1:
                maxDist = i
            else:
                maxDist = max(maxDist, (i - lastPerson) // 2)
            lastPerson = i

    maxDist = max(maxDist, n - 1 - lastPerson)
    return maxDist

-----
def maxDistToClosest(seats):
    # Your code here


************************************
Question ID: 850
def rectangleArea(rectangles):
    mod = 10**9 + 7
    n = len(rectangles)
    X, Y = set(), set()
    for rect in rectangles:
        X.add(rect[0])
        X.add(rect[2])
        Y.add(rect[1])
        Y.add(rect[3])
    sorted_x = sorted(X)
    sorted_y = sorted(Y)
    cnt = [[0 for _ in range(len(Y) - 1)] for _ in range(len(X) - 1)]

    for rect in rectangles:
        x1_idx = sorted_x.index(rect[0])
        x2_idx = sorted_x.index(rect[2]) - 1
        y1_idx = sorted_y.index(rect[1])
        y2_idx = sorted_y.index(rect[3]) - 1
        for i in range(x1_idx, x2_idx + 1):
            for j in range(y1_idx, y2_idx + 1):
                cnt[i][j] = 1

    total_area = 0
    for i in range(len(X) - 1):
        for j in range(len(Y) - 1):
            if cnt[i][j]:
                total_area += (sorted_x[i + 1] - sorted_x[i]) * (sorted_y[j + 1] - sorted_y[j])
                total_area %= mod

    return total_area

-----
def rectangleArea(rectangles):
    # Your code here


************************************
Question ID: 851
def to_goat_latin(sentence: str) -> str:
    words = sentence.split()
    vowels = set("AEIOUaeiou")
    result = []

    for i, word in enumerate(words):
        if word[0] not in vowels:
            word = word[1:] + word[0]
        result.append(word + "ma" + "a" * (i + 1))

    return ' '.join(result)

-----
def to_goat_latin(sentence: str) -> str:
    # Your code here


************************************
Question ID: 852
def numFriendRequests(ages):
    count = [0] * 121
    total_requests = 0

    for age in ages:
        count[age] += 1

    for a in range(1, 121):
        for b in range(1, 121):
            if a * 0.5 + 7 >= b:
                continue
            if a < b:
                continue
            if a < b * 2:
                total_requests += count[a] * count[b]
                if a == b:
                    total_requests -= count[a]

    return total_requests

-----
def numFriendRequests(ages):
    # Your code here


************************************
Question ID: 853
def max_profit_assignment(difficulty, profit, worker):
    jobs = sorted(zip(difficulty, profit))
    worker.sort()

    i, max_profit, total_profit = 0, 0, 0
    for ability in worker:
        while i < len(difficulty) and ability >= jobs[i][0]:
            max_profit = max(max_profit, jobs[i][1])
            i += 1
        total_profit += max_profit
    return total_profit

-----
def max_profit_assignment(difficulty, profit, worker):
    # Your code here


************************************
Question ID: 854
def kSimilarity(s1: str, s2: str) -> int:
    k = 0
    temp = list(s1)

    for i in range(len(temp)):
        if temp[i] != s2[i]:
            j = i + 1
            while temp[j] != s2[i] or s2[j] == temp[j]:
                j += 1
            temp[i], temp[j] = temp[j], temp[i]
            k += 1

    return k

-----
def kSimilarity(s1: str, s2: str) -> int:
    # Your code here


************************************
Question ID: 855
def count_unique_chars(s):
    return len(set(s))

def sum_count_unique_chars(s):
    sum = 0
    for i in range(len(s)):
        for j in range(i + 1, len(s) + 1):
            sum += count_unique_chars(s[i:j])
    return sum

-----
def count_unique_chars(s):
    # Your code here


************************************
Question ID: 856
def consecutive_numbers_sum(n: int) -> int:
    count = 0
    i = 1
    while i * (i - 1) // 2 < n:
        if (n - i * (i - 1) // 2) % i == 0:
            count += 1
        i += 1
    return count


-----
def consecutive_numbers_sum(n: int) -> int:
    # Your code here


************************************
Question ID: 857
def largeGroupPositions(s: str):
    result = []
    start = 0
    for i in range(1, len(s)):
        if s[i] != s[start]:
            if i - start >= 3:
                result.append([start, i - 1])
            start = i
    if len(s) - start >= 3:
        result.append([start, len(s) - 1])
    return result


-----
def largeGroupPositions(s: str):
    # Your code here


************************************
Question ID: 858
def mask_information(s: str) -> str:
    if '@' in s:
        s = s.lower()
        return s[0] + "*****" + s[s.index('@') - 1:]
    else:
        digits = "".join(filter(str.isdigit, s))
        if len(digits) == 10:
            return "***-***-" + digits[-4:]
        prefix = "*"* (len(digits) - 10) + "-"
        return "+" + prefix + "***-***-" + digits[-4:]

-----
def mask_information(s: str) -> str:
    # Your code here


************************************
Question ID: 859
#

class MyCircularDeque {
    constructor(k) {
        this.buffer = new Array(k);
        this.front = 0;
        this.rear = 0;
        this.size = 0;
    }

    insertFront(value) {
        if (this.size == this.buffer.length) return false;
        this.front = (this.front - 1 + this.buffer.length) % this.buffer.length;
        this.buffer[this.front] = value;
        this.size++;
        return true;
    }

    insertLast(value) {
        if (this.size == this.buffer.length) return false;
        this.buffer[this.rear] = value;
        this.rear = (this.rear + 1) % this.buffer.length;
        this.size++;
        return true;
    }

    deleteFront() {
        if (this.size == 0) return false;
        this.front = (this.front + 1) % this.buffer.length;
        this.size--;
        return true;
    }

    deleteLast() {
        if (this.size == 0) return false;
        this.rear = (this.rear - 1 + this.buffer.length) % this.buffer.length;
        this.size--;
        return true;
    }

    getFront() {
        if (this.size == 0) return -1;
        return this.buffer[this.front];
    }

    getRear() {
        if (this.size == 0) return -1;
        return this.buffer[(this.rear - 1 + this.buffer.length) % this.buffer.length];
    }

    isEmpty() {
        return this.size == 0;
    }

    isFull() {
        return this.size == this.buffer.length;
    }
}

#
-----
#
    # Your code here

#
************************************
Question ID: 861
def flipAndInvertImage(image):
    for row in image:
        row.reverse()
        for j in range(len(row)):
            row[j] = 1 - row[j]
    return image

-----
def flipAndInvertImage(image):
    # Your code here


************************************
Question ID: 862
def findReplaceString(s, indices, sources, targets):
    index_mapping = sorted(
        [(indices[i], i) for i in range(len(indices)) if s.startswith(sources[i], indices[i])]
    )
    result = []
    last_idx = 0

    for idx, i in index_mapping:
        result.append(s[last_idx:idx])
        result.append(targets[i])
        last_idx = idx + len(sources[i])

    result.append(s[last_idx:])
    return "".join(result)

-----
def findReplaceString(s, indices, sources, targets):
    # Your code here


************************************
Question ID: 863
from collections import defaultdict

def sumOfDistancesInTree(n, edges):
    tree = defaultdict(set)
    for u, v in edges:
        tree[u].add(v)
        tree[v].add(u)

    count = [1] * n
    res = [0] * n

    def dfs(node, parent):
        for child in tree[node]:
            if child != parent:
                dfs(child, node)
                count[node] += count[child]
                res[node] += res[child] + count[child]

    def dfs2(node, parent):
        for child in tree[node]:
            if child != parent:
                res[child] = res[node] - count[child] + n - count[child]
                dfs2(child, node)

    dfs(0, -1)
    dfs2(0, -1)

    return res


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 864
def largestOverlap(img1, img2):
    n = len(img1)
    onesImg1 = [(i, j) for i in range(n) for j in range(n) if img1[i][j]]
    onesImg2 = [(i, j) for i in range(n) for j in range(n) if img2[i][j]]

    overlaps = {}
    for pt1 in onesImg1:
        for pt2 in onesImg2:
            dx, dy = pt2[0] - pt1[0], pt2[1] - pt1[1]
            key = (dx, dy)
            if key not in overlaps:
                overlaps[key] = 0
            overlaps[key] += 1

    return max(overlaps.values() or [0])

-----
def largestOverlap(img1, img2):
    # Your code here


************************************
Question ID: 866
def isRectangleOverlap(rec1, rec2):
    return rec1[2] > rec2[0] and rec1[3] > rec2[1] and rec1[0] < rec2[2] and rec1[1] < rec2[3]

-----
def isRectangleOverlap(rec1, rec2):
    # Your code here


************************************
Question ID: 867
def new21Game(n: int, k: int, maxPts: int) -> float:
    if k == 0 or n >= k + maxPts:
        return 1
    
    dp = [0] * (n + 1)
    dp[0] = 1
    s, ans = 1, 0

    for i in range(1, n + 1):
        dp[i] = s / maxPts
        if i < k:
            s += dp[i]
        else:
            ans += dp[i]
        if i >= maxPts:
            s -= dp[i - maxPts]

    return ans


-----
def new21Game(n: int, k: int, maxPts: int) -> float:
    # Your code here


************************************
Question ID: 868
def push_dominoes(dominoes: str) -> str:
    prev, cur = None, dominoes
    while prev != cur:
        prev = cur
        cur_lst = list(prev)
        for i in range(len(cur)):
            if prev[i] == 'L' and i > 0 and prev[i - 1] == '.':
                cur_lst[i - 1] = 'L'
            elif prev[i] == 'R' and i < len(cur) - 1 and prev[i + 1] == '.':
                cur_lst[i + 1] = 'R'
        cur = ''.join(cur_lst)
    return cur

-----
def push_dominoes(dominoes: str) -> str:
    # Your code here


************************************
Question ID: 869
def is_similar(a: str, b: str) -> bool:
    diff_count = 0
    for char_a, char_b in zip(a, b):
        if char_a != char_b:
            diff_count += 1
            if diff_count > 2:
                return False
    return True

def count_groups(strs: list[str]) -> int:
    count = 0
    visited = [False] * len(strs)
    for i in range(len(strs)):
        if not visited[i]:
            count += 1
            visited[i] = True
            for j in range(i + 1, len(strs)):
                if is_similar(strs[i], strs[j]):
                    visited[j] = True
    return count


-----
def is_similar(a: str, b: str) -> bool:
    # Your code here


************************************
Question ID: 870
from sortedcontainers import SortedList

def advantage_count(nums1, nums2):
    nums1_sorted = SortedList(nums1)
    result = []
    for num in nums2:
        index = nums1_sorted.bisect_right(num)
        if index == len(nums1_sorted):
            val = nums1_sorted.pop(0)
        else:
            val = nums1_sorted.pop(index)
        result.append(val)
    return result

-----
from sortedcontainers import SortedList
    # Your code here


************************************
Question ID: 871
def can_visit_all_rooms(rooms):
    visited = set()
    stack = [0]

    while stack:
        current_room = stack.pop()

        visited.add(current_room)

        for key in rooms[current_room]:
            if key not in visited:
                stack.append(key)

    return len(visited) == len(rooms)

-----
def can_visit_all_rooms(rooms):
    # Your code here


************************************
Question ID: 872
def splitIntoFibonacci(num):
    ans = []
    def backtrack(index, prev1, prev2):
        if index == len(num):
            return len(ans) >= 3
        curr = 0
        for i in range(index, len(num)):
            if i > index and num[index] == '0':
                break
            curr = curr * 10 + ord(num[i]) - ord('0')
            if curr > 2**31 - 1:
                break
            if len(ans) >= 2:
                if curr < prev1 + prev2:
                    continue
                elif curr > prev1 + prev2:
                    break
            ans.append(curr)
            if backtrack(i + 1, prev2, curr):
                return True
            ans.pop()
        return False
            
    backtrack(0, 0, 0)
    return ans

-----
def splitIntoFibonacci(num):
    # Your code here


************************************
Question ID: 873
import random

def match(a, b):
    return sum(a[i] == b[i] for i in range(6))

def find_secret_word(wordlist, master):
    for _ in range(10):
        guess = random.choice(wordlist)
        match_cnt = master.guess(guess)
        if match_cnt == 6:
            return
        wordlist = [word for word in wordlist if match(word, guess) == match_cnt]

-----
import random
    # Your code here


************************************
Question ID: 874
def backspace_compare(s, t):
    def process_backspaces(string):
        stack = []
        for c in string:
            if c != '#':
                stack.append(c)
            elif stack:
                stack.pop()
        return stack

    return process_backspaces(s) == process_backspaces(t)

-----
def backspace_compare(s, t):
    # Your code here


************************************
Question ID: 875
def longest_mountain(arr):
    n = len(arr)
    max_length = 0
    i = 1
    while i < n - 1:
        if arr[i - 1] < arr[i] and arr[i] > arr[i + 1]:
            left = i - 1
            right = i + 1
            while left > 0 and arr[left - 1] < arr[left]:
                left -= 1
            while right < n - 1 and arr[right] > arr[right + 1]:
                right += 1
            max_length = max(max_length, right - left + 1)
            i = right
        else:
            i += 1
    return max_length

-----
def longest_mountain(arr):
    # Your code here


************************************
Question ID: 876
from collections import Counter

def is_n_straight_hand(hand, group_size):
    counts = Counter(hand)

    for card in sorted(counts):
        if counts[card] > 0:
            for i in range(group_size - 1, -1, -1):
                if counts[card + i] < counts[card]:
                    return False
                counts[card + i] -= counts[card]

    return True


-----
from collections import Counter
    # Your code here


************************************
Question ID: 877
from collections import deque, defaultdict

def shortestPathLength(graph):
    n = len(graph)
    q = deque()
    
    for i in range(n):
        q.append((i, 1 << i))
    steps = -1
    visited = {i: set() for i in range(n)}
    
    while q:
        steps += 1
        for _ in range(len(q)):
            currNode, currVisits = q.popleft()
            
            if bin(currVisits).count('1') == n:
                return steps

            for nextNode in graph[currNode]:
                nextVisits = currVisits | (1 << nextNode)

                if nextVisits not in visited[nextNode]:
                    visited[nextNode].add(nextVisits)
                    q.append((nextNode, nextVisits))

    return -1


-----
from collections import deque, defaultdict
    # Your code here


************************************
Question ID: 878
def shiftingLetters(s: str, shifts: list[int]) -> str:
    n = len(s)
    for i in range(n - 2, -1, -1):
        shifts[i] = (shifts[i] + shifts[i + 1]) % 26
    
    result = []
    for i in range(n):
        result.append(chr(((ord(s[i]) - ord('a')) + shifts[i]) % 26 + ord('a')))
    
    return "".join(result)

-----
def shiftingLetters(s: str, shifts: list[int]) -> str:
    # Your code here


************************************
Question ID: 879
def max_dist_to_closest(seats):
    max_dist = 0
    last_person = -1
    for i, seat in enumerate(seats):
        if seat == 1:
            max_dist = i if last_person < 0 else max(max_dist, (i - last_person) // 2)
            last_person = i
    return max(max_dist, len(seats) - 1 - last_person)

-----
def max_dist_to_closest(seats):
    # Your code here


************************************
Question ID: 880
def rectangleArea(rectangles):
    mod = 10**9 + 7
    X = sorted(set(x for rect in rectangles for x in rect[::2]))
    Xdict = {x:i for i,x in enumerate(X)}

    events = []
    for x1,y1,x2,y2 in rectangles:
        events.append((Xdict[x1], 1, y1, y2))
        events.append((Xdict[x2], -1, y1, y2))
    events.sort()

    area = 0
    cnt = [0] * len(X)
    active = 0
    for idx, type, y1, y2 in events:
        area = (area + (X[idx+1] - X[idx]) * active % mod) % mod
        cnt[y1] += type
        cnt[y2] -= type
        active = sum(p for j,p in zip(X, cnt) if p)

    return area

-----
def rectangleArea(rectangles):
    # Your code here


************************************
Question ID: 881
from collections import defaultdict

def loudAndRich(richer, quiet):
    n = len(quiet)
    graph = defaultdict(list)
    for r in richer:
        graph[r[1]].append(r[0])

    answer = [-1] * n

    def dfs(x):
        if answer[x] != -1:
            return answer[x]
        answer[x] = x
        for y in graph[x]:
            cand = dfs(y)
            if quiet[cand] < quiet[answer[x]]:
                answer[x] = cand
        return answer[x]

    for i in range(n):
        dfs(i)

    return answer


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 882
def peakIndexInMountainArray(arr):
    low, high = 0, len(arr) - 1
    while low < high:
        mid = low + (high - low) // 2
        if arr[mid] < arr[mid + 1]:
            low = mid + 1
        else:
            high = mid
    return low

-----
def peakIndexInMountainArray(arr):
    # Your code here


************************************
Question ID: 883
def carFleet(target: int, position: List[int], speed: List[int]) -> int:
    cars = sorted(zip(position, speed), reverse=True)
    fleets = 0
    last_arrival = -1

    for pos, sp in cars:
        arrival = (target - pos) / sp
        if arrival > last_arrival:
            fleets += 1
            last_arrival = arrival

    return fleets


-----
def carFleet(target: int, position: List[int], speed: List[int]) -> int:
    # Your code here


************************************
Question ID: 884
def k_similarity(s1, s2):
    k = 0
    a, b = list(s1), list(s2)
    for i in range(len(a)):
        if a[i] != b[i]:
            for j in range(i + 1, len(b)):
                if a[i] == b[j] and a[j] != b[j]:
                    a[i], a[j] = a[j], a[i]
                    k += 1
                    break
    return k

-----
def k_similarity(s1, s2):
    # Your code here


************************************
Question ID: 885
from bisect import bisect_left, insort_left

class ExamRoom:

    def __init__(self, n: int):
        self.students = []
        self.n = n

    def seat(self) -> int:
        if not self.students:
            seat_index = 0
        else:
            distance, seat_index = self.students[0], 0
            
            for i in range(1, len(self.students)):
                d = (self.students[i] - self.students[i - 1]) // 2
                if d > distance:
                    distance = d
                    seat_index = self.students[i - 1] + d
                    
            if self.n - 1 - self.students[-1] > distance:
                seat_index = self.n - 1
                
        insort_left(self.students, seat_index)
        return seat_index

    def leave(self, p: int) -> None:
        index = bisect_left(self.students, p)
        self.students.pop(index)


-----
from bisect import bisect_left, insort_left
    # Your code here


************************************
Question ID: 886
def scoreOfParentheses(s):
    score, depth = 0, 0
    for i in range(len(s)):
        if s[i] == '(':
            depth += 1
        else:
            depth -= 1
            if s[i - 1] == '(':
                score += 1 << depth
    return score

-----
def scoreOfParentheses(s):
    # Your code here


************************************
Question ID: 887
import heapq

def mincost_to_hire_workers(quality, wage, k):
    workers = sorted((w / q, q) for w, q in zip(wage, quality))
    total_quality = 0
    max_heap = []
    result = float("inf")

    for ratio, q in workers:
        heapq.heappush(max_heap, -q)
        total_quality += q

        if len(max_heap) > k:
            total_quality += heapq.heappop(max_heap)

        if len(max_heap) == k:
            result = min(result, total_quality * ratio)

    return result

-----
import heapq
    # Your code here


************************************
Question ID: 888
def mirrorReflection(p, q):
    from math import gcd
    m = p // gcd(p, q)

    if m % 2 == 0:
        return 2
    if (q // gcd(p, q)) % 2 == 0:
        return 0
    return 1

-----
def mirrorReflection(p, q):
    # Your code here


************************************
Question ID: 889
def are_almost_equal(s, goal):
    if s == goal:
        return True
    count = 0
    index1, index2 = -1, -1
    for i in range(len(s)):
        if s[i] != goal[i]:
            count += 1
            if index1 == -1:
                index1 = i
            else:
                index2 = i
            if count > 2:
                return False
    return count == 2 and s[index1] == goal[index2] and s[index2] == goal[index1]

-----
def are_almost_equal(s, goal):
    # Your code here


************************************
Question ID: 890
def lemonadeChange(bills):
    five, ten = 0, 0
    for bill in bills:
        if bill == 5:
            five += 1
        elif bill == 10:
            if not five:
                return False
            five -= 1
            ten += 1
        else:
            if ten and five:
                ten -= 1
                five -= 1
            elif five >= 3:
                five -= 3
            else:
                return False
    return True

-----
def lemonadeChange(bills):
    # Your code here


************************************
Question ID: 891
def matrixScore(grid):
    m, n = len(grid), len(grid[0])
    for i in range(m):
        if grid[i][0] == 0:
            for j in range(n):
                grid[i][j] = 1 - grid[i][j]
    for j in range(1, n):
        count = sum(grid[i][j] for i in range(m))
        if count <= m // 2:
            for i in range(m):
                grid[i][j] = 1 - grid[i][j]
    return sum(sum(grid[i][j]*(1 << (n - 1 - j)) for j in range(n)) for i in range(m))

-----
def matrixScore(grid):
    # Your code here


************************************
Question ID: 892
from collections import deque

def shortest_subarray(nums, k):
    n = len(nums)
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]

    res = n + 1
    dq = deque()
    for i in range(n + 1):
        while dq and prefix_sum[i] - prefix_sum[dq[0]] >= k:
            res = min(res, i - dq.popleft())
        while dq and prefix_sum[i] <= prefix_sum[dq[-1]]:
            dq.pop()
        dq.append(i)

    return res if res <= n else -1

-----
from collections import deque
    # Your code here


************************************
Question ID: 893
from collections import defaultdict

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def find_nodes_at_distance_k(root, target_val, k):
    if k < 0:
        return []

    parent_map = defaultdict(lambda: None)
    visited = set()
    target_node = initialize_parent_map(root, None, target_val, parent_map)

    result = []
    find_nodes_at_distance_k_helper(target_node, k, visited, parent_map, result)
    return result

def initialize_parent_map(node, parent, target_val, parent_map):
    if not node:
        return None
    if node.val == target_val:
        return node

    parent_map[node] = parent
    left = initialize_parent_map(node.left, node, target_val, parent_map)
    right = initialize_parent_map(node.right, node, target_val, parent_map)
    return left if left else right

def find_nodes_at_distance_k_helper(node, k, visited, parent_map, result):
    if not node or node in visited:
        return

    visited.add(node)
    if k == 0:
        result.append(node.val)
        return

    find_nodes_at_distance_k_helper(node.left, k-1, visited, parent_map, result)
    find_nodes_at_distance_k_helper(node.right, k-1, visited, parent_map, result)
    find_nodes_at_distance_k_helper(parent_map[node], k-1, visited, parent_map, result)


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 894
import random

class Solution:

    def __init__(self, n: int, blacklist: List[int]):
        self.blacklist_map = {}
        self.reduced_n = n - len(blacklist)

        for b in blacklist:
            if b < n:
                self.blacklist_map[b] = -1

        for b in blacklist:
            if b >= self.reduced_n:
                continue
            while n - 1 in self.blacklist_map:
                n -= 1
            self.blacklist_map[b] = n - 1
            n -= 1

    def pick(self) -> int:
        random_int = random.randint(0, self.reduced_n - 1)
        return self.blacklist_map.get(random_int, random_int)

-----
import random
    # Your code here


************************************
Question ID: 895
from collections import deque

def shortestPathAllKeys(grid):
    m, n, steps, k, x, y, mask = len(grid), len(grid[0]), 0, 0, -1, -1, 0

    for i in range(m):
        for j in range(n):
            if grid[i][j] == '@':
                x, y = i, j
            elif 'a' <= grid[i][j] <= 'f':
                k = max(k, ord(grid[i][j]) - ord('a') + 1)

    q = deque([(x, y, 0)])
    visited = {(x, y, mask)}

    dirs = [(-1, 0), (1, 0), (0, 1), (0, -1)]

    while q:
        qs = len(q)
        for sz in range(qs):
            x, y, mask = q.popleft()

            if mask == (1 << k) - 1:
                return steps

            for dx, dy in dirs:
                nx, ny, nmask = x + dx, y + dy, mask

                if 0 <= nx < m and 0 <= ny < n:
                    c = grid[nx][ny]
                    if 'A' <= c <= 'F' and not nmask & (1 << (ord(c) - ord('A'))):
                        continue
                    if 'a' <= c <= 'f':
                        nmask |= (1 << (ord(c) - ord('a')))

                    if (nx, ny, nmask) in visited:
                        continue

                    visited.add((nx, ny, nmask))
                    q.append((nx, ny, nmask))

        steps += 1

    return -1


-----
from collections import deque
    # Your code here


************************************
Question ID: 897
def is_prime(n):
    if n <= 1:
        return False
    i = 2
    while i * i <= n:
        if n % i == 0:
            return False
        i += 1
    return True

def is_palindrome(n):
    return str(n) == str(n)[::-1]

def prime_palindrome(n):
    while True:
        if is_prime(n) and is_palindrome(n):
            return n
        n += 1

-----
def is_prime(n):
    # Your code here


************************************
Question ID: 898
def transpose(matrix):
    rows = len(matrix)
    cols = len(matrix[0])
    result = [[0] * rows for _ in range(cols)]
    for i in range(rows):
        for j in range(cols):
            result[j][i] = matrix[i][j]
    return result

-----
def transpose(matrix):
    # Your code here


************************************
Question ID: 899
def longest_distance(n):
    last = -1
    longest = 0
    i = 0
    while n:
        if n & 1:
            if last >= 0:
                longest = max(longest, i - last)
            last = i
        n >>= 1
        i += 1
    return longest

-----
def longest_distance(n):
    # Your code here


************************************
Question ID: 900
from itertools import permutations as perm

def reorderedPowerOf2(n):
    for p in set(perm(str(n))):
        if p[0] != '0' and (bin(int(''.join(p))).count('1') == 1):
            return True
    return False


-----
from itertools import permutations as perm
    # Your code here


************************************
Question ID: 901
from collections import defaultdict
from sortedcontainers import SortedList

def advantageCount(nums1, nums2):
    d = defaultdict(int)
    sorted_nums1 = SortedList(nums1)
    res = []
    
    for num in nums2:
        i = sorted_nums1.bisect_right(num)
        if i == len(sorted_nums1):
            i = 0
        res.append(sorted_nums1.pop(i))
    return res

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 902
import heapq

def minRefuelStops(target: int, startFuel: int, stations: List[List[int]]) -> int:
    i, stops, curFuel = 0, 0, startFuel
    pq = []
    while curFuel < target:
        while i < len(stations) and stations[i][0] <= curFuel:
            heapq.heappush(pq, -stations[i][1])
            i += 1
        if not pq: return -1
        curFuel += -heapq.heappop(pq)
        stops += 1
    return stops


-----
import heapq
    # Your code here


************************************
Question ID: 903
def rand7(): # Given API
    pass

def rand10():
    result = 41
    while result > 40:
        result = (rand7() - 1) * 7 + rand7()
    return result % 10 + 1

-----
def rand7(): # Given API
    # Your code here


************************************
Question ID: 904
def leafSimilar(root1, root2):
    def getLeaves(node):
        if not node:
            return []
        if not node.left and not node.right:
            return [node.val]
        return getLeaves(node.left) + getLeaves(node.right)

    return getLeaves(root1) == getLeaves(root2)

-----
def leafSimilar(root1, root2):
    # Your code here


************************************
Question ID: 905
def lenLongestFibSubseq(arr):
    index = {x: i for i, x in enumerate(arr)}

    longest = dict()
    ans = 0

    for k, z in enumerate(arr):
        for j, y in enumerate(arr[:k]):
            i = index.get(z - y, None)
            if i is not None and i < j:
                longest[j, k] = longest.get((i, j), 1) + 1
                ans = max(ans, longest[j, k] + 1)

    return ans if ans >= 3 else 0

-----
def lenLongestFibSubseq(arr):
    # Your code here


************************************
Question ID: 907
def minEatingSpeed(piles, h):
    left, right = 1, max(piles)
    while left < right:
        mid = left + (right - left) // 2
        totalHours = sum((pile + mid - 1) // mid for pile in piles)
        if totalHours > h:
            left = mid + 1
        else:
            right = mid
    return left

-----
def minEatingSpeed(piles, h):
    # Your code here


************************************
Question ID: 909
def aliceWins(piles):
    n = len(piles)
    dp = [[0] * n for _ in range(n)]
    for gap in range(n):
        for i in range(n - gap):
            j = i + gap
            x = dp[i + 2][j] if i + 2 <= j else 0
            y = dp[i + 1][j - 1] if i + 1 <= j - 1 else 0
            z = dp[i][j - 2] if i <= j - 2 else 0
            dp[i][j] = max(piles[i] + min(x, y), piles[j] + min(y, z))
    sum_of_piles = sum(piles)
    return dp[0][n - 1] > (sum_of_piles - dp[0][n - 1])

-----
def aliceWins(piles):
    # Your code here


************************************
Question ID: 910
def nthMagicalNumber(n, a, b):
    mod = 1000000007
    lcm = a * b // gcd(a, b)
    left, right = 1, 10**14
    while left < right:
        mid = left + (right - left) // 2
        if (mid // a + mid // b - mid // lcm) < n:
            left = mid + 1
        else:
            right = mid
    return left % mod

def gcd(a, b):
    return a if b == 0 else gcd(b, a % b)

-----
def nthMagicalNumber(n, a, b):
    # Your code here


************************************
Question ID: 911
def profitableSchemes(n, minProfit, group, profit):
    dp = [[0] * (minProfit + 1) for _ in range(n + 1)]
    mod = 10**9 + 7
    dp[0][0] = 1
    for i in range(len(group)):
        for j in range(n, group[i] - 1, -1):
            for k in range(minProfit, -1, -1):
                dp[j][k] = (dp[j][k] + dp[j - group[i]][max(0, k - profit[i])]) % mod
    return sum(dp[i][minProfit] for i in range(1, n + 1)) % mod

-----
def profitableSchemes(n, minProfit, group, profit):
    # Your code here


************************************
Question ID: 912
import random
from bisect import bisect_left

class Solution:

    def __init__(self, w: List[int]):
        self.prefix_sum = []
        for weight in w:
            previous = self.prefix_sum[-1] if self.prefix_sum else 0
            self.prefix_sum.append(previous + weight)

    def pickIndex(self) -> int:
        num = random.random() * self.prefix_sum[-1]
        return bisect_left(self.prefix_sum, num)

-----
import random
    # Your code here


************************************
Question ID: 913
import random

class Solution:
    def __init__(self, m, n):
        self.grid = [[0] * n for _ in range(m)]
        self.zero_count = m * n

    def pick(self):
        index = random.randrange(self.zero_count)

        for i, row in enumerate(self.grid):
            for j, cell in enumerate(row):
                if cell == 0:
                    if index == 0:
                        self.grid[i][j] = 1
                        self.zero_count -= 1
                        return (i, j)
                    index -= 1
        return (-1, -1)  # Should not happen

-----
import random
    # Your code here


************************************
Question ID: 914
import random
from bisect import bisect_left

class Solution:
    def __init__(self, rects):
        self.rects = rects
        self.areas = []
        self.total_area = 0
        for rect in rects:
            area = (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1)
            self.total_area += area
            self.areas.append(self.total_area)

    def pick(self):
        random_area = random.randint(0, self.total_area - 1)
        rect_index = bisect_left(self.areas, random_area + 1)

        x = random.randint(self.rects[rect_index][0], self.rects[rect_index][2])
        y = random.randint(self.rects[rect_index][1], self.rects[rect_index][3])

        return [x, y]


-----
import random
    # Your code here


************************************
Question ID: 915
import random
import math

class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.radius = radius
        self.x_center = x_center
        self.y_center = y_center

    def randPoint(self):
        angle = random.random() * 2 * math.pi
        r = math.sqrt(random.random()) * self.radius
        return [self.x_center + r * math.cos(angle), self.y_center + r * math.sin(angle)]

-----
import random
    # Your code here


************************************
Question ID: 916
def find_kth_character(s: str, k: int) -> str:
    n = len(s)
    size = 0

    for c in s:
        if c.isdigit():
            size = size * int(c)
        else:
            size += 1

    for i in range(n - 1, -1, -1):
        c = s[i]
        k %= size
        if k == 0 and not c.isdigit():
            return c

        if c.isdigit():
            size //= int(c)
        else:
            size -= 1

    return '-'

-----
def find_kth_character(s: str, k: int) -> str:
    # Your code here


************************************
Question ID: 917
def num_rescue_boats(people, limit):
    people.sort()
    left, right = 0, len(people) - 1
    boats = 0
    while left <= right:
        if people[left] + people[right] <= limit:
            left += 1
        right -= 1
        boats += 1
    return boats

-----
def num_rescue_boats(people, limit):
    # Your code here


************************************
Question ID: 918
from heapq import heappush, heappop

def reachableNodes(edges, maxMoves, n):
    graph = [[] for _ in range(n)]
    for u, v, cnt in edges:
        graph[u].append((v, cnt + 1))
        graph[v].append((u, cnt + 1))

    visited = set()
    pq = [(-maxMoves, 0)]

    while pq:
        moves_left, node = heappop(pq)

        if node in visited:
            continue
        visited.add(node)

        for next_node, moves_needed in graph[node]:
            moves_left_after = moves_left - moves_needed
            if next_node not in visited and moves_left_after > 0:
                heappush(pq, (moves_left_after, next_node))

    return len(visited)


-----
from heapq import heappush, heappop
    # Your code here


************************************
Question ID: 919
def projectionArea(grid):
    n = len(grid)
    top, front, side = 0, 0, 0
    for i in range(n):
        max_front, max_side = 0, 0
        for j in range(n):
            if grid[i][j] > 0:
                top += 1
            max_front = max(max_front, grid[i][j])
            max_side = max(max_side, grid[j][i])
        front += max_front
        side += max_side
    return top + front + side

-----
def projectionArea(grid):
    # Your code here


************************************
Question ID: 920
def uncommon_from_sentences(s1, s2):
    word_count = {}
    for word in (s1 + " " + s2).split():
        word_count[word] = word_count.get(word, 0) + 1

    return [key for key, val in word_count.items() if val == 1]

-----
def uncommon_from_sentences(s1, s2):
    # Your code here


************************************
Question ID: 921
def spiral_walk(rows, cols, rStart, cStart):
    result = []
    dr = [0, 1, 0, -1]
    dc = [1, 0, -1, 0]
    moves = rows * cols
    r, c, dir = rStart, cStart, 0
    
    while len(result) < moves:
        result.append([r, c])
        r += dr[dir]
        c += dc[dir]
        
        if r < 0 or r >= rows or c < 0 or c >= cols:
            r -= dr[dir]
            c -= dc[dir]
            dir = (dir + 1) % 4
            r += dr[dir]
            c += dc[dir]

    return result

-----
def spiral_walk(rows, cols, rStart, cStart):
    # Your code here


************************************
Question ID: 922
from collections import defaultdict


def possible_bipartition(n, dislikes):
    def dfs(person, group):
        if person in groups:
            return groups[person] == group
        groups[person] = group
        for other in dislike_list[person]:
            if not dfs(other, -group):
                return False
        return True

    groups = {}
    dislike_list = defaultdict(list)
    for p1, p2 in dislikes:
        dislike_list[p1].append(p2)
        dislike_list[p2].append(p1)

    for person in range(1, n + 1):
        if person not in groups and not dfs(person, 1):
            return False

    return True


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 923
def min_moves(k, n):
    if k == 1 or n == 0 or n == 1:
        return n
    
    res = float('inf')
    for i in range(1, n + 1):
        temp = max(min_moves(k - 1, i - 1), min_moves(k, n - i))
        res = min(res, temp)
    
    return res + 1

-----
def min_moves(k, n):
    # Your code here


************************************
Question ID: 924
def fair_candy_swap(aliceSizes, bobSizes):
    aliceTotal, bobTotal = sum(aliceSizes), sum(bobSizes)
    delta = (bobTotal - aliceTotal) // 2
    for a in aliceSizes:
        for b in bobSizes:
            if a + delta == b:
                return [a, b]
    return []

-----
def fair_candy_swap(aliceSizes, bobSizes):
    # Your code here


************************************
Question ID: 926
def find_and_replace_patterns(words, pattern):
    result = []
    for word in words:
        if len(word) != len(pattern): continue

        w2p = {}
        p2w = {}
        matches = True
        for cWord, cPattern in zip(word, pattern):
            if cWord not in w2p: w2p[cWord] = cPattern
            if cPattern not in p2w: p2w[cPattern] = cWord

            if w2p[cWord] != cPattern or p2w[cPattern] != cWord:
                matches = False
                break

        if matches: result.append(word)
    return result


-----
def find_and_replace_patterns(words, pattern):
    # Your code here


************************************
Question ID: 927
def sum_of_widths(nums):
    MOD = 10**9 + 7
    nums.sort()
    c, res = 1, 0
    n = len(nums)

    for i in range(n):
        res = (res + (nums[i] - nums[n - i - 1]) * c) % MOD
        c = c * 2 % MOD

    return res

-----
def sum_of_widths(nums):
    # Your code here


************************************
Question ID: 928
def surfaceArea(grid):
    n = len(grid)
    area = 0

    for i in range(n):
        for j in range(n):
            if grid[i][j]:
                area += 4 * grid[i][j] + 2
                if i > 0:
                    area -= 2 * min(grid[i][j], grid[i - 1][j])
                if j > 0:
                    area -= 2 * min(grid[i][j], grid[i][j - 1])

    return area

-----
def surfaceArea(grid):
    # Your code here


************************************
Question ID: 929
def num_special_equivalent_groups(words):
    groups = set()

    for word in words:
        evens = "".join(sorted(word[0::2]))
        odds = "".join(sorted(word[1::2]))

        groups.add(evens + odds)

    return len(groups)


-----
def num_special_equivalent_groups(words):
    # Your code here


************************************
Question ID: 931
from collections import defaultdict, deque

class FreqStack:
    def __init__(self):
        self.freq = defaultdict(int)
        self.group = defaultdict(list)

    def push(self, x: int):
        freq = self.freq[x] = self.freq[x] + 1
        self.group[freq].append(x)

    def pop(self) -> int:
        max_freq = max(self.group)
        x = self.group[max_freq].pop()
        self.freq[x] -= 1
        if not self.group[max_freq]:
            del self.group[max_freq]
        return x


-----
from collections import defaultdict, deque
    # Your code here


************************************
Question ID: 932
def isMonotonic(nums):
    increasing = decreasing = True
    for i in range(1, len(nums)):
        if nums[i] > nums[i - 1]: decreasing = False
        if nums[i] < nums[i - 1]: increasing = False
    return increasing or decreasing

-----
def isMonotonic(nums):
    # Your code here


************************************
Question ID: 934
def subarrayBitwiseORs(arr: List[int]) -> int:
    result, current, temp = set(), set(), set()
    for num in arr:
        temp = {num}
        for c in current:
            temp.add(num | c)
        current = temp
        result |= current
    return len(result)

-----
def subarrayBitwiseORs(arr: List[int]) -> int:
    # Your code here


************************************
Question ID: 935
def lex_smallest_string(s, k):
    res = s
    for i in range(k):
        tmp = s[i:] + s[:i]
        if tmp < res:
            res = tmp
    return res

-----
def lex_smallest_string(s, k):
    # Your code here


************************************
Question ID: 938
from bisect import bisect_right

def num_digits_less_than_n(digits: List[int], n: int) -> int:
    ans = 0
    factor = 1
    n_str = str(n)
    for i in range(len(n_str) - 1, -1, -1):
        ans += bisect_right(digits, int(n_str[i])) * factor
        factor *= len(digits)
    return ans

-----
from bisect import bisect_right
    # Your code here


************************************
Question ID: 939
def find_valid_permutations(s: str) -> int:
    n = len(s)
    MOD = 1000000007
    dp = [0] * (n + 2)
    dp[0] = 1

    for c in s:
        new_dp = [0] * (n + 2)
        if c == 'I':
            for i in range(n):
                new_dp[i + 1] = (new_dp[i + 1] + dp[i]) % MOD
        else:
            for i in range(n - 1, -1, -1):
                new_dp[i] = (new_dp[i + 1] + dp[i + 1]) % MOD
        dp = new_dp

    return dp[0]

-----
def find_valid_permutations(s: str) -> int:
    # Your code here


************************************
Question ID: 940
def totalFruit(fruits):
    left, right, max_count = 0, 0, 0
    count = {}

    while right < len(fruits):
        count[fruits[right]] = count.get(fruits[right], 0) + 1
        while len(count) > 2:
            count[fruits[left]] -= 1
            if count[fruits[left]] == 0:
                del count[fruits[left]]
            left += 1
        max_count = max(max_count, right - left + 1)
        right += 1

    return max_count

-----
def totalFruit(fruits):
    # Your code here


************************************
Question ID: 941
def move_even_odd(nums):
    even_index = 0
    odd_index = len(nums) - 1

    while even_index < odd_index:
        if nums[even_index] % 2 == 0:
            even_index += 1
        else:
            nums[even_index], nums[odd_index] = nums[odd_index], nums[even_index]
            odd_index -= 1

    return nums

-----
def move_even_odd(nums):
    # Your code here


************************************
Question ID: 942
def isPalindrome(num):
    return str(num) == str(num)[::-1]

def superpalindromesInRange(left: str, right: str) -> int:
    l = int(left)
    r = int(right)
    cnt = 0
    base = 1
    while base * base <= r:
        if isPalindrome(base) and isPalindrome(base * base):
            if base * base >= l:
                cnt += 1
        base += 1
    return cnt


-----
def isPalindrome(num):
    # Your code here


************************************
Question ID: 943
def sum_of_mins(arr):
    mod = 10**9 + 7
    n = len(arr)
    left, right = [0] * n, [0] * n
    st = []

    for i in range(n):
        while st and arr[st[-1]] > arr[i]:
            st.pop()
        left[i] = st[-1] if st else -1
        st.append(i)

    st.clear()
    for i in range(n - 1, -1, -1):
        while st and arr[st[-1]] > arr[i]:
            st.pop()
        right[i] = st[-1] if st else n
        st.append(i)

    ans = 0
    for i in range(n):
        ans = (ans + arr[i] * (i - left[i]) * (right[i] - i)) % mod
    return ans

-----
def sum_of_mins(arr):
    # Your code here


************************************
Question ID: 944
def minDifference(nums, k):
    if len(nums) <= 1: return 0
    nums.sort()
    min_diff = nums[-1] - nums[0]
    for i in range(1, len(nums)):
        high = max(nums[i-1] + k, nums[-1] - k)
        low = min(nums[i] - k, nums[0] + k)
        min_diff = min(min_diff, high - low)
    return min_diff

-----
def minDifference(nums, k):
    # Your code here


************************************
Question ID: 945
def snakesAndLadders(board):
    n = len(board)
    visited = [False] * (n*n + 1)
    queue = [(1, 0)]  # starting at position 1
    visited[1] = True

    def get_position(pos):
        r = (pos - 1) // n
        c = (pos - 1) % n
        if r % 2 == 1:
            c = n - 1 - c
        r = n - r - 1
        return r, c

    while queue:
        pos, steps = queue.pop(0)
        for jump in range(1, 7):
            next_pos = pos + jump
            if next_pos > n*n:
                break
            r, c = get_position(next_pos)
            if board[r][c] != -1:
                next_pos = board[r][c]
            if next_pos == n*n:
                return steps + 1
            if not visited[next_pos]:
                visited[next_pos] = True
                queue.append((next_pos, steps + 1))

    return -1


-----
def snakesAndLadders(board):
    # Your code here


************************************
Question ID: 946
def minimum_score(nums, k):
    nums.sort()
    n = len(nums)
    res = nums[n - 1] - nums[0]

    for i in range(n - 1):
        high = max(nums[i] + k, nums[n - 1] - k)
        low = min(nums[i + 1] - k, nums[0] + k)
        res = min(res, high - low)

    return res

-----
def minimum_score(nums, k):
    # Your code here


************************************
Question ID: 947
from collections import defaultdict
from bisect import bisect

class TopVotedCandidate:

    def __init__(self, persons, times):
        self.leader_map = {}
        self.times = times
        votes = defaultdict(int)
        leader = -1
        for i, t in enumerate(times):
            votes[persons[i]] += 1
            if votes[persons[i]] >= votes[leader]:
                leader = persons[i]
            self.leader_map[t] = leader

    def q(self, t):
        idx = bisect.bisect(self.times, t)
        return self.times[idx - 1]

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 948
def sortArray(nums):
    nums.sort()

-----
def sortArray(nums):
    # Your code here


************************************
Question ID: 949
from collections import deque

def catMouseGame(graph):
    n = len(graph)
    status = [[[0]*3 for _ in range(n)] for _ in range(n)]

    for i in range(1, n):
        status[i][i][1] = 2
        status[i][i][2] = 2
    queue = deque([(i, i, t, 2) for i in range(1, n) for t in (1, 2)])

    while queue:
        pos_m, pos_c, t_type, t_result = queue.popleft()

        for prev in graph[pos_m if t_type == 1 else pos_c]:
            if (t_type == 2 and prev == 0) or (t_result == 2 and status[prev][pos_c][3 - t_type]):
                continue
            if status[prev][pos_c][3 - t_type]:
                continue
            queue.append((pos_c, prev, 3 - t_type, 3 - t_result))
            status[prev][pos_c][3 - t_type] = 3 - t_result

    return status[1][2][1]


-----
from collections import deque
    # Your code here


************************************
Question ID: 950
from collections import Counter
from math import gcd
from functools import reduce

def hasGroupsSizeX(deck):
    counts = Counter(deck)
    gcd_result = reduce(gcd, counts.values())
    return gcd_result > 1

-----
from collections import Counter
    # Your code here


************************************
Question ID: 951
def partitionDisjoint(nums):
    left_max, global_max, left_length = nums[0], nums[0], 1
    for i in range(1, len(nums)):
        if nums[i] < left_max:
            left_max = global_max
            left_length = i + 1
        else:
            global_max = max(global_max, nums[i])
    return left_length

-----
def partitionDisjoint(nums):
    # Your code here


************************************
Question ID: 952
from collections import Counter

def word_subsets(words1, words2):
    max_chars = Counter()
    for word in words2:
        chars = Counter(word)
        for c, count in chars.items():
            max_chars[c] = max(max_chars[c], count)
    
    result = []
    for word in words1:
        word_chars = Counter(word)
        universal = all(word_chars[c] >= max_chars[c] for c in max_chars)
        if universal:
            result.append(word)
    
    return result


-----
from collections import Counter
    # Your code here


************************************
Question ID: 953
def reverse_string(s):
    return s[::-1]


-----
def reverse_string(s):
    # Your code here


************************************
Question ID: 954
def canReorderDoubled(arr):
    count = collections.Counter(arr)
    
    for a in sorted(count, key=abs):
        if count[a] > 0:
            target = a * 2
            if count[target] < count[a]:
                return False
            count[target] -= count[a]

    return True

-----
def canReorderDoubled(arr):
    # Your code here


************************************
Question ID: 955
from collections import deque

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class CBTInserter:
    def __init__(self, root: TreeNode):
        self.root = root
        self.q = deque([root])
        while True:
            node = self.q[0]
            if not node.left or not node.right:
                break
            self.q.append(node.left)
            self.q.append(node.right)
            self.q.popleft()

    def insert(self, v: int) -> int:
        newNode = TreeNode(v)
        parentNode = self.q[0]
        if not parentNode.left:
            parentNode.left = newNode
        else:
            parentNode.right = newNode
            self.q.append(parentNode.left)
            self.q.append(parentNode.right)
            self.q.popleft()
        return parentNode.val

    def get_root(self) -> TreeNode:
        return self.root


-----
from collections import deque
    # Your code here


************************************
Question ID: 956
def numMusicPlaylists(n, goal, k):
    MOD = 1000000007
    dp = [[0] * (n + 1) for _ in range(goal + 1)]
    dp[0][0] = 1
    for i in range(1, goal + 1):
        for j in range(1, n + 1):
            dp[i][j] = (dp[i - 1][j - 1] * (n - (j - 1)) % MOD + dp[i - 1][j] * max(0, j - k) % MOD) % MOD
    return dp[goal][n]

-----
def numMusicPlaylists(n, goal, k):
    # Your code here


************************************
Question ID: 957
def minAddToMakeValid(s: str) -> int:
    result = balance = 0
    for c in s:
        balance += 1 if c == '(' else -1
        if balance == -1:
            result += 1
            balance += 1
    return result + balance

-----
def minAddToMakeValid(s: str) -> int:
    # Your code here


************************************
Question ID: 958
def sortArrayByParityII(nums):
    j = 1
    for i in range(0, len(nums), 2):
        if nums[i] % 2:
            while nums[j] % 2:
                j += 2
            nums[i], nums[j] = nums[j], nums[i]
    return nums

-----
def sortArrayByParityII(nums):
    # Your code here


************************************
Question ID: 959
def threeSumMulti(arr, target):
    MOD = 1000000007
    ans = 0

    arr.sort()
    n = len(arr)

    for i in range(n - 2):
        j, k = i + 1, n - 1
        while j < k:
            s = arr[i] + arr[j] + arr[k]
            if s > target:
                k -= 1
            elif s < target:
                j += 1
            else:
                if arr[j] != arr[k]:
                    left_count = right_count = 1

                    while j < n - 1 and arr[j] == arr[j + 1]:
                        left_count += 1
                        j += 1

                    while k > 0 and arr[k] == arr[k - 1]:
                        right_count += 1
                        k -= 1

                    ans += left_count * right_count
                    ans %= MOD
                    j += 1
                    k -= 1
                else:
                    ans += (k - j + 1) * (k - j) // 2
                    ans %= MOD
                    break

    return ans

-----
def threeSumMulti(arr, target):
    # Your code here


************************************
Question ID: 960
from collections import deque

def minMalwareSpread(graph, initial):
    n = len(graph)
    initial.sort()
    
    malware = set(initial)
    
    minNode = initial[0]
    minSpread = n + 1

    for node in initial:
        q = deque(otherNode for otherNode in initial if node != otherNode)
        visited = [node != otherNode and otherNode in malware for otherNode in range(n)]
        
        while q:
            cur = q.popleft()
            for next, isConnected in enumerate(graph[cur]):
                if isConnected and not visited[next] and next not in malware:
                    visited[next] = True
                    q.append(next)
        
        spread = sum(visited)
        
        if spread < minSpread:
            minNode = node
            minSpread = spread
    
    return minNode


-----
from collections import deque
    # Your code here


************************************
Question ID: 961
def isLongPressedName(name: str, typed: str) -> bool:
    i, j = 0, 0
    while j < len(typed):
        if i < len(name) and name[i] == typed[j]:
            i += 1
        elif j == 0 or typed[j] != typed[j - 1]:
            return False
        j += 1
    return i == len(name)

-----
def isLongPressedName(name: str, typed: str) -> bool:
    # Your code here


************************************
Question ID: 962
def minFlipsMonoIncr(s: str) -> int:
    flipCount, oneCount = 0, 0
    for c in s:
        if c == '1':
            oneCount += 1
        else:
            flipCount = min(flipCount + 1, oneCount)
    return flipCount

-----
def minFlipsMonoIncr(s: str) -> int:
    # Your code here


************************************
Question ID: 963
def find_same_binary_value_parts(arr):
    ones = sum(arr)

    if ones % 3 != 0:
        return [-1, -1]

    target = ones // 3
    if target == 0:
        return [0, len(arr) - 2]

    count = 0
    i = j = -1
    ones = 0
    for idx, n in enumerate(arr):
        if n == 1:
            ones += 1
            if ones == target + 1:
                count += 1
            if count == 1 and i == -1:
                i = idx
            if count == 2 and j == -1:
                j = idx
            if count == 3:
                break

    return [i, j]

-----
def find_same_binary_value_parts(arr):
    # Your code here


************************************
Question ID: 964
from collections import deque
from typing import List

def minMalwareSpread(graph: List[List[int]], initial: List[int]) -> int:
    n = len(graph)
    color = [-1] * n
    colors = 0

    for i in range(n):
        if color[i] == -1:
            q = deque([i])
            color[i] = colors

            while q:
                t = q.popleft()
                for j in range(n):
                    if graph[t][j] == 1 and color[j] == -1:
                        q.append(j)
                        color[j] = colors

            colors += 1

    area = [0] * colors
    count = [0] * colors
    initially_infected = set(initial)
    for i in range(n):
        area[color[i]] += 1
        if i in initially_infected:
            count[color[i]] += 1

    res = min(initial)
    min_size = n + 1
    for i in initial:
        if count[color[i]] == 1:
            if area[color[i]] < min_size:
                min_size = area[color[i]]
                res = i
            elif area[color[i]] == min_size and i < res:
                res = i

    return res

-----
from collections import deque
    # Your code here


************************************
Question ID: 965
def num_unique_emails(emails):
    unique_emails = set()

    for email in emails:
        local_name, domain_name = email.split("@")
        local_name = local_name.split("+")[0]
        local_name = local_name.replace(".", "")

        unique_emails.add(local_name + "@" + domain_name)

    return len(unique_emails)

-----
def num_unique_emails(emails):
    # Your code here


************************************
Question ID: 966
def num_subarrays_with_sum(nums, goal):
    from collections import defaultdict
    prefix_sum_count = defaultdict(int)
    prefix_sum_count[0] = 1
    cumulative_sum, result = 0, 0
    
    for num in nums:
        cumulative_sum += num
        result += prefix_sum_count[cumulative_sum - goal]
        prefix_sum_count[cumulative_sum] += 1
    
    return result

-----
def num_subarrays_with_sum(nums, goal):
    # Your code here


************************************
Question ID: 967
def minFallingPathSum(matrix):
    n = len(matrix)
    for i in range(1, n):
        for j in range(n):
            min_val = matrix[i - 1][j]
            if j > 0: min_val = min(min_val, matrix[i - 1][j - 1])
            if j < n - 1: min_val = min(min_val, matrix[i - 1][j + 1])
            matrix[i][j] += min_val
    return min(matrix[-1])

-----
def minFallingPathSum(matrix):
    # Your code here


************************************
Question ID: 968
def beautifulArray(n: int) -> List[int]:
    result = [1]
    while len(result) < n:
        temp = []
        for i in result:
            if i * 2 - 1 <= n:
                temp.append(i * 2 - 1)
        for i in result:
            if i * 2 <= n:
                temp.append(i * 2)
        result = temp
    return result

-----
def beautifulArray(n: int) -> List[int]:
    # Your code here


************************************
Question ID: 969
from collections import deque

class RecentCounter:
    def __init__(self):
        self.requests = deque()

    def ping(self, t: int) -> int:
        self.requests.append(t)
        while self.requests[0] < t - 3000:
            self.requests.popleft()
        return len(self.requests)

-----
from collections import deque
    # Your code here


************************************
Question ID: 970
def powerfulIntegers(x, y, bound):
    max_i = 0 if x == 1 else int(math.log(bound, x))
    max_j = 0 if y == 1 else int(math.log(bound, y))
    result_set = set()
    
    for i in range(max_i + 1):
        for j in range(max_j + 1):
            powerful_num = x ** i + y ** j
            if powerful_num <= bound:
                result_set.add(powerful_num)
                
    return list(result_set)

-----
def powerfulIntegers(x, y, bound):
    # Your code here


************************************
Question ID: 971
from collections import deque

def shortestBridge(grid):
    n = len(grid)
    q = deque()

    # Find the first island and mark it
    for i in range(n):
        if any(grid[i]):
            first_row = i
            first_col = grid[first_row].index(1)
            break

    dfs(grid, q, first_row, first_col)

    steps = 0
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    
    while q:
        for _ in range(len(q)):
            x, y = q.popleft()
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < n:
                    if grid[nx][ny] == 1:
                        return steps
                    elif grid[nx][ny] == 0:
                        grid[nx][ny] = -1
                        q.append((nx, ny))
        steps += 1
    return -1

def dfs(grid, q, i, j):
    n = len(grid)
    if not (0 <= i < n and 0 <= j < n and grid[i][j] == 1):
        return
    grid[i][j] = -1
    q.append((i, j))
    
    dfs(grid, q, i - 1, j)
    dfs(grid, q, i + 1, j)
    dfs(grid, q, i, j - 1)
    dfs(grid, q, i, j + 1)


-----
from collections import deque
    # Your code here


************************************
Question ID: 972
def knightDialer(n: int) -> int:
    if n == 1:
        return 10
    MOD = 10**9 + 7
    moves = [
        [4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9],
        [], [1, 7, 0], [2, 6], [1, 3], [2, 4]
    ]
    dp = [1] * 10
    for _ in range(2, n + 1):
        new_dp = [0] * 10
        for j in range(10):
            for move in moves[j]:
                new_dp[j] = (new_dp[j] + dp[move]) % MOD
        dp = new_dp
    return sum(dp) % MOD

-----
def knightDialer(n: int) -> int:
    # Your code here


************************************
Question ID: 973
def moves_to_stamp(stamp: str, target: str) -> list:
    result = []
    is_stamped = [False] * len(target)
    stamp_count = 0
    target = list(target)

    while stamp_count < 10 * len(target):
        found_stamp = False
        for i in range(len(target) - len(stamp) + 1):
            if is_stamped[i]:
                continue
            j = 0
            overlap = 0
            while j < len(stamp) and (target[i + j] == '?' or target[i + j] == stamp[j]):
                if target[i + j] == stamp[j]:
                    overlap += 1
                j += 1
            if j == len(stamp) and overlap > 0:
                for j in range(len(stamp)):
                    target[i + j] = '?'
                result.append(i)
                is_stamped[i] = True
                found_stamp = True
        if not found_stamp:
            break
        
        stamp_count += 1

    for c in target:
        if c != '?':
            return []

    return result[::-1]


-----
def moves_to_stamp(stamp: str, target: str) -> list:
    # Your code here


************************************
Question ID: 974
def subarraysDivByK(nums, k):
    prefix_sums_mod_k = [0] * k
    prefix_sums_mod_k[0] = 1
    running_sum = 0
    count = 0
    
    for num in nums:
        running_sum += num
        mod = (running_sum % k + k) % k
        count += prefix_sums_mod_k[mod]
        prefix_sums_mod_k[mod] += 1
    
    return count

-----
def subarraysDivByK(nums, k):
    # Your code here


************************************
Question ID: 975
def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:
    if not root:
        return 0
    if root.val < low:
        return self.rangeSumBST(root.right, low, high)
    if root.val > high:
        return self.rangeSumBST(root.left, low, high)
    return root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)

-----
def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:
    # Your code here


************************************
Question ID: 976
def min_area_rect(points):
    point_set = {(x, y) for x, y in points}
    min_area = float('inf')

    for p1 in point_set:
        for p2 in point_set:
            if p1[0] != p2[0] and p1[1] != p2[1]:
                if (p1[0], p2[1]) in point_set and (p2[0], p1[1]) in point_set:
                    min_area = min(min_area, abs((p1[0] - p2[0]) * (p1[1] - p2[1])))

    return min_area if min_area != float('inf') else 0


-----
def min_area_rect(points):
    # Your code here


************************************
Question ID: 977
def distinctSubseqII(s):
    mod = 10**9 + 7
    n = len(s)
    dp = [0] * (n + 1)
    dp[0] = 1
    last = [-1] * 26

    for i in range(1, n + 1):
        dp[i] = (dp[i - 1] * 2) % mod
        if last[ord(s[i - 1]) - ord('a')] != -1:
            dp[i] = (dp[i] - dp[last[ord(s[i - 1]) - ord('a')]] + mod) % mod
        last[ord(s[i - 1]) - ord('a')] = i - 1

    dp[n] = (dp[n] - 1 + mod) % mod
    return dp[n]

-----
def distinctSubseqII(s):
    # Your code here


************************************
Question ID: 978
def valid_mountain_array(arr):
    n, i, j = len(arr), 0, len(arr) - 1
    while i + 1 < n and arr[i] < arr[i + 1]:
        i += 1
    while j > 0 and arr[j - 1] > arr[j]:
        j -= 1
    return i > 0 and i == j and j < n - 1

-----
def valid_mountain_array(arr):
    # Your code here


************************************
Question ID: 979
def decode_permutation(s: str):
    n = len(s)
    perm = [0] * (n + 1)
    next_zero, next_one = 0, n

    for c in s:
        if c == '0':
            perm[next_zero] = next_one
            next_zero += 1
            next_one -= 1
        else:
            perm[next_one] = next_zero
            next_one -= 1
            next_zero += 1

    perm[next_zero] = next_one
    return perm


-----
def decode_permutation(s: str):
    # Your code here


************************************
Question ID: 980
from itertools import permutations

def smallestSuperstring(words):
    def get_shared_length(a, b):
        for shared_length in range(min(len(a), len(b)), 0, -1):
            if a[-shared_length:] == b[:shared_length]:
                return shared_length
        return 0

    def merge(a, b, shared_length):
        return a + b[shared_length:]

    def get_total_length(merged_words):
        return sum(len(word) for word in merged_words)

    best = None
    for perm in permutations(words):
        merged_words = list(perm)
        for i in range(len(words) - 1):
            shared_length = get_shared_length(merged_words[i], merged_words[i + 1])
            merged_words[i + 1] = merge(merged_words[i], merged_words[i + 1], shared_length)
        if best is None or get_total_length(merged_words) < len(best):
            best = "".join(merged_words)

    return best

-----
from itertools import permutations
    # Your code here


************************************
Question ID: 981
def min_deletion_size(strs):
    num_deleted = 0
    for col in range(len(strs[0])):
        for row in range(1, len(strs)):
            if strs[row][col] < strs[row - 1][col]:
                num_deleted += 1
                break
    return num_deleted


-----
def min_deletion_size(strs):
    # Your code here


************************************
Question ID: 982
def min_moves_unique(nums):
    nums.sort()
    moves = 0
    for i in range(1, len(nums)):
        if nums[i] <= nums[i - 1]:
            diff = nums[i - 1] - nums[i] + 1
            moves += diff
            nums[i] += diff
    return moves

-----
def min_moves_unique(nums):
    # Your code here


************************************
Question ID: 983
def validateStackSequences(pushed, popped):
    stack = []
    popIndex = 0
    
    for pushValue in pushed:
        stack.append(pushValue)
        while stack and stack[-1] == popped[popIndex]:
            stack.pop()
            popIndex += 1
    
    return not stack


-----
def validateStackSequences(pushed, popped):
    # Your code here


************************************
Question ID: 984
from collections import defaultdict

def removeStones(stones):
    row_groups = defaultdict(int)
    col_groups = defaultdict(int)
    group_count = 0
    
    groups = defaultdict(list)
    
    for x, y in stones:
        if x not in row_groups:
            row_groups[x] = group_count
            group_count += 1
        if y + 10001 not in col_groups: # Offset by max row index
            col_groups[y + 10001] = group_count
            group_count += 1
            
        group_x, group_y = row_groups[x], col_groups[y + 10001]
        groups[group_x].append(group_y)
        groups[group_y].append(group_x)
    
    visited = [False] * group_count
    
    def dfs(groupId):
        if visited[groupId]:
            return 0
        visited[groupId] = True
        size = 1
        for neighbor in groups[groupId]:
            size += dfs(neighbor)
        return size
    
    max_stones = 0
    for groupId in range(group_count):
        max_stones += dfs(groupId) - 1
    
    return max_stones

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 985
def bag_of_tokens_score(tokens, power):
    tokens.sort()
    max_score = score = 0
    left, right = 0, len(tokens) - 1

    while left <= right:
        if power >= tokens[left]:
            power -= tokens[left]
            left += 1
            score += 1
            max_score = max(max_score, score)
        elif score > 0:
            power += tokens[right]
            right -= 1
            score -= 1
        else:
            break

    return max_score

-----
def bag_of_tokens_score(tokens, power):
    # Your code here


************************************
Question ID: 986
from itertools import permutations

def largestTimeFromDigits(arr):
    max_time = -1
    for h, i, j, k in permutations(arr):
        hour = h * 10 + i
        minute = j * 10 + k
        time = hour * 60 + minute
        if hour < 24 and minute < 60 and time > max_time:
            max_time = time

    if max_time == -1:
        return ""
    else:
        return "{:02d}:{:02d}".format(max_time // 60, max_time % 60)

-----
from itertools import permutations
    # Your code here


************************************
Question ID: 987
from collections import deque

def deckRevealedIncreasing(deck):
    n = len(deck)
    index = deque(range(n))
    ans = [0] * n

    deck.sort()
    for card in deck:
        ans[index.popleft()] = card
        if index:
            index.append(index.popleft())

    return ans

-----
from collections import deque
    # Your code here


************************************
Question ID: 989
from collections import defaultdict

def largestComponentSize(nums):
    def primes(n):
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return i
        return n

    def dfs(node, visited, graph):
        if node in visited:
            return 0
        visited.add(node)
        size = 1
        for neighbor in graph[node]:
            size += dfs(neighbor, visited, graph)
        return size

    graph = defaultdict(set)
    visited = set()

    for num in nums:
        prime = primes(num)
        graph[prime].add(num)
        if num != prime:
            graph[num].add(prime)

    count = 0
    for num in nums:
        count = max(count, dfs(num, visited, graph))

    return count

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 990
def is_alien_sorted(words, order):
    alien_order = {char: i for i, char in enumerate(order)}

    for i in range(1, len(words)):
        for j in range(len(words[i - 1])):
            if j == len(words[i]):
                return False

            if words[i - 1][j] != words[i][j]:
                if alien_order[words[i - 1][j]] > alien_order[words[i][j]]:
                    return False
                break

    return True

-----
def is_alien_sorted(words, order):
    # Your code here


************************************
Question ID: 991
def can_reorder_array(arr):
    from collections import Counter
    
    count = Counter(arr)
    arr = sorted(arr)
    for x in arr:
        if count[x] == 0:
            continue
        if count[2 * x] > 0:
            count[x] -= 1
            count[2 * x] -= 1
        else:
            return False
    return True

-----
def can_reorder_array(arr):
    # Your code here


************************************
Question ID: 993
def tallestBillboard(rods):
    n = len(rods)
    totalLength = sum(rods)
    dp = [[-1] * (totalLength + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    
    for i in range(1, n + 1):
        for j in range(totalLength + 1):
            dp[i][j] = dp[i - 1][j]
            if rods[i - 1] <= j:
                dp[i][j] = max(dp[i][j], dp[i - 1][j - rods[i - 1]] + rods[i - 1])
            if rods[i - 1] <= totalLength - j:
                dp[i][j] = max(dp[i][j], dp[i - 1][j + rods[i - 1]])
                
    return dp[n][0] // 2


-----
def tallestBillboard(rods):
    # Your code here


************************************
Question ID: 994
def prisonAfterNDays(cells, n):
    n = n % 14 if n % 14 != 0 else 14 # Pattern repeats every 14 days

    for _ in range(n):
        temp = [0] * 8
        for i in range(1, 7):
            temp[i] = int(cells[i - 1] == cells[i + 1])
        cells = temp

    return cells

-----
def prisonAfterNDays(cells, n):
    # Your code here


************************************
Question ID: 995
def min_k_bit_flips(nums, k):
    n = len(nums)
    flipped = [0] * n
    flips = ans = 0
    for i in range(n):
        if i >= k:
            flips -= flipped[i - k]
        if (flips + nums[i]) % 2 == 0:
            if i + k > n:
                return -1
            flipped[i] = 1
            flips += 1
            ans += 1
    return ans

-----
def min_k_bit_flips(nums, k):
    # Your code here


************************************
Question ID: 996
from collections import Counter

def numSquarefulPerms(nums):
    def is_square(n):
        return int(n ** 0.5) ** 2 == n

    def dfs(idx):
        if idx == len(nums):
            return 1

        count = 0
        for key in counter.keys():
            if counter[key] and (idx == 0 or is_square(nums[idx - 1] + key)):
                counter[key] -= 1
                nums[idx] = key
                count += dfs(idx + 1)
                counter[key] += 1

        return count

    key_set, counter = set(nums), Counter(nums)
    return dfs(0)


-----
from collections import Counter
    # Your code here


************************************
Question ID: 997
def findJudge(n, trust):
    trust_counts = [0] * (n + 1)
    for a, b in trust:
        trust_counts[a] -= 1
        trust_counts[b] += 1
    for i in range(1, n + 1):
        if trust_counts[i] == n - 1:
            return i
    return -1

-----
def findJudge(n, trust):
    # Your code here


************************************
Question ID: 999
def regionsBySlashes(grid):
    n = len(grid)
    graph = [[0] * (n * 3) for _ in range(n * 3)]

    for i in range(n):
        for j in range(n):
            if grid[i][j] == '/':
                graph[i * 3][j * 3 + 2] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3] = 1
            if grid[i][j] == '\\':
                graph[i * 3][j * 3] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3 + 2] = 1

    regions = 0
    for i in range(n * 3):
        for j in range(n * 3):
            if not graph[i][j]:
                regions += 1
                dfs(graph, i, j)

    return regions

def dfs(graph, i, j):
    n = len(graph)
    if i < 0 or j < 0 or i >= n or j >= n or graph[i][j]:
        return

    graph[i][j] = 1
    dfs(graph, i - 1, j)
    dfs(graph, i + 1, j)
    dfs(graph, i, j - 1)
    dfs(graph, i, j + 1)

-----
def regionsBySlashes(grid):
    # Your code here


************************************
Question ID: 1000
def min_deletion_size(strs):
    rows, cols = len(strs), len(strs[0])
    count = 0
    for c in range(cols):
        for r in range(1, rows):
            if strs[r - 1][c] > strs[r][c]:
                count += 1
                break
    return count


-----
def min_deletion_size(strs):
    # Your code here


************************************
Question ID: 1001
def repeatedNTimes(nums):
    hash_map = {}
    for num in nums:
        if num in hash_map:
            return num
        else:
            hash_map[num] = 1


-----
def repeatedNTimes(nums):
    # Your code here


************************************
Question ID: 1002

```javascript
function maxWidthRamp(nums) {
    const indices = [...Array(nums.length).keys()].sort((i, j) => {
        return nums[i] === nums[j] ? i - j : nums[i] - nums[j];
    });
    
    let maxWidth = 0;
    let minIndex = Infinity;
    for (const index of indices) {
        maxWidth = Math.max(maxWidth, index - minIndex);
        minIndex = Math.min(minIndex, index);
    }
    
    return maxWidth;
}
```


-----

    # Your code here


************************************
Question ID: 1003
from collections import defaultdict
from math import sqrt, inf

def minAreaFreeRect(points):
    minArea = inf
    xGroups = defaultdict(set)

    for x, y in points:
        xGroups[x].add(y)

    for x1, ys1 in xGroups.items():
        for x2, ys2 in xGroups.items():
            if x1 == x2:
                continue

            for y1 in ys1:
                for y2 in ys2:
                    if y2 in ys1 and y1 in ys2:
                        area = sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2) * sqrt((x1 - x2) ** 2 + (y1 - y1) ** 2)
                        minArea = min(minArea, area)

    return minArea if minArea != inf else 0


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1004
def least_ops_express_target(x, target):
    if x == target:
        return 0
    if target == 1:
        return 1
    if x > target:
        return min(2 * target - 1, 2 * (x - target))

    k = 0
    p = x
    while p < target:
        k += 1
        p *= x

    ans = float('inf')
    d = 1

    for i in range(k - 1, -1, -1):
        while p >= target + d * (1 - x):
            p -= d
            ans = min(ans, i + int(math.log2(target // d) + 1) + int(d == 1 and -1 or 0))
        d = d * x + 1

    return ans


-----
def least_ops_express_target(x, target):
    # Your code here


************************************
Question ID: 1005
def is_univalued(root, val=None):
    if not root:
        return True
    if val is None:
        val = root.val
    return root.val == val and is_univalued(root.left, val) and is_univalued(root.right, val)

-----
def is_univalued(root, val=None):
    # Your code here


************************************
Question ID: 1006
def spellchecker(wordlist, queries):
    word_map = {word: word for word in wordlist}
    word_map_lower_case = {word.lower(): word for word in wordlist if word.lower() not in word_map_lower_case}
    word_map_vowel_replaced = {replace_vowels(word.lower()): word for word in wordlist if replace_vowels(word.lower()) not in word_map_vowel_replaced}

    result = []
    for query in queries:
        lower_query = query.lower()
        vowel_replaced_query = replace_vowels(lower_query)

        if query in word_map:
            result.append(word_map[query])
        elif lower_query in word_map_lower_case:
            result.append(word_map_lower_case[lower_query])
        elif vowel_replaced_query in word_map_vowel_replaced:
            result.append(word_map_vowel_replaced[vowel_replaced_query])
        else:
            result.append("")

    return result


def replace_vowels(word):
    return ''.join(['#' if ch in 'aeiou' else ch for ch in word])


-----
def spellchecker(wordlist, queries):
    # Your code here


************************************
Question ID: 1007
def numsSameConsecDiff(n, k):
    result = []
    if n == 1: result.append(0)

    def dfs(current):
        if len(current) == n:
            result.append(int(current))
            return

        last_digit = current[-1]
        if last_digit - k >= 0: dfs(current + str(last_digit - k))
        if k != 0 and last_digit + k <= 9: dfs(current + str(last_digit + k))

    for i in range(1, 10):
        dfs(str(i))

    return result

-----
def numsSameConsecDiff(n, k):
    # Your code here


************************************
Question ID: 1008
def min_camera_cover(root):
    ans = [0]
    return (dfs(root, ans) < 1) + ans[0]

def dfs(node, ans):
    if not node:
        return 2
    left = dfs(node.left, ans)
    right = dfs(node.right, ans)
    if left == 0 or right == 0:
        ans[0] += 1
        return 1
    return 2 if left == 1 or right == 1 else 0


-----
def min_camera_cover(root):
    # Your code here


************************************
Question ID: 1009
def pancakeSort(arr):
    flips = []
    for size in range(len(arr), 1, -1):
        maxIdx = arr.index(max(arr[:size]))
        flips.extend([maxIdx + 1, size])
        arr[:maxIdx + 1] = reversed(arr[:maxIdx + 1])
        arr[:size] = reversed(arr[:size])
    return flips

-----
def pancakeSort(arr):
    # Your code here


************************************
Question ID: 1010
def powerful_integers(x, y, bound):
    result = set()
    for i in range(20):
        for j in range(20):
            val = x**i + y**j
            if val <= bound:
                result.add(val)
    return list(result)


-----
def powerful_integers(x, y, bound):
    # Your code here


************************************
Question ID: 1011
def flipRecur(node, voyage, flipped, idx):
    if not node:
        return idx
    if node.val != voyage[idx]:
        flipped[0] = -1
        return idx
    idx += 1
    if (idx < len(voyage) and node.left and
            node.left.val != voyage[idx]):
        flipped.append(node.val)
        idx = flipRecur(node.right, voyage, flipped, idx)
        idx = flipRecur(node.left, voyage, flipped, idx)
    else:
        idx = flipRecur(node.left, voyage, flipped, idx)
        idx = flipRecur(node.right, voyage, flipped, idx)
    return idx


def flipMatchVoyage(root, voyage):
    flipped = []
    flipRecur(root, voyage, flipped, 0)
    if flipped and flipped[0] == -1:
        return [-1]
    return flipped


-----
def flipRecur(node, voyage, flipped, idx):
    # Your code here


************************************
Question ID: 1012
def isRationalEqual(s: str, t: str) -> bool:
    def evaluate(s: str) -> float:
        i = s.find('(')
        if i != -1:
            base = s[:i]
            rep = s[i + 1:-1]
            return float(base + rep * 20)
        return float(s)

    return abs(evaluate(s) - evaluate(t)) < 1e-12

-----
def isRationalEqual(s: str, t: str) -> bool:
    # Your code here


************************************
Question ID: 1013
def fib(n):
    if n <= 1:
        return n
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b

-----
def fib(n):
    # Your code here


************************************
Question ID: 1014
def kClosest(points, k):
    points.sort(key=lambda x: x[0] ** 2 + x[1] ** 2)
    return points[:k]

-----
def kClosest(points, k):
    # Your code here


************************************
Question ID: 1015
def smallestRepunitDivByK(k: int) -> int:
    if k % 2 == 0 or k % 5 == 0:
        return -1
    n = 0
    for i in range(1, k + 1):
        n = (n * 10 + 1) % k
        if n == 0:
            return i
    return -1

-----
def smallestRepunitDivByK(k: int) -> int:
    # Your code here


************************************
Question ID: 1016
def subarraysDivByK(nums, k):
    counts = {0: 1}
    sum_, result = 0, 0
    
    for num in nums:
        sum_ += num
        mod = (sum_ % k + k) % k
        result += counts.get(mod, 0)
        counts[mod] = counts.get(mod, 0) + 1
    
    return result

-----
def subarraysDivByK(nums, k):
    # Your code here


************************************
Question ID: 1017
def odd_even_jumps(arr):
    n = len(arr)
    can_reach_odd = [False] * n
    can_reach_even = [False] * n
    can_reach_odd[-1] = can_reach_even[-1] = True

    index_map = {}
    index_map[arr[-1]] = n - 1

    good_indices = 1
    for i in range(n - 2, -1, -1):
        odd_jump = next(iter([value for value in index_map if value >= arr[i]]), None)
        even_jump = next(iter([value for value in index_map if value <= arr[i]]), None)

        if odd_jump is not None:
            can_reach_odd[i] = can_reach_even[index_map[odd_jump]]
        if even_jump is not None:
            can_reach_even[i] = can_reach_odd[index_map[even_jump]]

        if can_reach_odd[i]:
            good_indices += 1

        index_map[arr[i]] = i

    return good_indices

-----
def odd_even_jumps(arr):
    # Your code here


************************************
Question ID: 1018
def largestPerimeter(nums):
    nums.sort(reverse=True)

    for i in range(len(nums) - 2):
        if nums[i] < nums[i + 1] + nums[i + 2]:
            return nums[i] + nums[i + 1] + nums[i + 2]

    return 0

-----
def largestPerimeter(nums):
    # Your code here


************************************
Question ID: 1019
def sortedSquares(nums):
    return sorted([x ** 2 for x in nums])

-----
def sortedSquares(nums):
    # Your code here


************************************
Question ID: 1020
def maxTurbulenceSize(arr):
    n = len(arr)
    result = 1
    i = 0

    while i < n - 1:
        if arr[i] == arr[i + 1]:
            i += 1
            continue

        j = i + 1
        while j < n - 1 and ((arr[j] > arr[j + 1]) != (arr[j - 1] > arr[j])):
            j += 1
        
        result = max(result, j - i + 1)
        i = j

    return result


-----
def maxTurbulenceSize(arr):
    # Your code here


************************************
Question ID: 1021
def distributeCoins(root):
    def dfs(node):
        if not node:
            return 0
        left, right = dfs(node.left), dfs(node.right)
        moves[0] += abs(left) + abs(right)
        return node.val + left + right - 1

    moves = [0]
    dfs(root)
    return moves[0]

-----
def distributeCoins(root):
    # Your code here


************************************
Question ID: 1022
def uniquePathsIII(grid):
    x, y, empty = 0, 0, 1
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                x, y = i, j
            elif grid[i][j] == 0:
                empty += 1
    return dfs(grid, x, y, empty)

def dfs(grid, x, y, empty):
    if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == -1:
        return 0
    if grid[x][y] == 2:
        return 1 if empty == -1 else 0
    grid[x][y] = -1
    paths = dfs(grid, x + 1, y, empty - 1) + dfs(grid, x - 1, y, empty - 1) + dfs(grid, x, y + 1, empty - 1) + dfs(grid, x, y - 1, empty - 1)
    grid[x][y] = 0
    return paths

-----
def uniquePathsIII(grid):
    # Your code here


************************************
Question ID: 1023
from collections import defaultdict
import bisect

class TimeMap:

    def __init__(self):
        self.data = defaultdict(list)

    def set(self, key, value, timestamp):
        self.data[key].append((timestamp, value))

    def get(self, key, timestamp):
        if key not in self.data: return ""
        index = bisect.bisect(self.data[key], (timestamp + 1,))
        return self.data[key][index-1][1] if index else ""

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1024
def count_and_triples(nums):
    count = 0
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            for k in range(j + 1, len(nums)):
                if nums[i] & nums[j] & nums[k] != 0:
                    count += 1
    return count

-----
def count_and_triples(nums):
    # Your code here


************************************
Question ID: 1025
def mincostTickets(days, costs):
  travel_days = set(days)
  dp = [0] * 366

  for i in range(1, 366):
    if i not in travel_days:
      dp[i] = dp[i - 1]
    else:
      dp[i] = min(dp[i - 1] + costs[0],
                  dp[max(0, i - 7)] + costs[1],
                  dp[max(0, i - 30)] + costs[2])

  return dp[365]

-----
def mincostTickets(days, costs):
    # Your code here


************************************
Question ID: 1027
def sumEvenAfterQueries(nums, queries):
    answer = []
    even_sum = sum(num for num in nums if num % 2 == 0)

    for value, index in queries:
        if nums[index] % 2 == 0:
            even_sum -= nums[index]
        nums[index] += value
        if nums[index] % 2 == 0:
            even_sum += nums[index]
        answer.append(even_sum)

    return answer


-----
def sumEvenAfterQueries(nums, queries):
    # Your code here


************************************
Question ID: 1028
def interval_intersection(firstList, secondList):
    result = []
    i, j = 0, 0

    while i < len(firstList) and j < len(secondList):
        start = max(firstList[i][0], secondList[j][0])
        end = min(firstList[i][1], secondList[j][1])

        if start <= end:
            result.append([start, end])

        if firstList[i][1] < secondList[j][1]:
            i += 1
        else:
            j += 1

    return result

-----
def interval_intersection(firstList, secondList):
    # Your code here


************************************
Question ID: 1029
from collections import defaultdict, deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def verticalTraversal(root):
    if not root:
        return []

    columns = defaultdict(lambda: defaultdict(list))
    q = deque([(root, 0, 0)])

    while q:
        node, row, col = q.popleft()
        columns[col][row].append(node.val)
        columns[col][row].sort()

        if node.left:
            q.append((node.left, row + 1, col - 1))
        if node.right:
            q.append((node.right, row + 1, col + 1))

    return [[val for row in column_data.values() for val in row] for column_data in sorted(columns.values())]

-----
from collections import defaultdict, deque
    # Your code here


************************************
Question ID: 1031
def add_to_array_form(num, k):
    for i in range(len(num) - 1, -1, -1):
        k, num[i] = divmod(num[i] + k, 10)
        if k == 0:
            break
    while k:
        k, digit = divmod(k, 10)
        num.insert(0, digit)
    return num


-----
def add_to_array_form(num, k):
    # Your code here


************************************
Question ID: 1032
def equationsPossible(equations):
    parent = [i for i in range(26)]

    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]

    for e in equations:
        if e[1] == '=':
            x = ord(e[0]) - ord('a')
            y = ord(e[3]) - ord('a')
            parent[find(x)] = find(y)

    for e in equations:
        if e[1] == '!' and find(ord(e[0]) - ord('a')) == find(ord(e[3]) - ord('a')):
            return False

    return True


-----
def equationsPossible(equations):
    # Your code here


************************************
Question ID: 1033
def broken_calc(startValue: int, target: int) -> int:
    operations = 0
    while target > startValue:
        target = target // 2 if target % 2 == 0 else target + 1
        operations += 1
    return operations + startValue - target

-----
def broken_calc(startValue: int, target: int) -> int:
    # Your code here


************************************
Question ID: 1034
def good_subarrays(nums, k):
    count = 0
    for i in range(len(nums)):
        frequency = {}
        for j in range(i, len(nums)):
            frequency[nums[j]] = frequency.get(nums[j], 0) + 1
            if len(frequency) > k:
                break
            if len(frequency) == k:
                count += 1
    return count

-----
def good_subarrays(nums, k):
    # Your code here


************************************
Question ID: 1036
from collections import deque

def orangesRotting(grid):
    m, n = len(grid), len(grid[0])
    fresh_oranges = sum(row.count(1) for row in grid)
    rotten = deque([(i, j) for i, row in enumerate(grid) for j, value in enumerate(row) if value == 2])
    
    minutes = 0
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    while rotten and fresh_oranges:
        for _ in range(len(rotten)):
            x, y = rotten.popleft()

            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:
                    grid[nx][ny] = 2
                    fresh_oranges -= 1
                    rotten.append((nx, ny))
        minutes += 1

    return minutes if fresh_oranges == 0 else -1


-----
from collections import deque
    # Your code here


************************************
Question ID: 1037
def min_k_bit_flips(nums, k):
    n, res, flipped = len(nums), 0, 0
    change = [0] * n
    for i in range(n - k + 1):
        flipped ^= change[i]
        if nums[i] == flipped:
            res += 1
            flipped ^= 1
            if i + k < n:
                change[i + k] ^= 1
    for i in range(n - k + 1, n):
        flipped ^= change[i]
        if nums[i] == flipped:
            return -1
    return res


-----
def min_k_bit_flips(nums, k):
    # Your code here


************************************
Question ID: 1038
from math import sqrt
from itertools import permutations

def is_squareful(x, int_y):
    s = int(sqrt(x + y))
    return s * s == x + y

def squareful_perms(nums):
    count = 0
    for p in permutations(nums):
        if all(is_squareful(p[i], p[i + 1]) for i in range(len(p) - 1)):
            count += 1
    return count


-----
from math import sqrt
    # Your code here


************************************
Question ID: 1039
def find_judge(n, trust):
    trustCounts = [0] * (n + 1)
    for a, b in trust:
        trustCounts[a] -= 1
        trustCounts[b] += 1

    for i in range(1, n + 1):
        if trustCounts[i] == n - 1:
            return i
    return -1

-----
def find_judge(n, trust):
    # Your code here


************************************
Question ID: 1040
def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:
    if root is None or val > root.val:
        newNode = TreeNode(val)
        newNode.left = root
        return newNode
    root.right = self.insertIntoMaxTree(root.right, val)
    return root


-----
def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:
    # Your code here


************************************
Question ID: 1041
def numRookCaptures(board):
    x, y, captures = 0, 0, 0

    for i in range(8):
        for j in range(8):
            if board[i][j] == 'R':
                x, y = i, j
                break
        if board[x][y] == 'R':
            break

    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    for dx, dy in dirs:
        nx, ny = x + dx, y + dy
        while 0 <= nx < 8 and 0 <= ny < 8:
            if board[nx][ny] == 'p':
                captures += 1
                break
            elif board[nx][ny] == 'B':
                break
            nx += dx
            ny += dy

    return captures


-----
def numRookCaptures(board):
    # Your code here


************************************
Question ID: 1042
def mergeStones(stones, k):
    n = len(stones)
    if (n - 1) % (k - 1) != 0:
        return -1
    prefixSum = [0] * (n + 1)
    dp = [[[-1] * (k + 1) for _ in range(n)] for _ in range(n)]

    for i in range(n):
        prefixSum[i + 1] = prefixSum[i] + stones[i]

    for l in range(2, n + 1):
        for i in range(n - l + 1):
            j = i + l - 1
            for m in range(2, k + 1):
                for p in range(i, j + 1 - m + 1, k - 1):
                    dp[i][j][m] = (dp[i][p][1] + dp[p + 1][j][m - 1]) % (1e9 + 7)
            if (j - i) % (k - 1) == 0:
                dp[i][j][1] = (dp[i][j][k] + prefixSum[j + 1] - prefixSum[i]) % (1e9 + 7)

    return dp[0][n - 1][1]

-----
def mergeStones(stones, k):
    # Your code here


************************************
Question ID: 1043
def grid_illumination(n, lamps, queries):
    lamp_rows = set()
    lamp_cols = set()
    lamp_left_diag = set()
    lamp_right_diag = set()

    for lamp in lamps:
        row, col = lamp
        lamp_rows.add(row)
        lamp_cols.add(col)
        lamp_left_diag.add(row - col)
        lamp_right_diag.add(row + col)

    ans = []

    for query in queries:
        row, col = query
        if row in lamp_rows or col in lamp_cols or (row - col) in lamp_left_diag or (row + col) in lamp_right_diag:
            ans.append(1)
        else:
            ans.append(0)
        for i in range(-1, 2):
            for j in range(-1, 2):
                newRow, newCol = row + i, col + j
                lamp_rows.discard(newRow)
                lamp_cols.discard(newCol)
                lamp_left_diag.discard(newRow - newCol)
                lamp_right_diag.discard(newRow + newCol)

    return ans


-----
def grid_illumination(n, lamps, queries):
    # Your code here


************************************
Question ID: 1044
from collections import Counter

def commonChars(words):
    merged = Counter()
    for word in words:
        word_count = Counter(word)
        if not merged:
            merged = word_count
        else:
            for char in merged:
                merged[char] = min(merged[char], word_count[char])

    result = []
    for char, count in merged.items():
        result.extend([char] * count)
    return result

-----
from collections import Counter
    # Your code here


************************************
Question ID: 1046
def longestOnes(nums, k):
    left, right, max_ones, zero_count = 0, 0, 0, 0
    while right < len(nums):
        if nums[right] == 0:
            zero_count += 1
        while zero_count > k:
            if nums[left] == 0:
                zero_count -= 1
            left += 1
        max_ones = max(max_ones, right - left + 1)
        right += 1
    return max_ones


-----
def longestOnes(nums, k):
    # Your code here


************************************
Question ID: 1047
import heapq

def maxSumAfterKOperations(nums, k):
    heapq.heapify(nums)
    for _ in range(k):
        current = heapq.heappop(nums)
        heapq.heappush(nums, -current)
    return sum(nums)

-----
import heapq
    # Your code here


************************************
Question ID: 1048
def clumsy(n: int) -> int:
    if n <= 2:
        return n
    if n == 3:
        return 6
    result = n * (n - 1) // (n - 2) + (n - 3)
    n -= 4
    while n >= 4:
        result = result - (n * (n - 1) // (n - 2)) + (n - 3)
        n -= 4
    return result - clumsy(n)


-----
def clumsy(n: int) -> int:
    # Your code here


************************************
Question ID: 1049
def min_rotations(tops, bottoms):
    res = float('inf')

    for target in (tops[0], bottoms[0]):
        top_rot, bot_rot = 0, 0
        for ti, bi in zip(tops, bottoms):
            if ti != target and bi != target:
                top_rot = bot_rot = float('inf')
                break
            top_rot += ti != target
            bot_rot += bi != target

        res = min(res, top_rot, bot_rot)

    return -1 if res == float('inf') else res

-----
def min_rotations(tops, bottoms):
    # Your code here


************************************
Question ID: 1051
def height_checker(heights):
    expected = sorted(heights)
    
    count = 0
    for i in range(len(heights)):
        if heights[i] != expected[i]:
            count += 1
            
    return count

-----
def height_checker(heights):
    # Your code here


************************************
Question ID: 1052
def maxSatisfied(customers, grumpy, minutes):
    total_customers = 0
    max_extra_customers = 0
    extra_customers = 0
    for i in range(len(customers)):
        if grumpy[i] == 0:
            total_customers += customers[i]
        if i < minutes:
            extra_customers += customers[i] * grumpy[i]
        else:
            extra_customers += (customers[i] * grumpy[i]) - (customers[i - minutes] * grumpy[i - minutes])
        max_extra_customers = max(max_extra_customers, extra_customers)
    return total_customers + max_extra_customers


-----
def maxSatisfied(customers, grumpy, minutes):
    # Your code here


************************************
Question ID: 1053
def prevPermOpt1(arr):
    n = len(arr)
    for i in range(n - 2, -1, -1):
        if arr[i] > arr[i + 1]:
            j = i + 1
            while j < n and arr[j] < arr[i]:
                j += 1
            arr[i], arr[j - 1] = arr[j - 1], arr[i]
            break
    return arr


-----
def prevPermOpt1(arr):
    # Your code here


************************************
Question ID: 1054
def bitwise_complement(n):
    x = 1
    while n > x:
        x = x * 2 + 1
    return x - n

-----
def bitwise_complement(n):
    # Your code here


************************************
Question ID: 1055
def num_pairs_divisible_by60(time):
    count = [0] * 60
    pairs = 0

    for t in time:
        mod = t % 60
        pairs += count[(60 - mod) % 60]
        count[mod] += 1

    return pairs

-----
def num_pairs_divisible_by60(time):
    # Your code here


************************************
Question ID: 1056

```javascript
function shipWithinDays(weights, days) {
    let left = Math.max(...weights), right = weights.reduce((a, b) => a + b, 0);
    while (left < right) {
        let mid = left + ((right - left) / 2) | 0;
        let day_count = 1, curr_capacity = 0;
        for (const w of weights) {
            curr_capacity += w;
            if (curr_capacity > mid) {
                day_count++;
                curr_capacity = w;
            }
        }
        if (day_count > days) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}
```

-----

    # Your code here


************************************
Question ID: 1057
def num_dup_digits_at_most_n(n):
    count = 0
    for i in range(1, n + 1):
        digits = set()
        num = i
        while num != 0:
            digit = num % 10
            if digit in digits:
                count += 1
                break
            else:
                digits.add(digit)
            num //= 10
    return count

-----
def num_dup_digits_at_most_n(n):
    # Your code here


************************************
Question ID: 1058
from math import floor, ceil

def find_rounding_error(prices, target):
    n = len(prices)
    decimals = [float(price) - floor(float(price)) for price in prices]
    rounded_sum = sum(floor(float(price)) for price in prices)

    if target < rounded_sum or target > rounded_sum + n:
        return "-1 "

    ceil_count = target - rounded_sum
    rounding_error = 0.0

    for d in decimals:
        if ceil_count > 0:
            rounding_error += 1 - d
            ceil_count -= 1
        else:
            rounding_error += d

    return f"{rounding_error:.3f} "


-----
from math import floor, ceil
    # Your code here


************************************
Question ID: 1059
from collections import defaultdict

def leadsToDestination(n, edges, source, destination):
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)

    visited = [0] * n
    return dfs(source, graph, visited, destination)

def dfs(node, graph, visited, destination):
    if node not in graph:
        return node == destination
    if visited[node] != 0:
        return visited[node] == 2

    visited[node] = 1
    for neighbor in graph[node]:
        if not dfs(neighbor, graph, visited, destination):
            return False

    visited[node] = 2
    return True

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1060
def findKthPositive(nums, k):
    left, right = 0, len(nums)
    while left < right:
        mid = left + (right - left) // 2
        if nums[mid] - mid - 1 < k:
            left = mid + 1
        else:
            right = mid
    return left + k

-----
def findKthPositive(nums, k):
    # Your code here


************************************
Question ID: 1061
def lex_smallest_equivalent(s1, s2, base_str):
    parent = {chr(ch): chr(ch) for ch in range(ord('a'), ord('z') + 1)}

    for c1, c2 in zip(s1, s2):
        root1, root2 = c1, c2
        while parent[root1] != root1:
            root1 = parent[root1]
        while parent[root2] != root2:
            root2 = parent[root2]
        if root1 != root2:
            min_root = min(root1, root2)
            parent[root1] = min_root
            parent[root2] = min_root

    return ''.join(parent[ch] for ch in base_str)

-----
def lex_smallest_equivalent(s1, s2, base_str):
    # Your code here


************************************
Question ID: 1062
def find_longest_repeating_substring(s: str) -> int:
    n = len(s)
    max_substr_length = 0
    for length in range(1, n // 2 + 1):
        max_repeat_count = repeat_count = 0
        for i in range(n - length):
            if s[i:i + length] == s[i + length:i + 2 * length]:
                repeat_count += 1
            else:
                max_repeat_count = max(max_repeat_count, repeat_count)
                repeat_count = 0
        max_substr_length = max(max_substr_length, max_repeat_count * length)
    return max_substr_length

-----
def find_longest_repeating_substring(s: str) -> int:
    # Your code here


************************************
Question ID: 1063
def maxScoreSightseeingPair(values):
    max_score = 0
    max_score_left = values[0] + 0
    for j in range(1, len(values)):
        max_score = max(max_score, max_score_left + values[j] - j)
        max_score_left = max(max_score_left, values[j] + j)
    return max_score

-----
def maxScoreSightseeingPair(values):
    # Your code here


************************************
Question ID: 1064
def fixedPoint(arr: List[int]) -> int:
    left, right = 0, len(arr) - 1
    while left < right:
        middle = left + (right - left) // 2
        if arr[middle] < middle:
            left = middle + 1
        else:
            right = middle
    return left if arr[left] == left else -1

-----
def fixedPoint(arr: List[int]) -> int:
    # Your code here


************************************
Question ID: 1065
def has_all_codes_in_range(s: str, n: int) -> bool:
    substrings = set()
    length = len(bin(n)) - 2
    for i in range(len(s) - length + 1):
        substrings.add(s[i:i + length])
    return len(substrings) == n


-----
def has_all_codes_in_range(s: str, n: int) -> bool:
    # Your code here


************************************
Question ID: 1066
from typing import List

def manhattan_distance(worker: List[int], bike: List[int]) -> int:
    return abs(worker[0] - bike[0]) + abs(worker[1] - bike[1])

def dfs(workers: List[List[int]], bikes: List[List[int]], used: List[bool], index: int, dist: int, min_dist: List[int]) -> None:
    if index == len(workers):
        min_dist[0] = min(min_dist[0], dist)
        return

    if dist >= min_dist[0]:
        return

    for i in range(len(bikes)):
        if used[i]:
            continue
        used[i] = True
        cur_dist = manhattan_distance(workers[index], bikes[i])
        dfs(workers, bikes, used, index + 1, dist + cur_dist, min_dist)
        used[i] = False

def assign_bikes(workers: List[List[int]], bikes: List[List[int]]) -> int:
    min_dist = [float('inf')]
    used = [False] * len(bikes)
    dfs(workers, bikes, used, 0, 0, min_dist)
    return min_dist[0]

-----
from typing import List
    # Your code here


************************************
Question ID: 1067
def count_digit(d, low, high):
    count = 0
    for i in range(low, high + 1):
        num = i
        while num > 0:
            if num % 10 == d:
                count += 1
            num //= 10
    return count

-----
def count_digit(d, low, high):
    # Your code here


************************************
Question ID: 1071
def prefixesDivBy5(nums):
    result = []
    current = 0
    for num in nums:
        current = ((current << 1) | num) % 5
        result.append(current == 0)
    return result

-----
def prefixesDivBy5(nums):
    # Your code here


************************************
Question ID: 1073
from collections import deque

def addNegabinary(arr1, arr2):
    res = deque()
    carry, i, j = 0, len(arr1) - 1, len(arr2) - 1
    while i >= 0 or j >= 0 or carry:
        if i >= 0: carry += arr1[i]; i -= 1
        if j >= 0: carry += arr2[j]; j -= 1
        res.appendleft(carry & 1)
        carry = -(carry >> 1)
    while len(res) > 1 and res[0] == 0: res.popleft()
    return list(res)


-----
from collections import deque
    # Your code here


************************************
Question ID: 1074
def numSubmatrixSumTarget(matrix: List[List[int]], target: int) -> int:
    rows, cols = len(matrix), len(matrix[0])
    for row in range(rows):
        for col in range(1, cols):
            matrix[row][col] += matrix[row][col-1]
    
    count = 0
    for col1 in range(cols):
        for col2 in range(col1, cols):
            counter = collections.defaultdict(int)
            counter[0] = 1
            cur_sum = 0
            for row in range(rows):
                cur_sum += matrix[row][col2] - (matrix[row][col1-1] if col1 > 0 else 0)
                count += counter[cur_sum - target]
                counter[cur_sum] += 1

    return count

-----
def numSubmatrixSumTarget(matrix: List[List[int]], target: int) -> int:
    # Your code here


************************************
Question ID: 1078
def remove_outer_parentheses(s: str) -> str:
    result = []
    opened = 0

    for c in s:
        if c == '(':
            if opened > 0:
                result.append(c)
            opened += 1
        elif c == ')':
            if opened > 1:
                result.append(c)
            opened -= 1

    return ''.join(result)


-----
def remove_outer_parentheses(s: str) -> str:
    # Your code here


************************************
Question ID: 1079
def sumRootToLeaf(root, path_value=0):
    if not root:
        return 0
    path_value = path_value * 2 + root.val
    if not root.left and not root.right:
        return path_value
    return sumRootToLeaf(root.left, path_value) + sumRootToLeaf(root.right, path_value)

-----
def sumRootToLeaf(root, path_value=0):
    # Your code here


************************************
Question ID: 1080
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:
        if not root:
            return None
        if not root.left and not root.right:
            if root.val < limit:
                return None
            return root
        root.left = self.sufficientSubset(root.left, limit - root.val)
        root.right = self.sufficientSubset(root.right, limit - root.val)
        if not root.left and not root.right:
            return None

        return root


-----
# Definition for a binary tree node.
    # Your code here


************************************
Question ID: 1081
def videoStitching(clips, time):
    dp = [float('inf')] * (time + 1)
    dp[0] = 0
    for i in range(1, time + 1):
        for clip in clips:
            if clip[0] < i and i <= clip[1]:
                dp[i] = min(dp[i], dp[clip[0]] + 1)
    return -1 if dp[time] == float('inf') else dp[time]

-----
def videoStitching(clips, time):
    # Your code here


************************************
Question ID: 1085
def sum_of_digits(nums):
    min_val = min(nums)
    digit_sum = sum(int(digit) for digit in str(min_val))
    return 1 if digit_sum % 2 == 0 else 0


-----
def sum_of_digits(nums):
    # Your code here


************************************
Question ID: 1086
def alice_win(n):
    return n % 2 == 0


-----
def alice_win(n):
    # Your code here


************************************
Question ID: 1087
def longestArithSeqLength(nums):
    n = len(nums)
    longest = 0
    dp = [{} for _ in range(n)]
    
    for i in range(n):
        for j in range(i):
            diff = nums[i] - nums[j]
            dp[i][diff] = dp[j].get(diff, 1) + 1
            longest = max(longest, dp[i][diff])
    
    return longest

-----
def longestArithSeqLength(nums):
    # Your code here


************************************
Question ID: 1088
def confusingNumberII(n):
    def helper(current):
        nonlocal count, validNums
        for num in validNums:
            next_num = current * 10 + num
            if next_num > n:
                break
            if current != 0 or next_num != 0:
                if next_num != rotate(next_num):
                    count += 1
                count = helper(next_num)
        return count

    def rotate(num):
        rotated = 0
        original = num
        while num > 0:
            digit = num % 10
            if digit in (2, 3, 4, 5, 7):
                return original
            revd = {0: 0, 1: 1, 6: 9, 8: 8, 9: 6}
            rotated = rotated * 10 + revd[digit]
            num //= 10
        return rotated

    count = 0
    validNums = [0, 1, 6, 8, 9]
    return helper(0)

-----
def confusingNumberII(n):
    # Your code here


************************************
Question ID: 1089
def duplicateZeros(arr):
    n = len(arr)
    i = 0
    while i < n - 1:
        if arr[i] == 0:
            for j in range(n - 1, i + 1, -1):
                arr[j] = arr[j - 1]
            arr[i + 1] = 0
            i += 1
        i += 1

-----
def duplicateZeros(arr):
    # Your code here


************************************
Question ID: 1090
from typing import List

def largestValsFromLabels(values: List[int], labels: List[int], numWanted: int, useLimit: int) -> int:
    items = list(zip(values, labels))
    items.sort(key=lambda x: x[0], reverse=True)

    label_count = {}
    ans = 0

    for value, label in items:
        if label not in label_count:
            label_count[label] = 0
        if label_count[label] < useLimit:
            ans += value
            label_count[label] += 1
            numWanted -= 1
            if numWanted == 0:
                break

    return ans


-----
from typing import List
    # Your code here


************************************
Question ID: 1091
from collections import deque

def shortestPathBinaryMatrix(grid):
    n = len(grid)
    if grid[0][0] or grid[n - 1][n - 1]: return -1

    dir = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]
    q = deque([(0, 0)])
    grid[0][0] = 1

    pathLength = 1

    while q:
        qlen = len(q)
        for _ in range(qlen):
            x, y = q.popleft()

            if x == n - 1 and y == n - 1: return pathLength

            for d in dir:
                newX, newY = x + d[0], y + d[1]

                if 0 <= newX < n and 0 <= newY < n and grid[newX][newY] == 0:
                    q.append((newX, newY))
                    grid[newX][newY] = 1
        pathLength += 1

    return -1

-----
from collections import deque
    # Your code here


************************************
Question ID: 1094
def allCellsDistOrder(rows, cols, rCenter, cCenter):
    coordinates = [[i, j] for i in range(rows) for j in range(cols)]

    coordinates.sort(key=lambda x: abs(x[0] - rCenter) + abs(x[1] - cCenter))

    return coordinates

-----
def allCellsDistOrder(rows, cols, rCenter, cCenter):
    # Your code here


************************************
Question ID: 1095
def twoCitySchedCost(costs):
    costs.sort(key=lambda x: x[0] - x[1])

    totalCost = 0
    n = len(costs) // 2

    for i in range(n):
        totalCost += costs[i][0] + costs[i + n][1]

    return totalCost

-----
def twoCitySchedCost(costs):
    # Your code here


************************************
Question ID: 1099
def max_sum_under_k(nums, k):
    max_sum = -1
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            _sum = nums[i] + nums[j]
            if _sum < k and _sum > max_sum:
                max_sum = _sum
    return max_sum

-----
def max_sum_under_k(nums, k):
    # Your code here


************************************
Question ID: 1100
def num_k_len_substr_no_repeats(s: str, k: int) -> int:
    n = len(s)
    if k > n:
        return 0

    result = 0
    window = set()

    i = 0
    for j in range(n):
        while s[j] in window:
            window.remove(s[i])
            i += 1
        window.add(s[j])
        if j - i + 1 == k:
            result += 1
            window.remove(s[i])
            i += 1

    return result

-----
def num_k_len_substr_no_repeats(s: str, k: int) -> int:
    # Your code here


************************************
Question ID: 1101
def earliestAcq(logs, n):
    def find(x):
        if x != parents[x]:
            parents[x] = find(parents[x])
        return parents[x]

    parents = list(range(n))
    logs.sort()

    group_count = n
    for timestamp, x, y in logs:
        root_x, root_y = find(x), find(y)
        if root_x != root_y:
            parents[root_x] = root_y
            group_count -= 1
        if group_count == 1:
            return timestamp
    return -1

-----
def earliestAcq(logs, n):
    # Your code here


************************************
Question ID: 1102
def maxScore(grid):
    m, n = len(grid), len(grid[0])

    for i in range(1, n):
        grid[0][i] = min(grid[0][i], grid[0][i - 1])

    for i in range(1, m):
        grid[i][0] = min(grid[i][0], grid[i - 1][0])

        for j in range(1, n):
            grid[i][j] = max(min(grid[i - 1][j], grid[i][j]), min(grid[i][j - 1], grid[i][j]))

    return grid[m - 1][n - 1]



-----
def maxScore(grid):
    # Your code here


************************************
Question ID: 1103
def distribute_candies(candies, num_people):
    result = [0] * num_people
    i = 0
    count = 1

    while candies > 0:
        result[i % num_people] += min(candies, count)
        candies -= count
        count += 1
        i += 1

    return result


-----
def distribute_candies(candies, num_people):
    # Your code here


************************************
Question ID: 1104
def colorBorder(grid, row, col, color):
    def dfs(grid, row, col, current, color):
        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != current:
            return

        grid[row][col] = color
        dfs(grid, row - 1, col, current, color)
        dfs(grid, row + 1, col, current, color)
        dfs(grid, row, col - 1, current, color)
        dfs(grid, row, col + 1, current, color)

    current = grid[row][col]
    if current == color:
        return grid

    dfs(grid, row, col, current, color + 1000)

    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] > 1000:
                grid[i][j] -= 1000

    return grid

-----
def colorBorder(grid, row, col, color):
    # Your code here


************************************
Question ID: 1105
def max_uncrossed_lines(nums1, nums2):
    m, n = len(nums1), len(nums2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if nums1[i - 1] == nums2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]


-----
def max_uncrossed_lines(nums1, nums2):
    # Your code here


************************************
Question ID: 1106
MAX_STEPS = 200

def isEscapePossible(blocked, source, target):
    blockedSet = set(["{}_{}".format(block[0], block[1]) for block in blocked])
    visited = set()

    def dfs(x, y, tx, ty, steps):
        pos = "{}_{}".format(x, y)
        if x < 0 or x >= 1000000 or y < 0 or y >= 1000000 or steps >= MAX_STEPS or pos in blockedSet or pos in visited:
            return False

        if x == tx and y == ty:
            return True

        visited.add(pos)

        return (dfs(x + 1, y, tx, ty, steps + 1) or dfs(x, y + 1, tx, ty, steps + 1)
                or dfs(x - 1, y, tx, ty, steps + 1) or dfs(x, y - 1, tx, ty, steps + 1))

    return dfs(source[0], source[1], target[0], target[1], 0)


-----
MAX_STEPS = 200
    # Your code here


************************************
Question ID: 1108
def defangIPaddr(address: str) -> str:
    return address.replace('.', '[.]')

-----
def defangIPaddr(address: str) -> str:
    # Your code here


************************************
Question ID: 1109
def corpFlightBookings(bookings, n):
    seats = [0] * n
    for booking in bookings:
        seats[booking[0] - 1] += booking[2]
        if booking[1] < n:
            seats[booking[1]] -= booking[2]
    for i in range(1, n):
        seats[i] += seats[i - 1]
    return seats

-----
def corpFlightBookings(bookings, n):
    # Your code here


************************************
Question ID: 1111
def minScoreTriangulation(values):
    n = len(values)
    dp = [[0] * n for _ in range(n)]

    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            dp[i][j] = float('inf')
            for k in range(i + 1, j):
                dp[i][j] = min(dp[i][j], values[i] * values[j] * values[k] + dp[i][k] + dp[k][j])

    return dp[0][n - 1]


-----
def minScoreTriangulation(values):
    # Your code here


************************************
Question ID: 1118
def number_of_days(year, month):
    if month == 2:
        if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:
            return 29
        return 28
    if month in [4, 6, 9, 11]:
        return 30
    return 31

-----
def number_of_days(year, month):
    # Your code here


************************************
Question ID: 1119
def is_robot_bounded(instructions: str) -> bool:
    x, y, dir = 0, 0, 0
    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    for c in instructions:
        if c == 'G':
            x += moves[dir][0]
            y += moves[dir][1]
        elif c == 'L':
            dir = (dir + 3) % 4
        else:
            dir = (dir + 1) % 4

    return (x == 0 and y == 0) or dir != 0

-----
def is_robot_bounded(instructions: str) -> bool:
    # Your code here


************************************
Question ID: 1120
from collections import defaultdict

def gardenNoAdj(n, paths):
    graph = defaultdict(set)
    for x, y in paths:
        graph[x - 1].add(y - 1)
        graph[y - 1].add(x - 1)
    
    result = [0] * n
    for i in range(n):
        used_flowers = {result[neighbor] for neighbor in graph[i]}
        for flower in range(1, 5):
            if flower not in used_flowers:
                result[i] = flower
                break
    return result


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1121
def maxSumAfterPartitioning(arr: list, k: int) -> int:
    n = len(arr)
    dp = [0] * (n + 1)
    for i in range(1, n + 1):
        current_max = 0
        for j in range(1, k + 1):
            if i - j < 0:
                break
            current_max = max(current_max, arr[i - j])
            dp[i] = max(dp[i], dp[i - j] + current_max * j)
    return dp[n]

-----
def maxSumAfterPartitioning(arr: list, k: int) -> int:
    # Your code here


************************************
Question ID: 1122
def longest_dup_substring(s):
    n = len(s)
    longest_duplicate = ""
    for length in range(n - 1, 0, -1):
        for i in range(n - length + 1):
            substring = s[i:i + length]
            if s.find(substring, i + 1) != -1:
                longest_duplicate = substring
                return longest_duplicate
    return longest_duplicate


-----
def longest_dup_substring(s):
    # Your code here


************************************
Question ID: 1124
def longestWellPerformingInterval(hours):
    sum = 0
    longest = 0
    first_sum_index = {}

    for i, hour in enumerate(hours):
        sum += 1 if hour > 8 else -1
        if sum > 0:
            longest = i + 1
        else:
            if sum - 1 in first_sum_index:
                longest = max(longest, i - first_sum_index[sum - 1])
            if sum not in first_sum_index:
                first_sum_index[sum] = i

    return longest


-----
def longestWellPerformingInterval(hours):
    # Your code here


************************************
Question ID: 1125
from collections import defaultdict
from math import log2

def smallestSufficientTeam(req_skills, people):
    skill_to_id = {skill: idx for idx, skill in enumerate(req_skills)}

    n, m = len(people), len(req_skills)
    dp = [float("inf")] * (1 << m)
    pre = [0] * (1 << m)
    skill_set = [0] * (1 << m)

    dp[0] = 0

    for i, skills in enumerate(people):
        skill_mask = sum(1 << skill_to_id[skill] for skill in skills)
        for j in range((1 << m) - 1, -1, -1):
            if dp[j | skill_mask] > dp[j] + 1:
                dp[j | skill_mask] = dp[j] + 1
                pre[j | skill_mask] = j
                skill_set[j | skill_mask] = i

    res = []
    mask = (1 << m) - 1
    while mask:
        res.append(skill_set[mask])
        mask = pre[mask]

    return res


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1128
def remove_duplicates(s: str) -> str:
    stack = []
    for c in s:
        if stack and stack[-1] == c:
            stack.pop()
        else:
            stack.append(c)
    return "".join(stack)

-----
def remove_duplicates(s: str) -> str:
    # Your code here


************************************
Question ID: 1129
def longestStrChain(words):
    words.sort(key=lambda x: len(x))
    dp = {}

    max_len = 0
    for word in words:
        for i in range(len(word)):
            pre = word[:i] + word[i + 1:]
            dp[word] = max(dp.get(word, 0), dp.get(pre, 0) + 1)
        max_len = max(max_len, dp[word])

    return max_len

-----
def longestStrChain(words):
    # Your code here


************************************
Question ID: 1130
import heapq

def lastStoneWeight(stones):
    stones = [-stone for stone in stones]
    heapq.heapify(stones)
    while len(stones) > 1:
        y = -heapq.heappop(stones)
        x = -heapq.heappop(stones)
        if x != y:
            heapq.heappush(stones, -(y - x))
    return -stones[0] if stones else 0

-----
import heapq
    # Your code here


************************************
Question ID: 1131
def maxAbsValExpr(arr1, arr2):
    result = 0
    max_sum = [float('-inf')] * 4

    for i in range(len(arr1)):
        max_sum[0] = max(max_sum[0], arr1[i] + arr2[i] + i)
        max_sum[1] = max(max_sum[1], arr1[i] - arr2[i] + i)
        max_sum[2] = max(max_sum[2], -arr1[i] + arr2[i] + i)
        max_sum[3] = max(max_sum[3], -arr1[i] - arr2[i] + i)

    for i in range(len(arr1)):
        result = max(result, max_sum[0] - arr1[i] - arr2[i] - i)
        result = max(result, max_sum[1] - arr1[i] + arr2[i] - i)
        result = max(result, max_sum[2] + arr1[i] - arr2[i] - i)
        result = max(result, max_sum[3] + arr1[i] + arr2[i] - i)

    return result

-----
def maxAbsValExpr(arr1, arr2):
    # Your code here


************************************
Question ID: 1133
def last_substring(s: str) -> str:
    i, j, k, n = 0, 1, 0, len(s)
    while j + k < n:
        if s[i + k] == s[j + k]:
            k += 1
        elif s[i + k] < s[j + k]:
            i = j
            j += 1
            k = 0
        else:
            j += 1
            k = 0
    return s[i:]

-----
def last_substring(s: str) -> str:
    # Your code here


************************************
Question ID: 1134
def is_armstrong(n: int) -> bool:
    power_sum = 0
    original = n
    k = len(str(n))
    while n > 0:
        digit = n % 10
        power_sum += digit ** k
        n //= 10
    return power_sum == original

-----
def is_armstrong(n: int) -> bool:
    # Your code here


************************************
Question ID: 1135
def find(parent, x):
    if parent[x] != x:
        parent[x] = find(parent, parent[x])
    return parent[x]

def minimumCost(n, connections):
    connections.sort(key=lambda x: x[2])

    parent = list(range(n + 1))

    cost = 0
    edges = 0
    for c in connections:
        root_x = find(parent, c[0])
        root_y = find(parent, c[1])

        if root_x != root_y:
            parent[root_y] = root_x
            cost += c[2]
            edges += 1

        if edges == n - 1:
            break

    return cost if edges == n - 1 else -1

-----
def find(parent, x):
    # Your code here


************************************
Question ID: 1136
def minimum_semesters(n: int, relations: List[List[int]]) -> int:
    in_degree = [0] * (n + 1)
    graph = [[] for _ in range(n + 1)]

    for prev, next in relations:
        graph[prev].append(next)
        in_degree[next] += 1

    q = [i for i in range(1, n + 1) if in_degree[i] == 0]
    semesters = 0

    while q:
        next_q = []
        semesters += 1
        for course in q:
            n -= 1
            for next_course in graph[course]:
                in_degree[next_course] -= 1
                if in_degree[next_course] == 0:
                    next_q.append(next_course)
        q = next_q

    return semesters if n == 0 else -1

-----
def minimum_semesters(n: int, relations: List[List[int]]) -> int:
    # Your code here


************************************
Question ID: 1137
def height_checker(heights):
    expected = sorted(heights)
    count = 0
    for i in range(len(heights)):
        if heights[i] != expected[i]:
            count += 1
    return count

-----
def height_checker(heights):
    # Your code here


************************************
Question ID: 1138
def maxSatisfied(customers, grumpy, minutes):
    total, max_increase, window_increase = 0, 0, 0
    i, j = 0, 0
    while i < len(customers):
        if i - j == minutes:
            window_increase -= customers[j] * grumpy[j]
            j += 1
        window_increase += customers[i] * grumpy[i]
        total += customers[i] * (1 - grumpy[i])
        max_increase = max(max_increase, window_increase)
        i += 1
    return total + max_increase

-----
def maxSatisfied(customers, grumpy, minutes):
    # Your code here


************************************
Question ID: 1139
def prev_perm_opt1(arr):
    n = len(arr)
    for i in range(n - 2, -1, -1):
        if arr[i] > arr[i + 1]:
            j = i + 1
            while j < n and arr[j] < arr[i]:
                j += 1
            arr[i], arr[j - 1] = arr[j - 1], arr[i]
            return arr
    return arr

-----
def prev_perm_opt1(arr):
    # Your code here


************************************
Question ID: 1140
from heapq import heappush, heappop

def rearrange_barcodes(barcodes):
    count = {}
    for barcode in barcodes:
        if barcode not in count:
            count[barcode] = 0
        count[barcode] += 1

    pq = []
    for key, value in count.items():
        heappush(pq, (-value, key))

    idx = 0
    while pq:
        curr = heappop(pq)
        while curr[0] < 0:
            barcodes[idx] = curr[1]
            curr = (curr[0] + 1, curr[1])
            idx += 2
            if idx >= len(barcodes):
                idx = 1
    return barcodes

-----
from heapq import heappush, heappop
    # Your code here


************************************
Question ID: 1143
def longestCommonSubsequence(text1: str, text2: str) -> int:
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]

-----
def longestCommonSubsequence(text1: str, text2: str) -> int:
    # Your code here


************************************
Question ID: 1144
def movesToMakeZigzag(nums):
    even_moves, odd_moves = 0, 0
    for i in range(len(nums)):
        left = nums[i - 1] if i > 0 else 1001
        right = nums[i + 1] if i < len(nums) - 1 else 1001
        min_value = min(left, right)
        if nums[i] >= min_value:
            if i % 2 == 0:
                even_moves += nums[i] - min_value + 1
            else:
                odd_moves += nums[i] - min_value + 1
    return min(even_moves, odd_moves)

-----
def movesToMakeZigzag(nums):
    # Your code here


************************************
Question ID: 1146
def gcd_of_strings(str1: str, str2: str) -> str:
    if str1 + str2 != str2 + str1:
        return ''
    gcd = lambda a, b: a if not b else gcd(b, a % b)
    return str1[:gcd(len(str1), len(str2))]


-----
def gcd_of_strings(str1: str, str2: str) -> str:
    # Your code here


************************************
Question ID: 1147
from collections import defaultdict

def maxEqualRowsAfterFlips(matrix):
    count = defaultdict(int)
    for row in matrix:
        row_str = "".join(str(row[0] ^ val) for val in row)
        count[row_str] += 1
    return max(count.values())

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1150
def is_majority_element(nums, target):
    count = 0
    for num in nums:
        if num == target: count += 1
        if count > len(nums) / 2: return True
    return False

-----
def is_majority_element(nums, target):
    # Your code here


************************************
Question ID: 1151
def minSwaps(data):
    ones = sum(data)
    cur_ones, max_ones = 0, 0
    for i, d in enumerate(data):
        cur_ones += d
        if i >= ones:
            cur_ones -= data[i - ones]
        max_ones = max(max_ones, cur_ones)
    return ones - max_ones


-----
def minSwaps(data):
    # Your code here


************************************
Question ID: 1152
from typing import List
from collections import defaultdict
from itertools import combinations

class Solution:
    def mostVisitedPattern(self, username: List[str], timestamp: List[int], website: List[str]) -> List[str]:
        n = len(username)
        visits = defaultdict(list)
        
        # user_visits: {user: [(timestamp, website),...]}
        for i in range(n):
            visits[username[i]].append((timestamp[i], website[i]))


        for user in visits:
            visits[user].sort()
        
        patterns = defaultdict(int)
        
        for user in visits:
            websites = [web for _, web in visits[user]]
            patterns_set = set(combinations(websites, 3))

            for pattern in patterns_set:
                patterns[pattern] += 1
                
        patterns = sorted(patterns.items(), key=lambda x: (-x[1], x[0]))
        
        return list(patterns[0][0])


-----
from typing import List
    # Your code here


************************************
Question ID: 1153
def canConvert(str1, str2):
    if str1 == str2: return True;
    conversion = {}
    for c1, c2 in zip(str1, str2):
        if c1 in conversion and conversion[c1] != c2: return False
        conversion[c1] = c2
    return len(set(str2)) < 26


-----
def canConvert(str1, str2):
    # Your code here


************************************
Question ID: 1154
def is_leap_year(year: int) -> bool:
    return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)

def day_of_year(date: str) -> int:
    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    year, month, day = int(date[:4]), int(date[5:7]), int(date[8:])

    if is_leap_year(year):
        days_in_month[1] = 29

    return sum(days_in_month[:month-1]) + day


-----
def is_leap_year(year: int) -> bool:
    # Your code here


************************************
Question ID: 1155
def numRollsToTarget(n, k, target):
    MOD = 1000000007
    dp = [[0 for _ in range(target + 1)] for _ in range(n + 1)]
    dp[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i, target + 1):
            for d in range(1, k + 1):
                if j - d >= 0:
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - d]) % MOD
    return dp[n][target]

-----
def numRollsToTarget(n, k, target):
    # Your code here


************************************
Question ID: 1156
def find_third_words(text, first, second):
    words = text.split()
    result = []
    
    for i in range(len(words) - 2):
        if words[i] == first and words[i + 1] == second:
            result.append(words[i + 2])
            
    return result

-----
def find_third_words(text, first, second):
    # Your code here


************************************
Question ID: 1160
def num_tile_possibilities(tiles: str) -> int:
    freq = [0] * 26
    for c in tiles:
        freq[ord(c) - ord('A')] += 1

    def dfs(freq):
        result = 0
        for i in range(26):
            if freq[i] > 0:
                freq[i] -= 1
                result += 1 + dfs(freq)
                freq[i] += 1
        return result

    return dfs(freq)

-----
def num_tile_possibilities(tiles: str) -> int:
    # Your code here


************************************
Question ID: 1162
from collections import deque

def maxDistance(grid):
    distance = -1
    water_cells = deque()
    n = len(grid)

    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                water_cells.append((i, j))

    if not water_cells or len(water_cells) == n * n:
        return distance

    directions = ((0, 1), (0, -1), (1, 0), (-1, 0))

    while water_cells:
        size = len(water_cells)
        for _ in range(size):
            x, y = water_cells.popleft()
            for dx, dy in directions:
                newX, newY = x + dx, y + dy
                if 0 <= newX < n and 0 <= newY < n and grid[newX][newY] == 0:
                    grid[newX][newY] = 1
                    water_cells.append((newX, newY))
        distance += 1
        
    return distance - 1


-----
from collections import deque
    # Your code here


************************************
Question ID: 1163
def lastSubstring(s: str) -> str:
    maxIndex = 0
    curIndex = 1
    while curIndex < len(s):
        i = 0
        while curIndex + i < len(s) and s[maxIndex + i] == s[curIndex + i]:
            i += 1
        if curIndex + i == len(s):
            break
        if s[maxIndex + i] < s[curIndex + i]:
            maxIndex = curIndex
        curIndex += 1
    return s[maxIndex:]

-----
def lastSubstring(s: str) -> str:
    # Your code here


************************************
Question ID: 1165
def calculate_time(keyboard: str, word: str) -> int:
    time = 0
    prev_index = 0
    char_to_index = {char: i for i, char in enumerate(keyboard)}

    for c in word:
        time += abs(char_to_index[c] - prev_index)
        prev_index = char_to_index[c]

    return time

-----
def calculate_time(keyboard: str, word: str) -> int:
    # Your code here


************************************
Question ID: 1167
import heapq

def connectSticks(sticks):
    heapq.heapify(sticks)
    cost = 0
    while len(sticks) > 1:
        first = heapq.heappop(sticks)
        second = heapq.heappop(sticks)
        cost += first + second
        heapq.heappush(sticks, first + second)
    return cost

-----
import heapq
    # Your code here


************************************
Question ID: 1168
def duplicateZeros(arr):
    n = len(arr)
    i = 0
    while i < n - 1:
        if arr[i] == 0:
            for j in range(n - 2, i, -1):
                arr[j + 1] = arr[j]
            arr[i + 1] = 0
            i += 2
        else:
            i += 1

-----
def duplicateZeros(arr):
    # Your code here


************************************
Question ID: 1169
from typing import List

def largestValsFromLabels(values: List[int], labels: List[int], numWanted: int, useLimit: int) -> int:
    items = sorted(zip(values, labels), reverse=True)
    label_count = {}
    result = 0
    
    for value, label in items:
        if numWanted > 0 and label_count.get(label, 0) < useLimit:
            result += value
            label_count[label] = label_count.get(label, 0) + 1
            numWanted -= 1
    
    return result

-----
from typing import List
    # Your code here


************************************
Question ID: 1170
def shortest_common_supersequence(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif str1[i - 1] == str2[j - 1]:
                dp[i][j] = 1 + dp[i - 1][j - 1]
            else:
                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1])

    i, j = m, n
    result = []

    while i > 0 and j > 0:
        if str1[i - 1] == str2[j - 1]:
            result.append(str1[i - 1])
            i -= 1
            j -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            j -= 1
            result.append(str2[j])
        else:
            i -= 1
            result.append(str1[i])

    while i > 0:
        i -= 1
        result.append(str1[i])

    while j > 0:
        j -= 1
        result.append(str2[j])

    return "".join(result[::-1])

-----
def shortest_common_supersequence(str1, str2):
    # Your code here


************************************
Question ID: 1171
from collections import deque

def shortestPathBinaryMatrix(grid):
    n = len(grid)
    if grid[0][0] == 1 or grid[n - 1][n - 1] == 1:
        return -1
    q = deque([(0, 0)])
    dirs = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
    grid[0][0] = 1
    steps = 1

    while q:
        size = len(q)
        for _ in range(size):
            x, y = q.popleft()

            if x == n - 1 and y == n - 1:
                return steps

            for dx, dy in dirs:
                newX, newY = x + dx, y + dy

                if 0 <= newX < n and 0 <= newY < n and grid[newX][newY] == 0:
                    q.append((newX, newY))
                    grid[newX][newY] = 1

        steps += 1

    return -1

-----
from collections import deque
    # Your code here


************************************
Question ID: 1175
def numPrimeArrangements(n: int) -> int:
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num ** 0.5) + 1):
            if num % i == 0:
                return False
        return True

    prime_count = sum(1 for i in range(2, n + 1) if is_prime(i))
    composite_count = n - prime_count

    MOD = 10**9 + 7
    res = 1
    for i in range(1, prime_count + 1):
        res = res * i % MOD
    for i in range(1, composite_count + 1):
        res = res * i % MOD

    return res

-----
def numPrimeArrangements(n: int) -> int:
    # Your code here


************************************
Question ID: 1176
def dietPlanPerformance(calories, k, lower, upper):
    points = 0
    T = 0

    for i in range(len(calories)):
        T += calories[i]
        if i >= k:
            T -= calories[i-k]
        if i >= k-1:
            if T < lower: points -= 1
            if T > upper: points += 1

    return points

-----
def dietPlanPerformance(calories, k, lower, upper):
    # Your code here


************************************
Question ID: 1177
def canMakePaliQueries(s, queries):
    answer = []
    prefixSum = [0] * (len(s) + 1)

    for i in range(len(s)):
        prefixSum[i + 1] = prefixSum[i] ^ (1 << (ord(s[i]) - ord('a')))

    for query in queries:
        left, right, k = query
        diffCount = bin(prefixSum[right + 1] ^ prefixSum[left]).count('1')
        answer.append((diffCount // 2) <= k)

    return answer


-----
def canMakePaliQueries(s, queries):
    # Your code here


************************************
Question ID: 1178
def find_num_of_valid_words(words, puzzles):
    result = []
    for puzzle in puzzles:
        count = 0
        puzzle_set = set(puzzle)
        for word in words:
            if puzzle[0] in word:
                if all(c in puzzle_set for c in word):
                    count += 1
        result.append(count)
    return result


-----
def find_num_of_valid_words(words, puzzles):
    # Your code here


************************************
Question ID: 1180
def count_letters(s: str) -> int:
    count = 0
    current = 1

    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            current += 1
        else:
            count += (current * (current + 1)) // 2
            current = 1

    count += (current * (current + 1)) // 2
    return count

-----
def count_letters(s: str) -> int:
    # Your code here


************************************
Question ID: 1181
from collections import defaultdict

def beforeAndAfterPuzzles(phrases):
    first_word_map = defaultdict(set)
    result = set()

    for phrase in phrases:
        first_word = phrase.split(' ')[0]
        first_word_map[first_word].add(phrase)

    for phrase in phrases:
        last_word = phrase.split(' ')[-1]
        if last_word in first_word_map:
            for cur_phrase in first_word_map[last_word]:
                if phrase != cur_phrase:
                    result.add(phrase + cur_phrase[cur_phrase.index(' '):])

    return sorted(list(result))

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1182
def shortestDistance(colors, queries):
    result = []
    positions = [[] for _ in range(3)]

    for i, color in enumerate(colors):
        positions[color - 1].append(i)

    for query in queries:
        index_positions = positions[query[1] - 1]

        if not index_positions:
            result.append(-1)
        else:
            dist = float('inf')

            for pos in index_positions:
                dist = min(dist, abs(pos - query[0]))

            result.append(dist)

    return result

-----
def shortestDistance(colors, queries):
    # Your code here


************************************
Question ID: 1183
def sampleStats(count):
    minVal, maxVal, mode, median, mean = -1, -1, 0, 0, 0
    totalCount, modeCount, curCount = 0, 0, 0
    sum = 0

    for i in range(256):
        if count[i] > 0:
            if minVal == -1:
                minVal = i
            maxVal = i
            sum += i * count[i]
            totalCount += count[i]
            if count[i] > modeCount:
                modeCount = count[i]
                mode = i

    mean = sum / totalCount
    isEven = (totalCount % 2 == 0)
    mid1 = totalCount // 2
    mid2 = mid1 - 1
    if isEven:
        mid2 += 1

    for i in range(256):
        curCount += count[i]
        if isEven and curCount >= mid2:
            median += i
            mid2 = totalCount
            isEven = False

        if curCount >= mid1:
            median += i
            break

    if not isEven:
        median /= 2
    return [minVal, maxVal, mean, median, mode]

-----
def sampleStats(count):
    # Your code here


************************************
Question ID: 1184
def carPooling(trips, capacity):
    stops = [0] * 1001
    for num, start, end in trips:
        stops[start] += num
        stops[end] -= num
    for i in stops:
        capacity -= i
        if capacity < 0:
            return False
    return True

-----
def carPooling(trips, capacity):
    # Your code here


************************************
Question ID: 1185
def day_of_the_week(day, month, year):
    from datetime import date
    days = ["Sunday ", "Monday ", "Tuesday ", "Wednesday ", "Thursday ", "Friday ", "Saturday "]
    return days[date(year, month, day).weekday()]

-----
def day_of_the_week(day, month, year):
    # Your code here


************************************
Question ID: 1186
from threading import Semaphore

class H2O:
    def __init__(self):
        self.hydrogenSemaphore = Semaphore(2)
        self.oxygenSemaphore = Semaphore(1)

    def hydrogen(self, releaseHydrogen):
        self.hydrogenSemaphore.acquire()
        releaseHydrogen()
        self.oxygenSemaphore.release()

    def oxygen(self, releaseOxygen):
        self.oxygenSemaphore.acquire()
        releaseOxygen()
        self.hydrogenSemaphore.release(2)

-----
from threading import Semaphore
    # Your code here


************************************
Question ID: 1187
from threading import Lock

class FooBar:
    def __init__(self, n: int):
        self.n = n
        self.foo_lock = Lock()
        self.bar_lock = Lock()
        self.bar_lock.acquire()

    def foo(self, printFoo) -> None:
        for _ in range(self.n):
            self.foo_lock.acquire()
            printFoo()
            self.bar_lock.release()

    def bar(self, printBar) -> None:
        for _ in range(self.n):
            self.bar_lock.acquire()
            printBar()
            self.foo_lock.release()

-----
from threading import Lock
    # Your code here


************************************
Question ID: 1189
def max_number_of_balloons(text: str) -> int:
    letter_count = [0] * 5
    for c in text:
        if c == 'b': letter_count[0] += 1
        if c == 'a': letter_count[1] += 1
        if c == 'l': letter_count[2] += 1
        if c == 'o': letter_count[3] += 1
        if c == 'n': letter_count[4] += 1
    letter_count[2] //= 2
    letter_count[3] //= 2
    return min(letter_count)

-----
def max_number_of_balloons(text: str) -> int:
    # Your code here


************************************
Question ID: 1190
def reverseParentheses(s: str) -> str:
    stack = []
    for i, c in enumerate(s):
        if c == '(':
            stack.append(i)
        elif c == ')':
            start, end = stack.pop(), i
            # reversal of the substring
            s = s[:start] + s[start+1:end][::-1] + s[end+1:]
    return ''.join(c for c in s if c.isalpha())

-----
def reverseParentheses(s: str) -> str:
    # Your code here


************************************
Question ID: 1191
def kConcatenationMaxSum(arr, k):
    mod = 10**9 + 7
    n = len(arr)
    max_sum, max_left, max_right = 0, 0, 0
    total_sum = sum(arr)
    temp_sum = 0

    for i in range(n):
        temp_sum += arr[i]
        max_sum = max(max_sum, temp_sum)
        temp_sum = max(0, temp_sum)
        max_left = max(max_left, temp_sum)

    temp = total_sum
    for i in range(n - 1, -1, -1):
        temp -= arr[i]
        max_right = max(max_right, temp)

    ans = max(max_sum, max_left + max_right + total_sum * (k - 2), 0)
    return ans % mod

-----
def kConcatenationMaxSum(arr, k):
    # Your code here


************************************
Question ID: 1192
from collections import defaultdict

def criticalConnections(n, connections):
    def dfs(node, parent, depth, rank, graph, result):
        rank[node] = depth
        for neighbor in graph[node]:
            if neighbor == parent:
                continue
            if rank[neighbor] == -1:
                dfs(neighbor, node, depth + 1, rank, graph, result)
            rank[node] = min(rank[node], rank[neighbor])
            if rank[neighbor] == depth + 1:
                result.append((node, neighbor))

    graph = defaultdict(list)
    for fr, to in connections:
        graph[fr].append(to)
        graph[to].append(fr)

    rank = [-1] * n
    result = []
    dfs(0, -1, 0, rank, graph, result)
    return result


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1196
def minHeightShelves(books, shelfWidth):
    n = len(books)
    dp = [1000000] * (n + 1)
    dp[0] = 0
    
    for i in range(1, n + 1):
        width = 0
        height = 0
        j = i
        while j >= 1:
            width += books[j - 1][0]
            height = max(height, books[j - 1][1])
            
            if width <= shelfWidth:
                dp[i] = min(dp[i], dp[j - 1] + height)
            j -= 1
    
    return dp[n]

-----
def minHeightShelves(books, shelfWidth):
    # Your code here


************************************
Question ID: 1197
def parse_bool_expr(expression, pos=None):
    if pos is None:
        pos = [0]
    current = expression[pos[0]]
    pos[0] += 1
    if current == 't': return True
    if current == 'f': return False
    if current == '!':
        pos[0] += 1
        return not parse_bool_expr(expression, pos)
    if current == '&':
        pos[0] += 1
        result = True
        while expression[pos[0]] != ')':
            result &= parse_bool_expr(expression, pos)
            if expression[pos[0]] == ',': pos[0] += 1
    elif current == '|':
        pos[0] += 1
        result = False
        while expression[pos[0]] != ')':
            result |= parse_bool_expr(expression, pos)
            if expression[pos[0]] == ',': pos[0] += 1
    pos[0] += 1
    return result

-----
def parse_bool_expr(expression, pos=None):
    # Your code here


************************************
Question ID: 1198
def smallest_common_element(mat):
    counts = {}
    for row in mat:
        for num in row:
            counts[num] = counts.get(num, 0) + 1
            if counts[num] == len(mat):
                return num
    return -1

-----
def smallest_common_element(mat):
    # Your code here


************************************
Question ID: 1199
import heapq

def min_build_time(blocks, split):
    heapq.heapify(blocks)
    
    while len(blocks) > 1:
        a = heapq.heappop(blocks)
        b = heapq.heappop(blocks)
        heapq.heappush(blocks, b + split)
    
    return blocks[0]

-----
import heapq
    # Your code here


************************************
Question ID: 1200
from typing import List

def minimumAbsDifference(arr: List[int]) -> List[List[int]]:
    arr.sort()
    min_diff = min(arr[i] - arr[i - 1] for i in range(1, len(arr)))

    result = []
    for i in range(1, len(arr)):
        if arr[i] - arr[i - 1] == min_diff:
            result.append([arr[i - 1], arr[i]])

    return result

-----
from typing import List
    # Your code here


************************************
Question ID: 1201
import math

def nthUglyNumber(n, a, b, c):
    left, right = 1, int(2e9)
    lcm_ab, lcm_ac, lcm_bc = a * b // math.gcd(a, b), a * c // math.gcd(a, c), b * c // math.gcd(b, c)
    lcm_abc = a * lcm_bc // math.gcd(a, lcm_bc)

    while left < right:
        mid = left + (right - left) // 2
        count = mid // a + mid // b + mid // c - mid // lcm_ab - mid // lcm_ac - mid // lcm_bc + mid // lcm_abc
        if count < n:
            left = mid + 1
        else:
            right = mid
    return left

-----
import math
    # Your code here


************************************
Question ID: 1202
from collections import defaultdict

class Solution:
    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:
        n = len(s)

        # Initialize the parents array
        p = list(range(n))

        # Helper function to find the parent of an index
        def find(x):
            if p[x] != x:
                p[x] = find(p[x])
            return p[x]

        # Union-find, grouping connected indices together
        for pair in pairs:
            root1 = find(pair[0])
            root2 = find(pair[1])
            if root1 != root2:
                p[root2] = root1
                
        # Group all the characters together according to their representatives (parent)
        groups = defaultdict(list)
        for i in range(n):
            root = find(i)
            groups[root].append(s[i])

        # Sort each group
        for group in groups.values():
            group.sort(reverse=True)

        # Build the result string
        res = []
        for i in range(n):
            root = find(i)
            res.append(groups[root].pop())

        return "".join(res)


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1203
from threading import Condition

class Foo:
    def __init__(self):
        self.order = 1
        self.cv = Condition()

    def first(self):
        with self.cv:
            # printFirst() outputs "first". Do not change or remove this line.
            printFirst()
            self.order = 2
            self.cv.notify_all()

    def second(self):
        with self.cv:
            self.cv.wait_for(lambda: self.order == 2)
            # printSecond() outputs "second". Do not change or remove this line.
            printSecond()
            self.order = 3
            self.cv.notify_all()

    def third(self):
        with self.cv:
            self.cv.wait_for(lambda: self.order == 3)
            # printThird() outputs "third". Do not change or remove this line.
            printThird()

-----
from threading import Condition
    # Your code here


************************************
Question ID: 1206
def corp_flight_bookings(bookings, n):
    answer = [0] * n
    for start, end, seats in bookings:
        answer[start - 1] += seats
        if end < n:
            answer[end] -= seats
    for i in range(1, n):
        answer[i] += answer[i - 1]
    return answer

-----
def corp_flight_bookings(bookings, n):
    # Your code here


************************************
Question ID: 1208
def split_string(seq: str):
    result = [0] * len(seq)
    count = 0

    for i in range(len(seq)):
        if seq[i] == '(':
            result[i] = count % 2
            count += 1
        else:
            count -= 1
            result[i] = count % 2

    return result


-----
def split_string(seq: str):
    # Your code here


************************************
Question ID: 1209
def removeDuplicates(s: str, k: int) -> str:
    stack = []
    for c in s:
        if not stack or stack[-1][0] != c:
            stack.append((c, 1))
        elif stack[-1][1] + 1 != k:
            stack[-1] = (c, stack[-1][1] + 1)
        else:
            stack.pop()
    return ''.join(c * count for c, count in stack)


-----
def removeDuplicates(s: str, k: int) -> str:
    # Your code here


************************************
Question ID: 1210
def trimmed_mean(arr):
    n = len(arr)
    remove = int(n * 0.05)
    arr.sort()
    return sum(arr[remove:n - remove]) / (n - 2 * remove)

-----
def trimmed_mean(arr):
    # Your code here


************************************
Question ID: 1213
def arraysIntersection(arr1, arr2, arr3):
    i, j, k = 0, 0, 0
    result = []
    while i < len(arr1) and j < len(arr2) and k < len(arr3):
        if arr1[i] == arr2[j] and arr2[j] == arr3[k]:
            result.append(arr1[i])
            i, j, k = i + 1, j + 1, k + 1
        else:
            if arr1[i] <= arr2[j] and arr1[i] <= arr3[k]:
                i += 1
            elif arr2[j] <= arr3[k]:
                j += 1
            else:
                k += 1
    return result

-----
def arraysIntersection(arr1, arr2, arr3):
    # Your code here


************************************
Question ID: 1215
def countSteppingNumbers(low, high):
    results = []
    for i in range(low, high+1):
        prev = -1
        j = i
        is_stepping = True
        while j > 0:
            digit = j % 10
            if prev != -1 and abs(prev - digit) != 1:
                is_stepping = False
                break
            prev = digit
            j //= 10
        if is_stepping:
            results.append(i)
    return results

-----
def countSteppingNumbers(low, high):
    # Your code here


************************************
Question ID: 1216
from threading import Lock

class ZeroEvenOdd:
    def __init__(self, n):
        self.n = n
        self.cnt = 1
        self.lock = Lock()

    def zero(self, printNumber):
        for i in range(1, self.n + 1):
            with self.lock:
                while self.cnt % 2 == 0:
                    self.lock.wait()
                printNumber(0)
                self.cnt += 1
                self.lock.notify_all()

    def even(self, printNumber):
        for i in range(2, self.n + 1, 2):
            with self.lock:
                while self.cnt != 2 * i:
                    self.lock.wait()
                printNumber(i)
                self.cnt += 1
                self.lock.notify_all()

    def odd(self, printNumber):
        for i in range(1, self.n + 1, 2):
            with self.lock:
                while self.cnt != 2 * i - 1:
                    self.lock.wait()
                printNumber(i)
                self.cnt += 1
                self.lock.notify_all()

-----
from threading import Lock
    # Your code here


************************************
Question ID: 1217
def sort_array(arr1, arr2):
    counts = {}
    result = []

    for num in arr1:
        counts[num] = counts.get(num, 0) + 1

    for num in arr2:
        if num in counts:
            result.extend([num] * counts[num])
            del counts[num]

    for num in sorted(counts.keys()):
        result.extend([num] * counts[num])

    return result

-----
def sort_array(arr1, arr2):
    # Your code here


************************************
Question ID: 1219
def longest_wpi(hours):
    score = 0
    max_length = 0
    first_occurrence = {}

    for i, h in enumerate(hours):
        score += 1 if h > 8 else -1
        if score > 0:
            max_length = i + 1
        else:
            if score not in first_occurrence:
                first_occurrence[score] = i
            if score - 1 in first_occurrence:
                max_length = max(max_length, i - first_occurrence[score - 1])
    return max_length


-----
def longest_wpi(hours):
    # Your code here


************************************
Question ID: 1220
from typing import List

def smallestSufficientTeam(req_skills: List[str], people: List[List[str]]) -> List[int]:
    skill_to_int = {s: i for i, s in enumerate(req_skills)}
    people_skills = [sum(1 << skill_to_int[skill] for skill in person) for person in people]
        
    n = len(req_skills)
    INF = 64
    dp = [INF] * (1 << n)
    dp[0] = 0
    parent = [None] * (1 << n)
        
    for i, person_skills in enumerate(people_skills):
        for completed_skills in range((1 << n) - 1, -1, -1):
            with_person_skills = completed_skills | person_skills
            if dp[with_person_skills] > dp[completed_skills] + 1:
                dp[with_person_skills] = dp[completed_skills] + 1
                parent[with_person_skills] = completed_skills
                
    ans = [0] * dp[-1]
    cur = (1 << n) - 1
    t = dp[-1] - 1
        
    for i in range(len(people) - 1, -1, -1):
        old = parent[cur]
        diff = cur ^ old
        is_essential = (people_skills[i] & diff) > 0
        if is_essential:
            ans[t] = i
            t -= 1
        cur = old
    return ans

-----
from typing import List
    # Your code here


************************************
Question ID: 1221
def find_special_integer(arr):
    n = len(arr)
    required_count = n // 4
    for i in range(n):
        if arr[i] == arr[i + required_count]:
            return arr[i]
    return -1

-----
def find_special_integer(arr):
    # Your code here


************************************
Question ID: 1222
def remove_covered_intervals(intervals):
    intervals.sort(key=lambda x: (x[0], -x[1]))
    
    count = 0
    end = 0
    for i in intervals:
        if i[1] > end:
            count += 1
            end = i[1]
    return count


-----
def remove_covered_intervals(intervals):
    # Your code here


************************************
Question ID: 1223
def areConnected(n, threshold, queries):
    answer = [False] * len(queries)
    parent = list(range(n + 1))
    rank = [0] * (n + 1)

    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]

    def unite(x, y):
        rootx = find(x)
        rooty = find(y)
        if rootx != rooty:
            if rank[rootx] > rank[rooty]:
                rootx, rooty = rooty, rootx
            parent[rootx] = rooty
            if rank[rootx] == rank[rooty]:
                rank[rooty] += 1

    for i in range(threshold + 1, n + 1):
        for j in range(i * 2, n + 1, i):
            unite(i, j)

    for i, query in enumerate(queries):
        answer[i] = find(query[0]) == find(query[1])

    return answer

-----
def areConnected(n, threshold, queries):
    # Your code here


************************************
Question ID: 1224
def minFallingPathSum(grid):
    n = len(grid)
    for i in range(1, n):
        for j in range(n):
            minVal = float('inf')
            for k in range(n):
                if k == j:
                    continue
                minVal = min(minVal, grid[i - 1][k])
            grid[i][j] += minVal
    return min(grid[n - 1])

-----
def minFallingPathSum(grid):
    # Your code here


************************************
Question ID: 1227
from collections import defaultdict

def num_equiv_domino_pairs(dominoes):
    freq = defaultdict(int)
    result = 0
    for domino in dominoes:
        key = min(domino[0], domino[1]) * 10 + max(domino[0], domino[1])
        result += freq[key]
        freq[key] += 1
    return result

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1228
def mctFromLeafValues(arr: List[int]) -> int:
    n = len(arr)
    dp = [[0] * n for _ in range(n)]
    maxs = [[0] * n for _ in range(n)]

    for i in range(n):
        for j in range(i, n):
            maxs[i][j] = max(arr[i:j+1])

    for len_ in range(1, n):
        for i in range(n - len_):
            j = i + len_
            dp[i][j] = float('inf')
            for k in range(i, j):
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + maxs[i][k] * maxs[k+1][j])

    return dp[0][n - 1]

-----
def mctFromLeafValues(arr: List[int]) -> int:
    # Your code here


************************************
Question ID: 1229
from collections import defaultdict, deque

def shortestAlternatingPaths(n, redEdges, blueEdges):
    adj_list = defaultdict(lambda: defaultdict(set))
    
    for u, v in redEdges:
        adj_list[u][0].add(v)
        
    for u, v in blueEdges:
        adj_list[u][1].add(v)
        
    dist = [[-1] * 2 for _ in range(n)]
    dist[0] = [0, 0]
    
    q = deque([(0,0), (0,1)])

    while q:
        node, color = q.popleft()
        next_color = color ^ 1
        
        for neighbor in adj_list[node][next_color]:
            if dist[neighbor][next_color] == -1:
                dist[neighbor][next_color] = dist[node][color] + 1
                q.append((neighbor, next_color))
                
    result = []
    for a, b in dist:
        result.append(min(a, b) if a != -1 and b != -1 else max(a, b))
        
    return result


-----
from collections import defaultdict, deque
    # Your code here


************************************
Question ID: 1230
def max_value(arr1, arr2):
    n = len(arr1)
    max1 = max2 = max3 = max4 = float('-inf')
    min1 = min2 = min3 = min4 = float('inf')

    for i in range(n):
        max1 = max(max1, arr1[i] - arr2[i] + i)
        max2 = max(max2, arr1[i] + arr2[i] + i)
        max3 = max(max3, -arr1[i] + arr2[i] + i)
        max4 = max(max4, -arr1[i] - arr2[i] + i)

        min1 = min(min1, arr1[i] - arr2[i] + i)
        min2 = min(min2, arr1[i] + arr2[i] + i)
        min3 = min(min3, -arr1[i] + arr2[i] + i)
        min4 = min(min4, -arr1[i] - arr2[i] + i)

    return max(max1 - min1, max2 - min2, max3 - min3, max4 - min4)


-----
def max_value(arr1, arr2):
    # Your code here


************************************
Question ID: 1231
def replaceElements(arr):
    n = len(arr)
    maxElement = -1
    for i in range(n - 1, -1, -1):
        temp = arr[i]
        arr[i] = maxElement
        maxElement = max(maxElement, temp)
    return arr

-----
def replaceElements(arr):
    # Your code here


************************************
Question ID: 1232
def findBestValue(arr, target):
    left = 0
    right = max(arr)
    result = -1
    min_diff = float('inf')

    while left <= right:
        mid = left + (right - left) // 2
        total_sum = sum(min(x, mid) for x in arr)
        if total_sum == target:
            return mid
        elif total_sum > target:
            right = mid - 1
        else:
            left = mid + 1

        if abs(target - total_sum) < min_diff or (
                abs(target - total_sum) == min_diff and mid < result):
            min_diff = abs(target - total_sum)
            result = mid

    return result

-----
def findBestValue(arr, target):
    # Your code here


************************************
Question ID: 1233
from typing import List

def removeSubfolders(folder: List[str]) -> List[str]:
    result = []
    folder.sort()
    prefix = "/"
    
    for path in folder:
        if not path.startswith(prefix):
            result.append(path)
            prefix = path + "/"
    return result

-----
from typing import List
    # Your code here


************************************
Question ID: 1234
def getMaxSumAndCount(board):
    mod = 1000000007
    n = len(board)
    dp = [[(0, 0) for _ in range(n)] for _ in range(n)]
    dp[n - 1][n - 1] = (0, 1)

    for i in range(n - 1, -1, -1):
        for j in range(n - 1, -1, -1):
            if board[i][j] == 'X' or (i == n - 1 and j == n - 1):
                continue
            currVal = 0 if board[i][j] == 'E' else int(board[i][j])
            up = dp[i - 1][j] if i > 0 else (-1, 0)
            left = dp[i][j - 1] if j > 0 else (-1, 0)
            diag = dp[i - 1][j - 1] if i > 0 and j > 0 else (-1, 0)

            maxTuple = max(up, left, diag)
            if maxTuple[0] == -1:
                continue

            dp[i][j] = (maxTuple[0] + currVal, dp[i][j][1])

            if up == maxTuple:
                dp[i][j] = (dp[i][j][0], (dp[i][j][1] + up[1]) % mod)
            if left == maxTuple:
                dp[i][j] = (dp[i][j][0], (dp[i][j][1] + left[1]) % mod)
            if diag == maxTuple:
                dp[i][j] = (dp[i][j][0], (dp[i][j][1] + diag[1]) % mod)

    return dp[0][0]


-----
def getMaxSumAndCount(board):
    # Your code here


************************************
Question ID: 1235
from bisect import bisect_left

def jobScheduling(startTime, endTime, profit):
    jobs = sorted(zip(endTime, startTime, profit))
    dp = [jobs[0][2]]
    
    def latestNonConflict(index):
        startTimeToFind = jobs[index][1]
        index = bisect_left([job[0] for job in jobs], startTimeToFind)
        if index:
            return index - 1
        return -1

    for i in range(1, len(jobs)):
        L = latestNonConflict(i)
        dp.append(max(dp[-1], (0 if L == -1 else dp[L]) + jobs[i][2]))

    return dp[-1]

-----
from bisect import bisect_left
    # Your code here


************************************
Question ID: 1236
def tribonacci(n: int) -> int:
    if n == 0: return 0
    if n == 1 or n == 2: return 1
    a, b, c = 0, 1, 1
    for _ in range(3, n + 1):
        a, b, c = b, c, a + b + c
    return c

-----
def tribonacci(n: int) -> int:
    # Your code here


************************************
Question ID: 1237
def findSolution(customfunction: 'CustomFunction', z: int) -> List[List[int]]:
    results = []
    for x in range(1, 1001):
        for y in range(1, 1001):
            if customfunction.f(x, y) == z:
                results.append([x, y])
            elif customfunction.f(x, y) > z:
                break
    return results

-----
def findSolution(customfunction: 'CustomFunction', z: int) -> List[List[int]]:
    # Your code here


************************************
Question ID: 1238
def alphabet_board_path(target: str) -> str:
    startX, startY = 0, 0
    result = []

    for t in target:
        targetX, targetY = divmod(ord(t) - ord('a'), 5)
        while startX > targetX:
            result.append('U')
            startX -= 1
        while startY > targetY:
            result.append('L')
            startY -= 1
        while startX < targetX:
            result.append('D')
            startX += 1
        while startY < targetY:
            result.append('R')
            startY += 1
        result.append('!')

    return ''.join(result)


-----
def alphabet_board_path(target: str) -> str:
    # Your code here


************************************
Question ID: 1239
def largest1BorderedSquare(grid):
    m, n = len(grid), len(grid[0])
    horizontal, vertical = [[0] * n for _ in range(m)], [[0] * n for _ in range(m)]

    max_square_size = 0

    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                horizontal[i][j] = 1 if j == 0 else horizontal[i][j - 1] + 1
                vertical[i][j] = 1 if i == 0 else vertical[i - 1][j] + 1

                min_size = min(horizontal[i][j], vertical[i][j])
                while min_size > max_square_size:
                    if (horizontal[i - min_size + 1][j] >= min_size and
                        vertical[i][j - min_size + 1] >= min_size):
                        max_square_size = min_size
                    min_size -= 1

    return max_square_size * max_square_size

-----
def largest1BorderedSquare(grid):
    # Your code here


************************************
Question ID: 1240
from functools import lru_cache

def stoneGameII(piles):
    n = len(piles)
    for i in range(n - 2, -1, -1):
        piles[i] += piles[i + 1]

    @lru_cache(None)
    def search(idx, M):
        if idx + 2 * M >= n:
            return piles[idx]
        return max(piles[idx] - search(idx + x, max(M, x)) for x in range(1, 2 * M + 1))

    return search(0, 1)

-----
from functools import lru_cache
    # Your code here


************************************
Question ID: 1243
def sumEvenGrandparent(root, parent=None, grandparent=None):
    if not root:
        return 0
    sum = 0
    if grandparent and grandparent.val % 2 == 0:
        sum += root.val
    sum += sumEvenGrandparent(root.left, root, parent) + sumEvenGrandparent(root.right, root, parent)
    return sum

-----
def sumEvenGrandparent(root, parent=None, grandparent=None):
    # Your code here


************************************
Question ID: 1244
def num_distinct_repeated_substrings(s):
    seen = set()
    for length in range(len(s) // 2, 0, -1):
        for i in range(len(s) - 2 * length + 1):
            substr = s[i:i + length]
            if substr in s[i + length:]:
                seen.add(substr)
    return len(seen)


-----
def num_distinct_repeated_substrings(s):
    # Your code here


************************************
Question ID: 1245
from collections import deque, defaultdict

def tree_diameter(edges):
    tree = defaultdict(list)
    for edge in edges:
        tree[edge[0]].append(edge[1])
        tree[edge[1]].append(edge[0])

    queue = deque([(0, 0)])
    furthest, max_distance = 0, 0
    while queue:
        node, distance = queue.popleft()
        if distance > max_distance:
            max_distance = distance
            furthest = node
        for neighbor in tree[node]:
            tree[neighbor].remove(node)
            queue.append((neighbor, distance + 1))

    queue.append((furthest, 0))
    max_distance = 0
    while queue:
        node, distance = queue.popleft()
        if distance > max_distance:
            max_distance = distance
        for neighbor in tree[node]:
            tree[neighbor].remove(node)
            queue.append((neighbor, distance + 1))

    return max_distance

-----
from collections import deque, defaultdict
    # Your code here


************************************
Question ID: 1246
def minimumMoves(arr):
    def minRemovals(i, j):
        if i > j:
            return 0
        if i == j:
            return 1
        if dp[i][j] != -1:
            return dp[i][j]

        ans = minRemovals(i + 1, j) + 1
        for k in range(i + 1, j + 1):
            if arr[i] == arr[k]:
                ans = min(ans, minRemovals(i + 1, k - 1) + minRemovals(k + 1, j))
        dp[i][j] = ans
        return ans

    dp = [[-1] * len(arr) for _ in range(len(arr))]
    return minRemovals(0, len(arr) - 1)

-----
def minimumMoves(arr):
    # Your code here


************************************
Question ID: 1247
def moves_to_make_zigzag(nums):
    moves1, moves2 = 0, 0
    for i in range(len(nums)):
        left = nums[i - 1] if i > 0 else float('inf')
        right = nums[i + 1] if i + 1 < len(nums) else float('inf')
        diff1 = nums[i] - min(left, right) + 1
        diff2 = nums[i] - min(left, right) + 1
        if i % 2 == 0:
            moves1 += max(0, diff1)
        else:
            moves2 += max(0, diff2)
    return min(moves1, moves2)

-----
def moves_to_make_zigzag(nums):
    # Your code here


************************************
Question ID: 1250
from math import gcd
from functools import reduce

def isGoodArray(nums):
    return reduce(gcd, nums) == 1

-----
from math import gcd
    # Your code here


************************************
Question ID: 1252
def break_palindrome(palindrome: str) -> str:
    n = len(palindrome)
    if n < 2:
        return ""
    
    palindrome = list(palindrome)
    for i in range(n // 2):
        if palindrome[i] != 'a':
            palindrome[i] = 'a'
            return "".join(palindrome)
    
    palindrome[-1] = 'b'
    return "".join(palindrome)

-----
def break_palindrome(palindrome: str) -> str:
    # Your code here


************************************
Question ID: 1253
from heapq import heappush, heappop

def diagonalSort(mat):
    m, n = len(mat), len(mat[0])
    for i in range(m):
        pq = []
        row, col = i, 0
        while row < m and col < n:
            heappush(pq, mat[row][col])
            row += 1
            col += 1
        row, col = i, 0
        while row < m and col < n:
            mat[row][col] = heappop(pq)
            row += 1
            col += 1
        
    for i in range(1, n):
        pq = []
        row, col = 0, i
        while row < m and col < n:
            heappush(pq, mat[row][col])
            row += 1
            col += 1
        row, col = 0, i
        while row < m and col < n:
            mat[row][col] = heappop(pq)
            row += 1
            col += 1
    return mat


-----
from heapq import heappush, heappop
    # Your code here


************************************
Question ID: 1254
def closedIsland(grid):
    def dfs(grid, i, j):
        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]):
            return False

        if grid[i][j] == 1:
            return True

        grid[i][j] = 1

        up = dfs(grid, i - 1, j)
        down = dfs(grid, i + 1, j)
        left = dfs(grid, i, j - 1)
        right = dfs(grid, i, j + 1)

        return up and down and left and right

    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 0 and dfs(grid, i, j):
                count += 1

    return count


-----
def closedIsland(grid):
    # Your code here


************************************
Question ID: 1255
def maxValueAfterReverse(nums):
    total, diff = 0, 0
    min2, max2 = float('inf'), float('-inf')
    for i in range(len(nums) - 1):
        total += abs(nums[i] - nums[i + 1])
        min2 = min(min2, max(nums[i], nums[i + 1]))
        max2 = max(max2, min(nums[i], nums[i + 1]))
        diff = max(diff, abs(nums[i + 1] - nums[0]) - abs(nums[i + 1] - nums[i]))
        diff = max(diff, abs(nums[i] - nums[-1]) - abs(nums[i] - nums[i + 1]))
    return total + max(diff, 2 * (max2 - min2))

-----
def maxValueAfterReverse(nums):
    # Your code here


************************************
Question ID: 1256
def arrayRankTransform(arr):
    sorted_arr = sorted(arr)
    rank_map = {}
    rank = 1

    for num in sorted_arr:
        if num not in rank_map:
            rank_map[num] = rank
            rank += 1

    return [rank_map[num] for num in arr]

-----
def arrayRankTransform(arr):
    # Your code here


************************************
Question ID: 1257
from collections import deque
from itertools import chain

def matrix_rank_transform(matrix):
    def neighbours(r, c):
        for i in range(m):
            if i != r:
                yield i, c
        for i in range(n):
            if i != c:
                yield r, i

    m, n = len(matrix), len(matrix[0])
    rank = [[0] * n for _ in range(m)]
    sorted_row = [0] * m
    sorted_col = [0] * n

    for bound in range(200001):
        q = deque((r, c) for r in range(m) for c in range(n) if matrix[r][c] == bound and rank[r][c] == 0)
        if not q:
            break
        while q:
            r, c = rc = q.popleft()
            potential_rank = sorted_row[r] + 1
            for row, col in neighbours(r, c):
                if matrix[row][col] <= matrix[r][c]:
                    potential_rank = max(potential_rank, rank[row][col] + (matrix[row][col] < matrix[r][c]))
            if potential_rank == sorted_col[c] + 1:
                rank[r][c] = sorted_row[r] = sorted_col[c] = potential_rank
            else:
                q.append(rc)
    return rank

-----
from collections import deque
    # Your code here


************************************
Question ID: 1258
from typing import List


def generateSentences(synonyms: List[List[str]], text: str) -> List[str]:
    synonym_map = {}

    for s, t in synonyms:
        if s not in synonym_map:
            synonym_map[s] = {s}
        if t not in synonym_map:
            synonym_map[t] = {t}
        synonym_map[s].add(t)
        synonym_map[t].add(s)

    words = text.split()
    results = []

    def helper(index: int, cur_sentence: List[str]) -> None:
        if index == len(words):
            results.append(" ".join(cur_sentence))
            return
        for w in synonym_map.get(words[index], {words[index]}):
            cur_sentence.append(w)
            helper(index + 1, cur_sentence)
            cur_sentence.pop()

    helper(0, [])

    return sorted(results)


-----
from typing import List
    # Your code here


************************************
Question ID: 1259
def numberOfWays(numPeople: int) -> int:
    MOD = 1000000007
    dp = [0] * (numPeople // 2 + 1)
    dp[0] = 1
    for i in range(1, numPeople // 2 + 1):
        for j in range(1, i + 1):
            dp[i] = (dp[i] + dp[i - j] * dp[j - 1]) % MOD
    return dp[numPeople // 2]


-----
def numberOfWays(numPeople: int) -> int:
    # Your code here


************************************
Question ID: 1260
def dayOfYear(date: str) -> int:
    year, month, day = map(int, date.split('-'))

    daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):
        daysInMonth[2] = 29

    dayOfYear = sum(daysInMonth[:month]) + day
    return dayOfYear

-----
def dayOfYear(date: str) -> int:
    # Your code here


************************************
Question ID: 1262
from collections import defaultdict
from random import randint

class MajorityChecker:
    def __init__(self, arr: List[int]):
        self.arr = arr
        self.positions = defaultdict(list)
        for i, num in enumerate(arr):
            self.positions[num].append(i)

    def query(self, left: int, right: int, threshold: int) -> int:
        for _ in range(20):
            randomIndex = randint(left, right)
            num = self.arr[randomIndex]
            lb = self.lower_bound(self.positions[num], left)
            ub = self.upper_bound(self.positions[num], right)
            if ub - lb >= threshold:
                return num
        return -1

    def lower_bound(self, nums, target):
        l, r = 0, len(nums)
        while l < r:
            mid = (l + r) // 2
            if nums[mid] < target:
                l = mid + 1
            else:
                r = mid
        return l

    def upper_bound(self, nums, target):
        l, r = 0, len(nums)
        while l < r:
            mid = (l + r) // 2
            if nums[mid] <= target:
                l = mid + 1
            else:
                r = mid
        return l

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1263
def numRollsToTarget(n, k, target):
    MOD = 10**9 + 7
    dp = [[0] * (target + 1) for _ in range(n + 1)]
    dp[0][0] = 1
    
    for i in range(1, n + 1):
        for j in range(1, target + 1):
            for l in range(1, k + 1):
                if j >= l:
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - l]) % MOD
    return dp[n][target]

-----
def numRollsToTarget(n, k, target):
    # Your code here


************************************
Question ID: 1265
def printLinkedListInReverse(head: 'ImmutableListNode') -> None:
    if head is not None:
        printLinkedListInReverse(head.getNext())
        head.printValue()

-----
def printLinkedListInReverse(head: 'ImmutableListNode') -> None:
    # Your code here


************************************
Question ID: 1266
def minTimeToVisitAllPoints(points):
    time = 0
    for i in range(1, len(points)):
        dx = abs(points[i][0] - points[i - 1][0])
        dy = abs(points[i][1] - points[i - 1][1])
        time += max(dx, dy)
    return time

-----
def minTimeToVisitAllPoints(points):
    # Your code here


************************************
Question ID: 1267
def remove_zero_sum_sublists(head):
    dummy = ListNode(0)
    dummy.next = head
    current = dummy

    while current:
        sum = 0
        while head:
            sum += head.val
            if sum == 0:
                current.next = head.next
            head = head.next
        current = current.next
        if current:
            head = current.next

    return dummy.next


-----
def remove_zero_sum_sublists(head):
    # Your code here


************************************
Question ID: 1268
def suggestedProducts(products, searchWord):
    result = []
    products.sort()
    
    for i in range(len(searchWord)):
        suggestions = []
        for product in products:
            if len(product) > i and product[i] == searchWord[i]:
                suggestions.append(product)
                if len(suggestions) == 3:
                    break
        result.append(suggestions)
    
    return result


-----
def suggestedProducts(products, searchWord):
    # Your code here


************************************
Question ID: 1269
from functools import lru_cache

mod = 10**9 + 7

def numOfWays(steps: int, arrLen: int) -> int:
    @lru_cache(None)
    def dp(s, p):
        if p < 0 or p >= arrLen or p > steps - p:
            return 0
        if s == 0:
            return p == 0
        return (dp(s - 1, p - 1) + dp(s - 1, p) + dp(s - 1, p + 1)) % mod

    return dp(steps, 0)


-----
from functools import lru_cache
    # Your code here


************************************
Question ID: 1271
def to_hexspeak(num: str) -> str:
    n = int(num)
    hex_str = []
    while n:
        rem = n % 16
        if rem == 1: hex_str.insert(0, 'I')
        elif rem == 0: hex_str.insert(0, 'O')
        elif rem > 9: hex_str.insert(0, chr(rem - 10 + ord('A')))
        else: return 'ERROR'
        n //= 16
    return ''.join(hex_str)

-----
def to_hexspeak(num: str) -> str:
    # Your code here


************************************
Question ID: 1272
def invalid_transactions(transactions):
    trans_map = {}
    
    for trans in transactions:
        temp = trans.split(",")
        trans_map.setdefault(temp[0], []).append(temp)
    
    ans = []

    for trans in transactions:
        temp = trans.split(",")

        if int(temp[2]) > 1000:
            ans.append(trans)
            continue

        for other in trans_map[temp[0]]:
            if other[3] != temp[3] and abs(int(other[1]) - int(temp[1])) <= 60:
                ans.append(trans)
                break

    return ans


-----
def invalid_transactions(transactions):
    # Your code here


************************************
Question ID: 1273
def countSmallerFrequencies(words, queries):
    freqWords = [word.count(min(word)) for word in words]
    
    ans = []
    for query in queries:
        freqQuery = query.count(min(query))
        ans.append(sum(f > freqQuery for f in freqWords))
        
    return ans

-----
def countSmallerFrequencies(words, queries):
    # Your code here


************************************
Question ID: 1274
from datetime import datetime

def countDaysBetweenDates(date1, date2):
    d1 = datetime.strptime(date1, "%Y-%m-%d")
    d2 = datetime.strptime(date2, "%Y-%m-%d")
    return abs((d2 - d1).days)

-----
from datetime import datetime
    # Your code here


************************************
Question ID: 1275
def validateBinaryTreeNodes(n, leftChild, rightChild):
    parent = [-1] * n
    for i in range(n):
        if leftChild[i] != -1:
            if parent[leftChild[i]] != -1:
                return False
            parent[leftChild[i]] = i
        if rightChild[i] != -1:
            if parent[rightChild[i]] != -1:
                return False
            parent[rightChild[i]] = i
    
    root = -1
    for i in range(n):
        if parent[i] == -1:
            if root != -1:
                return False
            root = i

    return root != -1

-----
def validateBinaryTreeNodes(n, leftChild, rightChild):
    # Your code here


************************************
Question ID: 1276
def closest_factors(num):
    factor1 = int((num + 2) ** 0.5)
    while True:
        factor2 = (num + 2) // factor1
        if factor1 * factor2 == num + 2:
            return factor1, factor2
        factor2 = (num + 1) // factor1
        if factor1 * factor2 == num + 1:
            return factor1, factor2
        factor1 -= 1

-----
def closest_factors(num):
    # Your code here


************************************
Question ID: 1277
def largest_multiple_of_three(digits):
    count = [0] * 3
    num_sum = sum(digits)
    
    for d in digits:
        count[d % 3] += 1

    if num_sum % 3 == 1:
        if count[1] >= 1:
            count[1] -= 1
        else:
            count[2] -= 2
    elif num_sum % 3 == 2:
        if count[2] >= 1:
            count[2] -= 1
        else:
            count[1] -= 2

    res = ""
    for i in range(10):
        res += str(i) * count[i % 3]
    
    if res and res[-1] == "0":
        return "0"
    return res[::-1]

-----
def largest_multiple_of_three(digits):
    # Your code here


************************************
Question ID: 1278
def palindromePartition(s: str, k: int) -> int:
    n = len(s)
    dp = [[0] * n for _ in range(n)]

    for len in range(2, n + 1):
        for i in range(n - len + 1):
            j = i + len - 1
            dp[i][j] = dp[i + 1][j - 1] + (s[i] != s[j])

    memo = [float('inf')] * n
    for i in range(n):
        if dp[0][i] == 0:
            memo[i] = 0
        else:
            for j in range(i):
                memo[i] = min(memo[i], memo[j] + dp[j + 1][i])

    return memo[-1] + k



-----
def palindromePartition(s: str, k: int) -> int:
    # Your code here


************************************
Question ID: 1281
def can_make_pali_queries(s, queries):
    result = []
    for left, right, k in queries:
        count = [0] * 26
        for i in range(left, right + 1):
            count[ord(s[i]) - ord('a')] += 1
        odd_count = sum(c % 2 for c in count)
        result.append(odd_count // 2 <= k)
    return result

-----
def can_make_pali_queries(s, queries):
    # Your code here


************************************
Question ID: 1282
from collections import defaultdict

def groupThePeople(groupSizes):
    groups = defaultdict(list)
    result = []

    for i, size in enumerate(groupSizes):
        groups[size].append(i)
        if len(groups[size]) == size:
            result.append(groups[size])
            groups[size] = []

    return result

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1283
def format_date(date):
    months = {
        "Jan": "01",
        "Feb": "02",
        "Mar": "03",
        "Apr": "04",
        "May": "05",
        "Jun": "06",
        "Jul": "07",
        "Aug": "08",
        "Sep": "09",
        "Oct": "10",
        "Nov": "11",
        "Dec": "12",
    }

    day, month, year = date.split()
    return f"{year}-{months[month]}-{day}"

-----
def format_date(date):
    # Your code here


************************************
Question ID: 1284
def sum_of_divisors_with_four_divisors(nums):
    total_sum = 0

    for num in nums:
        div_count = 0
        div_sum = 0

        for i in range(1, int(num ** 0.5) + 1):
            if num % i == 0:
                div_sum += i
                div_count += 1

                if num // i != i:
                    div_sum += num // i
                    div_count += 1

            if div_count > 4:
                break

        if div_count == 4:
            total_sum += div_sum

    return total_sum

-----
def sum_of_divisors_with_four_divisors(nums):
    # Your code here


************************************
Question ID: 1286
def max_sum_subsequence(nums: List[int], k: int) -> int:
    n = len(nums)
    dp = [0] * n
    result = 0

    for i in range(n):
        dp[i] = nums[i]
        for j in range(max(0, i - k), i):
            dp[i] = max(dp[i], dp[j] + nums[i])
        result = max(result, dp[i])

    return result

-----
def max_sum_subsequence(nums: List[int], k: int) -> int:
    # Your code here


************************************
Question ID: 1287
def shortest_distance(distance, start, destination):
    total_distance = sum(distance)
    clockwise_distance = sum(distance[start:destination])
    
    return min(clockwise_distance, total_distance - clockwise_distance)

-----
def shortest_distance(distance, start, destination):
    # Your code here


************************************
Question ID: 1288
def maximum_sum(arr):
    n = len(arr)
    sum_without_deletion = [0] * n
    sum_with_deletion = [0] * n
    sum_without_deletion[0] = arr[0]
    sum_with_deletion[0] = 0
    max_sum = arr[0]

    for i in range(1, n):
        sum_without_deletion[i] = max(arr[i], sum_without_deletion[i - 1] + arr[i])
        sum_with_deletion[i] = max(sum_with_deletion[i - 1] + arr[i], sum_without_deletion[i - 1])
        max_sum = max(max_sum, max(sum_without_deletion[i], sum_with_deletion[i]))
    return max_sum

-----
def maximum_sum(arr):
    # Your code here


************************************
Question ID: 1289
def day_of_the_week(day, month, year):
    days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    if month < 3:
        month += 12
        year -= 1
    k = year % 100
    j = year // 100
    day_of_week = (day + 13 * (month + 1) // 5 + k + k // 4 + 5 * j + j // 4) % 7
    return days[day_of_week]

-----
def day_of_the_week(day, month, year):
    # Your code here


************************************
Question ID: 1290
def min_operations(arr1, arr2):
    n = len(arr1)
    dp = [float('inf')] * n
    for a in arr2:
        new_dp = [float('inf')] * n
        p = 0
        for i in range(n):
            if a < arr1[i]:
                new_dp[i] = p
            if i > 0 and dp[i - 1] < p:
                p = dp[i - 1]
            if arr1[i] > arr1[i + 1]:
                return -1
        dp = new_dp
    return dp[-1]

-----
def min_operations(arr1, arr2):
    # Your code here


************************************
Question ID: 1291
def sequential_digits(low, high):
    result = []
    for i in range(1, 10):
        number = i
        for j in range(i + 1, 10):
            number = number * 10 + j
            if low <= number <= high:
                result.append(number)
    return sorted(result)

-----
def sequential_digits(low, high):
    # Your code here


************************************
Question ID: 1292
def maxSideLength(mat: List[List[int]], threshold: int) -> int:
    m, n = len(mat), len(mat[0])
    preSum = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            preSum[i][j] = mat[i - 1][j - 1] + preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1]

    maxSide = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            for k in range(1, min(m, n) + 1):
                endX, endY = i + k - 1, j + k - 1
                if endX <= m and endY <= n:
                    sum = preSum[endX][endY] - preSum[endX][j - 1] - preSum[i - 1][endY] + preSum[i - 1][j - 1]
                    if sum <= threshold:
                        maxSide = max(maxSide, k)
                else:
                    break
    return maxSide


-----
def maxSideLength(mat: List[List[int]], threshold: int) -> int:
    # Your code here


************************************
Question ID: 1293
from collections import deque

def shortestPath(grid, k):
    m, n = len(grid), len(grid[0])
    visited = [[[False for _ in range(k + 1)] for _ in range(n)] for _ in range(m)]
    q = deque([(0, 0, 0, k)])
    moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    steps = 0

    while q:
        for _ in range(len(q)):
            x, y, steps, k_remaining = q.popleft()
            if x == m - 1 and y == n - 1:
                return steps
            for dx, dy in moves:
                new_x, new_y, = x + dx, y + dy
                if 0 <= new_x < m and 0 <= new_y < n:
                    new_k_remaining = k_remaining - grid[new_x][new_y]
                    if new_k_remaining >= 0 and not visited[new_x][new_y][new_k_remaining]:
                        visited[new_x][new_y][new_k_remaining] = True
                        q.append((new_x, new_y, steps + 1, new_k_remaining))
        steps += 1

    return -1

-----
from collections import deque
    # Your code here


************************************
Question ID: 1295
def min_perimeter(neededApples):
    layer = 0
    apples = 0

    while apples < neededApples:
        layer += 1
        apples += 12 * layer

    return 8 * layer

-----
def min_perimeter(neededApples):
    # Your code here


************************************
Question ID: 1297
def maxNumberOfBalloons(text):
    freqs = [0] * 26
    for c in text:
        freqs[ord(c) - ord('a')] += 1
    subs = [freqs[ord('b') - ord('a')], freqs[ord('a') - ord('a')], freqs[ord('l') - ord('a')] // 2, freqs[ord('o') - ord('a')] // 2, freqs[ord('n') - ord('a')]]
    return min(subs)


-----
def maxNumberOfBalloons(text):
    # Your code here


************************************
Question ID: 1298
def reverseParentheses(s: str) -> str:
    st = []
    result = []

    for c in s:
        if c != ')':
            st.append(c)
        else:
            temp = []
            while st and st[-1] != '(':
                temp.append(st.pop())
            if st: st.pop()  # Remove '('
            st.extend(temp)

    result = "".join(st)
    return result


-----
def reverseParentheses(s: str) -> str:
    # Your code here


************************************
Question ID: 1299
def kConcatenationMaxSum(arr, k):
    M = 10**9 + 7
    s = sum(arr)
    max_sum = max_ending_here = 0
    for i in range(len(arr) * min(2, k)):
        max_ending_here = max(arr[i % len(arr)], max_ending_here + arr[i % len(arr)])
        max_sum = max(max_sum, max_ending_here)
    return 0 if k == 1 else (((max_sum - max_ending_here) % M) * (k - 2) % M + max_ending_here) % M

-----
def kConcatenationMaxSum(arr, k):
    # Your code here


************************************
Question ID: 1300
from collections import defaultdict

def criticalConnections(n, connections):
    graph = defaultdict(list)
    for u, v in connections:
        graph[u].append(v)
        graph[v].append(u)

    ans = []
    low, disc = [-1] * n, [-1] * n
    time = [0]

    def dfs(u, parent):
        low[u] = disc[u] = time[0]
        time[0] += 1
        for v in graph[u]:
            if v == parent:
                continue
            if disc[v] == -1:
                dfs(v, u)
                low[u] = min(low[u], low[v])
                if low[v] > disc[u]:
                    ans.append([u, v])
            else:
                low[u] = min(low[u], disc[v])

    dfs(0, -1)
    return ans

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1301
from typing import List

MOD = 10**9 + 7

def pathsWithMaxScore(board: List[str]) -> List[int]:
    n = len(board)
    dp = [[0] * n for _ in range(n)]
    cnt = [[0] * n for _ in range(n)]

    board[0] = list(board[0])
    board[0][0] = '0'
    board[n-1] = list(board[n-1])
    board[n-1][n-1] = '0'
    cnt[n-1][n-1] = 1

    for i in range(n-1, -1, -1):
        for j in range(n-1, -1, -1):
            if board[i][j] != 'X':
                neighbors = [(i-1, j), (i, j-1), (i-1, j-1)]
                for x, y in neighbors:
                    if x >= 0 and y >= 0:
                        if dp[i][j] < dp[x][y] + int(board[i][j]):
                            dp[i][j] = dp[x][y] + int(board[i][j])
                            cnt[i][j] = cnt[x][y]
                        elif dp[i][j] == dp[x][y] + int(board[i][j]):
                            cnt[i][j] = (cnt[i][j] + cnt[x][y]) % MOD

    return [dp[0][0], cnt[0][0]]


-----
from typing import List
    # Your code here


************************************
Question ID: 1302
def make_fancy_string(s: str) -> str:
    result = [s[0]]
    count = 1

    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            count += 1
        else:
            count = 1
        if count < 3:
            result.append(s[i])

    return ''.join(result)


-----
def make_fancy_string(s: str) -> str:
    # Your code here


************************************
Question ID: 1304
from heapq import heappush, heappop

def longestHappyString(a, b, c):
    res = ""
    pq = []
    if a: heappush(pq, (-a, 'a'))
    if b: heappush(pq, (-b, 'b'))
    if c: heappush(pq, (-c, 'c'))

    while pq:
        curr = heappop(pq)
        if len(res) >= 2 and res[-1] == curr[1] and res[-2] == curr[1]:
            if not pq: break
            next = heappop(pq)
            res += next[1]
            if next[0] < -1: heappush(pq, (next[0] + 1, next[1]))
            heappush(pq, curr)
        else:
            res += curr[1]
            if curr[0] < -1: heappush(pq, (curr[0] + 1, curr[1]))

    return res


-----
from heapq import heappush, heappop
    # Your code here


************************************
Question ID: 1305
def people_can_see(heights):
    n = len(heights)
    ans = [0] * n
    st = []

    for i in range(n - 1, -1, -1):
        while st and heights[st[-1]] < heights[i]:
            idx = st.pop()
            ans[i] += 1
            ans[i] += ans[idx]
        st.append(i)

    return ans


-----
def people_can_see(heights):
    # Your code here


************************************
Question ID: 1306
def minimumAbsDifference(arr):
    arr.sort()
    min_difference = float('inf')
    result = []

    for i in range(1, len(arr)):
        difference = arr[i] - arr[i - 1]
        if difference < min_difference:
            min_difference = difference
            result = [[arr[i - 1], arr[i]]]
        elif difference == min_difference:
            result.append([arr[i - 1], arr[i]])

    return result

-----
def minimumAbsDifference(arr):
    # Your code here


************************************
Question ID: 1307
def nthUglyNumber(n, a, b, c):
    from math import gcd

    ab = a * b // gcd(a, b)
    ac = a * c // gcd(a, c)
    bc = b * c // gcd(b, c)
    abc = a * bc // gcd(a, bc)

    left, right = 0, 2 * 10**9
    while left < right:
        mid = left + (right - left) // 2
        cnt = mid // a + mid // b + mid // c - mid // ab - mid // ac - mid // bc + mid // abc
        if cnt < n:
            left = mid + 1
        else:
            right = mid

    return left

-----
def nthUglyNumber(n, a, b, c):
    # Your code here


************************************
Question ID: 1309
from collections import defaultdict, deque

def sortItems(n, m, group, beforeItems):
    def topological_sort(outdegree, edges):
        res = []
        q = deque([i for i in range(len(outdegree)) if outdegree[i] == 0])
        while q:
            u = q.pop()
            res.append(u)
            for v in edges[u]:
                outdegree[v] -= 1
                if outdegree[v] == 0:
                    q.append(v)
        return res

    # Calculate outdegrees and dependencies for groups and items
    group_outdegree = [0] * m
    group_edges = defaultdict(list)

    item_outdegree = [0] * n
    item_edges = defaultdict(list)

    for i in range(n):
        for dep in beforeItems[i]:
            a, b = group[i], group[dep]
            if a != -1 and a != b and not (group_edges[b] and group_edges[b][-1] == a):
                group_edges[b].append(a)
                group_outdegree[a] += 1
            if a != b:
                item_edges[dep].append(i)
                item_outdegree[i] += 1

    group_order = topological_sort(group_outdegree, group_edges)
    if len(group_order) < m:
        return []

    item_order = topological_sort(item_outdegree, item_edges)
    if len(item_order) < n:
        return []

    # Combine orders
    res = [0] * n
    idx = 0
    for gi in group_order:
        for item_idx in item_order:
            if group[item_idx] == gi:
                res[idx] = item_idx
                idx += 1

    return res


-----
from collections import defaultdict, deque
    # Your code here


************************************
Question ID: 1310
def water_plants(plants, capacity):
    steps = 0
    water_left = 0

    for i, plant in enumerate(plants):
        if water_left < plant:
            steps += 2 * i + 1  # Refill the watering can
            water_left = capacity
        water_left -= plant
        steps += 1  # Move to the next plant

    return steps


-----
def water_plants(plants, capacity):
    # Your code here


************************************
Question ID: 1311
def largestMagicSquare(grid):
    m, n = len(grid), len(grid[0])
    row = [[0] * (n + 1) for _ in range(m)]
    col = [[0] * n for _ in range(m + 1)]

    for i in range(m):
        for j in range(n):
            row[i][j + 1] = row[i][j] + grid[i][j]
            col[i + 1][j] = col[i][j] + grid[i][j]

    for k in reversed(range(2, min(m, n) + 1)):
        for i in range(m - k + 1):
            for j in range(n - k + 1):
                _sum = row[i][j + k] - row[i][j]
                ok = all(row[i + t][j + k] - row[i + t][j] == _sum for t in range(1, k)) and all(
                    col[i + k][j + t] - col[i][j + t] == _sum for t in range(1, k))

                if not ok: continue
                
                diag1 = sum(grid[i + t][j + t] for t in range(k))
                diag2 = sum(grid[i + t][j + k - 1 - t] for t in range(k))
                
                if diag1 == _sum and diag2 == _sum: return k

    return 1


-----
def largestMagicSquare(grid):
    # Your code here


************************************
Question ID: 1312
def extract_artifacts(n, artifacts, dig):
    artifact_cells = {}
    artifact_count = {}

    for i, (r1, c1, r2, c2) in enumerate(artifacts):
        for r in range(r1, r2 + 1):
            for c in range(c1, c2 + 1):
                cell = r * n + c
                if cell not in artifact_cells:
                    artifact_cells[cell] = set()
                artifact_cells[cell].add(i)
                artifact_count[i] = artifact_count.get(i, 0) + 1

    ans = 0
    for r, c in dig:
        cell = r * n + c
        if cell in artifact_cells:
            for artifact_id in artifact_cells[cell]:
                artifact_count[artifact_id] -= 1
                if artifact_count[artifact_id] == 0:
                    ans += 1
            del artifact_cells[cell]

    return ans

-----
def extract_artifacts(n, artifacts, dig):
    # Your code here


************************************
Question ID: 1313
MOD = 10**9 + 7

def add_rooms(idx, children, memo):
    if not children[idx]:
        return 1
    if memo[idx] != -1:
        return memo[idx]

    res = 1
    cnt = 0
    for child in children[idx]:
        cnt += 1
        res = (res * add_rooms(child, children, memo)) % MOD
    
    for i in range(2, cnt + 1):
        res = (res * i) % MOD
    
    memo[idx] = res
    return res

def num_of_ways(prev_room):
    n = len(prev_room)
    children = [[] for _ in range(n)]
    for i in range(1, n):
        children[prev_room[i]].append(i)

    memo = [-1] * n
    return add_rooms(0, children, memo)

-----
MOD = 10**9 + 7
    # Your code here


************************************
Question ID: 1314
def matrix_block_sum(mat, k):
    m, n = len(mat), len(mat[0])
    answer = [[0 for _ in range(n)] for _ in range(m)]

    for i in range(m):
        for j in range(n):
            for r in range(max(0, i - k), min(m, i + k + 1)):
                for c in range(max(0, j - k), min(n, j + k + 1)):
                    answer[i][j] += mat[r][c]
                    
    return answer

-----
def matrix_block_sum(mat, k):
    # Your code here


************************************
Question ID: 1317
def no_zero_integers(n: int):
    for a in range(1, n):
        if '0' not in str(a) and '0' not in str(n - a):
            return [a, n - a]
    return [0, 0]  # never gets here

-----
def no_zero_integers(n: int):
    # Your code here


************************************
Question ID: 1318
def minFlips(a: int, b: int, c: int) -> int:
    count = 0
    for i in range(32):
        bitA = (a >> i) & 1
        bitB = (b >> i) & 1
        bitC = (c >> i) & 1
        if bitC == 0:
            count += bitA + bitB
        else:
            count += 1 - (bitA | bitB)
    return count

-----
def minFlips(a: int, b: int, c: int) -> int:
    # Your code here


************************************
Question ID: 1319
def unique_occurrences(arr):
    counts = {}
    for num in arr:
        counts[num] = counts.get(num, 0) + 1
    
    unique_counts = set()
    for count in counts.values():
        if count in unique_counts:
            return False
        unique_counts.add(count)
    
    return True

-----
def unique_occurrences(arr):
    # Your code here


************************************
Question ID: 1320
def removeDuplicates(s: str, k: int) -> str:
    stack = []
    for c in s:
        if stack and stack[-1][0] == c:
            stack[-1][1] += 1
            if stack[-1][1] == k:
                stack.pop()
        else:
            stack.append([c, 1])
    return ''.join(c * n for c, n in stack)

-----
def removeDuplicates(s: str, k: int) -> str:
    # Your code here


************************************
Question ID: 1323
def maximum69Number(num: int) -> int:
    num_str = list(str(num))
    for i in range(len(num_str)):
        if num_str[i] == '6':
            num_str[i] = '9'
            break
    return int(''.join(num_str))

-----
def maximum69Number(num: int) -> int:
    # Your code here


************************************
Question ID: 1324
def findBall(grid):
    m, n = len(grid), len(grid[0])
    result = [-1] * n

    for i in range(n):
        x, y = 0, i

        while x < m:
            nx, ny = x + 1, y + grid[x][y]
            if ny < 0 or ny >= n or grid[x][ny] != grid[x][y]:
                break
            x, y = nx, ny

        if x == m:
            result[i] = y

    return result


-----
def findBall(grid):
    # Your code here


************************************
Question ID: 1325
from heapq import heappush, heappop

def maxProbability(n, edges, succProb, start, end):
    graph = [[] for _ in range(n)]
    for i in range(len(edges)):
        a, b = edges[i]
        graph[a].append((b, succProb[i]))
        graph[b].append((a, succProb[i]))

    max_prob = [0] * n
    max_prob[start] = 1

    pq = [(-1, start)]
    
    while pq:
        prob, node = heappop(pq)

        if node == end:
            return -prob

        if -prob < max_prob[node]:
            continue

        for neighbor, edge_prob in graph[node]:
            new_prob = -prob * edge_prob
            if new_prob > max_prob[neighbor]:
                max_prob[neighbor] = new_prob
                heappush(pq, (-new_prob, neighbor))

    return 0


-----
from heapq import heappush, heappop
    # Your code here


************************************
Question ID: 1326
def sum_of_floored_pairs(nums):
    mod = 10**9 + 7
    max_val = max(nums)
    count = [0] * (max_val + 1)
    pref_sum = [0] * (max_val + 1)

    for num in nums:
        count[num] += 1

    for i in range(1, max_val + 1):
        pref_sum[i] = (pref_sum[i - 1] + count[i]) % mod

    res = 0
    for x in range(1, max_val + 1):
        nx = x
        k = 1
        while nx <= max_val:
            res = (res + ((pref_sum[nx] - pref_sum[nx - x] + mod) % mod) * k % mod * count[x] % mod) % mod
            k += 1
            nx += x
    return res

-----
def sum_of_floored_pairs(nums):
    # Your code here


************************************
Question ID: 1328
def breakPalindrome(palindrome: str) -> str:
    length = len(palindrome)
    if length == 1:
        return ""
    
    chars = list(palindrome)
    for i in range(length // 2):
        if chars[i] != 'a':
            chars[i] = 'a'
            return "".join(chars)
    
    chars[length - 1] = 'b'
    return "".join(chars)

-----
def breakPalindrome(palindrome: str) -> str:
    # Your code here


************************************
Question ID: 1329
def minCostToMoveChips(position):
    evenCount, oddCount = 0, 0
    for i in position:
        if i % 2 == 0:
            evenCount += 1
        else:
            oddCount += 1
    return min(evenCount, oddCount)

-----
def minCostToMoveChips(position):
    # Your code here


************************************
Question ID: 1330
def longestSubsequence(arr, difference):
    dp = {}
    maxLength = 0
    for num in arr:
        dp[num] = dp.get(num - difference, 0) + 1
        maxLength = max(maxLength, dp[num])
    return maxLength


-----
def longestSubsequence(arr, difference):
    # Your code here


************************************
Question ID: 1331
def getMaximumGold(grid):
    m, n, max_gold = len(grid), len(grid[0]), 0

    def getMaximumGoldHelper(x, y):
        if not (0 <= x < m) or not (0 <= y < n) or grid[x][y] == 0:
            return 0

        original_gold = grid[x][y]
        grid[x][y] = 0

        max_gold = 0
        max_gold = max(max_gold, getMaximumGoldHelper(x + 1, y))
        max_gold = max(max_gold, getMaximumGoldHelper(x - 1, y))
        max_gold = max(max_gold, getMaximumGoldHelper(x, y + 1))
        max_gold = max(max_gold, getMaximumGoldHelper(x, y - 1))

        grid[x][y] = original_gold
        return max_gold + original_gold

    for i in range(m):
        for j in range(n):
            if grid[i][j] != 0:
                max_gold = max(max_gold, getMaximumGoldHelper(i, j))

    return max_gold


-----
def getMaximumGold(grid):
    # Your code here


************************************
Question ID: 1332
def countStrings(n):
    mod = 10**9 + 7
    a, b = 1, 1
    for _ in range(n):
        a = (a * 2) % mod
        b = (b * 3) % mod
    return (b - a + mod) % mod


-----
def countStrings(n):
    # Your code here


************************************
Question ID: 1333
def sort_based_on_mapping(mapping, nums):
    def mapped_value(num):
        return int(''.join(str(mapping[int(d)]) for d in str(num)))
    
    return sorted(nums, key=mapped_value)

-----
def sort_based_on_mapping(mapping, nums):
    # Your code here


************************************
Question ID: 1334
def findTheCity(n, edges, distanceThreshold):
    distance = [[1e5] * n for _ in range(n)]

    for edge in edges:
        distance[edge[0]][edge[1]] = edge[2]
        distance[edge[1]][edge[0]] = edge[2]

    for i in range(n):
        distance[i][i] = 0

    for k in range(n):
        for i in range(n):
            for j in range(n):
                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])

    res, minReachable = 0, n
    for i in range(n):
        reachable = sum(1 for j in range(n) if distance[i][j] <= distanceThreshold)
        if reachable <= minReachable:
            minReachable = reachable
            res = i
    return res


-----
def findTheCity(n, edges, distanceThreshold):
    # Your code here


************************************
Question ID: 1335
def max_candies(candies, k):
    left, right = 1, max(candies)
    
    while left <= right:
        mid = left + (right - left) // 2
        count = sum(candy // mid for candy in candies)
        if count >= k:
            left = mid + 1
        else:
            right = mid - 1
    return right

-----
def max_candies(candies, k):
    # Your code here


************************************
Question ID: 1337
from typing import List

def kWeakestRows(mat: List[List[int]], k: int) -> List[int]:
    soldiers_count = [(sum(row), idx) for idx, row in enumerate(mat)]
    soldiers_count.sort()
    return [x[1] for x in soldiers_count[:k]]

-----
from typing import List
    # Your code here


************************************
Question ID: 1338
from collections import Counter
import heapq

def minSetSize(arr):
    freq_map = Counter(arr)
    max_heap = [-cnt for cnt in freq_map.values()]
    heapq.heapify(max_heap)
    half = len(arr) // 2
    cnt = 0
    size = 0
    while size < half:
        size -= heapq.heappop(max_heap)
        cnt += 1
    return cnt

-----
from collections import Counter
    # Your code here


************************************
Question ID: 1340
import threading

class DiningPhilosophers:
    def __init__(self):
        self.forks = [threading.Lock() for _ in range(5)]
        self.not_busy = [threading.Condition(self.forks[i]) for i in range(5)]

    def wantsToEat(self, philosopher: int, pickLeftFork: 'Callable[[], None]', pickRightFork: 'Callable[[], None]', eat: 'Callable[[], None]', putLeftFork: 'Callable[[], None]', putRightFork: 'Callable[[], None]') -> None:
        left_fork = philosopher
        right_fork = (philosopher + 1) % 5

        with self.forks[left_fork]:
            with self.not_busy[left_fork]:
                while not self.forks[right_fork].acquire(blocking=False):
                    self.not_busy[left_fork].wait()
            pickLeftFork()

            with self.forks[right_fork]:
                pickRightFork()
                eat()
                putRightFork()
                self.forks[right_fork].release()
                with self.not_busy[right_fork]:
                    self.not_busy[right_fork].notify_all()

            putLeftFork()
            self.not_busy[left_fork].notify_all()

-----
import threading
    # Your code here


************************************
Question ID: 1342
def queensAttacktheKing(queens, king):
    result = []
    for x in range(-1, 2):
        for y in range(-1, 2):
            if x == 0 and y == 0:
                continue
            posX, posY = king[0] + x, king[1] + y
            while 0 <= posX < 8 and 0 <= posY < 8:
                for queen in queens:
                    if posX == queen[0] and posY == queen[1]:
                        result.append([queen[0], queen[1]])
                        break
                posX += x
                posY += y
    return result

-----
def queensAttacktheKing(queens, king):
    # Your code here


************************************
Question ID: 1343
def dieSimulator(n, rollMax):
    MOD = 10**9 + 7
    dp = [[0] * (n + 1) for _ in range(6)]
    sum_dp = [0] * (n + 1)

    for i in range(6):
        dp[i][1] = 1
    sum_dp[1] = 6

    for j in range(2, n + 1):
        cur_sum = 0
        for i in range(6):
            dp[i][j] = sum_dp[j - 1]
            if j - rollMax[i] - 1 >= 0:
                dp[i][j] = (dp[i][j] - sum_dp[j - rollMax[i] - 1] + MOD) % MOD
                if j - rollMax[i] - 1 >= 1:
                    dp[i][j] = (dp[i][j] + dp[i][j - rollMax[i] - 1]) % MOD
            cur_sum = (cur_sum + dp[i][j]) % MOD
        sum_dp[j] = cur_sum

    return sum_dp[n]

-----
def dieSimulator(n, rollMax):
    # Your code here


************************************
Question ID: 1344
def maxEqualFreq(nums):
    count, freq = {}, {}
    max_len, max_freq = 0, 0
    for i, num in enumerate(nums):
        count[num] = count.get(num, 0) + 1
        freq[count[num] - 1] = freq.get(count[num] - 1, 0) - 1
        freq[count[num]] = freq.get(count[num], 0) + 1

        max_freq = max(max_freq, count[num])
        if max_freq * (i + 1) == i or max_freq * (freq.get(max_freq - 1, 0) + 1) + (max_freq - 1) * freq.get(max_freq - 1, 0) == i:
            max_len = i + 1
    return max_len


-----
def maxEqualFreq(nums):
    # Your code here


************************************
Question ID: 1345
from collections import defaultdict

def minJumps(arr):
    n = len(arr)
    if n <= 1:
        return 0

    value_indices = defaultdict(list)
    
    for i, value in enumerate(arr):
        value_indices[value].append(i)

    q = [0]
    visited = [False] * n
    visited[0] = True
    steps = 0

    while q:
        size = len(q)
        for _ in range(size):
            index = q.pop(0)
            
            if index == n - 1:
                return steps
            
            if index > 0 and not visited[index - 1]:
                q.append(index - 1)
                visited[index - 1] = True
                
            if index < n - 1 and not visited[index + 1]:
                q.append(index + 1)
                visited[index + 1] = True

            for neighbor in value_indices[arr[index]]:
                if not visited[neighbor]:
                    q.append(neighbor)
                    visited[neighbor] = True
            
            value_indices[arr[index]] = []

        steps += 1

    return -1

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1346
def maxValueInStack(nums, k):
    n = len(nums)
    if k >= n:
        return -1

    max_val = float('-inf')
    for i in range(k+1):
        max_val = max(max_val, nums[i])
    return max_val

-----
def maxValueInStack(nums, k):
    # Your code here


************************************
Question ID: 1347
def minSteps(s, t):
    s_Count = [0] * 26
    t_Count = [0] * 26
    for c in s: s_Count[ord(c) - ord('a')] += 1
    for c in t: t_Count[ord(c) - ord('a')] += 1
    res = 0
    for i in range(26):
        res += abs(s_Count[i] - t_Count[i])
    return res // 2

-----
def minSteps(s, t):
    # Your code here


************************************
Question ID: 1348
from collections import defaultdict
from typing import List

class TweetCounts:

    def __init__(self):
        self.data = defaultdict(dict)

    def recordTweet(self, tweetName: str, time: int) -> None:
        if time not in self.data[tweetName]:
            self.data[tweetName][time] = 1
        else:
            self.data[tweetName][time] += 1

    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:
        step = 60 if freq == "minute" else 3600 if freq == "hour" else 86400
        chunks = [0] * ((endTime - startTime) // step + 1)

        if tweetName in self.data:
            for time, count in self.data[tweetName].items():
                chunk_index = (time - startTime) // step
                if 0 <= chunk_index < len(chunks):
                    chunks[chunk_index] += count

        return chunks

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1349
from typing import List

def checkStraightLine(coordinates: List[List[int]]) -> bool:
    dx = coordinates[1][0] - coordinates[0][0]
    dy = coordinates[1][1] - coordinates[0][1]

    for x, y in coordinates[2:]:
        if dx * (y - coordinates[0][1]) != dy * (x - coordinates[0][0]):
            return False

    return True

-----
from typing import List
    # Your code here


************************************
Question ID: 1351
def balanced_string(s):
    n = len(s)
    freq_map = {}
    for c in s:
        freq_map[c] = freq_map.get(c, 0) + 1
    
    i = 0
    result = n
    for j in range(n):
        freq_map[s[j]] -= 1
        while i < n and all(freq_map.get(c, 0) <= n // 4 for c in "QWER"):
            result = min(result, j - i + 1)
            freq_map[s[i]] += 1
            i += 1
    
    return result

-----
def balanced_string(s):
    # Your code here


************************************
Question ID: 1352
from functools import lru_cache

class Job:
    def __init__(self, start, end, profit):
        self.start = start
        self.end = end
        self.profit = profit

def find_next_job(jobs, i):
    for j in range(i + 1, len(jobs)):
        if jobs[j].start >= jobs[i].end:
            return j
    return -1

@lru_cache(None)
def max_profit_helper(jobs, i):
    if i == -1:
        return 0

    next_job = find_next_job(jobs, i)
    incl_curr_job = jobs[i].profit + max_profit_helper(jobs, next_job)
    excl_curr_job = max_profit_helper(jobs, i - 1)
    
    return max(incl_curr_job, excl_curr_job)

def max_profit(startTime, endTime, profit):
    n = len(startTime)
    jobs = [Job(startTime[i], endTime[i], profit[i]) for i in range(n)]

    jobs.sort(key=lambda job: job.end)
    
    return max_profit_helper(tuple(jobs), n - 1)

-----
from functools import lru_cache
    # Your code here


************************************
Question ID: 1353
import heapq

def maxEvents(events: List[List[int]]) -> int:
    events.sort(key=lambda x: x[0])
    min_heap = []
    event_count, day = 0, 0

    for event in events:
        while min_heap and min_heap[0] < event[0]:
            heapq.heappop(min_heap)
        heapq.heappush(min_heap, event[1])
        event_count += 1
        day += 1

    return event_count


-----
import heapq
    # Your code here


************************************
Question ID: 1354
from sortedcontainers import SortedSet

def winners_and_losers(matches):
    winners, losers = SortedSet(), SortedSet()

    for winner, loser in matches:
        winners.add(winner)
        losers.add(loser)

    return [list(winners), list(losers)]

-----
from sortedcontainers import SortedSet
    # Your code here


************************************
Question ID: 1356
def min_moves_to_palindrome(s: str) -> int:
    moves = 0
    s = list(s)
    left, right = 0, len(s) - 1

    while left < right:
        if s[left] != s[right]:
            temp_right = right

            while s[left] != s[temp_right]:
                temp_right -= 1
            s.insert(right, s.pop(temp_right))
            moves += right - temp_right
        left += 1
        right -= 1

    return moves

-----
def min_moves_to_palindrome(s: str) -> int:
    # Your code here


************************************
Question ID: 1358
def find_pairs(z):
    pairs = []
    
    def f(x, y):
        return x + y
    
    for x in range(1, z+1):
        for y in range(1, z+1):
            if f(x, y) == z:
                pairs.append((x, y))
    return pairs

-----
def find_pairs(z):
    # Your code here


************************************
Question ID: 1359
def circular_permutation(n, start):
    result = [start ^ (i ^ (i >> 1)) for i in range(1 << n)]
    return result


-----
def circular_permutation(n, start):
    # Your code here


************************************
Question ID: 1360
def maxLength(arr):
    dp = ['']
    maxLen = 0

    for s in arr:
        if len(set(s)) < len(s): continue
        for i in range(len(dp) - 1, -1, -1):
            tmp = dp[i] + s
            if len(set(tmp)) == len(tmp):
                dp.append(tmp)
                maxLen = max(maxLen, len(tmp))
                
    return maxLen

-----
def maxLength(arr):
    # Your code here


************************************
Question ID: 1361
def tilingRectangle(n, m):
    if n > m:
        n, m = m, n
    if n == 1:
        return m
    if n == m:
        return 1

    res = float('inf')
    for a in range(1, n // 2 + 1):
        res = min(res, tilingRectangle(a, m) + tilingRectangle(n - a, m))

    for b in range(1, m // 2 + 1):
        res = min(res, tilingRectangle(n, b) + tilingRectangle(n, m - b))

    return res


-----
def tilingRectangle(n, m):
    # Your code here


************************************
Question ID: 1362
def findClosestDivisors(num):
    for i in range(int((num + 2) ** 0.5), 0, -1):
        if (num + 1) % i == 0:
            return [i, (num + 1) // i]
        if (num + 2) % i == 0:
            return [i, (num + 2) // i]
    return []

-----
def findClosestDivisors(num):
    # Your code here


************************************
Question ID: 1363
from collections import defaultdict

def largest_multiple_of_three(digits):
    digits.sort(reverse=True)
    sum_digits = sum(digits)

    if sum_digits % 3 == 0:
        return '0' if digits[-1] == 0 else ''.join(map(str, digits))

    mod = defaultdict(list)
    for digit in digits:
        mod[digit % 3].append(digit)

    if sum_digits % 3 == 1:
        if mod[1]:
            mod[1].pop()
        else:
            mod[2].pop(), mod[2].pop()
    else:
        if mod[2]:
            mod[2].pop()
        else:
            mod[1].pop(), mod[1].pop()

    result = "".join(str(digit) for value in mod.values() for digit in value)
    result = "".join(sorted(result, reverse=True))

    return '0' if not result or result[0] == '0' else result


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1365
def smallerNumbersThanCurrent(nums):
    result = []
    for i in range(len(nums)):
        count = 0
        for j in range(len(nums)):
            if i != j and nums[j] < nums[i]:
                count += 1
        result.append(count)
    return result

-----
def smallerNumbersThanCurrent(nums):
    # Your code here


************************************
Question ID: 1366
def rankTeams(votes):
    n, m = len(votes), len(votes[0])
    count = [[0] * m for _ in range(26)]
    res = votes[0]

    for vote in votes:
        for j, team in enumerate(vote):
            count[ord(team) - ord('A')][j] += 1

    return ''.join(sorted(res, key=lambda x: (-count[ord(x) - ord('A')][:m], x)))


-----
def rankTeams(votes):
    # Your code here


************************************
Question ID: 1367
def maxHeight(cuboids):
    cuboids = [sorted(cuboid) for cuboid in cuboids]
    cuboids.sort()

    n = len(cuboids)
    dp = [0] * n
    ans = 0

    for i, cuboid in enumerate(cuboids):
        dp[i] = cuboid[2]
        for j in range(i):
            if all(cuboids[j][k] <= cuboid[k] for k in range(3)):
                dp[i] = max(dp[i], dp[j] + cuboid[2])

        ans = max(ans, dp[i])

    return ans


-----
def maxHeight(cuboids):
    # Your code here


************************************
Question ID: 1368
from collections import deque

def minCost(grid):
    m, n = len(grid), len(grid[0])
    cost = 0

    visited = [[1000000] * n for _ in range(m)]
    q = deque([(0, 0)])
    visited[0][0] = 0

    while q:
        y, x = q.popleft()
        if y == m - 1 and x == n - 1:
            cost = visited[y][x]
            break

        dx = [1, 0, -1, 0]
        dy = [0, 1, 0, -1]

        for dir in range(4):
            newY, newX = y + dy[dir], x + dx[dir]
            if 0 <= newY < m and 0 <= newX < n:
                newCost = visited[y][x] + (1 if dir + 1 != grid[y][x] else 0)
                if newCost < visited[newY][newX]:
                    visited[newY][newX] = newCost
                    q.append((newY, newX))

    return cost

-----
from collections import deque
    # Your code here


************************************
Question ID: 1370
def numberOfSubarrays(nums, k):
    n = len(nums)
    result = count = 0
    odd_count = [0] * (n + 1)

    odd_count[0] = 1
    for num in nums:
        count += num % 2
        if count >= k:
            result += odd_count[count - k]
        odd_count[count] += 1

    return result

-----
def numberOfSubarrays(nums, k):
    # Your code here


************************************
Question ID: 1371
def min_remove_to_make_valid(s: str) -> str:
    stk = []
    result = list(s)

    for i, ch in enumerate(s):
        if ch == '(':
            stk.append(i)
        elif ch == ')':
            if stk:
                stk.pop()
            else:
                result[i] = ''

    for i in stk:
        result[i] = ''

    return ''.join(result)


-----
def min_remove_to_make_valid(s: str) -> str:
    # Your code here


************************************
Question ID: 1372
from math import gcd
from functools import reduce

def is_good_array(nums):
    gcd_value = reduce(gcd, nums)
    return gcd_value == 1


-----
from math import gcd
    # Your code here


************************************
Question ID: 1374
def generateTheString(n: int) -> str:
    result = 'a' * n
    if n % 2 == 0:
        result = result[:-1] + 'b'
    return result

-----
def generateTheString(n: int) -> str:
    # Your code here


************************************
Question ID: 1375
def find_kth_palindrome(k, int_length):
    mid = (int_length + 1) // 2
    limit = 10 ** mid - 1

    i = 0
    while i <= limit:
        num = str(i)
        rev = num[::-1]
        if int_length % 2 != 0:
            rev = rev[1:]
        palindrome = int(num + rev)
        if palindrome > 0:
            k -= 1
        if k == 0:
            return palindrome
        i += 1
    return -1

def palindrome_queries(queries, int_length):
    return [find_kth_palindrome(query, int_length) for query in queries]


-----
def find_kth_palindrome(k, int_length):
    # Your code here


************************************
Question ID: 1376
def numOfMinutes(n, headID, manager, informTime):
    subordinates = [[] for _ in range(n)]
    for i in range(n):
        if manager[i] != -1:
            subordinates[manager[i]].append(i)
    return dfs(headID, subordinates, informTime)

def dfs(employee, subordinates, informTime):
    if informTime[employee] == 0:
        return 0
    max_time = 0
    for i in subordinates[employee]:
        max_time = max(max_time, dfs(i, subordinates, informTime))
    return max_time + informTime[employee]


-----
def numOfMinutes(n, headID, manager, informTime):
    # Your code here


************************************
Question ID: 1377
from collections import defaultdict

def dfs(node, parent, t, target, graph, prob, ans):
    if t == 0:
        if node == target:
            ans[0] += prob
        return

    has_child = False
    for neighbor in graph[node]:
        if neighbor != parent:
            has_child = True
            dfs(neighbor, node, t - 1, target, graph, prob / (len(graph[node]) - (1 if node != 1 else 0)), ans)

    if not has_child and node == target:
        ans[0] += prob

def frogPosition(n, edges, t, target):
    graph = defaultdict(list)
    for a, b in edges:
        graph[a].append(b)
        graph[b].append(a)

    ans = [0.0]
    dfs(1, -1, t, target, graph, 1.0, ans)
    return ans[0]


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1379
def reconstructMatrix(upper, lower, colsum):
    result = [[0] * len(colsum) for _ in range(2)]
    
    for i in range(len(colsum)):
        if colsum[i] == 2:
            result[0][i] = 1
            result[1][i] = 1
            upper -= 1
            lower -= 1
        elif colsum[i] == 1:
            if upper > lower:
                result[0][i] = 1
                upper -= 1
            else:
                result[1][i] = 1
                lower -= 1
        
        if upper < 0 or lower < 0:
            return []
    
    if upper > 0 or lower > 0:
        return []
    
    return result

-----
def reconstructMatrix(upper, lower, colsum):
    # Your code here


************************************
Question ID: 1380
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

def dfs(grid, x, y):
    n, m = len(grid), len(grid[0])
    grid[x][y] = 1
    for i in range(4):
        nx, ny = x + dx[i], y + dy[i]
        if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0:
            dfs(grid, nx, ny)

def closedIsland(grid):
    n, m = len(grid), len(grid[0])
    for i in range(n):
        for j in range(m):
            if i == 0 or i == n - 1 or j == 0 or j == m - 1:
                if grid[i][j] == 0:
                    dfs(grid, i, j)
    res = 0
    for i in range(1, n - 1):
        for j in range(1, m - 1):
            if grid[i][j] == 0:
                dfs(grid, i, j)
                res += 1
    return res


-----
dx = [-1, 1, 0, 0]
    # Your code here


************************************
Question ID: 1381
def get_max_score(word, score):
    return sum(score[ord(c) - ord('a')] for c in word)

def get_max_score_helper(words, score, letters, i):
    if i == len(words):
        return 0
    letters_copy = letters.copy()
    for c in words[i]:
        if letters_copy[c] == 0:
            return get_max_score_helper(words, score, letters, i + 1)
        letters_copy[c] -= 1
    return max(get_max_score(words[i], score) + get_max_score_helper(words, score, letters_copy, i + 1),
               get_max_score_helper(words, score, letters, i + 1))

def max_score_words(words, letters, score):
    letters_count = {}
    for letter in letters:
        letters_count[letter] = letters_count.get(letter, 0) + 1
    return get_max_score_helper(words, score, letters_count, 0)
```
-----
def get_max_score(word, score):
    # Your code here

```
************************************
Question ID: 1383
import heapq
from typing import List

def max_performance(n: int, k: int, speed: List[int], efficiency: List[int]) -> int:
    engineers = sorted(zip(efficiency, speed), reverse=True)
    min_heap = []
    speed_sum = 0
    max_performance = 0

    for e, s in engineers:
        speed_sum += s
        heapq.heappush(min_heap, s)

        if len(min_heap) > k:
            speed_sum -= heapq.heappop(min_heap)

        max_performance = max(max_performance, speed_sum * e)

    return max_performance % (10**9 + 7)

-----
import heapq
    # Your code here


************************************
Question ID: 1385
def findTheDistanceValue(arr1, arr2, d):
    distance = 0
    for a in arr1:
        found = True
        for b in arr2:
            if abs(a - b) <= d:
                found = False
                break
        if found:
            distance += 1
    return distance

-----
def findTheDistanceValue(arr1, arr2, d):
    # Your code here


************************************
Question ID: 1386
def shiftGrid(grid, k):
    m, n = len(grid), len(grid[0])
    k %= (m * n)
    res = [[0] * n for _ in range(m)]
    for i in range(m):
        for j in range(n):
            idx = (i * n + j + k) % (m * n)
            res[idx // n][idx % n] = grid[i][j]
    return res


-----
def shiftGrid(grid, k):
    # Your code here


************************************
Question ID: 1388
def maxSumDivThree(nums):
    dp = [0, 0, 0]
    for num in nums:
        temp = dp[:]
        for s in temp:
            dp[(s + num) % 3] = max(dp[(s + num) % 3], s + num)
    return dp[0]

-----
def maxSumDivThree(nums):
    # Your code here


************************************
Question ID: 1390
def sum_of_four_divisors(nums):
    total_sum = 0
    for num in nums:
        count = 0
        div_sum = 0
        i = 1
        while i * i <= num:
            if num % i == 0:
                count += 1 if i * i == num else 2
                div_sum += i + (num // i)
                if count > 4:
                    break
            i += 1
        if count == 4:
            total_sum += div_sum
    return total_sum

-----
def sum_of_four_divisors(nums):
    # Your code here


************************************
Question ID: 1391
def hasValidPath(grid):
    m, n = len(grid), len(grid[0])

    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]
    allowed = [[], [0, 2], [1, 3], [0, 1], [0, 3], [1, 2], [1, 0]]

    visited = [[False] * n for _ in range(m)]

    def dfs(i, j):
        if i == m - 1 and j == n - 1:
            return True

        visited[i][j] = True
        for dir in allowed[grid[i][j]]:
            x, y = i + directions[dir][0], j + directions[dir][1]
            if 0 <= x < m and 0 <= y < n and not visited[x][y] and (dir + 2) % 4 in allowed[grid[x][y]]:
                if dfs(x, y):
                    return True
        return False

    return dfs(0, 0)

-----
def hasValidPath(grid):
    # Your code here


************************************
Question ID: 1394
def find_lucky(arr):
    freq = {}
    for num in arr:
        freq[num] = freq.get(num, 0) + 1
    max_lucky = -1
    for num, count in freq.items():
        if num == count:
            max_lucky = max(max_lucky, num)
    return max_lucky

-----
def find_lucky(arr):
    # Your code here


************************************
Question ID: 1395
def minTimeToVisitAllPoints(points: List[List[int]]) -> int:
    time = 0
    for i in range(1, len(points)):
        dx = abs(points[i][0] - points[i-1][0])
        dy = abs(points[i][1] - points[i-1][1])
        time += max(dx, dy)
    return time


-----
def minTimeToVisitAllPoints(points: List[List[int]]) -> int:
    # Your code here


************************************
Question ID: 1397
from bisect import bisect_left

def suggestedProducts(products, searchWord):
    products.sort()
    result = []
    current_prefix = ""
    
    for letter in searchWord:
        current_prefix += letter
        index = bisect_left(products, current_prefix)
        suggestions = []
        
        for i in range(3):
            if index < len(products) and products[index].startswith(current_prefix):
                suggestions.append(products[index])
                index += 1
            else:
                break
        
        result.append(suggestions)
    
    return result

-----
from bisect import bisect_left
    # Your code here


************************************
Question ID: 1399
def countLargestGroup(n: int) -> int:
    groups = [0] * 37
    largest_group_size = 0
    count_largest_groups = 0

    for i in range(1, n + 1):
        sum_of_digits = sum(map(int, str(i)))
        groups[sum_of_digits] += 1
        if groups[sum_of_digits] > largest_group_size:
            largest_group_size = groups[sum_of_digits]
            count_largest_groups = 1
        elif groups[sum_of_digits] == largest_group_size:
            count_largest_groups += 1

    return count_largest_groups

-----
def countLargestGroup(n: int) -> int:
    # Your code here


************************************
Question ID: 1400
def tictactoe(moves):
    grid = [[0] * 3 for _ in range(3)]
    player = 1
    for move in moves:
        r, c = move
        grid[r][c] = player
        if (all(grid[i][c] == player for i in range(3)) or
            all(grid[r][i] == player for i in range(3)) or
            (r == c and all(grid[i][i] == player for i in range(3))) or
            (r + c == 2 and all(grid[i][2 - i] == player for i in range(3)))):
            return 'A' if player == 1 else 'B'
        player = 3 - player
    
    return 'Draw' if len(moves) == 9 else 'Pending'


-----
def tictactoe(moves):
    # Your code here


************************************
Question ID: 1401
def checkOverlap(radius, xCenter, yCenter, x1, y1, x2, y2):
    xClosest = max(x1, min(xCenter, x2))
    yClosest = max(y1, min(yCenter, y2))
    return (xCenter - xClosest) ** 2 + (yCenter - yClosest) ** 2 <= radius ** 2

-----
def checkOverlap(radius, xCenter, yCenter, x1, y1, x2, y2):
    # Your code here


************************************
Question ID: 1402
def countSquares(matrix: List[List[int]]) -> int:
    m, n, ans = len(matrix), len(matrix[0]), 0
    dp = [[0] * n for _ in range(m)]
    for i in range(m):
        for j in range(n):
            if i == 0 or j == 0:
                dp[i][j] = matrix[i][j]
            elif matrix[i][j]:
                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1
            ans += dp[i][j]
    return ans

-----
def countSquares(matrix: List[List[int]]) -> int:
    # Your code here


************************************
Question ID: 1403
def min_changes_to_divide_string(s, k):
    n = len(s)
    if n % k != 0:
        return -1
    chunk_count = n // k
    res = 0
    for i in range(k):
        counts = [0] * 26
        for j in range(i, n, k):
            counts[ord(s[j]) - ord('a')] += 1
        max_count = max(counts)
        res += chunk_count - max_count
    return res

-----
def min_changes_to_divide_string(s, k):
    # Your code here


************************************
Question ID: 1404
def num_steps(s: str) -> int:
    steps = 0
    carry = 0
    
    for c in reversed(s[1:]):
        bit = int(c)
        if bit and carry:
            carry = 1
            steps += 2
        elif bit or carry:
            carry ^= 1
            steps += 2
        else:
            steps += 1
            
    return steps + carry

-----
def num_steps(s: str) -> int:
    # Your code here


************************************
Question ID: 1405
import heapq

def longest_diverse_string(a: int, b: int, c: int) -> str:
    result = ""
    pq = [(-a, 'a'), (-b, 'b'), (-c, 'c')]
    heapq.heapify(pq)
    
    while pq:
        first = heapq.heappop(pq)
        if not result or result[-1] != first[1]:
            result += first[1]
            first = (first[0] + 1, first[1])
            if first[0] < 0:
                heapq.heappush(pq, first)
        elif pq:
            second = heapq.heappop(pq)
            result += second[1]
            second = (second[0] + 1, second[1])
            if second[0] < 0:
                heapq.heappush(pq, second)
            if first[0] < 0:
                heapq.heappush(pq, first)
        else:
            break
            
    return result

-----
import heapq
    # Your code here


************************************
Question ID: 1406
def stoneGameIII(stoneValue):
    n = len(stoneValue)
    dp = [float("-inf")] * (n + 1)
    dp[n] = 0
    
    for i in range(n - 1, -1, -1):
        curr = 0
        for j in range(3):
            if i + j < n:
                curr += stoneValue[i + j]
                dp[i] = max(dp[i], curr - dp[i + j + 1])
                
    return "Tie " if dp[0] == 0 else "Alice " if dp[0] > 0 else "Bob "


-----
def stoneGameIII(stoneValue):
    # Your code here


************************************
Question ID: 1408
import math

def smallest_divisor(nums, threshold):
    left, right = 1, 10**6
    while left < right:
        mid = (left + right) // 2
        total = sum(math.ceil(n / mid) for n in nums)
        if total > threshold:
            left = mid + 1
        else:
            right = mid
    return left

-----
import math
    # Your code here


************************************
Question ID: 1409
from collections import deque

def minNumberOfFlips(mat):
    m, n = len(mat), len(mat[0])
    steps = 0
    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 0)]

    def encode(i, j):
        return i * n + j

    while True:
        flipped = 0
        que = deque()

        for i in range(m):
            for j in range(n):
                if mat[i][j] == 1:
                    que.append(encode(i, j))

        while que:
            cur = que.popleft()
            cur_i, cur_j = divmod(cur, n)

            for dx, dy in dirs:
                ni, nj = cur_i + dx, cur_j + dy
                if 0 <= ni < m and 0 <= nj < n:
                    mat[ni][nj] ^= 1
                    flipped += 1

        if flipped == 0:
            break
        steps += flipped

    for row in mat:
        if any(cell == 1 for cell in row):
            return -1

    return steps

-----
from collections import deque
    # Your code here


************************************
Question ID: 1410
def entity_parser(text: str) -> str:
    entities = {
        "&quot;": "\"",
        "&apos;": "'",
        "&amp;": "&",
        "&gt;": ">",
        "&lt;": "<",
        "&frasl;": "/",
    }
    
    result = []
    current_entity = []
    in_entity = False
    
    for c in text:
        if in_entity:
            current_entity.append(c)
            if c == ';':
                entity = ''.join(current_entity)
                if entity in entities:
                    result.append(entities[entity])
                else:
                    result.extend(current_entity)
                in_entity = False
                current_entity.clear()
        else:
            if c == '&':
                in_entity = True
                current_entity.append(c)
            else:
                result.append(c)

    return ''.join(result)

-----
def entity_parser(text: str) -> str:
    # Your code here


************************************
Question ID: 1413
def maxSideLength(mat, threshold):
    m, n = len(mat), len(mat[0])
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    ans = 0

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            dp[i][j] = mat[i - 1][j - 1] + dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1]
            k = ans + 1
            if i >= k and j >= k and dp[i][j] - dp[i][j - k] - dp[i - k][j] + dp[i - k][j - k] <= threshold:
                ans += 1

    return ans

-----
def maxSideLength(mat, threshold):
    # Your code here


************************************
Question ID: 1414
from collections import deque

def shortestPath(grid, k):
    m, n = len(grid), len(grid[0])
    queue = deque([(0, 0, 0, k)])
    visited = [[[False] * (k + 1) for _ in range(n)] for _ in range(m)]

    while queue:
        x, y, step, remaining_k = queue.popleft()

        if x == m - 1 and y == n - 1:
            return step
        if visited[x][y][remaining_k]:
            continue
        visited[x][y][remaining_k] = True

        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

        for dx, dy in directions:
            nx, ny = x + dx, y + dy

            if 0 <= nx < m and 0 <= ny < n:
                if grid[nx][ny] == 1 and remaining_k > 0:
                    queue.append((nx, ny, step + 1, remaining_k - 1))
                elif grid[nx][ny] == 0:
                    queue.append((nx, ny, step + 1, remaining_k))

    return -1

-----
from collections import deque
    # Your code here


************************************
Question ID: 1416
def numDecodings(s: str, k: int) -> int:
    n = len(s)
    dp = [0] * (n + 1)
    dp[n] = 1
    MOD = 1000000007

    for i in range(n - 1, -1, -1):
        num = 0
        for j in range(i, n):
            num = num * 10 + int(s[j])
            if num >= 1 and num <= k:
                dp[i] = (dp[i] + dp[j + 1]) % MOD
            if num > k:
                break

    return dp[0]

-----
def numDecodings(s: str, k: int) -> int:
    # Your code here


************************************
Question ID: 1417
from collections import deque

def reformat(s: str) -> str:
    letters, digits = deque(), deque()

    for c in s:
        if c.isalpha():
            letters.append(c)
        else:
            digits.append(c)

    if abs(len(letters) - len(digits)) > 1:
        return ""

    result = []
    use_letter = len(letters) > len(digits)

    while letters or digits:
        if use_letter:
            result.append(letters.popleft())
        else:
            result.append(digits.popleft())
        use_letter = not use_letter

    return ''.join(result)

-----
from collections import deque
    # Your code here


************************************
Question ID: 1418
from collections import defaultdict
from typing import List

def displayTable(orders: List[List[str]]) -> List[List[str]]:
    tables = defaultdict(lambda: defaultdict(int))
    foodSet = set()

    for order in orders:
        tableNumber = int(order[1])
        foodItem = order[2]
        tables[tableNumber][foodItem] += 1
        foodSet.add(foodItem)

    foodList = sorted(foodSet)
    result = [["Table"] + foodList]

    for tableNumber, table in sorted(tables.items()):
        row = [str(tableNumber)]
        row.extend(str(table[foodItem]) for foodItem in foodList)
        result.append(row)

    return result

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1419
def minNumberOfFrogs(croakOfFrogs: str) -> int:
    counter = [0] * 5
    frogs = max_frogs = 0
    for ch in croakOfFrogs:
        idx = 'croak'.index(ch)
        counter[idx] += 1
        if idx == 0:
            max_frogs = max(max_frogs, frogs + 1)
            frogs += 1
        else:
            counter[idx - 1] -= 1
            if counter[idx - 1] < 0:
                return -1
            if idx == 4:
                frogs -= 1
    return max_frogs if all(count == counter[0] for count in counter) else -1

-----
def minNumberOfFrogs(croakOfFrogs: str) -> int:
    # Your code here


************************************
Question ID: 1420
def waysToBuildArray(n, m, k):
    mod = 10**9 + 7
    dp = [[0] * (k+1) for _ in range(n+1)]
    dp[0][0] = 1
    for i in range(1, n+1):
        for j in range(k+1):
            for x in range(1, m+1):
                if j < i * (x-1):
                    dp[i][j] = (dp[i][j] + dp[i-1][j-(i-1)*(x-1)]) % mod
    return dp[n][k]

-----
def waysToBuildArray(n, m, k):
    # Your code here


************************************
Question ID: 1422
from collections import Counter

def is_possible_divide(nums: List[int], k: int) -> bool:
    counts = Counter(nums)
    
    for key in sorted(counts):
        if counts[key] > 0:
            for i in range(k-1, -1, -1):
                if counts[key+i] < counts[key]:
                    return False
                counts[key+i] -= counts[key]
    
    return True

-----
from collections import Counter
    # Your code here


************************************
Question ID: 1423
def max_substring_occurrences(s: str, k: int) -> int:
    freq = {}
    res = 0
    for c in s:
        freq[c] = freq.get(c, 0) + 1
        if len(freq) <= k:
            res = max(res, freq[c])
    return 0 if len(freq) > k else res


-----
def max_substring_occurrences(s: str, k: int) -> int:
    # Your code here


************************************
Question ID: 1424
from collections import deque

def maxCandies(status, candies, keys, containedBoxes, initialBoxes):
    max_candies = 0
    visited = set()
    to_process = deque(initialBoxes)

    while to_process:
        box = to_process.popleft()

        if box in visited:
            continue

        visited.add(box)

        if status[box]:
            max_candies += candies[box]
            for key in keys[box]:
                status[key] = 1
                if key in visited:
                    to_process.append(key)
            for contained in containedBoxes[box]:
                to_process.append(contained)
        else:
            to_process.append(box)

    return max_candies

-----
from collections import deque
    # Your code here


************************************
Question ID: 1425
def maxSum(nums, k):
    n = len(nums)
    dp = [0] * (n + 1)
    pq = []
    sum_ = 0

    for i in range(n):
        if i >= k:
            pq.remove(-(dp[i] - nums[i]))  # Remove element from pq
        heapq.heappush(pq, -(dp[i] - nums[i]))  # Push in the negative for max heap
        dp[i + 1] = max(dp[i], nums[i] - pq[0])
        sum_ = max(sum_, dp[i + 1])

    return sum_

-----
def maxSum(nums, k):
    # Your code here


************************************
Question ID: 1426
def sum_zero(n):
    res = []
    for i in range(1, (n // 2) + 1):
        res.append(i)
        res.append(-i)
    if n % 2 != 0:
        res.append(0)
    return res

-----
def sum_zero(n):
    # Your code here


************************************
Question ID: 1428
def canReach(arr: List[int], start: int) -> bool:
    if 0 <= start < len(arr) and arr[start] >= 0:
        if arr[start] == 0:
            return True
        
        jump = arr[start]
        arr[start] = -arr[start]
        return canReach(arr, start + jump) or canReach(arr, start - jump)
    return False

-----
def canReach(arr: List[int], start: int) -> bool:
    # Your code here


************************************
Question ID: 1429
def is_solvable(words, result):
    return sum(words.values()) % 10 == result % 10

-----
def is_solvable(words, result):
    # Your code here


************************************
Question ID: 1431
from collections import defaultdict

def find_ancestors(node, adj_list, visited, ans):
    if visited[node]:
        return
    visited[node] = True
    for ancestor in adj_list[node]:
        ans.append(ancestor)
        find_ancestors(ancestor, adj_list, visited, ans)

def find_ancestors_in_dag(n, edges):
    adj_list = defaultdict(list)
    for edge in edges:
        adj_list[edge[1]].append(edge[0])
    ans = []
    for i in range(n):
        visited = [False] * n
        ancestors = []
        find_ancestors(i, adj_list, visited, ancestors)
        ans.append(sorted(ancestors))
    return ans


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1432
def max_diff(num):
    a, b = -1, -1
    num_str = str(num)
    for c in num_str:
        if a == -1 and c != '9':
            a = int(c)
        if b == -1 and c > '1':
            b = int(c)
        if a != -1 and b != -1:
            break
            
    result = 0
    for c in num_str:
        if int(c) == a:
            result = result * 10 + 9
        elif int(c) == b:
            result = result * 10 + (1 if c == num_str[0] else 0)
        else:
            result = result * 10 + int(c)
    return result - num


-----
def max_diff(num):
    # Your code here


************************************
Question ID: 1434
def freqAlphabets(s):
    result = []
    i = 0
    while i < len(s):
        if i + 2 < len(s) and s[i + 2] == '#':
            result.append(chr(ord('a') + int(s[i:i + 2]) - 1))
            i += 3
        else:
            result.append(chr(ord('a') + int(s[i]) - 1))
            i += 1
    return ''.join(result)

-----
def freqAlphabets(s):
    # Your code here


************************************
Question ID: 1436
from collections import deque
from collections import defaultdict

def watched_videos_by_friends(watched_videos, friends, id, level):
    visited = set()
    q = deque([(id, 0)])
    video_freq = defaultdict(int)

    while q:
        current_id, current_level = q.popleft()

        if current_level == level:
            for video in watched_videos[current_id]:
                video_freq[video] += 1
        elif current_level < level:
            for friend_id in friends[current_id]:
                if friend_id not in visited:
                    visited.add(friend_id)
                    q.append((friend_id, current_level + 1))

    result = sorted(video_freq.keys(), key=lambda x: (video_freq[x], x))

    return result

-----
from collections import deque
    # Your code here


************************************
Question ID: 1437
def min_steps_to_make_palindrome(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]

    for i in range(n - 2, -1, -1):
        for j in range(i + 1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1]
            else:
                dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1])

    return dp[0][n - 1]

-----
def min_steps_to_make_palindrome(s):
    # Your code here


************************************
Question ID: 1438
from collections import deque
def longestSubarray(nums, limit):
    max_deque = deque()
    min_deque = deque()
    left, right, longest = 0, 0, 0
    
    while right < len(nums):
        while max_deque and nums[right] > max_deque[-1]: max_deque.pop()
        while min_deque and nums[right] < min_deque[-1]: min_deque.pop()
        
        max_deque.append(nums[right])
        min_deque.append(nums[right])
        
        while max_deque[0] - min_deque[0] > limit:
            if max_deque[0] == nums[left]: max_deque.popleft()
            if min_deque[0] == nums[left]: min_deque.popleft()
            left += 1
        
        longest = max(longest, right - left + 1)
        right += 1
    
    return longest

-----
from collections import deque
    # Your code here


************************************
Question ID: 1439
import heapq

def kthSmallest(mat, k):
    m, n = len(mat), len(mat[0])
    minHeap = [(mat[0][0], 0, 0)]

    visited = set([(0, 0)])
    count = 0

    while minHeap:
        cur = heapq.heappop(minHeap)
        sum, row, col = cur

        count += 1
        if count == k:
            return sum

        if row + 1 < m and (row + 1, col) not in visited:
            visited.add((row + 1, col))
            heapq.heappush(minHeap, (sum - mat[row][col] + mat[row + 1][col], row + 1, col))
        
        if col + 1 < n and (row, col + 1) not in visited:
            visited.add((row, col + 1))
            heapq.heappush(minHeap, (sum - mat[row][col] + mat[row][col + 1], row, col + 1))

    return -1

-----
import heapq
    # Your code here


************************************
Question ID: 1441
def build_array(target, n):
    result = []
    current = 1
    for num in target:
        while current < num:
            result.append("Push ")
            result.append("Pop ")
            current += 1
        result.append("Push ")
        current += 1
    return result

-----
def build_array(target, n):
    # Your code here


************************************
Question ID: 1442
def make_connected(n, connections):
    adj_list = [[] for _ in range(n)]
    visited = [False] * n
    components = 0
    extra_edges = 0

    for a, b in connections:
        adj_list[a].append(b)
        adj_list[b].append(a)

    for i in range(n):
        if not visited[i]:
            components += 1
            stack = [i]

            while stack:
                current = stack.pop()

                if not visited[current]:
                    visited[current] = True

                    for neighbor in adj_list[current]:
                        if not visited[neighbor]:
                            stack.append(neighbor)
                        else:
                            extra_edges += 1

    extra_needed = components - 1

    if extra_edges >= extra_needed:
        return extra_needed

    return -1


-----
def make_connected(n, connections):
    # Your code here


************************************
Question ID: 1443
def minimum_distance(word: str) -> int:
    def dp(first: int, second: int, pos: int) -> int:
        if pos == len(word): return 0
        
        ans = float('inf')
        for i in [first, second]:
            if i != -1:
                dx = abs(ord(word[pos]) - ord(word[i])) % 6
                dy = abs(ord(word[pos]) - ord(word[i])) // 6
                ans = min(ans, min(dx, dy) * 2 + max(dx, dy))
        ans += dp(first, second, pos + 1)

        if first == -1 or second == -1:
            ans = min(ans, dp(pos if first == -1 else first, ord(word[pos]), pos + 1))

        return ans
    
    return dp(-1, -1, 0)


-----
def minimum_distance(word: str) -> int:
    # Your code here


************************************
Question ID: 1444
def number_of_steps(num):
    steps = 0
    while num:
        steps += 1 if num % 2 == 0 else 2
        num >>= 1
    return steps - 1

-----
def number_of_steps(num):
    # Your code here


************************************
Question ID: 1446
def angleClock(hour: int, minutes: int) -> float:
    minute_angle = 6 * minutes
    hour_angle = 30 * hour + 0.5 * minutes
    angle = abs(hour_angle - minute_angle)
    return min(angle, 360 - angle)

-----
def angleClock(hour: int, minutes: int) -> float:
    # Your code here


************************************
Question ID: 1447
def minJumps(arr):
    n = len(arr)
    maxReach = arr[0]
    step = arr[0]
    jumps = 1

    if n == 1:
        return 0

    for i in range(1, n):
        if i == n - 1:
            return jumps

        maxReach = max(maxReach, i + arr[i])

        step -= 1

        if step == 0:
            jumps += 1
            step = maxReach - i

    return -1

-----
def minJumps(arr):
    # Your code here


************************************
Question ID: 1448
def maximum69Number(num: int) -> int:
    num_str = list(str(num))
    for i, c in enumerate(num_str):
        if c == '6':
            num_str[i] = '9'
            break
    return int(''.join(num_str))

-----
def maximum69Number(num: int) -> int:
    # Your code here


************************************
Question ID: 1449
def largestNumber(cost, target):
    dp = ["" for _ in range(target + 1)]
    dp[0] = ""

    for i in range(9):
        for j in range(cost[i], target + 1):
            if dp[j - cost[i]] != None and len(dp[j - cost[i]]) < j - cost[i] \
               and (dp[j] == None or len(dp[j - cost[i]]) + 1 > len(dp[j])):
                dp[j] = dp[j - cost[i]] + str(i + 1)

    return dp[target] if dp[target] else "0"

-----
def largestNumber(cost, target):
    # Your code here


************************************
Question ID: 1450
def removeLeafNodes(root, target):
    if not root:
        return None
    root.left = removeLeafNodes(root.left, target)
    root.right = removeLeafNodes(root.right, target)
    if not root.left and not root.right and root.val == target:
        return None
    return root


-----
def removeLeafNodes(root, target):
    # Your code here


************************************
Question ID: 1451
def min_taps(n, ranges):
    intervals = [0] * (n + 1)
    for i in range(n + 1):
        left = max(0, i - ranges[i])
        right = min(n, i + ranges[i])
        intervals[left] = max(intervals[left], right - left)

    position, total_taps, max_reach = 0, 0, 0
    while position < n:
        max_reach = max(max_reach, position + intervals[position])
        if max_reach == position:
            return -1
        position = max_reach
        total_taps += 1

    return total_taps

-----
def min_taps(n, ranges):
    # Your code here


************************************
Question ID: 1452
from typing import List

def peopleIndexes(favoriteCompanies: List[List[str]]) -> List[int]:
    result = []
    companySets = [set(companies) for companies in favoriteCompanies]

    for i, companies in enumerate(companySets):
        isSubset = False
        for j, otherCompanies in enumerate(companySets):
            if i != j and companies.issubset(otherCompanies):
                isSubset = True
                break
        if not isSubset:
            result.append(i)

    return result

-----
from typing import List
    # Your code here


************************************
Question ID: 1453
def numPoints(darts, r):
    n = len(darts)
    result = 1
    
    for i in range(n):
        for j in range(n):
            cnt = 0
            for k in range(n):
                dx = darts[i][0] - darts[k][0]
                dy = darts[i][1] - darts[k][1]
                if (dx * dx + dy * dy) ** 0.5 <= r:
                    cnt += 1
                    
            if cnt > result:
                result = cnt
                
    return result

-----
def numPoints(darts, r):
    # Your code here


************************************
Question ID: 1455
def filter_restaurants(restaurants, vegan_friendly, max_price, max_distance):
    def custom_compare(a, b):
        if a[1] == b[1]:
            return b[0] - a[0]
        return b[1] - a[1]

    filtered_restaurants = [
        r for r in restaurants
        if (vegan_friendly == 0 or r[2] == vegan_friendly) and r[3] <= max_price and r[4] <= max_distance
    ]

    filtered_restaurants.sort(key=lambda r: (r[1], r[0]), reverse=True)

    return [r[0] for r in filtered_restaurants]

-----
def filter_restaurants(restaurants, vegan_friendly, max_price, max_distance):
    # Your code here


************************************
Question ID: 1456
def findTheCity(n, edges, distanceThreshold):
    INF = float("inf")
    dist = [[INF] * n for _ in range(n)]

    for i in range(n):
        dist[i][i] = 0

    for fr, to, w in edges:
        dist[fr][to] = dist[to][fr] = w

    for k in range(n):
        for i in range(n):
            for j in range(n):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    res, minReachable = -1, n + 1
    for i in range(n):
        cnt = sum(1 for d in dist[i] if d <= distanceThreshold)
        if cnt <= minReachable:
            minReachable = cnt
            res = i

    return res


-----
def findTheCity(n, edges, distanceThreshold):
    # Your code here


************************************
Question ID: 1457
def minDifficulty(jobDifficulty, d):
    n = len(jobDifficulty)
    if n < d: return -1
    dp = [[float("inf")] * n for _ in range(d)]

    dp[0][0] = jobDifficulty[0]
    for i in range(1, n):
        dp[0][i] = max(dp[0][i-1], jobDifficulty[i])

    for i in range(1, d):
        for j in range(i, n):
            maxD = jobDifficulty[j]
            for k in range(j, i - 1, -1):
                maxD = max(maxD, jobDifficulty[k])
                dp[i][j] = min(dp[i][j], dp[i-1][k-1] + maxD)

    return dp[d-1][n-1]


-----
def minDifficulty(jobDifficulty, d):
    # Your code here


************************************
Question ID: 1458
def sortByBits(arr):
    return sorted(arr, key=lambda x: (bin(x).count('1'), x))


-----
def sortByBits(arr):
    # Your code here


************************************
Question ID: 1460
def numberOfSubstrings(s: str) -> int:
    res, i, count = 0, 0, [0, 0, 0]
    
    for j, ch in enumerate(s):
        count[ord(ch) - ord('a')] += 1
        
        while count[0] > 0 and count[1] > 0 and count[2] > 0:
            count[ord(s[i]) - ord('a')] -= 1
            i += 1
            
        res += i
    
    return res

-----
def numberOfSubstrings(s: str) -> int:
    # Your code here


************************************
Question ID: 1461
def countOrders(n: int) -> int:
    MOD = 10**9 + 7
    ans = 1
    for i in range(1, n + 1):
        ans = ans * (2 * i - 1) * i % MOD
    return ans

-----
def countOrders(n: int) -> int:
    # Your code here


************************************
Question ID: 1462
def checkIfPrerequisite(numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
    adj_matrix = [[False] * numCourses for _ in range(numCourses)]
    for pre in prerequisites:
        adj_matrix[pre[0]][pre[1]] = True

    for k in range(numCourses):
        for i in range(numCourses):
            for j in range(numCourses):
                adj_matrix[i][j] = adj_matrix[i][j] or (adj_matrix[i][k] and adj_matrix[k][j])

    return [adj_matrix[query[0]][query[1]] for query in queries]


-----
def checkIfPrerequisite(numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
    # Your code here


************************************
Question ID: 1463
from typing import List
import heapq

def kWeakestRows(mat: List[List[int]], k: int) -> List[int]:
    soldier_rows = [(row.count(1), i) for i, row in enumerate(mat)]
    heapq.heapify(soldier_rows)
    return [heapq.heappop(soldier_rows)[1] for _ in range(k)]


-----
from typing import List
    # Your code here


************************************
Question ID: 1464
from collections import Counter

def minSetSize(arr):
    count = Counter(arr)
    freq = list(count.values())
    freq.sort(reverse=True)

    removed, setSize = 0, 0
    for f in freq:
        removed += f
        setSize += 1
        if removed * 2 >= len(arr):
            return setSize

    return 0


-----
from collections import Counter
    # Your code here


************************************
Question ID: 1466
def maxJumps(arr, d):
    n = len(arr)
    dp = [1] * n

    def helper(idx):
        if dp[idx] > 1:
            return dp[idx]
        maximum = 1
        for i in range(1, d + 1):
            if idx + i < n and arr[idx] <= arr[idx + i]:
                break
            if idx + i < n:
                maximum = max(maximum, 1 + helper(idx + i))

            if idx - i >= 0 and arr[idx] <= arr[idx - i]:
                break
            if idx - i >= 0:
                maximum = max(maximum, 1 + helper(idx - i))
        
        dp[idx] = maximum
        return maximum

    for i in range(n):
        helper(i)

    return max(dp)


-----
def maxJumps(arr, d):
    # Your code here


************************************
Question ID: 1467
from math import factorial

def count_combinations(balls, combinations, curr_ball):
    total_combinations = 1
    for i in range(curr_ball):
        total_combinations *= factorial(balls[i] + combinations[i]) / (factorial(balls[i]) * factorial(combinations[i]))

    return total_combinations

def dfs(balls, combinations, curr_ball):
    if curr_ball == len(balls):
        if combinations[-1] == combinations[0]:
            return count_combinations(balls, combinations, curr_ball)
        else:
            return 0

    result = 0
    for i in range(balls[curr_ball] + 1):
        combinations.append(i)
        result += dfs(balls, combinations, curr_ball + 1)
        combinations.pop()

    return result

def get_probability(balls):
    sum_balls = sum(balls)

    total_combinations = 1
    for ball in balls:
        total_combinations *= factorial(ball)

    combinations = []
    return dfs(balls, combinations, 0) / total_combinations

-----
from math import factorial
    # Your code here


************************************
Question ID: 1469
def min_steps(s, t):
    count_s = [0] * 26
    count_t = [0] * 26
    steps = 0
    
    for c in s:
        count_s[ord(c) - ord('a')] += 1
    for c in t:
        count_t[ord(c) - ord('a')] += 1
    
    for i in range(26):
        steps += abs(count_s[i] - count_t[i])
    
    return steps // 2

-----
def min_steps(s, t):
    # Your code here


************************************
Question ID: 1470
from collections import defaultdict
from typing import List

class TweetCounts:

    def __init__(self):
        self.tweet_records = defaultdict(lambda: defaultdict(int))

    def recordTweet(self, tweetName: str, time: int) -> None:
        self.tweet_records[tweetName][time] += 1

    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:
        if freq == "minute":
            interval = 60
        elif freq == "hour":
            interval = 3600
        else:
            interval = 86400

        result = [0] * ((endTime - startTime) // interval + 1)
        for time, count in self.tweet_records[tweetName].items():
            if startTime <= time <= endTime:
                result[(time - startTime) // interval] += count

        return result


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1471
def maxStudents(seats):
    m, n = len(seats), len(seats[0])
    valid_rows = [0] * m
    max_valid = (1 << n) - 1
    for i in range(m):
        state = 0
        for j in range(n):
            state |= (seats[i][j] == '.') << j
        valid_rows[i] = state

    memo = [[-1] * (1 << n) for _ in range(m)]
    return dfs(0, 0, valid_rows, m, n, max_valid, memo)

def dfs(row_index, prev_state, valid_rows, m, n, max_valid, memo):
    if row_index == m:
        return 0

    if memo[row_index][prev_state] != -1:
        return memo[row_index][prev_state]

    max_students = 0
    for cur_state in range(max_valid + 1):
        if (cur_state & valid_rows[row_index]) != cur_state:
            continue
        if cur_state & (cur_state << 1):
            continue
        if cur_state & (prev_state << 1) or prev_state & (cur_state << 1):
            continue

        max_students = max(max_students, dfs(row_index + 1, cur_state, valid_rows, m, n, max_valid, memo) + bin(cur_state).count('1'))

    memo[row_index][prev_state] = max_students
    return max_students

-----
def maxStudents(seats):
    # Your code here


************************************
Question ID: 1472
from collections import OrderedDict

def sortString(s: str) -> str:
    freq_map = OrderedDict(sorted({c: s.count(c) for c in set(s)}.items()))
    result = []

    while freq_map:
        for key in list(freq_map.keys()):
            result.append(key)
            freq_map[key] -= 1

            if freq_map[key] == 0:
                del freq_map[key]

        for key in list(reversed(freq_map.keys())):
            result.append(key)
            freq_map[key] -= 1

            if freq_map[key] == 0:
                del freq_map[key]

    return "".join(result)

-----
from collections import OrderedDict
    # Your code here


************************************
Question ID: 1473
def findTheLongestSubstring(s: str) -> int:
    pos = {-1: 0}
    ans = cur = 0
    for i, c in enumerate(s):
        cur ^= 1 << ("aeiou".find(c) + 1) >> 1
        if cur not in pos:
            pos[cur] = i + 1
        ans = max(ans, i + 1 - pos[cur])
    return ans

-----
def findTheLongestSubstring(s: str) -> int:
    # Your code here


************************************
Question ID: 1476
def countNegatives(grid):
    m, n, count, i, j = len(grid), len(grid[0]), 0, 0, len(grid[0]) - 1
    while i < m and j >= 0:
        if grid[i][j] < 0:
            count += j + 1
            i += 1
        else:
            j -= 1
    return count

-----
def countNegatives(grid):
    # Your code here


************************************
Question ID: 1478
def max_events(events):
    events.sort(key=lambda x: x[1])

    count = 0
    last_day = -1

    for event in events:
        if event[0] > last_day:
            count += 1
            last_day = event[1]

    return count

-----
def max_events(events):
    # Your code here


************************************
Question ID: 1480
def runningSum(nums):
    for i in range(1, len(nums)):
        nums[i] += nums[i - 1]
    return nums

-----
def runningSum(nums):
    # Your code here


************************************
Question ID: 1481
from collections import Counter
import heapq

def findLeastNumOfUniqueInts(arr, k):
    count = Counter(arr)
    pq = list(count.values())
    heapq.heapify(pq)
    while k > 0:
        k -= heapq.heappop(pq)
    return len(pq) if k == 0 else len(pq) + 1

-----
from collections import Counter
    # Your code here


************************************
Question ID: 1482
def smallerNumbersThanCurrent(nums):
    result = [0] * len(nums)
    for i in range(len(nums)):
        for j in range(len(nums)):
            if nums[j] < nums[i]:
                result[i] += 1
    return result

-----
def smallerNumbersThanCurrent(nums):
    # Your code here


************************************
Question ID: 1483
def rank_teams(votes):
    teams = len(votes[0])
    ranks = [[0] * teams for _ in range(26)]

    for vote in votes:
        for i in range(teams):
            ranks[ord(vote[i]) - ord('A')][i] += 1

    result = list(votes[0])
    result.sort(key=lambda ch: tuple([-ranks[ord(ch) - ord('A')][i] for i in range(teams)] + [ch]))
    return ''.join(result)


-----
def rank_teams(votes):
    # Your code here


************************************
Question ID: 1485
from collections import deque

def minCost(grid):
    def dfs(r, c, d):
        if 0 <= r < m and 0 <= c < n and d < cost[r][c]:
            cost[r][c] = d
            q.append((r, c))

    m, n = len(grid), len(grid[0])
    cost = [[1e6] * n for _ in range(m)]

    q = deque()
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    dfs(0, 0, 0)

    while q:
        r, c = q.popleft()
        for i, (dr, dc) in enumerate(directions):
            dfs(r + dr, c + dc, cost[r][c] + (grid[r][c] != i + 1))

    return cost[-1][-1]

-----
from collections import deque
    # Your code here


************************************
Question ID: 1486
def findTheDistanceValue(arr1, arr2, d):
    count = 0
    for i in arr1:
        valid = True
        for j in arr2:
            if abs(i - j) <= d:
                valid = False
                break
        if valid:
            count += 1
    return count

-----
def findTheDistanceValue(arr1, arr2, d):
    # Your code here


************************************
Question ID: 1487
def maxNumberOfFamilies(n, reservedSeats):
    rows = {}
    for seat in reservedSeats:
        rows[seat[0]] = rows.get(seat[0], 0) | (1 << (seat[1] - 1))
    
    max_groups = (n - len(rows)) * 2
    for row_mask in rows.values():
        seats = ~(row_mask | (row_mask >> 1) | (row_mask >> 2) | (row_mask >> 3)) & 0x3FF
        max_groups += (seats & (seats >> 1) & (seats >> 2) & (seats >> 3)) != 0
        
    return max_groups

-----
def maxNumberOfFamilies(n, reservedSeats):
    # Your code here


************************************
Question ID: 1488
def get_power(x):
    steps = 0
    while x != 1:
        if x % 2 == 0:
            x //= 2
        else:
            x = 3 * x + 1
        steps += 1
    return steps

def sort_by_power(lo, hi, k):
    nums = [(get_power(i), i) for i in range(lo, hi + 1)]
    nums.sort()
    return nums[k - 1][1]

-----
def get_power(x):
    # Your code here


************************************
Question ID: 1489
def max_size_slices(slices):
    def max_sum(slices, start, end, n, memo):
        if n == 0:
            return 0
        if end - start + 1 < n * 2:
            return float('-inf')
        if memo[start][n] != -1:
            return memo[start][n]

        pick = max_sum(slices, start + 2, end, n - 1, memo) + slices[start]
        not_pick = max_sum(slices, start + 1, end, n, memo)

        memo[start][n] = max(pick, not_pick)
        return memo[start][n]

    n = len(slices) // 3
    memo1 = [[-1] * (n + 1) for _ in range(len(slices))]
    memo2 = [[-1] * (n + 1) for _ in range(len(slices))]

    return max(max_sum(slices, 0, len(slices) - 1, n, memo1),
               max_sum(slices, 1, len(slices), n, memo2))


-----
def max_size_slices(slices):
    # Your code here


************************************
Question ID: 1490
def generate_the_string(n: int) -> str:
    if n % 2 == 0:
        return 'a' * (n - 1) + 'b'
    else:
        return 'a' * n

-----
def generate_the_string(n: int) -> str:
    # Your code here


************************************
Question ID: 1491
def count_prefix_aligned(flips):
    count = 0
    for i in range(len(flips)):
        if flips[i] == i + 1:
            count += 1
    return count

-----
def count_prefix_aligned(flips):
    # Your code here


************************************
Question ID: 1492
from collections import deque

def numOfMinutes(n, headID, manager, informTime):
    subordinates = {i: [] for i in range(n)}
    for i in range(n):
        if manager[i] != -1:
            subordinates[manager[i]].append(i)

    queue = deque([(headID, 0)])
    totalTime = 0

    while queue:
        current, time = queue.popleft()
        totalTime = max(totalTime, time)
        for sub in subordinates[current]:
            queue.append((sub, time + informTime[current]))

    return totalTime


-----
from collections import deque
    # Your code here


************************************
Question ID: 1493
from collections import defaultdict

def frogPosition(n, edges, t, target):
    graph = defaultdict(list)
    for edge in edges:
        graph[edge[0]].append(edge[1])
        graph[edge[1]].append(edge[0])
    return dfs(1, -1, t, target, graph)

def dfs(node, parent, t, target, graph):
    if t == 0:
        return 1.0 if node == target else 0.0
    probability = 0.0
    for neighbor in graph[node]:
        if neighbor != parent:
            probability += dfs(neighbor, node, t - 1, target, graph)
    return probability / (len(graph[node]) - (0 if parent == -1 else 1))


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1494
from collections import deque

def minNumberOfSemesters(n, relations, k):
    indegree = [0] * (n + 1)
    graph = [[] for _ in range(n + 1)]

    for prev_course, next_course in relations:
        graph[prev_course].append(next_course)
        indegree[next_course] += 1

    semesters = 0
    while n > 0:
        zero_indegree = deque()
        for i in range(1, len(indegree)):
            if indegree[i] == 0:
                zero_indegree.append(i)
                indegree[i] = -1

        courses = 0
        while zero_indegree and courses < k:
            curr_course = zero_indegree.popleft()
            n -= 1

            for next_course in graph[curr_course]:
                indegree[next_course] -= 1
            courses += 1
        semesters += 1
    return semesters

-----
from collections import deque
    # Your code here


************************************
Question ID: 1496
def lucky_numbers(matrix):
    m, n = len(matrix), len(matrix[0])
    lucky_numbers = []

    for i in range(m):
        min_row = min(matrix[i])
        min_row_idx = matrix[i].index(min_row)
        is_lucky = all(matrix[k][min_row_idx] <= min_row for k in range(m))

        if is_lucky:
            lucky_numbers.append(min_row)

    return lucky_numbers

-----
def lucky_numbers(matrix):
    # Your code here


************************************
Question ID: 1498
def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:
    if original is None:
        return None
    if original is target:
        return cloned

    left = self.getTargetCopy(original.left, cloned.left, target)
    return left if left else self.getTargetCopy(original.right, cloned.right, target)

-----
def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:
    # Your code here


************************************
Question ID: 1499
import heapq

def max_performance(n, k, speed, efficiency):
    engineers = sorted(zip(efficiency, speed), reverse=True)

    result = 0
    sum_speed = 0
    min_heap = []
    for e, s in engineers:
        if len(min_heap) >= k:
            sum_speed -= heapq.heappop(min_heap)

        heapq.heappush(min_heap, s)
        sum_speed += s
        result = max(result, e * sum_speed)

    return result % (10**9 + 7)

-----
import heapq
    # Your code here


************************************
Question ID: 1500
def countLargestGroup(n: int) -> int:
    freq = [0] * 37
    max_group_size = 0
    max_group_count = 0
    
    for i in range(1, n + 1):
        _sum = sum(map(int, str(i)))
        freq[_sum] += 1
        max_group_size = max(max_group_size, freq[_sum])
    
    for count in freq:
        if count == max_group_size:
            max_group_count += 1

    return max_group_count


-----
def countLargestGroup(n: int) -> int:
    # Your code here


************************************
Question ID: 1502
def can_construct(s, k):
    char_counts = [0] * 26

    for c in s:
        char_counts[ord(c) - ord('a')] += 1

    odd_count = sum(count % 2 for count in char_counts)

    return odd_count <= k <= len(s)


-----
def can_construct(s, k):
    # Your code here


************************************
Question ID: 1503
def max_satisfaction(satisfaction):
    satisfaction.sort(reverse=True)
    ans = total = sum = 0
    for i in satisfaction:
        total += i
        if total > 0:
            sum += total
            ans = max(ans, sum)
    return ans

-----
def max_satisfaction(satisfaction):
    # Your code here


************************************
Question ID: 1504
def numSubmat(mat: List[List[int]]) -> int:
    m, n = len(mat), len(mat[0])
    dp = [[0] * n for _ in range(m)]
    ans = 0
    
    for i in range(m):
        for j in range(n):
            if mat[i][j]:
                dp[i][j] = 1 if j == 0 else dp[i][j-1] + 1
                width = dp[i][j]
                for k in range(i, -1, -1):
                    width = min(width, dp[k][j])
                    ans += width
    
    return ans

-----
def numSubmat(mat: List[List[int]]) -> int:
    # Your code here


************************************
Question ID: 1505
def createTargetArray(nums, index):
    target = []
    for i in range(len(nums)):
        target.insert(index[i], nums[i])
    return target

-----
def createTargetArray(nums, index):
    # Your code here


************************************
Question ID: 1507
def hasValidPath(grid):
    m, n = len(grid), len(grid[0])
    visited = [[False for _ in range(n)] for _ in range(m)]

    return dfs(grid, 0, 0, m, n, visited)

def dfs(grid, x, y, m, n, visited):
    if x < 0 or y < 0 or x >= m or y >= n or visited[x][y]:
        return False
    if x == m - 1 and y == n - 1:
        return True
    
    visited[x][y] = True

    next_x = [-1, 0, 1, 0]
    next_y = [0, 1, 0, -1]

    for i in range(4):
        dx = x + next_x[i]
        dy = y + next_y[i]

        if dfs(grid, dx, dy, m, n, visited):
            return True

    return False

-----
def hasValidPath(grid):
    # Your code here


************************************
Question ID: 1508
def longestHappyPrefix(s):
    n = len(s)
    lps = [0] * n
    length = 0
    i = 1
    while i < n:
        if s[i] == s[length]:
            length += 1
            lps[i] = length
            i += 1
        elif length != 0:
            length = lps[length - 1]
        else:
            lps[i] = 0
            i += 1
    return s[:lps[-1]]

-----
def longestHappyPrefix(s):
    # Your code here


************************************
Question ID: 1509
def minDifference(nums):
    n = len(nums)
    if n <= 4: return 0
    nums.sort()
    res = float('inf')
    for i in range(4):
        res = min(res, nums[n - 4 + i] - nums[i])
    return res

-----
def minDifference(nums):
    # Your code here


************************************
Question ID: 1510
def find_lucky(arr):
    freq = {}

    for n in arr:
        if n in freq:
            freq[n] += 1
        else:
            freq[n] = 1

    lucky = -1
    for key, value in freq.items():
        if key == value:
            lucky = max(lucky, key)

    return lucky

-----
def find_lucky(arr):
    # Your code here


************************************
Question ID: 1513
MOD = 10**9 + 7

def countGoodStrings(s1, s2, evil):
    n = len(s1)
    m = len(evil)
    dp = [[0] * m for _ in range(n + 1)]

    # Preprocess the KMP prefix function for the evil string
    lps = [0] * m
    len_ = 0
    i = 1
    while i < m:
        if evil[i] == evil[len_]:
            len_ += 1
            lps[i] = len_
            i += 1
        elif len_:
            len_ = lps[len_ - 1]
        else:
            i += 1

    dp[0][0] = 1
    for i in range(n):
        for j in range(m):
            for k in range(2):
                for c in range(ord('a'), ord(s2[i] if k else 'z') + 1):
                    e = j
                    while e and (chr(c) != evil[e]):
                        e = lps[e - 1]

                    if chr(c) != evil[e]:
                        e += 1

                    if e != m:
                        dp[i + 1][k | (c < ord(s2[i]))] += dp[i][k]
                        dp[i + 1][k | (c < ord(s2[i]))] %= MOD

    return (dp[n][1] - dp[n][0] + MOD) % MOD


-----
MOD = 10**9 + 7
    # Your code here


************************************
Question ID: 1514
def min_start_value(nums):
    min_sum, sum = 0, 0
    for num in nums:
        sum += num
        min_sum = min(min_sum, sum)
    return 1 - min_sum

-----
def min_start_value(nums):
    # Your code here


************************************
Question ID: 1515
def find_min_fibonacci_numbers(k):
    if k == 0:
        return 0
    a, b = 0, 1
    while b <= k:
        a, b = b, a + b
    return 1 + find_min_fibonacci_numbers(k - a)

-----
def find_min_fibonacci_numbers(k):
    # Your code here


************************************
Question ID: 1516
def get_happy_string(n, k):
    def dfs(s, prev):
        if len(s) == n:
            happy_strings.append(s)
            return
        for c in 'abc':
            if c != prev:
                dfs(s + c, c)

    happy_strings = []
    dfs("", ' ')
    return happy_strings[k - 1] if k <= len(happy_strings) else ""

-----
def get_happy_string(n, k):
    # Your code here


************************************
Question ID: 1518
def numWaterBottles(numBottles: int, numExchange: int) -> int:
    totalBottles = numBottles
    while numBottles >= numExchange:
        newBottles = numBottles // numExchange
        totalBottles += newBottles
        numBottles = newBottles + numBottles % numExchange
    return totalBottles

-----
def numWaterBottles(numBottles: int, numExchange: int) -> int:
    # Your code here


************************************
Question ID: 1519
def min_subsequence(nums):
    nums.sort(reverse=True)
    total_sum, current_sum = sum(nums), 0
    result = []
    for num in nums:
        current_sum += num
        result.append(num)
        if current_sum > total_sum - current_sum:
            break
    return result

-----
def min_subsequence(nums):
    # Your code here


************************************
Question ID: 1520
def num_steps(s: str) -> int:
    steps = 0
    carry = 0

    for i in range(len(s) - 1, 0, -1):
        current = int(s[i]) + carry
        if current == 1:
            steps += 2
            carry = 1
        else:
            steps += carry
            carry = current

    return steps + carry

-----
def num_steps(s: str) -> int:
    # Your code here


************************************
Question ID: 1521
def closestToTarget(arr: List[int], target: int) -> int:
    min_diff = float('inf')
    prefix = set()

    for n in arr:
        next_prefix = set()
        for p in prefix:
            next_prefix.add(p & n)
        next_prefix.add(n)

        for p in next_prefix:
            min_diff = min(min_diff, abs(p - target))
        prefix = next_prefix
    return min_diff

-----
def closestToTarget(arr: List[int], target: int) -> int:
    # Your code here


************************************
Question ID: 1522
def stoneGameIII(stoneValue):
    n = len(stoneValue)
    dp = [0] * (n + 1)
    dp[n - 1] = stoneValue[n - 1]
    for i in range(n - 2, -1, -1):
        dp[i] = stoneValue[i] - dp[i + 1]
        for j in range(1, 3):
            if i + j < n:
                dp[i] = max(dp[i], stoneValue[i + j] - dp[i + j + 1])
    if dp[0] > 0: return "Alice"
    if dp[0] < 0: return "Bob"
    return "Tie"

-----
def stoneGameIII(stoneValue):
    # Your code here


************************************
Question ID: 1523
def count_odds(low, high):
    return (high - low) // 2 + (1 if low % 2 == 1 or high % 2 == 1 else 0)

-----
def count_odds(low, high):
    # Your code here


************************************
Question ID: 1524
def stringMatching(words):
    result = []
    for word1 in words:
        for word2 in words:
            if word1 != word2 and word1 in word2:
                result.append(word1)
                break
    return result

-----
def stringMatching(words):
    # Your code here


************************************
Question ID: 1525
def process_queries(queries, m):
    nums = list(range(1, m+1))
    result = []
    for q in queries:
        pos = nums.index(q)
        result.append(pos)
        del nums[pos]
        nums.insert(0, q)
    return result

-----
def process_queries(queries, m):
    # Your code here


************************************
Question ID: 1526
def entityParser(text: str) -> str:
    entities = {
        "&quot;": '\"',
        "&apos;": '\'',
        "&amp;": '&',
        "&gt;": '>',
        "&lt;": '<',
        "&frasl;": '/'
    }

    result, i = [], 0
    while i < len(text):
        if text[i] == '&':
            temp = ''
            for j in range(i, min(i+7, len(text))):
                temp += text[j]
                if temp in entities:
                    result.append(entities[temp])
                    i = j
                    break
            else:
                result.append(text[i])
        else:
            result.append(text[i])
        i += 1
    return ''.join(result)


-----
def entityParser(text: str) -> str:
    # Your code here


************************************
Question ID: 1528
from typing import List

def kids_with_candies(candies: List[int], extra_candies: int) -> List[bool]:
    max_candies = max(candies)
    result = [candy + extra_candies >= max_candies for candy in candies]
    return result

-----
from typing import List
    # Your code here


************************************
Question ID: 1529
def max_difference(num):
    a = num + 9 - (num % 10)
    b = num - (num // 1000 % 10) * 111

    return a - b

-----
def max_difference(num):
    # Your code here


************************************
Question ID: 1530
def check_if_can_break(s1, s2):
    s1 = sorted(s1)
    s2 = sorted(s2)

    can_break_1 = can_break_2 = True
    for c1, c2 in zip(s1, s2):
        if c1 < c2:
            can_break_1 = False
        if c2 < c1:
            can_break_2 = False

    return can_break_1 or can_break_2


-----
def check_if_can_break(s1, s2):
    # Your code here


************************************
Question ID: 1531
def number_ways(hats):
    kMod = 1000000007
    kMaxHats = 40

    num_people = len(hats)
    people_with_hat = [[] for _ in range(kMaxHats)]

    for i in range(num_people):
        for hat in hats[i]:
            people_with_hat[hat - 1].append(i)

    dp = [[0] * (kMaxHats + 1) for _ in range(1 << num_people)]
    dp[0][0] = 1

    for hat in range(kMaxHats):
        for mask in reversed(range(1 << num_people)):
            dp[mask][hat + 1] = (dp[mask][hat + 1] + dp[mask][hat]) % kMod
            for person in people_with_hat[hat]:
                if mask & (1 << person) == 0:
                    dp[mask | (1 << person)][hat + 1] = (dp[mask | (1 << person)][hat + 1] + dp[mask][hat]) % kMod

    return dp[(1 << num_people) - 1][kMaxHats]

-----
def number_ways(hats):
    # Your code here


************************************
Question ID: 1533
from collections import defaultdict
from typing import List

def displayTable(orders: List[List[str]]) -> List[List[str]]:
    foodItems = set()
    tableOrders = defaultdict(lambda: defaultdict(int))

    for order in orders:
        foodItems.add(order[2])
        tableOrders[int(order[1])][order[2]] += 1

    foodItems = sorted(foodItems)
    header = ["Table"] + foodItems
    result = [header]

    for tableNumber, foodOrder in sorted(tableOrders.items()):
        row = [str(tableNumber)] + [str(foodOrder[food]) for food in foodItems]
        result.append(row)

    return result


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1534
def minNumberOfFrogs(croakOfFrogs: str) -> int:
    counts = [0] * 5
    max_frogs = 0

    for c in croakOfFrogs:
        index = "croak".find(c)
        if index == 0:
            counts[0] += 1
            max_frogs = max(max_frogs, counts[0])
        elif counts[index - 1] > 0:
            counts[index - 1] -= 1
            counts[index] += 1
        else:
            return -1

    if counts[0] == counts[4]:
        return max_frogs
    else:
        return -1

-----
def minNumberOfFrogs(croakOfFrogs: str) -> int:
    # Your code here


************************************
Question ID: 1535
def number_of_ways(n, m, k, mod=1_000_000_007):
    if k > 1:
        result = 1
        for _ in range(n):
            result = (result * m) % mod
        return result
    return 1 if n % 2 == 0 else m

-----
def number_of_ways(n, m, k, mod=1_000_000_007):
    # Your code here


************************************
Question ID: 1536
def minSwaps(grid):
    n = len(grid)
    steps = 0

    for i in range(n):
        row = -1
        for j in range(i, n):
            if grid[j][i] == 0:
                row = j
                break
        if row == -1:
            return -1

        while row > i:
            grid[row], grid[row - 1] = grid[row - 1], grid[row]
            steps += 1
            row -= 1

    return steps


-----
def minSwaps(grid):
    # Your code here


************************************
Question ID: 1537
def maxScore(s):
    left_zeros, right_ones, max_score = 0, s.count('1'), 0
    for i in range(len(s) - 1):
        if s[i] == '0': left_zeros += 1
        else: right_ones -= 1
        max_score = max(max_score, left_zeros + right_ones)
    return max_score

-----
def maxScore(s):
    # Your code here


************************************
Question ID: 1538
def maxScore(cardPoints, k):
    n = len(cardPoints)
    total = sum(cardPoints[:k])

    max_score = total
    for i in range(k - 1, -1, -1):
        j = n - k + i
        total += cardPoints[j] - cardPoints[i]
        max_score = max(max_score, total)

    return max_score


-----
def maxScore(cardPoints, k):
    # Your code here


************************************
Question ID: 1539
def find_diagonal_order(nums):
    diagonals = {}
    for i in range(len(nums)):
        for j in range(len(nums[i])):
            if i + j not in diagonals:
                diagonals[i + j] = []
            diagonals[i + j].append(nums[i][j])

    res = []
    for key in diagonals:
        res.extend(reversed(diagonals[key]))

    return res

-----
def find_diagonal_order(nums):
    # Your code here


************************************
Question ID: 1540
def canConvertString(s: str, t: str, k: int) -> bool:
    if len(s) != len(t):
        return False
    count = [0] * 26
    for i in range(len(s)):
        diff = (ord(t[i]) - ord(s[i]) + 26) % 26
        if diff > 0:
            count[diff] += 1
    for i in range(1, 26):
        if count[i] > 0:
            if count[i] * 26 - 26 + i > k:
                return False
    return True

-----
def canConvertString(s: str, t: str, k: int) -> bool:
    # Your code here


************************************
Question ID: 1541
def minInsertions(s: str) -> int:
    left = 0
    res = 0
    n = len(s)
    i = 0
    while i < n:
        if s[i] == '(':
            left += 1
        else:
            if left == 0: 
                res += 1
            else: 
                left -= 1
            if i == n - 1 or s[i + 1] != ')':
                res += 1
                i += 1
        i += 1
    return res + left * 2

-----
def minInsertions(s: str) -> int:
    # Your code here


************************************
Question ID: 1542
def max_power(s: str) -> int:
    max_power = current_power = 1

    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            current_power += 1
        else:
            max_power = max(max_power, current_power)
            current_power = 1

    return max(max_power, current_power)

-----
def max_power(s: str) -> int:
    # Your code here


************************************
Question ID: 1544
def goodNodes(root, maxVal=float('-inf')):
    if not root:
        return 0
    result = 0
    if root.val >= maxVal:
        result = 1
        maxVal = root.val
    return result + goodNodes(root.left, maxVal) + goodNodes(root.right, maxVal)

-----
def goodNodes(root, maxVal=float('-inf')):
    # Your code here


************************************
Question ID: 1545
def largestNumber(cost, target):
    dp = ["" for _ in range(target + 1)]
    dp[0] = ""
    
    for t in range(1, target + 1):
        for i in range(1, 10):
            if t >= cost[i - 1] and dp[t - cost[i - 1]]:
                temp = dp[t - cost[i - 1]] + str(i)
                if len(dp[t]) <= len(temp):
                    dp[t] = temp

    return dp[target] if dp[target] else "0"


-----
def largestNumber(cost, target):
    # Your code here


************************************
Question ID: 1546
def maxNonOverlapping(nums, target):
    prefix_sum = {0: 0}
    sum, count = 0, 0
    for num in nums:
        sum += num
        if sum - target in prefix_sum:
            count = max(count, 1 + prefix_sum[sum - target])
        prefix_sum[sum] = count
    return count

-----
def maxNonOverlapping(nums, target):
    # Your code here


************************************
Question ID: 1547
def destCity(paths):
    starting_cities = set()
    
    for path in paths:
        starting_cities.add(path[0])

    for path in paths:
        if path[1] not in starting_cities:
            return path[1]

    return ""

-----
def destCity(paths):
    # Your code here


************************************
Question ID: 1548
def kLengthApart(nums, k):
    last_one = -1
    for i, num in enumerate(nums):
        if num == 1:
            if last_one != -1 and i - last_one <= k:
                return False
            last_one = i
    return True

-----
def kLengthApart(nums, k):
    # Your code here


************************************
Question ID: 1550
import heapq

def kthSmallest(mat, k):
    m, n = len(mat), len(mat[0])
    
    minHeap = [(mat[0][0], 0, 0)]
    visited = [[False for _ in range(n)] for _ in range(m)]
    visited[0][0] = True
    
    for _ in range(k):
        res, i, j = heapq.heappop(minHeap)
        
        if i < m - 1 and not visited[i+1][j]:
            heapq.heappush(minHeap, (res - mat[i][j] + mat[i + 1][j], i + 1, j))
            visited[i+1][j] = True
        if j < n - 1 and not visited[i][j+1]:
            heapq.heappush(minHeap, (res - mat[i][j] + mat[i][j + 1], i, j + 1))
            visited[i][j+1] = True
            
    return res

-----
import heapq
    # Your code here


************************************
Question ID: 1551
def min_operations(n):
    return n * n // 4

-----
def min_operations(n):
    # Your code here


************************************
Question ID: 1552
def build_array(target, n):
    result = []
    current = 1
    for num in target:
        while current < num:
            result.append("Push")
            result.append("Pop")
            current += 1
        result.append("Push")
        current += 1
    return result

-----
def build_array(target, n):
    # Your code here


************************************
Question ID: 1553
def countTriplets(arr):
    n = len(arr)
    XOR = [0] * (n + 1)
    
    for i in range(n):
        XOR[i+1] = XOR[i] ^ arr[i]
    
    count = 0
    for i in range(n):
        for k in range(i+1, n):
            if XOR[i] == XOR[k+1]:
                count += k-i
    return count

-----
def countTriplets(arr):
    # Your code here


************************************
Question ID: 1554
def minTime(n, edges, hasApple):
    graph = {i: {} for i in range(n)}

    for a, b in edges:
        graph[a][b] = 0
        graph[b][a] = 0

    def dfs(v, parent):
        ans = 0
        for u in graph[v]:
            if u == parent:
                continue
            ans += dfs(u, v) * 2
        return ans + int(hasApple[v] or ans > 0)

    return dfs(0, -1)

-----
def minTime(n, edges, hasApple):
    # Your code here


************************************
Question ID: 1556
def can_be_equal(target, arr):
    target.sort()
    arr.sort()
    return target == arr


-----
def can_be_equal(target, arr):
    # Your code here


************************************
Question ID: 1557
def has_all_codes(s, k):
    need = 1 << k
    got = set()
    
    for i in range(len(s) - k + 1):
        got.add(s[i:i + k])
    
    return len(got) == need


-----
def has_all_codes(s, k):
    # Your code here


************************************
Question ID: 1558
from collections import defaultdict

def DFS(src, graph, visited, transitive_closure, dest):
    if src == dest:
        transitive_closure[dest] = True
        return
    if visited[src]:
        return
    visited[src] = True
    for neighbor in graph[src]:
        DFS(neighbor, graph, visited, transitive_closure, dest)
        if transitive_closure[dest]:
            return

def checkIfPrerequisite(numCourses, prerequisites, queries):
    graph = defaultdict(list)

    for pre in prerequisites:
        graph[pre[0]].append(pre[1])

    result = []

    for i in range(len(queries)):
        visited = [False] * numCourses
        transitive_closure = [False] * numCourses
        DFS(queries[i][0], graph, visited, transitive_closure, queries[i][1])
        result.append(transitive_closure[queries[i][1]])

    return result

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1559
def cherry_pickup(grid):
    rows, cols = len(grid), len(grid[0])
    dp = [[[0] * cols for _ in range(cols)] for _ in range(rows)]

    for row in reversed(range(rows)):
        for col1 in range(cols):
            for col2 in range(cols):
                current_cell = dp[row + 1][col1][col2] if row < rows - 1 else 0
                current_cell += grid[row][col1] + (grid[row][col2] if col1 != col2 else 0)

                max_val = 0
                for move1 in range(-1, 2):
                    for move2 in range(-1, 2):
                        new_col1, new_col2 = col1 + move1, col2 + move2
                        if 0 <= new_col1 < cols and 0 <= new_col2 < cols:
                            max_val = max(max_val, dp[row][new_col1][new_col2])

                dp[row][col1][col2] = current_cell + max_val

    return dp[0][0][cols - 1]


-----
def cherry_pickup(grid):
    # Your code here


************************************
Question ID: 1560
def busy_student(start_time, end_time, query_time):
    count = 0
    for i in range(len(start_time)):
        if start_time[i] <= query_time <= end_time[i]:
            count += 1
    return count

-----
def busy_student(start_time, end_time, query_time):
    # Your code here


************************************
Question ID: 1561
def arrangeWords(text: str) -> str:
    words = text.split()
    words[0] = words[0].lower()
    words.sort(key=len)
    words[0] = words[0].capitalize()
    return ' '.join(words)

-----
def arrangeWords(text: str) -> str:
    # Your code here


************************************
Question ID: 1562
from typing import List

def peopleIndexes(favoriteCompanies: List[List[str]]) -> List[int]:
    result = []
    for i in range(len(favoriteCompanies)):
        is_subset = False
        for j in range(len(favoriteCompanies)):
            if i != j and set(favoriteCompanies[i]).issubset(favoriteCompanies[j]):
                is_subset = True
                break
        if not is_subset:
            result.append(i)
    return result

-----
from typing import List
    # Your code here


************************************
Question ID: 1563
from math import acos, cos, sin, sqrt

def max_number_of_darts(darts, r):
    n = len(darts)
    max_darts = 1

    for i in range(n):
        for j in range(i + 1, n):
            dist = sqrt((darts[j][0] - darts[i][0])**2 + (darts[j][1] - darts[i][1])**2)
            if dist > 2.0 * r: continue

            angle = acos(dist / (2.0 * r))
            for k in range(2):
                loc_angle = angle * (1 if k == 0 else -1)
                cx = darts[i][0] + r * (darts[j][0] - darts[i][0]) / dist * cos(loc_angle) - r * (darts[j][1] - darts[i][1]) / dist * sin(loc_angle)
                cy = darts[i][1] + r * (darts[j][0] - darts[i][0]) / dist * sin(loc_angle) + r * (darts[j][1] - darts[i][1]) / dist * cos(loc_angle)

                cnt = 0
                for l in range(n):
                    new_dist = sqrt((darts[l][0] - cx)**2 + (darts[l][1] - cy)**2)
                    if new_dist <= r + 1e-5: cnt += 1

                max_darts = max(max_darts, cnt)

    return max_darts

-----
from math import acos, cos, sin, sqrt
    # Your code here


************************************
Question ID: 1564
def maxBoxesInWarehouse(boxes, warehouse):
    n = len(warehouse)
    for i in range(1, n):
        warehouse[i] = min(warehouse[i], warehouse[i - 1])
    boxes.sort(reverse=True)
    boxIndex = 0
    boxesCount = 0
    for i in range(n):
        if boxIndex < len(boxes) and boxes[boxIndex] <= warehouse[i]:
            boxesCount += 1
            boxIndex += 1
    return boxesCount


-----
def maxBoxesInWarehouse(boxes, warehouse):
    # Your code here


************************************
Question ID: 1566
def is_prefix_of_word(sentence: str, search_word: str) -> int:
    words = sentence.split(' ')
    for index, word in enumerate(words, start=1):
        if word.startswith(search_word):
            return index
    return -1

-----
def is_prefix_of_word(sentence: str, search_word: str) -> int:
    # Your code here


************************************
Question ID: 1567
def max_vowels(s, k):
    max_count = count = 0
    for i, c in enumerate(s):
        count += int(c in 'aeiou')
        if i >= k:
            count -= int(s[i - k] in 'aeiou')
        max_count = max(max_count, count)
    return max_count


-----
def max_vowels(s, k):
    # Your code here


************************************
Question ID: 1568
def pseudoPalindromicPaths(root, cnt = 0):
    if not root:
        return 0
    cnt ^= 1 << (root.val - 1)
    if not root.left and not root.right:
        return (cnt & (cnt - 1)) == 0
    return pseudoPalindromicPaths(root.left, cnt) + pseudoPalindromicPaths(root.right, cnt)

-----
def pseudoPalindromicPaths(root, cnt = 0):
    # Your code here


************************************
Question ID: 1569
def maxDotProduct(nums1, nums2):
    n, m = len(nums1), len(nums2)
    dp = [[float('-inf') for _ in range(m + 1)] for _ in range(n + 1)]
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            dp[i][j] = max(dp[i][j], dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1], nums1[i - 1] * nums2[j - 1])
    return dp[n][m]

-----
def maxDotProduct(nums1, nums2):
    # Your code here


************************************
Question ID: 1570
def final_prices(prices):
    for i in range(len(prices)):
        for j in range(i + 1, len(prices)):
            if prices[j] <= prices[i]:
                prices[i] -= prices[j]
                break
    return prices

-----
def final_prices(prices):
    # Your code here


************************************
Question ID: 1573
def min_sum_of_lengths(arr, target):
    n = len(arr)
    sum_, min_len, result = 0, float('inf'), float('inf')
    mp = {0: -1}

    for i in range(n):
        sum_ += arr[i]
        if sum_ >= target and (sum_ - target) in mp:
            if mp[sum_ - target] > -1 and min_len != float('inf'):
                result = min(result, i - mp[sum_ - target] + min_len)
            min_len = min(min_len, i - mp[sum_ - target])
        mp[sum_] = i

    return result if result != float('inf') else -1


-----
def min_sum_of_lengths(arr, target):
    # Your code here


************************************
Question ID: 1574
def findLengthOfShortestSubarray(arr):
    n = len(arr)
    left, right = 0, n - 1
    while left < n - 1 and arr[left] <= arr[left + 1]:
        left += 1
    if left == n - 1:
        return 0
    while right > 0 and arr[right] >= arr[right - 1]:
        right -= 1
    result = min(n - left - 1, right)
    i, j = 0, right
    while i <= left and j < n:
        if arr[i] <= arr[j]:
            result = min(result, j - i - 1)
            i += 1
        else:
            j += 1
    return result

-----
def findLengthOfShortestSubarray(arr):
    # Your code here


************************************
Question ID: 1575
def maxArea(h, w, horizontalCuts, verticalCuts):
    horizontalCuts.sort()
    verticalCuts.sort()

    maxH = max(horizontalCuts[0], h - horizontalCuts[-1])
    maxV = max(verticalCuts[0], w - verticalCuts[-1])

    for i in range(1, len(horizontalCuts)):
        maxH = max(maxH, horizontalCuts[i] - horizontalCuts[i - 1])

    for i in range(1, len(verticalCuts)):
        maxV = max(maxV, verticalCuts[i] - verticalCuts[i - 1])

    return (maxH * maxV) % (10**9 + 7)

-----
def maxArea(h, w, horizontalCuts, verticalCuts):
    # Your code here


************************************
Question ID: 1576
from collections import defaultdict

def dfs(node, parent, graph, count):
    if node != 0 and parent == 0:
        count[0] += 1

    for neighbor in graph[node]:
        if neighbor != parent:
            dfs(neighbor, node, graph, count)

def minReorder(n, connections):
    graph = defaultdict(list)
    for a, b in connections:
        graph[a].append(b)
        graph[b].append(a)

    count = [0]
    dfs(0, -1, graph, count)
    return count[0]

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1578
def minTime(colors: str, neededTime: List[int]) -> int:
    res, prev = 0, -1
    for i in range(len(colors) - 1):
        if colors[i] == colors[i + 1]:
            if prev == -1 or neededTime[i] < neededTime[prev]:
                prev = i
            if neededTime[i + 1] < neededTime[prev]:
                prev = i + 1
            res += neededTime[prev]
            neededTime[prev] = 1000000
            prev = -1
    return res

-----
def minTime(colors: str, neededTime: List[int]) -> int:
    # Your code here


************************************
Question ID: 1580
def shuffle(nums, n):
    shuffled = []
    for i in range(n):
        shuffled.append(nums[i])
        shuffled.append(nums[i+n])
    return shuffled

-----
def shuffle(nums, n):
    # Your code here


************************************
Question ID: 1583
def minCost(houses, cost, m, n, target):
    dp = [[[float('inf')] * (target + 1) for _ in range(n)] for _ in range(m)]

    if houses[0] != 0:
        dp[0][houses[0] - 1][1] = 0
    else:
        for j in range(n):
            dp[0][j][1] = cost[0][j]

    for i in range(1, m):
        for j in range(n):
            for k in range(1, target + 1):
                if houses[i] != 0 and houses[i] != j + 1:
                    continue
                paint_cost = 0 if houses[i] != 0 else cost[i][j]

                for l in range(n):
                    if l == j:
                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][l][k] + paint_cost)
                    else:
                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][l][k - 1] + paint_cost)

    ans = min(dp[m - 1][j][target] for j in range(n))
    return -1 if ans == float('inf') else ans


-----
def minCost(houses, cost, m, n, target):
    # Your code here


************************************
Question ID: 1584
def average(salary):
    min_salary = min(salary)
    max_salary = max(salary)
    sum_salaries = sum(salary)
    sum_salaries -= (min_salary + max_salary)
    return sum_salaries / (len(salary) - 2)

-----
def average(salary):
    # Your code here


************************************
Question ID: 1585
def kth_factor(n: int, k: int) -> int:
    for i in range(1, n+1):
        if n % i == 0:
            k -= 1
            if k == 0:
                return i
    return -1


-----
def kth_factor(n: int, k: int) -> int:
    # Your code here


************************************
Question ID: 1586
def findMaxLength(nums):
    max_length, zeroes, ones = 0, 0, 0
    count_map = {0: -1}

    for i, num in enumerate(nums):
        if num == 0:
            zeroes += 1
        else:
            ones += 1

        if zeroes - ones not in count_map:
            count_map[zeroes - ones] = i
        else:
            max_length = max(max_length, i - count_map[zeroes - ones])

    return max_length

-----
def findMaxLength(nums):
    # Your code here


************************************
Question ID: 1588
def sumOddLengthSubarrays(arr):
    sum = 0
    n = len(arr)
    for i in range(n):
        oddSubarrays = ((i + 1) * (n - i) + 1) // 2
        sum += arr[i] * oddSubarrays
    return sum

-----
def sumOddLengthSubarrays(arr):
    # Your code here


************************************
Question ID: 1589
def maxSumRangeQuery(nums, requests):
    n = len(nums)
    count = [0] * n
    for request in requests:
        count[request[0]] += 1
        if request[1] + 1 < n:
            count[request[1] + 1] -= 1
    for i in range(1, n):
        count[i] += count[i - 1]

    nums.sort()
    count.sort()

    ans = 0
    for i in range(n):
        ans = (ans + nums[i] * count[i]) % 1000000007
    return ans

-----
def maxSumRangeQuery(nums, requests):
    # Your code here


************************************
Question ID: 1590
def minSubarray(nums, p):
    n, res, need, cur = len(nums), len(nums), 0, 0
    for num in nums:
        need = (need + num) % p
    if need == 0:
        return 0
    last_seen = {0: -1}
    for i, num in enumerate(nums):
        cur = (cur + num) % p
        last_seen[cur] = i
        res = min(res, i - last_seen.get((cur - need + p) % p, -n))
    return res if res < n else -1

-----
def minSubarray(nums, p):
    # Your code here


************************************
Question ID: 1591
def isPrintable(self, targetGrid: List[List[int]]) -> bool:
    color_bounds = {}
    m, n = len(targetGrid), len(targetGrid[0])

    for i in range(m):
        for j in range(n):
            color = targetGrid[i][j]
            if color not in color_bounds:
                color_bounds[color] = [i, j, i, j]
            else:
                color_bounds[color][0] = min(color_bounds[color][0], i)
                color_bounds[color][1] = min(color_bounds[color][1], j)
                color_bounds[color][2] = max(color_bounds[color][2], i)
                color_bounds[color][3] = max(color_bounds[color][3], j)

    remaining_colors = set(color_bounds.keys())
    while remaining_colors:
        progress = False
        to_remove = set()
        for color in remaining_colors:
            bounds = color_bounds[color]
            contained = all(targetGrid[i][j] == color or targetGrid[i][j] == -1
                        for i in range(bounds[0], bounds[2] + 1)
                        for j in range(bounds[1], bounds[3] + 1))
            if contained:
                for i in range(bounds[0], bounds[2] + 1):
                    for j in range(bounds[1], bounds[3] + 1):
                        targetGrid[i][j] = -1
                to_remove.add(color)
                progress = True

        remaining_colors -= to_remove
        if not progress:
            return False

    return True


-----
def isPrintable(self, targetGrid: List[List[int]]) -> bool:
    # Your code here


************************************
Question ID: 1592
def reorderSpaces(text):
    spaces = text.count(' ')
    words = text.split()
    num_words = len(words)
    
    if num_words == 1:
        spaces_between_words = 0
    else:
        spaces_between_words = spaces // (num_words - 1)
    
    extra_spaces = spaces - spaces_between_words * (num_words - 1)

    return (' ' * spaces_between_words).join(words) + ' ' * extra_spaces

-----
def reorderSpaces(text):
    # Your code here


************************************
Question ID: 1593
def maxUniqueSplit(s, start=0, seen=None):
    if seen is None:
        seen = set()
    if start == len(s):
        return 0
    maxUnique = -1
    for i in range(start + 1, len(s) + 1):
        sub = s[start:i]
        if sub not in seen:
            seen.add(sub)
            unique = maxUniqueSplit(s, i, seen)
            if unique != -1:
                maxUnique = max(maxUnique, unique + 1)
            seen.remove(sub)
    return maxUnique

-----
def maxUniqueSplit(s, start=0, seen=None):
    # Your code here


************************************
Question ID: 1594
def maxProductPath(self, grid: List[List[int]]) -> int:
    m, n, mod = len(grid), len(grid[0]), 10**9 + 7
    dp = [[[0, 0] for _ in range(n)] for _ in range(m)]
    dp[0][0] = [grid[0][0], grid[0][0]]
    for i in range(1, m):
        dp[i][0] = [grid[i][0] * dp[i - 1][0][0], grid[i][0] * dp[i - 1][0][0]]
    for j in range(1, n):
        dp[0][j] = [grid[0][j] * dp[0][j - 1][0], grid[0][j] * dp[0][j - 1][0]]
    for i in range(1, m):
        for j in range(1, n):
            if grid[i][j] < 0:
                dp[i][j][0] = min(grid[i][j] * dp[i - 1][j][1], grid[i][j] * dp[i][j - 1][1])
                dp[i][j][1] = max(grid[i][j] * dp[i - 1][j][0], grid[i][j] * dp[i][j - 1][0])
            else:
                dp[i][j][0] = min(grid[i][j] * dp[i - 1][j][0], grid[i][j] * dp[i][j - 1][0])
                dp[i][j][1] = max(grid[i][j] * dp[i - 1][j][1], grid[i][j] * dp[i][j - 1][1])
    return -1 if dp[-1][-1][1] < 0 else dp[-1][-1][1] % mod

-----
def maxProductPath(self, grid: List[List[int]]) -> int:
    # Your code here


************************************
Question ID: 1595
def connectTwoGroups(cost):
    size1, size2 = len(cost), len(cost[0])
    min_cost = [float('inf')] * size2

    for i in range(size1):
        for j in range(size2):
            min_cost[j] = min(min_cost[j], cost[i][j])

    total_cost = 0
    for i in range(size1):
        total_cost += min(cost[i])

    for j in range(size2):
        total_cost += min_cost[j]

    return total_cost


-----
def connectTwoGroups(cost):
    # Your code here


************************************
Question ID: 1598
def minOperations(logs):
    depth = 0
    for log in logs:
        if log == "../":
            depth = max(0, depth - 1)
        elif log != "./":
            depth += 1
    return depth

-----
def minOperations(logs):
    # Your code here


************************************
Question ID: 1599
def minOperationsMaxProfit(customers, boardingCost, runningCost):
    waiting = 0
    profit = 0
    max_profit = 0
    rotations = 0
    result = -1

    for i in range(len(customers) + sum(customers)):
        if i < len(customers):
            waiting += customers[i]
        boarding = min(waiting, 4)
        waiting -= boarding
        profit += boarding * boardingCost - runningCost

        if profit > max_profit:
            max_profit = profit
            result = rotations + 1
        rotations += 1
    
    return result


-----
def minOperationsMaxProfit(customers, boardingCost, runningCost):
    # Your code here


************************************
Question ID: 1601
def maximumRequests(n, requests):
    req_size = len(requests)
    max_requests = 0

    for i in range(1 << req_size):
        net_transfers = [0] * n
        count = 0
        
        for j in range(req_size):
            if i & (1 << j):
                net_transfers[requests[j][0]] -= 1
                net_transfers[requests[j][1]] += 1
                count += 1

        valid = all(val == 0 for val in net_transfers)

        if valid:
            max_requests = max(max_requests, count)

    return max_requests

-----
def maximumRequests(n, requests):
    # Your code here


************************************
Question ID: 1603
def runningSum(nums):
    for i in range(1, len(nums)):
        nums[i] += nums[i - 1]
    return nums

-----
def runningSum(nums):
    # Your code here


************************************
Question ID: 1604
import heapq
from collections import Counter

def find_least_num_of_unique_ints(arr, k):
    freq_map = Counter(arr)
    min_heap = list(freq_map.values())
    heapq.heapify(min_heap)

    while k > 0:
        k -= heapq.heappop(min_heap)

    return len(min_heap) if k == 0 else len(min_heap) + 1

-----
import heapq
    # Your code here


************************************
Question ID: 1605
def minDays(bloomDay, m, k):
    left, right = min(bloomDay), max(bloomDay)

    while left < right:
        mid = left + (right - left) // 2
        bouquets = flowers = 0
        for day in bloomDay:
            if day > mid:
                flowers = 0
            else:
                flowers += 1
                if flowers == k:
                    bouquets += 1
                    flowers = 0

        if bouquets >= m:
            right = mid
        else:
            left = mid + 1

    return -1 if m == 0 else left

-----
def minDays(bloomDay, m, k):
    # Your code here


************************************
Question ID: 1606
def busiestServers(k, arrival, load):
    server_status = [-1] * k
    server_request_count = [0] * k

    for i in range(len(arrival)):
        index = i % k
        for _ in range(k):
            if server_status[index] <= arrival[i]:
                server_status[index] = arrival[i] + load[i]
                server_request_count[index] += 1
                break
            index = (index + 1) % k

    max_requests = max(server_request_count)
    return [i for i in range(k) if server_request_count[i] == max_requests]

-----
def busiestServers(k, arrival, load):
    # Your code here


************************************
Question ID: 1608
def specialArray(nums):
    max_val = max(nums)
    for x in range(1, max_val + 1):
        count = sum([1 for num in nums if num >= x])
        if count == x:
            return x
    return -1

-----
def specialArray(nums):
    # Your code here


************************************
Question ID: 1609
from collections import deque

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def is_even_odd_tree(root):
    if not root:
        return False
    
    q = deque([root])
    level = 0
    
    while q:
        size = len(q)
        prev_val = 0 if level % 2 == 0 else 10**6 + 1
        
        for _ in range(size):
            curr = q.popleft()
            
            if ((level % 2 == 0 and (curr.val % 2 == 0 or curr.val <= prev_val)) or 
                (level % 2 != 0 and (curr.val % 2 != 0 or curr.val >= prev_val))):
                return False
            
            prev_val = curr.val
            
            if curr.left:
                q.append(curr.left)
            if curr.right:
                q.append(curr.right)
        
        level += 1
    
    return True

-----
from collections import deque
    # Your code here


************************************
Question ID: 1610
def xor_operation(n, start):
    xor_result = 0
    for i in range(n):
        xor_result ^= (start + 2 * i)
    return xor_result

-----
def xor_operation(n, start):
    # Your code here


************************************
Question ID: 1611
def get_folder_names(names):
    name_count = {}
    ans = []

    for name in names:
        if name not in name_count:
            ans.append(name)
            name_count[name] = 1
        else:
            k = name_count[name]
            new_name = f"{name}({k})"
            while new_name in name_count:
                k += 1
                new_name = f"{name}({k})"
            ans.append(new_name)
            name_count[new_name] = 1
            name_count[name] = k + 1

    return ans

-----
def get_folder_names(names):
    # Your code here


************************************
Question ID: 1612
from sortedcontainers import SortedSet

def avoidFlood(rains: List[int]) -> List[int]:
    res = [-1] * len(rains)
    filled_lakes = {}
    dry_days = SortedSet()

    for i, lake in enumerate(rains):
        if lake == 0:
            dry_days.add(i)
        else:
            if lake in filled_lakes:
                day = dry_days.ceiling(filled_lakes[lake])
                if day is None:
                    return []
                res[day] = lake
                dry_days.remove(day)
            filled_lakes[lake] = i

    for day in dry_days:
        res[day] = 1

    return res


-----
from sortedcontainers import SortedSet
    # Your code here


************************************
Question ID: 1614
def maxDepth(s: str) -> int:
    depth = 0
    max_depth = 0

    for c in s:
        if c == '(':
            depth += 1
            max_depth = max(depth, max_depth)
        elif c == ')':
            depth -= 1

    return max_depth

-----
def maxDepth(s: str) -> int:
    # Your code here


************************************
Question ID: 1615
def range_sum(nums, n, left, right):
    MOD = 10**9 + 7
    sums = []
    for i in range(n):
        sum = 0
        for j in range(i, n):
            sum += nums[j]
            sums.append(sum)
    sums.sort()
    result = 0
    for i in range(left-1, right):
        result = (result + sums[i]) % MOD
    return result

-----
def range_sum(nums, n, left, right):
    # Your code here


************************************
Question ID: 1616
def min_difference(nums):
    size = len(nums)
    if size < 5:
        return 0

    nums.sort()

    return min(nums[-1] - nums[3], nums[-2] - nums[2], nums[-3] - nums[1], nums[-4] - nums[0])

-----
def min_difference(nums):
    # Your code here


************************************
Question ID: 1617
def winnerSquareGame(n: int) -> bool:
    dp = [False] * (n + 1)
    for i in range(1, n + 1):
        j = 1
        while j * j <= i:
            if not dp[i - j * j]:
                dp[i] = True
                break
            j += 1
    return dp[n]

-----
def winnerSquareGame(n: int) -> bool:
    # Your code here


************************************
Question ID: 1618
def max_font_size(text: str, w: int, h: int, fonts: List[int], font_info) -> int:
    left, right, ans = 0, len(fonts) - 1, -1
    while left <= right:
        mid = left + (right - left) // 2
        font_size = fonts[mid]
        width, height = sum(font_info.getWidth(font_size, ch) for ch in text), font_info.getHeight(font_size)
        if width <= w and height <= h:
            ans = font_size
            left = mid + 1
        else:
            right = mid - 1
    return ans

-----
def max_font_size(text: str, w: int, h: int, fonts: List[int], font_info) -> int:
    # Your code here


************************************
Question ID: 1619
def is_path_crossing(path: str) -> bool:
    visited = {(0, 0)}
    x, y = 0, 0
    for dir in path:
        if dir == 'N': y += 1
        elif dir == 'S': y -= 1
        elif dir == 'E': x += 1
        elif dir == 'W': x -= 1
        if (x, y) in visited: return True
        visited.add((x, y))
    return False

-----
def is_path_crossing(path: str) -> bool:
    # Your code here


************************************
Question ID: 1620
def canArrange(arr, k):
    counts = [0] * k
    for num in arr:
        counts[(num % k + k) % k] += 1
    if counts[0] % 2 != 0:
        return False
    for i in range(1, k // 2 + 1):
        if counts[i] != counts[k - i]:
            return False
    return True

-----
def canArrange(arr, k):
    # Your code here


************************************
Question ID: 1621
def numSubseq(nums, target):
    nums.sort()
    n = len(nums)
    mod = 10**9 + 7

    power = [1] * n
    for i in range(1, n):
        power[i] = (power[i - 1] * 2) % mod

    ans = 0
    r = n
    for l in range(n):
        while r > l and nums[l] + nums[r - 1] > target:
            r -= 1

        ans = (ans + power[r - l]) % mod

    return ans


-----
def numSubseq(nums, target):
    # Your code here


************************************
Question ID: 1622
from collections import deque

def findMaxValueOfEquation(points, k):
    res = -float("inf")
    q = deque()
   
    for p in points:
        while q and p[0] - q[0][1] > k:
            q.popleft()
        
        if q:
            res = max(res, p[1] + p[0] + q[0][0])
        
        while q and p[1] - p[0] >= q[-1][0]:
            q.pop()
        
        q.append((p[1] - p[0], p[0]))
    
    return res


-----
from collections import deque
    # Your code here


************************************
Question ID: 1624
def maxLengthBetweenEqualCharacters(s: str) -> int:
    result = -1
    char_map = {}

    for i, c in enumerate(s):
        if c not in char_map:
            char_map[c] = i
        else:
            result = max(result, i - char_map[c] - 1)

    return result

-----
def maxLengthBetweenEqualCharacters(s: str) -> int:
    # Your code here


************************************
Question ID: 1625
def findLexSmallestString(s: str, a: int, b: int) -> str:
    def add_odd(s: str, a: int) -> str:
        return ''.join([str((int(ch) + a) % 10) if idx % 2 else ch for idx, ch in enumerate(s)])

    def rotate(s: str, k: int) -> str:
        k %= len(s)
        return s[-k:] + s[:-k]

    smallest = s
    for _ in range(len(s)):
        for _ in range(10):
            rotated = rotate(s, b)
            temp = add_odd(rotated, a)
            smallest = min(smallest, temp)
            s = rotated
        s = add_odd(s, a)
    return smallest

-----
def findLexSmallestString(s: str, a: int, b: int) -> str:
    # Your code here


************************************
Question ID: 1626
def can_make_arithmetic_progression(arr):
    arr.sort()
    difference = arr[1] - arr[0]
    for i in range(2, len(arr)):
        if arr[i] - arr[i - 1] != difference:
            return False
    return True

-----
def can_make_arithmetic_progression(arr):
    # Your code here


************************************
Question ID: 1627
def lastMoment(n, left, right):
    max_left = max(left, default=0)
    min_right = min(right, default=n)

    return max(max_left, n - min_right)

-----
def lastMoment(n, left, right):
    # Your code here


************************************
Question ID: 1628
def numSubmat(mat):
    m, n = len(mat), len(mat[0])
    dp = [[0] * n for _ in range(m)]
    count = 0

    for i in range(m):
        for j in range(n):
            if mat[i][j] == 1:
                dp[i][j] = (1 if j == 0 else dp[i][j - 1] + 1)
                minWidth = dp[i][j]
                for k in range(i, -1, -1):
                    minWidth = min(minWidth, dp[k][j])
                    count += minWidth

    return count

-----
def numSubmat(mat):
    # Your code here


************************************
Question ID: 1629
def minInteger(num: str, k: int) -> str:
    if k == 0:
        return num
    num = list(num)
    n = len(num)
    for i in range(n):
        idx = i
        for j in range(i + 1, n):
            if j - i > k:
                break
            if num[j] < num[idx]:
                idx = j
        min_digit = num[idx]
        for j in range(idx, i, -1):
            num[j] = num[j - 1]
        num[i] = min_digit
        k -= idx - i
    return ''.join(num)

-----
def minInteger(num: str, k: int) -> str:
    # Your code here


************************************
Question ID: 1630
def count_odds(low, high):
    return (high + 1) // 2 - low // 2

-----
def count_odds(low, high):
    # Your code here


************************************
Question ID: 1631
def numOfSubarrays(arr):
    odd, even, sum_, result = 0, 1, 0, 0
    mod = 10**9 + 7
    for x in arr:
        sum_ = (sum_ + x) % 2
        if sum_ % 2 == 0:
            even += 1
        else:
            odd += 1
        result = (result + odd) % mod
    return result

-----
def numOfSubarrays(arr):
    # Your code here


************************************
Question ID: 1632
def numSplits(s: str) -> int:
    left_set, right_set = set(), set()
    left, right = [0] * len(s), [0] * len(s)
    count = 0

    for i, char in enumerate(s):
        left_set.add(char)
        left[i] = len(left_set)

    for i in range(len(s) - 1, 0, -1):
        right_set.add(s[i])
        right[i] = len(right_set)

    for i in range(len(s) - 1):
        if left[i] == right[i + 1]:
            count += 1

    return count

-----
def numSplits(s: str) -> int:
    # Your code here


************************************
Question ID: 1636
def num_sub(s: str) -> int:
    mod = 1000000007
    result = 0
    count = 0
    for c in s:
        count = count + 1 if c == '1' else 0
        result = (result + count) % mod
    return result

-----
def num_sub(s: str) -> int:
    # Your code here


************************************
Question ID: 1637
def min_length_encoded(s: str, k: int) -> int:
    n = len(s)
    dp = [[0] * (k + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for j in range(k + 1):
            cnt = 1
            dp[i][j] = i - j
            l = i - 2
            while l >= 0 and i - 2 - l <= j:
                if s[l] == s[i - 1]:
                    cnt += 1
                else:
                    cnt = 1
                used = i - 2 - l
                new_aposition = i - 1 - cnt - used + 1
                if cnt >= 100:
                    new_aposition += 4
                elif cnt >= 10:
                    new_aposition += 3
                elif cnt >= 2:
                    new_aposition += 2
                else:
                    new_aposition += 1
                dp[i][j] = min(dp[i][j], new_aposition + dp[l][j - used])
                l -= 1

    return dp[n][k]

-----
def min_length_encoded(s: str, k: int) -> int:
    # Your code here


************************************
Question ID: 1638
def get_min_dist_sum(positions: List[List[int]]) -> float:
    x, y = 0, 0
    n = len(positions)
    for pos in positions:
        x += pos[0]
        y += pos[1]
    x /= n
    y /= n
    return x

-----
def get_min_dist_sum(positions: List[List[int]]) -> float:
    # Your code here


************************************
Question ID: 1639
def numWays(words, target):
    n = len(words)
    m = len(target)
    count = [[0] * 26 for _ in range(n)]
    dp = [[0] * n for _ in range(m)]
    mod = 1000000007

    for i, word in enumerate(words):
        for c in word:
            count[i][ord(c) - ord('a')] += 1

    for i in range(n):
        dp[0][i] = count[i][ord(target[0]) - ord('a')]

    for i in range(1, m):
        for j in range(n):
            for k in range(n):
                dp[i][j] = (dp[i][j] + dp[i-1][k] * count[j][ord(target[i]) - ord('a')]) % mod

    return sum(dp[m-1]) % mod

-----
def numWays(words, target):
    # Your code here


************************************
Question ID: 1640
def canFormArray(arr, pieces):
    map = {piece[0]: piece for piece in pieces}

    i = 0
    while i < len(arr):
        if arr[i] not in map:
            return False
        piece = map[arr[i]]
        for num in piece:
            if num != arr[i]:
                return False
            i += 1
    return True


-----
def canFormArray(arr, pieces):
    # Your code here


************************************
Question ID: 1641
def countVowelStrings(n: int) -> int:
    dp = [1, 1, 1, 1, 1]
    for i in range(2, n + 1):
        for j in range(3, -1, -1):
            dp[j] = dp[j] + dp[j + 1]
    return sum(dp)

-----
def countVowelStrings(n: int) -> int:
    # Your code here


************************************
Question ID: 1642
def maxWaterBottles(numBottles: int, numExchange: int) -> int:
    total = numBottles
    while numBottles >= numExchange:
        newBottles = numBottles // numExchange
        total += newBottles
        numBottles = newBottles + numBottles % numExchange
    return total

-----
def maxWaterBottles(numBottles: int, numExchange: int) -> int:
    # Your code here


************************************
Question ID: 1643
from collections import defaultdict

def dfs(node, tree, labels, ans, count):
    prev_count = count[labels[node]]
    count[labels[node]] += 1
    ans[node] = count[labels[node]] - prev_count

    for child in tree[node]:
        dfs(child, tree, labels, ans, count)

    count[labels[node]] = prev_count

def countSubTrees(n, edges, labels):
    tree = defaultdict(list)
    for edge in edges:
        tree[edge[1]].append(edge[0])

    ans = [0] * n
    count = defaultdict(int)
    dfs(0, tree, labels, ans, count)

    return ans

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1644
def max_num_of_substrings(s: str) -> List[str]:
    last = [-1] * 26
    for i, ch in enumerate(s):
        last[ord(ch) - ord('a')] = i
    
    res = []
    pre, max_right = -1, -1
    for i, ch in enumerate(s):
        max_right = max(max_right, last[ord(ch) - ord('a')])
        if max_right == i:
            res.append(s[pre + 1:max_right + 1])
            pre = i
    
    return res

-----
def max_num_of_substrings(s: str) -> List[str]:
    # Your code here


************************************
Question ID: 1646
def findKthPositive(arr, k):
    i, num = 0, 1
    while k > 0:
        if i < len(arr) and arr[i] == num:
            i += 1
        else:
            k -= 1
        num += 1
    return num - 1

-----
def findKthPositive(arr, k):
    # Your code here


************************************
Question ID: 1647
def can_convert(s, t, k):
    diff = 0
    for i in range(len(s)):
        curr_diff = (ord(t[i]) - ord(s[i]) + 26) % 26
        if curr_diff > 0:
            diff += curr_diff
            k -= curr_diff
    return k >= 0 and k >= diff - len(s) and k % 26 == 0

-----
def can_convert(s, t, k):
    # Your code here


************************************
Question ID: 1648
def minInsertions(s: str) -> int:
    ans, depth = 0, 0
    for i in range(len(s)):
        if s[i] == '(':
            depth += 2
        else:
            if s[i - 1] == '(':
                depth -= 1
            else:
                depth -= 2
            if depth < 0:
                ans -= depth
                depth = 0
    return ans + depth

-----
def minInsertions(s: str) -> int:
    # Your code here


************************************
Question ID: 1649
def maxNonOverlapping(nums, target):
    prefix_sum = {0: 1}
    sum_so_far = count = 0
    for num in nums:
        sum_so_far += num
        if sum_so_far - target in prefix_sum:
            count += 1
            prefix_sum.clear()
            prefix_sum[0] = 1
            sum_so_far = 0
        else:
            prefix_sum[sum_so_far] = prefix_sum.get(sum_so_far, 0) + 1
    return count


-----
def maxNonOverlapping(nums, target):
    # Your code here


************************************
Question ID: 1652
def minOperations(target: str) -> int:
    operations = 0
    current_bit = '0'
    for bit in target:
        if bit != current_bit:
            operations += 1
            current_bit = bit
    return operations

-----
def minOperations(target: str) -> int:
    # Your code here


************************************
Question ID: 1653
def dfs(root, distance, depths):
    if not root:
        return 0
    if not root.left and not root.right:
        depths.append(0)
        return 1
    left, right = [], []
    count = dfs(root.left, distance, left) + dfs(root.right, distance, right)
    for l in left:
        for r in right:
            if l + r + 2 <= distance:
                count += 1
    depths.extend(l + 1 for l in left)
    depths.extend(r + 1 for r in right)
    return count

def countPairs(root, distance):
    depths = []
    return dfs(root, distance, depths)

-----
def dfs(root, distance, depths):
    # Your code here


************************************
Question ID: 1654
from collections import deque

def minimumJumps(forbidden, a, b, x):
    forbidden_positions = set(forbidden)
    q = deque([(0, 0, 0)])
    visited = {(0, 0)}
    while q:
        pos, steps, backward = q.popleft()
        if pos == x:
            return steps
        forward_pos = pos + a
        backward_pos = pos - b
        if forward_pos <= 6000 and forward_pos not in forbidden_positions and (forward_pos, 0) not in visited:
            visited.add((forward_pos, 0))
            q.append((forward_pos, steps + 1, 0))
        if backward == 0 and backward_pos > 0 and backward_pos not in forbidden_positions and (backward_pos, 1) not in visited:
            visited.add((backward_pos, 1))
            q.append((backward_pos, steps + 1, 1))
    return -1

-----
from collections import deque
    # Your code here


************************************
Question ID: 1655
from collections import Counter

def canDistribute(nums, quantity):
    counts = Counter(nums)
    values = list(counts.values())
    quantity.sort(reverse=True)

    def dfs(index, values):
        if index == len(quantity):
            return True
        for i in range(len(values)):
            if values[i] >= quantity[index]:
                values[i] -= quantity[index]
                if dfs(index + 1, values):
                    return True
                values[i] += quantity[index]
        return False

    return dfs(0, values)


-----
from collections import Counter
    # Your code here


************************************
Question ID: 1656
def count_good_triplets(arr, a, b, c):
    count = 0
    for i in range(len(arr)):
        for j in range(i+1, len(arr)):
            if abs(arr[i] - arr[j]) <= a:
                for k in range(j+1, len(arr)):
                    if abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:
                        count += 1
    return count


-----
def count_good_triplets(arr, a, b, c):
    # Your code here


************************************
Question ID: 1657
def get_winner(arr, k):
    winner = arr[0]
    consecutive_wins = 0

    for i in range(1, len(arr)):
        if arr[i] > winner:
            winner = arr[i];
            consecutive_wins = 0

        consecutive_wins += 1
        if consecutive_wins == k:
            break

    return winner

-----
def get_winner(arr, k):
    # Your code here


************************************
Question ID: 1658
def min_swaps(grid):
    n = len(grid)
    row_zeros = [0] * n
    
    for i in range(n):
        for j in range(n - 1, -1, -1):
            if grid[i][j] == 0:
                row_zeros[i] += 1
            else:
                break
    
    steps = 0
    for i in range(n):
        target = n - i - 1
        current_row = i
        while current_row < n and row_zeros[current_row] < target:
            current_row += 1
        if current_row == n:
            return -1
        steps += current_row - i
        row_zeros.pop(current_row)
        row_zeros.insert(i, target)
    
    return steps

-----
def min_swaps(grid):
    # Your code here


************************************
Question ID: 1659
def maxSum(nums1, nums2):
    mod = 10**9 + 7
    m, n = len(nums1), len(nums2)
    dp1, dp2 = [0] * (m + 1), [0] * (n + 1)
    i, j = m - 1, n - 1
    while i >= 0 or j >= 0:
        a = dp1[i] + nums1[i] if i >= 0 else float('-inf')
        b = dp2[j] + nums2[j] if j >= 0 else float('-inf')
        seen = set()
        if a > b:
            dp1[i] = a % mod
            i -= 1
            seen.add(nums1[i + 1])
        else:
            dp2[j] = b % mod
            j -= 1
            seen.add(nums2[j + 1])
    return max(dp1[0], dp2[0]) % mod

-----
def maxSum(nums1, nums2):
    # Your code here


************************************
Question ID: 1660
def thousand_separator(n: int) -> str:
    result = str(n)
    count = 0
    for i in range(len(result) - 1, 0, -1):
        count += 1
        if count % 3 == 0:
            result = result[:i] + '.' + result[i:]
    return result

-----
def thousand_separator(n: int) -> str:
    # Your code here


************************************
Question ID: 1662
def min_num_operations(nums):
    result = 0
    highest_bit = [0] * 32
    for num in nums:
        for j in range(32):
            if num & (1 << j):
                highest_bit[j] += 1
    for count in highest_bit:
        result = max(result, count)
    return result + 31

-----
def min_num_operations(nums):
    # Your code here


************************************
Question ID: 1663
def contains_cycle(grid):
    def dfs(x, y, start_x, start_y, depth):
        if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] != grid[start_x][start_y]:
            return False
        
        grid[x][y] = '*'

        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        for dx, dy in directions:
            new_x, new_y = x + dx, y + dy

            if new_x == start_x and new_y == start_y and depth >= 4:
                return True

            if dfs(new_x, new_y, start_x, start_y, depth + 1):
                return True
        
        grid[x][y] = grid[start_x][start_y]

        return False

    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if dfs(i, j, i, j, 0):
                return True

    return False

-----
def contains_cycle(grid):
    # Your code here


************************************
Question ID: 1664
def numberOfFairs(nums):
    even_sum = sum(nums[0::2])
    odd_sum = sum(nums[1::2])
    l_even = l_odd = count = 0
    for i, num in enumerate(nums):
        if i % 2 == 0:
            even_sum -= num
            if l_even + odd_sum == l_odd + even_sum:
                count += 1
            l_even += num
        else:
            odd_sum -= num
            if l_even + odd_sum == l_odd + even_sum:
                count += 1
            l_odd += num
    return count

-----
def numberOfFairs(nums):
    # Your code here


************************************
Question ID: 1665
def minimumEffort(tasks):
    tasks.sort(key=lambda task: task[1] - task[0], reverse=True)
    ans, sum_energy = 0, 0
    for task in tasks:
        ans = max(ans, sum_energy + task[1])
        sum_energy += task[0]
    return ans

-----
def minimumEffort(tasks):
    # Your code here


************************************
Question ID: 1666
def make_good(s: str) -> str:
    result = []
    for c in s:
        if result and abs(ord(result[-1]) - ord(c)) == 32:
            result.pop()
        else:
            result.append(c)
    return "".join(result)


-----
def make_good(s: str) -> str:
    # Your code here


************************************
Question ID: 1668
def longestAwesomeSubstring(s):
    n = len(s)
    maxLen = 0
    for i in range(n):
        for j in range(i + 1, n + 1):
            substr = s[i:j]
            if isAwesome(substr):
                maxLen = max(maxLen, j - i)
    return maxLen

def isAwesome(s):
    odd_count = 0
    freq = [0] * 26
    for c in s:
        freq[ord(c) - ord('a')] += 1
    for i in range(26):
        if freq[i] % 2 == 1:
            odd_count += 1
    return odd_count <= 1

-----
def longestAwesomeSubstring(s):
    # Your code here


************************************
Question ID: 1669
def minCost(n, cuts):
    cuts = [0] + cuts + [n]
    cuts.sort()
    size = len(cuts)
    dp = [[0] * size for _ in range(size)]

    for len in range(2, size):
        for i in range(size - len):
            j = i + len
            dp[i][j] = float('inf')
            for k in range(i + 1, j):
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cuts[j] - cuts[i])

    return dp[0][size - 1]

-----
def minCost(n, cuts):
    # Your code here


************************************
Question ID: 1670
from collections import deque

class FrontMiddleBackQueue:

    def __init__(self):
        self.first = deque()
        self.second = deque()

    def pushFront(self, val: int) -> None:
        self.first.appendleft(val)
        if len(self.first) > len(self.second) + 1:
            self.second.appendleft(self.first.pop())

    def pushMiddle(self, val: int) -> None:
        if len(self.first) < len(self.second):
            self.first.append(val)
        else:
            self.second.appendleft(val)

    def pushBack(self, val: int) -> None:
        self.second.append(val)
        if len(self.second) > len(self.first):
            self.first.append(self.second.popleft())

    def popFront(self) -> int:
        if not self.first and not self.second:
            return -1
        val = self.first.popleft()
        if len(self.first) + 1 < len(self.second):
            self.first.append(self.second.popleft())
        return val

    def popMiddle(self) -> int:
        if not self.first and not self.second:
            return -1
        if len(self.first) < len(self.second):
            val = self.second.popleft()
        else:
            val = self.first.pop()
        if len(self.second) > len(self.first):
            self.first.append(self.second.popleft())
        return val

    def popBack(self) -> int:
        if not self.first and not self.second:
            return -1
        val = self.second.pop()
        if len(self.first) > len(self.second) + 1:
            self.second.appendleft(self.first.pop())
        return val


-----
from collections import deque
    # Your code here


************************************
Question ID: 1671
def minimumMountainRemovals(nums):
    n = len(nums)
    left, right = [0] * n, [0] * n
    for i in range(1, n):
        left[i] = left[i - 1] + int(nums[i] > nums[i - 1])
        right[n - i - 1] = right[n - i] + int(nums[n - i - 1] > nums[n - i])
    ans = n - 3
    for i in range(1, n - 1):
        ans = min(ans, n - 1 - left[i] - right[i])
    return ans

-----
def minimumMountainRemovals(nums):
    # Your code here


************************************
Question ID: 1672
def maximumWealth(accounts):
    max_wealth = 0
    for customer in accounts:
        wealth = sum(customer)
        max_wealth = max(max_wealth, wealth)
    return max_wealth

-----
def maximumWealth(accounts):
    # Your code here


************************************
Question ID: 1673
from collections import deque

def mostCompetitive(nums, k):
    stack = deque()
    n = len(nums)
    for i in range(n):
        while stack and stack[-1] > nums[i] and len(stack) + n - i > k:
            stack.pop()
        if len(stack) < k:
            stack.append(nums[i])
    return list(stack)


-----
from collections import deque
    # Your code here


************************************
Question ID: 1674
def min_operations(n):
    return n * (n - 1) // 2


-----
def min_operations(n):
    # Your code here


************************************
Question ID: 1675
from typing import List

def can_place_balls(force: int, position: List[int], m: int) -> bool:
    last_position = position[0]
    placed_balls = 1

    for i in range(1, len(position)):
        if position[i] - last_position >= force:
            placed_balls += 1
            last_position = position[i]

            if placed_balls == m:
                return True

    return False

def max_distance(position: List[int], m: int) -> int:
    position.sort()

    left = 1
    right = position[-1] - position[0]
    ans = 0

    while left <= right:
        mid = (left + right) // 2
        if can_place_balls(mid, position, m):
            ans = mid
            left = mid + 1
        else:
            right = mid - 1

    return ans

-----
from typing import List
    # Your code here


************************************
Question ID: 1678
def num_ways(s: str) -> int:
    number_of_ones = s.count('1')
    if number_of_ones % 3 != 0:
        return 0

    target = number_of_ones // 3
    if target == 0:
        n = len(s)
        return ((n - 1) * (n - 2) // 2) % 1000000007

    ones_so_far1, ones_so_far2 = 0, 0
    way1, way2 = 0, 0
    for c in s:
        if c == '1':
            ones_so_far1 += 1
            if ones_so_far1 == target:
                way1 += 1
                ones_so_far1 = 0

            ones_so_far2 += 1
            if ones_so_far2 == target * 2:
                way2 += 1
                ones_so_far2 = 0

    return (way1 * way2) % 1000000007


-----
def num_ways(s: str) -> int:
    # Your code here


************************************
Question ID: 1679
def findLengthOfShortestSubarray(arr):
    n = len(arr)
    left, right = 0, n - 1

    while left < n - 1 and arr[left] <= arr[left + 1]:
        left += 1

    if left == n - 1:
        return 0

    while right > 0 and arr[right] >= arr[right - 1]:
        right -= 1

    result = min(right, n - left - 1)

    i, j = 0, right

    while i <= left and j < n:
        if arr[i] <= arr[j]:
            result = min(result, j - i - 1)
            i += 1
        else:
            j += 1

    return result


-----
def findLengthOfShortestSubarray(arr):
    # Your code here


************************************
Question ID: 1680
def count_routes(locations, start, finish, fuel, curr=None, remaining_fuel=None, memo=None):
    if memo is None:
        memo = {}
     
    if curr is None:
        curr = start
        remaining_fuel = fuel

    if remaining_fuel < 0:
        return 0

    if (curr, remaining_fuel) in memo:
        return memo[(curr, remaining_fuel)]

    ans = 1 if curr == finish else 0
    for next in range(len(locations)):
        if next != curr:
            ans += count_routes(locations, start, finish, fuel, next, remaining_fuel - abs(locations[curr] - locations[next]), memo)
            ans %= 1000000007

    memo[(curr, remaining_fuel)] = ans
    return ans

-----
def count_routes(locations, start, finish, fuel, curr=None, remaining_fuel=None, memo=None):
    # Your code here


************************************
Question ID: 1682
def most_visited(n, rounds):
    visited = [0] * (n + 1)
    
    for i in range(1, len(rounds)):
        start, end = rounds[i - 1], rounds[i]
        while start != end:
            visited[start] += 1
            start = (start % n) + 1
    visited[rounds[-1]] += 1
    
    max_visits = max(visited);
    return [i for i in range(1, n + 1) if visited[i] == max_visits]

-----
def most_visited(n, rounds):
    # Your code here


************************************
Question ID: 1684
def find_latest_step(arr, m):
    n = len(arr)
    length_left, length_right = [0] * (n + 2), [0] * (n + 2)
    count, result = 0, -1

    for i, pos in enumerate(arr):
        left_length = length_right[pos - 1]
        right_length = length_left[pos + 1]
        new_length = left_length + right_length + 1

        if left_length == m or right_length == m:
            count -= 1

        if new_length == m:
            count += 1

        if new_length > 0:
            length_left[pos - left_length] = new_length
            length_right[pos + right_length] = new_length
            result = i + 1

    return result if count > 0 else -1


-----
def find_latest_step(arr, m):
    # Your code here


************************************
Question ID: 1685
def stoneGameV(stoneValue):
    memo = [[-1 for _ in range(len(stoneValue))] for _ in range(len(stoneValue))]
    return maxScore(stoneValue, 0, len(stoneValue) - 1, memo)

def maxScore(stoneValue, start, end, memo):
    if start == end:
        return 0
    if memo[start][end] != -1:
        return memo[start][end]

    left_sum, right_sum = 0, 0
    for i in range(start, end):
        left_sum += stoneValue[i]
        right_sum = sum(stoneValue[i + 1:end + 1])

        if left_sum > right_sum:
            memo[start][end] = max(memo[start][end], right_sum + maxScore(stoneValue, i + 1, end, memo))
        elif left_sum < right_sum:
            memo[start][end] = max(memo[start][end], left_sum + maxScore(stoneValue, start, i, memo))
        else:
            memo[start][end] = max(memo[start][end], left_sum + max(maxScore(stoneValue, start, i, memo), maxScore(stoneValue, i + 1, end, memo)))

    return memo[start][end]


-----
def stoneGameV(stoneValue):
    # Your code here


************************************
Question ID: 1686
def stoneGameVI(aliceValues, bobValues):
    n = len(aliceValues)
    diff = sorted([(aliceValues[i] + bobValues[i], i) for i in range(n)], reverse=True)

    aliceSum, bobSum = 0, 0
    for i in range(n):
        if i % 2 == 0:
            aliceSum += aliceValues[diff[i][1]]
        else:
            bobSum += bobValues[diff[i][1]]
            
    return 0 if aliceSum == bobSum else (1 if aliceSum > bobSum else -1)


-----
def stoneGameVI(aliceValues, bobValues):
    # Your code here


************************************
Question ID: 1687
def min_trips(boxes, portsCount, maxBoxes, maxWeight):
    trips = 0
    idx = 0
    n = len(boxes)
    while idx < n:
        curr_limit = maxWeight
        prev_port = 0
        count = 0
        while count < maxBoxes and idx < n:
            if boxes[idx][1] <= curr_limit:
                if prev_port != boxes[idx][0]:
                    prev_port = boxes[idx][0]
                    trips += 1
                curr_limit -= boxes[idx][1]
                count += 1
                idx += 1
            else:
                break
        trips += 1
    return trips

-----
def min_trips(boxes, portsCount, maxBoxes, maxWeight):
    # Your code here


************************************
Question ID: 1688
def numberOfMatches(n: int) -> int:
    matches = 0
    while n > 1:
        matches += n // 2
        n = (n + 1) // 2
    return matches

-----
def numberOfMatches(n: int) -> int:
    # Your code here


************************************
Question ID: 1689
def containsPattern(arr, m, k):
    n = len(arr)
    if m * k > n:
        return False

    for i in range(n - m * k + 1):
        patternFound = True
        for j in range(m):
            for l in range(1, k):
                if arr[i + j] != arr[i + j + l * m]:
                    patternFound = False
                    break
            if not patternFound:
                break
        if patternFound:
            return True
    return False

-----
def containsPattern(arr, m, k):
    # Your code here


************************************
Question ID: 1690
def getMaxLen(nums):
    maxLength = currentLen = currentNegLen = 0
    
    for num in nums:
        if num > 0:
            currentLen += 1
            if currentNegLen > 0:
                currentNegLen += 1
        elif num < 0:
            currentLen, currentNegLen = currentNegLen, currentLen + 1
        else:
            currentLen = currentNegLen = 0
        maxLength = max(maxLength, currentLen)
    
    return maxLength

-----
def getMaxLen(nums):
    # Your code here


************************************
Question ID: 1692
def numTrees(n: int) -> int:
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1

    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - 1 - j]
            dp[i] %= (10**9 + 7)

    return dp[n]

-----
def numTrees(n: int) -> int:
    # Your code here


************************************
Question ID: 1694
def min_subarray(nums, p):
    n = len(nums)
    need, cur, res = 0, 0, n
    last_seen = {}

    for num in nums:
        need = (need + num) % p

    if need == 0:
        return 0

    last_seen[cur] = -1
    for i, num in enumerate(nums):
        cur = (cur + num) % p
        last_seen[cur] = i
        want = (cur - need + p) % p
        if want in last_seen:
            res = min(res, i - last_seen[want])

    return res if res != n else -1


-----
def min_subarray(nums, p):
    # Your code here


************************************
Question ID: 1695
from typing import List

def maxSumRangeQuery(nums: List[int], requests: List[List[int]]) -> int:
    mod = 10**9 + 7
    n = len(nums)
    cnt = [0] * n
    
    for req in requests:
        cnt[req[0]] += 1
        if req[1] + 1 < n:
            cnt[req[1] + 1] -= 1
    
    for i in range(1, n):
        cnt[i] += cnt[i - 1]
    
    nums.sort()
    cnt.sort()
    
    ans = sum(nums[i] * cnt[i] for i in range(n)) % mod
    
    return ans

-----
from typing import List
    # Your code here


************************************
Question ID: 1696
def isPrintable(targetGrid):
    m, n = len(targetGrid), len(targetGrid[0])
    top, bottom, left, right = [m]*61, [-1]*61, [n]*61, [-1]*61
    vis = [[False]*n for _ in range(m)]

    for i in range(m):
        for j in range(n):
            c = targetGrid[i][j]
            top[c] = min(top[c], i)
            bottom[c] = max(bottom[c], i)
            left[c] = min(left[c], j)
            right[c] = max(right[c], j)

    def dfs(x):
        i, j = x // n, x % n
        if vis[i][j]: return True
        c = targetGrid[i][j]
        if i < top[c] or i > bottom[c] or j < left[c] or j > right[c]: return False
        vis[i][j] = True
        for k in range(1, 61):
            if k == c: continue
            if i >= top[k] and i <= bottom[k] and j >= left[k] and j <= right[k]: return False
            if not dfs(((i-top[k])*(right[k]-left[k]+1)) + j - left[k]): return False
        return True

    for color in range(1, 61):
        for i in range(top[color], bottom[color] + 1):
            for j in range(left[color], right[color] + 1):
                if not vis[i][j] and not dfs(i * n + j): return False

    return True


-----
def isPrintable(targetGrid):
    # Your code here


************************************
Question ID: 1697
from collections import defaultdict, deque

def distanceLimitedPathsExist(n, edgeList, queries):
    graph = defaultdict(list)

    for u, v, dis in edgeList:
        graph[u].append((v, dis))
        graph[v].append((u, dis))

    answer = [False] * len(queries)
    for i, (pj, qj, limitj) in enumerate(queries):
        q = deque([(pj, 0)])
        visited = [False] * n
        visited[pj] = True

        while q:
            curr_node, curr_dist = q.popleft()

            for next_node, next_dist in graph[curr_node]:
                if curr_dist + next_dist < limitj:
                    if next_node == qj:
                        answer[i] = True
                        break
                    if not visited[next_node]:
                        visited[next_node] = True
                        q.append((next_node, curr_dist + next_dist))
            if answer[i]:
                break

    return answer

-----
from collections import defaultdict, deque
    # Your code here


************************************
Question ID: 1698
def modifyString(s: str) -> str:
    s = list(s)
    for i in range(len(s)):
        if s[i] == '?':
            for c in range(ord('a'), ord('z') + 1):
                if (i - 1 < 0 or s[i - 1] != chr(c)) and (i + 1 >= len(s) or s[i + 1] != chr(c)):
                    s[i] = chr(c)
                    break
    return ''.join(s)


-----
def modifyString(s: str) -> str:
    # Your code here


************************************
Question ID: 1700
def min_time_to_remove_balloons(colors, neededTime):
    n = len(colors)
    INF = 10**9
    dp = [[INF] * 26 for _ in range(n)]

    for color in range(26):
        if colors[0] != chr(ord('A') + color):
            dp[0][color] = neededTime[0]

    for i in range(1, n):
        for color1 in range(26):
            for color2 in range(26):
                if color1 != color2 and colors[i] != chr(ord('A') + color1):
                    dp[i][color1] = min(dp[i][color1], dp[i-1][color2] + neededTime[i])

    ans = INF
    for color in range(26):
        ans = min(ans, dp[n-1][color])

    return ans


-----
def min_time_to_remove_balloons(colors, neededTime):
    # Your code here


************************************
Question ID: 1701
def maxNumEdgesToRemove(n, edges):
    def find(u):
        if parent[u] == u:
            return u
        else:
            parent[u] = find(parent[u])
            return parent[u]

    def unite(u, v):
        u = find(u)
        v = find(v)
        if u != v:
            parent[u] = v
            return True
        return False

    parent = list(range(2 * n + 1))
    ct = [0, 0]
    both = n - 1
    edges.sort(reverse=True)
    for edge in edges:
        type, u, v = edge
        if type == 3 and unite(u, v + n):
            both -= 1
        if both == 0:
            break

    for type in range(1, 3):
        for edge in edges:
            a, u, v = edge
            if a == type and unite(u, v + n):
                ct[type - 1] += 1
        if both + ct[type - 1] < n - 1:
            return -1

    return ct[0] + ct[1] - n + 1


-----
def maxNumEdgesToRemove(n, edges):
    # Your code here


************************************
Question ID: 1702
def maximum_binary_string(binary: str) -> str:
    zero_count = binary.count('0')
    
    if zero_count <= 1:
        return binary
    
    one_count = len(binary) - zero_count

    result = "1" * one_count + "0" * (zero_count - 1) + "1####1"
    return result[:len(binary)]

-----
def maximum_binary_string(binary: str) -> str:
    # Your code here


************************************
Question ID: 1703
def minMoves(nums, k):
    ones_pos = [i for i, x in enumerate(nums) if x == 1]
    to_move = [i_b - i_a for i_a, i_b in zip(range(k), ones_pos)]
    min_moves = sum(to_move[k // 2:])
    move = min_moves
    for left, right in zip(
        to_move[:-k],       # left "window" of k-sized sliding window
        to_move[k // 2 + 1:],  # right "window" of k-sized sliding window
    ):
        move += left - right
        min_moves = min(min_moves, move)
    return min_moves

-----
def minMoves(nums, k):
    # Your code here


************************************
Question ID: 1704
def numSpecial(mat):
    m, n = len(mat), len(mat[0])
    row, col = [0] * m, [0] * n

    for i in range(m):
        for j in range(n):
            if mat[i][j] == 1:
                row[i] += 1
                col[j] += 1

    special_positions = 0
    for i in range(m):
        for j in range(n):
            if mat[i][j] == 1 and row[i] == 1 and col[j] == 1:
                special_positions += 1

    return special_positions

-----
def numSpecial(mat):
    # Your code here


************************************
Question ID: 1705
def unhappyFriends(n, preferences, pairs):
    pair_mapping = [0] * n
    for pair in pairs:
        pair_mapping[pair[0]] = pair[1]
        pair_mapping[pair[1]] = pair[0]

    unhappy_count = 0
    for x in range(n):
        y = pair_mapping[x]
        pref_x = preferences[x]
        idx_y = pref_x.index(y)

        for i in range(idx_y):
            u = pref_x[i]
            v = pair_mapping[u]
            pref_u = preferences[u]
            if x in pref_u[:pref_u.index(v)]:
                unhappy_count += 1
                break

    return unhappy_count // 2


-----
def unhappyFriends(n, preferences, pairs):
    # Your code here


************************************
Question ID: 1706
def minCostConnectPoints(points):
    n = len(points)
    cost = [float('inf')] * n
    visited = [False] * n
    cost[0] = 0

    ans = 0

    for _ in range(n):
        min_cost = float('inf')
        cur_point = -1
        for j in range(n):
            if not visited[j] and cost[j] < min_cost:
                min_cost = cost[j]
                cur_point = j

        visited[cur_point] = True
        ans += min_cost

        for j in range(n):
            if not visited[j]:
                new_cost = abs(points[cur_point][0] - points[j][0]) + abs(points[cur_point][1] - points[j][1])
                cost[j] = min(cost[j], new_cost)

    return ans


-----
def minCostConnectPoints(points):
    # Your code here


************************************
Question ID: 1707
def can_transform(s, t):
    i, j = 0, 0
    while i < len(s) and j < len(t):
        if s[i] == t[j]:
            i += 1
            j += 1
        else:
            i += 1
    return j == len(t)


-----
def can_transform(s, t):
    # Your code here


************************************
Question ID: 1710
import heapq

def busiest_servers(k, arrival, load):
    server_requests = [0] * k
    pq = []
    available_servers = list(range(k))

    for i in range(len(arrival)):
        while pq and pq[0][0] <= arrival[i]:
            _, server_id = heapq.heappop(pq)
            available_servers.append(server_id)

        if available_servers:
            server_id = available_servers.pop(0)
            server_requests[server_id] += 1
            heapq.heappush(pq, (arrival[i] + load[i], server_id))

    max_requests = max(server_requests)
    return [i for i in range(k) if server_requests[i] == max_requests]


-----
import heapq
    # Your code here


************************************
Question ID: 1711
def restoreMatrix(rowSum, colSum):
    m, n = len(rowSum), len(colSum)
    result = [[0] * n for _ in range(m)]

    for i in range(m):
        for j in range(n):
            value = min(rowSum[i], colSum[j])
            result[i][j] = value
            rowSum[i] -= value
            colSum[j] -= value

    return result

-----
def restoreMatrix(rowSum, colSum):
    # Your code here


************************************
Question ID: 1712
def waysToSplit(nums):
    MOD = 10**9 + 7
    n = len(nums)
    prefixSum = [0] * (n + 1)
    for i in range(n):
        prefixSum[i + 1] = prefixSum[i] + nums[i]
    
    ans = 0
    left, right = 0, 0
    for mid in range(1, n - 1):
        while left + 1 < mid and prefixSum[left + 1] * 2 <= prefixSum[mid]:
            left += 1
        while right < mid or (right + 1 < n and prefixSum[right + 1] - prefixSum[mid] <= prefixSum[n] - prefixSum[right + 1]):
            right += 1
        if right >= mid and prefixSum[mid] - prefixSum[left] <= prefixSum[right] - prefixSum[mid]:
            ans = (ans + right - mid + 1) % MOD

    return ans

-----
def waysToSplit(nums):
    # Your code here


************************************
Question ID: 1713
from bisect import bisect_left

def minOperations(target, arr):
    pos = {x: i for i, x in enumerate(target)}

    dp = []
    for a in arr:
        if a in pos:
            idx = bisect_left(dp, pos[a])
            if idx == len(dp):
                dp.append(pos[a])
            else:
                dp[idx] = pos[a]
    return len(target) - len(dp)

-----
from bisect import bisect_left
    # Your code here


************************************
Question ID: 1714
def reorder_spaces(text: str) -> str:
    spaces = text.count(' ')
    words = text.split()
    
    if len(words) == 1:
        return words[0] + ' ' * spaces

    space_between_words = spaces // (len(words) - 1)
    extra_spaces = spaces % (len(words) - 1)
    result = ''
    
    for i, word in enumerate(words):
        result += word
        if i < len(words) - 1:
            result += ' ' * space_between_words
    
    result += ' ' * extra_spaces

    return result

-----
def reorder_spaces(text: str) -> str:
    # Your code here


************************************
Question ID: 1716
def maxProductPath(grid):
    m, n, mod = len(grid), len(grid[0]), int(1e9 + 7)
    dp = [[[0, 0] for _ in range(n)] for _ in range(m)]
    
    dp[0][0] = [grid[0][0], grid[0][0]]
    
    for i in range(1, m):
        dp[i][0] = [dp[i - 1][0][0] * grid[i][0], dp[i - 1][0][0] * grid[i][0]]
    for j in range(1, n):
        dp[0][j] = [dp[0][j - 1][0] * grid[0][j], dp[0][j - 1][0] * grid[0][j]]
    
    for i in range(1, m):
        for j in range(1, n):
            if grid[i][j] < 0:
                dp[i][j][0] = min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j]
                dp[i][j][1] = max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j]
            else:
                dp[i][j][0] = max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j]
                dp[i][j][1] = min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j]
            
    return dp[m - 1][n - 1][0] % mod if dp[m - 1][n - 1][0] >= 0 else -1


-----
def maxProductPath(grid):
    # Your code here


************************************
Question ID: 1717
def min_cost(cost, size1, size2):
    dp = [float('inf')] * (size2 + 1)
    dp[0] = 0

    for i in range(size1):
        for j in range(size2, -1, -1):
            min_cost = float('inf')
            for k in range(size2):
                if (1 << k) & j == 0:
                    min_cost = min(min_cost, cost[i][k] + dp[j | (1 << k)])
            dp[j] = min(dp[j], min_cost)

    return dp[(1 << size2) - 1]

-----
def min_cost(cost, size1, size2):
    # Your code here


************************************
Question ID: 1719
def check_ways(pairs):
    candidates = {}
    for x, y in pairs:
        candidates[x] = candidates.get(x, 0) + 1
        candidates[y] = candidates.get(y, 0) + 1

    root_count = sum(1 for v in candidates.values() if v == 1)
    return min(root_count, 2)

-----
def check_ways(pairs):
    # Your code here


************************************
Question ID: 1720
def minOperations(logs):
    depth = 0
    for log in logs:
        if log == "../":
            if depth > 0:
                depth -= 1
        elif log != "./":
            depth += 1
    return depth


-----
def minOperations(logs):
    # Your code here


************************************
Question ID: 1721
def min_operations_max_profit(customers, boarding_cost, running_cost):
    rotations = waiting = on_board = profit = max_profit = max_rotations = 0
    while customers or waiting > 0:
        if customers:
            waiting += customers.pop(0)
            
        on_board = min(waiting, 4)
        waiting -= on_board
        profit += on_board * boarding_cost - running_cost
        rotations += 1
        
        if profit > max_profit:
            max_profit = profit
            max_rotations = rotations
            
    return max_rotations if max_profit > 0 else -1


-----
def min_operations_max_profit(customers, boarding_cost, running_cost):
    # Your code here


************************************
Question ID: 1723
def max_achievable_requests(n, requests, idx=0, counts=None):
    if counts is None:
        counts = [0] * n
    if idx == len(requests):
        if all(count == 0 for count in counts):
            return 0
        return 0

    ignored = max_achievable_requests(n, requests, idx+1, counts[:])
    counts[requests[idx][0]] += 1
    counts[requests[idx][1]] -= 1

    accepted = 1 + max_achievable_requests(n, requests, idx+1, counts)

    return max(ignored, accepted)

-----
def max_achievable_requests(n, requests, idx=0, counts=None):
    # Your code here


************************************
Question ID: 1725
def numberOfSets(n, k):
    mod = 10**9 + 7
    dp = [[0] * (k + 1) for _ in range(n)]
    presum = [1] * n
    
    for j in range(1, k + 1):
        for i in range(n):
            dp[i][j] = presum[i]
            if i > 0:
                dp[i][j] += dp[i - 1][j]
            dp[i][j] %= mod
            presum[i] = (presum[i] + dp[i][j - 1]) % mod
    
    return dp[n - 1][k]

-----
def numberOfSets(n, k):
    # Your code here


************************************
Question ID: 1726
from math import sqrt

def best_coordinate(towers, radius):
    max_quality = 0
    best_x, best_y = 0, 0

    for x in range(51):
        for y in range(51):
            sum_quality = 0
            for tower in towers:
                dist = sqrt((x - tower[0])**2 + (y - tower[1])**2)
                if dist <= radius:
                    sum_quality += tower[2] // (1 + dist)
            if sum_quality > max_quality:
                max_quality = sum_quality
                best_x, best_y = x, y

    return [best_x, best_y]

-----
from math import sqrt
    # Your code here


************************************
Question ID: 1727
def canMouseWin(grid: List[List[str]], catJump: int, mouseJump: int) -> bool:
    rows, cols = len(grid), len(grid[0])
    cat_r = cat_c = mouse_r = mouse_c = 0

    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 'C':
                cat_r, cat_c = r, c
            elif grid[r][c] == 'M':
                mouse_r, mouse_c = r, c

    dirs = [-1, 0, 1, 0, -1]

    def dfs(r_m, c_m, r_c, c_c, cnt, dst_m_c):
        if cnt >= 100:
            return False
        if r_m < 0 or r_m >= rows or c_m < 0 or c_m >= cols:
            return False
        if r_c < 0 or r_c >= rows or c_c < 0 or c_c >= cols:
            return True
        if grid[r_m][c_m] == 'F' or cnt != dst_m_c:
            return True
        elif grid[r_m][c_m] == '#' or cnt + 1 == dst_m_c:
            return False

        res = False
        for i in range(4):
            jump = catJump if dst_m_c == cnt else mouseJump
            res |= not dfs(r_m + jump * dirs[i], c_m + jump * dirs[i + 1], r_c + dirs[i] * dirs[(i + 2) % 4], c_c + dirs[i+1] * dirs[(i + 3) % 4], cnt + 1, dst_m_c)
            if jump == 1:
                break

        return res

    return dfs(mouse_r, mouse_c, cat_r, cat_c, 0, abs(cat_r - mouse_r) + abs(cat_c - mouse_c))

-----
def canMouseWin(grid: List[List[str]], catJump: int, mouseJump: int) -> bool:
    # Your code here


************************************
Question ID: 1730
def find_special_integer(nums):
    for x in range(1, len(nums) + 1):
        count = sum(1 for num in nums if num >= x)
        if count == x:
            return x
    return -1

-----
def find_special_integer(nums):
    # Your code here


************************************
Question ID: 1732
def min_operations(n):
    operations = 0
    while n > 0:
        if n % 2 == 0:
            n //= 2
        else:
            n -= 1
        operations += 1
    return operations

-----
def min_operations(n):
    # Your code here


************************************
Question ID: 1733
from math import atan2, degrees

def visiblePoints(points, angle, location):
    angles = [degrees(atan2(y - location[1], x - location[0])) for x, y in points if [x, y] != location]
    angles.sort()
    angles += [a + 360 for a in angles]
    n = len(angles)
    max_points, j = 0, 0
    for i in range(2 * n):
        while angles[i] - angles[j] > angle:
            j += 1
        max_points = max(max_points, i - j + 1)
    return max_points + points.count(location)


-----
from math import atan2, degrees
    # Your code here


************************************
Question ID: 1734
def decode(encoded):
    n = len(encoded) + 1
    total_xor = 0
    
    for i in range(1, n + 1):
        total_xor ^= i

    non_first_xor = 0
    for i in range(1, n - 1, 2):
        non_first_xor ^= encoded[i]

    perm = [total_xor ^ non_first_xor]
    for i in range(1, n):
        perm.append(perm[-1] ^ encoded[i - 1])
    
    return perm


-----
def decode(encoded):
    # Your code here


************************************
Question ID: 1735
MOD = 10**9 + 7

def mul(a, b):
    return (a * b) % MOD

def ways(n, k, mem):
    if n == 1:
        return k
    if (n_tuple := (n, k)) in mem:
        return mem[n_tuple]
    if k == 1:
        mem[n_tuple] = 1
        return 1
    if n > k:
        mem[n_tuple] = 0
        return 0
    res = mul(ways(n, k - 1, mem), n)
    res = (res - mul(n - 1, ways(n - 1, k - 1, mem)) + MOD) % MOD
    mem[n_tuple] = res
    return res

def waysToFillArray(queries):
    mem = {}
    ans = []
    for q in queries:
        ans.append(ways(q[0], q[1], mem))
    return ans

-----
MOD = 10**9 + 7
    # Your code here


************************************
Question ID: 1736
def maximumTime(time: str) -> str:
    time_list = list(time)
    if time_list[0] == '?':
        time_list[0] = '2' if time_list[1] <= '3' or time_list[1] == '?' else '1'
    if time_list[1] == '?':
        time_list[1] = '3' if time_list[0] == '2' else '9'
    if time_list[3] == '?':
        time_list[3] = '5'
    if time_list[4] == '?':
        time_list[4] = '9'
    return "".join(time_list)

-----
def maximumTime(time: str) -> str:
    # Your code here


************************************
Question ID: 1737
def maxDepth(s: str) -> int:
    depth, max_depth = 0, 0
    for ch in s:
        if ch == '(':
            depth += 1
        elif ch == ')':
            depth -= 1
        max_depth = max(max_depth, depth)
    return max_depth

-----
def maxDepth(s: str) -> int:
    # Your code here


************************************
Question ID: 1738
def maximalNetworkRank(n, roads):
    degree = [0] * n
    s = set()
    
    for road in roads:
        degree[road[0]] += 1
        degree[road[1]] += 1
        s.add(tuple(sorted(road)))
    
    ans = 0
    for i in range(n):
        for j in range(i + 1, n):
            ans = max(ans, degree[i] + degree[j] - (1 if (i, j) in s else 0))
    return ans


-----
def maximalNetworkRank(n, roads):
    # Your code here


************************************
Question ID: 1739
def check_palindrome_formation(a: str, b: str) -> bool:
    def is_palindrome(s: str, left: int, right: int) -> bool:
        while left < right:
            if s[left] != s[right]:
                return False
            left += 1
            right -= 1
        return True

    i, j = 0, len(a) - 1
    while i < j:
        if a[i] != b[j]:
            return is_palindrome(a, i, j) or is_palindrome(b, i, j)
        i += 1
        j -= 1
    return True

-----
def check_palindrome_formation(a: str, b: str) -> bool:
    # Your code here


************************************
Question ID: 1740
from collections import defaultdict

def countSubgraphsForEachD(n, edges):
    tree = defaultdict(list)
    for u, v in edges:
        tree[u].append(v)
        tree[v].append(u)

    def dfs(node, parent):
        depth = 0
        for child in tree[node]:
            if child != parent:
                depth = max(depth, 1 + dfs(child, node))
        return depth

    ans = [0] * (n - 1)
    for i in range(1, n + 1):
        maxD = dfs(i, 0)
        if maxD > 0:
            ans[maxD - 1] += 1

    return ans

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1742
def maxWidthOfVerticalArea(points):
    xs = sorted([point[0] for point in points])
    max_width = 0
    for i in range(1, len(xs)):
        max_width = max(max_width, xs[i] - xs[i - 1])
    return max_width


-----
def maxWidthOfVerticalArea(points):
    # Your code here


************************************
Question ID: 1743
def count_substrings_with_one_difference(s, t):
    count = 0
    for i in range(len(s)):
        for j in range(len(t)):
            differences = 0
            k = 0
            while i + k < len(s) and j + k < len(t):
                if s[i + k] != t[j + k]:
                    differences += 1
                if differences == 2:
                    break
                if differences == 1:
                    count += 1
                k += 1
    return count

-----
def count_substrings_with_one_difference(s, t):
    # Your code here


************************************
Question ID: 1744
def num_ways(words, target):
    n, m = len(words), len(target)
    MOD = 10**9 + 7
    cnt = [0] * 26
    for word in words:
        for ch in word:
            cnt[ord(ch) - ord('a')] += 1
    dp = [0] * (m + 1)
    dp[0] = 1
    for ch in target:
        for i in range(m - 1, -1, -1):
            dp[i + 1] += dp[i] * cnt[ord(ch) - ord('a')]
            dp[i + 1] %= MOD
    return dp[m]

-----
def num_ways(words, target):
    # Your code here


************************************
Question ID: 1745
def is_palindrome(s, start, end):
    while start < end:
        if s[start] != s[end]:
            return False
        start += 1
        end -= 1
    return True

def check_partitioning(s):
    n = len(s)
    for i in range(0, n - 2):
        if is_palindrome(s, 0, i):
            for j in range(i + 1, n - 1):
                if is_palindrome(s, i + 1, j) and is_palindrome(s, j + 1, n - 1):
                    return True
    return False

-----
def is_palindrome(s, start, end):
    # Your code here


************************************
Question ID: 1746
def maxLengthBetweenEqualCharacters(s: str) -> int:
    max_length = -1
    char_index_map = {}

    for i, char in enumerate(s):
        if char in char_index_map:
            max_length = max(max_length, i - char_index_map[char] - 1)
        else:
            char_index_map[char] = i

    return max_length

-----
def maxLengthBetweenEqualCharacters(s: str) -> int:
    # Your code here


************************************
Question ID: 1748
def bestTeamScore(scores, ages):
    players = sorted(zip(ages, scores))
    n = len(players)
    dp = [0] * n
    best_score = 0
    
    for i in range(n):
        dp[i] = players[i][1]
        for j in range(i):
            if players[i][1] >= players[j][1]:
                dp[i] = max(dp[i], dp[j] + players[i][1])
        best_score = max(best_score, dp[i])
    
    return best_score


-----
def bestTeamScore(scores, ages):
    # Your code here


************************************
Question ID: 1749
def maxAbsoluteSum(nums):
    max_sum = max_end = min_sum = min_end = 0
    for num in nums:
        max_end = max(max_end + num, num)
        min_end = min(min_end + num, num)
        max_sum = max(max_sum, max_end)
        min_sum = min(min_sum, min_end)
    return max(max_sum, -min_sum)

-----
def maxAbsoluteSum(nums):
    # Your code here


************************************
Question ID: 1750
def minimumLength(s: str) -> int:
    if not s: return 0
    i, j = 0, len(s) - 1
    while i < j:
        if s[i] != s[j]: break
        remove_char = s[i]
        while i < len(s) and s[i] == remove_char: i += 1
        while j >= 0 and s[j] == remove_char: j -= 1
    return max(0, j - i + 1)

-----
def minimumLength(s: str) -> int:
    # Your code here


************************************
Question ID: 1751
def slowestKey(releaseTimes, keysPressed):
    max_key = keysPressed[0]
    max_duration = releaseTimes[0]
    for i in range(1, len(releaseTimes)):
        duration = releaseTimes[i] - releaseTimes[i - 1]
        if duration > max_duration or (duration == max_duration and keysPressed[i] > max_key):
            max_key = keysPressed[i]
            max_duration = duration
    return max_key


-----
def slowestKey(releaseTimes, keysPressed):
    # Your code here


************************************
Question ID: 1752
def check_arithmetic_subarrays(nums, l, r):
    results = []
    for i in range(len(l)):
        subarray = sorted(nums[l[i]:r[i] + 1])
        is_arithmetic = True
        diff = subarray[1] - subarray[0]
        for j in range(1, len(subarray) - 1):
            if subarray[j + 1] - subarray[j] != diff:
                is_arithmetic = False
                break
        results.append(is_arithmetic)
    return results


-----
def check_arithmetic_subarrays(nums, l, r):
    # Your code here


************************************
Question ID: 1753
import heapq
from typing import List

def minimumEffortPath(heights: List[List[int]]) -> int:
    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]
    rows = len(heights)
    cols = len(heights[0])
    efforts = [[float('inf')] * cols for _ in range(rows)]

    q = [(0, 0, 0)]
    efforts[0][0] = 0
    
    while q:
        effort, x, y = heapq.heappop(q)
        
        if x == rows - 1 and y == cols - 1:
            return effort
        
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < rows and 0 <= ny < cols:
                new_effort = max(effort, abs(heights[nx][ny] - heights[x][y]))
                if new_effort < efforts[nx][ny]:
                    efforts[nx][ny] = new_effort
                    heapq.heappush(q, (new_effort, nx, ny))
    
    return -1


-----
import heapq
    # Your code here


************************************
Question ID: 1754
def largest_merge(word1: str, word2: str) -> str:
    merge = []
    while word1 or word2:
        if word1 > word2:
            merge.append(word1[0])
            word1 = word1[1:]
        else:
            merge.append(word2[0])
            word2 = word2[1:]
    return ''.join(merge)

-----
def largest_merge(word1: str, word2: str) -> str:
    # Your code here


************************************
Question ID: 1755
def decrypt(code, k):
    n = len(code)
    result = [0] * n
    if k == 0: return result
    
    for i in range(n):
        sum = 0
        for j in range(1, abs(k) + 1):
            sum += code[(i + j) % n] if k > 0 else code[(i - j + n) % n]
        result[i] = sum
    return result

-----
def decrypt(code, k):
    # Your code here


************************************
Question ID: 1756
def min_deletions(s: str) -> int:
    a_count, deletions = 0, 0
    for c in s:
        if c == 'a':
            a_count += 1
        else:
            if a_count > 0:
                a_count -= 1
            else:
                deletions += 1
    return deletions

-----
def min_deletions(s: str) -> int:
    # Your code here


************************************
Question ID: 1758
from typing import List

def canDistribute(nums: List[int], quantity: List[int]) -> bool:
    counts = [0] * 51
    for num in nums:
        counts[num] += 1

    quantity.sort(reverse=True)

    def dfs(idx: int) -> bool:
        if idx == len(quantity):
            return True
        for i in range(1, 51):
            if counts[i] >= quantity[idx]:
                counts[i] -= quantity[idx]
                if dfs(idx + 1):
                    return True
                counts[i] += quantity[idx]
        return False

    return dfs(0)


-----
from typing import List
    # Your code here


************************************
Question ID: 1759
def count_homogenous(s: str) -> int:
    MOD = 1000000007
    count, total = 1, 0
    for i in range(1, len(s)):
        count = count + 1 if s[i] == s[i - 1] else 1
        total = (total + count) % MOD
    return (total + count) % MOD

-----
def count_homogenous(s: str) -> int:
    # Your code here


************************************
Question ID: 1760
def can_form_array(arr, pieces):
    piece_map = {piece[0]: piece for piece in pieces}
    
    i = 0
    while i < len(arr):
        if arr[i] not in piece_map:
            return False
        
        for num in piece_map[arr[i]]:
            if arr[i] != num:
                return False
            i += 1
            
    return True

-----
def can_form_array(arr, pieces):
    # Your code here


************************************
Question ID: 1761
def count_vowel_strings(n):
    dp = [1, 1, 1, 1, 1]

    for i in range(1, n):
        for j in range(3, -1, -1):
            dp[j] += dp[j + 1]

    return sum(dp)

-----
def count_vowel_strings(n):
    # Your code here


************************************
Question ID: 1762
import heapq

def furthest_building(heights, bricks, ladders):
    min_heap = []
    for i in range(len(heights) - 1):
        diff = heights[i + 1] - heights[i]
        if diff > 0:
            heapq.heappush(min_heap, diff)
            if len(min_heap) > ladders:
                bricks -= heapq.heappop(min_heap)
                if bricks < 0:
                    return i
    return len(heights) - 1


-----
import heapq
    # Your code here


************************************
Question ID: 1763
def longestNiceSubstring(s: str) -> str:
    n = len(s)
    result = ""
    for i in range(n):
        for j in range(i + 1, n):
            is_nice = True
            for ch in range(ord('A'), ord('Z') + 1):
                upper = chr(ch) in s[i:j+1]
                lower = chr(ch + 32) in s[i:j+1]
                if (upper and not lower) or (not upper and lower):
                    is_nice = False
                    break
            if is_nice and j - i + 1 > len(result):
                result = s[i:j+1]
    return result

-----
def longestNiceSubstring(s: str) -> str:
    # Your code here


************************************
Question ID: 1764
def max_k_repeating(sequence, word):
    max_k = 0
    seq_length = len(sequence)
    word_length = len(word)
    for i in range(seq_length - word_length + 1):
        k = 0
        while sequence[i:i + word_length * (k + 1)] == word * (k + 1):
            k += 1
        max_k = max(max_k, k)
    return max_k

-----
def max_k_repeating(sequence, word):
    # Your code here


************************************
Question ID: 1766
from bisect import bisect_left

def minimum_mountain_removals(nums):
    n = len(nums)
    left, right = [0] * n, [0] * n
    for i in range(n):
        left[i] = bisect_left(left[:i], nums[i])
        right[n - 1 - i] = bisect_left(right[n - i:], nums[n - 1 - i])

    return n - max(left[i] + right[i] for i in range(1, n - 1)) - 1

-----
from bisect import bisect_left
    # Your code here


************************************
Question ID: 1768
def mergeAlternately(word1: str, word2: str) -> str:
    result = []
    i, j = 0, 0
    while i < len(word1) and j < len(word2):
        result.append(word1[i])
        result.append(word2[j])
        i += 1
        j += 1
    result += word1[i:]
    result += word2[j:]
    return "".join(result)

-----
def mergeAlternately(word1: str, word2: str) -> str:
    # Your code here


************************************
Question ID: 1769
def maximum_generated(n: int) -> int:
    if n == 0:
        return 0
    nums = [0] * (n + 1)
    nums[1] = 1
    for i in range(2, n + 1):
        nums[i] = nums[i // 2] if i % 2 == 0 else nums[i // 2] + nums[i // 2 + 1]
    return max(nums)

-----
def maximum_generated(n: int) -> int:
    # Your code here


************************************
Question ID: 1770
def min_deletions(s):
    freq = collections.Counter(s)
    used = set()
    deletions = 0

    for count in freq.values():
        while count in used and count > 0:
            deletions += 1
            count -= 1
        used.add(count)

    return deletions

-----
def min_deletions(s):
    # Your code here


************************************
Question ID: 1771
def maxProfit(inventory, orders):
    mod = 10**9 + 7
    inventory.sort(reverse=True)
    inventory.append(0)
    n, ans, count = len(inventory), 0, 1
    for i in range(n - 1):
        diff = inventory[i] - inventory[i + 1]
        if count * diff < orders:
            orders -= count * diff
            ans = (ans + (((inventory[i] + inventory[i + 1] + 1) * diff) // 2) % mod * count) % mod
        else:
            q, r = divmod(orders, count)
            ans = (ans + (((inventory[i] + inventory[i] - q + 1) * q) // 2) % mod * count) % mod
            ans = (ans + r * (inventory[i] - q)) % mod
            break
        count += 1
    return ans

-----
def maxProfit(inventory, orders):
    # Your code here


************************************
Question ID: 1772
from sortedcontainers import SortedList

MOD = int(1e9) + 7

def create_sorted_array(instructions):
    s = SortedList()
    cost = 0

    for i in instructions:
        less_than = s.bisect_left(i)
        greater_than = len(s) - s.bisect_right(i)
        cost = (cost + min(less_than, greater_than)) % MOD
        s.add(i)

    return cost

-----
from sortedcontainers import SortedList
    # Your code here


************************************
Question ID: 1773
def countMatches(items, ruleKey, ruleValue):
    count = 0
    index = {"type": 0, "color": 1, "name": 2}[ruleKey]
    for item in items:
        if item[index] == ruleValue:
            count += 1
    return count

-----
def countMatches(items, ruleKey, ruleValue):
    # Your code here


************************************
Question ID: 1774
from itertools import product

def closest_cost(base_costs, topping_costs, target):
    closest = float('inf')
    topping_combinations = list(product([0, 1, 2], repeat=len(topping_costs)))
    
    for base in base_costs:
        for combination in topping_combinations:
            combination_cost = sum(x * y for x, y in zip(topping_costs, combination))
            diff = abs(target - (base + combination_cost))
            if diff < closest:
                closest = diff
            if diff == 0:
                return target

    return target - closest

-----
from itertools import product
    # Your code here


************************************
Question ID: 1776
def minOperations(nums, x):
    total = sum(nums)
    target = total - x
    if target < 0:
        return -1

    maxLength = -1
    left = 0
    current_sum = 0

    for right in range(len(nums)):
        current_sum += nums[right]

        while current_sum > target:
            current_sum -= nums[left]
            left += 1

        if current_sum == target:
            maxLength = max(maxLength, right - left + 1)

    return -1 if maxLength == -1 else len(nums) - maxLength


-----
def minOperations(nums, x):
    # Your code here


************************************
Question ID: 1778
from functools import lru_cache

def getMaxGridHappiness(m, n, introvertsCount, extrovertsCount):
    @lru_cache(None)
    def maxHappy(y, mask):
        if y == n:
            return 0

        ans = 0
        for x in range(m + 1):
            happiness = 0
            if mask >> x & 1:
                happiness -= 30
                if x > 0 and mask & 1:
                    happiness -= 30
                else:
                    happiness += 20
            ans = max(ans, happiness + maxHappy(y + 1, (mask | (1 << x)) >> 1))

        return ans

    return maxHappy(0, 0)


-----
from functools import lru_cache
    # Your code here


************************************
Question ID: 1779
def nearestValidPoint(x: int, y: int, points: List[List[int]]) -> int:
    min_distance = float("inf")
    index = -1
    for i, point in enumerate(points):
        if x == point[0] or y == point[1]:
            distance = abs(x - point[0]) + abs(y - point[1])
            if distance < min_distance:
                min_distance = distance
                index = i
    return index

-----
def nearestValidPoint(x: int, y: int, points: List[List[int]]) -> int:
    # Your code here


************************************
Question ID: 1780
def check_powers_of_three(n: int) -> bool:
    while n > 0:
        if n % 3 == 2:
            return False
        n //= 3
    return True

-----
def check_powers_of_three(n: int) -> bool:
    # Your code here


************************************
Question ID: 1781
def arrayStringsAreEqual(word1, word2):
    return "".join(word1) == "".join(word2)

-----
def arrayStringsAreEqual(word1, word2):
    # Your code here


************************************
Question ID: 1782
def get_smallest_string(n: int, k: int) -> str:
    result = ['a'] * n
    k -= n
    idx = n - 1
    while k > 0:
        value = min(k, 25)
        result[idx] = chr(ord(result[idx]) + value)
        k -= value
        idx -= 1
    return ''.join(result)

-----
def get_smallest_string(n: int, k: int) -> str:
    # Your code here


************************************
Question ID: 1784
def minimum_energy(tasks):
    tasks.sort(key=lambda task: task[1] - task[0], reverse=True)

    energy = 0
    for task in tasks:
        energy = max(energy + task[0], task[1])
    return energy

-----
def minimum_energy(tasks):
    # Your code here


************************************
Question ID: 1785
def minElements(nums, limit, goal):
    sum_nums = sum(nums)
    diff = abs(goal - sum_nums)
    
    return (diff + limit - 1) // limit


-----
def minElements(nums, limit, goal):
    # Your code here


************************************
Question ID: 1786
def count_consistent_strings(allowed, words):
    allowed_set = set(allowed)
    count = 0
    for word in words:
        is_valid = True
        for c in word:
            if c not in allowed_set:
                is_valid = False
                break
        if is_valid:
            count += 1
    return count

-----
def count_consistent_strings(allowed, words):
    # Your code here


************************************
Question ID: 1787
def calculate_summation_of_absolute_differences(nums):
    n = len(nums)
    result = [0] * n

    for i in range(n):
        for j in range(n):
            if i != j:
                result[i] += abs(nums[i] - nums[j])

    return result

-----
def calculate_summation_of_absolute_differences(nums):
    # Your code here


************************************
Question ID: 1788
def stoneGameVI(aliceValues, bobValues):
    n = len(aliceValues)
    sums = sorted([(aliceValues[i] + bobValues[i], i) for i in range(n)], reverse=True)
    
    aliceScore = sum(aliceValues[i] for _, i in sums[::2])
    bobScore = sum(bobValues[i] for _, i in sums[1::2])
    
    return 0 if aliceScore == bobScore else 1 if aliceScore > bobScore else -1

-----
def stoneGameVI(aliceValues, bobValues):
    # Your code here


************************************
Question ID: 1790
def are_almost_equal(s1, s2):
    if s1 == s2:
        return True
    diff = [i for i in range(len(s1)) if s1[i] != s2[i]]
    return len(diff) == 2 and s1[diff[0]] == s2[diff[1]] and s1[diff[1]] == s2[diff[0]]

-----
def are_almost_equal(s1, s2):
    # Your code here


************************************
Question ID: 1791
def maximum_wealth(accounts):
    return max(sum(customer) for customer in accounts)


-----
def maximum_wealth(accounts):
    # Your code here


************************************
Question ID: 1792
def most_competitive(nums, k):
    stack = []
    n = len(nums)

    for i in range(n):
        while stack and nums[i] < stack[-1] and len(stack) + n - i > k:
            stack.pop()
        if len(stack) < k:
            stack.append(nums[i])

    return stack

-----
def most_competitive(nums, k):
    # Your code here


************************************
Question ID: 1793
def min_moves(nums, limit):
    n = len(nums)
    delta = [0] * (2 * limit + 2)

    for i in range(n // 2):
        lo = min(nums[i], nums[n - 1 - i]) + 1
        hi = max(nums[i], nums[n - 1 - i]) + limit
        delta[lo] -= 1
        delta[nums[i] + nums[n - 1 - i]] -= 1
        delta[hi + 1] += 1

    moves, current = n, n
    for i in range(2, 2 * limit + 1):
        current += delta[i]
        moves = min(moves, current)

    return moves


-----
def min_moves(nums, limit):
    # Your code here


************************************
Question ID: 1794
import heapq

def minimum_deviation(nums):
    pq = []
    min_val = float("inf")

    for num in nums:
        if num % 2 == 0:
            heapq.heappush(pq, -num)
        else:
            heapq.heappush(pq, -(num * 2))
        min_val = min(min_val, num)

    result = float("inf")
    while True:
        top = -heapq.heappop(pq)
        result = min(result, top - min_val)

        if top % 2 == 1:
            break
        heapq.heappush(pq, -(top // 2))
        min_val = min(min_val, top // 2)

    return result


-----
import heapq
    # Your code here


************************************
Question ID: 1796
def second_highest(s: str) -> int:
    largest = -1
    second_largest = -1
    for c in s:
        if c.isdigit():
            d = int(c)
            if d > largest:
                second_largest = largest
                largest = d
            elif d < largest and d > second_largest:
                second_largest = d
    return second_largest

-----
def second_highest(s: str) -> int:
    # Your code here


************************************
Question ID: 1797
def interpret(command: str) -> str:
    result = []
    i = 0
    while i < len(command):
        if command[i] == "G":
            result.append("G")
            i += 1
        elif command[i:i+2] == "()":
            result.append("o")
            i += 2
        else:
            result.append("al")
            i += 4
    return "".join(result)

-----
def interpret(command: str) -> str:
    # Your code here


************************************
Question ID: 1798
def maxOperations(nums, k):
    count = {}
    operations = 0

    for num in nums:
        if count.get(k - num, 0) > 0:
            count[k - num] -= 1
            operations += 1
        else:
            count[num] = count.get(num, 0) + 1

    return operations


-----
def maxOperations(nums, k):
    # Your code here


************************************
Question ID: 1799
from typing import List

def minimumIncompatibility(nums: List[int], k: int) -> int:
    n = len(nums)
    if n % k != 0:
        return -1
    
    nums.sort()
    diffs = [nums[(i + 1) * (n // k) - 1] - nums[i * (n // k)] for i in range(k)]
    
    return sum(diffs)

-----
from typing import List
    # Your code here


************************************
Question ID: 1800
def concatenated_binary(n: int) -> int:
    result = 0
    mod = 1000000007
    for i in range(1, n + 1):
        length = len(bin(i)) - 2
        result = ((result << length) % mod + i) % mod
    return result


-----
def concatenated_binary(n: int) -> int:
    # Your code here


************************************
Question ID: 1801
from heapq import *

def getNumberOfBacklogOrders(orders):
    buy_orders, sell_orders = [], []
    num_orders, mod = 0, int(1e9) + 7

    for price, amount, order_type in orders:
        if order_type == 0: # buy order
            while amount and sell_orders and sell_orders[0][0] <= price:
                x = min(amount, sell_orders[0][1])
                amount, sell_orders[0][1] = amount - x, sell_orders[0][1] - x
                if sell_orders[0][1] == 0:
                    heappop(sell_orders)
            if amount:
                heappush(buy_orders, (-price, amount))
        else: # sell order
            while amount and buy_orders and -buy_orders[0][0] >= price:
                x = min(amount, buy_orders[0][1])
                amount, buy_orders[0][1] = amount - x, buy_orders[0][1] - x
                if buy_orders[0][1] == 0:
                    heappop(buy_orders)
            if amount:
                heappush(sell_orders, (price, amount))
    
    while buy_orders:
        num_orders = (num_orders + heappop(buy_orders)[1]) % mod

    while sell_orders:
        num_orders = (num_orders + heappop(sell_orders)[1]) % mod

    return num_orders

-----
from heapq import *
    # Your code here


************************************
Question ID: 1802
from collections import deque

def countStudents(students, sandwiches):
    queue = deque(students)
    index, attempts = 0, 0

    while queue:
        student = queue[0]
        if student == sandwiches[index]:
            queue.popleft()
            index += 1
            attempts = 0
        else:
            queue.rotate(-1)
            attempts += 1

        if attempts == len(queue):
            break

    return len(queue)

-----
from collections import deque
    # Your code here


************************************
Question ID: 1803
def average_waiting_time(customers):
    wait_time = 0
    curr_time = 0
    
    for arrival, time in customers:
        curr_time = max(curr_time, arrival) + time
        wait_time += curr_time - arrival
    
    return wait_time / len(customers)


-----
def average_waiting_time(customers):
    # Your code here


************************************
Question ID: 1805
def min_moves(nums, k):
    n = len(nums)
    ones = [i - j for i, j in enumerate(nums) if j == 1]
    
    moves = sum(ones[i] - ones[k // 2] for i in range(k))
    min_moves = moves
    
    for i in range(k, len(ones)):
        moves += ones[i] - ones[i - k] - k
        min_moves = min(min_moves, moves)
    
    return min_moves


-----
def min_moves(nums, k):
    # Your code here


************************************
Question ID: 1806
def numberOfMatches(n):
    return n - 1


-----
def numberOfMatches(n):
    # Your code here


************************************
Question ID: 1807
def minPartitions(n: str) -> int:
    max_digit = 0
    for c in n:
        max_digit = max(max_digit, int(c))
        if max_digit == 9:
            break
    return max_digit

-----
def minPartitions(n: str) -> int:
    # Your code here


************************************
Question ID: 1808
def stoneGame(stones):
    n = len(stones)
    dp = [[0] * n for _ in range(n)]
    
    for i in range(n - 1, -1, -1):
        for j in range(i + 1, n):
            dp[i][j] = max(stones[j] - dp[i][j - 1], stones[i] - dp[i + 1][j])
    
    return dp[0][n - 1]

-----
def stoneGame(stones):
    # Your code here


************************************
Question ID: 1812
def reformat_number(number):
    cleaned_number = ''.join(c for c in number if c.isdigit())

    blocks = []
    n = len(cleaned_number)
    i = 0
    while i < n:
        if n - i == 2 or n - i == 4:
            blocks.append(cleaned_number[i:i + 2])
            i += 2
        else:
            blocks.append(cleaned_number[i:i + 3])
            i += 3

    return '-'.join(blocks)

-----
def reformat_number(number):
    # Your code here


************************************
Question ID: 1813
def maximum_unique_subarray(nums):
    max_sum, current_sum, left = 0, 0, 0
    elements = set()
    
    for right in range(len(nums)):
        while nums[right] in elements:
            elements.remove(nums[left])
            current_sum -= nums[left]
            left += 1
        
        elements.add(nums[right])
        current_sum += nums[right]
        max_sum = max(max_sum, current_sum)
    
    return max_sum


-----
def maximum_unique_subarray(nums):
    # Your code here


************************************
Question ID: 1814
from collections import deque

def maxResult(nums, k):
    n = len(nums)
    dq = deque()
    dp = [0] * n
    
    dp[0] = nums[0]
    dq.append(0)
    
    for i in range(1, n):
        while dq and dq[0] < i - k:
            dq.popleft()
        
        dp[i] = nums[i] + dp[dq[0]]
        
        while dq and dp[i] >= dp[dq[-1]]:
            dq.pop()
        
        dq.append(i)
    
    return dp[-1]

-----
from collections import deque
    # Your code here


************************************
Question ID: 1815
from typing import List

def distanceLimitedPathsExist(n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:
    edgeList.sort(key=lambda x: x[2])
    queries = sorted(enumerate(queries), key=lambda x: x[1][2])

    def find(x: int, parent: List[int]) -> int:
        if x != parent[x]:
            parent[x] = find(parent[x], parent)
        return parent[x]

    parent = list(range(n))
    res = [False] * len(queries)
    idx = 0

    for query_id, query in queries:
        p, q, limit = query
        while idx < len(edgeList) and edgeList[idx][2] < limit:
            u, v = edgeList[idx][:2]
            ru, rv = find(u, parent), find(v, parent)
            if ru != rv:
                parent[ru] = rv
            idx += 1
        res[query_id] = find(p, parent) == find(q, parent)

    return res

-----
from typing import List
    # Your code here


************************************
Question ID: 1816
def truncateSentence(s: str, k: int) -> str:
    words = s.split()
    return " ".join(words[:k])

-----
def truncateSentence(s: str, k: int) -> str:
    # Your code here


************************************
Question ID: 1817
def total_money(n):
    weeks = n // 7
    days_remaining = n % 7
    return 28 * weeks + 7 * weeks * (weeks - 1) // 2 + (weeks + 1) * days_remaining + days_remaining * (days_remaining - 1) // 2


-----
def total_money(n):
    # Your code here


************************************
Question ID: 1818
def max_points(s, x, y):
    points = 0
    s = list(s)
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            points += max(x, y)
            s[i] = '#'
    return points

-----
def max_points(s, x, y):
    # Your code here


************************************
Question ID: 1819
def largest_lex_sequence(n: int) -> list[int]:
    res = [0] * n
    for i in range(n):
        res[i] = i % 2
    return res

-----
def largest_lex_sequence(n: int) -> list[int]:
    # Your code here


************************************
Question ID: 1820
def count_trees(pairs):
    nodes = len(pairs) + 1
    in_degrees = [0] * nodes
    for x, y in pairs:
        in_degrees[y] += 1
    
    res = 1
    for in_degree in in_degrees[1:]:
        res *= in_degree
    
    return res

-----
def count_trees(pairs):
    # Your code here


************************************
Question ID: 1822
def signFunc(x):
    if x > 0:
        return 1
    elif x < 0:
        return -1
    else:
        return 0

def arraySign(nums):
    product = 1
    for num in nums:
        product *= signFunc(num)
    return product

-----
def signFunc(x):
    # Your code here


************************************
Question ID: 1823
def halves_are_alike(s: str) -> bool:
    half_length = len(s) // 2
    count_a, count_b = 0, 0

    for i in range(half_length):
        if s[i] in "aeiouAEIOU": count_a += 1

    for i in range(half_length, len(s)):
        if s[i] in "aeiouAEIOU": count_b += 1

    return count_a == count_b

-----
def halves_are_alike(s: str) -> bool:
    # Your code here


************************************
Question ID: 1824
import heapq

def eatenApples(apples, days):
    n = len(apples)
    pq = []
    ans = 0

    for i in range(n + 1):
        if i < n and apples[i] > 0:
            heapq.heappush(pq, (i + days[i], apples[i]))

        while pq and pq[0][0] <= i:
            heapq.heappop(pq)

        if pq:
            ans += 1
            curr_apple = heapq.heappop(pq)
            if curr_apple[1] > 1:
                heapq.heappush(pq, (curr_apple[0], curr_apple[1] - 1))

    return ans


-----
import heapq
    # Your code here


************************************
Question ID: 1825
def minimum_working_time(jobs, k):
    max_job = max(jobs)
    sum_jobs = sum(jobs)
    
    left, right = max_job, sum_jobs
    while left < right:
        mid = left + (right - left) // 2
        count, current_sum = 1, 0

        for job in jobs:
            if current_sum + job > mid:
                count += 1
                current_sum = 0
            current_sum += job

        if count <= k:
            right = mid
        else:
            left = mid + 1

    return left


-----
def minimum_working_time(jobs, k):
    # Your code here


************************************
Question ID: 1826
def maximizeXor(nums, queries):
    trie = {}
    nums.sort()

    new_queries = sorted([(x, m, i) for i, (x, m) in enumerate(queries)], key=lambda x: x[1])

    ans = [0] * len(queries)

    idx = 0
    for x, m, i in new_queries:
        while idx < len(nums) and nums[idx] <= m:
            t = nums[idx]
            idx += 1
            cur = trie
            for j in range(31, -1, -1):
                bit = (t >> j) & 1
                cur = cur.setdefault(bit, {})
        cur = trie
        xor_value = 0
        for j in range(31, -1, -1):
            bit = (x >> j) & 1
            if 1 ^ bit in cur:
                cur = cur[1 ^ bit]
                xor_value |= 1 << j
            else:
                cur = cur[bit]
        ans[i] = xor_value if cur else -1

    return ans


-----
def maximizeXor(nums, queries):
    # Your code here


************************************
Question ID: 1827
def min_operations(nums):
    operations = 0
    for i in range(1, len(nums)):
        if nums[i] <= nums[i - 1]:
            operations += (nums[i - 1] - nums[i]) + 1
            nums[i] = nums[i - 1] + 1
    return operations

-----
def min_operations(nums):
    # Your code here


************************************
Question ID: 1828
def countPoints(points, queries):
    answer = []
    for query in queries:
        inside = 0
        for point in points:
            dx = point[0] - query[0]
            dy = point[1] - query[1]
            if dx * dx + dy * dy <= query[2] * query[2]:
                inside += 1
        answer.append(inside)
    return answer


-----
def countPoints(points, queries):
    # Your code here


************************************
Question ID: 1829
def maximumUnits(boxTypes, truckSize):
    boxTypes.sort(key=lambda x: x[1], reverse=True)
    
    totalUnits = 0
    for box in boxTypes:
        boxCount = min(truckSize, box[0])
        totalUnits += boxCount * box[1]
        truckSize -= boxCount
        if truckSize == 0:
            break
    
    return totalUnits

-----
def maximumUnits(boxTypes, truckSize):
    # Your code here


************************************
Question ID: 1830
from collections import defaultdict

def countPairs(deliciousness):
    MOD = 10**9 + 7
    hashMap = defaultdict(int)
    maxVal = max(deliciousness)
    maxSum = maxVal * 2

    count = 0
    for val in deliciousness:
        for sum in (1 << i for i in range(22)):
            count = (count + hashMap[sum - val]) % MOD
        hashMap[val] += 1

    return count

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1832
from bisect import bisect_left

def min_operations(target, arr):
    index_map = {num: i for i, num in enumerate(target)}

    lis = []
    for num in arr:
        if num in index_map:
            pos = bisect_left(lis, index_map[num])
            if pos == len(lis):
                lis.append(index_map[num])
            else:
                lis[pos] = index_map[num]

    return len(target) - len(lis)

-----
from bisect import bisect_left
    # Your code here


************************************
Question ID: 1833
def largestAltitude(gain):
    max_altitude, current_altitude = 0, 0
    for i in gain:
        current_altitude += i
        max_altitude = max(max_altitude, current_altitude)
    return max_altitude

-----
def largestAltitude(gain):
    # Your code here


************************************
Question ID: 1834
def minimum_teachings(n, languages, friendships):
    language_users = {}
    unconnected_users = set()

    for u, v in friendships:
        can_communicate = any(lang in languages[v-1] for lang in languages[u-1])
        if not can_communicate:
            unconnected_users.add(u)
            unconnected_users.add(v)

    res = len(unconnected_users)
    for i in range(1, n+1):
        cnt = sum(i not in languages[user-1] for user in unconnected_users)
        res = min(res, cnt)

    return res

-----
def minimum_teachings(n, languages, friendships):
    # Your code here


************************************
Question ID: 1835
def decode(encoded):
    n = len(encoded) + 1
    total_xor = 0
    for i in range(1, n + 1):
        total_xor ^= i
    encoded_xor = 0
    for i in range(1, n - 1, 2):
        encoded_xor ^= encoded[i]
    perm = [total_xor ^ encoded_xor]
    for i in range(1, n):
        perm.append(perm[-1] ^ encoded[i - 1])
    return perm

-----
def decode(encoded):
    # Your code here


************************************
Question ID: 1836
from collections import defaultdict
from typing import List

MOD = 10**9 + 7

def product_ways(queries: List[List[int]]) -> List[int]:
    res = []
    for n, k in queries:
        pf = []
        pm = defaultdict(int)

        i = 2
        while i * i <= k:
            cnt = 0
            while k % i == 0:
                cnt += 1
                k //= i
            if cnt:
                pf.append(cnt)
                pm[cnt] += 1
            i += 1

        if k > 1:
            pm[k] += 1
            pf.append(1)

        ans = 1
        for p in pf:
            ans = (ans * (p * (n - 1) + 1)) % MOD

        res.append(ans)
    return res

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1837
def sum_base(n: int, k: int) -> int:
    s = 0
    while n:
        s += n % k
        n //= k
    return s


-----
def sum_base(n: int, k: int) -> int:
    # Your code here


************************************
Question ID: 1838
def maxFrequency(nums: List[int], k: int) -> int:
    nums.sort()
    n, i, s, max_freq = len(nums), 0, 0, 0

    for j in range(n):
        s += nums[j]
        while s + k < nums[j] * (j - i + 1):
            s -= nums[i]
            i += 1
        max_freq = max(max_freq, j - i + 1)

    return max_freq

-----
def maxFrequency(nums: List[int], k: int) -> int:
    # Your code here


************************************
Question ID: 1839
def decode(encoded, first):
    arr = [first]
    for num in encoded:
        arr.append(arr[-1] ^ num)
    return arr


-----
def decode(encoded, first):
    # Your code here


************************************
Question ID: 1840
from collections import defaultdict

def dfs(node, visited, graph, group):
    if visited[node]:
        return
    visited[node] = 1
    group.append(node)
    for neighbor in graph[node]:
        dfs(neighbor, visited, graph, group)

def minimumHammingDistance(source, target, allowedSwaps):
    n = len(source)
    graph = defaultdict(list)
    for a, b in allowedSwaps:
        graph[a].append(b)
        graph[b].append(a)

    res = 0
    visited = [0] * n
    for i in range(n):
        if not visited[i]:
            group = []
            dfs(i, visited, graph, group)
            count = defaultdict(int)

            for node in group:
                count[source[node]] += 1
            for node in group:
                if count[target[node]] > 0:
                    res += 1
                    count[target[node]] -= 1

    return n - res


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1842
from itertools import permutations

def nextPalindrome(num: str) -> str:
    n = len(num)
    first_half = num[:(n + 1) // 2]
    candidates = sorted(set(int("".join(p)) for p in permutations(first_half)))

    for c in candidates:
        c_str = str(c)
        second_half = c_str[::-1]
        if n % 2 == 1: second_half = second_half[1:]
        candidate_str = c_str + second_half

        if candidate_str > num:
            return candidate_str

    return ""

-----
from itertools import permutations
    # Your code here


************************************
Question ID: 1844
def count_balls(low_limit: int, high_limit: int) -> int:
    box_counts = [0] * 46
    for i in range(low_limit, high_limit + 1):
        box_number = sum(map(int, str(i)))
        box_counts[box_number] += 1
    return max(box_counts)

-----
def count_balls(low_limit: int, high_limit: int) -> int:
    # Your code here


************************************
Question ID: 1845
def largestSubmatrix(matrix):
    m, n = len(matrix), len(matrix[0])
    height = [0] * n
    max_area = 0

    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 1:
                height[j] += 1
            else:
                height[j] = 0
        sorted_height = sorted(height)
        for j in range(n):
            max_area = max(max_area, sorted_height[j] * (n - j))

    return max_area


-----
def largestSubmatrix(matrix):
    # Your code here


************************************
Question ID: 1846
def maximumElementAfterDecrementingAndRearranging(arr: List[int]) -> int:
    arr.sort()
    arr[0] = 1
    for i in range(1, len(arr)):
        arr[i] = min(arr[i], arr[i - 1] + 1)
    return arr[-1]

-----
def maximumElementAfterDecrementingAndRearranging(arr: List[int]) -> int:
    # Your code here


************************************
Question ID: 1847

```javascript
function closestRoom(rooms, queries) {
    rooms.sort((a, b) => b[1] - a[1]);
    
    for (let i = 0; i < queries.length; ++i) {
        queries[i].push(i);
    }
    
    queries.sort((a, b) => b[1] - a[1]);
    
    let result = new Array(queries.length);
    let ids = new Set();
    
    let j = 0;
    for (const q of queries) {
        while (j < rooms.length && rooms[j][1] >= q[1]) {
            ids.add(rooms[j++][0]);
        }
        if (ids.size === 0) {
            result[q[2]] = -1;
        } else {
            let minAbsDiff = Infinity;
            let minId = undefined;
            for (let id = q[0]; id <= 10000000; ++id) {
                if (ids.has(id) && Math.abs(id-q[0]) < minAbsDiff) {
                    minAbsDiff = Math.abs(id - q[0]);
                    minId = id;
                }
                if (ids.has(id-1) && Math.abs(id-1-q[0]) < minAbsDiff) {
                    minAbsDiff = Math.abs(id - 1 - q[0]);
                    minId = id - 1;
                }
                if (minId !== undefined)
                    break;
            }
            result[q[2]] = minId;
        }
    }
    
    return result;
}
```


-----

    # Your code here


************************************
Question ID: 1848
def sum_of_unique_elements(nums):
    elem_count = {}
    for num in nums:
        elem_count[num] = elem_count.get(num, 0) + 1
    sum = 0
    for elem, count in elem_count.items():
        if count == 1:
            sum += elem
    return sum


-----
def sum_of_unique_elements(nums):
    # Your code here


************************************
Question ID: 1849
def maxAbsoluteSum(nums):
    max_sum, min_sum, max_so_far, min_so_far = 0, 0, 0, 0
    for num in nums:
        max_so_far = max(num, max_so_far + num)
        max_sum = max(max_sum, max_so_far)

        min_so_far = min(num, min_so_far + num)
        min_sum = min(min_sum, min_so_far)
    return max(max_sum, abs(min_sum))

-----
def maxAbsoluteSum(nums):
    # Your code here


************************************
Question ID: 1850
def min_length_after_operations(s: str) -> int:
    a_count = s.count('a')
    b_count = s.count('b')
    c_count = s.count('c')

    if a_count % 2 == b_count % 2 and b_count % 2 == c_count % 2:
        return len(s) % 2
    return (len(s) + 1) % 2

-----
def min_length_after_operations(s: str) -> int:
    # Your code here


************************************
Question ID: 1851
from bisect import bisect_left

def maxValue(events, k):
    events.sort(key=lambda x: x[1])
    n = len(events)
    dp = [[0] * (k + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        start = -1
        for j in range(i - 1, 0, -1):
            if events[j - 1][1] < events[i - 1][0]:
                start = j
                break

        for j in range(1, k + 1):
            if start == -1:
                dp[i][j] = max(dp[i - 1][j], events[i - 1][2])
            else:
                dp[i][j] = max(dp[i - 1][j], dp[start][j - 1] + events[i - 1][2])

    return dp[n][k]


-----
from bisect import bisect_left
    # Your code here


************************************
Question ID: 1852
def distinct_numbers_in_subarrays(nums, k):
    counts = {}
    ans = []
    for i, num in enumerate(nums):
        counts[num] = counts.get(num, 0) + 1
        if i >= k:
            counts[nums[i - k]] -= 1
            if counts[nums[i - k]] == 0:
                del counts[nums[i - k]]
        if i >= k - 1:
            ans.append(len(counts))
    return ans

-----
def distinct_numbers_in_subarrays(nums, k):
    # Your code here


************************************
Question ID: 1854
def maxAliveYear(logs):
    years = [0] * 101
    for log in logs:
        years[log[0] - 1950] += 1
        years[log[1] - 1950] -= 1
    max_population = years[0]
    max_year = 1950
    for i in range(1, 101):
        years[i] += years[i - 1]
        if years[i] > max_population:
            max_population = years[i]
            max_year = i + 1950
    return max_year

-----
def maxAliveYear(logs):
    # Your code here


************************************
Question ID: 1855
def maxDistance(nums1, nums2):
    i, j, maxDist = 0, 0, 0
    while i < len(nums1) and j < len(nums2):
        if nums1[i] > nums2[j]:
            i += 1
        else:
            maxDist = max(maxDist, j - i)
            j += 1
    return maxDist

-----
def maxDistance(nums1, nums2):
    # Your code here


************************************
Question ID: 1856
def maxSumMinProduct(nums: list[int]) -> int:
    MOD = int(1e9 + 7)
    max_product = 0
    stk = []
    prefix_sum = [0] * (len(nums) + 1)

    for i in range(len(nums)):
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]

    for i in range(len(nums)):
        while stk and nums[stk[-1]] > nums[i]:
            min_val = nums[stk.pop()]
            max_product = max(max_product, min_val * (prefix_sum[i] - prefix_sum[stk[-1] + 1 if stk else 0]))
        stk.append(i)
       
    while stk:
        min_val = nums[stk.pop()]
        max_product = max(max_product, min_val * (prefix_sum[len(nums)] - prefix_sum[stk[-1] + 1 if stk else 0]))

    return max_product % MOD


-----
def maxSumMinProduct(nums: list[int]) -> int:
    # Your code here


************************************
Question ID: 1857
from collections import deque

def largestPathValue(colors: str, edges: List[List[int]]) -> int:
    n = len(colors)
    adj = [[] for _ in range(n)]
    
    in_degrees = [0] * n
    for e in edges:
        adj[e[0]].append(e[1])
        in_degrees[e[1]] += 1
        
    color_counts = [[0] * 26 for _ in range(n)]
    queue = deque()
    
    for i in range(n):
        if in_degrees[i] == 0:
            queue.append(i)
            
    visited_nodes = 0
    max_color_value = 0
    
    while queue:
        node = queue.pop()
        color = ord(colors[node]) - ord('a')
        visited_nodes += 1
        
        for neighbor in adj[node]:
            for c in range(26):
                count = color_counts[node][c] + (c == color)
                color_counts[neighbor][c] = max(color_counts[neighbor][c], count)
                max_color_value = max(max_color_value, count)
                
            in_degrees[neighbor] -= 1
            if in_degrees[neighbor] == 0:
                queue.append(neighbor)
                
    return max_color_value if visited_nodes == n else -1


-----
from collections import deque
    # Your code here


************************************
Question ID: 1858
def maximum_time(time: str) -> str:
    time = list(time)
    if time[0] == "?":
        time[0] = "2" if time[1] == "?" or int(time[1]) < 4 else "1"
    if time[1] == "?":
        time[1] = "3" if time[0] == "2" else "9"
    if time[3] == "?":
        time[3] = "5"
    if time[4] == "?":
        time[4] = "9"
    return "".join(time)

-----
def maximum_time(time: str) -> str:
    # Your code here


************************************
Question ID: 1859
def min_operations_to_satisfy_conditions(a: str, b: str) -> int:
    same, less, greater = 0, 0, 0

    for i in range(len(a)):
        if a[i] == b[i]:
            same += 1
        elif a[i] < b[i]:
            less += 1
        else:
            greater += 1

    return min(same + max(less, greater), less, greater)

-----
def min_operations_to_satisfy_conditions(a: str, b: str) -> int:
    # Your code here


************************************
Question ID: 1860
import heapq

def kthLargestValue(matrix, k):
    m, n = len(matrix), len(matrix[0])
    prefix_xor = [[0] * (n + 1) for _ in range(m + 1)]
    pq = []

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            prefix_xor[i][j] = matrix[i - 1][j - 1] ^ prefix_xor[i - 1][j] ^ prefix_xor[i][j - 1] ^ prefix_xor[i - 1][j - 1]
            heapq.heappush(pq, prefix_xor[i][j])
            if len(pq) > k:
                heapq.heappop(pq)
    return pq[0]


-----
import heapq
    # Your code here


************************************
Question ID: 1861
def min_boxes_touching_floor(n):
    return (n + 1) // 2

-----
def min_boxes_touching_floor(n):
    # Your code here


************************************
Question ID: 1862
def sum_of_floored_pairs(nums):
    MOD = 10**9 + 7
    n = len(nums)
    max_element = max(nums)
    cnt = [0] * (max_element + 1)
    for num in nums:
        cnt[num] += 1
    for i in range(1, max_element + 1):
        cnt[i] += cnt[i - 1]

    res = 0
    for num in nums:
        j, k = 1, 1
        while k <= max_element:
            res += j * (cnt[min(k + num - 1, max_element)] - cnt[k - 1])
            res %= MOD
            j += 1
            k += num

    return res

-----
def sum_of_floored_pairs(nums):
    # Your code here


************************************
Question ID: 1863
def subsetXORSum(nums):
    ans = 0
    n = len(nums)
    max_val = 1 << n
    for i in range(1, max_val):
        xor_total = 0
        for j in range(n):
            if i & (1 << j):
                xor_total ^= nums[j]
        ans += xor_total
    return ans

-----
def subsetXORSum(nums):
    # Your code here


************************************
Question ID: 1864
def minSwaps(s):
    zeroCount = s.count('0')
    oneCount = len(s) - zeroCount

    if abs(zeroCount - oneCount) > 1:
        return -1

    swaps1 = swaps2 = 0
    for i, c in enumerate(s):
        if i % 2 == 0 and c != '0':
            swaps1 += 1
        if i % 2 == 1 and c != '1':
            swaps1 += 1
    swaps1 = swaps1 // 2

    for i, c in enumerate(s):
        if i % 2 == 0 and c != '1':
            swaps2 += 1
        if i % 2 == 1 and c != '0':
            swaps2 += 1
    swaps2 = swaps2 // 2

    if zeroCount == oneCount:
        return min(swaps1, swaps2)
    return swaps2 if zeroCount > oneCount else swaps1

-----
def minSwaps(s):
    # Your code here


************************************
Question ID: 1865
from collections import defaultdict

class FindSumPairs:
    def __init__(self, nums1: list[int], nums2: list[int]):
        self.nums1 = nums1
        self.nums2 = nums2
        self.nums2_map = defaultdict(int)
        for num in nums2:
            self.nums2_map[num] += 1

    def add(self, index: int, val: int) -> None:
        self.nums2_map[self.nums2[index]] -= 1
        self.nums2[index] += val
        self.nums2_map[self.nums2[index]] += 1

    def count(self, tot: int) -> int:
        return sum(self.nums2_map.get(tot - num, 0) for num in self.nums1)


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1866
from collections import defaultdict

def restoreArray(adjacentPairs):
    graph = defaultdict(list)
    for pair in adjacentPairs:
        graph[pair[0]].append(pair[1])
        graph[pair[1]].append(pair[0])

    n = len(graph)
    nums = [0] * n
    for key, nodes in graph.items():
        if len(nodes) == 1:
            nums[0] = key
            break

    nums[1] = graph[nums[0]][0]
    for i in range(2, n):
        nums[i] = (graph[nums[i - 1]][1]
                   if (nums[i - 2] == graph[nums[i - 1]][0])
                   else graph[nums[i - 1]][0])

    return nums

-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1868
def findRLEProduct(encoded1, encoded2):
    result = []
    i, j, count1, count2 = 0, 0, 0, 0

    while i < len(encoded1) and j < len(encoded2):
        product = encoded1[i][0] * encoded2[j][0]
        count = min(encoded1[i][1] - count1, encoded2[j][1] - count2)
        count1 += count
        count2 += count

        if result and result[-1][0] == product:
            result[-1][1] += count
        else:
            result.append([product, count])

        if count1 == encoded1[i][1]:
            i += 1
            count1 = 0

        if count2 == encoded2[j][1]:
            j += 1
            count2 = 0

    return result

-----
def findRLEProduct(encoded1, encoded2):
    # Your code here


************************************
Question ID: 1869
def checkZeroOnes(s: str) -> bool:
    max_ones, max_zeros, current_ones, current_zeros = 0, 0, 0, 0
    for c in s:
        if c == '1':
            current_ones += 1
            current_zeros = 0
        else:
            current_zeros += 1
            current_ones = 0
        max_ones = max(max_ones, current_ones)
        max_zeros = max(max_zeros, current_zeros)
    return max_ones > max_zeros

-----
def checkZeroOnes(s: str) -> bool:
    # Your code here


************************************
Question ID: 1870
from math import ceil

def minSpeedOnTime(dist, hour):
    max_time = hour - len(dist) + 1
    lower, upper = 1.0, 1e7
    while upper - lower >= 1e-9:
        mid = (lower + upper) / 2
        time_taken = sum(ceil(d / mid) - (0 if i == len(dist) - 1 else 1) for i, d in enumerate(dist))
        if time_taken <= max_time:
            upper = mid
        else:
            lower = mid
    return ceil(lower) if lower <= 1e7 else -1

-----
from math import ceil
    # Your code here


************************************
Question ID: 1871
def is_palindrome(s, l, r):
    while l < r:
        if s[l] != s[r]:
            return False
        l += 1
        r -= 1
    return True

def check_partitioning(s):
    n = len(s)
    for i in range(n - 2):
        if is_palindrome(s, 0, i):
            for j in range(i + 1, n - 1):
                if is_palindrome(s, i + 1, j) and is_palindrome(s, j + 1, n - 1):
                    return True
    return False


-----
def is_palindrome(s, l, r):
    # Your code here


************************************
Question ID: 1872
def can_eat(candiesCount, queries):
    prefix_sum = [0] * (len(candiesCount) + 1)
    for i in range(len(candiesCount)):
        prefix_sum[i + 1] = prefix_sum[i] + candiesCount[i]

    result = [False] * len(queries)
    for i in range(len(queries)):
        favoriteType, favoriteDay, dailyCap = queries[i]
        x1 = favoriteDay + 1
        y1 = (favoriteDay + 1) * dailyCap

        x2 = prefix_sum[favoriteType] + 1
        y2 = prefix_sum[favoriteType + 1]

        result[i] = not (x1 > y2 or y1 < x2)

    return result

-----
def can_eat(candiesCount, queries):
    # Your code here


************************************
Question ID: 1874
def can_choose(groups, nums):
    g_i, n_i = 0, 0
    while g_i < len(groups) and n_i + len(groups[g_i]) <= len(nums):
        if nums[n_i : n_i + len(groups[g_i])] == groups[g_i]:
            n_i += len(groups[g_i])
            g_i += 1
        else:
            n_i += 1
    return g_i == len(groups)

-----
def can_choose(groups, nums):
    # Your code here


************************************
Question ID: 1876
from collections import deque

def highest_island(is_water):
    m, n = len(is_water), len(is_water[0])
    height = [[-1] * n for _ in range(m)]
    q = deque()

    for i in range(m):
        for j in range(n):
            if is_water[i][j] == 1:
                height[i][j] = 0
                q.append((i, j))

    dx = [-1, 0, 1, 0]
    dy = [0, 1, 0, -1]

    while q:
        x, y = q.popleft()

        for i in range(4):
            newX = x + dx[i]
            newY = y + dy[i]

            if 0 <= newX < m and 0 <= newY < n and height[newX][newY] == -1:
                height[newX][newY] = height[x][y] + 1
                q.append((newX, newY))

    return height

-----
from collections import deque
    # Your code here


************************************
Question ID: 1877
def minPairSum(nums):
    nums.sort()
    max_sum = 0
    for i in range(len(nums) // 2):
        max_sum = max(max_sum, nums[i] + nums[-1 - i])
    return max_sum

-----
def minPairSum(nums):
    # Your code here


************************************
Question ID: 1878
def check(nums):
    count = 0
    for i in range(1, len(nums)):
        if nums[i] < nums[i - 1]:
            count += 1
        if count > 1:
            return False
    return count == 1 or nums[0] >= nums[-1]

-----
def check(nums):
    # Your code here


************************************
Question ID: 1879
def max_score(a: int, b: int, c: int) -> int:
    return (a + b + c - max(a, b, c)) // 2


-----
def max_score(a: int, b: int, c: int) -> int:
    # Your code here


************************************
Question ID: 1880
def largest_merge(word1: str, word2: str) -> str:
    merge = []
    while word1 or word2:
        if word1 > word2:
            merge.append(word1[0])
            word1 = word1[1:]
        else:
            merge.append(word2[0])
            word2 = word2[1:]
    return ''.join(merge)

-----
def largest_merge(word1: str, word2: str) -> str:
    # Your code here


************************************
Question ID: 1881
from itertools import combinations

def minAbsDifference(nums, goal):
    n = len(nums)
    left = nums[:n//2]
    right = nums[n//2:]

    sums_left = set()

    for i in range(len(left) + 1):
        for comb in combinations(left, i):
            sums_left.add(sum(comb))

    ans = abs(goal)

    for i in range(len(right) + 1):
        for comb in combinations(right, i):
            sum_r = sum(comb)
            sum_goal = goal - sum_r
            sum_l = min(sums_left, key=lambda x: abs(x - sum_goal))

            ans = min(ans, abs(sum_l + sum_r - goal))

    return ans

-----
from itertools import combinations
    # Your code here


************************************
Question ID: 1882
import heapq
from typing import List

def assignTasks(servers: List[int], tasks: List[int]) -> List[int]:
    free_servers = [(servers[i], i) for i in range(len(servers))]
    heapq.heapify(free_servers)
    busy_servers = []
    result = [0] * len(tasks)

    for time in range(len(tasks)):
        while busy_servers and busy_servers[0][0] <= time:
            _, server_elem = heapq.heappop(busy_servers)
            heapq.heappush(free_servers, server_elem)
        
        if free_servers:
            server_elem = heapq.heappop(free_servers)
            result[time] = server_elem[1]
            heapq.heappush(busy_servers, (time + tasks[time], server_elem))

    return result


-----
import heapq
    # Your code here


************************************
Question ID: 1883
def minSkips(dist, speed, hoursBefore):
    n = len(dist)
    dp = [[1e9] * (n + 1) for _ in range(n + 1)]
    dp[0][0] = 0

    for i in range(n):
        for j in range(i+1):
            t = dist[i] / speed + (1 if j else 0)
            dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j] + t)
            skipped_t = -(-dist[i] / speed) - dp[i][j]
            dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + skipped_t)

    for i in range(n + 1):
        if dp[n][i] <= hoursBefore:
            return i
    return -1

-----
def minSkips(dist, speed, hoursBefore):
    # Your code here


************************************
Question ID: 1884
def min_operations_to_alternate(s: str) -> int:
    count_a, count_b = 0, 0
    for i, c in enumerate(s):
        if i % 2 == 0:
            if c == '0':
                count_a += 1
            else:
                count_b += 1
        else:
            if c == '0':
                count_b += 1
            else:
                count_a += 1
    return min(count_a, count_b)

-----
def min_operations_to_alternate(s: str) -> int:
    # Your code here


************************************
Question ID: 1885
def count_homogenous(s: str) -> int:
    res, count, mod = 0, 1, 10**9 + 7
    for i in range(1, len(s)):
        count = count + 1 if s[i] == s[i - 1] else 1
        res = (res + count) % mod
    return res

-----
def count_homogenous(s: str) -> int:
    # Your code here


************************************
Question ID: 1886
import heapq

def minimumSize(nums, maxOperations):
    pq = [-num for num in nums] # Negative numbers to simulate max heap
    heapq.heapify(pq)
    while maxOperations > 0:
        maxBalls = -heapq.heappop(pq)
        heapq.heappush(pq, -maxBalls // 2)
        heapq.heappush(pq, -(maxBalls - (maxBalls // 2)))
        maxOperations -= 1
    return -pq[0]

-----
import heapq
    # Your code here


************************************
Question ID: 1887
from collections import defaultdict

def min_trio_degree(n, edges):
    graph = defaultdict(dict)
    degree = [0] * (n + 1)

    for u, v in edges:
        graph[u][v] = graph[v][u] = True
        degree[u] += 1
        degree[v] += 1

    min_degree = float('inf')
    for u, v in edges:
        for w in range(1, n + 1):
            if graph[u].get(w) and graph[v].get(w):
                min_degree = min(min_degree, degree[u] + degree[v] + degree[w] - 6)

    return min_degree if min_degree != float('inf') else -1


-----
from collections import defaultdict
    # Your code here


************************************
Question ID: 1888
def nearestValidPoint(x, y, points):
    min_distance = float('inf')
    min_index = -1

    for i, point in enumerate(points):
        if x == point[0] or y == point[1]:
            distance = abs(x - point[0]) + abs(y - point[1])
            if distance < min_distance:
                min_distance = distance
                min_index = i

    return min_index

-----
def nearestValidPoint(x, y, points):
    # Your code here


************************************
Question ID: 1889
def check_powers_of_three(n: int) -> bool:
    while n > 0:
        if n % 3 == 2:
            return False
        n //= 3
    return True

-----
def check_powers_of_three(n: int) -> bool:
    # Your code here


************************************
Question ID: 1893
def isCovered(ranges: List[List[int]], left: int, right: int) -> bool:
    for i in range(left, right + 1):
        found = False
        for _range in ranges:
            if _range[0] <= i <= _range[1]:
                found = True
                break
        if not found:
            return False
    return True

-----
def isCovered(ranges: List[List[int]], left: int, right: int) -> bool:
    # Your code here


************************************
Question ID: 1894
def merge_alternately(word1, word2):
    merged = []
    i, j = 0, 0
    while i < len(word1) or j < len(word2):
        if i < len(word1):
            merged.append(word1[i])
            i += 1
        if j < len(word2):
            merged.append(word2[j])
            j += 1
    return "".join(merged)

-----
def merge_alternately(word1, word2):
    # Your code here


************************************
Question ID: 1895
def min_operations(boxes: str):
    result = [0] * len(boxes)
    count, total = 0, 0

    for i in range(len(boxes)):
        total += count
        result[i] = total
        if boxes[i] == '1':
            count += 1

    count, total = 0, 0
    for i in range(len(boxes) - 1, -1, -1):
        total += count
        result[i] += total
        if boxes[i] == '1':
            count += 1

    return result

-----
def min_operations(boxes: str):
    # Your code here


************************************
Question ID: 1896
def maximumScore(nums, multipliers):
    n, m = len(nums), len(multipliers)
    dp = [[0] * (m + 1) for _ in range(m + 1)]
    maxScore = float('-inf')

    for i in range(m + 1):
        for j in range(m - i + 1):
            if i == 0 and j == 0:
                continue
            score = 0
            if i == 0:
                score = dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1]
            elif j == 0:
                score = dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1]
            else:
                score = max(dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1],
                            dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1])
            dp[i][j] = score
            if i + j == m:
                maxScore = max(maxScore, score)

    return maxScore

-----
def maximumScore(nums, multipliers):
    # Your code here


************************************
Question ID: 1897
def longestPalindromeSubseq(word1, word2):
    n, m = len(word1), len(word2)
    dp = [[0] * (m + 1) for _ in range(n + 1)]

    for i in range(n):
        for j in range(m):
            if word1[i] == word2[j]:
                dp[i + 1][j + 1] = dp[i][j] + 1
            else:
                dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j])

    return dp[n][m]

-----
def longestPalindromeSubseq(word1, word2):
    # Your code here


************************************
Question ID: 1898
def maximumRemovals(s: str, p: str, removable: List[int]) -> int:
    low, high = 0, len(removable)
    while low < high:
        mid = (low + high + 1) // 2
        temp_s = list(s)
        for i in range(mid):
            temp_s[removable[i]] = '-'
        i, j = 0, 0
        while i < len(temp_s) and j < len(p):
            if temp_s[i] == p[j]:
                j += 1
            i += 1
        if j == len(p):
            low = mid
        else:
            high = mid - 1
    return low


-----
def maximumRemovals(s: str, p: str, removable: List[int]) -> int:
    # Your code here


************************************
Question ID: 1899
def count_matches(items, rule_key, rule_value):
    rule = {"type": 0, "color": 1, "name": 2}
    count = 0

    for item in items:
        if item[rule[rule_key]] == rule_value:
            count += 1

    return count

-----
def count_matches(items, rule_key, rule_value):
    # Your code here


************************************
Question ID: 1900
def closest_cost(base_costs, topping_costs, target):
    closest = base_costs[0]
    
    for base in base_costs:
        cost = base
        
        for i in range(1 << (len(topping_costs) * 2)):
            bit_mask = i
            
            for j, topping_cost in enumerate(topping_costs):
                cost += (bit_mask & 3) * topping_cost
                bit_mask >>= 2
                
            if abs(target - cost) < abs(target - closest):
                closest = cost
            elif abs(target - cost) == abs(target - closest) and cost < closest:
                closest = cost
                
            cost = base
            
    return closest


-----
def closest_cost(base_costs, topping_costs, target):
    # Your code here


************************************
Question ID: 1901
def min_operations(nums1, nums2):
    sum1, sum2 = sum(nums1), sum(nums2)
    if sum1 == sum2: return 0
    if sum1 < sum2: nums1, nums2 = nums2, nums1
    nums1.sort(reverse=True)
    nums2.sort()
    diff, operations, i, j = abs(sum1 - sum2), 0, 0, 0
    while diff > 0 and (i < len(nums1) or j < len(nums2)):
        option1 = nums1[i] - 1 if i < len(nums1) else 0
        option2 = 6 - nums2[j] if j < len(nums2) else 0
        if option1 > option2:
            diff -= option1
            i += 1
        else:
            diff -= option2
            j += 1
        operations += 1
    return operations if diff == 0 else -1


-----
def min_operations(nums1, nums2):
    # Your code here


************************************
Question ID: 1902
def get_collision_times(cars):
    n = len(cars)
    collisions = [-1] * n
    for i in range(n-1, -1, -1):
        time_to_collision = 1e9
        for j in range(i+1, n):
            if cars[j][1] > cars[i][1]:
                continue
            current_collision = (cars[j][0] - cars[i][0]) / (cars[i][1] - cars[j][1])
            if current_collision < time_to_collision:
                time_to_collision = min(time_to_collision, min(collisions[j], current_collision))
        collisions[i] = -1.0 if time_to_collision == 1e9 else time_to_collision
    return collisions

-----
def get_collision_times(cars):
    # Your code here


************************************
Question ID: 1903
def largest_odd_number(num: str) -> str:
    for i in range(len(num) - 1, -1, -1):
        if int(num[i]) % 2 != 0:
            return num[:i + 1]
    return ""

-----
def largest_odd_number(num: str) -> str:
    # Your code here


************************************
Question ID: 1904
def second_largest_digit(s: str) -> int:
    largest = -1
    second_largest = -1
    for c in s:
        if c.isdigit():
            digit = int(c)
            if digit > largest:
                second_largest = largest
                largest = digit
            elif digit != largest and digit > second_largest:
                second_largest = digit
    return second_largest

-----
def second_largest_digit(s: str) -> int:
    # Your code here


************************************
Question ID: 1906
from functools import lru_cache
from math import gcd

def maxScore(nums):
    n = len(nums)

    @lru_cache(None)
    def dfs(i, j):
        if i > n:
            return 0
        ans = 0
        for k in range(j + 1, n * 2):
            ans = max(ans, dfs(i + 1, k) + i * gcd(nums[j], nums[k]))
        return ans

    return dfs(1, 0)

-----
from functools import lru_cache
    # Your code here


************************************
Question ID: 1908
def alice_wins(piles):
    xor_sum = 0
    for pile in piles:
        xor_sum ^= pile
    return xor_sum != 0


-----
def alice_wins(piles):
    # Your code here


************************************
Question ID: 1909
def canBeIncreasing(nums):
    count = 0
    for i in range(1, len(nums)):
        if nums[i - 1] >= nums[i]:
            count += 1
            if count > 1: return False
            if i > 1 and nums[i - 2] >= nums[i] and i < len(nums) - 1 and nums[i - 1] >= nums[i + 1]: return False
    return True

-----
def canBeIncreasing(nums):
    # Your code here


************************************
Question ID: 1910
def check_ones_segment(s: str) -> bool:
    count = 0
    for i in range(len(s)):
        if s[i] == '1':
            if i > 0 and s[i - 1] == '0':
                count += 1
    return count <= 1

-----
def check_ones_segment(s: str) -> bool:
    # Your code here


************************************
Question ID: 1911
def min_elements(nums, limit, goal):
    total_sum = sum(nums)
    diff = abs(goal - total_sum)
    return (diff + limit - 1) // limit


-----
def min_elements(nums, limit, goal):
    # Your code here


************************************
Question ID: 1912
from heapq import heappush, heappop
from collections import defaultdict
from functools import lru_cache

mod = 10**9 + 7

def countRestrictedPaths(n, edges):
    graph = defaultdict(list)
    for u, v, w in edges:
        graph[u].append((v, w))
        graph[v].append((u, w))

    dist = [float('inf')] * (n + 1)
    dist[n] = 0
    pq = [(0, n)] # (distance, node)
    
    while pq:
        d, u = heappop(pq)
        if d != dist[u]:
            continue
        for v, w in graph[u]:
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
                heappush(pq, (dist[v], v))

    @lru_cache(None)
    def dfs(u):
        if u == n:
            return 1
        ans = 0
        for v, _ in graph[u]:
            if dist[v] < dist[u]:
                ans = (ans + dfs(v)) % mod
        return ans

    return dfs(1)

-----
from heapq import heappush, heappop
    # Your code here


************************************
Question ID: 1913
def min_changes(nums, k):
    n = len(nums)
    xor_prefix = [0] * (n + 1)
    for i in range(1, n + 1):
        xor_prefix[i] = xor_prefix[i - 1] ^ nums[i - 1]

    dp = [{} for _ in range(k)]
    min_dp = [n] * k

    for i in range(1, n + 1):
        x = xor_prefix[i] ^ xor_prefix[i - k]

        if i >= k:
            dp[0][x] = dp[0].get(x, 0) + 1

        for j in range(1, 1 + (i - j * k) // k):
            if x in dp[j - 1]:
                dp[j][x] = dp[j].get(x, 0) + 1
                min_dp[j] = min(min_dp[j], dp[j - 1][x] - dp[j][x])

    return min(n, [min_dp[j] + j for j in range(k)])

-----
def min_changes(nums, k):
    # Your code here


************************************
Question ID: 1914
def rotateGrid(grid, k):
    if not grid: return grid
    
    m, n = len(grid), len(grid[0])
    numLayers = min(m, n) // 2

    for layer in range(numLayers):
        numToRotate = (m - 2 * layer) * 2 + (n - 2 * layer - 2) * 2
        effective_k = k % numToRotate

        while effective_k:
            temp = grid[layer][layer]
            for i in range(layer + 1, m - layer): temp, grid[i][layer] = grid[i][layer], temp
            for j in range(layer + 1, n - layer): temp, grid[m - layer - 1][j] = grid[m - layer - 1][j], temp
            for i in range(m - layer - 2, layer - 1, -1): temp, grid[i][n - layer - 1] = grid[i][n - layer - 1], temp
            for j in range(n - layer - 2, layer, -1): temp, grid[layer][j] = grid[layer][j], temp
            effective_k -= 1

    return grid

-----
def rotateGrid(grid, k):
    # Your code here


************************************
Question ID: 1915
def are_almost_equal(s1, s2):
    diff_count = 0
    first_diff = -1
    second_diff = -1
    for i in range(len(s1)):
        if s1[i] != s2[i]:
            diff_count += 1
            if diff_count == 1:
                first_diff = i
            elif diff_count == 2:
                second_diff = i
            else:
                return False
    return diff_count == 0 or (diff_count == 2 and s1[first_diff] == s2[second_diff] and s1[second_diff] == s2[first_diff])


-----
def are_almost_equal(s1, s2):
    # Your code here


************************************
Question ID: 1916
def findCenter(edges):
    if edges[0][0] == edges[1][0] or edges[0][0] == edges[1][1]:
        return edges[0][0]
    return edges[0][1]

-----
def findCenter(edges):
    # Your code here


************************************
Question ID: 1918
def maxScore(nums: List[int], k: int) -> int:
    n = len(nums)
    result = 0
    for i in range(k, -1, -1):
        for j in range(k, n):
            min_val = min(nums[i:j+1])
            result = max(result, min_val * (j - i + 1))
    return result

-----
def maxScore(nums: List[int], k: int) -> int:
    # Your code here


************************************
Question ID: 1920
def square_is_white(coordinates: str) -> bool:
    return (ord(coordinates[0]) - ord('a') + ord(coordinates[1]) - ord('1')) % 2 == 0

-----
def square_is_white(coordinates: str) -> bool:
    # Your code here


************************************
Question ID: 1921
def eliminate_maximum(dist, speed):
    n = len(dist)
    time_to_reach_city = [(dist[i] + speed[i] - 1) // speed[i] for i in range(n)]
    time_to_reach_city.sort()
    eliminated = 0
    for i in range(n):
        if time_to_reach_city[i] > i:
            eliminated += 1
        else:
            break
    return eliminated

-----
def eliminate_maximum(dist, speed):
    # Your code here


************************************
Question ID: 1922
def goodDigitStrings(n: int) -> int:
    MOD = 1000000007
    even_count, prime_count = 1, 1
    for i in range(n):
        if i % 2 == 0:
            even_count = (even_count * 5) % MOD
        else:
            prime_count = (prime_count * 4) % MOD
    return (even_count * prime_count) % MOD

-----
def goodDigitStrings(n: int) -> int:
    # Your code here


************************************
Question ID: 1923
def are_sentences_similar(sentence1, sentence2):
    words1 = sentence1.split()
    words2 = sentence2.split()

    while words1 and words2 and words1[0] == words2[0]:
        words1.pop(0)
        words2.pop(0)
    
    while words1 and words2 and words1[-1] == words2[-1]:
        words1.pop()
        words2.pop()

    return not words1 or not words2

-----
def are_sentences_similar(sentence1, sentence2):
    # Your code here


************************************
Question ID: 1924
def max_happy_groups(batchSize, groups):
    remainders = [0] * batchSize
    for g in groups:
        remainders[g % batchSize] += 1

    result = remainders[0]
    i, j = 1, batchSize - 1

    while i < j:
        result += min(remainders[i], remainders[j])
        i += 1
        j -= 1

    if i == j:
        result += remainders[i] // 2

    return result

-----
def max_happy_groups(batchSize, groups):
    # Your code here


************************************
Question ID: 1925
def reverse(x):
    rev = 0

    while x != 0:
        rev = rev * 10 + x % 10
        x = x // 10

    return rev

def count_nice_pairs(nums):
    MOD = 1_000_000_007
    count = {}
    result = 0

    for num in nums:
        diff = num - reverse(num)
        count[diff] = count.get(diff, 0) + 1

    for val in count.values():
        result = (result + ((val * (val - 1)) // 2) % MOD) % MOD

    return result

-----
def reverse(x):
    # Your code here


************************************
Question ID: 1926
from collections import deque

def nearest_exit(maze, entrance):
    m, n = len(maze), len(maze[0])
    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    q = deque([tuple(entrance)])
    
    steps = -1
    while q:
        steps += 1
        for _ in range(len(q)):
            r, c = q.popleft()
            if maze[r][c] == '+': continue
            if r == 0 or r == m-1 or c == 0 or c == n-1:
                if r != entrance[0] or c != entrance[1]: return steps
            maze[r][c] = '+'
            for dr, dc in moves:
                nr, nc = r + dr, c + dc
                if 0 <= nr < m and 0 <= nc < n:
                    q.append((nr, nc))
    return -1

-----
from collections import deque
    # Your code here


************************************
Question ID: 1927
def max_ascending_sum(nums):
    max_sum = current_sum = nums[0]

    for i in range(1, len(nums)):
        if nums[i] > nums[i - 1]:
            current_sum += nums[i]
        else:
            max_sum = max(max_sum, current_sum)
            current_sum = nums[i]

    return max(max_sum, current_sum)

-----
def max_ascending_sum(nums):
    # Your code here


************************************
Question ID: 1928
from heapq import heappush, heappop

def getNumberOfBacklogOrders(orders):
    buy, sell = [], []

    for price, amount, orderType in orders:
        if orderType == 0:
            while amount > 0 and sell and -sell[0][0] <= price:
                executedAmount = min(amount, sell[0][1])
                amount -= executedAmount
                sell[0] = [-sell[0][0], sell[0][1] - executedAmount]
                if sell[0][1] == 0:
                    heappop(sell)
            if amount:
                heappush(buy, [-price, amount])
        else:
            while amount > 0 and buy and buy[0][0] >= price:
                executedAmount = min(amount, buy[0][1])
                amount -= executedAmount
                buy[0] = [buy[0][0], buy[0][1] - executedAmount]
                if buy[0][1] == 0:
                    heappop(buy)
            if amount:
                heappush(sell, [-price, amount])

    res = sum(item[1] for item in buy) + sum(item[1] for item in sell)
    return res % 1000000007


-----
from heapq import heappush, heappop
    # Your code here


************************************
Question ID: 1929
def maxValue(n, index, maxSum):
    maxSum -= n
    left, right, ans = 0, maxSum, 0
    while left <= right:
        mid = left + (right - left) // 2
        sum = min(mid, index) * (min(mid, index) + 1) // 2 + min(mid, n - index - 1) * (min(mid, n - index) + 1) // 2
        if mid > index:
            sum += (mid - index - 1) * (mid - index) // 2
        if mid > n - index:
            sum += (mid - n + index) * (mid - n + index + 1) // 2
        if sum <= maxSum:
            ans = mid
            left = mid + 1
        else:
            right = mid - 1
    return ans + 1

-----
def maxValue(n, index, maxSum):
    # Your code here


************************************
Question ID: 1930
def max_consecutive_values(coins):
    coins.sort()
    max_value = 0    
    for coin in coins:
        if coin <= max_value + 1:
            max_value += coin
        else:
            break
    return max_value + 1

-----
def max_consecutive_values(coins):
    # Your code here


************************************
Question ID: 1931
def numOfWays(m, n):
    mod = 1000000007
    a, b, c, d = 6, 6, 3, 3
    while n > 1:
        n -= 1
        temp_a = a
        temp_c = c
        a = (a * 3 + b * 2) % mod
        b = (temp_a * 2 + b * 2) % mod
        c = (c * 3 + d * 2) % mod
        d = (temp_c * 2 + d * 2) % mod
    return b if m == 1 else (a + c) % mod

-----
def numOfWays(m, n):
    # Your code here


************************************
Question ID: 1933
def num_different_integers(word):
    for c in word:
        if not c.isdigit():
            word = word.replace(c, ' ')
    nums = word.split()
    unique_nums = set()
    for num in nums:
        num = num.lstrip('0') or '0'
        unique_nums.add(num)
    return len(unique_nums)

-----
def num_different_integers(word):
    # Your code here


************************************
Question ID: 1935
def min_operations(n):
    count = 1
    temp = 1

    while temp % n != 0:
        temp = (temp * 2) % n
        count += 1

    return count

-----
def min_operations(n):
    # Your code here


************************************
Question ID: 1936
def numberOfNiceDivisors(primeFactors):
    MOD = 1000000007
    result = 1
    p = 2
    while p <= primeFactors:
        if primeFactors % p == 0:
            count = 0
            while primeFactors % p == 0:
                primeFactors //= p
                count += 1
            result = (result * (count * 2 + 1)) % MOD
        p += 1
    return result

-----
def numberOfNiceDivisors(primeFactors):
    # Your code here


************************************
Question ID: 1937
def maxPoints(points):
    m, n = len(points), len(points[0])
    dp = [0] * n
    for row in points:
        next_dp = [0] * n
        for c1 in range(n):
            score = dp[c1] + row[c1] - c1
            for c2 in range(n):
                next_dp[c2] = max(next_dp[c2], score - row[c1] + c2)
        dp = next_dp
    return max(dp)

-----
def maxPoints(points):
    # Your code here


************************************
Question ID: 1938
def min_operations(nums):
    operations = 0
    for i in range(1, len(nums)):
        if nums[i] <= nums[i - 1]:
            operations += nums[i - 1] - nums[i] + 1
            nums[i] = nums[i - 1] + 1
    return operations

-----
def min_operations(nums):
    # Your code here


************************************
Question ID: 1942
from sortedcontainers import SortedDict
from sortedcontainers import SortedSet

def smallestChair(times, targetFriend):
    events = SortedDict()
    for i, (arrival, leaving) in enumerate(times):
        events[arrival] = i
        events[leaving] = ~i

    availableChairs = SortedSet(range(len(times)))
    assignedChair = [0] * len(times)

    for time, idx in events.items():
        if idx >= 0:
            chair = availableChairs.pop(0)
            assignedChair[idx] = chair
            if idx == targetFriend:
                return chair
        else:
            availableChairs.add(assignedChair[~idx])

    return -1

-----
from sortedcontainers import SortedDict
    # Your code here


************************************
